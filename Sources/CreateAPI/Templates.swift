// The MIT License (MIT)
//
// Copyright (c) 2021 Alexander Grebenyuk (github.com/kean).

import OpenAPIKit30
import Foundation

final class Templates {
    let options: GenerateOptions
    
    var access: String { options.access.map { "\($0) " } ?? "" }
    
    init(options: GenerateOptions) {
        self.options = options
    }

    var fileHeader: String {
        if let header = options.fileHeader.header {
            return header
        }
        
        var output = """
        // Generated by Create API
        // https://github.com/kean/CreateAPI
        """
        
        if options.fileHeader.addSwiftLintDisabled {
            output += "\n"
            output += """
            //
            // swiftlint:disable all
            """
        }

        output += "\n\nimport Foundation"
        
        return output
    }
    
    /// Generates an entity declaration:
    ///
    ///     public struct <name>: Decodable {
    ///         <contents>
    ///     }
    func entity(name: TypeName, contents: [String]) -> String {
        let isStruct = (options.schemes.isGeneratingStructs && !options.schemes.entitiesGeneratedAsClasses.contains(name.rawValue)) || (options.schemes.entitiesGeneratedAsStructs.contains(name.rawValue))
        let lhs = [options.access, (isStruct ? "struct" : "final class"), name.rawValue]
            .compactMap { $0 }.joined(separator: " ")
        let rhs = ([isStruct ? nil : options.schemes.baseClass] + options.schemes.adoptedProtocols)
            .compactMap { $0 }.joined(separator: ", ")

        return """
        \(lhs): \(rhs) {
        \(contents.joined(separator: "\n\n").shiftedRight(count: 4))
        }
        """
    }
    
    func decode(properties: [GenerateSchemas.Property]) -> String {
        properties.map(decode).joined(separator: "\n")
    }
    
    /// Generates a decode statement.
    ///
    ///     self.id = values.decode(Int.self, forKey: "id")
    func decode(property: GenerateSchemas.Property) -> String {
        let decode = property.isOptional ? "decodeIfPresent" : "decode"
        return "self.\(property.name.accessor) = try values.\(decode)(\(property.type).self, forKey: \"\(property.key)\")"
    }
    
    /// Generated decoding of the directly inlined nested object.
    ///
    ///     self.animal = try Animal(from: decoder)
    func decodeFromDecoder(property: GenerateSchemas.Property) -> String {
        "self.\(property.name.accessor) = try \(property.type)(from: decoder)"
    }

    func initFromDecoder(properties: [GenerateSchemas.Property]) -> String {
        initFromDecoder(contents: decode(properties: properties))
    }
    
    func initFromDecoder(contents: String) -> String {
        """
        \(access)init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
        \(contents.shiftedRight(count: 4))
        }
        """
    }
    
    /// Generates a list of properties.
    func properties(_ properties: [GenerateSchemas.Property]) -> String {
        properties.map(property).joined(separator: "\n")
    }
    
    /// Generates a property with comments and everything.
    ///
    ///     public var files: [Files]?
    func property(_ property: GenerateSchemas.Property) -> String {
        var output = ""
        if let context = property.context {
            output += comments(for: context)
        }
        output += "\(access)var \(property.name): \(property.type)\(property.isOptional ? "?" : "")"
        return output
    }
    
    /// Generates inline comments for a declaration containing a title, description, and examples.
    func comments(for context: JSONSchemaContext) -> String {
        let options = options.comments
        guard options.isEnabled else {
            return ""
        }
        var output = ""
        if options.addTitle, let title = context.title, !title.isEmpty {
            let title = options.capitilizeTitle ? title.capitalizingFirstLetter() : title
            output += "/// \(title)\n"
        }
        if options.addDescription, let description = context.description, !description.isEmpty, description != context.title {
            if !output.isEmpty {
                output += "///\n"
            }
            let description = options.capitilizeDescription ? description.capitalizingFirstLetter() : description
            for line in description.split(separator: "\n") {
                output += "/// \(line)\n"
            }
        }
        if options.addExamples, let example = context.example?.value {
            let value: String
            func format(dictionary: [String: Any]) -> String {
                let values = dictionary.keys.sorted().map { "  \"\($0)\": \"\(dictionary[$0]!)\"" }
                return "{\n\(values.joined(separator: ",\n"))\n}"
            }
            
            if JSONSerialization.isValidJSONObject(example) {
                let data = try? JSONSerialization.data(withJSONObject: example, options: [.prettyPrinted, .sortedKeys])
                value = String(data: data ?? Data(), encoding: .utf8) ?? ""
            } else {
                value = "\(example)"
            }
            if value.count > 1 { // Only display if it's something substantial
                if !output.isEmpty {
                    output += "///\n"
                }
                let lines = value.split(separator: "\n")
                if lines.count == 1 {
                    output += "/// Example: \(value)\n"
                } else {
                    output += "/// Example:\n\n"
                    for line in lines {
                        output += "/// \(line)\n"
                    }
                }
            }
        }
        return output
    }
}
