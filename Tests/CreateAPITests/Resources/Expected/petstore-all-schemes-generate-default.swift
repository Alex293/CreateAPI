// Auto-generated by [Create API](https://github.com/kean/CreateAPI).

// swiftlint:disable all

import Foundation

public struct Order: Decodable {
    public var complete: Bool?
    public var id: Int?
    public var petId: Int?
    public var quantity: Int?
    public var shipDate: Date?
    /// Order Status
    public var status: String?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.complete = try values.decodeIfPresent(Bool.self, forKey: "complete")
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.petId = try values.decodeIfPresent(Int.self, forKey: "petId")
        self.quantity = try values.decodeIfPresent(Int.self, forKey: "quantity")
        self.shipDate = try values.decodeIfPresent(Date.self, forKey: "shipDate")
        self.status = try values.decodeIfPresent(String.self, forKey: "status")
    }
}

public struct Category: Decodable {
    public var id: Int?
    public var name: String?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
    }
}

public struct User: Decodable {
    public var email: String?
    public var firstName: String?
    public var id: Int?
    public var lastName: String?
    public var password: String?
    public var phone: String?
    /// User Status
    public var userStatus: Int?
    public var username: String?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.email = try values.decodeIfPresent(String.self, forKey: "email")
        self.firstName = try values.decodeIfPresent(String.self, forKey: "firstName")
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.lastName = try values.decodeIfPresent(String.self, forKey: "lastName")
        self.password = try values.decodeIfPresent(String.self, forKey: "password")
        self.phone = try values.decodeIfPresent(String.self, forKey: "phone")
        self.userStatus = try values.decodeIfPresent(Int.self, forKey: "userStatus")
        self.username = try values.decodeIfPresent(String.self, forKey: "username")
    }
}

public struct Tag: Decodable {
    public var id: Int?
    public var name: String?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
    }
}

public struct Pet: Decodable {
    public var category: Category?
    public var id: Int?
    /// Example: doggie
    public var name: String
    public var photoUrls: [String]
    /// pet status in the store
    public var status: String?
    public var tags: [Tag]?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.category = try values.decodeIfPresent(Category.self, forKey: "category")
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.name = try values.decode(String.self, forKey: "name")
        self.photoUrls = try values.decode([String].self, forKey: "photoUrls")
        self.status = try values.decodeIfPresent(String.self, forKey: "status")
        self.tags = try values.decodeIfPresent([Tag].self, forKey: "tags")
    }
}

public struct ApiResponse: Decodable {
    public var code: Int?
    public var message: String?
    public var type: String?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.code = try values.decodeIfPresent(Int.self, forKey: "code")
        self.message = try values.decodeIfPresent(String.self, forKey: "message")
        self.type = try values.decodeIfPresent(String.self, forKey: "type")
    }
}

/// Model for testing reserved words
public struct Return: Decodable {
    public var `return`: Int?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.`return` = try values.decodeIfPresent(Int.self, forKey: "return")
    }
}

/// Model for testing model name same as property name
public struct Name: Decodable {
    public var 123Number: Int?
    public var name: Int
    public var property: String?
    public var snakeCase: Int?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.123Number = try values.decodeIfPresent(Int.self, forKey: "123Number")
        self.name = try values.decode(Int.self, forKey: "name")
        self.property = try values.decodeIfPresent(String.self, forKey: "property")
        self.snakeCase = try values.decodeIfPresent(Int.self, forKey: "snake_case")
    }
}

/// Model for testing model name starting with number
public struct 200Response: Decodable {
    public var `class`: String?
    public var name: Int?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.`class` = try values.decodeIfPresent(String.self, forKey: "class")
        self.name = try values.decodeIfPresent(Int.self, forKey: "name")
    }
}

/// Model for testing model with "_class" property
public struct ClassModel: Decodable {
    public var `class`: String?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.`class` = try values.decodeIfPresent(String.self, forKey: "_class")
    }
}

public struct Dog: Decodable {
    public var animal: Animal?
    public var object: Object?

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        self.animal = try? container.decode(Animal.self)
        self.object = try? container.decode(Object.self)
    }

    public struct Object: Decodable {
        public var breed: String?

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.breed = try values.decodeIfPresent(String.self, forKey: "breed")
        }
    }
}

public struct Cat: Decodable {
    public var animal: Animal?
    public var object: Object?

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        self.animal = try? container.decode(Animal.self)
        self.object = try? container.decode(Object.self)
    }

    public struct Object: Decodable {
        public var declawed: Bool?

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.declawed = try values.decodeIfPresent(Bool.self, forKey: "declawed")
        }
    }
}

public struct Animal: Decodable {
    public var className: String
    public var color: String?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.className = try values.decode(String.self, forKey: "className")
        self.color = try values.decodeIfPresent(String.self, forKey: "color")
    }
}

public typealias AnimalFarm = Animal

public struct FormatTest: Decodable {
    public var binary: String?
    public var byte: String
    public var date: String
    public var dateTime: Date?
    public var double: Double?
    public var float: Double?
    public var int32: Int?
    public var int64: Int?
    public var integer: Int?
    public var number: Double
    public var password: String
    public var string: String?
    public var uuid: String?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.binary = try values.decodeIfPresent(String.self, forKey: "binary")
        self.byte = try values.decode(String.self, forKey: "byte")
        self.date = try values.decode(String.self, forKey: "date")
        self.dateTime = try values.decodeIfPresent(Date.self, forKey: "dateTime")
        self.double = try values.decodeIfPresent(Double.self, forKey: "double")
        self.float = try values.decodeIfPresent(Double.self, forKey: "float")
        self.int32 = try values.decodeIfPresent(Int.self, forKey: "int32")
        self.int64 = try values.decodeIfPresent(Int.self, forKey: "int64")
        self.integer = try values.decodeIfPresent(Int.self, forKey: "integer")
        self.number = try values.decode(Double.self, forKey: "number")
        self.password = try values.decode(String.self, forKey: "password")
        self.string = try values.decodeIfPresent(String.self, forKey: "string")
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }
}

public enum EnumClass: String, Codable, CaseIterable {
    case abc = "_abc"
    case minusefg = "-efg"
    case xyz = "(xyz)"
}

public struct EnumTest: Decodable {
    public var enumInteger: Int?
    public var enumNumber: Double?
    public var enumString: String?
    public var outerEnum: OuterEnum?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.enumInteger = try values.decodeIfPresent(Int.self, forKey: "enum_integer")
        self.enumNumber = try values.decodeIfPresent(Double.self, forKey: "enum_number")
        self.enumString = try values.decodeIfPresent(String.self, forKey: "enum_string")
        self.outerEnum = try values.decodeIfPresent(OuterEnum.self, forKey: "outerEnum")
    }
}

public struct AdditionalPropertiesClass: Decodable {
    public var mapOfMapProperty: [String: MapOfMapPropertyItem]?
    public var mapProperty: [String: MapPropertyItem]?

    public struct MapOfMapPropertyItem: Decodable {
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.mapOfMapProperty = try values.decodeIfPresent([String: MapOfMapPropertyItem].self, forKey: "map_of_map_property")
        self.mapProperty = try values.decodeIfPresent([String: MapPropertyItem].self, forKey: "map_property")
    }
}

public struct MixedPropertiesAndAdditionalPropertiesClass: Decodable {
    public var dateTime: Date?
    public var map: [String: MapItem]?
    public var uuid: String?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.dateTime = try values.decodeIfPresent(Date.self, forKey: "dateTime")
        self.map = try values.decodeIfPresent([String: MapItem].self, forKey: "map")
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }
}

public struct List: Decodable {
    public var 123List: String?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.123List = try values.decodeIfPresent(String.self, forKey: "123-list")
    }
}

public struct Client: Decodable {
    public var client: String?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.client = try values.decodeIfPresent(String.self, forKey: "client")
    }
}

public struct ReadOnlyFirst: Decodable {
    public var bar: String?
    public var baz: String?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.bar = try values.decodeIfPresent(String.self, forKey: "bar")
        self.baz = try values.decodeIfPresent(String.self, forKey: "baz")
    }
}

public struct HasOnlyReadOnly: Decodable {
    public var bar: String?
    public var foo: String?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.bar = try values.decodeIfPresent(String.self, forKey: "bar")
        self.foo = try values.decodeIfPresent(String.self, forKey: "foo")
    }
}

public struct Capitalization: Decodable {
    /// Name of the pet
    public var attName: String?
    public var capitalCamel: String?
    public var capitalSnake: String?
    public var sCAETHFlowPoints: String?
    public var smallCamel: String?
    public var smallSnake: String?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.attName = try values.decodeIfPresent(String.self, forKey: "ATT_NAME")
        self.capitalCamel = try values.decodeIfPresent(String.self, forKey: "CapitalCamel")
        self.capitalSnake = try values.decodeIfPresent(String.self, forKey: "Capital_Snake")
        self.sCAETHFlowPoints = try values.decodeIfPresent(String.self, forKey: "SCA_ETH_Flow_Points")
        self.smallCamel = try values.decodeIfPresent(String.self, forKey: "smallCamel")
        self.smallSnake = try values.decodeIfPresent(String.self, forKey: "small_Snake")
    }
}

public struct MapTest: Decodable {
    public var mapMapOfString: [String: MapMapOfStringItem]?
    public var mapOfEnumString: [String: MapOfEnumStringItem]?

    public struct MapMapOfStringItem: Decodable {
    }

public enum MapOfEnumStringItem: String, Codable, CaseIterable {
    case upper = "UPPER"
    case lower = "lower"
}

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.mapMapOfString = try values.decodeIfPresent([String: MapMapOfStringItem].self, forKey: "map_map_of_string")
        self.mapOfEnumString = try values.decodeIfPresent([String: MapOfEnumStringItem].self, forKey: "map_of_enum_string")
    }
}

public struct ArrayTest: Decodable {
    public var arrayArrayOfInteger: [[Int]]?
    public var arrayArrayOfModel: [[ReadOnlyFirst]]?
    public var arrayOfString: [String]?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.arrayArrayOfInteger = try values.decodeIfPresent([[Int]].self, forKey: "array_array_of_integer")
        self.arrayArrayOfModel = try values.decodeIfPresent([[ReadOnlyFirst]].self, forKey: "array_array_of_model")
        self.arrayOfString = try values.decodeIfPresent([String].self, forKey: "array_of_string")
    }
}

public struct NumberOnly: Decodable {
    public var justNumber: Double?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.justNumber = try values.decodeIfPresent(Double.self, forKey: "JustNumber")
    }
}

public struct ArrayOfNumberOnly: Decodable {
    public var arrayNumber: [Double]?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.arrayNumber = try values.decodeIfPresent([Double].self, forKey: "ArrayNumber")
    }
}

public struct ArrayOfArrayOfNumberOnly: Decodable {
    public var arrayArrayNumber: [[Double]]?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.arrayArrayNumber = try values.decodeIfPresent([[Double]].self, forKey: "ArrayArrayNumber")
    }
}

public struct EnumArrays: Decodable {
    public var arrayEnum: [String]?
    public var justSymbol: String?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.arrayEnum = try values.decodeIfPresent([String].self, forKey: "array_enum")
        self.justSymbol = try values.decodeIfPresent(String.self, forKey: "just_symbol")
    }
}

public enum OuterEnum: String, Codable, CaseIterable {
    case placed = "placed"
    case approved = "approved"
    case delivered = "delivered"
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {

    private let string: String
    private let int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
        int = nil
    }
    init?(stringValue: String) {
        string = stringValue
        int = nil
    }

    var intValue: Int? { return int }
    init?(intValue: Int) {
        string = String(describing: intValue)
        int = intValue
    }

    init(stringLiteral value: String) {
        string = value
        int = nil
    }
}
