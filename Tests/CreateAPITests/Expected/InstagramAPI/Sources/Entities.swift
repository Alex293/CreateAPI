// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

public struct CaptionData: Codable {
    /// Caption creation UNIX timestamp
    public var createdTime: String?
    public var from: UserShortInfo?
    /// ID of this caption
    public var id: String?
    /// Caption text
    public var text: String?

    public init(createdTime: String? = nil, from: UserShortInfo? = nil, id: String? = nil, text: String? = nil) {
        self.createdTime = createdTime
        self.from = from
        self.id = id
        self.text = text
    }

    private enum CodingKeys: String, CodingKey {
        case createdTime = "created_time"
        case from
        case id
        case text
    }
}

public struct CommentEntry: Codable {
    /// Comment creation UNIX timestamp
    public var createdTime: String?
    public var from: UserShortInfo?
    /// ID of this comment
    public var id: String?
    /// Text of the comment
    public var text: String?

    public init(createdTime: String? = nil, from: UserShortInfo? = nil, id: String? = nil, text: String? = nil) {
        self.createdTime = createdTime
        self.from = from
        self.id = id
        self.text = text
    }

    private enum CodingKeys: String, CodingKey {
        case createdTime = "created_time"
        case from
        case id
        case text
    }
}

public struct CommentsCollection: Codable {
    /// Nember of comments available, data does not necessary contain all comments
    public var count: Int?
    /// Collection of comment entries; **warning:** deprecated for Apps [created on or after Nov 17, 2015](http://instagram.com/developer/changelog/)
    public var data: [CommentEntry]?

    public init(count: Int? = nil, data: [CommentEntry]? = nil) {
        self.count = count
        self.data = data
    }
}

public struct CommentsResponse: Codable {
    /// Collection of comments
    public var data: [CommentEntry]?
    public var meta: MetaData?

    public init(data: [CommentEntry]? = nil, meta: MetaData? = nil) {
        self.data = data
        self.meta = meta
    }
}

public struct CursorPaginationInfo: Codable {
    /// The cursor ID of the next page
    public var nextCursor: String?
    /// URL to retrieve next page of entries
    public var nextURL: String?

    public init(nextCursor: String? = nil, nextURL: String? = nil) {
        self.nextCursor = nextCursor
        self.nextURL = nextURL
    }

    private enum CodingKeys: String, CodingKey {
        case nextCursor = "next_cursor"
        case nextURL = "next_url"
    }
}

public struct IDPaginationInfo: Codable {
    /// The max ID of the next page
    public var nextMaxID: String?
    /// URL to retrieve next page of entries
    public var nextURL: String?

    public init(nextMaxID: String? = nil, nextURL: String? = nil) {
        self.nextMaxID = nextMaxID
        self.nextURL = nextURL
    }

    private enum CodingKeys: String, CodingKey {
        case nextMaxID = "next_max_id"
        case nextURL = "next_url"
    }
}

public struct ImageInfo: Codable {
    /// Image/video height in pixels
    public var height: Int?
    /// URL of the image/video resource
    public var url: String?
    /// Image/video width in pixels
    public var width: Int?

    public init(height: Int? = nil, url: String? = nil, width: Int? = nil) {
        self.height = height
        self.url = url
        self.width = width
    }
}

public struct ImagesData: Codable {
    public var lowResolution: ImageInfo?
    public var standardResolution: ImageInfo?
    public var thumbnail: ImageInfo?

    public init(lowResolution: ImageInfo? = nil, standardResolution: ImageInfo? = nil, thumbnail: ImageInfo? = nil) {
        self.lowResolution = lowResolution
        self.standardResolution = standardResolution
        self.thumbnail = thumbnail
    }

    private enum CodingKeys: String, CodingKey {
        case lowResolution = "low_resolution"
        case standardResolution = "standard_resolution"
        case thumbnail
    }
}

public struct LikesCollection: Codable {
    /// Nember of likes available, data does not necessary contain all comments
    public var count: Int?
    /// Collection of users who liked; **warning:** deprecated for Apps [created on or after Nov 17, 2015](http://instagram.com/developer/changelog/)
    public var data: [UserShortInfo]?

    public init(count: Int? = nil, data: [UserShortInfo]? = nil) {
        self.count = count
        self.data = data
    }
}

public struct LocationInfo: Codable {
    /// ID of this location (in some responses it has a type of 'integer')
    public var id: String?
    /// Location latitude
    public var latitude: Double?
    /// Location longitude
    public var longitude: Double?
    /// Location name
    public var name: String?

    public init(id: String? = nil, latitude: Double? = nil, longitude: Double? = nil, name: String? = nil) {
        self.id = id
        self.latitude = latitude
        self.longitude = longitude
        self.name = name
    }
}

public struct LocationInfoResponse: Codable {
    public var data: LocationInfo?
    public var meta: MetaData?

    public init(data: LocationInfo? = nil, meta: MetaData? = nil) {
        self.data = data
        self.meta = meta
    }
}

public struct LocationSearchResponse: Codable {
    /// List of found locations
    public var data: [LocationInfo]?
    public var meta: MetaData?

    public init(data: [LocationInfo]? = nil, meta: MetaData? = nil) {
        self.data = data
        self.meta = meta
    }
}

public struct MediaEntry: Codable {
    /// ??? Unknown ???
    public var attribution: String?
    public var caption: CaptionData?
    public var comments: CommentsCollection?
    /// Media creation UNIX timestamp
    public var createdTime: String?
    /// Filter of this media entry
    public var filter: String?
    /// ID of a media entry
    public var id: String?
    public var images: ImagesData?
    public var likes: LikesCollection?
    /// Fixed URL of this media entry
    public var link: String?
    public var location: LocationInfo?
    /// List of tags assigned to this media
    public var tags: [String]?
    /// Type of this media entry
    public var type: `Type`?
    public var user: UserShortInfo?
    /// Indicates whether authenticated user has liked this media or not
    public var userHasLiked: Bool?
    /// Users located on this media entry
    public var usersInPhoto: [UserInPhoto]?
    public var videos: VideosData?

    /// Type of this media entry
    public enum `Type`: String, Codable, CaseIterable {
        case image
        case video
    }

    public init(attribution: String? = nil, caption: CaptionData? = nil, comments: CommentsCollection? = nil, createdTime: String? = nil, filter: String? = nil, id: String? = nil, images: ImagesData? = nil, likes: LikesCollection? = nil, link: String? = nil, location: LocationInfo? = nil, tags: [String]? = nil, type: `Type`? = nil, user: UserShortInfo? = nil, userHasLiked: Bool? = nil, usersInPhoto: [UserInPhoto]? = nil, videos: VideosData? = nil) {
        self.attribution = attribution
        self.caption = caption
        self.comments = comments
        self.createdTime = createdTime
        self.filter = filter
        self.id = id
        self.images = images
        self.likes = likes
        self.link = link
        self.location = location
        self.tags = tags
        self.type = type
        self.user = user
        self.userHasLiked = userHasLiked
        self.usersInPhoto = usersInPhoto
        self.videos = videos
    }

    private enum CodingKeys: String, CodingKey {
        case attribution
        case caption
        case comments
        case createdTime = "created_time"
        case filter
        case id
        case images
        case likes
        case link
        case location
        case tags
        case type
        case user
        case userHasLiked = "user_has_liked"
        case usersInPhoto = "users_in_photo"
        case videos
    }
}

public struct MediaEntryResponse: Codable {
    public var data: MediaEntry?
    public var meta: MetaData?

    public init(data: MediaEntry? = nil, meta: MetaData? = nil) {
        self.data = data
        self.meta = meta
    }
}

public struct MediaListResponse: Codable {
    /// List of media entries
    public var data: [MediaEntry]?
    public var meta: MetaData?
    public var pagination: IDPaginationInfo?

    public init(data: [MediaEntry]? = nil, meta: MetaData? = nil, pagination: IDPaginationInfo? = nil) {
        self.data = data
        self.meta = meta
        self.pagination = pagination
    }
}

public struct MediaSearchResponse: Codable {
    /// Found media entries; some end-points do not return likes informtaion
    public var data: [MediaEntry]?
    public var meta: MetaData?

    public init(data: [MediaEntry]? = nil, meta: MetaData? = nil) {
        self.data = data
        self.meta = meta
    }
}

public struct MetaData: Codable {
    /// HTTP result code
    public var code: Int?

    public init(code: Int? = nil) {
        self.code = code
    }
}

public struct Position: Codable {
    /// X position (horizontal)
    public var x: Double?
    /// Y position (vertical)
    public var y: Double?

    public init(x: Double? = nil, y: Double? = nil) {
        self.x = x
        self.y = y
    }
}

public struct RelationshipInfo: Codable {
    /// Status of incoming relationship
    public var incomingStatus: IncomingStatus?
    /// Status of outgoing relationship
    public var outgoingStatus: OutgoingStatus?
    /// Indicates whether target user is private or not
    public var targetUserIsPrivate: Bool?

    /// Status of incoming relationship
    public enum IncomingStatus: String, Codable, CaseIterable {
        case `none`
        case followedBy = "followed_by"
        case requestedBy = "requested_by"
    }

    /// Status of outgoing relationship
    public enum OutgoingStatus: String, Codable, CaseIterable {
        case `none`
        case follows
        case requested
    }

    public init(incomingStatus: IncomingStatus? = nil, outgoingStatus: OutgoingStatus? = nil, targetUserIsPrivate: Bool? = nil) {
        self.incomingStatus = incomingStatus
        self.outgoingStatus = outgoingStatus
        self.targetUserIsPrivate = targetUserIsPrivate
    }

    private enum CodingKeys: String, CodingKey {
        case incomingStatus = "incoming_status"
        case outgoingStatus = "outgoing_status"
        case targetUserIsPrivate = "target_user_is_private"
    }
}

public struct RelationshipPostResponse: Codable {
    public var data: RelationshipStatus?
    public var meta: MetaData?

    public init(data: RelationshipStatus? = nil, meta: MetaData? = nil) {
        self.data = data
        self.meta = meta
    }
}

public struct RelationshipResponse: Codable {
    public var data: RelationshipInfo?
    public var meta: MetaData?

    public init(data: RelationshipInfo? = nil, meta: MetaData? = nil) {
        self.data = data
        self.meta = meta
    }
}

public struct RelationshipStatus: Codable {
    /// Status of outgoing relationship
    public var outgoingStatus: OutgoingStatus?

    /// Status of outgoing relationship
    public enum OutgoingStatus: String, Codable, CaseIterable {
        case `none`
        case follows
        case requested
    }

    public init(outgoingStatus: OutgoingStatus? = nil) {
        self.outgoingStatus = outgoingStatus
    }

    private enum CodingKeys: String, CodingKey {
        case outgoingStatus = "outgoing_status"
    }
}

public struct StatusResponse: Codable {
    /// No data - 'null'
    public var data: String?
    public var meta: MetaData?

    public init(data: String? = nil, meta: MetaData? = nil) {
        self.data = data
        self.meta = meta
    }
}

public struct TagInfo: Codable {
    /// Overall number of media entries taged with this name
    public var mediaCount: Int?
    /// Tag name
    public var name: String?

    public init(mediaCount: Int? = nil, name: String? = nil) {
        self.mediaCount = mediaCount
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case mediaCount = "media_count"
        case name
    }
}

public struct TagInfoResponse: Codable {
    public var data: TagInfo?
    public var meta: MetaData?

    public init(data: TagInfo? = nil, meta: MetaData? = nil) {
        self.data = data
        self.meta = meta
    }
}

public struct TagMediaListResponse: Codable {
    /// List of media entries with this tag
    public var data: [MediaEntry]?
    public var meta: MetaData?
    public var pagination: TagPaginationInfo?

    public init(data: [MediaEntry]? = nil, meta: MetaData? = nil, pagination: TagPaginationInfo? = nil) {
        self.data = data
        self.meta = meta
        self.pagination = pagination
    }
}

public struct TagPaginationInfo: Codable {
    /// The deprication warning, if information is available
    public var deprecationWarning: String?
    /// The min ID of a tag for the next page
    public var minTagID: String?
    /// Depricated. Use min_tag_id instead
    public var nextMaxID: String?
    /// The max ID of a tag for the next page
    public var nextMaxTagID: String?
    /// Depricated. Use max_tag_id instead
    public var nextMinID: String?
    /// URL to retrieve next page of entries
    public var nextURL: String?

    public init(deprecationWarning: String? = nil, minTagID: String? = nil, nextMaxID: String? = nil, nextMaxTagID: String? = nil, nextMinID: String? = nil, nextURL: String? = nil) {
        self.deprecationWarning = deprecationWarning
        self.minTagID = minTagID
        self.nextMaxID = nextMaxID
        self.nextMaxTagID = nextMaxTagID
        self.nextMinID = nextMinID
        self.nextURL = nextURL
    }

    private enum CodingKeys: String, CodingKey {
        case deprecationWarning = "deprecation_warning"
        case minTagID = "min_tag_id"
        case nextMaxID = "next_max_id"
        case nextMaxTagID = "next_max_tag_id"
        case nextMinID = "next_min_id"
        case nextURL = "next_url"
    }
}

public struct TagSearchResponse: Codable {
    /// List of found tags with brief statistics
    public var data: [TagInfo]?
    public var meta: MetaData?

    public init(data: [TagInfo]? = nil, meta: MetaData? = nil) {
        self.data = data
        self.meta = meta
    }
}

public struct UserCounts: Codable {
    /// Number of followers of this user
    public var followedBy: Int?
    /// Number of users followed by this user
    public var follows: Int?
    /// Number of user media
    public var media: Int?

    public init(followedBy: Int? = nil, follows: Int? = nil, media: Int? = nil) {
        self.followedBy = followedBy
        self.follows = follows
        self.media = media
    }

    private enum CodingKeys: String, CodingKey {
        case followedBy = "followed_by"
        case follows
        case media
    }
}

public struct UserInPhoto: Codable {
    public var position: Position?
    public var user: UserShortInfo?

    public init(position: Position? = nil, user: UserShortInfo? = nil) {
        self.position = position
        self.user = user
    }
}

public struct UserInfo: Codable {
    /// User biography
    public var bio: String?
    public var counts: UserCounts?
    /// User full name
    public var fullName: String?
    /// User ID
    public var id: String?
    /// URL to user profile picture
    public var profilePicture: String?
    /// User name, nickname
    public var username: String?
    /// URL to user web-site
    public var website: String?

    public init(bio: String? = nil, counts: UserCounts? = nil, fullName: String? = nil, id: String? = nil, profilePicture: String? = nil, username: String? = nil, website: String? = nil) {
        self.bio = bio
        self.counts = counts
        self.fullName = fullName
        self.id = id
        self.profilePicture = profilePicture
        self.username = username
        self.website = website
    }

    private enum CodingKeys: String, CodingKey {
        case bio
        case counts
        case fullName = "full_name"
        case id
        case profilePicture = "profile_picture"
        case username
        case website
    }
}

public struct UserResponse: Codable {
    public var data: UserInfo?
    public var meta: MetaData?

    public init(data: UserInfo? = nil, meta: MetaData? = nil) {
        self.data = data
        self.meta = meta
    }
}

public struct UserShortInfo: Codable {
    /// User full name
    public var fullName: String?
    /// User ID
    public var id: String?
    /// URL to user profile picture
    public var profilePicture: String?
    /// User name, nickname
    public var username: String?

    public init(fullName: String? = nil, id: String? = nil, profilePicture: String? = nil, username: String? = nil) {
        self.fullName = fullName
        self.id = id
        self.profilePicture = profilePicture
        self.username = username
    }

    private enum CodingKeys: String, CodingKey {
        case fullName = "full_name"
        case id
        case profilePicture = "profile_picture"
        case username
    }
}

public struct UsersInfoResponse: Codable {
    /// User short information entries
    public var data: [UserShortInfo]?
    public var meta: MetaData?

    public init(data: [UserShortInfo]? = nil, meta: MetaData? = nil) {
        self.data = data
        self.meta = meta
    }
}

public struct UsersPagingResponse: Codable {
    /// List of user short information entries
    public var data: [UserShortInfo]?
    public var meta: MetaData?
    public var pagination: CursorPaginationInfo?

    public init(data: [UserShortInfo]? = nil, meta: MetaData? = nil, pagination: CursorPaginationInfo? = nil) {
        self.data = data
        self.meta = meta
        self.pagination = pagination
    }
}

public struct VideosData: Codable {
    public var lowResolution: ImageInfo?
    public var standardResolution: ImageInfo?

    public init(lowResolution: ImageInfo? = nil, standardResolution: ImageInfo? = nil) {
        self.lowResolution = lowResolution
        self.standardResolution = standardResolution
    }

    private enum CodingKeys: String, CodingKey {
        case lowResolution = "low_resolution"
        case standardResolution = "standard_resolution"
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
