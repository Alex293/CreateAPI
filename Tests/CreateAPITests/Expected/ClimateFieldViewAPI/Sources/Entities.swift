// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

/// A minimal set of attributes regarding the parent of a farm organization.
public struct Parent: Codable {
    /// Unique identifier for the parent of a farm organization.
    public var id: String
    /// Type of the parent of a farm organization.
    public var type: `Type`

    /// Type of the parent of a farm organization.
    public enum `Type`: String, Codable, CaseIterable {
        case farm
    }

    public init(id: String, type: `Type`) {
        self.id = id
        self.type = type
    }
}

/// Logical representation of a Field with a name.  Spatial attributes of the Field are provided in the Boundary.
///
/// Example:
///
/// {
///   "boundaryId" : "00000000-0000-0000-0000-000000000000",
///   "id" : "00000000-0000-0000-0000-000000000000",
///   "name" : "Back Forty",
///   "parent" : {
///     "id" : "00000000-0000-0000-0000-000000000000",
///     "type" : "farm"
///   },
///   "resourceOwnerId" : "00000000-0000-0000-0000-000000000000"
/// }
public struct Field: Codable {
    /// Unique identifier for a Field.
    public var id: String
    /// Name of the Field.
    public var name: String
    /// Unique identifier for the current Field's Boundary.
    public var boundaryID: String
    /// Unique identifier of the resource owner that owns the Field.
    public var resourceOwnerID: String
    /// A minimal set of attributes regarding the parent of a farm organization.
    public var parent: Parent

    public init(id: String, name: String, boundaryID: String, resourceOwnerID: String, parent: Parent) {
        self.id = id
        self.name = name
        self.boundaryID = boundaryID
        self.resourceOwnerID = resourceOwnerID
        self.parent = parent
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case boundaryID = "boundaryId"
        case resourceOwnerID = "resourceOwnerId"
        case parent
    }
}

/// A batch of field results
public struct Fields: Codable {
    public var results: [Field]

    public init(results: [Field]) {
        self.results = results
    }
}

/// Logical representation of a farm organization with a name and type.
///
/// Example:
///
/// {
///   "id" : "00000000-0000-0000-0000-000000000000",
///   "name" : "Back Forty",
///   "type" : "farm"
/// }
public struct FarmOrganization: Codable {
    /// Unique identifier for a farm organization.
    public var id: String
    /// Name of the farm organization.
    public var name: String
    /// Type of the farm organization.
    public var type: `Type`

    /// Type of the farm organization.
    public enum `Type`: String, Codable, CaseIterable {
        case farm
    }

    public init(id: String, name: String, type: `Type`) {
        self.id = id
        self.name = name
        self.type = type
    }
}

public struct ResourceOwner: Codable {
    public var id: String
    public var name: String
    public var email: String

    public init(id: String, name: String, email: String) {
        self.id = id
        self.name = name
        self.email = email
    }
}

/// GeoJSON
///
/// Example:
///
/// {
///   "coordinates" : [
///     0,
///     0
///   ],
///   "type" : "Point"
/// }
public struct Geometry: Codable {
    public var type: `Type`
    public var coordinates: [String]

    public enum `Type`: String, Codable, CaseIterable {
        case point = "Point"
        case polygon = "Polygon"
        case multiPolygon = "MultiPolygon"
    }

    public init(type: `Type`, coordinates: [String]) {
        self.type = type
        self.coordinates = coordinates
    }
}

/// Area with units. Units are always "hectare".
///
/// Example:
///
/// {
///   "q" : 1,
///   "u" : "hectare"
/// }
public struct Area: Codable {
    public var q: Double
    public var u: String

    public init(q: Double, u: String) {
        self.q = q
        self.u = u
    }
}

/// Example:
///
/// {
///   "coordinates" : [
///     -122.2,
///     38.100000000000001
///   ],
///   "type" : "Point"
/// }
public struct Point: Codable {
    public var coordinates: [Double]
    public var type: String

    public init(coordinates: [Double], type: String) {
        self.coordinates = coordinates
        self.type = type
    }
}

/// Properties map.
public struct BoundaryProperties: Codable {
    /// Area with units. Units are always "hectare".
    ///
    /// Example:
    ///
    /// {
    ///   "q" : 1,
    ///   "u" : "hectare"
    /// }
    public var area: Area
    /// Example:
    ///
    /// {
    ///   "coordinates" : [
    ///     -122.2,
    ///     38.100000000000001
    ///   ],
    ///   "type" : "Point"
    /// }
    public var centroid: Point

    public init(area: Area, centroid: Point) {
        self.area = area
        self.centroid = centroid
    }
}

/// Arbitrary boundary.  GeoJSON Feature.
public struct Boundary: Codable {
    public var id: String
    public var type: `Type`
    /// GeoJSON
    ///
    /// Example:
    ///
    /// {
    ///   "coordinates" : [
    ///     0,
    ///     0
    ///   ],
    ///   "type" : "Point"
    /// }
    public var geometry: Geometry
    /// Properties map.
    public var properties: BoundaryProperties

    public enum `Type`: String, Codable, CaseIterable {
        case feature = "Feature"
    }

    public init(id: String, type: `Type`, geometry: Geometry, properties: BoundaryProperties) {
        self.id = id
        self.type = type
        self.geometry = geometry
        self.properties = properties
    }
}

/// Arbitrary boundary in a geometry map
public struct BoundaryUpload: Codable {
    /// GeoJSON
    ///
    /// Example:
    ///
    /// {
    ///   "coordinates" : [
    ///     0,
    ///     0
    ///   ],
    ///   "type" : "Point"
    /// }
    public var geometry: Geometry

    public init(geometry: Geometry) {
        self.geometry = geometry
    }
}

/// Unique identifier of a successfully uploaded boundary
public struct UploadedBoundaryID: Codable {
    public var id: String

    public init(id: String) {
        self.id = id
    }
}

/// A batch of boundary results
public struct Boundaries: Codable {
    public var type: `Type`
    public var features: [Boundary]

    public enum `Type`: String, Codable, CaseIterable {
        case featureCollection = "FeatureCollection"
    }

    public init(type: `Type`, features: [Boundary]) {
        self.type = type
        self.features = features
    }
}

public struct BoundariesQuery: Codable {
    public var ids: [String]

    public init(ids: [String]) {
        self.ids = ids
    }
}

/// Client request to upload data for a user.
public struct Upload: Codable {
    /// Content type representing data being uploaded (e.g. image/vnd.climate.rgb.geotiff)
    public var contentType: ContentType
    /// Base64 encoded md5 hash of the content
    public var md5: String
    /// Content size in bytes
    public var length: Int
    public var metadata: [String: AnyJSON]?

    /// Content type representing data being uploaded (e.g. image/vnd.climate.rgb.geotiff)
    public enum ContentType: String, Codable, CaseIterable {
        case applicationVndClimateFieldGeojson = "application/vnd.climate.field.geojson"
        case imageVndClimateThermalGeotiff = "image/vnd.climate.thermal.geotiff"
        case imageVndClimateNdviGeotiff = "image/vnd.climate.ndvi.geotiff"
        case imageVndClimateWaterstressGeotiff = "image/vnd.climate.waterstress.geotiff"
        case imageVndClimateElevationGeotiff = "image/vnd.climate.elevation.geotiff"
        case imageVndClimateRawGeotiff = "image/vnd.climate.raw.geotiff"
        case imageVndClimateRgbGeotiff = "image/vnd.climate.rgb.geotiff"
    }

    public init(contentType: ContentType, md5: String, length: Int, metadata: [String: AnyJSON]? = nil) {
        self.contentType = contentType
        self.md5 = md5
        self.length = length
        self.metadata = metadata
    }
}

public struct UploadStatus: Codable {
    /// Unique identifier for the upload.
    public var id: String
    /// Current status of the upload:
    ///   * `UPLOADING` - Uploading has started, parts are still coming in.
    ///   * `INVALID` - Upload has failed validity check.
    ///   * `PENDING` - Upload has been received by Climate and is being processed.
    ///   * `INBOX` - The upload is awaiting user acceptance in their Data Inbox.
    ///   * `DECLINED` - The user has declined the upload in their Data Inbox.
    ///   * `IMPORTING` - The user has accepted the upload and it is being imported into their account.
    ///   * `SUCCESS` - The upload has been successfully imported.
    public var status: Status

    /// Current status of the upload:
    ///   * `UPLOADING` - Uploading has started, parts are still coming in.
    ///   * `INVALID` - Upload has failed validity check.
    ///   * `PENDING` - Upload has been received by Climate and is being processed.
    ///   * `INBOX` - The upload is awaiting user acceptance in their Data Inbox.
    ///   * `DECLINED` - The user has declined the upload in their Data Inbox.
    ///   * `IMPORTING` - The user has accepted the upload and it is being imported into their account.
    ///   * `SUCCESS` - The upload has been successfully imported.
    public enum Status: String, Codable, CaseIterable {
        case uploading = "UPLOADING"
        case invalid = "INVALID"
        case pending = "PENDING"
        case inbox = "INBOX"
        case declined = "DECLINED"
        case importing = "IMPORTING"
        case success = "SUCCESS"
    }

    public init(id: String, status: Status) {
        self.id = id
        self.status = status
    }
}

public struct UploadStatuses: Codable {
    public var results: [UploadStatus]

    public init(results: [UploadStatus]) {
        self.results = results
    }
}

public struct UploadStatusQuery: Codable {
    public var ids: [String]

    public init(ids: [String]) {
        self.ids = ids
    }
}

public struct ScoutingTag: Codable {
    public var code: String

    public init(code: String) {
        self.code = code
    }
}

public struct ScoutingObservationSummary: Codable {
    /// The id of a scouting observation.
    public var id: String
    /// The start time of the scouting observation. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
    public var startTime: Date
    /// The start time of the scouting observation. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
    public var endTime: Date
    /// The time the scouting observation or any of its attachments was last updated.Time in ISO 8601 format with UTC timezone, 3 fractional seconds. (https://tools.ietf.org/html/rfc3339).
    public var updatedAt: Date

    public init(id: String, startTime: Date, endTime: Date, updatedAt: Date) {
        self.id = id
        self.startTime = startTime
        self.endTime = endTime
        self.updatedAt = updatedAt
    }
}

public struct ScoutingObservation: Codable {
    /// The id of a scouting observation.
    public var id: String
    /// The title or summary of the scouting observation. 40 Characters long, no emojis, and leading and trailing whitespace will be trimmed.
    public var title: String
    /// The text of the scouting observation. Maximum of 4000 characters.
    public var note: String
    /// GeoJSON
    ///
    /// Example:
    ///
    /// {
    ///   "coordinates" : [
    ///     0,
    ///     0
    ///   ],
    ///   "type" : "Point"
    /// }
    public var location: Geometry
    /// The start time of the scouting observation. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
    public var startTime: Date
    /// The start time of the scouting observation. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
    public var endTime: Date
    /// The time the scouting observation or any of its attachments was last updated.Time in ISO 8601 format with UTC timezone, 3 fractional seconds. (https://tools.ietf.org/html/rfc3339).
    public var updatedAt: Date
    /// Array of field ids associated with this observation.
    public var fieldIDs: [String]
    /// For example, ROCK_STONE, PONDING_WET, HAIL Maximum 20 tags allowed, 40 characters per tag.
    public var tags: [ScoutingTag]
    /// Permanent or seasonal
    public var timespan: Timespan
    /// Color of scouting pin assigned in the Climate FieldView app.
    /// Limited in the Ux to a set of RGB values.
    /// * #307af7
    /// * #38d753
    /// * #b037e4
    /// * #ef3e3e
    /// * #f7ec41
    /// * #ff8439
    /// * #808080
    public var locationDisplayColor: LocationDisplayColor
    /// The status of the scouting observation For example : ACTIVE, DELETED
    public var status: Status

    /// Permanent or seasonal
    public enum Timespan: String, Codable, CaseIterable {
        case permanent = "PERMANENT"
        case seasonal = "SEASONAL"
    }

    /// Color of scouting pin assigned in the Climate FieldView app.
    /// Limited in the Ux to a set of RGB values.
    /// * #307af7
    /// * #38d753
    /// * #b037e4
    /// * #ef3e3e
    /// * #f7ec41
    /// * #ff8439
    /// * #808080
    public enum LocationDisplayColor: String, Codable, CaseIterable {
        case _307af7 = "#307af7"
        case _38d753 = "#38d753"
        case b037e4 = "#b037e4"
        case ef3e3e = "#ef3e3e"
        case f7ec41 = "#f7ec41"
        case ff8439 = "#ff8439"
        case _808080 = "#808080"
    }

    /// The status of the scouting observation For example : ACTIVE, DELETED
    public enum Status: String, Codable, CaseIterable {
        case active = "ACTIVE"
        case deleted = "DELETED"
    }

    public init(id: String, title: String, note: String, location: Geometry, startTime: Date, endTime: Date, updatedAt: Date, fieldIDs: [String], tags: [ScoutingTag], timespan: Timespan, locationDisplayColor: LocationDisplayColor, status: Status) {
        self.id = id
        self.title = title
        self.note = note
        self.location = location
        self.startTime = startTime
        self.endTime = endTime
        self.updatedAt = updatedAt
        self.fieldIDs = fieldIDs
        self.tags = tags
        self.timespan = timespan
        self.locationDisplayColor = locationDisplayColor
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case title
        case note
        case location
        case startTime
        case endTime
        case updatedAt
        case fieldIDs = "fieldIds"
        case tags
        case timespan
        case locationDisplayColor
        case status
    }
}

/// A batch of scouting observations
public struct ScoutingObservations: Codable {
    public var results: [ScoutingObservationSummary]

    public init(results: [ScoutingObservationSummary]) {
        self.results = results
    }
}

public struct ScoutingObservationAttachment: Codable {
    /// Id of the attachment
    public var id: String
    /// The time the attachment was last updated.
    /// Time in ISO 8601 format with UTC timezone, 3 fractional seconds.
    /// (https://tools.ietf.org/html/rfc3339)
    public var updatedAt: Date
    /// The content type of the attachment, e.g. image/png.
    public var contentType: String
    /// The number of bytes in the attachment.
    public var length: Int
    /// The status of the attachment. For example : ACTIVE, DELETED
    public var status: Status

    /// The status of the attachment. For example : ACTIVE, DELETED
    public enum Status: String, Codable, CaseIterable {
        case active = "ACTIVE"
        case deleted = "DELETED"
    }

    public init(id: String, updatedAt: Date, contentType: String, length: Int, status: Status) {
        self.id = id
        self.updatedAt = updatedAt
        self.contentType = contentType
        self.length = length
        self.status = status
    }
}

/// A batch of scouting attachments
public struct ScoutingObservationAttachments: Codable {
    public var results: [ScoutingObservationAttachment]

    public init(results: [ScoutingObservationAttachment]) {
        self.results = results
    }
}

public struct ScoutingObservationAttachmentContents: Codable {
    /// Binary contents
    public var body: String

    public init(body: String) {
        self.body = body
    }
}

public struct PlantingActivityContents: Codable {
    /// Binary contents
    public var body: String

    public init(body: String) {
        self.body = body
    }
}

public struct ApplicationActivityContents: Codable {
    /// Binary contents
    public var body: String

    public init(body: String) {
        self.body = body
    }
}

public struct HarvestActivityContents: Codable {
    /// Binary contents
    public var body: String

    public init(body: String) {
        self.body = body
    }
}

public struct Error: Codable {
    public var error: Error?

    public struct Error: Codable {
        public var id: String
        public var code: String
        /// Description of the error encountered.
        public var message: String

        public init(id: String, code: String, message: String) {
            self.id = id
            self.code = code
            self.message = message
        }
    }

    public init(error: Error? = nil) {
        self.error = error
    }
}

/// A batch of planting activities
public struct PlantingActivities: Codable {
    public var results: [PlantingActivitySummary]

    public init(results: [PlantingActivitySummary]) {
        self.results = results
    }
}

public struct PlantingActivitySummary: Codable {
    /// The id of a planting activity.
    public var id: String
    /// The start time of the planting activity. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
    public var startTime: Date
    /// The start time of the planting activity. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
    public var endTime: Date
    /// The time the planting activity was created. Time in ISO 8601 format with UTC timezone, 3 fractional seconds. (https://tools.ietf.org/html/rfc3339).
    public var createdAt: Date
    /// The time the planting activity was last updated. Time in ISO 8601 format with UTC timezone, 3 fractional seconds. (https://tools.ietf.org/html/rfc3339).
    public var updatedAt: Date
    /// The size in bytes of the raw planting activity file.
    public var length: Int
    /// Array of field ids associated the planting activity.
    public var fieldIDs: [String]

    public init(id: String, startTime: Date, endTime: Date, createdAt: Date, updatedAt: Date, length: Int, fieldIDs: [String]) {
        self.id = id
        self.startTime = startTime
        self.endTime = endTime
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.length = length
        self.fieldIDs = fieldIDs
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case startTime
        case endTime
        case createdAt
        case updatedAt
        case length
        case fieldIDs = "fieldIds"
    }
}

/// A batch of application activities
public struct ApplicationActivities: Codable {
    public var results: [ApplicationActivitySummary]

    public init(results: [ApplicationActivitySummary]) {
        self.results = results
    }
}

public struct ApplicationActivitySummary: Codable {
    /// The id of an application activity.
    public var id: String
    /// The start time of the application activity. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
    public var startTime: Date
    /// The start time of the application activity. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
    public var endTime: Date
    /// The time the application activity was created. Time in ISO 8601 format with UTC timezone, 3 fractional seconds. (https://tools.ietf.org/html/rfc3339).
    public var createdAt: Date
    /// The time the application activity was last updated. Time in ISO 8601 format with UTC timezone, 3 fractional seconds. (https://tools.ietf.org/html/rfc3339).
    public var updatedAt: Date
    /// The size in bytes of the raw application activity file.
    public var length: Int
    /// Array of field ids associated the application activity.
    public var fieldIDs: [String]

    public init(id: String, startTime: Date, endTime: Date, createdAt: Date, updatedAt: Date, length: Int, fieldIDs: [String]) {
        self.id = id
        self.startTime = startTime
        self.endTime = endTime
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.length = length
        self.fieldIDs = fieldIDs
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case startTime
        case endTime
        case createdAt
        case updatedAt
        case length
        case fieldIDs = "fieldIds"
    }
}

/// A batch of harvest activities
public struct HarvestActivities: Codable {
    public var results: [HarvestActivitySummary]

    public init(results: [HarvestActivitySummary]) {
        self.results = results
    }
}

public struct HarvestActivitySummary: Codable {
    /// The id of a harvest activity.
    public var id: String
    /// The start time of the harvest activity. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
    public var startTime: Date
    /// The start time of the harvest activity. Time in ISO 8601 format with UTC timezone, 3 fractional seconds (https://tools.ietf.org/html/rfc3339).
    public var endTime: Date
    /// The time the harvest activity was created. Time in ISO 8601 format with UTC timezone, 3 fractional seconds. (https://tools.ietf.org/html/rfc3339).
    public var createdAt: Date
    /// The time the harvest activity was last updated. Time in ISO 8601 format with UTC timezone, 3 fractional seconds. (https://tools.ietf.org/html/rfc3339).
    public var updatedAt: Date
    /// The size in bytes of the raw harvest activity file.
    public var length: Int
    /// Array of field ids associated the harvest activity.
    public var fieldIDs: [String]

    public init(id: String, startTime: Date, endTime: Date, createdAt: Date, updatedAt: Date, length: Int, fieldIDs: [String]) {
        self.id = id
        self.startTime = startTime
        self.endTime = endTime
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.length = length
        self.fieldIDs = fieldIDs
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case startTime
        case endTime
        case createdAt
        case updatedAt
        case length
        case fieldIDs = "fieldIds"
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
