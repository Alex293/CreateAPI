// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get

extension Paths {
    public static var search: Search {
        Search(path: "/search")
    }

    public struct Search {
        /// Path: `/search`
        public let path: String
    }
}

extension Paths.Search {
    public func versionNumber(_ versionNumber: Int) -> WithVersionNumber {
        WithVersionNumber(path: "\(path)/\(versionNumber)")
    }

    public struct WithVersionNumber {
        /// Path: `/search/{versionNumber}`
        public let path: String
    }
}

extension Paths.Search.WithVersionNumber {
    public func ext(_ ext: String) -> WithAdditionalData {
        WithAdditionalData(path: "\(path)/additionalData.\(ext)")
    }

    public struct WithAdditionalData {
        /// Path: `/search/{versionNumber}/additionalData.{ext}`
        public let path: String

        /// Additional Data
        public func get(geometries: String, geometriesZoom: Int? = nil) -> Request<Void> {
            .get(path, query: makeGetQuery(geometries, geometriesZoom))
        }

        private func makeGetQuery(_ geometries: String, _ geometriesZoom: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("geometries", geometries)
            query.addQueryItem("geometriesZoom", geometriesZoom)
            return query
        }
    }
}

extension Paths.Search.WithVersionNumber {
    public var cs: CS {
        CS(path: path + "/cS")
    }

    public struct CS {
        /// Path: `/search/{versionNumber}/cS`
        public let path: String
    }
}

extension Paths.Search.WithVersionNumber.CS {
    public func category(_ category: String) -> WithExt {
        WithExt(path: "\(path)/\(category).{ext}")
    }

    public struct WithExt {
        /// Path: `/search/{versionNumber}/cS/{category}.{ext}`
        public let path: String

        /// Low Bandwith Category Search
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters? = nil) -> Request<Void> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isTypeahead: Bool?
            public var limit: Int?
            public var ofs: Int?
            public var countrySet: String?
            public var lat: Double?
            public var lon: Double?
            public var radius: Int?
            public var topLeft: String?
            public var btmRight: String?
            public var language: String?
            public var idxSet: String?
            public var view: View?

            public enum View: String, Codable, CaseIterable {
                case unified = "Unified"
                case `in` = "IN"
                case pk = "PK"
                case il = "IL"
                case ma = "MA"
            }

            public init(isTypeahead: Bool? = nil, limit: Int? = nil, ofs: Int? = nil, countrySet: String? = nil, lat: Double? = nil, lon: Double? = nil, radius: Int? = nil, topLeft: String? = nil, btmRight: String? = nil, language: String? = nil, idxSet: String? = nil, view: View? = nil) {
                self.isTypeahead = isTypeahead
                self.limit = limit
                self.ofs = ofs
                self.countrySet = countrySet
                self.lat = lat
                self.lon = lon
                self.radius = radius
                self.topLeft = topLeft
                self.btmRight = btmRight
                self.language = language
                self.idxSet = idxSet
                self.view = view
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("typeahead", isTypeahead)
                query.addQueryItem("limit", limit)
                query.addQueryItem("ofs", ofs)
                query.addQueryItem("countrySet", countrySet)
                query.addQueryItem("lat", lat)
                query.addQueryItem("lon", lon)
                query.addQueryItem("radius", radius)
                query.addQueryItem("topLeft", topLeft)
                query.addQueryItem("btmRight", btmRight)
                query.addQueryItem("language", language)
                query.addQueryItem("idxSet", idxSet)
                query.addQueryItem("view", view)
                return query
            }
        }
    }
}

extension Paths.Search.WithVersionNumber {
    public var categorySearch: CategorySearch {
        CategorySearch(path: path + "/categorySearch")
    }

    public struct CategorySearch {
        /// Path: `/search/{versionNumber}/categorySearch`
        public let path: String
    }
}

extension Paths.Search.WithVersionNumber.CategorySearch {
    public func query(_ query: String) -> WithExt {
        WithExt(path: "\(path)/\(query).{ext}")
    }

    public struct WithExt {
        /// Path: `/search/{versionNumber}/categorySearch/{query}.{ext}`
        public let path: String

        /// Category Search
        public func get(parameters: GetParameters? = nil) -> Request<Void> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isTypeahead: Bool?
            public var limit: Int?
            public var ofs: Int?
            public var countrySet: String?
            public var lat: Double?
            public var lon: Double?
            public var radius: Int?
            public var topLeft: String?
            public var btmRight: String?
            public var language: String?
            public var extendedPostalCodesFor: String?
            public var view: View?

            public enum View: String, Codable, CaseIterable {
                case unified = "Unified"
                case `in` = "IN"
                case pk = "PK"
                case il = "IL"
                case ma = "MA"
            }

            public init(isTypeahead: Bool? = nil, limit: Int? = nil, ofs: Int? = nil, countrySet: String? = nil, lat: Double? = nil, lon: Double? = nil, radius: Int? = nil, topLeft: String? = nil, btmRight: String? = nil, language: String? = nil, extendedPostalCodesFor: String? = nil, view: View? = nil) {
                self.isTypeahead = isTypeahead
                self.limit = limit
                self.ofs = ofs
                self.countrySet = countrySet
                self.lat = lat
                self.lon = lon
                self.radius = radius
                self.topLeft = topLeft
                self.btmRight = btmRight
                self.language = language
                self.extendedPostalCodesFor = extendedPostalCodesFor
                self.view = view
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("typeahead", isTypeahead)
                query.addQueryItem("limit", limit)
                query.addQueryItem("ofs", ofs)
                query.addQueryItem("countrySet", countrySet)
                query.addQueryItem("lat", lat)
                query.addQueryItem("lon", lon)
                query.addQueryItem("radius", radius)
                query.addQueryItem("topLeft", topLeft)
                query.addQueryItem("btmRight", btmRight)
                query.addQueryItem("language", language)
                query.addQueryItem("extendedPostalCodesFor", extendedPostalCodesFor)
                query.addQueryItem("view", view)
                return query
            }
        }
    }
}

extension Paths.Search.WithVersionNumber {
    public var geocode: Geocode {
        Geocode(path: path + "/geocode")
    }

    public struct Geocode {
        /// Path: `/search/{versionNumber}/geocode`
        public let path: String
    }
}

extension Paths.Search.WithVersionNumber.Geocode {
    public func query(_ query: String) -> WithExt {
        WithExt(path: "\(path)/\(query).{ext}")
    }

    public struct WithExt {
        /// Path: `/search/{versionNumber}/geocode/{query}.{ext}`
        public let path: String

        /// Geocode
        public func get(parameters: GetParameters? = nil) -> Request<Void> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isStoreResult: Bool?
            public var isTypeahead: Bool?
            public var limit: Int?
            public var ofs: Int?
            public var countrySet: String?
            public var lat: Double?
            public var lon: Double?
            public var radius: Int?
            public var topLeft: String?
            public var btmRight: String?
            public var language: String?
            public var extendedPostalCodesFor: String?
            public var view: View?

            public enum View: String, Codable, CaseIterable {
                case unified = "Unified"
                case `in` = "IN"
                case pk = "PK"
                case il = "IL"
                case ma = "MA"
            }

            public init(isStoreResult: Bool? = nil, isTypeahead: Bool? = nil, limit: Int? = nil, ofs: Int? = nil, countrySet: String? = nil, lat: Double? = nil, lon: Double? = nil, radius: Int? = nil, topLeft: String? = nil, btmRight: String? = nil, language: String? = nil, extendedPostalCodesFor: String? = nil, view: View? = nil) {
                self.isStoreResult = isStoreResult
                self.isTypeahead = isTypeahead
                self.limit = limit
                self.ofs = ofs
                self.countrySet = countrySet
                self.lat = lat
                self.lon = lon
                self.radius = radius
                self.topLeft = topLeft
                self.btmRight = btmRight
                self.language = language
                self.extendedPostalCodesFor = extendedPostalCodesFor
                self.view = view
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("storeResult", isStoreResult)
                query.addQueryItem("typeahead", isTypeahead)
                query.addQueryItem("limit", limit)
                query.addQueryItem("ofs", ofs)
                query.addQueryItem("countrySet", countrySet)
                query.addQueryItem("lat", lat)
                query.addQueryItem("lon", lon)
                query.addQueryItem("radius", radius)
                query.addQueryItem("topLeft", topLeft)
                query.addQueryItem("btmRight", btmRight)
                query.addQueryItem("language", language)
                query.addQueryItem("extendedPostalCodesFor", extendedPostalCodesFor)
                query.addQueryItem("view", view)
                return query
            }
        }
    }
}

extension Paths.Search.WithVersionNumber {
    public func ext(_ ext: String) -> WithGeometryFilter {
        WithGeometryFilter(path: "\(path)/geometryFilter.\(ext)")
    }

    public struct WithGeometryFilter {
        /// Path: `/search/{versionNumber}/geometryFilter.{ext}`
        public let path: String

        /// Geometry Filter
        public func get(geometryList: String, poiList: String) -> Request<Void> {
            .get(path, query: makeGetQuery(geometryList, poiList))
        }

        private func makeGetQuery(_ geometryList: String, _ poiList: String) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("geometryList", geometryList)
            query.addQueryItem("poiList", poiList)
            return query
        }

        /// Geometry Filter
        public func post(_ body: PostRequest? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "geometryList" : [
        ///     {
        ///       "position" : "40.80558,-73.96548",
        ///       "radius" : 100,
        ///       "type" : "CIRCLE"
        ///     },
        ///     {
        ///       "type" : "POLYGON",
        ///       "vertices" : [
        ///         "37.7524152343544,-122.43576049804686",
        ///         "37.70660472542312,-122.43301391601562",
        ///         "37.712059855877314,-122.36434936523438",
        ///         "37.75350561243041,-122.37396240234374"
        ///       ]
        ///     }
        ///   ],
        ///   "poiList" : [
        ///     {
        ///       "address" : {
        ///         "freeformAddress" : "2880 Broadway, New York, NY 10025"
        ///       },
        ///       "poi" : {
        ///         "name" : "S Restaurant Tom's"
        ///       },
        ///       "position" : {
        ///         "lat" : 40.805579999999999,
        ///         "lon" : -73.965479999999999
        ///       }
        ///     }
        ///   ]
        /// }
        public struct PostRequest: Encodable {
            public var geometryList: [GeometryListItem]?
            public var poiList: [PoiListItem]?

            public struct GeometryListItem: Encodable {
                public var position: String?
                public var radius: Int?
                public var type: String?
                public var vertices: [String]?

                public init(position: String? = nil, radius: Int? = nil, type: String? = nil, vertices: [String]? = nil) {
                    self.position = position
                    self.radius = radius
                    self.type = type
                    self.vertices = vertices
                }
            }

            public struct PoiListItem: Encodable {
                public var address: Address?
                public var poi: Poi?
                public var position: Position?

                public struct Address: Encodable {
                    public var freeformAddress: String?

                    public init(freeformAddress: String? = nil) {
                        self.freeformAddress = freeformAddress
                    }
                }

                public struct Poi: Encodable {
                    public var name: String?

                    public init(name: String? = nil) {
                        self.name = name
                    }
                }

                public struct Position: Encodable {
                    public var lat: Double?
                    public var lon: Double?

                    public init(lat: Double? = nil, lon: Double? = nil) {
                        self.lat = lat
                        self.lon = lon
                    }
                }

                public init(address: Address? = nil, poi: Poi? = nil, position: Position? = nil) {
                    self.address = address
                    self.poi = poi
                    self.position = position
                }
            }

            public init(geometryList: [GeometryListItem]? = nil, poiList: [PoiListItem]? = nil) {
                self.geometryList = geometryList
                self.poiList = poiList
            }
        }
    }
}

extension Paths.Search.WithVersionNumber {
    public var geometrySearch: GeometrySearch {
        GeometrySearch(path: path + "/geometrySearch")
    }

    public struct GeometrySearch {
        /// Path: `/search/{versionNumber}/geometrySearch`
        public let path: String
    }
}

extension Paths.Search.WithVersionNumber.GeometrySearch {
    public func query(_ query: String) -> WithExt {
        WithExt(path: "\(path)/\(query).{ext}")
    }

    public struct WithExt {
        /// Path: `/search/{versionNumber}/geometrySearch/{query}.{ext}`
        public let path: String

        /// Geometry Search
        public func get(parameters: GetParameters? = nil) -> Request<Void> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var geometryList: String?
            public var limit: Int?
            public var language: String?
            public var extendedPostalCodesFor: String?
            public var idxSet: String?

            public init(geometryList: String? = nil, limit: Int? = nil, language: String? = nil, extendedPostalCodesFor: String? = nil, idxSet: String? = nil) {
                self.geometryList = geometryList
                self.limit = limit
                self.language = language
                self.extendedPostalCodesFor = extendedPostalCodesFor
                self.idxSet = idxSet
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("geometryList", geometryList)
                query.addQueryItem("limit", limit)
                query.addQueryItem("language", language)
                query.addQueryItem("extendedPostalCodesFor", extendedPostalCodesFor)
                query.addQueryItem("idxSet", idxSet)
                return query
            }
        }

        /// Geometry Search
        public func post(parameters: PostParameters? = nil, geometryList: [PostRequest.GeometryListItem]? = nil) -> Request<Void> {
            .post(path, query: parameters?.asQuery, body: PostRequest(geometryList: geometryList))
        }

        public struct PostParameters {
            public var limit: Int?
            public var language: String?
            public var extendedPostalCodesFor: String?
            public var idxSet: String?

            public init(limit: Int? = nil, language: String? = nil, extendedPostalCodesFor: String? = nil, idxSet: String? = nil) {
                self.limit = limit
                self.language = language
                self.extendedPostalCodesFor = extendedPostalCodesFor
                self.idxSet = idxSet
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("limit", limit)
                query.addQueryItem("language", language)
                query.addQueryItem("extendedPostalCodesFor", extendedPostalCodesFor)
                query.addQueryItem("idxSet", idxSet)
                return query
            }
        }

        /// Example:
        ///
        /// {
        ///   "geometryList" : [
        ///     {
        ///       "type" : "POLYGON",
        ///       "vertices" : [
        ///         "37.7524152343544,-122.43576049804686",
        ///         "37.70660472542312,-122.43301391601562",
        ///         "37.712059855877314,-122.36434936523438",
        ///         "37.75350561243041,-122.37396240234374"
        ///       ]
        ///     },
        ///     {
        ///       "position" : "37.71205,-121.36434",
        ///       "radius" : 6000,
        ///       "type" : "CIRCLE"
        ///     },
        ///     {
        ///       "position" : "37.31205,-121.36434",
        ///       "radius" : 1000,
        ///       "type" : "CIRCLE"
        ///     }
        ///   ]
        /// }
        public struct PostRequest: Encodable {
            public var geometryList: [GeometryListItem]?

            public struct GeometryListItem: Encodable {
                public var position: String?
                public var radius: Int?
                public var type: String?
                public var vertices: [String]?

                public init(position: String? = nil, radius: Int? = nil, type: String? = nil, vertices: [String]? = nil) {
                    self.position = position
                    self.radius = radius
                    self.type = type
                    self.vertices = vertices
                }
            }

            public init(geometryList: [GeometryListItem]? = nil) {
                self.geometryList = geometryList
            }
        }
    }
}

extension Paths.Search.WithVersionNumber {
    public var nearbySearch: NearbySearch {
        NearbySearch(path: path + "/nearbySearch")
    }

    public struct NearbySearch {
        /// Path: `/search/{versionNumber}/nearbySearch`
        public let path: String
    }
}

extension Paths.Search.WithVersionNumber.NearbySearch {
    public func ext(_ ext: String) -> With {
        With(path: "\(path)/.\(ext)")
    }

    public struct With {
        /// Path: `/search/{versionNumber}/nearbySearch/.{ext}`
        public let path: String

        /// Nearby Search
        public func get(parameters: GetParameters) -> Request<Void> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var lat: Double
            public var lon: Double
            public var limit: Int?
            public var ofs: Int?
            public var countrySet: String?
            public var radius: Int?
            public var topLeft: String?
            public var btmRight: String?
            public var language: String?
            public var extendedPostalCodesFor: String?
            public var minFuzzyLevel: Int?
            public var maxFuzzyLevel: Int?
            public var idxSet: String?
            public var view: View?

            public enum View: String, Codable, CaseIterable {
                case unified = "Unified"
                case `in` = "IN"
                case pk = "PK"
                case il = "IL"
                case ma = "MA"
            }

            public init(lat: Double, lon: Double, limit: Int? = nil, ofs: Int? = nil, countrySet: String? = nil, radius: Int? = nil, topLeft: String? = nil, btmRight: String? = nil, language: String? = nil, extendedPostalCodesFor: String? = nil, minFuzzyLevel: Int? = nil, maxFuzzyLevel: Int? = nil, idxSet: String? = nil, view: View? = nil) {
                self.lat = lat
                self.lon = lon
                self.limit = limit
                self.ofs = ofs
                self.countrySet = countrySet
                self.radius = radius
                self.topLeft = topLeft
                self.btmRight = btmRight
                self.language = language
                self.extendedPostalCodesFor = extendedPostalCodesFor
                self.minFuzzyLevel = minFuzzyLevel
                self.maxFuzzyLevel = maxFuzzyLevel
                self.idxSet = idxSet
                self.view = view
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("lat", lat)
                query.addQueryItem("lon", lon)
                query.addQueryItem("limit", limit)
                query.addQueryItem("ofs", ofs)
                query.addQueryItem("countrySet", countrySet)
                query.addQueryItem("radius", radius)
                query.addQueryItem("topLeft", topLeft)
                query.addQueryItem("btmRight", btmRight)
                query.addQueryItem("language", language)
                query.addQueryItem("extendedPostalCodesFor", extendedPostalCodesFor)
                query.addQueryItem("minFuzzyLevel", minFuzzyLevel)
                query.addQueryItem("maxFuzzyLevel", maxFuzzyLevel)
                query.addQueryItem("idxSet", idxSet)
                query.addQueryItem("view", view)
                return query
            }
        }
    }
}

extension Paths.Search.WithVersionNumber {
    public var poiSearch: PoiSearch {
        PoiSearch(path: path + "/poiSearch")
    }

    public struct PoiSearch {
        /// Path: `/search/{versionNumber}/poiSearch`
        public let path: String
    }
}

extension Paths.Search.WithVersionNumber.PoiSearch {
    public func query(_ query: String) -> WithExt {
        WithExt(path: "\(path)/\(query).{ext}")
    }

    public struct WithExt {
        /// Path: `/search/{versionNumber}/poiSearch/{query}.{ext}`
        public let path: String

        /// Points of Interest Search
        public func get(parameters: GetParameters? = nil) -> Request<Void> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isTypeahead: Bool?
            public var limit: Int?
            public var ofs: Int?
            public var countrySet: String?
            public var lat: Double?
            public var lon: Double?
            public var radius: Int?
            public var topLeft: String?
            public var btmRight: String?
            public var language: String?
            public var extendedPostalCodesFor: String?
            public var view: View?

            public enum View: String, Codable, CaseIterable {
                case unified = "Unified"
                case `in` = "IN"
                case pk = "PK"
                case il = "IL"
                case ma = "MA"
            }

            public init(isTypeahead: Bool? = nil, limit: Int? = nil, ofs: Int? = nil, countrySet: String? = nil, lat: Double? = nil, lon: Double? = nil, radius: Int? = nil, topLeft: String? = nil, btmRight: String? = nil, language: String? = nil, extendedPostalCodesFor: String? = nil, view: View? = nil) {
                self.isTypeahead = isTypeahead
                self.limit = limit
                self.ofs = ofs
                self.countrySet = countrySet
                self.lat = lat
                self.lon = lon
                self.radius = radius
                self.topLeft = topLeft
                self.btmRight = btmRight
                self.language = language
                self.extendedPostalCodesFor = extendedPostalCodesFor
                self.view = view
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("typeahead", isTypeahead)
                query.addQueryItem("limit", limit)
                query.addQueryItem("ofs", ofs)
                query.addQueryItem("countrySet", countrySet)
                query.addQueryItem("lat", lat)
                query.addQueryItem("lon", lon)
                query.addQueryItem("radius", radius)
                query.addQueryItem("topLeft", topLeft)
                query.addQueryItem("btmRight", btmRight)
                query.addQueryItem("language", language)
                query.addQueryItem("extendedPostalCodesFor", extendedPostalCodesFor)
                query.addQueryItem("view", view)
                return query
            }
        }
    }
}

extension Paths.Search.WithVersionNumber {
    public var reverseGeocode: ReverseGeocode {
        ReverseGeocode(path: path + "/reverseGeocode")
    }

    public struct ReverseGeocode {
        /// Path: `/search/{versionNumber}/reverseGeocode`
        public let path: String
    }
}

extension Paths.Search.WithVersionNumber.ReverseGeocode {
    public var crossStreet: CrossStreet {
        CrossStreet(path: path + "/crossStreet")
    }

    public struct CrossStreet {
        /// Path: `/search/{versionNumber}/reverseGeocode/crossStreet`
        public let path: String
    }
}

extension Paths.Search.WithVersionNumber.ReverseGeocode.CrossStreet {
    public func position(_ position: String) -> WithExt {
        WithExt(path: "\(path)/\(position).{ext}")
    }

    public struct WithExt {
        /// Path: `/search/{versionNumber}/reverseGeocode/crossStreet/{position}.{ext}`
        public let path: String

        /// Cross Street lookup
        public func get(parameters: GetParameters? = nil) -> Request<Void> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var limit: Int?
            public var isSpatialKeys: Bool?
            public var heading: Double?
            public var radius: Int?
            public var language: String?

            public init(limit: Int? = nil, isSpatialKeys: Bool? = nil, heading: Double? = nil, radius: Int? = nil, language: String? = nil) {
                self.limit = limit
                self.isSpatialKeys = isSpatialKeys
                self.heading = heading
                self.radius = radius
                self.language = language
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("limit", limit)
                query.addQueryItem("spatialKeys", isSpatialKeys)
                query.addQueryItem("heading", heading)
                query.addQueryItem("radius", radius)
                query.addQueryItem("language", language)
                return query
            }
        }
    }
}

extension Paths.Search.WithVersionNumber.ReverseGeocode {
    public func position(_ position: String) -> WithExt {
        WithExt(path: "\(path)/\(position).{ext}")
    }

    public struct WithExt {
        /// Path: `/search/{versionNumber}/reverseGeocode/{position}.{ext}`
        public let path: String

        /// Reverse Geocode
        public func get(parameters: GetParameters? = nil) -> Request<Void> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isSpatialKeys: Bool?
            public var isReturnSpeedLimit: Bool?
            public var heading: Double?
            public var radius: Int?
            public var number: String?
            public var returnRoadUse: Bool?
            public var roadUse: String?
            public var callback: String?

            public init(isSpatialKeys: Bool? = nil, isReturnSpeedLimit: Bool? = nil, heading: Double? = nil, radius: Int? = nil, number: String? = nil, returnRoadUse: Bool? = nil, roadUse: String? = nil, callback: String? = nil) {
                self.isSpatialKeys = isSpatialKeys
                self.isReturnSpeedLimit = isReturnSpeedLimit
                self.heading = heading
                self.radius = radius
                self.number = number
                self.returnRoadUse = returnRoadUse
                self.roadUse = roadUse
                self.callback = callback
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("spatialKeys", isSpatialKeys)
                query.addQueryItem("returnSpeedLimit", isReturnSpeedLimit)
                query.addQueryItem("heading", heading)
                query.addQueryItem("radius", radius)
                query.addQueryItem("number", number)
                query.addQueryItem("returnRoadUse", returnRoadUse)
                query.addQueryItem("roadUse", roadUse)
                query.addQueryItem("callback", callback)
                return query
            }
        }
    }
}

extension Paths.Search.WithVersionNumber {
    public var routedFilter: RoutedFilter {
        RoutedFilter(path: path + "/routedFilter")
    }

    public struct RoutedFilter {
        /// Path: `/search/{versionNumber}/routedFilter`
        public let path: String
    }
}

extension Paths.Search.WithVersionNumber.RoutedFilter {
    public func position(_ position: String) -> WithPosition {
        WithPosition(path: "\(path)/\(position)")
    }

    public struct WithPosition {
        /// Path: `/search/{versionNumber}/routedFilter/{position}`
        public let path: String
    }
}

extension Paths.Search.WithVersionNumber.RoutedFilter.WithPosition {
    public func heading(_ heading: String) -> WithExt {
        WithExt(path: "\(path)/\(heading).{ext}")
    }

    public struct WithExt {
        /// Path: `/search/{versionNumber}/routedFilter/{position}/{heading}.{ext}`
        public let path: String

        /// Routed Filter
        @available(*, deprecated, message: "Deprecated")
        public func get(poiList: String, routingTimeout: Int? = nil) -> Request<Void> {
            .get(path, query: makeGetQuery(poiList, routingTimeout))
        }

        private func makeGetQuery(_ poiList: String, _ routingTimeout: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("poiList", poiList)
            query.addQueryItem("routingTimeout", routingTimeout)
            return query
        }

        /// Routed Filter
        @available(*, deprecated, message: "Deprecated")
        public func post(routingTimeout: Int? = nil, poiList: [PostRequest.PoiListItem]? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(routingTimeout), body: PostRequest(poiList: poiList))
        }

        private func makePostQuery(_ routingTimeout: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("routingTimeout", routingTimeout)
            return query
        }

        /// Example:
        ///
        /// {
        ///   "poiList" : [
        ///     {
        ///       "address" : {
        ///         "freeformAddress" : "9500 Gilman Dr, San Diego, CA 92037"
        ///       },
        ///       "poi" : {
        ///         "name" : "University of California San Diego"
        ///       },
        ///       "position" : {
        ///         "lat" : 32.873489999999997,
        ///         "lon" : -117.23779999999999
        ///       }
        ///     },
        ///     {
        ///       "address" : {
        ///         "freeformAddress" : "7220 Trade St, San Diego, CA 92121"
        ///       },
        ///       "poi" : {
        ///         "name" : "Cleaire Advanced Emission Controls"
        ///       },
        ///       "position" : {
        ///         "lat" : 37.832740000000001,
        ///         "lon" : -122.27631
        ///       }
        ///     }
        ///   ]
        /// }
        public struct PostRequest: Encodable {
            public var poiList: [PoiListItem]?

            public struct PoiListItem: Encodable {
                public var address: Address?
                public var poi: Poi?
                public var position: Position?

                public struct Address: Encodable {
                    public var freeformAddress: String?

                    public init(freeformAddress: String? = nil) {
                        self.freeformAddress = freeformAddress
                    }
                }

                public struct Poi: Encodable {
                    public var name: String?

                    public init(name: String? = nil) {
                        self.name = name
                    }
                }

                public struct Position: Encodable {
                    public var lat: Double?
                    public var lon: Double?

                    public init(lat: Double? = nil, lon: Double? = nil) {
                        self.lat = lat
                        self.lon = lon
                    }
                }

                public init(address: Address? = nil, poi: Poi? = nil, position: Position? = nil) {
                    self.address = address
                    self.poi = poi
                    self.position = position
                }
            }

            public init(poiList: [PoiListItem]? = nil) {
                self.poiList = poiList
            }
        }
    }
}

extension Paths.Search.WithVersionNumber {
    public var routedSearch: RoutedSearch {
        RoutedSearch(path: path + "/routedSearch")
    }

    public struct RoutedSearch {
        /// Path: `/search/{versionNumber}/routedSearch`
        public let path: String
    }
}

extension Paths.Search.WithVersionNumber.RoutedSearch {
    public func query(_ query: String) -> WithQuery {
        WithQuery(path: "\(path)/\(query)")
    }

    public struct WithQuery {
        /// Path: `/search/{versionNumber}/routedSearch/{query}`
        public let path: String
    }
}

extension Paths.Search.WithVersionNumber.RoutedSearch.WithQuery {
    public func position(_ position: String) -> WithPosition {
        WithPosition(path: "\(path)/\(position)")
    }

    public struct WithPosition {
        /// Path: `/search/{versionNumber}/routedSearch/{query}/{position}`
        public let path: String
    }
}

extension Paths.Search.WithVersionNumber.RoutedSearch.WithQuery.WithPosition {
    public func heading(_ heading: String) -> WithExt {
        WithExt(path: "\(path)/\(heading).{ext}")
    }

    public struct WithExt {
        /// Path: `/search/{versionNumber}/routedSearch/{query}/{position}/{heading}.{ext}`
        public let path: String

        /// Routed Search
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters? = nil) -> Request<Void> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isTypeahead: Bool?
            public var limit: Int?
            public var multiplier: Int?
            public var routingTimeout: Int?
            public var language: String?
            public var extendedPostalCodesFor: String?
            public var idxSet: String?

            public init(isTypeahead: Bool? = nil, limit: Int? = nil, multiplier: Int? = nil, routingTimeout: Int? = nil, language: String? = nil, extendedPostalCodesFor: String? = nil, idxSet: String? = nil) {
                self.isTypeahead = isTypeahead
                self.limit = limit
                self.multiplier = multiplier
                self.routingTimeout = routingTimeout
                self.language = language
                self.extendedPostalCodesFor = extendedPostalCodesFor
                self.idxSet = idxSet
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("typeahead", isTypeahead)
                query.addQueryItem("limit", limit)
                query.addQueryItem("multiplier", multiplier)
                query.addQueryItem("routingTimeout", routingTimeout)
                query.addQueryItem("language", language)
                query.addQueryItem("extendedPostalCodesFor", extendedPostalCodesFor)
                query.addQueryItem("idxSet", idxSet)
                return query
            }
        }
    }
}

extension Paths.Search.WithVersionNumber {
    public var s: S {
        S(path: path + "/s")
    }

    public struct S {
        /// Path: `/search/{versionNumber}/s`
        public let path: String
    }
}

extension Paths.Search.WithVersionNumber.S {
    public func query(_ query: String) -> WithExt {
        WithExt(path: "\(path)/\(query).{ext}")
    }

    public struct WithExt {
        /// Path: `/search/{versionNumber}/s/{query}.{ext}`
        public let path: String

        /// Low bandwith Search
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters? = nil) -> Request<Void> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isTypeahead: Bool?
            public var limit: Int?
            public var ofs: Int?
            public var countrySet: String?
            public var lat: Double?
            public var lon: Double?
            public var radius: Int?
            public var topLeft: String?
            public var btmRight: String?
            public var language: String?
            public var idxSet: String?
            public var view: View?

            public enum View: String, Codable, CaseIterable {
                case unified = "Unified"
                case `in` = "IN"
                case pk = "PK"
                case il = "IL"
                case ma = "MA"
            }

            public init(isTypeahead: Bool? = nil, limit: Int? = nil, ofs: Int? = nil, countrySet: String? = nil, lat: Double? = nil, lon: Double? = nil, radius: Int? = nil, topLeft: String? = nil, btmRight: String? = nil, language: String? = nil, idxSet: String? = nil, view: View? = nil) {
                self.isTypeahead = isTypeahead
                self.limit = limit
                self.ofs = ofs
                self.countrySet = countrySet
                self.lat = lat
                self.lon = lon
                self.radius = radius
                self.topLeft = topLeft
                self.btmRight = btmRight
                self.language = language
                self.idxSet = idxSet
                self.view = view
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("typeahead", isTypeahead)
                query.addQueryItem("limit", limit)
                query.addQueryItem("ofs", ofs)
                query.addQueryItem("countrySet", countrySet)
                query.addQueryItem("lat", lat)
                query.addQueryItem("lon", lon)
                query.addQueryItem("radius", radius)
                query.addQueryItem("topLeft", topLeft)
                query.addQueryItem("btmRight", btmRight)
                query.addQueryItem("language", language)
                query.addQueryItem("idxSet", idxSet)
                query.addQueryItem("view", view)
                return query
            }
        }
    }
}

extension Paths.Search.WithVersionNumber {
    public var search: Search {
        Search(path: path + "/search")
    }

    public struct Search {
        /// Path: `/search/{versionNumber}/search`
        public let path: String
    }
}

extension Paths.Search.WithVersionNumber.Search {
    public func query(_ query: String) -> WithExt {
        WithExt(path: "\(path)/\(query).{ext}")
    }

    public struct WithExt {
        /// Path: `/search/{versionNumber}/search/{query}.{ext}`
        public let path: String

        /// Fuzzy Search
        public func get(parameters: GetParameters? = nil) -> Request<Void> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isTypeahead: Bool?
            public var limit: Int?
            public var ofs: Int?
            public var countrySet: String?
            public var lat: Double?
            public var lon: Double?
            public var radius: Int?
            public var topLeft: String?
            public var btmRight: String?
            public var language: String?
            public var extendedPostalCodesFor: String?
            public var minFuzzyLevel: Int?
            public var maxFuzzyLevel: Int?
            public var idxSet: String?
            public var view: View?

            public enum View: String, Codable, CaseIterable {
                case unified = "Unified"
                case `in` = "IN"
                case pk = "PK"
                case il = "IL"
                case ma = "MA"
            }

            public init(isTypeahead: Bool? = nil, limit: Int? = nil, ofs: Int? = nil, countrySet: String? = nil, lat: Double? = nil, lon: Double? = nil, radius: Int? = nil, topLeft: String? = nil, btmRight: String? = nil, language: String? = nil, extendedPostalCodesFor: String? = nil, minFuzzyLevel: Int? = nil, maxFuzzyLevel: Int? = nil, idxSet: String? = nil, view: View? = nil) {
                self.isTypeahead = isTypeahead
                self.limit = limit
                self.ofs = ofs
                self.countrySet = countrySet
                self.lat = lat
                self.lon = lon
                self.radius = radius
                self.topLeft = topLeft
                self.btmRight = btmRight
                self.language = language
                self.extendedPostalCodesFor = extendedPostalCodesFor
                self.minFuzzyLevel = minFuzzyLevel
                self.maxFuzzyLevel = maxFuzzyLevel
                self.idxSet = idxSet
                self.view = view
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("typeahead", isTypeahead)
                query.addQueryItem("limit", limit)
                query.addQueryItem("ofs", ofs)
                query.addQueryItem("countrySet", countrySet)
                query.addQueryItem("lat", lat)
                query.addQueryItem("lon", lon)
                query.addQueryItem("radius", radius)
                query.addQueryItem("topLeft", topLeft)
                query.addQueryItem("btmRight", btmRight)
                query.addQueryItem("language", language)
                query.addQueryItem("extendedPostalCodesFor", extendedPostalCodesFor)
                query.addQueryItem("minFuzzyLevel", minFuzzyLevel)
                query.addQueryItem("maxFuzzyLevel", maxFuzzyLevel)
                query.addQueryItem("idxSet", idxSet)
                query.addQueryItem("view", view)
                return query
            }
        }
    }
}

extension Paths.Search.WithVersionNumber {
    public var searchAlongRoute: SearchAlongRoute {
        SearchAlongRoute(path: path + "/searchAlongRoute")
    }

    public struct SearchAlongRoute {
        /// Path: `/search/{versionNumber}/searchAlongRoute`
        public let path: String
    }
}

extension Paths.Search.WithVersionNumber.SearchAlongRoute {
    public func query(_ query: String) -> WithExt {
        WithExt(path: "\(path)/\(query).{ext}")
    }

    public struct WithExt {
        /// Path: `/search/{versionNumber}/searchAlongRoute/{query}.{ext}`
        public let path: String

        /// Along Route Search
        public func post(maxDetourTime: Int, limit: Int? = nil, route: PostRequest.Route? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(maxDetourTime, limit), body: PostRequest(route: route))
        }

        private func makePostQuery(_ maxDetourTime: Int, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("maxDetourTime", maxDetourTime)
            query.addQueryItem("limit", limit)
            return query
        }

        /// Example:
        ///
        /// {
        ///   "route" : {
        ///     "points" : [
        ///       {
        ///         "lat" : 37.752415234354402,
        ///         "lon" : -122.43576049804686
        ///       },
        ///       {
        ///         "lat" : 37.706604725423119,
        ///         "lon" : -122.43301391601562
        ///       },
        ///       {
        ///         "lat" : 37.712059855877314,
        ///         "lon" : -122.36434936523438
        ///       },
        ///       {
        ///         "lat" : 37.753505612430409,
        ///         "lon" : -122.37396240234374
        ///       }
        ///     ]
        ///   }
        /// }
        public struct PostRequest: Encodable {
            public var route: Route?

            public struct Route: Encodable {
                public var points: [Point]?

                public struct Point: Encodable {
                    public var lat: Double?
                    public var lon: Double?

                    public init(lat: Double? = nil, lon: Double? = nil) {
                        self.lat = lat
                        self.lon = lon
                    }
                }

                public init(points: [Point]? = nil) {
                    self.points = points
                }
            }

            public init(route: Route? = nil) {
                self.route = route
            }
        }
    }
}

extension Paths.Search.WithVersionNumber {
    public func ext(_ ext: String) -> WithStructuredGeocode {
        WithStructuredGeocode(path: "\(path)/structuredGeocode.\(ext)")
    }

    public struct WithStructuredGeocode {
        /// Path: `/search/{versionNumber}/structuredGeocode.{ext}`
        public let path: String

        /// Structured Geocode
        public func get(parameters: GetParameters) -> Request<Void> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var countryCode: String
            public var limit: Int?
            public var ofs: Int?
            public var streetNumber: String?
            public var streetName: String?
            public var crossStreet: String?
            public var municipality: String?
            public var municipalitySubdivision: String?
            public var countryTertiarySubdivision: String?
            public var countrySecondarySubdivision: String?
            public var countrySubdivision: String?
            public var postalCode: String?
            public var language: String?
            public var extendedPostalCodesFor: String?

            public init(countryCode: String, limit: Int? = nil, ofs: Int? = nil, streetNumber: String? = nil, streetName: String? = nil, crossStreet: String? = nil, municipality: String? = nil, municipalitySubdivision: String? = nil, countryTertiarySubdivision: String? = nil, countrySecondarySubdivision: String? = nil, countrySubdivision: String? = nil, postalCode: String? = nil, language: String? = nil, extendedPostalCodesFor: String? = nil) {
                self.countryCode = countryCode
                self.limit = limit
                self.ofs = ofs
                self.streetNumber = streetNumber
                self.streetName = streetName
                self.crossStreet = crossStreet
                self.municipality = municipality
                self.municipalitySubdivision = municipalitySubdivision
                self.countryTertiarySubdivision = countryTertiarySubdivision
                self.countrySecondarySubdivision = countrySecondarySubdivision
                self.countrySubdivision = countrySubdivision
                self.postalCode = postalCode
                self.language = language
                self.extendedPostalCodesFor = extendedPostalCodesFor
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("countryCode", countryCode)
                query.addQueryItem("limit", limit)
                query.addQueryItem("ofs", ofs)
                query.addQueryItem("streetNumber", streetNumber)
                query.addQueryItem("streetName", streetName)
                query.addQueryItem("crossStreet", crossStreet)
                query.addQueryItem("municipality", municipality)
                query.addQueryItem("municipalitySubdivision", municipalitySubdivision)
                query.addQueryItem("countryTertiarySubdivision", countryTertiarySubdivision)
                query.addQueryItem("countrySecondarySubdivision", countrySecondarySubdivision)
                query.addQueryItem("countrySubdivision", countrySubdivision)
                query.addQueryItem("postalCode", postalCode)
                query.addQueryItem("language", language)
                query.addQueryItem("extendedPostalCodesFor", extendedPostalCodesFor)
                return query
            }
        }
    }
}

public enum Paths {}

protocol QueryEncodable {
    var asQueryValue: String { get }
}

extension Bool: QueryEncodable {
    var asQueryValue: String {
        self ? "true" : "false"
    }
}

extension Date: QueryEncodable {
    var asQueryValue: String {
        ISO8601DateFormatter().string(from: self)
    }
}

extension Double: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int32: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int64: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension String: QueryEncodable {
    var asQueryValue: String {
        self
    }
}

extension URL: QueryEncodable {
    var asQueryValue: String {
        absoluteString
    }
}

extension RawRepresentable where RawValue == String {
    var asQueryValue: String {
        rawValue
    }
}

extension Array where Element == (String, String?) {
    mutating func addQueryItem<T: RawRepresentable>(_ name: String, _ value: T?) where T.RawValue == String {
        addQueryItem(name, value?.rawValue)
    }
    
    mutating func addQueryItem(_ name: String, _ value: QueryEncodable?) {
        guard let value = value?.asQueryValue, !value.isEmpty else { return }
        append((name, value))
    }
    
    mutating func addDeepObject(_ name: String, _ query: [(String, String?)]?) {
        for (key, value) in query ?? [] {
            addQueryItem("\(name)[\(key)]", value)
        }
    }

    var asPercentEncodedQuery: String {
        var components = URLComponents()
        components.queryItems = self.map(URLQueryItem.init)
        return components.percentEncodedQuery ?? ""
    }
    
    // [("role", "admin"), ("name": "kean)] -> "role,admin,name,kean"
    var asCompactQuery: String {
        flatMap { [$0, $1] }.compactMap { $0 }.joined(separator: ",")
    }
}
