// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var cloudloading: Cloudloading {
        Cloudloading(path: "/books/v1/cloudloading")
    }

    public struct Cloudloading {
        /// Path: `/books/v1/cloudloading`
        public let path: String
    }
}

extension Paths.Cloudloading {
    public var addBook: AddBook {
        AddBook(path: path + "/addBook")
    }

    public struct AddBook {
        /// Path: `/books/v1/cloudloading/addBook`
        public let path: String

        /// Add a user-upload volume and triggers processing.
        public func post(parameters: PostParameters? = nil) -> Request<GoogleBooksAPI.BooksCloudloadingResource> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            public var driveDocumentID: String?
            public var mimeType: String?
            public var name: String?
            public var uploadClientToken: String?

            public init(driveDocumentID: String? = nil, mimeType: String? = nil, name: String? = nil, uploadClientToken: String? = nil) {
                self.driveDocumentID = driveDocumentID
                self.mimeType = mimeType
                self.name = name
                self.uploadClientToken = uploadClientToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["drive_document_id": driveDocumentID])
                encoder.encode(["mime_type": mimeType])
                encoder.encode(["name": name])
                encoder.encode(["upload_client_token": uploadClientToken])
                return encoder.items
            }
        }
    }
}

extension Paths.Cloudloading {
    public var deleteBook: DeleteBook {
        DeleteBook(path: path + "/deleteBook")
    }

    public struct DeleteBook {
        /// Path: `/books/v1/cloudloading/deleteBook`
        public let path: String

        /// Remove the book and its contents
        public func post(volumeID: String) -> Request<[String: AnyJSON]> {
            .post(path, query: makePostQuery(volumeID))
        }

        private func makePostQuery(_ volumeID: String) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(["volumeId": volumeID])
            return encoder.items
        }
    }
}

extension Paths.Cloudloading {
    public var updateBook: UpdateBook {
        UpdateBook(path: path + "/updateBook")
    }

    public struct UpdateBook {
        /// Path: `/books/v1/cloudloading/updateBook`
        public let path: String

        /// Updates a user-upload volume.
        public func post(_ body: GoogleBooksAPI.BooksCloudloadingResource? = nil) -> Request<GoogleBooksAPI.BooksCloudloadingResource> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var dictionary: Dictionary {
        Dictionary(path: "/books/v1/dictionary")
    }

    public struct Dictionary {
        /// Path: `/books/v1/dictionary`
        public let path: String
    }
}

extension Paths.Dictionary {
    public var listOfflineMetadata: ListOfflineMetadata {
        ListOfflineMetadata(path: path + "/listOfflineMetadata")
    }

    public struct ListOfflineMetadata {
        /// Path: `/books/v1/dictionary/listOfflineMetadata`
        public let path: String

        /// Returns a list of offline dictionary metadata available
        public func get(cpksver: String) -> Request<GoogleBooksAPI.Metadata> {
            .get(path, query: makeGetQuery(cpksver))
        }

        private func makeGetQuery(_ cpksver: String) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(["cpksver": cpksver])
            return encoder.items
        }
    }
}

extension Paths {
    public static var familysharing: Familysharing {
        Familysharing(path: "/books/v1/familysharing")
    }

    public struct Familysharing {
        /// Path: `/books/v1/familysharing`
        public let path: String
    }
}

extension Paths.Familysharing {
    public var getFamilyInfo: GetFamilyInfo {
        GetFamilyInfo(path: path + "/getFamilyInfo")
    }

    public struct GetFamilyInfo {
        /// Path: `/books/v1/familysharing/getFamilyInfo`
        public let path: String

        /// Gets information regarding the family that the user is part of.
        public func get(source: String? = nil) -> Request<GoogleBooksAPI.FamilyInfo> {
            .get(path, query: makeGetQuery(source))
        }

        private func makeGetQuery(_ source: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(["source": source])
            return encoder.items
        }
    }
}

extension Paths.Familysharing {
    public var share: Share {
        Share(path: path + "/share")
    }

    public struct Share {
        /// Path: `/books/v1/familysharing/share`
        public let path: String

        /// Initiates sharing of the content with the user's family. Empty response indicates success.
        public func post(parameters: PostParameters? = nil) -> Request<[String: AnyJSON]> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            public var docID: String?
            public var source: String?
            public var volumeID: String?

            public init(docID: String? = nil, source: String? = nil, volumeID: String? = nil) {
                self.docID = docID
                self.source = source
                self.volumeID = volumeID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["docId": docID])
                encoder.encode(["source": source])
                encoder.encode(["volumeId": volumeID])
                return encoder.items
            }
        }
    }
}

extension Paths.Familysharing {
    public var unshare: Unshare {
        Unshare(path: path + "/unshare")
    }

    public struct Unshare {
        /// Path: `/books/v1/familysharing/unshare`
        public let path: String

        /// Initiates revoking content that has already been shared with the user's family. Empty response indicates success.
        public func post(parameters: PostParameters? = nil) -> Request<[String: AnyJSON]> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            public var docID: String?
            public var source: String?
            public var volumeID: String?

            public init(docID: String? = nil, source: String? = nil, volumeID: String? = nil) {
                self.docID = docID
                self.source = source
                self.volumeID = volumeID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["docId": docID])
                encoder.encode(["source": source])
                encoder.encode(["volumeId": volumeID])
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var myconfig: Myconfig {
        Myconfig(path: "/books/v1/myconfig")
    }

    public struct Myconfig {
        /// Path: `/books/v1/myconfig`
        public let path: String
    }
}

extension Paths.Myconfig {
    public var getUserSettings: GetUserSettings {
        GetUserSettings(path: path + "/getUserSettings")
    }

    public struct GetUserSettings {
        /// Path: `/books/v1/myconfig/getUserSettings`
        public let path: String

        /// Gets the current settings for the user.
        public func get(country: String? = nil) -> Request<GoogleBooksAPI.Usersettings> {
            .get(path, query: makeGetQuery(country))
        }

        private func makeGetQuery(_ country: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(["country": country])
            return encoder.items
        }
    }
}

extension Paths.Myconfig {
    public var releaseDownloadAccess: ReleaseDownloadAccess {
        ReleaseDownloadAccess(path: path + "/releaseDownloadAccess")
    }

    public struct ReleaseDownloadAccess {
        /// Path: `/books/v1/myconfig/releaseDownloadAccess`
        public let path: String

        /// Release downloaded content access restriction.
        public func post(parameters: PostParameters) -> Request<GoogleBooksAPI.DownloadAccesses> {
            .post(path, query: parameters.asQuery)
        }

        public struct PostParameters {
            public var cpksver: String
            public var volumeIDs: [String]
            public var locale: String?
            public var source: String?

            public init(cpksver: String, volumeIDs: [String], locale: String? = nil, source: String? = nil) {
                self.cpksver = cpksver
                self.volumeIDs = volumeIDs
                self.locale = locale
                self.source = source
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["cpksver": cpksver])
                encoder.encode(["volumeIds": volumeIDs])
                encoder.encode(["locale": locale])
                encoder.encode(["source": source])
                return encoder.items
            }
        }
    }
}

extension Paths.Myconfig {
    public var requestAccess: RequestAccess {
        RequestAccess(path: path + "/requestAccess")
    }

    public struct RequestAccess {
        /// Path: `/books/v1/myconfig/requestAccess`
        public let path: String

        /// Request concurrent and download access restrictions.
        public func post(parameters: PostParameters) -> Request<GoogleBooksAPI.RequestAccessData> {
            .post(path, query: parameters.asQuery)
        }

        public struct PostParameters {
            public var cpksver: String
            public var nonce: String
            public var source: String
            public var volumeID: String
            public var licenseTypes: LicenseTypes?
            public var locale: String?

            public enum LicenseTypes: String, Codable, CaseIterable {
                case licenseTypesUndefined = "LICENSE_TYPES_UNDEFINED"
                case both = "BOTH"
                case concurrent = "CONCURRENT"
                case download = "DOWNLOAD"
            }

            public init(cpksver: String, nonce: String, source: String, volumeID: String, licenseTypes: LicenseTypes? = nil, locale: String? = nil) {
                self.cpksver = cpksver
                self.nonce = nonce
                self.source = source
                self.volumeID = volumeID
                self.licenseTypes = licenseTypes
                self.locale = locale
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["cpksver": cpksver])
                encoder.encode(["nonce": nonce])
                encoder.encode(["source": source])
                encoder.encode(["volumeId": volumeID])
                encoder.encode(["licenseTypes": licenseTypes])
                encoder.encode(["locale": locale])
                return encoder.items
            }
        }
    }
}

extension Paths.Myconfig {
    public var syncVolumeLicenses: SyncVolumeLicenses {
        SyncVolumeLicenses(path: path + "/syncVolumeLicenses")
    }

    public struct SyncVolumeLicenses {
        /// Path: `/books/v1/myconfig/syncVolumeLicenses`
        public let path: String

        /// Request downloaded content access for specified volumes on the My eBooks shelf.
        public func post(parameters: PostParameters) -> Request<GoogleBooksAPI.Volumes> {
            .post(path, query: parameters.asQuery)
        }

        public struct PostParameters {
            public var cpksver: String
            public var nonce: String
            public var source: String
            public var features: [Features]?
            public var isIncludeNonComicsSeries: Bool?
            public var locale: String?
            public var isShowPreorders: Bool?
            public var volumeIDs: [String]?

            public enum Features: String, Codable, CaseIterable {
                case featuresUndefined = "FEATURES_UNDEFINED"
                case rentals = "RENTALS"
            }

            public init(cpksver: String, nonce: String, source: String, features: [Features]? = nil, isIncludeNonComicsSeries: Bool? = nil, locale: String? = nil, isShowPreorders: Bool? = nil, volumeIDs: [String]? = nil) {
                self.cpksver = cpksver
                self.nonce = nonce
                self.source = source
                self.features = features
                self.isIncludeNonComicsSeries = isIncludeNonComicsSeries
                self.locale = locale
                self.isShowPreorders = isShowPreorders
                self.volumeIDs = volumeIDs
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["cpksver": cpksver])
                encoder.encode(["nonce": nonce])
                encoder.encode(["source": source])
                encoder.encode(["features": features])
                encoder.encode(["includeNonComicsSeries": isIncludeNonComicsSeries])
                encoder.encode(["locale": locale])
                encoder.encode(["showPreorders": isShowPreorders])
                encoder.encode(["volumeIds": volumeIDs])
                return encoder.items
            }
        }
    }
}

extension Paths.Myconfig {
    public var updateUserSettings: UpdateUserSettings {
        UpdateUserSettings(path: path + "/updateUserSettings")
    }

    public struct UpdateUserSettings {
        /// Path: `/books/v1/myconfig/updateUserSettings`
        public let path: String

        /// Sets the settings for the user. If a sub-object is specified, it will overwrite the existing sub-object stored in the server. Unspecified sub-objects will retain the existing value.
        public func post(_ body: GoogleBooksAPI.Usersettings? = nil) -> Request<GoogleBooksAPI.Usersettings> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var mylibrary: Mylibrary {
        Mylibrary(path: "/books/v1/mylibrary")
    }

    public struct Mylibrary {
        /// Path: `/books/v1/mylibrary`
        public let path: String
    }
}

extension Paths.Mylibrary {
    public var annotations: Annotations {
        Annotations(path: path + "/annotations")
    }

    public struct Annotations {
        /// Path: `/books/v1/mylibrary/annotations`
        public let path: String

        /// Retrieves a list of annotations, possibly filtered.
        public func get(parameters: GetParameters? = nil) -> Request<GoogleBooksAPI.Annotations> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var contentVersion: String?
            public var layerID: String?
            public var layerIDs: [String]?
            public var maxResults: Int?
            public var pageToken: String?
            public var isShowDeleted: Bool?
            public var source: String?
            public var updatedMax: String?
            public var updatedMin: String?
            public var volumeID: String?

            public init(contentVersion: String? = nil, layerID: String? = nil, layerIDs: [String]? = nil, maxResults: Int? = nil, pageToken: String? = nil, isShowDeleted: Bool? = nil, source: String? = nil, updatedMax: String? = nil, updatedMin: String? = nil, volumeID: String? = nil) {
                self.contentVersion = contentVersion
                self.layerID = layerID
                self.layerIDs = layerIDs
                self.maxResults = maxResults
                self.pageToken = pageToken
                self.isShowDeleted = isShowDeleted
                self.source = source
                self.updatedMax = updatedMax
                self.updatedMin = updatedMin
                self.volumeID = volumeID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["contentVersion": contentVersion])
                encoder.encode(["layerId": layerID])
                encoder.encode(["layerIds": layerIDs])
                encoder.encode(["maxResults": maxResults])
                encoder.encode(["pageToken": pageToken])
                encoder.encode(["showDeleted": isShowDeleted])
                encoder.encode(["source": source])
                encoder.encode(["updatedMax": updatedMax])
                encoder.encode(["updatedMin": updatedMin])
                encoder.encode(["volumeId": volumeID])
                return encoder.items
            }
        }

        /// Inserts a new annotation.
        public func post(parameters: PostParameters? = nil, _ body: GoogleBooksAPI.Annotation? = nil) -> Request<GoogleBooksAPI.Annotation> {
            .post(path, query: parameters?.asQuery, body: body)
        }

        public struct PostParameters {
            public var annotationID: String?
            public var country: String?
            public var isShowOnlySummaryInResponse: Bool?
            public var source: String?

            public init(annotationID: String? = nil, country: String? = nil, isShowOnlySummaryInResponse: Bool? = nil, source: String? = nil) {
                self.annotationID = annotationID
                self.country = country
                self.isShowOnlySummaryInResponse = isShowOnlySummaryInResponse
                self.source = source
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["annotationId": annotationID])
                encoder.encode(["country": country])
                encoder.encode(["showOnlySummaryInResponse": isShowOnlySummaryInResponse])
                encoder.encode(["source": source])
                return encoder.items
            }
        }
    }
}

extension Paths.Mylibrary.Annotations {
    public var summary: Summary {
        Summary(path: path + "/summary")
    }

    public struct Summary {
        /// Path: `/books/v1/mylibrary/annotations/summary`
        public let path: String

        /// Gets the summary of specified layers.
        public func post(layerIDs: [String], volumeID: String) -> Request<GoogleBooksAPI.AnnotationsSummary> {
            .post(path, query: makePostQuery(layerIDs, volumeID))
        }

        private func makePostQuery(_ layerIDs: [String], _ volumeID: String) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(["layerIds": layerIDs])
            encoder.encode(["volumeId": volumeID])
            return encoder.items
        }
    }
}

extension Paths.Mylibrary.Annotations {
    public func annotationID(_ annotationID: String) -> WithAnnotationID {
        WithAnnotationID(path: "\(path)/\(annotationID)")
    }

    public struct WithAnnotationID {
        /// Path: `/books/v1/mylibrary/annotations/{annotationId}`
        public let path: String

        /// Updates an existing annotation.
        public func put(source: String? = nil, _ body: GoogleBooksAPI.Annotation? = nil) -> Request<GoogleBooksAPI.Annotation> {
            .put(path, query: makePutQuery(source), body: body)
        }

        private func makePutQuery(_ source: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(["source": source])
            return encoder.items
        }

        /// Deletes an annotation.
        public func delete(source: String? = nil) -> Request<[String: AnyJSON]> {
            .delete(path, query: makeDeleteQuery(source))
        }

        private func makeDeleteQuery(_ source: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(["source": source])
            return encoder.items
        }
    }
}

extension Paths.Mylibrary {
    public var bookshelves: Bookshelves {
        Bookshelves(path: path + "/bookshelves")
    }

    public struct Bookshelves {
        /// Path: `/books/v1/mylibrary/bookshelves`
        public let path: String

        /// Retrieves a list of bookshelves belonging to the authenticated user.
        public func get(source: String? = nil) -> Request<GoogleBooksAPI.Bookshelves> {
            .get(path, query: makeGetQuery(source))
        }

        private func makeGetQuery(_ source: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(["source": source])
            return encoder.items
        }
    }
}

extension Paths.Mylibrary.Bookshelves {
    public func shelf(_ shelf: String) -> WithShelf {
        WithShelf(path: "\(path)/\(shelf)")
    }

    public struct WithShelf {
        /// Path: `/books/v1/mylibrary/bookshelves/{shelf}`
        public let path: String

        /// Retrieves metadata for a specific bookshelf belonging to the authenticated user.
        public func get(source: String? = nil) -> Request<GoogleBooksAPI.Bookshelf> {
            .get(path, query: makeGetQuery(source))
        }

        private func makeGetQuery(_ source: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(["source": source])
            return encoder.items
        }
    }
}

extension Paths.Mylibrary.Bookshelves.WithShelf {
    public var addVolume: AddVolume {
        AddVolume(path: path + "/addVolume")
    }

    public struct AddVolume {
        /// Path: `/books/v1/mylibrary/bookshelves/{shelf}/addVolume`
        public let path: String

        /// Adds a volume to a bookshelf.
        public func post(parameters: PostParameters) -> Request<[String: AnyJSON]> {
            .post(path, query: parameters.asQuery)
        }

        public struct PostParameters {
            public var volumeID: String
            public var reason: Reason?
            public var source: String?

            public enum Reason: String, Codable, CaseIterable {
                case reasonUndefined = "REASON_UNDEFINED"
                case iosPrex = "IOS_PREX"
                case iosSearch = "IOS_SEARCH"
                case onboarding = "ONBOARDING"
            }

            public init(volumeID: String, reason: Reason? = nil, source: String? = nil) {
                self.volumeID = volumeID
                self.reason = reason
                self.source = source
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["volumeId": volumeID])
                encoder.encode(["reason": reason])
                encoder.encode(["source": source])
                return encoder.items
            }
        }
    }
}

extension Paths.Mylibrary.Bookshelves.WithShelf {
    public var clearVolumes: ClearVolumes {
        ClearVolumes(path: path + "/clearVolumes")
    }

    public struct ClearVolumes {
        /// Path: `/books/v1/mylibrary/bookshelves/{shelf}/clearVolumes`
        public let path: String

        /// Clears all volumes from a bookshelf.
        public func post(source: String? = nil) -> Request<[String: AnyJSON]> {
            .post(path, query: makePostQuery(source))
        }

        private func makePostQuery(_ source: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(["source": source])
            return encoder.items
        }
    }
}

extension Paths.Mylibrary.Bookshelves.WithShelf {
    public var moveVolume: MoveVolume {
        MoveVolume(path: path + "/moveVolume")
    }

    public struct MoveVolume {
        /// Path: `/books/v1/mylibrary/bookshelves/{shelf}/moveVolume`
        public let path: String

        /// Moves a volume within a bookshelf.
        public func post(parameters: PostParameters) -> Request<[String: AnyJSON]> {
            .post(path, query: parameters.asQuery)
        }

        public struct PostParameters {
            public var volumeID: String
            public var volumePosition: Int
            public var source: String?

            public init(volumeID: String, volumePosition: Int, source: String? = nil) {
                self.volumeID = volumeID
                self.volumePosition = volumePosition
                self.source = source
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["volumeId": volumeID])
                encoder.encode(["volumePosition": volumePosition])
                encoder.encode(["source": source])
                return encoder.items
            }
        }
    }
}

extension Paths.Mylibrary.Bookshelves.WithShelf {
    public var removeVolume: RemoveVolume {
        RemoveVolume(path: path + "/removeVolume")
    }

    public struct RemoveVolume {
        /// Path: `/books/v1/mylibrary/bookshelves/{shelf}/removeVolume`
        public let path: String

        /// Removes a volume from a bookshelf.
        public func post(parameters: PostParameters) -> Request<[String: AnyJSON]> {
            .post(path, query: parameters.asQuery)
        }

        public struct PostParameters {
            public var volumeID: String
            public var reason: Reason?
            public var source: String?

            public enum Reason: String, Codable, CaseIterable {
                case reasonUndefined = "REASON_UNDEFINED"
                case onboarding = "ONBOARDING"
            }

            public init(volumeID: String, reason: Reason? = nil, source: String? = nil) {
                self.volumeID = volumeID
                self.reason = reason
                self.source = source
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["volumeId": volumeID])
                encoder.encode(["reason": reason])
                encoder.encode(["source": source])
                return encoder.items
            }
        }
    }
}

extension Paths.Mylibrary.Bookshelves.WithShelf {
    public var volumes: Volumes {
        Volumes(path: path + "/volumes")
    }

    public struct Volumes {
        /// Path: `/books/v1/mylibrary/bookshelves/{shelf}/volumes`
        public let path: String

        /// Gets volume information for volumes on a bookshelf.
        public func get(parameters: GetParameters? = nil) -> Request<GoogleBooksAPI.Volumes> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var country: String?
            public var maxResults: Int?
            public var projection: Projection?
            public var q: String?
            public var isShowPreorders: Bool?
            public var source: String?
            public var startIndex: Int?

            public enum Projection: String, Codable, CaseIterable {
                case projectionUndefined = "PROJECTION_UNDEFINED"
                case full = "FULL"
                case lite = "LITE"
            }

            public init(country: String? = nil, maxResults: Int? = nil, projection: Projection? = nil, q: String? = nil, isShowPreorders: Bool? = nil, source: String? = nil, startIndex: Int? = nil) {
                self.country = country
                self.maxResults = maxResults
                self.projection = projection
                self.q = q
                self.isShowPreorders = isShowPreorders
                self.source = source
                self.startIndex = startIndex
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["country": country])
                encoder.encode(["maxResults": maxResults])
                encoder.encode(["projection": projection])
                encoder.encode(["q": q])
                encoder.encode(["showPreorders": isShowPreorders])
                encoder.encode(["source": source])
                encoder.encode(["startIndex": startIndex])
                return encoder.items
            }
        }
    }
}

extension Paths.Mylibrary {
    public var readingpositions: Readingpositions {
        Readingpositions(path: path + "/readingpositions")
    }

    public struct Readingpositions {
        /// Path: `/books/v1/mylibrary/readingpositions`
        public let path: String
    }
}

extension Paths.Mylibrary.Readingpositions {
    public func volumeID(_ volumeID: String) -> WithVolumeID {
        WithVolumeID(path: "\(path)/\(volumeID)")
    }

    public struct WithVolumeID {
        /// Path: `/books/v1/mylibrary/readingpositions/{volumeId}`
        public let path: String

        /// Retrieves my reading position information for a volume.
        public func get(contentVersion: String? = nil, source: String? = nil) -> Request<GoogleBooksAPI.ReadingPosition> {
            .get(path, query: makeGetQuery(contentVersion, source))
        }

        private func makeGetQuery(_ contentVersion: String?, _ source: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(["contentVersion": contentVersion])
            encoder.encode(["source": source])
            return encoder.items
        }
    }
}

extension Paths.Mylibrary.Readingpositions.WithVolumeID {
    public var setPosition: SetPosition {
        SetPosition(path: path + "/setPosition")
    }

    public struct SetPosition {
        /// Path: `/books/v1/mylibrary/readingpositions/{volumeId}/setPosition`
        public let path: String

        /// Sets my reading position information for a volume.
        public func post(parameters: PostParameters) -> Request<[String: AnyJSON]> {
            .post(path, query: parameters.asQuery)
        }

        public struct PostParameters {
            public var position: String
            public var timestamp: String
            public var action: Action?
            public var contentVersion: String?
            public var deviceCookie: String?
            public var source: String?

            public enum Action: String, Codable, CaseIterable {
                case actionUndefined = "ACTION_UNDEFINED"
                case bookmark
                case chapter
                case nextPage = "next-page"
                case prevPage = "prev-page"
                case scroll
                case search
            }

            public init(position: String, timestamp: String, action: Action? = nil, contentVersion: String? = nil, deviceCookie: String? = nil, source: String? = nil) {
                self.position = position
                self.timestamp = timestamp
                self.action = action
                self.contentVersion = contentVersion
                self.deviceCookie = deviceCookie
                self.source = source
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["position": position])
                encoder.encode(["timestamp": timestamp])
                encoder.encode(["action": action])
                encoder.encode(["contentVersion": contentVersion])
                encoder.encode(["deviceCookie": deviceCookie])
                encoder.encode(["source": source])
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var notification: Notification {
        Notification(path: "/books/v1/notification")
    }

    public struct Notification {
        /// Path: `/books/v1/notification`
        public let path: String
    }
}

extension Paths.Notification {
    public var get: Get {
        Get(path: path + "/get")
    }

    public struct Get {
        /// Path: `/books/v1/notification/get`
        public let path: String

        /// Returns notification details for a given notification id.
        public func get(parameters: GetParameters) -> Request<GoogleBooksAPI.Notification> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var notificationID: String
            public var locale: String?
            public var source: String?

            public init(notificationID: String, locale: String? = nil, source: String? = nil) {
                self.notificationID = notificationID
                self.locale = locale
                self.source = source
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["notification_id": notificationID])
                encoder.encode(["locale": locale])
                encoder.encode(["source": source])
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var onboarding: Onboarding {
        Onboarding(path: "/books/v1/onboarding")
    }

    public struct Onboarding {
        /// Path: `/books/v1/onboarding`
        public let path: String
    }
}

extension Paths.Onboarding {
    public var listCategories: ListCategories {
        ListCategories(path: path + "/listCategories")
    }

    public struct ListCategories {
        /// Path: `/books/v1/onboarding/listCategories`
        public let path: String

        /// List categories for onboarding experience.
        public func get(locale: String? = nil) -> Request<GoogleBooksAPI.Category> {
            .get(path, query: makeGetQuery(locale))
        }

        private func makeGetQuery(_ locale: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(["locale": locale])
            return encoder.items
        }
    }
}

extension Paths.Onboarding {
    public var listCategoryVolumes: ListCategoryVolumes {
        ListCategoryVolumes(path: path + "/listCategoryVolumes")
    }

    public struct ListCategoryVolumes {
        /// Path: `/books/v1/onboarding/listCategoryVolumes`
        public let path: String

        /// List available volumes under categories for onboarding experience.
        public func get(parameters: GetParameters? = nil) -> Request<GoogleBooksAPI.Volume2> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var categoryID: [String]?
            public var locale: String?
            public var maxAllowedMaturityRating: MaxAllowedMaturityRating?
            public var pageSize: Int?
            public var pageToken: String?

            public enum MaxAllowedMaturityRating: String, Codable, CaseIterable {
                case maxAllowedMaturityRatingUndefined = "MAX_ALLOWED_MATURITY_RATING_UNDEFINED"
                case mature = "MATURE"
                case notMature = "not-mature"
            }

            public init(categoryID: [String]? = nil, locale: String? = nil, maxAllowedMaturityRating: MaxAllowedMaturityRating? = nil, pageSize: Int? = nil, pageToken: String? = nil) {
                self.categoryID = categoryID
                self.locale = locale
                self.maxAllowedMaturityRating = maxAllowedMaturityRating
                self.pageSize = pageSize
                self.pageToken = pageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["categoryId": categoryID])
                encoder.encode(["locale": locale])
                encoder.encode(["maxAllowedMaturityRating": maxAllowedMaturityRating])
                encoder.encode(["pageSize": pageSize])
                encoder.encode(["pageToken": pageToken])
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var personalizedstream: Personalizedstream {
        Personalizedstream(path: "/books/v1/personalizedstream")
    }

    public struct Personalizedstream {
        /// Path: `/books/v1/personalizedstream`
        public let path: String
    }
}

extension Paths.Personalizedstream {
    public var get: Get {
        Get(path: path + "/get")
    }

    public struct Get {
        /// Path: `/books/v1/personalizedstream/get`
        public let path: String

        /// Returns a stream of personalized book clusters
        public func get(parameters: GetParameters? = nil) -> Request<GoogleBooksAPI.Discoveryclusters> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var locale: String?
            public var maxAllowedMaturityRating: MaxAllowedMaturityRating?
            public var source: String?

            public enum MaxAllowedMaturityRating: String, Codable, CaseIterable {
                case maxAllowedMaturityRatingUndefined = "MAX_ALLOWED_MATURITY_RATING_UNDEFINED"
                case mature = "MATURE"
                case notMature = "not-mature"
            }

            public init(locale: String? = nil, maxAllowedMaturityRating: MaxAllowedMaturityRating? = nil, source: String? = nil) {
                self.locale = locale
                self.maxAllowedMaturityRating = maxAllowedMaturityRating
                self.source = source
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["locale": locale])
                encoder.encode(["maxAllowedMaturityRating": maxAllowedMaturityRating])
                encoder.encode(["source": source])
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var promooffer: Promooffer {
        Promooffer(path: "/books/v1/promooffer")
    }

    public struct Promooffer {
        /// Path: `/books/v1/promooffer`
        public let path: String
    }
}

extension Paths.Promooffer {
    public var accept: Accept {
        Accept(path: path + "/accept")
    }

    public struct Accept {
        /// Path: `/books/v1/promooffer/accept`
        public let path: String

        /// Accepts the promo offer.
        public func post(parameters: PostParameters? = nil) -> Request<[String: AnyJSON]> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            public var androidID: String?
            public var device: String?
            public var manufacturer: String?
            public var model: String?
            public var offerID: String?
            public var product: String?
            public var serial: String?
            public var volumeID: String?

            public init(androidID: String? = nil, device: String? = nil, manufacturer: String? = nil, model: String? = nil, offerID: String? = nil, product: String? = nil, serial: String? = nil, volumeID: String? = nil) {
                self.androidID = androidID
                self.device = device
                self.manufacturer = manufacturer
                self.model = model
                self.offerID = offerID
                self.product = product
                self.serial = serial
                self.volumeID = volumeID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["androidId": androidID])
                encoder.encode(["device": device])
                encoder.encode(["manufacturer": manufacturer])
                encoder.encode(["model": model])
                encoder.encode(["offerId": offerID])
                encoder.encode(["product": product])
                encoder.encode(["serial": serial])
                encoder.encode(["volumeId": volumeID])
                return encoder.items
            }
        }
    }
}

extension Paths.Promooffer {
    public var dismiss: Dismiss {
        Dismiss(path: path + "/dismiss")
    }

    public struct Dismiss {
        /// Path: `/books/v1/promooffer/dismiss`
        public let path: String

        /// Marks the promo offer as dismissed.
        public func post(parameters: PostParameters? = nil) -> Request<[String: AnyJSON]> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            public var androidID: String?
            public var device: String?
            public var manufacturer: String?
            public var model: String?
            public var offerID: String?
            public var product: String?
            public var serial: String?

            public init(androidID: String? = nil, device: String? = nil, manufacturer: String? = nil, model: String? = nil, offerID: String? = nil, product: String? = nil, serial: String? = nil) {
                self.androidID = androidID
                self.device = device
                self.manufacturer = manufacturer
                self.model = model
                self.offerID = offerID
                self.product = product
                self.serial = serial
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["androidId": androidID])
                encoder.encode(["device": device])
                encoder.encode(["manufacturer": manufacturer])
                encoder.encode(["model": model])
                encoder.encode(["offerId": offerID])
                encoder.encode(["product": product])
                encoder.encode(["serial": serial])
                return encoder.items
            }
        }
    }
}

extension Paths.Promooffer {
    public var get: Get {
        Get(path: path + "/get")
    }

    public struct Get {
        /// Path: `/books/v1/promooffer/get`
        public let path: String

        /// Returns a list of promo offers available to the user
        public func get(parameters: GetParameters? = nil) -> Request<GoogleBooksAPI.Offers> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var androidID: String?
            public var device: String?
            public var manufacturer: String?
            public var model: String?
            public var product: String?
            public var serial: String?

            public init(androidID: String? = nil, device: String? = nil, manufacturer: String? = nil, model: String? = nil, product: String? = nil, serial: String? = nil) {
                self.androidID = androidID
                self.device = device
                self.manufacturer = manufacturer
                self.model = model
                self.product = product
                self.serial = serial
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["androidId": androidID])
                encoder.encode(["device": device])
                encoder.encode(["manufacturer": manufacturer])
                encoder.encode(["model": model])
                encoder.encode(["product": product])
                encoder.encode(["serial": serial])
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var series: Series {
        Series(path: "/books/v1/series")
    }

    public struct Series {
        /// Path: `/books/v1/series`
        public let path: String
    }
}

extension Paths.Series {
    public var get: Get {
        Get(path: path + "/get")
    }

    public struct Get {
        /// Path: `/books/v1/series/get`
        public let path: String

        /// Returns Series metadata for the given series ids.
        public func get(seriesID: [String]) -> Request<GoogleBooksAPI.Series> {
            .get(path, query: makeGetQuery(seriesID))
        }

        private func makeGetQuery(_ seriesID: [String]) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(["series_id": seriesID])
            return encoder.items
        }
    }
}

extension Paths.Series {
    public var membership: Membership {
        Membership(path: path + "/membership")
    }

    public struct Membership {
        /// Path: `/books/v1/series/membership`
        public let path: String
    }
}

extension Paths.Series.Membership {
    public var get: Get {
        Get(path: path + "/get")
    }

    public struct Get {
        /// Path: `/books/v1/series/membership/get`
        public let path: String

        /// Returns Series membership data given the series id.
        public func get(parameters: GetParameters) -> Request<GoogleBooksAPI.Seriesmembership> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var seriesID: String
            public var pageSize: Int?
            public var pageToken: String?

            public init(seriesID: String, pageSize: Int? = nil, pageToken: String? = nil) {
                self.seriesID = seriesID
                self.pageSize = pageSize
                self.pageToken = pageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["series_id": seriesID])
                encoder.encode(["page_size": pageSize])
                encoder.encode(["page_token": pageToken])
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var users: Users {
        Users(path: "/books/v1/users")
    }

    public struct Users {
        /// Path: `/books/v1/users`
        public let path: String
    }
}

extension Paths.Users {
    public func userID(_ userID: String) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/books/v1/users/{userId}`
        public let path: String
    }
}

extension Paths.Users.WithUserID {
    public var bookshelves: Bookshelves {
        Bookshelves(path: path + "/bookshelves")
    }

    public struct Bookshelves {
        /// Path: `/books/v1/users/{userId}/bookshelves`
        public let path: String

        /// Retrieves a list of public bookshelves for the specified user.
        public func get(source: String? = nil) -> Request<GoogleBooksAPI.Bookshelves> {
            .get(path, query: makeGetQuery(source))
        }

        private func makeGetQuery(_ source: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(["source": source])
            return encoder.items
        }
    }
}

extension Paths.Users.WithUserID.Bookshelves {
    public func shelf(_ shelf: String) -> WithShelf {
        WithShelf(path: "\(path)/\(shelf)")
    }

    public struct WithShelf {
        /// Path: `/books/v1/users/{userId}/bookshelves/{shelf}`
        public let path: String

        /// Retrieves metadata for a specific bookshelf for the specified user.
        public func get(source: String? = nil) -> Request<GoogleBooksAPI.Bookshelf> {
            .get(path, query: makeGetQuery(source))
        }

        private func makeGetQuery(_ source: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(["source": source])
            return encoder.items
        }
    }
}

extension Paths.Users.WithUserID.Bookshelves.WithShelf {
    public var volumes: Volumes {
        Volumes(path: path + "/volumes")
    }

    public struct Volumes {
        /// Path: `/books/v1/users/{userId}/bookshelves/{shelf}/volumes`
        public let path: String

        /// Retrieves volumes in a specific bookshelf for the specified user.
        public func get(parameters: GetParameters? = nil) -> Request<GoogleBooksAPI.Volumes> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            public var isShowPreorders: Bool?
            public var source: String?
            public var startIndex: Int?

            public init(maxResults: Int? = nil, isShowPreorders: Bool? = nil, source: String? = nil, startIndex: Int? = nil) {
                self.maxResults = maxResults
                self.isShowPreorders = isShowPreorders
                self.source = source
                self.startIndex = startIndex
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["maxResults": maxResults])
                encoder.encode(["showPreorders": isShowPreorders])
                encoder.encode(["source": source])
                encoder.encode(["startIndex": startIndex])
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var volumes: Volumes {
        Volumes(path: "/books/v1/volumes")
    }

    public struct Volumes {
        /// Path: `/books/v1/volumes`
        public let path: String

        /// Performs a book search.
        public func get(parameters: GetParameters) -> Request<GoogleBooksAPI.Volumes> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var q: String
            public var download: Download?
            public var filter: Filter?
            public var langRestrict: String?
            public var libraryRestrict: LibraryRestrict?
            public var maxAllowedMaturityRating: MaxAllowedMaturityRating?
            public var maxResults: Int?
            public var orderBy: OrderBy?
            public var partner: String?
            public var printType: PrintType?
            public var projection: Projection?
            public var isShowPreorders: Bool?
            public var source: String?
            public var startIndex: Int?

            public enum Download: String, Codable, CaseIterable {
                case downloadUndefined = "DOWNLOAD_UNDEFINED"
                case epub = "EPUB"
            }

            public enum Filter: String, Codable, CaseIterable {
                case filterUndefined = "FILTER_UNDEFINED"
                case ebooks
                case freeEbooks = "free-ebooks"
                case full
                case paidEbooks = "paid-ebooks"
                case partial
            }

            public enum LibraryRestrict: String, Codable, CaseIterable {
                case libraryRestrictUndefined = "LIBRARY_RESTRICT_UNDEFINED"
                case myLibrary = "my-library"
                case noRestrict = "no-restrict"
            }

            public enum MaxAllowedMaturityRating: String, Codable, CaseIterable {
                case maxAllowedMaturityRatingUndefined = "MAX_ALLOWED_MATURITY_RATING_UNDEFINED"
                case mature = "MATURE"
                case notMature = "not-mature"
            }

            public enum OrderBy: String, Codable, CaseIterable {
                case orderByUndefined = "ORDER_BY_UNDEFINED"
                case newest
                case relevance
            }

            public enum PrintType: String, Codable, CaseIterable {
                case printTypeUndefined = "PRINT_TYPE_UNDEFINED"
                case all = "ALL"
                case books = "BOOKS"
                case magazines = "MAGAZINES"
            }

            public enum Projection: String, Codable, CaseIterable {
                case projectionUndefined = "PROJECTION_UNDEFINED"
                case full = "FULL"
                case lite = "LITE"
            }

            public init(q: String, download: Download? = nil, filter: Filter? = nil, langRestrict: String? = nil, libraryRestrict: LibraryRestrict? = nil, maxAllowedMaturityRating: MaxAllowedMaturityRating? = nil, maxResults: Int? = nil, orderBy: OrderBy? = nil, partner: String? = nil, printType: PrintType? = nil, projection: Projection? = nil, isShowPreorders: Bool? = nil, source: String? = nil, startIndex: Int? = nil) {
                self.q = q
                self.download = download
                self.filter = filter
                self.langRestrict = langRestrict
                self.libraryRestrict = libraryRestrict
                self.maxAllowedMaturityRating = maxAllowedMaturityRating
                self.maxResults = maxResults
                self.orderBy = orderBy
                self.partner = partner
                self.printType = printType
                self.projection = projection
                self.isShowPreorders = isShowPreorders
                self.source = source
                self.startIndex = startIndex
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["q": q])
                encoder.encode(["download": download])
                encoder.encode(["filter": filter])
                encoder.encode(["langRestrict": langRestrict])
                encoder.encode(["libraryRestrict": libraryRestrict])
                encoder.encode(["maxAllowedMaturityRating": maxAllowedMaturityRating])
                encoder.encode(["maxResults": maxResults])
                encoder.encode(["orderBy": orderBy])
                encoder.encode(["partner": partner])
                encoder.encode(["printType": printType])
                encoder.encode(["projection": projection])
                encoder.encode(["showPreorders": isShowPreorders])
                encoder.encode(["source": source])
                encoder.encode(["startIndex": startIndex])
                return encoder.items
            }
        }
    }
}

extension Paths.Volumes {
    public var mybooks: Mybooks {
        Mybooks(path: path + "/mybooks")
    }

    public struct Mybooks {
        /// Path: `/books/v1/volumes/mybooks`
        public let path: String

        /// Return a list of books in My Library.
        public func get(parameters: GetParameters? = nil) -> Request<GoogleBooksAPI.Volumes> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var acquireMethod: [AcquireMethod]?
            public var country: String?
            public var locale: String?
            public var maxResults: Int?
            public var processingState: [ProcessingState]?
            public var source: String?
            public var startIndex: Int?

            public enum AcquireMethod: String, Codable, CaseIterable {
                case acquireMethodUndefined = "ACQUIRE_METHOD_UNDEFINED"
                case familyShared = "FAMILY_SHARED"
                case preordered = "PREORDERED"
                case previouslyRented = "PREVIOUSLY_RENTED"
                case publicDomain = "PUBLIC_DOMAIN"
                case purchased = "PURCHASED"
                case rented = "RENTED"
                case sample = "SAMPLE"
                case uploaded = "UPLOADED"
            }

            public enum ProcessingState: String, Codable, CaseIterable {
                case processingStateUndefined = "PROCESSING_STATE_UNDEFINED"
                case completedFailed = "COMPLETED_FAILED"
                case completedSuccess = "COMPLETED_SUCCESS"
                case running = "RUNNING"
            }

            public init(acquireMethod: [AcquireMethod]? = nil, country: String? = nil, locale: String? = nil, maxResults: Int? = nil, processingState: [ProcessingState]? = nil, source: String? = nil, startIndex: Int? = nil) {
                self.acquireMethod = acquireMethod
                self.country = country
                self.locale = locale
                self.maxResults = maxResults
                self.processingState = processingState
                self.source = source
                self.startIndex = startIndex
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["acquireMethod": acquireMethod])
                encoder.encode(["country": country])
                encoder.encode(["locale": locale])
                encoder.encode(["maxResults": maxResults])
                encoder.encode(["processingState": processingState])
                encoder.encode(["source": source])
                encoder.encode(["startIndex": startIndex])
                return encoder.items
            }
        }
    }
}

extension Paths.Volumes {
    public var recommended: Recommended {
        Recommended(path: path + "/recommended")
    }

    public struct Recommended {
        /// Path: `/books/v1/volumes/recommended`
        public let path: String

        /// Return a list of recommended books for the current user.
        public func get(parameters: GetParameters? = nil) -> Request<GoogleBooksAPI.Volumes> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var locale: String?
            public var maxAllowedMaturityRating: MaxAllowedMaturityRating?
            public var source: String?

            public enum MaxAllowedMaturityRating: String, Codable, CaseIterable {
                case maxAllowedMaturityRatingUndefined = "MAX_ALLOWED_MATURITY_RATING_UNDEFINED"
                case mature = "MATURE"
                case notMature = "not-mature"
            }

            public init(locale: String? = nil, maxAllowedMaturityRating: MaxAllowedMaturityRating? = nil, source: String? = nil) {
                self.locale = locale
                self.maxAllowedMaturityRating = maxAllowedMaturityRating
                self.source = source
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["locale": locale])
                encoder.encode(["maxAllowedMaturityRating": maxAllowedMaturityRating])
                encoder.encode(["source": source])
                return encoder.items
            }
        }
    }
}

extension Paths.Volumes.Recommended {
    public var rate: Rate {
        Rate(path: path + "/rate")
    }

    public struct Rate {
        /// Path: `/books/v1/volumes/recommended/rate`
        public let path: String

        /// Rate a recommended book for the current user.
        public func post(parameters: PostParameters) -> Request<GoogleBooksAPI.BooksVolumesRecommendedRateResponse> {
            .post(path, query: parameters.asQuery)
        }

        public struct PostParameters {
            public var rating: Rating
            public var volumeID: String
            public var locale: String?
            public var source: String?

            public enum Rating: String, Codable, CaseIterable {
                case ratingUndefined = "RATING_UNDEFINED"
                case haveIt = "HAVE_IT"
                case notInterested = "NOT_INTERESTED"
            }

            public init(rating: Rating, volumeID: String, locale: String? = nil, source: String? = nil) {
                self.rating = rating
                self.volumeID = volumeID
                self.locale = locale
                self.source = source
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["rating": rating])
                encoder.encode(["volumeId": volumeID])
                encoder.encode(["locale": locale])
                encoder.encode(["source": source])
                return encoder.items
            }
        }
    }
}

extension Paths.Volumes {
    public var useruploaded: Useruploaded {
        Useruploaded(path: path + "/useruploaded")
    }

    public struct Useruploaded {
        /// Path: `/books/v1/volumes/useruploaded`
        public let path: String

        /// Return a list of books uploaded by the current user.
        public func get(parameters: GetParameters? = nil) -> Request<GoogleBooksAPI.Volumes> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var locale: String?
            public var maxResults: Int?
            public var processingState: [ProcessingState]?
            public var source: String?
            public var startIndex: Int?
            public var volumeID: [String]?

            public enum ProcessingState: String, Codable, CaseIterable {
                case processingStateUndefined = "PROCESSING_STATE_UNDEFINED"
                case completedFailed = "COMPLETED_FAILED"
                case completedSuccess = "COMPLETED_SUCCESS"
                case running = "RUNNING"
            }

            public init(locale: String? = nil, maxResults: Int? = nil, processingState: [ProcessingState]? = nil, source: String? = nil, startIndex: Int? = nil, volumeID: [String]? = nil) {
                self.locale = locale
                self.maxResults = maxResults
                self.processingState = processingState
                self.source = source
                self.startIndex = startIndex
                self.volumeID = volumeID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["locale": locale])
                encoder.encode(["maxResults": maxResults])
                encoder.encode(["processingState": processingState])
                encoder.encode(["source": source])
                encoder.encode(["startIndex": startIndex])
                encoder.encode(["volumeId": volumeID])
                return encoder.items
            }
        }
    }
}

extension Paths.Volumes {
    public func volumeID(_ volumeID: String) -> WithVolumeID {
        WithVolumeID(path: "\(path)/\(volumeID)")
    }

    public struct WithVolumeID {
        /// Path: `/books/v1/volumes/{volumeId}`
        public let path: String

        /// Gets volume information for a single volume.
        public func get(parameters: GetParameters? = nil) -> Request<GoogleBooksAPI.Volume> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var country: String?
            public var isIncludeNonComicsSeries: Bool?
            public var partner: String?
            public var projection: Projection?
            public var source: String?
            public var isUserLibraryConsistentRead: Bool?

            public enum Projection: String, Codable, CaseIterable {
                case projectionUndefined = "PROJECTION_UNDEFINED"
                case full = "FULL"
                case lite = "LITE"
            }

            public init(country: String? = nil, isIncludeNonComicsSeries: Bool? = nil, partner: String? = nil, projection: Projection? = nil, source: String? = nil, isUserLibraryConsistentRead: Bool? = nil) {
                self.country = country
                self.isIncludeNonComicsSeries = isIncludeNonComicsSeries
                self.partner = partner
                self.projection = projection
                self.source = source
                self.isUserLibraryConsistentRead = isUserLibraryConsistentRead
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["country": country])
                encoder.encode(["includeNonComicsSeries": isIncludeNonComicsSeries])
                encoder.encode(["partner": partner])
                encoder.encode(["projection": projection])
                encoder.encode(["source": source])
                encoder.encode(["user_library_consistent_read": isUserLibraryConsistentRead])
                return encoder.items
            }
        }
    }
}

extension Paths.Volumes.WithVolumeID {
    public var associated: Associated {
        Associated(path: path + "/associated")
    }

    public struct Associated {
        /// Path: `/books/v1/volumes/{volumeId}/associated`
        public let path: String

        /// Return a list of associated books.
        public func get(parameters: GetParameters? = nil) -> Request<GoogleBooksAPI.Volumes> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var association: Association?
            public var locale: String?
            public var maxAllowedMaturityRating: MaxAllowedMaturityRating?
            public var source: String?

            public enum Association: String, Codable, CaseIterable {
                case associationUndefined = "ASSOCIATION_UNDEFINED"
                case endOfSample = "end-of-sample"
                case endOfVolume = "end-of-volume"
                case relatedForPlay = "related-for-play"
            }

            public enum MaxAllowedMaturityRating: String, Codable, CaseIterable {
                case maxAllowedMaturityRatingUndefined = "MAX_ALLOWED_MATURITY_RATING_UNDEFINED"
                case mature = "MATURE"
                case notMature = "not-mature"
            }

            public init(association: Association? = nil, locale: String? = nil, maxAllowedMaturityRating: MaxAllowedMaturityRating? = nil, source: String? = nil) {
                self.association = association
                self.locale = locale
                self.maxAllowedMaturityRating = maxAllowedMaturityRating
                self.source = source
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["association": association])
                encoder.encode(["locale": locale])
                encoder.encode(["maxAllowedMaturityRating": maxAllowedMaturityRating])
                encoder.encode(["source": source])
                return encoder.items
            }
        }
    }
}

extension Paths.Volumes.WithVolumeID {
    public var layers: Layers {
        Layers(path: path + "/layers")
    }

    public struct Layers {
        /// Path: `/books/v1/volumes/{volumeId}/layers`
        public let path: String
    }
}

extension Paths.Volumes.WithVolumeID.Layers {
    public func layerID(_ layerID: String) -> WithLayerID {
        WithLayerID(path: "\(path)/\(layerID)")
    }

    public struct WithLayerID {
        /// Path: `/books/v1/volumes/{volumeId}/layers/{layerId}`
        public let path: String

        /// Gets the volume annotations for a volume and layer.
        public func get(parameters: GetParameters) -> Request<GoogleBooksAPI.Volumeannotations> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var contentVersion: String
            public var endOffset: String?
            public var endPosition: String?
            public var locale: String?
            public var maxResults: Int?
            public var pageToken: String?
            public var isShowDeleted: Bool?
            public var source: String?
            public var startOffset: String?
            public var startPosition: String?
            public var updatedMax: String?
            public var updatedMin: String?
            public var volumeAnnotationsVersion: String?

            public init(contentVersion: String, endOffset: String? = nil, endPosition: String? = nil, locale: String? = nil, maxResults: Int? = nil, pageToken: String? = nil, isShowDeleted: Bool? = nil, source: String? = nil, startOffset: String? = nil, startPosition: String? = nil, updatedMax: String? = nil, updatedMin: String? = nil, volumeAnnotationsVersion: String? = nil) {
                self.contentVersion = contentVersion
                self.endOffset = endOffset
                self.endPosition = endPosition
                self.locale = locale
                self.maxResults = maxResults
                self.pageToken = pageToken
                self.isShowDeleted = isShowDeleted
                self.source = source
                self.startOffset = startOffset
                self.startPosition = startPosition
                self.updatedMax = updatedMax
                self.updatedMin = updatedMin
                self.volumeAnnotationsVersion = volumeAnnotationsVersion
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["contentVersion": contentVersion])
                encoder.encode(["endOffset": endOffset])
                encoder.encode(["endPosition": endPosition])
                encoder.encode(["locale": locale])
                encoder.encode(["maxResults": maxResults])
                encoder.encode(["pageToken": pageToken])
                encoder.encode(["showDeleted": isShowDeleted])
                encoder.encode(["source": source])
                encoder.encode(["startOffset": startOffset])
                encoder.encode(["startPosition": startPosition])
                encoder.encode(["updatedMax": updatedMax])
                encoder.encode(["updatedMin": updatedMin])
                encoder.encode(["volumeAnnotationsVersion": volumeAnnotationsVersion])
                return encoder.items
            }
        }
    }
}

extension Paths.Volumes.WithVolumeID.Layers.WithLayerID {
    public var annotations: Annotations {
        Annotations(path: path + "/annotations")
    }

    public struct Annotations {
        /// Path: `/books/v1/volumes/{volumeId}/layers/{layerId}/annotations`
        public let path: String
    }
}

extension Paths.Volumes.WithVolumeID.Layers.WithLayerID.Annotations {
    public func annotationID(_ annotationID: String) -> WithAnnotationID {
        WithAnnotationID(path: "\(path)/\(annotationID)")
    }

    public struct WithAnnotationID {
        /// Path: `/books/v1/volumes/{volumeId}/layers/{layerId}/annotations/{annotationId}`
        public let path: String

        /// Gets the volume annotation.
        public func get(locale: String? = nil, source: String? = nil) -> Request<GoogleBooksAPI.Volumeannotation> {
            .get(path, query: makeGetQuery(locale, source))
        }

        private func makeGetQuery(_ locale: String?, _ source: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(["locale": locale])
            encoder.encode(["source": source])
            return encoder.items
        }
    }
}

extension Paths.Volumes.WithVolumeID.Layers.WithLayerID {
    public var data: Data {
        Data(path: path + "/data")
    }

    public struct Data {
        /// Path: `/books/v1/volumes/{volumeId}/layers/{layerId}/data`
        public let path: String

        /// Gets the annotation data for a volume and layer.
        public func get(parameters: GetParameters) -> Request<GoogleBooksAPI.Annotationsdata> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var contentVersion: String
            public var annotationDataID: [String]?
            public var h: Int?
            public var locale: String?
            public var maxResults: Int?
            public var pageToken: String?
            public var scale: Int?
            public var source: String?
            public var updatedMax: String?
            public var updatedMin: String?
            public var w: Int?

            public init(contentVersion: String, annotationDataID: [String]? = nil, h: Int? = nil, locale: String? = nil, maxResults: Int? = nil, pageToken: String? = nil, scale: Int? = nil, source: String? = nil, updatedMax: String? = nil, updatedMin: String? = nil, w: Int? = nil) {
                self.contentVersion = contentVersion
                self.annotationDataID = annotationDataID
                self.h = h
                self.locale = locale
                self.maxResults = maxResults
                self.pageToken = pageToken
                self.scale = scale
                self.source = source
                self.updatedMax = updatedMax
                self.updatedMin = updatedMin
                self.w = w
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["contentVersion": contentVersion])
                encoder.encode(["annotationDataId": annotationDataID])
                encoder.encode(["h": h])
                encoder.encode(["locale": locale])
                encoder.encode(["maxResults": maxResults])
                encoder.encode(["pageToken": pageToken])
                encoder.encode(["scale": scale])
                encoder.encode(["source": source])
                encoder.encode(["updatedMax": updatedMax])
                encoder.encode(["updatedMin": updatedMin])
                encoder.encode(["w": w])
                return encoder.items
            }
        }
    }
}

extension Paths.Volumes.WithVolumeID.Layers.WithLayerID.Data {
    public func annotationDataID(_ annotationDataID: String) -> WithAnnotationDataID {
        WithAnnotationDataID(path: "\(path)/\(annotationDataID)")
    }

    public struct WithAnnotationDataID {
        /// Path: `/books/v1/volumes/{volumeId}/layers/{layerId}/data/{annotationDataId}`
        public let path: String

        /// Gets the annotation data.
        public func get(parameters: GetParameters) -> Request<GoogleBooksAPI.DictionaryAnnotationdata> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var contentVersion: String
            public var allowWebDefinitions: Bool?
            public var h: Int?
            public var locale: String?
            public var scale: Int?
            public var source: String?
            public var w: Int?

            public init(contentVersion: String, allowWebDefinitions: Bool? = nil, h: Int? = nil, locale: String? = nil, scale: Int? = nil, source: String? = nil, w: Int? = nil) {
                self.contentVersion = contentVersion
                self.allowWebDefinitions = allowWebDefinitions
                self.h = h
                self.locale = locale
                self.scale = scale
                self.source = source
                self.w = w
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["contentVersion": contentVersion])
                encoder.encode(["allowWebDefinitions": allowWebDefinitions])
                encoder.encode(["h": h])
                encoder.encode(["locale": locale])
                encoder.encode(["scale": scale])
                encoder.encode(["source": source])
                encoder.encode(["w": w])
                return encoder.items
            }
        }
    }
}

extension Paths.Volumes.WithVolumeID {
    public var layersummary: Layersummary {
        Layersummary(path: path + "/layersummary")
    }

    public struct Layersummary {
        /// Path: `/books/v1/volumes/{volumeId}/layersummary`
        public let path: String

        /// List the layer summaries for a volume.
        public func get(parameters: GetParameters? = nil) -> Request<GoogleBooksAPI.Layersummaries> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var contentVersion: String?
            public var maxResults: Int?
            public var pageToken: String?
            public var source: String?

            public init(contentVersion: String? = nil, maxResults: Int? = nil, pageToken: String? = nil, source: String? = nil) {
                self.contentVersion = contentVersion
                self.maxResults = maxResults
                self.pageToken = pageToken
                self.source = source
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(["contentVersion": contentVersion])
                encoder.encode(["maxResults": maxResults])
                encoder.encode(["pageToken": pageToken])
                encoder.encode(["source": source])
                return encoder.items
            }
        }
    }
}

extension Paths.Volumes.WithVolumeID.Layersummary {
    public func summaryID(_ summaryID: String) -> WithSummaryID {
        WithSummaryID(path: "\(path)/\(summaryID)")
    }

    public struct WithSummaryID {
        /// Path: `/books/v1/volumes/{volumeId}/layersummary/{summaryId}`
        public let path: String

        /// Gets the layer summary for a volume.
        public func get(contentVersion: String? = nil, source: String? = nil) -> Request<GoogleBooksAPI.Layersummary> {
            .get(path, query: makeGetQuery(contentVersion, source))
        }

        private func makeGetQuery(_ contentVersion: String?, _ source: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(["contentVersion": contentVersion])
            encoder.encode(["source": source])
            return encoder.items
        }
    }
}

public enum Paths {}
