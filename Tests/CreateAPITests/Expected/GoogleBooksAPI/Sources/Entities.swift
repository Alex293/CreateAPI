// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

public struct Annotation: Codable {
    /// Anchor text after excerpt. For requests, if the user bookmarked a screen that has no flowing text on it, then this field should be empty.
    public var afterSelectedText: String?
    /// Anchor text before excerpt. For requests, if the user bookmarked a screen that has no flowing text on it, then this field should be empty.
    public var beforeSelectedText: String?
    /// Selection ranges sent from the client.
    public var clientVersionRanges: ClientVersionRanges?
    /// Timestamp for the created time of this annotation.
    public var created: String?
    /// Selection ranges for the most recent content version.
    public var currentVersionRanges: CurrentVersionRanges?
    /// User-created data for this annotation.
    public var data: String?
    /// Indicates that this annotation is deleted.
    public var isDeleted: Bool?
    /// The highlight style for this annotation.
    public var highlightStyle: String?
    /// Id of this annotation, in the form of a GUID.
    public var id: String?
    /// Resource type.
    public var kind: String?
    /// The layer this annotation is for.
    public var layerID: String?
    public var layerSummary: LayerSummary?
    /// Pages that this annotation spans.
    public var pageIDs: [String]?
    /// Excerpt from the volume.
    public var selectedText: String?
    /// URL to this resource.
    public var selfLink: String?
    /// Timestamp for the last time this annotation was modified.
    public var updated: String?
    /// The volume that this annotation belongs to.
    public var volumeID: String?

    /// Selection ranges sent from the client.
    public struct ClientVersionRanges: Codable {
        public var cfiRange: BooksAnnotationsRange?
        /// Content version the client sent in.
        public var contentVersion: String?
        public var gbImageRange: BooksAnnotationsRange?
        public var gbTextRange: BooksAnnotationsRange?
        public var imageCfiRange: BooksAnnotationsRange?

        public init(cfiRange: BooksAnnotationsRange? = nil, contentVersion: String? = nil, gbImageRange: BooksAnnotationsRange? = nil, gbTextRange: BooksAnnotationsRange? = nil, imageCfiRange: BooksAnnotationsRange? = nil) {
            self.cfiRange = cfiRange
            self.contentVersion = contentVersion
            self.gbImageRange = gbImageRange
            self.gbTextRange = gbTextRange
            self.imageCfiRange = imageCfiRange
        }
    }

    /// Selection ranges for the most recent content version.
    public struct CurrentVersionRanges: Codable {
        public var cfiRange: BooksAnnotationsRange?
        /// Content version applicable to ranges below.
        public var contentVersion: String?
        public var gbImageRange: BooksAnnotationsRange?
        public var gbTextRange: BooksAnnotationsRange?
        public var imageCfiRange: BooksAnnotationsRange?

        public init(cfiRange: BooksAnnotationsRange? = nil, contentVersion: String? = nil, gbImageRange: BooksAnnotationsRange? = nil, gbTextRange: BooksAnnotationsRange? = nil, imageCfiRange: BooksAnnotationsRange? = nil) {
            self.cfiRange = cfiRange
            self.contentVersion = contentVersion
            self.gbImageRange = gbImageRange
            self.gbTextRange = gbTextRange
            self.imageCfiRange = imageCfiRange
        }
    }

    public struct LayerSummary: Codable {
        /// Maximum allowed characters on this layer, especially for the "copy" layer.
        public var allowedCharacterCount: Int?
        /// Type of limitation on this layer. "limited" or "unlimited" for the "copy" layer.
        public var limitType: String?
        /// Remaining allowed characters on this layer, especially for the "copy" layer.
        public var remainingCharacterCount: Int?

        public init(allowedCharacterCount: Int? = nil, limitType: String? = nil, remainingCharacterCount: Int? = nil) {
            self.allowedCharacterCount = allowedCharacterCount
            self.limitType = limitType
            self.remainingCharacterCount = remainingCharacterCount
        }
    }

    public init(afterSelectedText: String? = nil, beforeSelectedText: String? = nil, clientVersionRanges: ClientVersionRanges? = nil, created: String? = nil, currentVersionRanges: CurrentVersionRanges? = nil, data: String? = nil, isDeleted: Bool? = nil, highlightStyle: String? = nil, id: String? = nil, kind: String? = nil, layerID: String? = nil, layerSummary: LayerSummary? = nil, pageIDs: [String]? = nil, selectedText: String? = nil, selfLink: String? = nil, updated: String? = nil, volumeID: String? = nil) {
        self.afterSelectedText = afterSelectedText
        self.beforeSelectedText = beforeSelectedText
        self.clientVersionRanges = clientVersionRanges
        self.created = created
        self.currentVersionRanges = currentVersionRanges
        self.data = data
        self.isDeleted = isDeleted
        self.highlightStyle = highlightStyle
        self.id = id
        self.kind = kind
        self.layerID = layerID
        self.layerSummary = layerSummary
        self.pageIDs = pageIDs
        self.selectedText = selectedText
        self.selfLink = selfLink
        self.updated = updated
        self.volumeID = volumeID
    }

    private enum CodingKeys: String, CodingKey {
        case afterSelectedText
        case beforeSelectedText
        case clientVersionRanges
        case created
        case currentVersionRanges
        case data
        case isDeleted = "deleted"
        case highlightStyle
        case id
        case kind
        case layerID = "layerId"
        case layerSummary
        case pageIDs = "pageIds"
        case selectedText
        case selfLink
        case updated
        case volumeID = "volumeId"
    }
}

public struct Annotations: Codable {
    /// A list of annotations.
    public var items: [Annotation]?
    /// Resource type.
    public var kind: String?
    /// Token to pass in for pagination for the next page. This will not be present if this request does not have more results.
    public var nextPageToken: String?
    /// Total number of annotations found. This may be greater than the number of notes returned in this response if results have been paginated.
    public var totalItems: Int?

    public init(items: [Annotation]? = nil, kind: String? = nil, nextPageToken: String? = nil, totalItems: Int? = nil) {
        self.items = items
        self.kind = kind
        self.nextPageToken = nextPageToken
        self.totalItems = totalItems
    }
}

public struct AnnotationsSummary: Codable {
    public var kind: String?
    public var layers: [Layer]?

    public struct Layer: Codable {
        public var allowedCharacterCount: Int?
        public var layerID: String?
        public var limitType: String?
        public var remainingCharacterCount: Int?
        public var updated: String?

        public init(allowedCharacterCount: Int? = nil, layerID: String? = nil, limitType: String? = nil, remainingCharacterCount: Int? = nil, updated: String? = nil) {
            self.allowedCharacterCount = allowedCharacterCount
            self.layerID = layerID
            self.limitType = limitType
            self.remainingCharacterCount = remainingCharacterCount
            self.updated = updated
        }

        private enum CodingKeys: String, CodingKey {
            case allowedCharacterCount
            case layerID = "layerId"
            case limitType
            case remainingCharacterCount
            case updated
        }
    }

    public init(kind: String? = nil, layers: [Layer]? = nil) {
        self.kind = kind
        self.layers = layers
    }
}

public struct Annotationsdata: Codable {
    /// A list of Annotation Data.
    public var items: [GeoAnnotationdata]?
    /// Resource type
    public var kind: String?
    /// Token to pass in for pagination for the next page. This will not be present if this request does not have more results.
    public var nextPageToken: String?
    /// The total number of volume annotations found.
    public var totalItems: Int?

    public init(items: [GeoAnnotationdata]? = nil, kind: String? = nil, nextPageToken: String? = nil, totalItems: Int? = nil) {
        self.items = items
        self.kind = kind
        self.nextPageToken = nextPageToken
        self.totalItems = totalItems
    }
}

public struct BooksAnnotationsRange: Codable {
    /// The offset from the ending position.
    public var endOffset: String?
    /// The ending position for the range.
    public var endPosition: String?
    /// The offset from the starting position.
    public var startOffset: String?
    /// The starting position for the range.
    public var startPosition: String?

    public init(endOffset: String? = nil, endPosition: String? = nil, startOffset: String? = nil, startPosition: String? = nil) {
        self.endOffset = endOffset
        self.endPosition = endPosition
        self.startOffset = startOffset
        self.startPosition = startPosition
    }
}

public struct BooksCloudloadingResource: Codable {
    public var author: String?
    public var processingState: String?
    public var title: String?
    public var volumeID: String?

    public init(author: String? = nil, processingState: String? = nil, title: String? = nil, volumeID: String? = nil) {
        self.author = author
        self.processingState = processingState
        self.title = title
        self.volumeID = volumeID
    }

    private enum CodingKeys: String, CodingKey {
        case author
        case processingState
        case title
        case volumeID = "volumeId"
    }
}

public struct BooksVolumesRecommendedRateResponse: Codable {
    public var consistencyToken: String?

    public init(consistencyToken: String? = nil) {
        self.consistencyToken = consistencyToken
    }

    private enum CodingKeys: String, CodingKey {
        case consistencyToken = "consistency_token"
    }
}

public struct Bookshelf: Codable {
    /// Whether this bookshelf is PUBLIC or PRIVATE.
    public var access: String?
    /// Created time for this bookshelf (formatted UTC timestamp with millisecond resolution).
    public var created: String?
    /// Description of this bookshelf.
    public var description: String?
    /// Id of this bookshelf, only unique by user.
    public var id: Int?
    /// Resource type for bookshelf metadata.
    public var kind: String?
    /// URL to this resource.
    public var selfLink: String?
    /// Title of this bookshelf.
    public var title: String?
    /// Last modified time of this bookshelf (formatted UTC timestamp with millisecond resolution).
    public var updated: String?
    /// Number of volumes in this bookshelf.
    public var volumeCount: Int?
    /// Last time a volume was added or removed from this bookshelf (formatted UTC timestamp with millisecond resolution).
    public var volumesLastUpdated: String?

    public init(access: String? = nil, created: String? = nil, description: String? = nil, id: Int? = nil, kind: String? = nil, selfLink: String? = nil, title: String? = nil, updated: String? = nil, volumeCount: Int? = nil, volumesLastUpdated: String? = nil) {
        self.access = access
        self.created = created
        self.description = description
        self.id = id
        self.kind = kind
        self.selfLink = selfLink
        self.title = title
        self.updated = updated
        self.volumeCount = volumeCount
        self.volumesLastUpdated = volumesLastUpdated
    }
}

public struct Bookshelves: Codable {
    /// A list of bookshelves.
    public var items: [Bookshelf]?
    /// Resource type.
    public var kind: String?

    public init(items: [Bookshelf]? = nil, kind: String? = nil) {
        self.items = items
        self.kind = kind
    }
}

public struct Category: Codable {
    /// A list of onboarding categories.
    public var items: [Item]?
    /// Resource type.
    public var kind: String?

    public struct Item: Codable {
        public var badgeURL: String?
        public var categoryID: String?
        public var name: String?

        public init(badgeURL: String? = nil, categoryID: String? = nil, name: String? = nil) {
            self.badgeURL = badgeURL
            self.categoryID = categoryID
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case badgeURL = "badgeUrl"
            case categoryID = "categoryId"
            case name
        }
    }

    public init(items: [Item]? = nil, kind: String? = nil) {
        self.items = items
        self.kind = kind
    }
}

public struct ConcurrentAccessRestriction: Codable {
    /// Whether access is granted for this (user, device, volume).
    public var isDeviceAllowed: Bool?
    /// Resource type.
    public var kind: String?
    /// The maximum number of concurrent access licenses for this volume.
    public var maxConcurrentDevices: Int?
    /// Error/warning message.
    public var message: String?
    /// Client nonce for verification. Download access and client-validation only.
    public var nonce: String?
    /// Error/warning reason code.
    public var reasonCode: String?
    /// Whether this volume has any concurrent access restrictions.
    public var isRestricted: Bool?
    /// Response signature.
    public var signature: String?
    /// Client app identifier for verification. Download access and client-validation only.
    public var source: String?
    /// Time in seconds for license auto-expiration.
    public var timeWindowSeconds: Int?
    /// Identifies the volume for which this entry applies.
    public var volumeID: String?

    public init(isDeviceAllowed: Bool? = nil, kind: String? = nil, maxConcurrentDevices: Int? = nil, message: String? = nil, nonce: String? = nil, reasonCode: String? = nil, isRestricted: Bool? = nil, signature: String? = nil, source: String? = nil, timeWindowSeconds: Int? = nil, volumeID: String? = nil) {
        self.isDeviceAllowed = isDeviceAllowed
        self.kind = kind
        self.maxConcurrentDevices = maxConcurrentDevices
        self.message = message
        self.nonce = nonce
        self.reasonCode = reasonCode
        self.isRestricted = isRestricted
        self.signature = signature
        self.source = source
        self.timeWindowSeconds = timeWindowSeconds
        self.volumeID = volumeID
    }

    private enum CodingKeys: String, CodingKey {
        case isDeviceAllowed = "deviceAllowed"
        case kind
        case maxConcurrentDevices
        case message
        case nonce
        case reasonCode
        case isRestricted = "restricted"
        case signature
        case source
        case timeWindowSeconds
        case volumeID = "volumeId"
    }
}

public struct DictionaryAnnotationdata: Codable {
    /// The type of annotation this data is for.
    public var annotationType: String?
    public var data: Dictlayerdata?
    /// Base64 encoded data for this annotation data.
    public var encodedData: String?
    /// Unique id for this annotation data.
    public var id: String?
    /// Resource Type
    public var kind: String?
    /// The Layer id for this data. *
    public var layerID: String?
    /// URL for this resource. *
    public var selfLink: String?
    /// Timestamp for the last time this data was updated. (RFC 3339 UTC date-time format).
    public var updated: String?
    /// The volume id for this data. *
    public var volumeID: String?

    public init(annotationType: String? = nil, data: Dictlayerdata? = nil, encodedData: String? = nil, id: String? = nil, kind: String? = nil, layerID: String? = nil, selfLink: String? = nil, updated: String? = nil, volumeID: String? = nil) {
        self.annotationType = annotationType
        self.data = data
        self.encodedData = encodedData
        self.id = id
        self.kind = kind
        self.layerID = layerID
        self.selfLink = selfLink
        self.updated = updated
        self.volumeID = volumeID
    }

    private enum CodingKeys: String, CodingKey {
        case annotationType
        case data
        case encodedData
        case id
        case kind
        case layerID = "layerId"
        case selfLink
        case updated
        case volumeID = "volumeId"
    }
}

public struct Dictlayerdata: Codable {
    public var common: Common?
    public var dict: Dict?
    public var kind: String?

    public struct Common: Codable {
        /// The display title and localized canonical name to use when searching for this entity on Google search.
        public var title: String?

        public init(title: String? = nil) {
            self.title = title
        }
    }

    public struct Dict: Codable {
        /// The source, url and attribution for this dictionary data.
        public var source: Source?
        public var words: [Word]?

        /// The source, url and attribution for this dictionary data.
        public struct Source: Codable {
            public var attribution: String?
            public var url: String?

            public init(attribution: String? = nil, url: String? = nil) {
                self.attribution = attribution
                self.url = url
            }
        }

        public struct Word: Codable {
            public var derivatives: [Derivative]?
            public var examples: [Example]?
            public var senses: [Sense]?
            /// The words with different meanings but not related words, e.g. "go" (game) and "go" (verb).
            public var source: Source?

            public struct Derivative: Codable {
                public var source: Source?
                public var text: String?

                public struct Source: Codable {
                    public var attribution: String?
                    public var url: String?

                    public init(attribution: String? = nil, url: String? = nil) {
                        self.attribution = attribution
                        self.url = url
                    }
                }

                public init(source: Source? = nil, text: String? = nil) {
                    self.source = source
                    self.text = text
                }
            }

            public struct Example: Codable {
                public var source: Source?
                public var text: String?

                public struct Source: Codable {
                    public var attribution: String?
                    public var url: String?

                    public init(attribution: String? = nil, url: String? = nil) {
                        self.attribution = attribution
                        self.url = url
                    }
                }

                public init(source: Source? = nil, text: String? = nil) {
                    self.source = source
                    self.text = text
                }
            }

            public struct Sense: Codable {
                public var conjugations: [Conjugation]?
                public var definitions: [Definition]?
                public var partOfSpeech: String?
                public var pronunciation: String?
                public var pronunciationURL: String?
                public var source: Source?
                public var syllabification: String?
                public var synonyms: [Synonym]?

                public struct Conjugation: Codable {
                    public var type: String?
                    public var value: String?

                    public init(type: String? = nil, value: String? = nil) {
                        self.type = type
                        self.value = value
                    }
                }

                public struct Definition: Codable {
                    public var definition: String?
                    public var examples: [Example]?

                    public struct Example: Codable {
                        public var source: Source?
                        public var text: String?

                        public struct Source: Codable {
                            public var attribution: String?
                            public var url: String?

                            public init(attribution: String? = nil, url: String? = nil) {
                                self.attribution = attribution
                                self.url = url
                            }
                        }

                        public init(source: Source? = nil, text: String? = nil) {
                            self.source = source
                            self.text = text
                        }
                    }

                    public init(definition: String? = nil, examples: [Example]? = nil) {
                        self.definition = definition
                        self.examples = examples
                    }
                }

                public struct Source: Codable {
                    public var attribution: String?
                    public var url: String?

                    public init(attribution: String? = nil, url: String? = nil) {
                        self.attribution = attribution
                        self.url = url
                    }
                }

                public struct Synonym: Codable {
                    public var source: Source?
                    public var text: String?

                    public struct Source: Codable {
                        public var attribution: String?
                        public var url: String?

                        public init(attribution: String? = nil, url: String? = nil) {
                            self.attribution = attribution
                            self.url = url
                        }
                    }

                    public init(source: Source? = nil, text: String? = nil) {
                        self.source = source
                        self.text = text
                    }
                }

                public init(conjugations: [Conjugation]? = nil, definitions: [Definition]? = nil, partOfSpeech: String? = nil, pronunciation: String? = nil, pronunciationURL: String? = nil, source: Source? = nil, syllabification: String? = nil, synonyms: [Synonym]? = nil) {
                    self.conjugations = conjugations
                    self.definitions = definitions
                    self.partOfSpeech = partOfSpeech
                    self.pronunciation = pronunciation
                    self.pronunciationURL = pronunciationURL
                    self.source = source
                    self.syllabification = syllabification
                    self.synonyms = synonyms
                }

                private enum CodingKeys: String, CodingKey {
                    case conjugations
                    case definitions
                    case partOfSpeech
                    case pronunciation
                    case pronunciationURL = "pronunciationUrl"
                    case source
                    case syllabification
                    case synonyms
                }
            }

            /// The words with different meanings but not related words, e.g. "go" (game) and "go" (verb).
            public struct Source: Codable {
                public var attribution: String?
                public var url: String?

                public init(attribution: String? = nil, url: String? = nil) {
                    self.attribution = attribution
                    self.url = url
                }
            }

            public init(derivatives: [Derivative]? = nil, examples: [Example]? = nil, senses: [Sense]? = nil, source: Source? = nil) {
                self.derivatives = derivatives
                self.examples = examples
                self.senses = senses
                self.source = source
            }
        }

        public init(source: Source? = nil, words: [Word]? = nil) {
            self.source = source
            self.words = words
        }
    }

    public init(common: Common? = nil, dict: Dict? = nil, kind: String? = nil) {
        self.common = common
        self.dict = dict
        self.kind = kind
    }
}

public struct Discoveryclusters: Codable {
    public var clusters: [Cluster]?
    /// Resorce type.
    public var kind: String?
    public var totalClusters: Int?

    public struct Cluster: Codable {
        public var bannerWithContentContainer: BannerWithContentContainer?
        public var subTitle: String?
        public var title: String?
        public var totalVolumes: Int?
        public var uid: String?
        public var volumes: [Volume]?

        public struct BannerWithContentContainer: Codable {
            public var fillColorArgb: String?
            public var imageURL: String?
            public var maskColorArgb: String?
            public var moreButtonText: String?
            public var moreButtonURL: String?
            public var textColorArgb: String?

            public init(fillColorArgb: String? = nil, imageURL: String? = nil, maskColorArgb: String? = nil, moreButtonText: String? = nil, moreButtonURL: String? = nil, textColorArgb: String? = nil) {
                self.fillColorArgb = fillColorArgb
                self.imageURL = imageURL
                self.maskColorArgb = maskColorArgb
                self.moreButtonText = moreButtonText
                self.moreButtonURL = moreButtonURL
                self.textColorArgb = textColorArgb
            }

            private enum CodingKeys: String, CodingKey {
                case fillColorArgb
                case imageURL = "imageUrl"
                case maskColorArgb
                case moreButtonText
                case moreButtonURL = "moreButtonUrl"
                case textColorArgb
            }
        }

        public init(bannerWithContentContainer: BannerWithContentContainer? = nil, subTitle: String? = nil, title: String? = nil, totalVolumes: Int? = nil, uid: String? = nil, volumes: [Volume]? = nil) {
            self.bannerWithContentContainer = bannerWithContentContainer
            self.subTitle = subTitle
            self.title = title
            self.totalVolumes = totalVolumes
            self.uid = uid
            self.volumes = volumes
        }

        private enum CodingKeys: String, CodingKey {
            case bannerWithContentContainer = "banner_with_content_container"
            case subTitle
            case title
            case totalVolumes
            case uid
            case volumes
        }
    }

    public init(clusters: [Cluster]? = nil, kind: String? = nil, totalClusters: Int? = nil) {
        self.clusters = clusters
        self.kind = kind
        self.totalClusters = totalClusters
    }
}

public struct DownloadAccessRestriction: Codable {
    /// If restricted, whether access is granted for this (user, device, volume).
    public var isDeviceAllowed: Bool?
    /// If restricted, the number of content download licenses already acquired (including the requesting client, if licensed).
    public var downloadsAcquired: Int?
    /// If deviceAllowed, whether access was just acquired with this request.
    public var isJustAcquired: Bool?
    /// Resource type.
    public var kind: String?
    /// If restricted, the maximum number of content download licenses for this volume.
    public var maxDownloadDevices: Int?
    /// Error/warning message.
    public var message: String?
    /// Client nonce for verification. Download access and client-validation only.
    public var nonce: String?
    /// Error/warning reason code. Additional codes may be added in the future. 0 OK 100 ACCESS_DENIED_PUBLISHER_LIMIT 101 ACCESS_DENIED_LIMIT 200 WARNING_USED_LAST_ACCESS
    public var reasonCode: String?
    /// Whether this volume has any download access restrictions.
    public var isRestricted: Bool?
    /// Response signature.
    public var signature: String?
    /// Client app identifier for verification. Download access and client-validation only.
    public var source: String?
    /// Identifies the volume for which this entry applies.
    public var volumeID: String?

    public init(isDeviceAllowed: Bool? = nil, downloadsAcquired: Int? = nil, isJustAcquired: Bool? = nil, kind: String? = nil, maxDownloadDevices: Int? = nil, message: String? = nil, nonce: String? = nil, reasonCode: String? = nil, isRestricted: Bool? = nil, signature: String? = nil, source: String? = nil, volumeID: String? = nil) {
        self.isDeviceAllowed = isDeviceAllowed
        self.downloadsAcquired = downloadsAcquired
        self.isJustAcquired = isJustAcquired
        self.kind = kind
        self.maxDownloadDevices = maxDownloadDevices
        self.message = message
        self.nonce = nonce
        self.reasonCode = reasonCode
        self.isRestricted = isRestricted
        self.signature = signature
        self.source = source
        self.volumeID = volumeID
    }

    private enum CodingKeys: String, CodingKey {
        case isDeviceAllowed = "deviceAllowed"
        case downloadsAcquired
        case isJustAcquired = "justAcquired"
        case kind
        case maxDownloadDevices
        case message
        case nonce
        case reasonCode
        case isRestricted = "restricted"
        case signature
        case source
        case volumeID = "volumeId"
    }
}

public struct DownloadAccesses: Codable {
    /// A list of download access responses.
    public var downloadAccessList: [DownloadAccessRestriction]?
    /// Resource type.
    public var kind: String?

    public init(downloadAccessList: [DownloadAccessRestriction]? = nil, kind: String? = nil) {
        self.downloadAccessList = downloadAccessList
        self.kind = kind
    }
}

public struct FamilyInfo: Codable {
    /// Resource type.
    public var kind: String?
    /// Family membership info of the user that made the request.
    public var membership: Membership?

    /// Family membership info of the user that made the request.
    public struct Membership: Codable {
        /// Restrictions on user buying and acquiring content.
        public var acquirePermission: String?
        /// The age group of the user.
        public var ageGroup: String?
        /// The maximum allowed maturity rating for the user.
        public var allowedMaturityRating: String?
        public var isInFamily: Bool?
        /// The role of the user in the family.
        public var role: String?

        public init(acquirePermission: String? = nil, ageGroup: String? = nil, allowedMaturityRating: String? = nil, isInFamily: Bool? = nil, role: String? = nil) {
            self.acquirePermission = acquirePermission
            self.ageGroup = ageGroup
            self.allowedMaturityRating = allowedMaturityRating
            self.isInFamily = isInFamily
            self.role = role
        }
    }

    public init(kind: String? = nil, membership: Membership? = nil) {
        self.kind = kind
        self.membership = membership
    }
}

public struct GeoAnnotationdata: Codable {
    /// The type of annotation this data is for.
    public var annotationType: String?
    public var data: Geolayerdata?
    /// Base64 encoded data for this annotation data.
    public var encodedData: String?
    /// Unique id for this annotation data.
    public var id: String?
    /// Resource Type
    public var kind: String?
    /// The Layer id for this data. *
    public var layerID: String?
    /// URL for this resource. *
    public var selfLink: String?
    /// Timestamp for the last time this data was updated. (RFC 3339 UTC date-time format).
    public var updated: String?
    /// The volume id for this data. *
    public var volumeID: String?

    public init(annotationType: String? = nil, data: Geolayerdata? = nil, encodedData: String? = nil, id: String? = nil, kind: String? = nil, layerID: String? = nil, selfLink: String? = nil, updated: String? = nil, volumeID: String? = nil) {
        self.annotationType = annotationType
        self.data = data
        self.encodedData = encodedData
        self.id = id
        self.kind = kind
        self.layerID = layerID
        self.selfLink = selfLink
        self.updated = updated
        self.volumeID = volumeID
    }

    private enum CodingKeys: String, CodingKey {
        case annotationType
        case data
        case encodedData
        case id
        case kind
        case layerID = "layerId"
        case selfLink
        case updated
        case volumeID = "volumeId"
    }
}

public struct Geolayerdata: Codable {
    public var common: Common?
    public var geo: Geo?
    public var kind: String?

    public struct Common: Codable {
        /// The language of the information url and description.
        public var lang: String?
        /// The URL for the preview image information.
        public var previewImageURL: String?
        /// The description for this location.
        public var snippet: String?
        /// The URL for information for this location. Ex: wikipedia link.
        public var snippetURL: String?
        /// The display title and localized canonical name to use when searching for this entity on Google search.
        public var title: String?

        public init(lang: String? = nil, previewImageURL: String? = nil, snippet: String? = nil, snippetURL: String? = nil, title: String? = nil) {
            self.lang = lang
            self.previewImageURL = previewImageURL
            self.snippet = snippet
            self.snippetURL = snippetURL
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case lang
            case previewImageURL = "previewImageUrl"
            case snippet
            case snippetURL = "snippetUrl"
            case title
        }
    }

    public struct Geo: Codable {
        /// The boundary of the location as a set of loops containing pairs of latitude, longitude coordinates.
        public var boundary: [String]?
        /// The cache policy active for this data. EX: UNRESTRICTED, RESTRICTED, NEVER
        public var cachePolicy: String?
        /// The country code of the location.
        public var countryCode: String?
        /// The latitude of the location.
        public var latitude: Double?
        /// The longitude of the location.
        public var longitude: Double?
        /// The type of map that should be used for this location. EX: HYBRID, ROADMAP, SATELLITE, TERRAIN
        public var mapType: String?
        /// The viewport for showing this location. This is a latitude, longitude rectangle.
        public var viewport: Viewport?
        /// The Zoom level to use for the map. Zoom levels between 0 (the lowest zoom level, in which the entire world can be seen on one map) to 21+ (down to individual buildings). See: https: //developers.google.com/maps/documentation/staticmaps/#Zoomlevels
        public var zoom: Int?

        /// The viewport for showing this location. This is a latitude, longitude rectangle.
        public struct Viewport: Codable {
            public var hi: Hi?
            public var lo: Lo?

            public struct Hi: Codable {
                public var latitude: Double?
                public var longitude: Double?

                public init(latitude: Double? = nil, longitude: Double? = nil) {
                    self.latitude = latitude
                    self.longitude = longitude
                }
            }

            public struct Lo: Codable {
                public var latitude: Double?
                public var longitude: Double?

                public init(latitude: Double? = nil, longitude: Double? = nil) {
                    self.latitude = latitude
                    self.longitude = longitude
                }
            }

            public init(hi: Hi? = nil, lo: Lo? = nil) {
                self.hi = hi
                self.lo = lo
            }
        }

        public init(boundary: [String]? = nil, cachePolicy: String? = nil, countryCode: String? = nil, latitude: Double? = nil, longitude: Double? = nil, mapType: String? = nil, viewport: Viewport? = nil, zoom: Int? = nil) {
            self.boundary = boundary
            self.cachePolicy = cachePolicy
            self.countryCode = countryCode
            self.latitude = latitude
            self.longitude = longitude
            self.mapType = mapType
            self.viewport = viewport
            self.zoom = zoom
        }
    }

    public init(common: Common? = nil, geo: Geo? = nil, kind: String? = nil) {
        self.common = common
        self.geo = geo
        self.kind = kind
    }
}

public struct Layersummaries: Codable {
    /// A list of layer summary items.
    public var items: [Layersummary]?
    /// Resource type.
    public var kind: String?
    /// The total number of layer summaries found.
    public var totalItems: Int?

    public init(items: [Layersummary]? = nil, kind: String? = nil, totalItems: Int? = nil) {
        self.items = items
        self.kind = kind
        self.totalItems = totalItems
    }
}

public struct Layersummary: Codable {
    /// The number of annotations for this layer.
    public var annotationCount: Int?
    /// The list of annotation types contained for this layer.
    public var annotationTypes: [String]?
    /// Link to get data for this annotation.
    public var annotationsDataLink: String?
    /// The link to get the annotations for this layer.
    public var annotationsLink: String?
    /// The content version this resource is for.
    public var contentVersion: String?
    /// The number of data items for this layer.
    public var dataCount: Int?
    /// Unique id of this layer summary.
    public var id: String?
    /// Resource Type
    public var kind: String?
    /// The layer id for this summary.
    public var layerID: String?
    /// URL to this resource.
    public var selfLink: String?
    /// Timestamp for the last time an item in this layer was updated. (RFC 3339 UTC date-time format).
    public var updated: String?
    /// The current version of this layer's volume annotations. Note that this version applies only to the data in the books.layers.volumeAnnotations.* responses. The actual annotation data is versioned separately.
    public var volumeAnnotationsVersion: String?
    /// The volume id this resource is for.
    public var volumeID: String?

    public init(annotationCount: Int? = nil, annotationTypes: [String]? = nil, annotationsDataLink: String? = nil, annotationsLink: String? = nil, contentVersion: String? = nil, dataCount: Int? = nil, id: String? = nil, kind: String? = nil, layerID: String? = nil, selfLink: String? = nil, updated: String? = nil, volumeAnnotationsVersion: String? = nil, volumeID: String? = nil) {
        self.annotationCount = annotationCount
        self.annotationTypes = annotationTypes
        self.annotationsDataLink = annotationsDataLink
        self.annotationsLink = annotationsLink
        self.contentVersion = contentVersion
        self.dataCount = dataCount
        self.id = id
        self.kind = kind
        self.layerID = layerID
        self.selfLink = selfLink
        self.updated = updated
        self.volumeAnnotationsVersion = volumeAnnotationsVersion
        self.volumeID = volumeID
    }

    private enum CodingKeys: String, CodingKey {
        case annotationCount
        case annotationTypes
        case annotationsDataLink
        case annotationsLink
        case contentVersion
        case dataCount
        case id
        case kind
        case layerID = "layerId"
        case selfLink
        case updated
        case volumeAnnotationsVersion
        case volumeID = "volumeId"
    }
}

public struct Metadata: Codable {
    /// A list of offline dictionary metadata.
    public var items: [Item]?
    /// Resource type.
    public var kind: String?

    public struct Item: Codable {
        public var downloadURL: String?
        public var encryptedKey: String?
        public var language: String?
        public var size: String?
        public var version: String?

        public init(downloadURL: String? = nil, encryptedKey: String? = nil, language: String? = nil, size: String? = nil, version: String? = nil) {
            self.downloadURL = downloadURL
            self.encryptedKey = encryptedKey
            self.language = language
            self.size = size
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case downloadURL = "download_url"
            case encryptedKey = "encrypted_key"
            case language
            case size
            case version
        }
    }

    public init(items: [Item]? = nil, kind: String? = nil) {
        self.items = items
        self.kind = kind
    }
}

public struct Notification: Codable {
    public var body: String?
    /// The list of crm experiment ids.
    public var crmExperimentIDs: [String]?
    public var docID: String?
    public var docType: String?
    public var isDontShowNotification: Bool?
    public var iconURL: String?
    public var isDocumentMature: Bool?
    /// Resource type.
    public var kind: String?
    public var notificationGroup: String?
    public var notificationType: String?
    public var pcampaignID: String?
    public var reason: String?
    public var isShowNotificationSettingsAction: Bool?
    public var targetURL: String?
    public var timeToExpireMs: String?
    public var title: String?

    public init(body: String? = nil, crmExperimentIDs: [String]? = nil, docID: String? = nil, docType: String? = nil, isDontShowNotification: Bool? = nil, iconURL: String? = nil, isDocumentMature: Bool? = nil, kind: String? = nil, notificationGroup: String? = nil, notificationType: String? = nil, pcampaignID: String? = nil, reason: String? = nil, isShowNotificationSettingsAction: Bool? = nil, targetURL: String? = nil, timeToExpireMs: String? = nil, title: String? = nil) {
        self.body = body
        self.crmExperimentIDs = crmExperimentIDs
        self.docID = docID
        self.docType = docType
        self.isDontShowNotification = isDontShowNotification
        self.iconURL = iconURL
        self.isDocumentMature = isDocumentMature
        self.kind = kind
        self.notificationGroup = notificationGroup
        self.notificationType = notificationType
        self.pcampaignID = pcampaignID
        self.reason = reason
        self.isShowNotificationSettingsAction = isShowNotificationSettingsAction
        self.targetURL = targetURL
        self.timeToExpireMs = timeToExpireMs
        self.title = title
    }

    private enum CodingKeys: String, CodingKey {
        case body
        case crmExperimentIDs = "crmExperimentIds"
        case docID = "doc_id"
        case docType = "doc_type"
        case isDontShowNotification = "dont_show_notification"
        case iconURL = "iconUrl"
        case isDocumentMature = "is_document_mature"
        case kind
        case notificationGroup
        case notificationType = "notification_type"
        case pcampaignID = "pcampaign_id"
        case reason
        case isShowNotificationSettingsAction = "show_notification_settings_action"
        case targetURL = "targetUrl"
        case timeToExpireMs
        case title
    }
}

public struct Offers: Codable {
    /// A list of offers.
    public var items: [Item]?
    /// Resource type.
    public var kind: String?

    public struct Item: Codable {
        public var artURL: String?
        public var gservicesKey: String?
        public var id: String?
        public var items: [Item]?

        public struct Item: Codable {
            public var author: String?
            public var canonicalVolumeLink: String?
            public var coverURL: String?
            public var description: String?
            public var title: String?
            public var volumeID: String?

            public init(author: String? = nil, canonicalVolumeLink: String? = nil, coverURL: String? = nil, description: String? = nil, title: String? = nil, volumeID: String? = nil) {
                self.author = author
                self.canonicalVolumeLink = canonicalVolumeLink
                self.coverURL = coverURL
                self.description = description
                self.title = title
                self.volumeID = volumeID
            }

            private enum CodingKeys: String, CodingKey {
                case author
                case canonicalVolumeLink
                case coverURL = "coverUrl"
                case description
                case title
                case volumeID = "volumeId"
            }
        }

        public init(artURL: String? = nil, gservicesKey: String? = nil, id: String? = nil, items: [Item]? = nil) {
            self.artURL = artURL
            self.gservicesKey = gservicesKey
            self.id = id
            self.items = items
        }

        private enum CodingKeys: String, CodingKey {
            case artURL = "artUrl"
            case gservicesKey
            case id
            case items
        }
    }

    public init(items: [Item]? = nil, kind: String? = nil) {
        self.items = items
        self.kind = kind
    }
}

public struct ReadingPosition: Codable {
    /// Position in an EPUB as a CFI.
    public var epubCfiPosition: String?
    /// Position in a volume for image-based content.
    public var gbImagePosition: String?
    /// Position in a volume for text-based content.
    public var gbTextPosition: String?
    /// Resource type for a reading position.
    public var kind: String?
    /// Position in a PDF file.
    public var pdfPosition: String?
    /// Timestamp when this reading position was last updated (formatted UTC timestamp with millisecond resolution).
    public var updated: String?
    /// Volume id associated with this reading position.
    public var volumeID: String?

    public init(epubCfiPosition: String? = nil, gbImagePosition: String? = nil, gbTextPosition: String? = nil, kind: String? = nil, pdfPosition: String? = nil, updated: String? = nil, volumeID: String? = nil) {
        self.epubCfiPosition = epubCfiPosition
        self.gbImagePosition = gbImagePosition
        self.gbTextPosition = gbTextPosition
        self.kind = kind
        self.pdfPosition = pdfPosition
        self.updated = updated
        self.volumeID = volumeID
    }

    private enum CodingKeys: String, CodingKey {
        case epubCfiPosition
        case gbImagePosition
        case gbTextPosition
        case kind
        case pdfPosition
        case updated
        case volumeID = "volumeId"
    }
}

public struct RequestAccessData: Codable {
    public var concurrentAccess: ConcurrentAccessRestriction?
    public var downloadAccess: DownloadAccessRestriction?
    /// Resource type.
    public var kind: String?

    public init(concurrentAccess: ConcurrentAccessRestriction? = nil, downloadAccess: DownloadAccessRestriction? = nil, kind: String? = nil) {
        self.concurrentAccess = concurrentAccess
        self.downloadAccess = downloadAccess
        self.kind = kind
    }
}

public struct Review: Codable {
    /// Author of this review.
    public var author: Author?
    /// Review text.
    public var content: String?
    /// Date of this review.
    public var date: String?
    /// URL for the full review text, for reviews gathered from the web.
    public var fullTextURL: String?
    /// Resource type for a review.
    public var kind: String?
    /// Star rating for this review. Possible values are ONE, TWO, THREE, FOUR, FIVE or NOT_RATED.
    public var rating: String?
    /// Information regarding the source of this review, when the review is not from a Google Books user.
    public var source: Source?
    /// Title for this review.
    public var title: String?
    /// Source type for this review. Possible values are EDITORIAL, WEB_USER or GOOGLE_USER.
    public var type: String?
    /// Volume that this review is for.
    public var volumeID: String?

    /// Author of this review.
    public struct Author: Codable {
        /// Name of this person.
        public var displayName: String?

        public init(displayName: String? = nil) {
            self.displayName = displayName
        }
    }

    /// Information regarding the source of this review, when the review is not from a Google Books user.
    public struct Source: Codable {
        /// Name of the source.
        public var description: String?
        /// Extra text about the source of the review.
        public var extraDescription: String?
        /// URL of the source of the review.
        public var url: String?

        public init(description: String? = nil, extraDescription: String? = nil, url: String? = nil) {
            self.description = description
            self.extraDescription = extraDescription
            self.url = url
        }
    }

    public init(author: Author? = nil, content: String? = nil, date: String? = nil, fullTextURL: String? = nil, kind: String? = nil, rating: String? = nil, source: Source? = nil, title: String? = nil, type: String? = nil, volumeID: String? = nil) {
        self.author = author
        self.content = content
        self.date = date
        self.fullTextURL = fullTextURL
        self.kind = kind
        self.rating = rating
        self.source = source
        self.title = title
        self.type = type
        self.volumeID = volumeID
    }

    private enum CodingKeys: String, CodingKey {
        case author
        case content
        case date
        case fullTextURL = "fullTextUrl"
        case kind
        case rating
        case source
        case title
        case type
        case volumeID = "volumeId"
    }
}

public struct Series: Codable {
    /// Resource type.
    public var kind: String?
    public var series: [SeriesItem]?

    public struct SeriesItem: Codable {
        public var bannerImageURL: String?
        public var isEligibleForSubscription: Bool?
        public var imageURL: String?
        public var isComplete: Bool?
        public var seriesFormatType: String?
        public var seriesID: String?
        public var seriesSubscriptionReleaseInfo: SeriesSubscriptionReleaseInfo?
        public var seriesType: String?
        public var subscriptionID: String?
        public var title: String?

        public struct SeriesSubscriptionReleaseInfo: Codable {
            public var cancelTime: String?
            public var currentReleaseInfo: CurrentReleaseInfo?
            public var nextReleaseInfo: NextReleaseInfo?
            public var seriesSubscriptionType: String?

            public struct CurrentReleaseInfo: Codable {
                public var amountInMicros: Double?
                public var currencyCode: String?
                public var releaseNumber: String?
                public var releaseTime: String?

                public init(amountInMicros: Double? = nil, currencyCode: String? = nil, releaseNumber: String? = nil, releaseTime: String? = nil) {
                    self.amountInMicros = amountInMicros
                    self.currencyCode = currencyCode
                    self.releaseNumber = releaseNumber
                    self.releaseTime = releaseTime
                }
            }

            public struct NextReleaseInfo: Codable {
                public var amountInMicros: Double?
                public var currencyCode: String?
                public var releaseNumber: String?
                public var releaseTime: String?

                public init(amountInMicros: Double? = nil, currencyCode: String? = nil, releaseNumber: String? = nil, releaseTime: String? = nil) {
                    self.amountInMicros = amountInMicros
                    self.currencyCode = currencyCode
                    self.releaseNumber = releaseNumber
                    self.releaseTime = releaseTime
                }
            }

            public init(cancelTime: String? = nil, currentReleaseInfo: CurrentReleaseInfo? = nil, nextReleaseInfo: NextReleaseInfo? = nil, seriesSubscriptionType: String? = nil) {
                self.cancelTime = cancelTime
                self.currentReleaseInfo = currentReleaseInfo
                self.nextReleaseInfo = nextReleaseInfo
                self.seriesSubscriptionType = seriesSubscriptionType
            }
        }

        public init(bannerImageURL: String? = nil, isEligibleForSubscription: Bool? = nil, imageURL: String? = nil, isComplete: Bool? = nil, seriesFormatType: String? = nil, seriesID: String? = nil, seriesSubscriptionReleaseInfo: SeriesSubscriptionReleaseInfo? = nil, seriesType: String? = nil, subscriptionID: String? = nil, title: String? = nil) {
            self.bannerImageURL = bannerImageURL
            self.isEligibleForSubscription = isEligibleForSubscription
            self.imageURL = imageURL
            self.isComplete = isComplete
            self.seriesFormatType = seriesFormatType
            self.seriesID = seriesID
            self.seriesSubscriptionReleaseInfo = seriesSubscriptionReleaseInfo
            self.seriesType = seriesType
            self.subscriptionID = subscriptionID
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case bannerImageURL = "bannerImageUrl"
            case isEligibleForSubscription = "eligibleForSubscription"
            case imageURL = "imageUrl"
            case isComplete
            case seriesFormatType
            case seriesID = "seriesId"
            case seriesSubscriptionReleaseInfo
            case seriesType
            case subscriptionID = "subscriptionId"
            case title
        }
    }

    public init(kind: String? = nil, series: [SeriesItem]? = nil) {
        self.kind = kind
        self.series = series
    }
}

public struct Seriesmembership: Codable {
    /// Resorce type.
    public var kind: String?
    public var member: [Volume]?
    public var nextPageToken: String?

    public init(kind: String? = nil, member: [Volume]? = nil, nextPageToken: String? = nil) {
        self.kind = kind
        self.member = member
        self.nextPageToken = nextPageToken
    }
}

public struct Usersettings: Codable {
    /// Resource type.
    public var kind: String?
    /// User settings in sub-objects, each for different purposes.
    public var notesExport: NotesExport?
    public var notification: Notification?

    /// User settings in sub-objects, each for different purposes.
    public struct NotesExport: Codable {
        public var folderName: String?
        public var isEnabled: Bool?

        public init(folderName: String? = nil, isEnabled: Bool? = nil) {
            self.folderName = folderName
            self.isEnabled = isEnabled
        }
    }

    public struct Notification: Codable {
        public var matchMyInterests: MatchMyInterests?
        public var moreFromAuthors: MoreFromAuthors?
        public var moreFromSeries: MoreFromSeries?
        public var priceDrop: PriceDrop?
        public var rewardExpirations: RewardExpirations?

        public struct MatchMyInterests: Codable {
            public var optedState: String?

            public init(optedState: String? = nil) {
                self.optedState = optedState
            }

            private enum CodingKeys: String, CodingKey {
                case optedState = "opted_state"
            }
        }

        public struct MoreFromAuthors: Codable {
            public var optedState: String?

            public init(optedState: String? = nil) {
                self.optedState = optedState
            }

            private enum CodingKeys: String, CodingKey {
                case optedState = "opted_state"
            }
        }

        public struct MoreFromSeries: Codable {
            public var optedState: String?

            public init(optedState: String? = nil) {
                self.optedState = optedState
            }

            private enum CodingKeys: String, CodingKey {
                case optedState = "opted_state"
            }
        }

        public struct PriceDrop: Codable {
            public var optedState: String?

            public init(optedState: String? = nil) {
                self.optedState = optedState
            }

            private enum CodingKeys: String, CodingKey {
                case optedState = "opted_state"
            }
        }

        public struct RewardExpirations: Codable {
            public var optedState: String?

            public init(optedState: String? = nil) {
                self.optedState = optedState
            }

            private enum CodingKeys: String, CodingKey {
                case optedState = "opted_state"
            }
        }

        public init(matchMyInterests: MatchMyInterests? = nil, moreFromAuthors: MoreFromAuthors? = nil, moreFromSeries: MoreFromSeries? = nil, priceDrop: PriceDrop? = nil, rewardExpirations: RewardExpirations? = nil) {
            self.matchMyInterests = matchMyInterests
            self.moreFromAuthors = moreFromAuthors
            self.moreFromSeries = moreFromSeries
            self.priceDrop = priceDrop
            self.rewardExpirations = rewardExpirations
        }
    }

    public init(kind: String? = nil, notesExport: NotesExport? = nil, notification: Notification? = nil) {
        self.kind = kind
        self.notesExport = notesExport
        self.notification = notification
    }
}

public struct Volume: Codable {
    /// Any information about a volume related to reading or obtaining that volume text. This information can depend on country (books may be public domain in one country but not in another, e.g.).
    public var accessInfo: AccessInfo?
    /// Opaque identifier for a specific version of a volume resource. (In LITE projection)
    public var etag: String?
    /// Unique identifier for a volume. (In LITE projection.)
    public var id: String?
    /// Resource type for a volume. (In LITE projection.)
    public var kind: String?
    /// What layers exist in this volume and high level information about them.
    public var layerInfo: LayerInfo?
    /// Recommendation related information for this volume.
    public var recommendedInfo: RecommendedInfo?
    /// Any information about a volume related to the eBookstore and/or purchaseability. This information can depend on the country where the request originates from (i.e. books may not be for sale in certain countries).
    public var saleInfo: SaleInfo?
    /// Search result information related to this volume.
    public var searchInfo: SearchInfo?
    /// URL to this resource. (In LITE projection.)
    public var selfLink: String?
    /// User specific information related to this volume. (e.g. page this user last read or whether they purchased this book)
    public var userInfo: UserInfo?
    /// General volume information.
    public var volumeInfo: VolumeInfo?

    /// Any information about a volume related to reading or obtaining that volume text. This information can depend on country (books may be public domain in one country but not in another, e.g.).
    public struct AccessInfo: Codable {
        /// Combines the access and viewability of this volume into a single status field for this user. Values can be FULL_PURCHASED, FULL_PUBLIC_DOMAIN, SAMPLE or NONE. (In LITE projection.)
        public var accessViewStatus: String?
        /// The two-letter ISO_3166-1 country code for which this access information is valid. (In LITE projection.)
        public var country: String?
        public var downloadAccess: DownloadAccessRestriction?
        /// URL to the Google Drive viewer if this volume is uploaded by the user by selecting the file from Google Drive.
        public var driveImportedContentLink: String?
        /// Whether this volume can be embedded in a viewport using the Embedded Viewer API.
        public var isEmbeddable: Bool?
        /// Information about epub content. (In LITE projection.)
        public var epub: Epub?
        /// Whether this volume requires that the client explicitly request offline download license rather than have it done automatically when loading the content, if the client supports it.
        public var isExplicitOfflineLicenseManagement: Bool?
        /// Information about pdf content. (In LITE projection.)
        public var pdf: Pdf?
        /// Whether or not this book is public domain in the country listed above.
        public var isPublicDomain: Bool?
        /// Whether quote sharing is allowed for this volume.
        public var isQuoteSharingAllowed: Bool?
        /// Whether text-to-speech is permitted for this volume. Values can be ALLOWED, ALLOWED_FOR_ACCESSIBILITY, or NOT_ALLOWED.
        public var textToSpeechPermission: String?
        /// For ordered but not yet processed orders, we give a URL that can be used to go to the appropriate Google Wallet page.
        public var viewOrderURL: String?
        /// The read access of a volume. Possible values are PARTIAL, ALL_PAGES, NO_PAGES or UNKNOWN. This value depends on the country listed above. A value of PARTIAL means that the publisher has allowed some portion of the volume to be viewed publicly, without purchase. This can apply to eBooks as well as non-eBooks. Public domain books will always have a value of ALL_PAGES.
        public var viewability: String?
        /// URL to read this volume on the Google Books site. Link will not allow users to read non-viewable volumes.
        public var webReaderLink: String?

        /// Information about epub content. (In LITE projection.)
        public struct Epub: Codable {
            /// URL to retrieve ACS token for epub download. (In LITE projection.)
            public var acsTokenLink: String?
            /// URL to download epub. (In LITE projection.)
            public var downloadLink: String?
            /// Is a flowing text epub available either as public domain or for purchase. (In LITE projection.)
            public var isAvailable: Bool?

            public init(acsTokenLink: String? = nil, downloadLink: String? = nil, isAvailable: Bool? = nil) {
                self.acsTokenLink = acsTokenLink
                self.downloadLink = downloadLink
                self.isAvailable = isAvailable
            }
        }

        /// Information about pdf content. (In LITE projection.)
        public struct Pdf: Codable {
            /// URL to retrieve ACS token for pdf download. (In LITE projection.)
            public var acsTokenLink: String?
            /// URL to download pdf. (In LITE projection.)
            public var downloadLink: String?
            /// Is a scanned image pdf available either as public domain or for purchase. (In LITE projection.)
            public var isAvailable: Bool?

            public init(acsTokenLink: String? = nil, downloadLink: String? = nil, isAvailable: Bool? = nil) {
                self.acsTokenLink = acsTokenLink
                self.downloadLink = downloadLink
                self.isAvailable = isAvailable
            }
        }

        public init(accessViewStatus: String? = nil, country: String? = nil, downloadAccess: DownloadAccessRestriction? = nil, driveImportedContentLink: String? = nil, isEmbeddable: Bool? = nil, epub: Epub? = nil, isExplicitOfflineLicenseManagement: Bool? = nil, pdf: Pdf? = nil, isPublicDomain: Bool? = nil, isQuoteSharingAllowed: Bool? = nil, textToSpeechPermission: String? = nil, viewOrderURL: String? = nil, viewability: String? = nil, webReaderLink: String? = nil) {
            self.accessViewStatus = accessViewStatus
            self.country = country
            self.downloadAccess = downloadAccess
            self.driveImportedContentLink = driveImportedContentLink
            self.isEmbeddable = isEmbeddable
            self.epub = epub
            self.isExplicitOfflineLicenseManagement = isExplicitOfflineLicenseManagement
            self.pdf = pdf
            self.isPublicDomain = isPublicDomain
            self.isQuoteSharingAllowed = isQuoteSharingAllowed
            self.textToSpeechPermission = textToSpeechPermission
            self.viewOrderURL = viewOrderURL
            self.viewability = viewability
            self.webReaderLink = webReaderLink
        }

        private enum CodingKeys: String, CodingKey {
            case accessViewStatus
            case country
            case downloadAccess
            case driveImportedContentLink
            case isEmbeddable = "embeddable"
            case epub
            case isExplicitOfflineLicenseManagement = "explicitOfflineLicenseManagement"
            case pdf
            case isPublicDomain = "publicDomain"
            case isQuoteSharingAllowed = "quoteSharingAllowed"
            case textToSpeechPermission
            case viewOrderURL = "viewOrderUrl"
            case viewability
            case webReaderLink
        }
    }

    /// What layers exist in this volume and high level information about them.
    public struct LayerInfo: Codable {
        /// A layer should appear here if and only if the layer exists for this book.
        public var layers: [Layer]?

        public struct Layer: Codable {
            /// The layer id of this layer (e.g. "geo").
            public var layerID: String?
            /// The current version of this layer's volume annotations. Note that this version applies only to the data in the books.layers.volumeAnnotations.* responses. The actual annotation data is versioned separately.
            public var volumeAnnotationsVersion: String?

            public init(layerID: String? = nil, volumeAnnotationsVersion: String? = nil) {
                self.layerID = layerID
                self.volumeAnnotationsVersion = volumeAnnotationsVersion
            }

            private enum CodingKeys: String, CodingKey {
                case layerID = "layerId"
                case volumeAnnotationsVersion
            }
        }

        public init(layers: [Layer]? = nil) {
            self.layers = layers
        }
    }

    /// Recommendation related information for this volume.
    public struct RecommendedInfo: Codable {
        /// A text explaining why this volume is recommended.
        public var explanation: String?

        public init(explanation: String? = nil) {
            self.explanation = explanation
        }
    }

    /// Any information about a volume related to the eBookstore and/or purchaseability. This information can depend on the country where the request originates from (i.e. books may not be for sale in certain countries).
    public struct SaleInfo: Codable {
        /// URL to purchase this volume on the Google Books site. (In LITE projection)
        public var buyLink: String?
        /// The two-letter ISO_3166-1 country code for which this sale information is valid. (In LITE projection.)
        public var country: String?
        /// Whether or not this volume is an eBook (can be added to the My eBooks shelf).
        public var isEbook: Bool?
        /// Suggested retail price. (In LITE projection.)
        public var listPrice: ListPrice?
        /// Offers available for this volume (sales and rentals).
        public var offers: [Offer]?
        /// The date on which this book is available for sale.
        public var onSaleDate: String?
        /// The actual selling price of the book. This is the same as the suggested retail or list price unless there are offers or discounts on this volume. (In LITE projection.)
        public var retailPrice: RetailPrice?
        /// Whether or not this book is available for sale or offered for free in the Google eBookstore for the country listed above. Possible values are FOR_SALE, FOR_RENTAL_ONLY, FOR_SALE_AND_RENTAL, FREE, NOT_FOR_SALE, or FOR_PREORDER.
        public var saleability: String?

        /// Suggested retail price. (In LITE projection.)
        public struct ListPrice: Codable {
            /// Amount in the currency listed below. (In LITE projection.)
            public var amount: Double?
            /// An ISO 4217, three-letter currency code. (In LITE projection.)
            public var currencyCode: String?

            public init(amount: Double? = nil, currencyCode: String? = nil) {
                self.amount = amount
                self.currencyCode = currencyCode
            }
        }

        public struct Offer: Codable {
            /// The finsky offer type (e.g., PURCHASE=0 RENTAL=3)
            public var finskyOfferType: Int?
            /// Indicates whether the offer is giftable.
            public var isGiftable: Bool?
            /// Offer list (=undiscounted) price in Micros.
            public var listPrice: ListPrice?
            /// The rental duration (for rental offers only).
            public var rentalDuration: RentalDuration?
            /// Offer retail (=discounted) price in Micros
            public var retailPrice: RetailPrice?

            /// Offer list (=undiscounted) price in Micros.
            public struct ListPrice: Codable {
                public var amountInMicros: Double?
                public var currencyCode: String?

                public init(amountInMicros: Double? = nil, currencyCode: String? = nil) {
                    self.amountInMicros = amountInMicros
                    self.currencyCode = currencyCode
                }
            }

            /// The rental duration (for rental offers only).
            public struct RentalDuration: Codable {
                public var count: Double?
                public var unit: String?

                public init(count: Double? = nil, unit: String? = nil) {
                    self.count = count
                    self.unit = unit
                }
            }

            /// Offer retail (=discounted) price in Micros
            public struct RetailPrice: Codable {
                public var amountInMicros: Double?
                public var currencyCode: String?

                public init(amountInMicros: Double? = nil, currencyCode: String? = nil) {
                    self.amountInMicros = amountInMicros
                    self.currencyCode = currencyCode
                }
            }

            public init(finskyOfferType: Int? = nil, isGiftable: Bool? = nil, listPrice: ListPrice? = nil, rentalDuration: RentalDuration? = nil, retailPrice: RetailPrice? = nil) {
                self.finskyOfferType = finskyOfferType
                self.isGiftable = isGiftable
                self.listPrice = listPrice
                self.rentalDuration = rentalDuration
                self.retailPrice = retailPrice
            }

            private enum CodingKeys: String, CodingKey {
                case finskyOfferType
                case isGiftable = "giftable"
                case listPrice
                case rentalDuration
                case retailPrice
            }
        }

        /// The actual selling price of the book. This is the same as the suggested retail or list price unless there are offers or discounts on this volume. (In LITE projection.)
        public struct RetailPrice: Codable {
            /// Amount in the currency listed below. (In LITE projection.)
            public var amount: Double?
            /// An ISO 4217, three-letter currency code. (In LITE projection.)
            public var currencyCode: String?

            public init(amount: Double? = nil, currencyCode: String? = nil) {
                self.amount = amount
                self.currencyCode = currencyCode
            }
        }

        public init(buyLink: String? = nil, country: String? = nil, isEbook: Bool? = nil, listPrice: ListPrice? = nil, offers: [Offer]? = nil, onSaleDate: String? = nil, retailPrice: RetailPrice? = nil, saleability: String? = nil) {
            self.buyLink = buyLink
            self.country = country
            self.isEbook = isEbook
            self.listPrice = listPrice
            self.offers = offers
            self.onSaleDate = onSaleDate
            self.retailPrice = retailPrice
            self.saleability = saleability
        }
    }

    /// Search result information related to this volume.
    public struct SearchInfo: Codable {
        /// A text snippet containing the search query.
        public var textSnippet: String?

        public init(textSnippet: String? = nil) {
            self.textSnippet = textSnippet
        }
    }

    /// User specific information related to this volume. (e.g. page this user last read or whether they purchased this book)
    public struct UserInfo: Codable {
        /// Timestamp when this volume was acquired by the user. (RFC 3339 UTC date-time format) Acquiring includes purchase, user upload, receiving family sharing, etc.
        public var acquiredTime: String?
        /// How this volume was acquired.
        public var acquisitionType: Int?
        /// Copy/Paste accounting information.
        public var copy: Copy?
        /// Whether this volume is purchased, sample, pd download etc.
        public var entitlementType: Int?
        /// Information on the ability to share with the family.
        public var familySharing: FamilySharing?
        /// Whether or not the user shared this volume with the family.
        public var isFamilySharedFromUser: Bool?
        /// Whether or not the user received this volume through family sharing.
        public var isFamilySharedToUser: Bool?
        /// Deprecated: Replaced by familySharing.
        public var isFamilySharingAllowed: Bool?
        /// Deprecated: Replaced by familySharing.
        public var isFamilySharingDisabledByFop: Bool?
        /// Whether or not this volume is currently in "my books."
        public var isInMyBooks: Bool?
        /// Whether or not this volume was pre-ordered by the authenticated user making the request. (In LITE projection.)
        public var isPreordered: Bool?
        /// Whether or not this volume was purchased by the authenticated user making the request. (In LITE projection.)
        public var isPurchased: Bool?
        /// Whether or not this volume was user uploaded.
        public var isUploaded: Bool?
        public var readingPosition: ReadingPosition?
        /// Period during this book is/was a valid rental.
        public var rentalPeriod: RentalPeriod?
        /// Whether this book is an active or an expired rental.
        public var rentalState: String?
        public var review: Review?
        /// Timestamp when this volume was last modified by a user action, such as a reading position update, volume purchase or writing a review. (RFC 3339 UTC date-time format).
        public var updated: String?
        public var userUploadedVolumeInfo: UserUploadedVolumeInfo?

        /// Copy/Paste accounting information.
        public struct Copy: Codable {
            public var allowedCharacterCount: Int?
            public var limitType: String?
            public var remainingCharacterCount: Int?
            public var updated: String?

            public init(allowedCharacterCount: Int? = nil, limitType: String? = nil, remainingCharacterCount: Int? = nil, updated: String? = nil) {
                self.allowedCharacterCount = allowedCharacterCount
                self.limitType = limitType
                self.remainingCharacterCount = remainingCharacterCount
                self.updated = updated
            }
        }

        /// Information on the ability to share with the family.
        public struct FamilySharing: Codable {
            /// The role of the user in the family.
            public var familyRole: String?
            /// Whether or not this volume can be shared with the family by the user. This includes sharing eligibility of both the volume and the user. If the value is true, the user can initiate a family sharing action.
            public var isSharingAllowed: Bool?
            /// Whether or not sharing this volume is temporarily disabled due to issues with the Family Wallet.
            public var isSharingDisabledByFop: Bool?

            public init(familyRole: String? = nil, isSharingAllowed: Bool? = nil, isSharingDisabledByFop: Bool? = nil) {
                self.familyRole = familyRole
                self.isSharingAllowed = isSharingAllowed
                self.isSharingDisabledByFop = isSharingDisabledByFop
            }
        }

        /// Period during this book is/was a valid rental.
        public struct RentalPeriod: Codable {
            public var endUtcSec: String?
            public var startUtcSec: String?

            public init(endUtcSec: String? = nil, startUtcSec: String? = nil) {
                self.endUtcSec = endUtcSec
                self.startUtcSec = startUtcSec
            }
        }

        public struct UserUploadedVolumeInfo: Codable {
            public var processingState: String?

            public init(processingState: String? = nil) {
                self.processingState = processingState
            }
        }

        public init(acquiredTime: String? = nil, acquisitionType: Int? = nil, copy: Copy? = nil, entitlementType: Int? = nil, familySharing: FamilySharing? = nil, isFamilySharedFromUser: Bool? = nil, isFamilySharedToUser: Bool? = nil, isFamilySharingAllowed: Bool? = nil, isFamilySharingDisabledByFop: Bool? = nil, isInMyBooks: Bool? = nil, isPreordered: Bool? = nil, isPurchased: Bool? = nil, isUploaded: Bool? = nil, readingPosition: ReadingPosition? = nil, rentalPeriod: RentalPeriod? = nil, rentalState: String? = nil, review: Review? = nil, updated: String? = nil, userUploadedVolumeInfo: UserUploadedVolumeInfo? = nil) {
            self.acquiredTime = acquiredTime
            self.acquisitionType = acquisitionType
            self.copy = copy
            self.entitlementType = entitlementType
            self.familySharing = familySharing
            self.isFamilySharedFromUser = isFamilySharedFromUser
            self.isFamilySharedToUser = isFamilySharedToUser
            self.isFamilySharingAllowed = isFamilySharingAllowed
            self.isFamilySharingDisabledByFop = isFamilySharingDisabledByFop
            self.isInMyBooks = isInMyBooks
            self.isPreordered = isPreordered
            self.isPurchased = isPurchased
            self.isUploaded = isUploaded
            self.readingPosition = readingPosition
            self.rentalPeriod = rentalPeriod
            self.rentalState = rentalState
            self.review = review
            self.updated = updated
            self.userUploadedVolumeInfo = userUploadedVolumeInfo
        }
    }

    /// General volume information.
    public struct VolumeInfo: Codable {
        /// Whether anonymous logging should be allowed.
        public var allowAnonLogging: Bool?
        /// The names of the authors and/or editors for this volume. (In LITE projection)
        public var authors: [String]?
        /// The mean review rating for this volume. (min = 1.0, max = 5.0)
        public var averageRating: Double?
        /// Canonical URL for a volume. (In LITE projection.)
        public var canonicalVolumeLink: String?
        /// A list of subject categories, such as "Fiction", "Suspense", etc.
        public var categories: [String]?
        /// Whether the volume has comics content.
        public var isComicsContent: Bool?
        /// An identifier for the version of the volume content (text &amp; images). (In LITE projection)
        public var contentVersion: String?
        /// A synopsis of the volume. The text of the description is formatted in HTML and includes simple formatting elements, such as b, i, and br tags. (In LITE projection.)
        public var description: String?
        /// Physical dimensions of this volume.
        public var dimensions: Dimensions?
        /// A list of image links for all the sizes that are available. (In LITE projection.)
        public var imageLinks: ImageLinks?
        /// Industry standard identifiers for this volume.
        public var industryIdentifiers: [IndustryIdentifier]?
        /// URL to view information about this volume on the Google Books site. (In LITE projection)
        public var infoLink: String?
        /// Best language for this volume (based on content). It is the two-letter ISO 639-1 code such as 'fr', 'en', etc.
        public var language: String?
        /// The main category to which this volume belongs. It will be the category from the categories list returned below that has the highest weight.
        public var mainCategory: String?
        public var maturityRating: String?
        /// Total number of pages as per publisher metadata.
        public var pageCount: Int?
        /// A top-level summary of the panelization info in this volume.
        public var panelizationSummary: PanelizationSummary?
        /// URL to preview this volume on the Google Books site.
        public var previewLink: String?
        /// Type of publication of this volume. Possible values are BOOK or MAGAZINE.
        public var printType: String?
        /// Total number of printed pages in generated pdf representation.
        public var printedPageCount: Int?
        /// Date of publication. (In LITE projection.)
        public var publishedDate: String?
        /// Publisher of this volume. (In LITE projection.)
        public var publisher: String?
        /// The number of review ratings for this volume.
        public var ratingsCount: Int?
        /// The reading modes available for this volume.
        public var readingModes: ReadingModes?
        /// Total number of sample pages as per publisher metadata.
        public var samplePageCount: Int?
        public var seriesInfo: Volumeseriesinfo?
        /// Volume subtitle. (In LITE projection.)
        public var subtitle: String?
        /// Volume title. (In LITE projection.)
        public var title: String?

        /// Physical dimensions of this volume.
        public struct Dimensions: Codable {
            /// Height or length of this volume (in cm).
            public var height: String?
            /// Thickness of this volume (in cm).
            public var thickness: String?
            /// Width of this volume (in cm).
            public var width: String?

            public init(height: String? = nil, thickness: String? = nil, width: String? = nil) {
                self.height = height
                self.thickness = thickness
                self.width = width
            }
        }

        /// A list of image links for all the sizes that are available. (In LITE projection.)
        public struct ImageLinks: Codable {
            /// Image link for extra large size (width of ~1280 pixels). (In LITE projection)
            public var extraLarge: String?
            /// Image link for large size (width of ~800 pixels). (In LITE projection)
            public var large: String?
            /// Image link for medium size (width of ~575 pixels). (In LITE projection)
            public var medium: String?
            /// Image link for small size (width of ~300 pixels). (In LITE projection)
            public var small: String?
            /// Image link for small thumbnail size (width of ~80 pixels). (In LITE projection)
            public var smallThumbnail: String?
            /// Image link for thumbnail size (width of ~128 pixels). (In LITE projection)
            public var thumbnail: String?

            public init(extraLarge: String? = nil, large: String? = nil, medium: String? = nil, small: String? = nil, smallThumbnail: String? = nil, thumbnail: String? = nil) {
                self.extraLarge = extraLarge
                self.large = large
                self.medium = medium
                self.small = small
                self.smallThumbnail = smallThumbnail
                self.thumbnail = thumbnail
            }
        }

        public struct IndustryIdentifier: Codable {
            /// Industry specific volume identifier.
            public var identifier: String?
            /// Identifier type. Possible values are ISBN_10, ISBN_13, ISSN and OTHER.
            public var type: String?

            public init(identifier: String? = nil, type: String? = nil) {
                self.identifier = identifier
                self.type = type
            }
        }

        /// A top-level summary of the panelization info in this volume.
        public struct PanelizationSummary: Codable {
            public var containsEpubBubbles: Bool?
            public var containsImageBubbles: Bool?
            public var epubBubbleVersion: String?
            public var imageBubbleVersion: String?

            public init(containsEpubBubbles: Bool? = nil, containsImageBubbles: Bool? = nil, epubBubbleVersion: String? = nil, imageBubbleVersion: String? = nil) {
                self.containsEpubBubbles = containsEpubBubbles
                self.containsImageBubbles = containsImageBubbles
                self.epubBubbleVersion = epubBubbleVersion
                self.imageBubbleVersion = imageBubbleVersion
            }
        }

        /// The reading modes available for this volume.
        public struct ReadingModes: Codable {
            public var isImage: Bool?
            public var isText: Bool?

            public init(isImage: Bool? = nil, isText: Bool? = nil) {
                self.isImage = isImage
                self.isText = isText
            }

            private enum CodingKeys: String, CodingKey {
                case isImage = "image"
                case isText = "text"
            }
        }

        public init(allowAnonLogging: Bool? = nil, authors: [String]? = nil, averageRating: Double? = nil, canonicalVolumeLink: String? = nil, categories: [String]? = nil, isComicsContent: Bool? = nil, contentVersion: String? = nil, description: String? = nil, dimensions: Dimensions? = nil, imageLinks: ImageLinks? = nil, industryIdentifiers: [IndustryIdentifier]? = nil, infoLink: String? = nil, language: String? = nil, mainCategory: String? = nil, maturityRating: String? = nil, pageCount: Int? = nil, panelizationSummary: PanelizationSummary? = nil, previewLink: String? = nil, printType: String? = nil, printedPageCount: Int? = nil, publishedDate: String? = nil, publisher: String? = nil, ratingsCount: Int? = nil, readingModes: ReadingModes? = nil, samplePageCount: Int? = nil, seriesInfo: Volumeseriesinfo? = nil, subtitle: String? = nil, title: String? = nil) {
            self.allowAnonLogging = allowAnonLogging
            self.authors = authors
            self.averageRating = averageRating
            self.canonicalVolumeLink = canonicalVolumeLink
            self.categories = categories
            self.isComicsContent = isComicsContent
            self.contentVersion = contentVersion
            self.description = description
            self.dimensions = dimensions
            self.imageLinks = imageLinks
            self.industryIdentifiers = industryIdentifiers
            self.infoLink = infoLink
            self.language = language
            self.mainCategory = mainCategory
            self.maturityRating = maturityRating
            self.pageCount = pageCount
            self.panelizationSummary = panelizationSummary
            self.previewLink = previewLink
            self.printType = printType
            self.printedPageCount = printedPageCount
            self.publishedDate = publishedDate
            self.publisher = publisher
            self.ratingsCount = ratingsCount
            self.readingModes = readingModes
            self.samplePageCount = samplePageCount
            self.seriesInfo = seriesInfo
            self.subtitle = subtitle
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case allowAnonLogging
            case authors
            case averageRating
            case canonicalVolumeLink
            case categories
            case isComicsContent = "comicsContent"
            case contentVersion
            case description
            case dimensions
            case imageLinks
            case industryIdentifiers
            case infoLink
            case language
            case mainCategory
            case maturityRating
            case pageCount
            case panelizationSummary
            case previewLink
            case printType
            case printedPageCount
            case publishedDate
            case publisher
            case ratingsCount
            case readingModes
            case samplePageCount
            case seriesInfo
            case subtitle
            case title
        }
    }

    public init(accessInfo: AccessInfo? = nil, etag: String? = nil, id: String? = nil, kind: String? = nil, layerInfo: LayerInfo? = nil, recommendedInfo: RecommendedInfo? = nil, saleInfo: SaleInfo? = nil, searchInfo: SearchInfo? = nil, selfLink: String? = nil, userInfo: UserInfo? = nil, volumeInfo: VolumeInfo? = nil) {
        self.accessInfo = accessInfo
        self.etag = etag
        self.id = id
        self.kind = kind
        self.layerInfo = layerInfo
        self.recommendedInfo = recommendedInfo
        self.saleInfo = saleInfo
        self.searchInfo = searchInfo
        self.selfLink = selfLink
        self.userInfo = userInfo
        self.volumeInfo = volumeInfo
    }
}

public struct Volume2: Codable {
    /// A list of volumes.
    public var items: [Volume]?
    /// Resource type.
    public var kind: String?
    public var nextPageToken: String?

    public init(items: [Volume]? = nil, kind: String? = nil, nextPageToken: String? = nil) {
        self.items = items
        self.kind = kind
        self.nextPageToken = nextPageToken
    }
}

public struct Volumeannotation: Codable {
    /// The annotation data id for this volume annotation.
    public var annotationDataID: String?
    /// Link to get data for this annotation.
    public var annotationDataLink: String?
    /// The type of annotation this is.
    public var annotationType: String?
    /// The content ranges to identify the selected text.
    public var contentRanges: ContentRanges?
    /// Data for this annotation.
    public var data: String?
    /// Indicates that this annotation is deleted.
    public var isDeleted: Bool?
    /// Unique id of this volume annotation.
    public var id: String?
    /// Resource Type
    public var kind: String?
    /// The Layer this annotation is for.
    public var layerID: String?
    /// Pages the annotation spans.
    public var pageIDs: [String]?
    /// Excerpt from the volume.
    public var selectedText: String?
    /// URL to this resource.
    public var selfLink: String?
    /// Timestamp for the last time this anntoation was updated. (RFC 3339 UTC date-time format).
    public var updated: String?
    /// The Volume this annotation is for.
    public var volumeID: String?

    /// The content ranges to identify the selected text.
    public struct ContentRanges: Codable {
        public var cfiRange: BooksAnnotationsRange?
        /// Content version applicable to ranges below.
        public var contentVersion: String?
        public var gbImageRange: BooksAnnotationsRange?
        public var gbTextRange: BooksAnnotationsRange?

        public init(cfiRange: BooksAnnotationsRange? = nil, contentVersion: String? = nil, gbImageRange: BooksAnnotationsRange? = nil, gbTextRange: BooksAnnotationsRange? = nil) {
            self.cfiRange = cfiRange
            self.contentVersion = contentVersion
            self.gbImageRange = gbImageRange
            self.gbTextRange = gbTextRange
        }
    }

    public init(annotationDataID: String? = nil, annotationDataLink: String? = nil, annotationType: String? = nil, contentRanges: ContentRanges? = nil, data: String? = nil, isDeleted: Bool? = nil, id: String? = nil, kind: String? = nil, layerID: String? = nil, pageIDs: [String]? = nil, selectedText: String? = nil, selfLink: String? = nil, updated: String? = nil, volumeID: String? = nil) {
        self.annotationDataID = annotationDataID
        self.annotationDataLink = annotationDataLink
        self.annotationType = annotationType
        self.contentRanges = contentRanges
        self.data = data
        self.isDeleted = isDeleted
        self.id = id
        self.kind = kind
        self.layerID = layerID
        self.pageIDs = pageIDs
        self.selectedText = selectedText
        self.selfLink = selfLink
        self.updated = updated
        self.volumeID = volumeID
    }

    private enum CodingKeys: String, CodingKey {
        case annotationDataID = "annotationDataId"
        case annotationDataLink
        case annotationType
        case contentRanges
        case data
        case isDeleted = "deleted"
        case id
        case kind
        case layerID = "layerId"
        case pageIDs = "pageIds"
        case selectedText
        case selfLink
        case updated
        case volumeID = "volumeId"
    }
}

public struct Volumeannotations: Codable {
    /// A list of volume annotations.
    public var items: [Volumeannotation]?
    /// Resource type
    public var kind: String?
    /// Token to pass in for pagination for the next page. This will not be present if this request does not have more results.
    public var nextPageToken: String?
    /// The total number of volume annotations found.
    public var totalItems: Int?
    /// The version string for all of the volume annotations in this layer (not just the ones in this response). Note: the version string doesn't apply to the annotation data, just the information in this response (e.g. the location of annotations in the book).
    public var version: String?

    public init(items: [Volumeannotation]? = nil, kind: String? = nil, nextPageToken: String? = nil, totalItems: Int? = nil, version: String? = nil) {
        self.items = items
        self.kind = kind
        self.nextPageToken = nextPageToken
        self.totalItems = totalItems
        self.version = version
    }
}

public struct Volumes: Codable {
    /// A list of volumes.
    public var items: [Volume]?
    /// Resource type.
    public var kind: String?
    /// Total number of volumes found. This might be greater than the number of volumes returned in this response if results have been paginated.
    public var totalItems: Int?

    public init(items: [Volume]? = nil, kind: String? = nil, totalItems: Int? = nil) {
        self.items = items
        self.kind = kind
        self.totalItems = totalItems
    }
}

public struct Volumeseriesinfo: Codable {
    /// The display number string. This should be used only for display purposes and the actual sequence should be inferred from the below orderNumber.
    public var bookDisplayNumber: String?
    /// Resource type.
    public var kind: String?
    /// Short book title in the context of the series.
    public var shortSeriesBookTitle: String?
    public var volumeSeries: [VolumeSeriesItem]?

    public struct VolumeSeriesItem: Codable {
        /// List of issues. Applicable only for Collection Edition and Omnibus.
        public var issue: [IssueItem]?
        /// The book order number in the series.
        public var orderNumber: Int?
        /// The book type in the context of series. Examples - Single Issue, Collection Edition, etc.
        public var seriesBookType: String?
        /// The series id.
        public var seriesID: String?

        public struct IssueItem: Codable {
            public var issueDisplayNumber: String?
            public var issueOrderNumber: Int?

            public init(issueDisplayNumber: String? = nil, issueOrderNumber: Int? = nil) {
                self.issueDisplayNumber = issueDisplayNumber
                self.issueOrderNumber = issueOrderNumber
            }
        }

        public init(issue: [IssueItem]? = nil, orderNumber: Int? = nil, seriesBookType: String? = nil, seriesID: String? = nil) {
            self.issue = issue
            self.orderNumber = orderNumber
            self.seriesBookType = seriesBookType
            self.seriesID = seriesID
        }

        private enum CodingKeys: String, CodingKey {
            case issue
            case orderNumber
            case seriesBookType
            case seriesID = "seriesId"
        }
    }

    public init(bookDisplayNumber: String? = nil, kind: String? = nil, shortSeriesBookTitle: String? = nil, volumeSeries: [VolumeSeriesItem]? = nil) {
        self.bookDisplayNumber = bookDisplayNumber
        self.kind = kind
        self.shortSeriesBookTitle = shortSeriesBookTitle
        self.volumeSeries = volumeSeries
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
