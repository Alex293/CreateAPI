// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

/// Example:
///
/// {
///   "actions" : [
///     {
///       "waitFor" : {
///         "waitForSelector" : ":root"
///       }
///     }
///   ],
///   "output" : "buffer",
///   "proxy" : "country-any",
///   "type" : "base",
///   "url" : "https:\/\/ipapi.co\/json\/"
/// }
public struct Fetchrequest: Codable {
    /// Specify URL to download.
    public var url: String
    /// If set to `base`, the Base fetcher is used for downloading web page content. Use `chrome` for fetching content with a Headless chrome browser. If omitted `base` fetcher is used by default.
    public var type: `Type`
    /// Specify proxy by adding [country ISO code](https://en.wikipedia.org/wiki/ISO_3166-2) to `country-` value to send requests through a proxy in the specified country. Use `country-any` to use random geo-targets.
    ///
    /// Example: "country-sk"
    public var proxy: String?
    /// Specify a wait delay (in seconds). This may be useful if certain elements of the web site need to be rendered after the initial page load. _(Chrome fetcher type only)_
    public var waitDelay: Double?
    /// The "Initial Cookies" option is useful for crawling websites that require a login. The simplest solution to get an array of cookies for specific websites is to use a web browser "EditThisCookie" extension. Copy a cookie array with "EditThisCookie" and paste it into the "Initial cookie" field.
    public var initialCookies: [InitialCookie]?
    /// The HTTP 200 OK success status response code indicates that the request has succeeded. Sometimes a server returns normal HTML content even with an erroneous Non-200 HTTP response status code. The IgnoreHTTPStatusCode option is useful when you need to force the return of HTML content. Defaults to "false."
    public var isIgnoreHTTPStatusErrCodes: Bool?
    /// Use actions to automate manual workflows while rendering web pages. They simulate real-world human interaction with pages. _(Chrome fetcher type only)_
    public var actions: [Action]?
    /// If set to _file_, the content of downloaded HTML is uploaded to Dataflow Kit Storage first. Then the link to this file is returned. Overwise, downloaded content is returned in the response body.
    public var output: Output?

    /// If set to `base`, the Base fetcher is used for downloading web page content. Use `chrome` for fetching content with a Headless chrome browser. If omitted `base` fetcher is used by default.
    public enum `Type`: String, Codable, CaseIterable {
        case base
        case chrome
    }

    /// If set to _file_, the content of downloaded HTML is uploaded to Dataflow Kit Storage first. Then the link to this file is returned. Overwise, downloaded content is returned in the response body.
    public enum Output: String, Codable, CaseIterable {
        case buffer
        case file
    }

    public init(url: String, type: `Type`, proxy: String? = nil, waitDelay: Double? = nil, initialCookies: [InitialCookie]? = nil, isIgnoreHTTPStatusErrCodes: Bool? = nil, actions: [Action]? = nil, output: Output? = nil) {
        self.url = url
        self.type = type
        self.proxy = proxy
        self.waitDelay = waitDelay
        self.initialCookies = initialCookies
        self.isIgnoreHTTPStatusErrCodes = isIgnoreHTTPStatusErrCodes
        self.actions = actions
        self.output = output
    }

    private enum CodingKeys: String, CodingKey {
        case url
        case type
        case proxy
        case waitDelay
        case initialCookies
        case isIgnoreHTTPStatusErrCodes = "ignoreHTTPStatusErrCodes"
        case actions
        case output
    }
}

/// Example:
///
/// {
///   "commonParent" : "div[id].result",
///   "fields" : [
///     {
///       "attrs" : [
///         "href",
///         "text"
///       ],
///       "filters" : [
///         {
///           "name" : "trim"
///         }
///       ],
///       "name" : "link",
///       "selector" : ".result__a",
///       "type" : 2
///     },
///     {
///       "attrs" : [
///         "text"
///       ],
///       "filters" : [
///         {
///           "name" : "trim"
///         }
///       ],
///       "name" : "description",
///       "selector" : ".js-result-snippet",
///       "type" : 1
///     }
///   ],
///   "format" : "json",
///   "name" : "duckduckgo",
///   "request" : {
///     "proxy" : "country-any",
///     "type" : "chrome",
///     "url" : "https:\/\/duckduckgo.com\/?q=Dataflow+kit&ia=web"
///   }
/// }
public struct Serprequest: Codable {
    /// Collection name.
    public var name: String
    /// Url holds the link to a Search Engine to use, and other optional parameters like languages or country.
    public var url: String
    /// For SERP requests you should _always_ use `chrome` type to fetch content with a Headless chrome browser
    ///
    /// Example: "chrome"
    public var type: String
    /// Always specify proxy for sending SERP requests. Add choosen [country ISO code](https://en.wikipedia.org/wiki/ISO_3166-2) to `country-` value to send requests through a proxy in the specified country. Use `country-any` to use random geo-targets.
    ///
    /// Example: "country-any"
    public var proxy: String
    /// Specify CSS selectors (patterns) used to gather data from Search Engine Result Pages.
    /// 
    /// Ready-to-use payloads for collecting search results from the most popular Search Engines are available. These payloads are customizable, though.
    public var fields: [Field]?
    /// Specify number of pages to crawl.
    public var pageNum: Int?
    /// Extracted data is returned either in CSV, MS Excel, JSON, JSON(Lines) or XML format.
    public var format: Format

    /// Extracted data is returned either in CSV, MS Excel, JSON, JSON(Lines) or XML format.
    public enum Format: String, Codable, CaseIterable {
        case csv
        case json
        case jsonl
        case excel
        case xml
    }

    public init(name: String, url: String, type: String, proxy: String, fields: [Field]? = nil, pageNum: Int? = nil, format: Format) {
        self.name = name
        self.url = url
        self.type = type
        self.proxy = proxy
        self.fields = fields
        self.pageNum = pageNum
        self.format = format
    }
}

/// Example:
///
/// {
///   "fields" : [
///     {
///       "attrs" : [
///         "text"
///       ],
///       "filters" : [
///         {
///           "name" : "trim"
///         }
///       ],
///       "name" : "Number",
///       "selector" : ".badge-primary",
///       "type" : 1
///     },
///     {
///       "attrs" : [
///         "href",
///         "text"
///       ],
///       "filters" : [
///         {
///           "name" : "trim"
///         }
///       ],
///       "name" : "Name",
///       "selector" : "#cards a",
///       "type" : 2
///     },
///     {
///       "attrs" : [
///         "src",
///         "alt"
///       ],
///       "filters" : [
///         {
///           "name" : "trim"
///         }
///       ],
///       "name" : "Picture",
///       "selector" : ".card-img-top",
///       "type" : 0
///     }
///   ],
///   "format" : "json",
///   "name" : "test.dataflowkit.com",
///   "paginator" : {
///     "nextPageSelector" : ".page-item:nth-child(2) .page-link",
///     "pageNum" : 2
///   },
///   "path" : false,
///   "request" : {
///     "type" : "chrome",
///     "url" : "https:\/\/test.dataflowkit.com\/persons\/page-0"
///   }
/// }
public struct Parserequest: Codable {
    /// Collection name.
    public var name: String
    public var request: Fetchrequest?
    /// Specifies common ancestor block for a set of fields used to extract data from a web page. _(CSS Selector)_
    ///
    /// Example: ".common-block"
    public var commonParent: String?
    /// Define a  set of fields used to extract data from a web page. A Field represents a given chunk of extracted data from every block on each page.
    public var fields: [Field]
    /// Specify _Next link_ paginator on pages containing a link pointing to the next page. The next page link is extracted from a document by querying href attribute of a given element's CSS selector.
    public var paginator: Paginator?
    /// Path
    ///
    /// Path is a special parameter specifying navigation pages only. It collects information from detailed pages. No results from the current page return. Defaults to false.
    public var isPath: Bool
    /// Extracted data is returned either in CSV, MS Excel, JSON, JSON(Lines) or XML format.
    public var format: Format
    public var proxy: AnyJSON
    public var type: AnyJSON
    public var url: AnyJSON

    /// Extracted data is returned either in CSV, MS Excel, JSON, JSON(Lines) or XML format.
    public enum Format: String, Codable, CaseIterable {
        case csv
        case json
        case jsonl
        case excel
        case xml
    }

    public init(name: String, request: Fetchrequest? = nil, commonParent: String? = nil, fields: [Field], paginator: Paginator? = nil, isPath: Bool? = nil, format: Format, proxy: AnyJSON, type: AnyJSON, url: AnyJSON) {
        self.name = name
        self.request = request
        self.commonParent = commonParent
        self.fields = fields
        self.paginator = paginator
        self.isPath = isPath ?? false
        self.format = format
        self.proxy = proxy
        self.type = type
        self.url = url
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case request
        case commonParent
        case fields
        case paginator
        case isPath = "path"
        case format
        case proxy
        case type
        case url
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.name = try values.decode(String.self, forKey: .name)
        self.request = try values.decodeIfPresent(Fetchrequest.self, forKey: .request)
        self.commonParent = try values.decodeIfPresent(String.self, forKey: .commonParent)
        self.fields = try values.decode([Field].self, forKey: .fields)
        self.paginator = try values.decodeIfPresent(Paginator.self, forKey: .paginator)
        self.isPath = try values.decodeIfPresent(Bool.self, forKey: .isPath) ?? false
        self.format = try values.decode(Format.self, forKey: .format)
        self.proxy = try values.decode(AnyJSON.self, forKey: .proxy)
        self.type = try values.decode(AnyJSON.self, forKey: .type)
        self.url = try values.decode(AnyJSON.self, forKey: .url)
    }
}

/// URL to PDF request
///
/// Example:
///
/// {
///   "landscape" : false,
///   "marginBottom" : 0.40000000000000002,
///   "marginLeft" : 0.40000000000000002,
///   "marginRight" : 0.40000000000000002,
///   "marginTop" : 0.40000000000000002,
///   "pageRanges" : null,
///   "paperSize" : "A4",
///   "printBackground" : false,
///   "printHeaderFooter" : false,
///   "scale" : 1,
///   "url" : "https:\/\/dataflowkit.com",
///   "waitDelay" : 0.5
/// }
public struct Url2pdfrequest: Codable {
    /// The full URL address (including HTTP/HTTPS) of a web page that you want to save as PDF
    public var url: String
    /// Specify proxy by adding [country ISO code](https://en.wikipedia.org/wiki/ISO_3166-2) to `country-` value to send requests through a proxy in the specified country. Use `country-any` to use random geo-targets.
    ///
    /// Example: "country-any"
    public var proxy: String?
    /// Paper orientation. Parameter landscape = false means portrait orientation. Set landscape to true for landscape page oriantation.
    public var isLandscape: Bool
    /// Page size parameter consists of the most popular page formats.
    public var paperSize: PaperSize?
    /// Print background graphics in the PDF.
    public var isPrintBackground: Bool
    /// Specify page ranges to convert. Defaults to the empty value, which means convert all pages.
    ///
    /// Example: "1-4, 6, 10-12"
    public var pageRanges: String?
    /// By default, PDF document content is generated according to dimensions of the original web page content. Using the `scale` parameter, you can specify a custom zoom factor from 0.1 to 5.0 of the webpage rendering.
    public var scale: Double?
    /// PrintHeaderFooter  parameter consists of the date, name of the web page, the page URL, and how many pages the document you are printing.
    public var isPrintHeaderFooter: Bool
    /// Top Margin of the PDF (in inches)
    public var marginTop: Double?
    /// Left Margin of the PDF (in inches)
    public var marginLeft: Double?
    /// Right Margin of the PDF (in inches)
    public var marginRight: Double?
    /// Bottom Margin of the PDF (in inches)
    public var marginBottom: Double?
    /// Specify a wait delay (in seconds). This may be useful if certain elements of the web site need to be rendered after the initial page load.
    public var waitDelay: Double?
    /// The "Initial Cookies" option is useful for crawling websites that require a login. The simplest solution to get an array of cookies for specific websites is to use a web browser "EditThisCookie" extension. Copy a cookie array with "EditThisCookie" and paste it into the "Initial cookie" field.
    public var initialCookies: [InitialCookie]?
    /// The HTTP 200 OK success status response code indicates that the request has succeeded. Sometimes a server returns normal HTML content even with an erroneous Non-200 HTTP response status code. The IgnoreHTTPStatusCode option is useful when you need to force the return of HTML content. Defaults to "false."
    public var isIgnoreHTTPStatusErrCodes: Bool?
    /// Use actions to automate manual workflows while rendering web pages. They simulate real-world human interaction with pages.
    public var actions: [Action]?
    /// If set to _file_, the resulted PDF is uploaded to Dataflow Kit Storage first. Then the link to this file is returned. Overwise, PDF content is returned in the response body.
    public var output: Output?

    /// Page size parameter consists of the most popular page formats.
    public enum PaperSize: String, Codable, CaseIterable {
        case a3 = "A3"
        case a4 = "A4"
        case a5 = "A5"
        case a6 = "A6"
        case letter = "Letter"
        case legal = "Legal"
        case tabloid = "Tabloid"
    }

    /// If set to _file_, the resulted PDF is uploaded to Dataflow Kit Storage first. Then the link to this file is returned. Overwise, PDF content is returned in the response body.
    public enum Output: String, Codable, CaseIterable {
        case buffer
        case file
    }

    public init(url: String, proxy: String? = nil, isLandscape: Bool? = nil, paperSize: PaperSize? = nil, isPrintBackground: Bool? = nil, pageRanges: String? = nil, scale: Double? = nil, isPrintHeaderFooter: Bool? = nil, marginTop: Double? = nil, marginLeft: Double? = nil, marginRight: Double? = nil, marginBottom: Double? = nil, waitDelay: Double? = nil, initialCookies: [InitialCookie]? = nil, isIgnoreHTTPStatusErrCodes: Bool? = nil, actions: [Action]? = nil, output: Output? = nil) {
        self.url = url
        self.proxy = proxy
        self.isLandscape = isLandscape ?? false
        self.paperSize = paperSize
        self.isPrintBackground = isPrintBackground ?? false
        self.pageRanges = pageRanges
        self.scale = scale
        self.isPrintHeaderFooter = isPrintHeaderFooter ?? false
        self.marginTop = marginTop
        self.marginLeft = marginLeft
        self.marginRight = marginRight
        self.marginBottom = marginBottom
        self.waitDelay = waitDelay
        self.initialCookies = initialCookies
        self.isIgnoreHTTPStatusErrCodes = isIgnoreHTTPStatusErrCodes
        self.actions = actions
        self.output = output
    }

    private enum CodingKeys: String, CodingKey {
        case url
        case proxy
        case isLandscape = "landscape"
        case paperSize
        case isPrintBackground = "printBackground"
        case pageRanges
        case scale
        case isPrintHeaderFooter = "printHeaderFooter"
        case marginTop
        case marginLeft
        case marginRight
        case marginBottom
        case waitDelay
        case initialCookies
        case isIgnoreHTTPStatusErrCodes = "ignoreHTTPStatusErrCodes"
        case actions
        case output
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.url = try values.decode(String.self, forKey: .url)
        self.proxy = try values.decodeIfPresent(String.self, forKey: .proxy)
        self.isLandscape = try values.decodeIfPresent(Bool.self, forKey: .isLandscape) ?? false
        self.paperSize = try values.decodeIfPresent(PaperSize.self, forKey: .paperSize)
        self.isPrintBackground = try values.decodeIfPresent(Bool.self, forKey: .isPrintBackground) ?? false
        self.pageRanges = try values.decodeIfPresent(String.self, forKey: .pageRanges)
        self.scale = try values.decodeIfPresent(Double.self, forKey: .scale)
        self.isPrintHeaderFooter = try values.decodeIfPresent(Bool.self, forKey: .isPrintHeaderFooter) ?? false
        self.marginTop = try values.decodeIfPresent(Double.self, forKey: .marginTop)
        self.marginLeft = try values.decodeIfPresent(Double.self, forKey: .marginLeft)
        self.marginRight = try values.decodeIfPresent(Double.self, forKey: .marginRight)
        self.marginBottom = try values.decodeIfPresent(Double.self, forKey: .marginBottom)
        self.waitDelay = try values.decodeIfPresent(Double.self, forKey: .waitDelay)
        self.initialCookies = try values.decodeIfPresent([InitialCookie].self, forKey: .initialCookies)
        self.isIgnoreHTTPStatusErrCodes = try values.decodeIfPresent(Bool.self, forKey: .isIgnoreHTTPStatusErrCodes)
        self.actions = try values.decodeIfPresent([Action].self, forKey: .actions)
        self.output = try values.decodeIfPresent(Output.self, forKey: .output)
    }
}

/// URL to Screenshot request
///
/// Example:
///
/// {
///   "format" : "jpeg",
///   "height" : 1080,
///   "quality" : 80,
///   "scale" : 1,
///   "url" : "https:\/\/dataflowkit.com",
///   "waitDelay" : 0.5,
///   "width" : 1920
/// }
public struct Url2screenshotrequest: Codable {
    /// The full URL address (including HTTP/HTTPS) of a web page that you want to capture
    public var url: String
    /// Specify proxy by adding [country ISO code](https://en.wikipedia.org/wiki/ISO_3166-2) to `country-` value to send requests through a proxy in the specified country. Use `country-any` to use random geo-targets.
    ///
    /// Example: "country-any"
    public var proxy: String?
    /// Takes a screenshot of a full web page. It ignores offsetX, offsety, width and height argument values.
    public var isFullPage: Bool
    /// Rectangle width in device independent pixels (dip).
    public var width: Int?
    /// Rectangle height in device independent pixels (dip).
    public var height: Int?
    /// X offset in device independent pixels (dip).
    public var offsetx: Int?
    /// Y offset in device independent pixels (dip).
    public var offsety: Int?
    /// Print background graphics in the PDF.
    public var isPrintBackground: Bool
    /// Captures a screenshot of specified CSS element on a web page.
    ///
    /// Example: "#css-element"
    public var clipSelector: String?
    /// Sets the Format of output image
    public var format: Format?
    /// Sets the Quality of output image. Compression quality from range [0..100] (jpeg only).
    public var quality: Int?
    /// Image scale factor. range [0.1 .. 3]
    public var scale: Double?
    /// Specify a wait delay (in seconds). This may be useful if certain elements of the web site need to be rendered after the initial page load.
    public var waitDelay: Double?
    /// The "Initial Cookies" option is useful for crawling websites that require a login. The simplest solution to get an array of cookies for specific websites is to use a web browser "EditThisCookie" extension. Copy a cookie array with "EditThisCookie" and paste it into the "Initial cookie" field.
    public var initialCookies: [InitialCookie]?
    /// The HTTP 200 OK success status response code indicates that the request has succeeded. Sometimes a server returns normal HTML content even with an erroneous Non-200 HTTP response status code. The IgnoreHTTPStatusCode option is useful when you need to force the return of HTML content. Defaults to "false."
    public var isIgnoreHTTPStatusErrCodes: Bool?
    /// Use actions to automate manual workflows while rendering web pages. They simulate real-world human interaction with pages.
    public var actions: [Action]?
    /// If set to _file_, the resulted screenshot is uploaded to Dataflow Kit Storage first. Then the link to this file is returned. Overwise, web site screenshot is returned in the response body.
    public var output: Output?

    /// Sets the Format of output image
    public enum Format: String, Codable, CaseIterable {
        case png
        case jpeg
    }

    /// If set to _file_, the resulted screenshot is uploaded to Dataflow Kit Storage first. Then the link to this file is returned. Overwise, web site screenshot is returned in the response body.
    public enum Output: String, Codable, CaseIterable {
        case buffer
        case file
    }

    public init(url: String, proxy: String? = nil, isFullPage: Bool? = nil, width: Int? = nil, height: Int? = nil, offsetx: Int? = nil, offsety: Int? = nil, isPrintBackground: Bool? = nil, clipSelector: String? = nil, format: Format? = nil, quality: Int? = nil, scale: Double? = nil, waitDelay: Double? = nil, initialCookies: [InitialCookie]? = nil, isIgnoreHTTPStatusErrCodes: Bool? = nil, actions: [Action]? = nil, output: Output? = nil) {
        self.url = url
        self.proxy = proxy
        self.isFullPage = isFullPage ?? false
        self.width = width
        self.height = height
        self.offsetx = offsetx
        self.offsety = offsety
        self.isPrintBackground = isPrintBackground ?? false
        self.clipSelector = clipSelector
        self.format = format
        self.quality = quality
        self.scale = scale
        self.waitDelay = waitDelay
        self.initialCookies = initialCookies
        self.isIgnoreHTTPStatusErrCodes = isIgnoreHTTPStatusErrCodes
        self.actions = actions
        self.output = output
    }

    private enum CodingKeys: String, CodingKey {
        case url
        case proxy
        case isFullPage = "fullPage"
        case width
        case height
        case offsetx
        case offsety
        case isPrintBackground = "printBackground"
        case clipSelector
        case format
        case quality
        case scale
        case waitDelay
        case initialCookies
        case isIgnoreHTTPStatusErrCodes = "ignoreHTTPStatusErrCodes"
        case actions
        case output
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.url = try values.decode(String.self, forKey: .url)
        self.proxy = try values.decodeIfPresent(String.self, forKey: .proxy)
        self.isFullPage = try values.decodeIfPresent(Bool.self, forKey: .isFullPage) ?? false
        self.width = try values.decodeIfPresent(Int.self, forKey: .width)
        self.height = try values.decodeIfPresent(Int.self, forKey: .height)
        self.offsetx = try values.decodeIfPresent(Int.self, forKey: .offsetx)
        self.offsety = try values.decodeIfPresent(Int.self, forKey: .offsety)
        self.isPrintBackground = try values.decodeIfPresent(Bool.self, forKey: .isPrintBackground) ?? false
        self.clipSelector = try values.decodeIfPresent(String.self, forKey: .clipSelector)
        self.format = try values.decodeIfPresent(Format.self, forKey: .format)
        self.quality = try values.decodeIfPresent(Int.self, forKey: .quality)
        self.scale = try values.decodeIfPresent(Double.self, forKey: .scale)
        self.waitDelay = try values.decodeIfPresent(Double.self, forKey: .waitDelay)
        self.initialCookies = try values.decodeIfPresent([InitialCookie].self, forKey: .initialCookies)
        self.isIgnoreHTTPStatusErrCodes = try values.decodeIfPresent(Bool.self, forKey: .isIgnoreHTTPStatusErrCodes)
        self.actions = try values.decodeIfPresent([Action].self, forKey: .actions)
        self.output = try values.decodeIfPresent(Output.self, forKey: .output)
    }
}

public struct Field: Codable {
    /// Field name is used to aggregate results.
    public var name: String
    /// Selector represents a CSS selector for data extraction within the given block.
    ///
    /// Example: "#cards a"
    public var selector: String
    /// Selector type. ( 0 - image, 1 - text, 2 - link)
    public var type: Int
    /// A set of attributes to extract from a Field. Find more information about attributes
    public var attrs: [Attr]
    /// Filters are used to pre-processing of text data when extracting.
    public var filters: [Filter]?
    /// Details themself represent independent Parse request that extracts data from linked pages.
    public var details: Parserequest?

    public enum Attr: String, Codable, CaseIterable {
        case text
        case href
        case src
        case alt
    }

    public struct Filter: Codable {
        public var a: A?
        public var b: B?

        public struct A: Codable {
            public var name: Name?

            public enum Name: String, Codable, CaseIterable {
                case trim
                case normal
                case uppercase
                case lowercase
                case capitalize
                case concatinate
            }

            public init(name: Name? = nil) {
                self.name = name
            }
        }

        public struct B: Codable {
            /// Example: "regex"
            public var name: String?
            /// Example: "[\\d.]+"
            public var param: String?

            public init(name: String? = nil, param: String? = nil) {
                self.name = name
                self.param = param
            }
        }

        public init(a: A? = nil, b: B? = nil) {
            self.a = a
            self.b = b
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.a = try? container.decode(A.self)
            self.b = try? container.decode(B.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = a { try container.encode(value) }
            if let value = b { try container.encode(value) }
        }
    }

    public init(name: String, selector: String, type: Int, attrs: [Attr], filters: [Filter]? = nil, details: Parserequest? = nil) {
        self.name = name
        self.selector = selector
        self.type = type
        self.attrs = attrs
        self.filters = filters
        self.details = details
    }
}

/// InitialCookie structure keep cookies that optionally can be passed to the new fetcher crawl a website that requires a login. Generate Cookies array with EditThisCookie chrome extension.
public struct InitialCookie: Codable {
    /// Example: ".twitter.com"
    public var domain: String?
    /// Example: 1762900726.409761
    public var expirationDate: Double?
    /// Example: false
    public var isHostOnly: Bool?
    /// Example: false
    public var isHTTPOnly: Bool?
    /// Example: "auth_token"
    public var name: String?
    /// Example: "/"
    public var path: String?
    public var sameSite: SameSite?
    /// Example: true
    public var isSecure: Bool?
    /// Example: true
    public var isSession: Bool?
    /// Example: "1"
    public var storeID: String?
    /// Example: "46fd9fed1ab8b0b0e231ac3f"
    public var value: String?
    public var id: Double?

    public enum SameSite: String, Codable, CaseIterable {
        case unspecified
        case strict
        case lax
        case noRestriction = "no_restriction"
    }

    public init(domain: String? = nil, expirationDate: Double? = nil, isHostOnly: Bool? = nil, isHTTPOnly: Bool? = nil, name: String? = nil, path: String? = nil, sameSite: SameSite? = nil, isSecure: Bool? = nil, isSession: Bool? = nil, storeID: String? = nil, value: String? = nil, id: Double? = nil) {
        self.domain = domain
        self.expirationDate = expirationDate
        self.isHostOnly = isHostOnly
        self.isHTTPOnly = isHTTPOnly
        self.name = name
        self.path = path
        self.sameSite = sameSite
        self.isSecure = isSecure
        self.isSession = isSession
        self.storeID = storeID
        self.value = value
        self.id = id
    }

    private enum CodingKeys: String, CodingKey {
        case domain
        case expirationDate
        case isHostOnly = "hostOnly"
        case isHTTPOnly = "httpOnly"
        case name
        case path
        case sameSite
        case isSecure = "secure"
        case isSession = "session"
        case storeID
        case value
        case id
    }
}

public struct Action: Codable {
    /// Input
    ///
    /// Sets the value of an input field as if you had typed it in. You can also set the value of combo boxes, checkboxes, etc., using this action. In these cases, the value must be the value of the selected option, not visible text.
    public var a: A?
    /// SendKeys
    ///
    /// The Send Keys action simulates real user input of key by key into a given string. It mimics real user behavior, such as the inability to type into invisible or read-only DOM elements. This action is useful for cases where explicit keystroke events are required, like auto-completing combo boxes. Unlike a similar 'input' action, which forces a specified value directly into an input selector, this action does not overwrite existing content.
    public var b: B?
    /// Click
    ///
    /// Clicks on a target element (such as a link, button, checkbox, or radio button) with specified CSS Selector.
    public var c: C?
    /// DoubleClick
    ///
    /// Double clicks on a target element (such as a link, button, checkbox, or radio button) with specified CSS Selector.
    public var d: D?
    /// Jsclick
    ///
    /// Click on an element with the specified CSS Selector. JS Click internally invokes a script (Javascript) that clicks the element.
    public var e: E?
    /// Submit
    ///
    /// Submit the specified form. This action is useful for forms without explicit submit buttons, such as single-input Search forms.
    public var f: F?
    /// WaitVisible
    ///
    /// Wait for the target element to become visible on the page.
    public var g: G?
    /// WaitNotVisible
    ///
    /// Wait for the target element to become invisible on the page.
    public var h: H?
    /// Pause
    ///
    /// Wait for the specified amount of time.
    public var i: I?
    /// Execute
    ///
    /// Executes the Javascript passes as 'script' parameter
    public var j: J?
    /// Loop .. times
    ///
    /// Loop action combines a set of actions and executes it as many times as specified in the "times" parameter.
    public var k: K?
    /// Getcontent
    ///
    /// Sometimes it is necessary to retrieve the HTML content of a web page multiple times in a single request. This action is for that.
    public var l: L?
    /// Scroll
    ///
    /// Scroll a page down to load more content, simulating user interaction with infinite scrolled pages. Or specify the element's CSS Selector to click for loading more content.
    public var m: M?

    /// Input
    ///
    /// Sets the value of an input field as if you had typed it in. You can also set the value of combo boxes, checkboxes, etc., using this action. In these cases, the value must be the value of the selected option, not visible text.
    public struct A: Codable {
        /// Must be a valid CSS Selector
        ///
        /// Example: "#search-form-editbox"
        public var selector: String?
        /// The value to input.
        ///
        /// Example: "web scraper"
        public var value: String?
        /// Example: false
        public var isIgnoreIfNotPresent: Bool?

        public init(selector: String? = nil, value: String? = nil, isIgnoreIfNotPresent: Bool? = nil) {
            self.selector = selector
            self.value = value
            self.isIgnoreIfNotPresent = isIgnoreIfNotPresent
        }

        private enum CodingKeys: String, CodingKey {
            case selector
            case value
            case isIgnoreIfNotPresent = "ignoreIfNotPresent"
        }
    }

    /// SendKeys
    ///
    /// The Send Keys action simulates real user input of key by key into a given string. It mimics real user behavior, such as the inability to type into invisible or read-only DOM elements. This action is useful for cases where explicit keystroke events are required, like auto-completing combo boxes. Unlike a similar 'input' action, which forces a specified value directly into an input selector, this action does not overwrite existing content.
    public struct B: Codable {
        /// Must be a valid CSS Selector
        ///
        /// Example: "#search-form-editbox"
        public var selector: String?
        /// Sequence of keys to send. Keys can include keystrokes such as ALT+A, ENTER, BACKSPACE, etc.
        ///
        /// Example: "web scraper"
        public var value: String?
        /// Example: false
        public var isIgnoreIfNotPresent: Bool?

        public init(selector: String? = nil, value: String? = nil, isIgnoreIfNotPresent: Bool? = nil) {
            self.selector = selector
            self.value = value
            self.isIgnoreIfNotPresent = isIgnoreIfNotPresent
        }

        private enum CodingKeys: String, CodingKey {
            case selector
            case value
            case isIgnoreIfNotPresent = "ignoreIfNotPresent"
        }
    }

    /// Click
    ///
    /// Clicks on a target element (such as a link, button, checkbox, or radio button) with specified CSS Selector.
    public struct C: Codable {
        /// Must be a valid CSS Selector
        ///
        /// Example: ".click-me"
        public var selector: String?
        /// This optional parameter is useful when the target element occasionally may not be present in the DOM.
        ///
        /// Example: false
        public var isIgnoreIfNotPresent: Bool?
        /// It is only used for click action inside a loop only. Skips the last iteration.
        ///
        /// Example: true
        public var isSkipLastIteration: Bool?

        public init(selector: String? = nil, isIgnoreIfNotPresent: Bool? = nil, isSkipLastIteration: Bool? = nil) {
            self.selector = selector
            self.isIgnoreIfNotPresent = isIgnoreIfNotPresent
            self.isSkipLastIteration = isSkipLastIteration
        }

        private enum CodingKeys: String, CodingKey {
            case selector
            case isIgnoreIfNotPresent = "ignoreIfNotPresent"
            case isSkipLastIteration = "skipLastIteration"
        }
    }

    /// DoubleClick
    ///
    /// Double clicks on a target element (such as a link, button, checkbox, or radio button) with specified CSS Selector.
    public struct D: Codable {
        /// Must be a valid CSS Selector
        ///
        /// Example: ".double-click-me"
        public var selector: String?
        /// This optional parameter is useful when the target element occasionally may not be present in the DOM.
        ///
        /// Example: false
        public var isIgnoreIfNotPresent: Bool?
        /// It is only used for click action inside a loop only. Skips the last iteration.
        ///
        /// Example: true
        public var isSkipLastIteration: Bool?

        public init(selector: String? = nil, isIgnoreIfNotPresent: Bool? = nil, isSkipLastIteration: Bool? = nil) {
            self.selector = selector
            self.isIgnoreIfNotPresent = isIgnoreIfNotPresent
            self.isSkipLastIteration = isSkipLastIteration
        }

        private enum CodingKeys: String, CodingKey {
            case selector
            case isIgnoreIfNotPresent = "ignoreIfNotPresent"
            case isSkipLastIteration = "skipLastIteration"
        }
    }

    /// Jsclick
    ///
    /// Click on an element with the specified CSS Selector. JS Click internally invokes a script (Javascript) that clicks the element.
    public struct E: Codable {
        /// Must be a valid CSS Selector for the target element.
        ///
        /// Example: ".js-click-me"
        public var selector: String?
        /// This optional parameter is useful when the target element occasionally may not be present in the DOM.
        ///
        /// Example: false
        public var isIgnoreIfNotPresent: Bool?
        /// It is only used for click action inside a loop only. Skips the last iteration.
        ///
        /// Example: true
        public var isSkipLastIteration: Bool?

        public init(selector: String? = nil, isIgnoreIfNotPresent: Bool? = nil, isSkipLastIteration: Bool? = nil) {
            self.selector = selector
            self.isIgnoreIfNotPresent = isIgnoreIfNotPresent
            self.isSkipLastIteration = isSkipLastIteration
        }

        private enum CodingKeys: String, CodingKey {
            case selector
            case isIgnoreIfNotPresent = "ignoreIfNotPresent"
            case isSkipLastIteration = "skipLastIteration"
        }
    }

    /// Submit
    ///
    /// Submit the specified form. This action is useful for forms without explicit submit buttons, such as single-input Search forms.
    public struct F: Codable {
        /// Must be an any valid CSS Selector inside the parent form to submit.
        ///
        /// Example: ".some-element-inside-form"
        public var selector: String?

        public init(selector: String? = nil) {
            self.selector = selector
        }
    }

    /// WaitVisible
    ///
    /// Wait for the target element to become visible on the page.
    public struct G: Codable {
        /// Must be a valid CSS Selector for the target element.
        ///
        /// Example: ":root"
        public var selector: String?

        public init(selector: String? = nil) {
            self.selector = selector
        }
    }

    /// WaitNotVisible
    ///
    /// Wait for the target element to become invisible on the page.
    public struct H: Codable {
        /// Must be a valid CSS Selector for the target element.
        ///
        /// Example: "#some-element"
        public var selector: String?

        public init(selector: String? = nil) {
            self.selector = selector
        }
    }

    /// Pause
    ///
    /// Wait for the specified amount of time.
    public struct I: Codable {
        /// Wait time (in milliseconds).
        ///
        /// Example: "5000"
        public var waitDelay: String?

        public init(waitDelay: String? = nil) {
            self.waitDelay = waitDelay
        }
    }

    /// Execute
    ///
    /// Executes the Javascript passes as 'script' parameter
    public struct J: Codable {
        /// The JavaScript snippet to run
        ///
        /// Example: "console.log("It works!")"
        public var script: String?

        public init(script: String? = nil) {
            self.script = script
        }
    }

    /// Loop .. times
    ///
    /// Loop action combines a set of actions and executes it as many times as specified in the "times" parameter.
    public struct K: Codable {
        /// List of actions combined in the loop are executed step-by-step
        public var actions: [Action]?
        /// The number of times to execute the wrapped actions within the 'loop .. times' construction.
        public var times: Double?

        public init(actions: [Action]? = nil, times: Double? = nil) {
            self.actions = actions
            self.times = times
        }
    }

    /// Getcontent
    ///
    /// Sometimes it is necessary to retrieve the HTML content of a web page multiple times in a single request. This action is for that.
    public struct L: Codable {
        /// It is only used for loop actions only. Skips the last iteration.
        ///
        /// Example: true
        public var isSkipLastIteration: Bool?

        public init(isSkipLastIteration: Bool? = nil) {
            self.isSkipLastIteration = isSkipLastIteration
        }

        private enum CodingKeys: String, CodingKey {
            case isSkipLastIteration = "skipLastIteration"
        }
    }

    /// Scroll
    ///
    /// Scroll a page down to load more content, simulating user interaction with infinite scrolled pages. Or specify the element's CSS Selector to click for loading more content.
    public struct M: Codable {
        /// The number of times to scroll down a web page.
        public var times: Int?
        /// Some websites require clicking 'More' button while scrolling a page. Put here 'More' button valid CSS Selector.
        ///
        /// Example: ".more-button"
        public var selector: String?
        /// Scrolls a web page by the number of pixels specified by 'scrollByPixels' parameter.
        ///
        /// Example: 650
        public var scrollByPixels: Double?
        /// Optionally specify here a valid CSS Selector of scrolling element.
        ///
        /// Example: "#scroll-panel"
        public var scrollingElementSelector: String?

        public init(times: Int? = nil, selector: String? = nil, scrollByPixels: Double? = nil, scrollingElementSelector: String? = nil) {
            self.times = times
            self.selector = selector
            self.scrollByPixels = scrollByPixels
            self.scrollingElementSelector = scrollingElementSelector
        }
    }

    public init(a: A? = nil, b: B? = nil, c: C? = nil, d: D? = nil, e: E? = nil, f: F? = nil, g: G? = nil, h: H? = nil, i: I? = nil, j: J? = nil, k: K? = nil, l: L? = nil, m: M? = nil) {
        self.a = a
        self.b = b
        self.c = c
        self.d = d
        self.e = e
        self.f = f
        self.g = g
        self.h = h
        self.i = i
        self.j = j
        self.k = k
        self.l = l
        self.m = m
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        self.a = try? container.decode(A.self)
        self.b = try? container.decode(B.self)
        self.c = try? container.decode(C.self)
        self.d = try? container.decode(D.self)
        self.e = try? container.decode(E.self)
        self.f = try? container.decode(F.self)
        self.g = try? container.decode(G.self)
        self.h = try? container.decode(H.self)
        self.i = try? container.decode(I.self)
        self.j = try? container.decode(J.self)
        self.k = try? container.decode(K.self)
        self.l = try? container.decode(L.self)
        self.m = try? container.decode(M.self)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        if let value = a { try container.encode(value) }
        if let value = b { try container.encode(value) }
        if let value = c { try container.encode(value) }
        if let value = d { try container.encode(value) }
        if let value = e { try container.encode(value) }
        if let value = f { try container.encode(value) }
        if let value = g { try container.encode(value) }
        if let value = h { try container.encode(value) }
        if let value = i { try container.encode(value) }
        if let value = j { try container.encode(value) }
        if let value = k { try container.encode(value) }
        if let value = l { try container.encode(value) }
        if let value = m { try container.encode(value) }
    }
}

/// Specify _Next link_ paginator on pages containing a link pointing to the next page. The next page link is extracted from a document by querying href attribute of a given element's CSS selector.
public struct Paginator: Codable {
    /// Example: ".page-link"
    public var nextPageSelector: String?
    /// Example: 10
    public var pageNum: Int?

    public init(nextPageSelector: String? = nil, pageNum: Int? = nil) {
        self.nextPageSelector = nextPageSelector
        self.pageNum = pageNum
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
