// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var companies: Companies {
        Companies(path: "/crm/companies")
    }

    public struct Companies {
        /// Path: `/crm/companies`
        public let path: String

        /// List companies
        public func get(parameters: GetParameters? = nil) -> Request<ApiDeckCRMAPI.GetCompaniesResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isRaw: Bool?
            public var cursor: String?
            public var limit: Int?
            /// Example:
            ///
            /// {
            ///   "name" : "SpaceX"
            /// }
            public var filter: Filter?
            /// Example:
            ///
            /// {
            ///   "by" : "created_at",
            ///   "direction" : "desc"
            /// }
            public var sort: Sort?

            /// Example:
            ///
            /// {
            ///   "name" : "SpaceX"
            /// }
            public struct Filter: Codable {
                /// Name of the company to filter on
                ///
                /// Example: "SpaceX"
                public var name: String?

                public init(name: String? = nil) {
                    self.name = name
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(name, forKey: "name")
                    return encoder.items
                }
            }

            /// Example:
            ///
            /// {
            ///   "by" : "created_at",
            ///   "direction" : "desc"
            /// }
            public struct Sort: Codable {
                /// The field on which to sort the Companies
                ///
                /// Example: "created_at"
                public var by: By
                /// The direction in which to sort the results
                public var direction: Direction?

                /// The field on which to sort the Companies
                ///
                /// Example: "created_at"
                public enum By: String, Codable, CaseIterable {
                    case createdAt = "created_at"
                    case updatedAt = "updated_at"
                    case name
                }

                /// The direction in which to sort the results
                public enum Direction: String, Codable, CaseIterable {
                    case asc
                    case desc
                }

                public init(by: By, direction: Direction? = nil) {
                    self.by = by
                    self.direction = direction
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(by, forKey: "by")
                    encoder.encode(direction, forKey: "direction")
                    return encoder.items
                }
            }

            public init(isRaw: Bool? = nil, cursor: String? = nil, limit: Int? = nil, filter: Filter? = nil, sort: Sort? = nil) {
                self.isRaw = isRaw
                self.cursor = cursor
                self.limit = limit
                self.filter = filter
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isRaw, forKey: "raw")
                encoder.encode(cursor, forKey: "cursor")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(filter, forKey: "filter", isDeepObject: true)
                encoder.encode(sort, forKey: "sort", isDeepObject: true)
                return encoder.items
            }
        }

        /// Create company
        public func post(isRaw: Bool? = nil, _ body: ApiDeckCRMAPI.Company) -> Request<ApiDeckCRMAPI.CreateCompanyResponse> {
            .post(path, query: makePostQuery(isRaw), body: body)
        }

        private func makePostQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }
    }
}

extension Paths.Companies {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/crm/companies/{id}`
        public let path: String

        /// Get company
        public func get(isRaw: Bool? = nil) -> Request<ApiDeckCRMAPI.GetCompanyResponse> {
            .get(path, query: makeGetQuery(isRaw))
        }

        private func makeGetQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }

        /// Update company
        public func patch(isRaw: Bool? = nil, _ body: ApiDeckCRMAPI.Company) -> Request<ApiDeckCRMAPI.UpdateCompanyResponse> {
            .patch(path, query: makePatchQuery(isRaw), body: body)
        }

        private func makePatchQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }

        /// Delete company
        public func delete(isRaw: Bool? = nil) -> Request<ApiDeckCRMAPI.DeleteCompanyResponse> {
            .delete(path, query: makeDeleteQuery(isRaw))
        }

        private func makeDeleteQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }
    }
}

extension Paths {
    public static var contacts: Contacts {
        Contacts(path: "/crm/contacts")
    }

    public struct Contacts {
        /// Path: `/crm/contacts`
        public let path: String

        /// List contacts
        public func get(parameters: GetParameters? = nil) -> Request<ApiDeckCRMAPI.GetContactsResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isRaw: Bool?
            public var cursor: String?
            public var limit: Int?
            /// Example:
            ///
            /// {
            ///   "email" : "elon@tesla.com",
            ///   "first_name" : "Elon",
            ///   "last_name" : "Musk"
            /// }
            public var filter: Filter?
            /// Example:
            ///
            /// {
            ///   "by" : "created_at",
            ///   "direction" : "desc"
            /// }
            public var sort: Sort?

            /// Example:
            ///
            /// {
            ///   "email" : "elon@tesla.com",
            ///   "first_name" : "Elon",
            ///   "last_name" : "Musk"
            /// }
            public struct Filter: Codable {
                /// Name of the contact to filter on
                ///
                /// Example: "Elon Musk"
                public var name: String?
                /// First name of the contact to filter on
                ///
                /// Example: "Elon"
                public var firstName: String?
                /// Last name of the contact to filter on
                ///
                /// Example: "Musk"
                public var lastName: String?
                /// E-mail of the contact to filter on
                ///
                /// Example: "elon@tesla.com"
                public var email: String?

                public init(name: String? = nil, firstName: String? = nil, lastName: String? = nil, email: String? = nil) {
                    self.name = name
                    self.firstName = firstName
                    self.lastName = lastName
                    self.email = email
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(name, forKey: "name")
                    encoder.encode(firstName, forKey: "first_name")
                    encoder.encode(lastName, forKey: "last_name")
                    encoder.encode(email, forKey: "email")
                    return encoder.items
                }
            }

            /// Example:
            ///
            /// {
            ///   "by" : "created_at",
            ///   "direction" : "desc"
            /// }
            public struct Sort: Codable {
                /// The field on which to sort the Contacts
                ///
                /// Example: "created_at"
                public var by: By
                /// The direction in which to sort the results
                public var direction: Direction?

                /// The field on which to sort the Contacts
                ///
                /// Example: "created_at"
                public enum By: String, Codable, CaseIterable {
                    case createdAt = "created_at"
                    case updatedAt = "updated_at"
                    case name
                    case firstName = "first_name"
                    case lastName = "last_name"
                    case email
                }

                /// The direction in which to sort the results
                public enum Direction: String, Codable, CaseIterable {
                    case asc
                    case desc
                }

                public init(by: By, direction: Direction? = nil) {
                    self.by = by
                    self.direction = direction
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(by, forKey: "by")
                    encoder.encode(direction, forKey: "direction")
                    return encoder.items
                }
            }

            public init(isRaw: Bool? = nil, cursor: String? = nil, limit: Int? = nil, filter: Filter? = nil, sort: Sort? = nil) {
                self.isRaw = isRaw
                self.cursor = cursor
                self.limit = limit
                self.filter = filter
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isRaw, forKey: "raw")
                encoder.encode(cursor, forKey: "cursor")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(filter, forKey: "filter", isDeepObject: true)
                encoder.encode(sort, forKey: "sort", isDeepObject: true)
                return encoder.items
            }
        }

        /// Create contact
        public func post(isRaw: Bool? = nil, _ body: ApiDeckCRMAPI.Contact) -> Request<ApiDeckCRMAPI.CreateContactResponse> {
            .post(path, query: makePostQuery(isRaw), body: body)
        }

        private func makePostQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }
    }
}

extension Paths.Contacts {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/crm/contacts/{id}`
        public let path: String

        /// Get contact
        public func get(isRaw: Bool? = nil) -> Request<ApiDeckCRMAPI.GetContactResponse> {
            .get(path, query: makeGetQuery(isRaw))
        }

        private func makeGetQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }

        /// Update contact
        public func patch(isRaw: Bool? = nil, _ body: ApiDeckCRMAPI.Contact) -> Request<ApiDeckCRMAPI.UpdateContactResponse> {
            .patch(path, query: makePatchQuery(isRaw), body: body)
        }

        private func makePatchQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }

        /// Delete contact
        public func delete(isRaw: Bool? = nil) -> Request<ApiDeckCRMAPI.DeleteContactResponse> {
            .delete(path, query: makeDeleteQuery(isRaw))
        }

        private func makeDeleteQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }
    }
}

extension Paths {
    public static var opportunities: Opportunities {
        Opportunities(path: "/crm/opportunities")
    }

    public struct Opportunities {
        /// Path: `/crm/opportunities`
        public let path: String

        /// List opportunities
        public func get(parameters: GetParameters? = nil) -> Request<ApiDeckCRMAPI.GetOpportunitiesResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isRaw: Bool?
            public var cursor: String?
            public var limit: Int?
            /// Example:
            ///
            /// {
            ///   "monetary_amount" : 75000,
            ///   "status" : "Completed"
            /// }
            public var filter: Filter?
            /// Example:
            ///
            /// {
            ///   "by" : "created_at",
            ///   "direction" : "desc"
            /// }
            public var sort: Sort?

            /// Example:
            ///
            /// {
            ///   "monetary_amount" : 75000,
            ///   "status" : "Completed"
            /// }
            public struct Filter: Codable {
                /// Title of the opportunity to filter on
                ///
                /// Example: "Tesla deal"
                public var title: String?
                /// Status to filter on
                ///
                /// Example: "Completed"
                public var status: String?
                /// Monetary amount to filter on
                ///
                /// Example: 75000
                public var monetaryAmount: Double?
                /// Win probability to filter on
                ///
                /// Example: 50
                public var winProbability: Double?

                public init(title: String? = nil, status: String? = nil, monetaryAmount: Double? = nil, winProbability: Double? = nil) {
                    self.title = title
                    self.status = status
                    self.monetaryAmount = monetaryAmount
                    self.winProbability = winProbability
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(title, forKey: "title")
                    encoder.encode(status, forKey: "status")
                    encoder.encode(monetaryAmount, forKey: "monetary_amount")
                    encoder.encode(winProbability, forKey: "win_probability")
                    return encoder.items
                }
            }

            /// Example:
            ///
            /// {
            ///   "by" : "created_at",
            ///   "direction" : "desc"
            /// }
            public struct Sort: Codable {
                /// The field on which to sort the Opportunities
                ///
                /// Example: "created_at"
                public var by: By
                /// The direction in which to sort the results
                public var direction: Direction?

                /// The field on which to sort the Opportunities
                ///
                /// Example: "created_at"
                public enum By: String, Codable, CaseIterable {
                    case createdAt = "created_at"
                    case updatedAt = "updated_at"
                    case title
                    case winProbability = "win_probability"
                    case monetaryAmount = "monetary_amount"
                    case status
                }

                /// The direction in which to sort the results
                public enum Direction: String, Codable, CaseIterable {
                    case asc
                    case desc
                }

                public init(by: By, direction: Direction? = nil) {
                    self.by = by
                    self.direction = direction
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(by, forKey: "by")
                    encoder.encode(direction, forKey: "direction")
                    return encoder.items
                }
            }

            public init(isRaw: Bool? = nil, cursor: String? = nil, limit: Int? = nil, filter: Filter? = nil, sort: Sort? = nil) {
                self.isRaw = isRaw
                self.cursor = cursor
                self.limit = limit
                self.filter = filter
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isRaw, forKey: "raw")
                encoder.encode(cursor, forKey: "cursor")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(filter, forKey: "filter", isDeepObject: true)
                encoder.encode(sort, forKey: "sort", isDeepObject: true)
                return encoder.items
            }
        }

        /// Create opportunity
        public func post(isRaw: Bool? = nil, _ body: ApiDeckCRMAPI.Opportunity) -> Request<ApiDeckCRMAPI.CreateOpportunityResponse> {
            .post(path, query: makePostQuery(isRaw), body: body)
        }

        private func makePostQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }
    }
}

extension Paths.Opportunities {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/crm/opportunities/{id}`
        public let path: String

        /// Get opportunity
        public func get(isRaw: Bool? = nil) -> Request<ApiDeckCRMAPI.GetOpportunityResponse> {
            .get(path, query: makeGetQuery(isRaw))
        }

        private func makeGetQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }

        /// Update opportunity
        public func patch(isRaw: Bool? = nil, _ body: ApiDeckCRMAPI.Opportunity) -> Request<ApiDeckCRMAPI.UpdateOpportunityResponse> {
            .patch(path, query: makePatchQuery(isRaw), body: body)
        }

        private func makePatchQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }

        /// Delete opportunity
        public func delete(isRaw: Bool? = nil) -> Request<ApiDeckCRMAPI.DeleteOpportunityResponse> {
            .delete(path, query: makeDeleteQuery(isRaw))
        }

        private func makeDeleteQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }
    }
}

extension Paths {
    public static var leads: Leads {
        Leads(path: "/crm/leads")
    }

    public struct Leads {
        /// Path: `/crm/leads`
        public let path: String

        /// List leads
        public func get(parameters: GetParameters? = nil) -> Request<ApiDeckCRMAPI.GetLeadsResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isRaw: Bool?
            public var cursor: String?
            public var limit: Int?
            /// Example:
            ///
            /// {
            ///   "email" : "elon@tesla.com",
            ///   "first_name" : "Elon",
            ///   "last_name" : "Musk"
            /// }
            public var filter: Filter?
            /// Example:
            ///
            /// {
            ///   "by" : "created_at",
            ///   "direction" : "desc"
            /// }
            public var sort: Sort?

            /// Example:
            ///
            /// {
            ///   "email" : "elon@tesla.com",
            ///   "first_name" : "Elon",
            ///   "last_name" : "Musk"
            /// }
            public struct Filter: Codable {
                /// Name of the lead to filter on
                ///
                /// Example: "Elon Musk"
                public var name: String?
                /// First name of the lead to filter on
                ///
                /// Example: "Elon"
                public var firstName: String?
                /// Last name of the lead to filter on
                ///
                /// Example: "Musk"
                public var lastName: String?
                /// E-mail of the lead to filter on
                ///
                /// Example: "elon@tesla.com"
                public var email: String?

                public init(name: String? = nil, firstName: String? = nil, lastName: String? = nil, email: String? = nil) {
                    self.name = name
                    self.firstName = firstName
                    self.lastName = lastName
                    self.email = email
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(name, forKey: "name")
                    encoder.encode(firstName, forKey: "first_name")
                    encoder.encode(lastName, forKey: "last_name")
                    encoder.encode(email, forKey: "email")
                    return encoder.items
                }
            }

            /// Example:
            ///
            /// {
            ///   "by" : "created_at",
            ///   "direction" : "desc"
            /// }
            public struct Sort: Codable {
                /// The field on which to sort the Leads
                ///
                /// Example: "created_at"
                public var by: By
                /// The direction in which to sort the results
                public var direction: Direction?

                /// The field on which to sort the Leads
                ///
                /// Example: "created_at"
                public enum By: String, Codable, CaseIterable {
                    case createdAt = "created_at"
                    case updatedAt = "updated_at"
                    case name
                    case firstName = "first_name"
                    case lastName = "last_name"
                    case email
                }

                /// The direction in which to sort the results
                public enum Direction: String, Codable, CaseIterable {
                    case asc
                    case desc
                }

                public init(by: By, direction: Direction? = nil) {
                    self.by = by
                    self.direction = direction
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(by, forKey: "by")
                    encoder.encode(direction, forKey: "direction")
                    return encoder.items
                }
            }

            public init(isRaw: Bool? = nil, cursor: String? = nil, limit: Int? = nil, filter: Filter? = nil, sort: Sort? = nil) {
                self.isRaw = isRaw
                self.cursor = cursor
                self.limit = limit
                self.filter = filter
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isRaw, forKey: "raw")
                encoder.encode(cursor, forKey: "cursor")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(filter, forKey: "filter", isDeepObject: true)
                encoder.encode(sort, forKey: "sort", isDeepObject: true)
                return encoder.items
            }
        }

        /// Create lead
        public func post(isRaw: Bool? = nil, _ body: ApiDeckCRMAPI.Lead) -> Request<ApiDeckCRMAPI.CreateLeadResponse> {
            .post(path, query: makePostQuery(isRaw), body: body)
        }

        private func makePostQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }
    }
}

extension Paths.Leads {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/crm/leads/{id}`
        public let path: String

        /// Get lead
        public func get(isRaw: Bool? = nil) -> Request<ApiDeckCRMAPI.GetLeadResponse> {
            .get(path, query: makeGetQuery(isRaw))
        }

        private func makeGetQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }

        /// Update lead
        public func patch(isRaw: Bool? = nil, _ body: ApiDeckCRMAPI.Lead) -> Request<ApiDeckCRMAPI.UpdateLeadResponse> {
            .patch(path, query: makePatchQuery(isRaw), body: body)
        }

        private func makePatchQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }

        /// Delete lead
        public func delete(isRaw: Bool? = nil) -> Request<ApiDeckCRMAPI.DeleteLeadResponse> {
            .delete(path, query: makeDeleteQuery(isRaw))
        }

        private func makeDeleteQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }
    }
}

extension Paths {
    public static var pipelines: Pipelines {
        Pipelines(path: "/crm/pipelines")
    }

    public struct Pipelines {
        /// Path: `/crm/pipelines`
        public let path: String

        /// List pipelines
        public func get(parameters: GetParameters? = nil) -> Request<ApiDeckCRMAPI.GetPipelinesResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isRaw: Bool?
            public var cursor: String?
            public var limit: Int?

            public init(isRaw: Bool? = nil, cursor: String? = nil, limit: Int? = nil) {
                self.isRaw = isRaw
                self.cursor = cursor
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isRaw, forKey: "raw")
                encoder.encode(cursor, forKey: "cursor")
                encoder.encode(limit, forKey: "limit")
                return encoder.items
            }
        }

        /// Create pipeline
        public func post(isRaw: Bool? = nil, _ body: ApiDeckCRMAPI.Pipeline) -> Request<ApiDeckCRMAPI.CreatePipelineResponse> {
            .post(path, query: makePostQuery(isRaw), body: body)
        }

        private func makePostQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }
    }
}

extension Paths.Pipelines {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/crm/pipelines/{id}`
        public let path: String

        /// Get pipeline
        public func get(isRaw: Bool? = nil) -> Request<ApiDeckCRMAPI.GetPipelineResponse> {
            .get(path, query: makeGetQuery(isRaw))
        }

        private func makeGetQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }

        /// Update pipeline
        public func patch(isRaw: Bool? = nil, _ body: ApiDeckCRMAPI.Pipeline) -> Request<ApiDeckCRMAPI.UpdatePipelineResponse> {
            .patch(path, query: makePatchQuery(isRaw), body: body)
        }

        private func makePatchQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }

        /// Delete pipeline
        public func delete(isRaw: Bool? = nil) -> Request<ApiDeckCRMAPI.DeletePipelineResponse> {
            .delete(path, query: makeDeleteQuery(isRaw))
        }

        private func makeDeleteQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }
    }
}

extension Paths {
    public static var notes: Notes {
        Notes(path: "/crm/notes")
    }

    public struct Notes {
        /// Path: `/crm/notes`
        public let path: String

        /// List notes
        public func get(parameters: GetParameters? = nil) -> Request<ApiDeckCRMAPI.GetNotesResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isRaw: Bool?
            public var cursor: String?
            public var limit: Int?

            public init(isRaw: Bool? = nil, cursor: String? = nil, limit: Int? = nil) {
                self.isRaw = isRaw
                self.cursor = cursor
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isRaw, forKey: "raw")
                encoder.encode(cursor, forKey: "cursor")
                encoder.encode(limit, forKey: "limit")
                return encoder.items
            }
        }

        /// Create note
        public func post(isRaw: Bool? = nil, _ body: ApiDeckCRMAPI.Note) -> Request<ApiDeckCRMAPI.CreateNoteResponse> {
            .post(path, query: makePostQuery(isRaw), body: body)
        }

        private func makePostQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }
    }
}

extension Paths.Notes {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/crm/notes/{id}`
        public let path: String

        /// Get note
        public func get(isRaw: Bool? = nil) -> Request<ApiDeckCRMAPI.GetNoteResponse> {
            .get(path, query: makeGetQuery(isRaw))
        }

        private func makeGetQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }

        /// Update note
        public func patch(isRaw: Bool? = nil, _ body: ApiDeckCRMAPI.Note) -> Request<ApiDeckCRMAPI.UpdateNoteResponse> {
            .patch(path, query: makePatchQuery(isRaw), body: body)
        }

        private func makePatchQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }

        /// Delete note
        public func delete(isRaw: Bool? = nil) -> Request<ApiDeckCRMAPI.DeleteNoteResponse> {
            .delete(path, query: makeDeleteQuery(isRaw))
        }

        private func makeDeleteQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }
    }
}

extension Paths {
    public static var users: Users {
        Users(path: "/crm/users")
    }

    public struct Users {
        /// Path: `/crm/users`
        public let path: String

        /// List users
        public func get(parameters: GetParameters? = nil) -> Request<ApiDeckCRMAPI.GetUsersResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isRaw: Bool?
            public var cursor: String?
            public var limit: Int?

            public init(isRaw: Bool? = nil, cursor: String? = nil, limit: Int? = nil) {
                self.isRaw = isRaw
                self.cursor = cursor
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isRaw, forKey: "raw")
                encoder.encode(cursor, forKey: "cursor")
                encoder.encode(limit, forKey: "limit")
                return encoder.items
            }
        }

        /// Create user
        public func post(isRaw: Bool? = nil, _ body: ApiDeckCRMAPI.User) -> Request<ApiDeckCRMAPI.CreateUserResponse> {
            .post(path, query: makePostQuery(isRaw), body: body)
        }

        private func makePostQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }
    }
}

extension Paths.Users {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/crm/users/{id}`
        public let path: String

        /// Get user
        public func get(isRaw: Bool? = nil) -> Request<ApiDeckCRMAPI.GetUserResponse> {
            .get(path, query: makeGetQuery(isRaw))
        }

        private func makeGetQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }

        /// Update user
        public func patch(isRaw: Bool? = nil, _ body: ApiDeckCRMAPI.User) -> Request<ApiDeckCRMAPI.UpdateUserResponse> {
            .patch(path, query: makePatchQuery(isRaw), body: body)
        }

        private func makePatchQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }

        /// Delete user
        public func delete(isRaw: Bool? = nil) -> Request<ApiDeckCRMAPI.DeleteUserResponse> {
            .delete(path, query: makeDeleteQuery(isRaw))
        }

        private func makeDeleteQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }
    }
}

extension Paths {
    public static var activities: Activities {
        Activities(path: "/crm/activities")
    }

    public struct Activities {
        /// Path: `/crm/activities`
        public let path: String

        /// List activities
        public func get(parameters: GetParameters? = nil) -> Request<ApiDeckCRMAPI.GetActivitiesResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isRaw: Bool?
            public var cursor: String?
            public var limit: Int?

            public init(isRaw: Bool? = nil, cursor: String? = nil, limit: Int? = nil) {
                self.isRaw = isRaw
                self.cursor = cursor
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isRaw, forKey: "raw")
                encoder.encode(cursor, forKey: "cursor")
                encoder.encode(limit, forKey: "limit")
                return encoder.items
            }
        }

        /// Create activity
        public func post(isRaw: Bool? = nil, _ body: ApiDeckCRMAPI.Activity) -> Request<ApiDeckCRMAPI.CreateActivityResponse> {
            .post(path, query: makePostQuery(isRaw), body: body)
        }

        private func makePostQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }
    }
}

extension Paths.Activities {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/crm/activities/{id}`
        public let path: String

        /// Get activity
        public func get(isRaw: Bool? = nil) -> Request<ApiDeckCRMAPI.GetActivityResponse> {
            .get(path, query: makeGetQuery(isRaw))
        }

        private func makeGetQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }

        /// Update activity
        public func patch(isRaw: Bool? = nil, _ body: ApiDeckCRMAPI.Activity) -> Request<ApiDeckCRMAPI.UpdateActivityResponse> {
            .patch(path, query: makePatchQuery(isRaw), body: body)
        }

        private func makePatchQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }

        /// Delete activity
        public func delete(isRaw: Bool? = nil) -> Request<ApiDeckCRMAPI.DeleteActivityResponse> {
            .delete(path, query: makeDeleteQuery(isRaw))
        }

        private func makeDeleteQuery(_ isRaw: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRaw, forKey: "raw")
            return encoder.items
        }
    }
}

public enum Paths {}
