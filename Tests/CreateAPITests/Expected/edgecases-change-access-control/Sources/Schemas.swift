// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

 struct Order: Decodable {
    var isComplete: Bool?
    var id: Int?
    var petID: Int?
    var quantity: Int?
    var shipDate: Date?
    /// Order Status
    var status: Status?

    /// Order Status
    enum Status: String, Codable, CaseIterable {
        case placed
        case approved
        case delivered
    }

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.isComplete = try values.decodeIfPresent(Bool.self, forKey: "complete")
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.petID = try values.decodeIfPresent(Int.self, forKey: "petId")
        self.quantity = try values.decodeIfPresent(Int.self, forKey: "quantity")
        self.shipDate = try values.decodeIfPresent(Date.self, forKey: "shipDate")
        self.status = try values.decodeIfPresent(Status.self, forKey: "status")
    }
}

 struct Category: Decodable {
    var id: Int?
    var name: String?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
    }
}

 struct User: Decodable {
    var email: String?
    var firstName: String?
    var id: Int?
    var lastName: String?
    var password: String?
    var phone: String?
    /// User Status
    var userStatus: Int?
    var username: String?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.email = try values.decodeIfPresent(String.self, forKey: "email")
        self.firstName = try values.decodeIfPresent(String.self, forKey: "firstName")
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.lastName = try values.decodeIfPresent(String.self, forKey: "lastName")
        self.password = try values.decodeIfPresent(String.self, forKey: "password")
        self.phone = try values.decodeIfPresent(String.self, forKey: "phone")
        self.userStatus = try values.decodeIfPresent(Int.self, forKey: "userStatus")
        self.username = try values.decodeIfPresent(String.self, forKey: "username")
    }
}

 struct Tag: Decodable {
    var id: Int?
    var name: String?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
    }
}

 struct Pet: Decodable {
    var category: Category?
    var id: Int?
    /// Example: doggie
    var name: String
    var photoURLs: [String]
    /// Pet status in the store
    var status: Status?
    var tags: [Tag]?

    /// Pet status in the store
    enum Status: String, Codable, CaseIterable {
        case available
        case pending
        case sold
    }

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.category = try values.decodeIfPresent(Category.self, forKey: "category")
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.name = try values.decode(String.self, forKey: "name")
        self.photoURLs = try values.decode([String].self, forKey: "photoUrls")
        self.status = try values.decodeIfPresent(Status.self, forKey: "status")
        self.tags = try values.decodeIfPresent([Tag].self, forKey: "tags")
    }
}

 struct APIResponse: Decodable {
    var code: Int?
    var message: String?
    var type: String?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.code = try values.decodeIfPresent(Int.self, forKey: "code")
        self.message = try values.decodeIfPresent(String.self, forKey: "message")
        self.type = try values.decodeIfPresent(String.self, forKey: "type")
    }
}

/// Model for testing reserved words
 struct Return: Decodable {
    var `return`: Int?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.return = try values.decodeIfPresent(Int.self, forKey: "return")
    }
}

/// Model for testing model name same as property name
 struct Name: Decodable {
    var _123Number: Int?
    var name: Int
    var property: String?
    var snakeCase: Int?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self._123Number = try values.decodeIfPresent(Int.self, forKey: "123Number")
        self.name = try values.decode(Int.self, forKey: "name")
        self.property = try values.decodeIfPresent(String.self, forKey: "property")
        self.snakeCase = try values.decodeIfPresent(Int.self, forKey: "snake_case")
    }
}

/// Model for testing model name starting with number
 struct _200Response: Decodable {
    var `class`: String?
    var name: Int?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.class = try values.decodeIfPresent(String.self, forKey: "class")
        self.name = try values.decodeIfPresent(Int.self, forKey: "name")
    }
}

/// Model for testing model with "_class" property
 struct ClassModel: Decodable {
    var `class`: String?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.class = try values.decodeIfPresent(String.self, forKey: "_class")
    }
}

 struct Dog: Decodable {
    var animal: Animal
    var breed: String?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.animal = try Animal(from: decoder)
        self.breed = try values.decodeIfPresent(String.self, forKey: "breed")
    }
}

 struct Cat: Decodable {
    var animal: Animal
    var isDeclawed: Bool?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.animal = try Animal(from: decoder)
        self.isDeclawed = try values.decodeIfPresent(Bool.self, forKey: "declawed")
    }
}

 struct Animal: Decodable {
    var className: String
    var color: String?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.className = try values.decode(String.self, forKey: "className")
        self.color = try values.decodeIfPresent(String.self, forKey: "color")
    }
}

 struct FormatTest: Decodable {
    var binary: String?
    var byte: String
    var date: String
    var dateTime: Date?
    var double: Double?
    var float: Double?
    var int32: Int?
    var int64: Int?
    var integer: Int?
    var number: Double
    var password: String
    var string: String?
    var uuid: String?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.binary = try values.decodeIfPresent(String.self, forKey: "binary")
        self.byte = try values.decode(String.self, forKey: "byte")
        self.date = try values.decode(String.self, forKey: "date")
        self.dateTime = try values.decodeIfPresent(Date.self, forKey: "dateTime")
        self.double = try values.decodeIfPresent(Double.self, forKey: "double")
        self.float = try values.decodeIfPresent(Double.self, forKey: "float")
        self.int32 = try values.decodeIfPresent(Int.self, forKey: "int32")
        self.int64 = try values.decodeIfPresent(Int.self, forKey: "int64")
        self.integer = try values.decodeIfPresent(Int.self, forKey: "integer")
        self.number = try values.decode(Double.self, forKey: "number")
        self.password = try values.decode(String.self, forKey: "password")
        self.string = try values.decodeIfPresent(String.self, forKey: "string")
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }
}

enum EnumClass: String, Codable, CaseIterable {
    case abc = "_abc"
    case minusefg = "-efg"
    case xyz = "(xyz)"
}

 struct EnumTest: Decodable {
    var enumInteger: Int?
    var enumNumber: Double?
    var enumString: EnumString?
    var outerEnum: OuterEnum?

    enum EnumString: String, Codable, CaseIterable {
        case upper = "UPPER"
        case lower
    }

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.enumInteger = try values.decodeIfPresent(Int.self, forKey: "enum_integer")
        self.enumNumber = try values.decodeIfPresent(Double.self, forKey: "enum_number")
        self.enumString = try values.decodeIfPresent(EnumString.self, forKey: "enum_string")
        self.outerEnum = try values.decodeIfPresent(OuterEnum.self, forKey: "outerEnum")
    }
}

 struct AdditionalPropertiesClass: Decodable {
    var mapOfMapProperty: [String: [String: String]]?
    var mapProperty: [String: String]?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.mapOfMapProperty = try values.decodeIfPresent([String: [String: String]].self, forKey: "map_of_map_property")
        self.mapProperty = try values.decodeIfPresent([String: String].self, forKey: "map_property")
    }
}

 struct MixedPropertiesAndAdditionalPropertiesClass: Decodable {
    var dateTime: Date?
    var map: [String: Animal]?
    var uuid: String?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.dateTime = try values.decodeIfPresent(Date.self, forKey: "dateTime")
        self.map = try values.decodeIfPresent([String: Animal].self, forKey: "map")
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }
}

 struct List: Decodable {
    var _123List: String?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self._123List = try values.decodeIfPresent(String.self, forKey: "123-list")
    }
}

 struct Client: Decodable {
    var client: String?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.client = try values.decodeIfPresent(String.self, forKey: "client")
    }
}

 struct ReadOnlyFirst: Decodable {
    var bar: String?
    var baz: String?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.bar = try values.decodeIfPresent(String.self, forKey: "bar")
        self.baz = try values.decodeIfPresent(String.self, forKey: "baz")
    }
}

 struct HasOnlyReadOnly: Decodable {
    var bar: String?
    var foo: String?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.bar = try values.decodeIfPresent(String.self, forKey: "bar")
        self.foo = try values.decodeIfPresent(String.self, forKey: "foo")
    }
}

 struct Capitalization: Decodable {
    /// Name of the pet
    var attName: String?
    var capitalCamel: String?
    var capitalSnake: String?
    var sCAETHFlowPoints: String?
    var smallCamel: String?
    var smallSnake: String?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.attName = try values.decodeIfPresent(String.self, forKey: "ATT_NAME")
        self.capitalCamel = try values.decodeIfPresent(String.self, forKey: "CapitalCamel")
        self.capitalSnake = try values.decodeIfPresent(String.self, forKey: "Capital_Snake")
        self.sCAETHFlowPoints = try values.decodeIfPresent(String.self, forKey: "SCA_ETH_Flow_Points")
        self.smallCamel = try values.decodeIfPresent(String.self, forKey: "smallCamel")
        self.smallSnake = try values.decodeIfPresent(String.self, forKey: "small_Snake")
    }
}

 struct MapTest: Decodable {
    var mapMapOfString: [String: [String: String]]?
    var mapOfEnumString: [String: MapOfEnumStringItem]?

    enum MapOfEnumStringItem: String, Codable, CaseIterable {
        case upper = "UPPER"
        case lower
    }

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.mapMapOfString = try values.decodeIfPresent([String: [String: String]].self, forKey: "map_map_of_string")
        self.mapOfEnumString = try values.decodeIfPresent([String: MapOfEnumStringItem].self, forKey: "map_of_enum_string")
    }
}

 struct ArrayTest: Decodable {
    var arrayArrayOfInteger: [[Int]]?
    var arrayArrayOfModel: [[ReadOnlyFirst]]?
    var arrayOfString: [String]?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.arrayArrayOfInteger = try values.decodeIfPresent([[Int]].self, forKey: "array_array_of_integer")
        self.arrayArrayOfModel = try values.decodeIfPresent([[ReadOnlyFirst]].self, forKey: "array_array_of_model")
        self.arrayOfString = try values.decodeIfPresent([String].self, forKey: "array_of_string")
    }
}

 struct NumberOnly: Decodable {
    var justNumber: Double?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.justNumber = try values.decodeIfPresent(Double.self, forKey: "JustNumber")
    }
}

 struct ArrayOfNumberOnly: Decodable {
    var arrayNumber: [Double]?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.arrayNumber = try values.decodeIfPresent([Double].self, forKey: "ArrayNumber")
    }
}

 struct ArrayOfArrayOfNumberOnly: Decodable {
    var arrayArrayNumber: [[Double]]?

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.arrayArrayNumber = try values.decodeIfPresent([[Double]].self, forKey: "ArrayArrayNumber")
    }
}

 struct EnumArrays: Decodable {
    var arrayEnum: [ArrayEnumItem]?
    var justSymbol: JustSymbol?

    enum ArrayEnumItem: String, Codable, CaseIterable {
        case fish
        case crab
    }

    enum JustSymbol: String, Codable, CaseIterable {
        case greaterThanOrEqualTo = ">="
        case dollar = "$"
    }

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.arrayEnum = try values.decodeIfPresent([ArrayEnumItem].self, forKey: "array_enum")
        self.justSymbol = try values.decodeIfPresent(JustSymbol.self, forKey: "just_symbol")
    }
}

enum OuterEnum: String, Codable, CaseIterable {
    case placed
    case approved
    case delivered
}

 struct ContainerA: Decodable {
    var child: Child?
    var refChild: AnyJSON

     struct Child: Decodable {
        var child: Child
        var `enum`: Enum
        var renameMe: String

         struct Child: Decodable {
            var `enum`: Enum
            var renameMe: String

            enum Enum: String, Codable, CaseIterable {
                case a
                case b
            }

            init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.enum = try values.decode(Enum.self, forKey: "enum")
                self.renameMe = try values.decode(String.self, forKey: "rename-me")
            }
        }

        enum Enum: String, Codable, CaseIterable {
            case a
            case b
        }

        init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.child = try values.decode(Child.self, forKey: "child")
            self.enum = try values.decode(Enum.self, forKey: "enum")
            self.renameMe = try values.decode(String.self, forKey: "rename-me")
        }
    }

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.child = try values.decodeIfPresent(Child.self, forKey: "child")
        self.refChild = try values.decode(AnyJSON.self, forKey: "refChild")
    }
}

 struct ContainerB: Decodable {
    var child: Child

     struct Child: Decodable {
        var child: Child
        var `enum`: Enum
        var renameMe: String

         struct Child: Decodable {
            var `enum`: Enum
            var renameMe: String

            enum Enum: String, Codable, CaseIterable {
                case a
                case b
            }

            init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.enum = try values.decode(Enum.self, forKey: "enum")
                self.renameMe = try values.decode(String.self, forKey: "rename-me")
            }
        }

        enum Enum: String, Codable, CaseIterable {
            case a
            case b
        }

        init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.child = try values.decode(Child.self, forKey: "child")
            self.enum = try values.decode(Enum.self, forKey: "enum")
            self.renameMe = try values.decode(String.self, forKey: "rename-me")
        }
    }

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.child = try values.decode(Child.self, forKey: "child")
    }
}

 struct ContainerC: Decodable {
    var child: Child

     struct Child: Decodable {
        var `enum`: Enum
        var renameMe: String

        enum Enum: String, Codable, CaseIterable {
            case a
            case b
        }

        init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.enum = try values.decode(Enum.self, forKey: "enum")
            self.renameMe = try values.decode(String.self, forKey: "rename-me")
        }
    }

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.child = try values.decode(Child.self, forKey: "child")
    }
}


public enum AnyJSON: Equatable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }
}

extension AnyJSON: Codable {
    public func encode(to encoder: Encoder) throws {

        var container = encoder.singleValueContainer()

        switch self {
        case let .array(array):
            try container.encode(array)
        case let .object(object):
            try container.encode(object)
        case let .string(string):
            try container.encode(string)
        case let .number(number):
            try container.encode(number)
        case let .bool(bool):
            try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()

        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

extension AnyJSON: CustomDebugStringConvertible {

    public var debugDescription: String {
        switch self {
        case .string(let str):
            return str.debugDescription
        case .number(let num):
            return num.debugDescription
        case .bool(let bool):
            return bool.description
        default:
            let encoder = JSONEncoder()
            encoder.outputFormatting = [.prettyPrinted]
            return try! String(data: encoder.encode(self), encoding: .utf8)!
        }
    }
}
struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
