// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension Paths {
    public static var users: Users {
        Users(path: "/v0.1/users")
    }

    public struct Users {
        /// Path: `/v0.1/users`
        public let path: String
    }
}

extension Paths.Users {
    public func userID(_ userID: String) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/v0.1/users/{user_id}`
        public let path: String
    }
}

extension Paths.Users.WithUserID {
    public var devices: Devices {
        Devices(path: path + "/devices")
    }

    public struct Devices {
        /// Path: `/v0.1/users/{user_id}/devices`
        public let path: String
    }
}

extension Paths.Users.WithUserID.Devices {
    public var register: Register {
        Register(path: path + "/register")
    }

    public struct Register {
        /// Path: `/v0.1/users/{user_id}/devices/register`
        public let path: String

        /// Registers a user for an existing device
        public func post(_ body: PostRequest) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        /// The information for a single iOS device
        public struct PostRequest: Encodable {
            /// The Unique Device IDentifier of the device
            public var udid: String
            /// The model identifier of the device, in the format iDeviceM,N
            public var model: String
            /// The build number of the last known OS version running on the device
            public var osBuild: String?
            /// The last known OS version running on the device
            public var osVersion: String?
            /// The device's serial number. Always empty or undefined at present.
            public var serial: String?
            /// The device's International Mobile Equipment Identity number. Always empty or undefined at present.
            public var imei: String?
            /// The user ID of the device owner.
            public var ownerID: String?

            public init(udid: String, model: String, osBuild: String? = nil, osVersion: String? = nil, serial: String? = nil, imei: String? = nil, ownerID: String? = nil) {
                self.udid = udid
                self.model = model
                self.osBuild = osBuild
                self.osVersion = osVersion
                self.serial = serial
                self.imei = imei
                self.ownerID = ownerID
            }

            private enum CodingKeys: String, CodingKey {
                case udid
                case model
                case osBuild = "os_build"
                case osVersion = "os_version"
                case serial
                case imei
                case ownerID = "owner_id"
            }
        }
    }
}

extension Paths.User {
    public var notifications: Notifications {
        Notifications(path: path + "/notifications")
    }

    public struct Notifications {
        /// Path: `/v0.1/user/notifications`
        public let path: String
    }
}

extension Paths.User.Notifications {
    public var emailSettings: EmailSettings {
        EmailSettings(path: path + "/emailSettings")
    }

    public struct EmailSettings {
        /// Path: `/v0.1/user/notifications/emailSettings`
        public let path: String

        /// Get Default email notification settings for the user
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Alerting Default Email Settings of the user
        public struct GetResponse: Decodable {
            /// Unique request identifier for tracking
            public var requestID: String

            public init(requestID: String) {
                self.requestID = requestID
            }

            private enum CodingKeys: String, CodingKey {
                case requestID = "request_id"
            }
        }
    }
}

extension Paths.User {
    public var metadata: Metadata {
        Metadata(path: path + "/metadata")
    }

    public struct Metadata {
        /// Path: `/v0.1/user/metadata`
        public let path: String
    }
}

extension Paths.User.Metadata {
    public var optimizely: Optimizely {
        Optimizely(path: path + "/optimizely")
    }

    public struct Optimizely {
        /// Path: `/v0.1/user/metadata/optimizely`
        public let path: String

        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.User {
    public var invitations: Invitations {
        Invitations(path: path + "/invitations")
    }

    public struct Invitations {
        /// Path: `/v0.1/user/invitations`
        public let path: String
    }
}

extension Paths.User.Invitations {
    public var orgs: Orgs {
        Orgs(path: path + "/orgs")
    }

    public struct Orgs {
        /// Path: `/v0.1/user/invitations/orgs`
        public let path: String
    }
}

extension Paths.User.Invitations.Orgs {
    public func invitationToken(_ invitationToken: String) -> WithInvitationToken {
        WithInvitationToken(path: "\(path)/\(invitationToken)")
    }

    public struct WithInvitationToken {
        /// Path: `/v0.1/user/invitations/orgs/{invitation_token}`
        public let path: String
    }
}

extension Paths.User.Invitations.Orgs.WithInvitationToken {
    public var reject: Reject {
        Reject(path: path + "/reject")
    }

    public struct Reject {
        /// Path: `/v0.1/user/invitations/orgs/{invitation_token}/reject`
        public let path: String

        /// Rejects a pending organization invitation
        public func post(_ body: [String: AnyJSON]? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.User.Invitations.Orgs.WithInvitationToken {
    public var accept: Accept {
        Accept(path: path + "/accept")
    }

    public struct Accept {
        /// Path: `/v0.1/user/invitations/orgs/{invitation_token}/accept`
        public let path: String

        /// Accepts a pending organization invitation for the specified user
        public func post(_ body: [String: AnyJSON]? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.User.Invitations {
    public var distributionGroups: DistributionGroups {
        DistributionGroups(path: path + "/distribution_groups")
    }

    public struct DistributionGroups {
        /// Path: `/v0.1/user/invitations/distribution_groups`
        public let path: String
    }
}

extension Paths.User.Invitations.DistributionGroups {
    public var accept: Accept {
        Accept(path: path + "/accept")
    }

    public struct Accept {
        /// Path: `/v0.1/user/invitations/distribution_groups/accept`
        public let path: String

        /// Accepts all pending invitations to distribution groups for the specified user
        public func post(_ body: [String: AnyJSON]? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.User.Invitations {
    public var apps: Apps {
        Apps(path: path + "/apps")
    }

    public struct Apps {
        /// Path: `/v0.1/user/invitations/apps`
        public let path: String
    }
}

extension Paths.User.Invitations.Apps {
    public func invitationToken(_ invitationToken: String) -> WithInvitationToken {
        WithInvitationToken(path: "\(path)/\(invitationToken)")
    }

    public struct WithInvitationToken {
        /// Path: `/v0.1/user/invitations/apps/{invitation_token}`
        public let path: String
    }
}

extension Paths.User.Invitations.Apps.WithInvitationToken {
    public var reject: Reject {
        Reject(path: path + "/reject")
    }

    public struct Reject {
        /// Path: `/v0.1/user/invitations/apps/{invitation_token}/reject`
        public let path: String

        /// Rejects a pending invitation for the specified user
        public func post(_ body: [String: AnyJSON]? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.User.Invitations.Apps.WithInvitationToken {
    public var accept: Accept {
        Accept(path: path + "/accept")
    }

    public struct Accept {
        /// Path: `/v0.1/user/invitations/apps/{invitation_token}/accept`
        public let path: String

        /// Accepts a pending invitation for the specified user
        public func post(_ body: [String: AnyJSON]? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.User {
    public var export: Export {
        Export(path: path + "/export")
    }

    public struct Export {
        /// Path: `/v0.1/user/export`
        public let path: String
    }
}

extension Paths.User.Export {
    public var serviceConnections: ServiceConnections {
        ServiceConnections(path: path + "/serviceConnections")
    }

    public struct ServiceConnections {
        /// Path: `/v0.1/user/export/serviceConnections`
        public let path: String

        /// Gets all service connections of the service type for GDPR export.
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        /// SharedConnectionResponse
        public struct GetResponseItem: Decodable {
            /// Id of the shared connection
            public var id: String
            /// Display name of shared connection
            public var displayName: String?
            /// Service type of shared connection can be apple|gitlab|googleplay|jira
            public var serviceType: ServiceType
            /// The type of the credential
            public var credentialType: CredentialType
            /// Whether the credentials are valid or not
            public var isValid: Bool?
            /// If the account is a 2FA account or not
            public var isIs2FA: Bool?

            /// Service type of shared connection can be apple|gitlab|googleplay|jira
            public enum ServiceType: String, Codable, CaseIterable {
                case apple
                case jira
                case googleplay
                case gitlab
            }

            /// The type of the credential
            public enum CredentialType: String, Codable, CaseIterable {
                case credentials
                case certificate
            }

            public init(id: String, displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
                self.id = id
                self.displayName = displayName
                self.serviceType = serviceType
                self.credentialType = credentialType
                self.isValid = isValid
                self.isIs2FA = isIs2FA
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case displayName
                case serviceType
                case credentialType
                case isValid
                case isIs2FA = "is2FA"
            }
        }
    }
}

extension Paths.User {
    public var dsr: Dsr {
        Dsr(path: path + "/dsr")
    }

    public struct Dsr {
        /// Path: `/v0.1/user/dsr`
        public let path: String
    }
}

extension Paths.User.Dsr.Export.WithToken {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/v0.1/user/dsr/export/{token}/cancel`
        public let path: String

        public var post: Request<PostResponse> {
            .post(path)
        }

        public enum PostResponseHeaders {
            /// Link to get details about the cancel export.
            public static let location = HTTPHeader<String>(field: "Location")
        }

        public struct PostResponse: Decodable {
            /// Unique request identifier
            public var token: String
            /// ISO 8601 format timestamp of when request was created.
            public var createdAt: Date

            public init(token: String, createdAt: Date) {
                self.token = token
                self.createdAt = createdAt
            }
        }
    }
}

extension Paths.User.Dsr.Export {
    public func token(_ token: String) -> WithToken {
        WithToken(path: "\(path)/\(token)")
    }

    public struct WithToken {
        /// Path: `/v0.1/user/dsr/export/{token}`
        public let path: String

        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Azure Storage shared access signature (SAS) URL for exported user data.
            public var sasURL: String?
            /// Whether Azure Storage shared access signature (SAS) URL has expired or not.
            public var isSasURLExpired: Bool?
            /// Status of data subject right request
            public var status: Status
            /// Explanation message of the status
            public var message: String

            /// Status of data subject right request
            public enum Status: String, Codable, CaseIterable {
                case `none` = "None"
                case created = "Created"
                case queued = "Queued"
                case inProgress = "InProgress"
                case completed = "Completed"
                case failed = "Failed"
            }

            public init(sasURL: String? = nil, isSasURLExpired: Bool? = nil, status: Status, message: String) {
                self.sasURL = sasURL
                self.isSasURLExpired = isSasURLExpired
                self.status = status
                self.message = message
            }

            private enum CodingKeys: String, CodingKey {
                case sasURL = "sasUrl"
                case isSasURLExpired = "sasUrlExpired"
                case status
                case message
            }
        }
    }
}

extension Paths.User.Dsr {
    public var export: Export {
        Export(path: path + "/export")
    }

    public struct Export {
        /// Path: `/v0.1/user/dsr/export`
        public let path: String

        public var post: Request<PostResponse> {
            .post(path)
        }

        public enum PostResponseHeaders {
            /// Link to get details about the export.
            public static let location = HTTPHeader<String>(field: "Location")
        }

        public struct PostResponse: Decodable {
            /// Unique request identifier
            public var token: String
            /// ISO 8601 format timestamp of when request was created.
            public var createdAt: Date

            public init(token: String, createdAt: Date) {
                self.token = token
                self.createdAt = createdAt
            }
        }
    }
}

extension Paths.User.Dsr.Delete.WithToken {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/v0.1/user/dsr/delete/{token}/cancel`
        public let path: String

        public func post(email: String) -> Request<PostResponse> {
            .post(path, body: ["email": email])
        }

        public enum PostResponseHeaders {
            /// Link to get details about the cancel delete.
            public static let location = HTTPHeader<String>(field: "Location")
        }

        public struct PostResponse: Decodable {
            /// Unique request identifier
            public var token: String
            /// ISO 8601 format timestamp of when request was created.
            public var createdAt: Date

            public init(token: String, createdAt: Date) {
                self.token = token
                self.createdAt = createdAt
            }
        }
    }
}

extension Paths.User.Dsr.Delete {
    public func token(_ token: String) -> WithToken {
        WithToken(path: "\(path)/\(token)")
    }

    public struct WithToken {
        /// Path: `/v0.1/user/dsr/delete/{token}`
        public let path: String

        public func get(email: String) -> Request<GetResponse> {
            .get(path, query: [("email", email)])
        }

        public struct GetResponse: Decodable {
            /// Azure Storage shared access signature (SAS) URL for exported user data.
            public var sasURL: String?
            /// Whether Azure Storage shared access signature (SAS) URL has expired or not.
            public var isSasURLExpired: Bool?
            /// Status of data subject right request
            public var status: Status
            /// Explanation message of the status
            public var message: String

            /// Status of data subject right request
            public enum Status: String, Codable, CaseIterable {
                case `none` = "None"
                case created = "Created"
                case queued = "Queued"
                case inProgress = "InProgress"
                case completed = "Completed"
                case failed = "Failed"
            }

            public init(sasURL: String? = nil, isSasURLExpired: Bool? = nil, status: Status, message: String) {
                self.sasURL = sasURL
                self.isSasURLExpired = isSasURLExpired
                self.status = status
                self.message = message
            }

            private enum CodingKeys: String, CodingKey {
                case sasURL = "sasUrl"
                case isSasURLExpired = "sasUrlExpired"
                case status
                case message
            }
        }
    }
}

extension Paths.User.Dsr {
    public var delete: Delete {
        Delete(path: path + "/delete")
    }

    public struct Delete {
        /// Path: `/v0.1/user/dsr/delete`
        public let path: String

        public var post: Request<PostResponse> {
            .post(path)
        }

        public enum PostResponseHeaders {
            /// Link to get details about the delete.
            public static let location = HTTPHeader<String>(field: "Location")
        }

        public struct PostResponse: Decodable {
            /// Unique request identifier
            public var token: String
            /// ISO 8601 format timestamp of when request was created.
            public var createdAt: Date

            public init(token: String, createdAt: Date) {
                self.token = token
                self.createdAt = createdAt
            }
        }
    }
}

extension Paths.User.Devices {
    public func deviceUdid(_ deviceUdid: String) -> WithDeviceUdid {
        WithDeviceUdid(path: "\(path)/\(deviceUdid)")
    }

    public struct WithDeviceUdid {
        /// Path: `/v0.1/user/devices/{device_udid}`
        public let path: String

        /// Returns the device details.
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Removes an existing device from a user
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.User {
    public var devices: Devices {
        Devices(path: path + "/devices")
    }

    public struct Devices {
        /// Path: `/v0.1/user/devices`
        public let path: String

        /// Returns all devices associated with the given user.
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        /// The information for a single iOS device
        public struct GetResponseItem: Decodable {
            /// The Unique Device IDentifier of the device
            public var udid: String
            /// The model identifier of the device, in the format iDeviceM,N
            public var model: String
            /// The device description, in the format "iPhone 7 Plus (A1784)"
            public var deviceName: String
            /// A combination of the device model name and the owner name.
            public var fullDeviceName: String?
            /// The last known OS version running on the device
            public var osBuild: String
            /// The last known OS version running on the device
            public var osVersion: String
            /// The device's serial number. Always empty or undefined at present.
            public var serial: String?
            /// The device's International Mobile Equipment Identity number. Always empty or undefined at present.
            public var imei: String?
            /// The user ID of the device owner.
            public var ownerID: String?
            /// The provisioning status of the device.
            public var status: String
            /// Timestamp of when the device was registered in ISO format.
            public var registeredAt: String?

            public init(udid: String, model: String, deviceName: String, fullDeviceName: String? = nil, osBuild: String, osVersion: String, serial: String? = nil, imei: String? = nil, ownerID: String? = nil, status: String, registeredAt: String? = nil) {
                self.udid = udid
                self.model = model
                self.deviceName = deviceName
                self.fullDeviceName = fullDeviceName
                self.osBuild = osBuild
                self.osVersion = osVersion
                self.serial = serial
                self.imei = imei
                self.ownerID = ownerID
                self.status = status
                self.registeredAt = registeredAt
            }

            private enum CodingKeys: String, CodingKey {
                case udid
                case model
                case deviceName = "device_name"
                case fullDeviceName = "full_device_name"
                case osBuild = "os_build"
                case osVersion = "os_version"
                case serial
                case imei
                case ownerID = "owner_id"
                case status
                case registeredAt = "registered_at"
            }
        }
    }
}

extension Paths {
    public static var user: User {
        User(path: "/v0.1/user")
    }

    public struct User {
        /// Path: `/v0.1/user`
        public let path: String

        /// Returns the user profile data
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Updates the user profile and returns the updated user data
        public func patch(displayName: String? = nil) -> Request<[String: AnyJSON]> {
            .patch(path, body: ["display_name": displayName])
        }
    }
}

extension Paths {
    public static var sdk: Sdk {
        Sdk(path: "/v0.1/sdk")
    }

    public struct Sdk {
        /// Path: `/v0.1/sdk`
        public let path: String
    }
}

extension Paths.Sdk {
    public var apps: Apps {
        Apps(path: path + "/apps")
    }

    public struct Apps {
        /// Path: `/v0.1/sdk/apps`
        public let path: String
    }
}

extension Paths.Sdk.Apps {
    public func appSecret(_ appSecret: String) -> WithAppSecret {
        WithAppSecret(path: "\(path)/\(appSecret)")
    }

    public struct WithAppSecret {
        /// Path: `/v0.1/sdk/apps/{app_secret}`
        public let path: String
    }
}

extension Paths.Sdk.Apps.WithAppSecret {
    public var releases: Releases {
        Releases(path: path + "/releases")
    }

    public struct Releases {
        /// Path: `/v0.1/sdk/apps/{app_secret}/releases`
        public let path: String
    }
}

extension Paths.Sdk.Apps.WithAppSecret.Releases {
    public func releaseHash(_ releaseHash: String) -> WithReleaseHash {
        WithReleaseHash(path: "\(path)/\(releaseHash)")
    }

    public struct WithReleaseHash {
        /// Path: `/v0.1/sdk/apps/{app_secret}/releases/{release_hash}`
        public let path: String

        /// If 'latest' is not specified then it will return the specified release if it's enabled. If 'latest' is specified, regardless of whether a release hash is provided, the latest enabled release is returned.
        public func get(udid: String? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(udid))
        }

        private func makeGetQuery(_ udid: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(udid, forKey: "udid")
            return encoder.items
        }
    }
}

extension Paths.Sdk.Apps.WithAppSecret.Releases {
    public var `private`: Private {
        Private(path: path + "/private")
    }

    public struct Private {
        /// Path: `/v0.1/sdk/apps/{app_secret}/releases/private`
        public let path: String
    }
}

extension Paths.Sdk.Apps.WithAppSecret.Releases.Private {
    public var latest: Latest {
        Latest(path: path + "/latest")
    }

    public struct Latest {
        /// Path: `/v0.1/sdk/apps/{app_secret}/releases/private/latest`
        public let path: String

        /// Get the latest release distributed to a private group the given user is a member of for the given app.
        public func get(udid: String? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(udid))
        }

        private func makeGetQuery(_ udid: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(udid, forKey: "udid")
            return encoder.items
        }
    }
}

extension Paths {
    public static var `public`: Public {
        Public(path: "/v0.1/public")
    }

    public struct Public {
        /// Path: `/v0.1/public`
        public let path: String
    }
}

extension Paths.Public {
    public var sparkle: Sparkle {
        Sparkle(path: path + "/sparkle")
    }

    public struct Sparkle {
        /// Path: `/v0.1/public/sparkle`
        public let path: String
    }
}

extension Paths.Public.Sparkle {
    public var apps: Apps {
        Apps(path: path + "/apps")
    }

    public struct Apps {
        /// Path: `/v0.1/public/sparkle/apps`
        public let path: String
    }
}

extension Paths.Public.Sparkle.Apps {
    public func appSecret(_ appSecret: String) -> WithAppSecret {
        WithAppSecret(path: "\(path)/\(appSecret)")
    }

    public struct WithAppSecret {
        /// Path: `/v0.1/public/sparkle/apps/{app_secret}`
        public let path: String

        /// Gets the sparkle feed of the releases that are distributed to all the public distribution groups.
        public var get: Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Public {
    public var sdk: Sdk {
        Sdk(path: path + "/sdk")
    }

    public struct Sdk {
        /// Path: `/v0.1/public/sdk`
        public let path: String
    }
}

extension Paths.Public.Sdk {
    public var apps: Apps {
        Apps(path: path + "/apps")
    }

    public struct Apps {
        /// Path: `/v0.1/public/sdk/apps`
        public let path: String
    }
}

extension Paths.Public.Sdk.Apps {
    public func appSecret(_ appSecret: String) -> WithAppSecret {
        WithAppSecret(path: "\(path)/\(appSecret)")
    }

    public struct WithAppSecret {
        /// Path: `/v0.1/public/sdk/apps/{app_secret}`
        public let path: String
    }
}

extension Paths.Public.Sdk.Apps.WithAppSecret {
    public var releases: Releases {
        Releases(path: path + "/releases")
    }

    public struct Releases {
        /// Path: `/v0.1/public/sdk/apps/{app_secret}/releases`
        public let path: String
    }
}

extension Paths.Public.Sdk.Apps.WithAppSecret.Releases {
    public func releaseHash(_ releaseHash: String) -> WithReleaseHash {
        WithReleaseHash(path: "\(path)/\(releaseHash)")
    }

    public struct WithReleaseHash {
        /// Path: `/v0.1/public/sdk/apps/{app_secret}/releases/{release_hash}`
        public let path: String
    }
}

extension Paths.Public.Sdk.Apps.WithAppSecret.Releases.WithReleaseHash {
    public var publicDistributionGroups: PublicDistributionGroups {
        PublicDistributionGroups(path: path + "/public_distribution_groups")
    }

    public struct PublicDistributionGroups {
        /// Path: `/v0.1/public/sdk/apps/{app_secret}/releases/{release_hash}/public_distribution_groups`
        public let path: String

        /// Get all public distribution groups that a given release has been distributed to
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The id of the distribution group
            public var id: String

            public init(id: String) {
                self.id = id
            }
        }
    }
}

extension Paths.Public.Sdk.Apps.WithAppSecret.Releases {
    public var latest: Latest {
        Latest(path: path + "/latest")
    }

    public struct Latest {
        /// Path: `/v0.1/public/sdk/apps/{app_secret}/releases/latest`
        public let path: String

        /// Get the latest public release for the given app.
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Public.Sdk.Apps.WithAppSecret {
    public var distributionGroups: DistributionGroups {
        DistributionGroups(path: path + "/distribution_groups")
    }

    public struct DistributionGroups {
        /// Path: `/v0.1/public/sdk/apps/{app_secret}/distribution_groups`
        public let path: String
    }
}

extension Paths.Public.Sdk.Apps.WithAppSecret.DistributionGroups {
    public func distributionGroupID(_ distributionGroupID: String) -> WithDistributionGroupID {
        WithDistributionGroupID(path: "\(path)/\(distributionGroupID)")
    }

    public struct WithDistributionGroupID {
        /// Path: `/v0.1/public/sdk/apps/{app_secret}/distribution_groups/{distribution_group_id}`
        public let path: String
    }
}

extension Paths.Public.Sdk.Apps.WithAppSecret.DistributionGroups.WithDistributionGroupID {
    public var releases: Releases {
        Releases(path: path + "/releases")
    }

    public struct Releases {
        /// Path: `/v0.1/public/sdk/apps/{app_secret}/distribution_groups/{distribution_group_id}/releases`
        public let path: String
    }
}

extension Paths.Public.Sdk.Apps.WithAppSecret.DistributionGroups.WithDistributionGroupID.Releases {
    public var latest: Latest {
        Latest(path: path + "/latest")
    }

    public struct Latest {
        /// Path: `/v0.1/public/sdk/apps/{app_secret}/distribution_groups/{distribution_group_id}/releases/latest`
        public let path: String

        /// Get a release with 'latest' for the given public group.
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Public {
    public var hooks: Hooks {
        Hooks(path: path + "/hooks")
    }

    public struct Hooks {
        /// Path: `/v0.1/public/hooks`
        public let path: String

        /// Public webhook sink
        public func post(_ body: [String: AnyJSON]? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Public {
    public var codepush: Codepush {
        Codepush(path: path + "/codepush")
    }

    public struct Codepush {
        /// Path: `/v0.1/public/codepush`
        public let path: String
    }
}

extension Paths.Public.Codepush {
    public var updateCheck: UpdateCheck {
        UpdateCheck(path: path + "/update_check")
    }

    public struct UpdateCheck {
        /// Path: `/v0.1/public/codepush/update_check`
        public let path: String

        /// Check for updates
        public func get(parameters: GetParameters) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var deploymentKey: String
            public var appVersion: String
            public var packageHash: String?
            public var label: String?
            public var clientUniqueID: String?
            public var isCompanion: Bool?
            public var previousLabelOrAppVersion: String?
            public var previousDeploymentKey: String?

            public init(deploymentKey: String, appVersion: String, packageHash: String? = nil, label: String? = nil, clientUniqueID: String? = nil, isCompanion: Bool? = nil, previousLabelOrAppVersion: String? = nil, previousDeploymentKey: String? = nil) {
                self.deploymentKey = deploymentKey
                self.appVersion = appVersion
                self.packageHash = packageHash
                self.label = label
                self.clientUniqueID = clientUniqueID
                self.isCompanion = isCompanion
                self.previousLabelOrAppVersion = previousLabelOrAppVersion
                self.previousDeploymentKey = previousDeploymentKey
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(deploymentKey, forKey: "deployment_key")
                encoder.encode(appVersion, forKey: "app_version")
                encoder.encode(packageHash, forKey: "package_hash")
                encoder.encode(label, forKey: "label")
                encoder.encode(clientUniqueID, forKey: "client_unique_id")
                encoder.encode(isCompanion, forKey: "is_companion")
                encoder.encode(previousLabelOrAppVersion, forKey: "previous_label_or_app_version")
                encoder.encode(previousDeploymentKey, forKey: "previous_deployment_key")
                return encoder.items
            }
        }
    }
}

extension Paths.Public.Codepush {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/v0.1/public/codepush/status`
        public let path: String

        /// Returns the acquisition service status to the caller
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Public.Codepush {
    public var reportStatus: ReportStatus {
        ReportStatus(path: path + "/report_status")
    }

    public struct ReportStatus {
        /// Path: `/v0.1/public/codepush/report_status`
        public let path: String
    }
}

extension Paths.Public.Codepush.ReportStatus {
    public var download: Download {
        Download(path: path + "/download")
    }

    public struct Download {
        /// Path: `/v0.1/public/codepush/report_status/download`
        public let path: String

        /// Report download of specified release
        public func post(_ body: PostRequest) -> Request<Void> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            public var deploymentKey: String
            public var label: String?
            public var appVersion: String?
            public var previousDeploymentKey: String?
            public var previousLabelOrAppVersion: String?
            public var status: String?
            public var clientUniqueID: String?

            public init(deploymentKey: String, label: String? = nil, appVersion: String? = nil, previousDeploymentKey: String? = nil, previousLabelOrAppVersion: String? = nil, status: String? = nil, clientUniqueID: String? = nil) {
                self.deploymentKey = deploymentKey
                self.label = label
                self.appVersion = appVersion
                self.previousDeploymentKey = previousDeploymentKey
                self.previousLabelOrAppVersion = previousLabelOrAppVersion
                self.status = status
                self.clientUniqueID = clientUniqueID
            }

            private enum CodingKeys: String, CodingKey {
                case deploymentKey = "deployment_key"
                case label
                case appVersion = "app_version"
                case previousDeploymentKey = "previous_deployment_key"
                case previousLabelOrAppVersion = "previous_label_or_app_version"
                case status
                case clientUniqueID = "client_unique_id"
            }
        }
    }
}

extension Paths.Public.Codepush.ReportStatus {
    public var deploy: Deploy {
        Deploy(path: path + "/deploy")
    }

    public struct Deploy {
        /// Path: `/v0.1/public/codepush/report_status/deploy`
        public let path: String

        /// Report Deployment status metric
        public func post(_ body: PostRequest) -> Request<Void> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            public var deploymentKey: String
            public var label: String?
            public var appVersion: String?
            public var previousDeploymentKey: String?
            public var previousLabelOrAppVersion: String?
            public var status: String?
            public var clientUniqueID: String?

            public init(deploymentKey: String, label: String? = nil, appVersion: String? = nil, previousDeploymentKey: String? = nil, previousLabelOrAppVersion: String? = nil, status: String? = nil, clientUniqueID: String? = nil) {
                self.deploymentKey = deploymentKey
                self.label = label
                self.appVersion = appVersion
                self.previousDeploymentKey = previousDeploymentKey
                self.previousLabelOrAppVersion = previousLabelOrAppVersion
                self.status = status
                self.clientUniqueID = clientUniqueID
            }

            private enum CodingKeys: String, CodingKey {
                case deploymentKey = "deployment_key"
                case label
                case appVersion = "app_version"
                case previousDeploymentKey = "previous_deployment_key"
                case previousLabelOrAppVersion = "previous_label_or_app_version"
                case status
                case clientUniqueID = "client_unique_id"
            }
        }
    }
}

extension Paths.Public {
    public var apps: Apps {
        Apps(path: path + "/apps")
    }

    public struct Apps {
        /// Path: `/v0.1/public/apps`
        public let path: String
    }
}

extension Paths.Public.Apps {
    public func ownerName(_ ownerName: String) -> WithOwnerName {
        WithOwnerName(path: "\(path)/\(ownerName)")
    }

    public struct WithOwnerName {
        /// Path: `/v0.1/public/apps/{owner_name}`
        public let path: String
    }
}

extension Paths.Public.Apps.WithOwnerName {
    public func appName(_ appName: String) -> WithAppName {
        WithAppName(path: "\(path)/\(appName)")
    }

    public struct WithAppName {
        /// Path: `/v0.1/public/apps/{owner_name}/{app_name}`
        public let path: String
    }
}

extension Paths.Public.Apps.WithOwnerName.WithAppName {
    public var installAnalytics: InstallAnalytics {
        InstallAnalytics(path: path + "/install_analytics")
    }

    public struct InstallAnalytics {
        /// Path: `/v0.1/public/apps/{owner_name}/{app_name}/install_analytics`
        public let path: String

        /// Notify download(s) for the provided distribution release(s).
        public func post(releases: [PostRequest.Release]? = nil) -> Request<Void> {
            .post(path, body: PostRequest(releases: releases))
        }

        public struct PostRequest: Encodable {
            public var releases: [Release]?

            public struct Release: Encodable {
                /// Release id
                public var releaseID: Int
                /// Distribution group id
                public var distributionGroupID: String
                /// User id
                public var userID: String

                public init(releaseID: Int, distributionGroupID: String, userID: String) {
                    self.releaseID = releaseID
                    self.distributionGroupID = distributionGroupID
                    self.userID = userID
                }

                private enum CodingKeys: String, CodingKey {
                    case releaseID = "release_id"
                    case distributionGroupID = "distribution_group_id"
                    case userID = "user_id"
                }
            }

            public init(releases: [Release]? = nil) {
                self.releases = releases
            }
        }
    }
}

extension Paths.Public.Apps {
    public func appID(_ appID: String) -> WithAppID {
        WithAppID(path: "\(path)/\(appID)")
    }

    public struct WithAppID {
        /// Path: `/v0.1/public/apps/{app_id}`
        public let path: String
    }
}

extension Paths.Public.Apps.WithAppID {
    public var releases: Releases {
        Releases(path: path + "/releases")
    }

    public struct Releases {
        /// Path: `/v0.1/public/apps/{app_id}/releases`
        public let path: String
    }
}

extension Paths.Public.Apps.WithAppID.Releases {
    public func releaseID(_ releaseID: Int) -> WithReleaseID {
        WithReleaseID(path: "\(path)/\(releaseID)")
    }

    public struct WithReleaseID {
        /// Path: `/v0.1/public/apps/{app_id}/releases/{release_id}`
        public let path: String
    }
}

extension Paths.Public.Apps.WithAppID.Releases.WithReleaseID {
    public var iosManifest: IosManifest {
        IosManifest(path: path + "/ios_manifest")
    }

    public struct IosManifest {
        /// Path: `/v0.1/public/apps/{app_id}/releases/{release_id}/ios_manifest`
        public let path: String

        /// Returns the manifest.plist in XML format for installing the release on a device. Only available for iOS.
        public func get(token: String) -> Request<Void> {
            .get(path, query: [("token", token)])
        }
    }
}

extension Paths.Orgs.WithOrgName.Users.WithUserName {
    public var apps: Apps {
        Apps(path: path + "/apps")
    }

    public struct Apps {
        /// Path: `/v0.1/orgs/{org_name}/users/{user_name}/apps`
        public let path: String

        /// Get a user apps information from an organization by name
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The unique ID (UUID) of the app
            public var id: String
            /// The description of the app
            public var description: String?
            /// The display name of the app
            public var displayName: String
            /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
            public var releaseType: String?
            /// The string representation of the URL pointing to the app's icon
            public var iconURL: String?
            /// The string representation of the source of the app's icon
            public var iconSource: String?
            /// The name of the app used in URLs
            public var name: String
            /// The OS the app will be running on
            public var os: Os
            /// The information about the app's owner
            public var owner: Owner
            /// A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics
            public var appSecret: String?
            public var azureSubscription: AzureSubscription?
            /// The platform of the app
            public var platform: Platform?
            /// The creation origin of this app
            public var origin: Origin?
            /// The created date of this app
            public var createdAt: String?
            /// The last updated date of this app
            public var updatedAt: String?
            /// The permissions of the calling user
            public var memberPermissions: [MemberPermission]?

            /// The OS the app will be running on
            public enum Os: String, Codable, CaseIterable {
                case android = "Android"
                case iOS
                case macOS
                case tizen = "Tizen"
                case tvOS
                case windows = "Windows"
                case linux = "Linux"
                case custom = "Custom"
            }

            /// The information about the app's owner
            public struct Owner: Decodable {
                /// The unique id (UUID) of the owner
                public var id: String
                /// The avatar URL of the owner
                public var avatarURL: String?
                /// The owner's display name
                public var displayName: String
                /// The owner's email address
                public var email: String?
                /// The unique name that used to identify the owner
                public var name: String
                /// The owner type. Can either be 'org' or 'user'
                public var type: `Type`

                /// The owner type. Can either be 'org' or 'user'
                public enum `Type`: String, Codable, CaseIterable {
                    case org
                    case user
                }

                public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
                    self.id = id
                    self.avatarURL = avatarURL
                    self.displayName = displayName
                    self.email = email
                    self.name = name
                    self.type = type
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case avatarURL = "avatar_url"
                    case displayName = "display_name"
                    case email
                    case name
                    case type
                }
            }

            public struct AzureSubscription: Decodable {
                /// The azure subscription id
                public var subscriptionID: String
                /// The tenant id of the azure subscription belongs to
                public var tenantID: String
                /// The name of the azure subscription
                public var subscriptionName: String
                /// If the subscription is used for billing
                public var isBilling: Bool?
                /// If the subscription can be used for billing
                public var isBillable: Bool?
                /// If the subscription is internal Microsoft subscription
                public var isMicrosoftInternal: Bool?

                public init(subscriptionID: String, tenantID: String, subscriptionName: String, isBilling: Bool? = nil, isBillable: Bool? = nil, isMicrosoftInternal: Bool? = nil) {
                    self.subscriptionID = subscriptionID
                    self.tenantID = tenantID
                    self.subscriptionName = subscriptionName
                    self.isBilling = isBilling
                    self.isBillable = isBillable
                    self.isMicrosoftInternal = isMicrosoftInternal
                }

                private enum CodingKeys: String, CodingKey {
                    case subscriptionID = "subscription_id"
                    case tenantID = "tenant_id"
                    case subscriptionName = "subscription_name"
                    case isBilling = "is_billing"
                    case isBillable = "is_billable"
                    case isMicrosoftInternal = "is_microsoft_internal"
                }
            }

            /// The platform of the app
            public enum Platform: String, Codable, CaseIterable {
                case java = "Java"
                case objectiveCSwift = "Objective-C-Swift"
                case uwp = "UWP"
                case cordova = "Cordova"
                case reactNative = "React-Native"
                case unity = "Unity"
                case electron = "Electron"
                case xamarin = "Xamarin"
                case wpf = "WPF"
                case winForms = "WinForms"
                case unknown = "Unknown"
                case custom = "Custom"
            }

            /// The creation origin of this app
            public enum Origin: String, Codable, CaseIterable {
                case appcenter
                case hockeyapp
                case codepush
            }

            public enum MemberPermission: String, Codable, CaseIterable {
                case manager
                case developer
                case viewer
                case tester
            }

            public init(id: String, description: String? = nil, displayName: String, releaseType: String? = nil, iconURL: String? = nil, iconSource: String? = nil, name: String, os: Os, owner: Owner, appSecret: String? = nil, azureSubscription: AzureSubscription? = nil, platform: Platform? = nil, origin: Origin? = nil, createdAt: String? = nil, updatedAt: String? = nil, memberPermissions: [MemberPermission]? = nil) {
                self.id = id
                self.description = description
                self.displayName = displayName
                self.releaseType = releaseType
                self.iconURL = iconURL
                self.iconSource = iconSource
                self.name = name
                self.os = os
                self.owner = owner
                self.appSecret = appSecret
                self.azureSubscription = azureSubscription
                self.platform = platform
                self.origin = origin
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.memberPermissions = memberPermissions
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decode(String.self, forKey: "id")
                self.description = try values.decodeIfPresent(String.self, forKey: "description")
                self.displayName = try values.decode(String.self, forKey: "display_name")
                self.releaseType = try values.decodeIfPresent(String.self, forKey: "release_type")
                self.iconURL = try values.decodeIfPresent(String.self, forKey: "icon_url")
                self.iconSource = try values.decodeIfPresent(String.self, forKey: "icon_source")
                self.name = try values.decode(String.self, forKey: "name")
                self.os = try Os(from: decoder)
                self.owner = try Owner(from: decoder)
                self.appSecret = try values.decodeIfPresent(String.self, forKey: "app_secret")
                self.azureSubscription = try AzureSubscription(from: decoder)
                self.platform = try Platform(from: decoder)
                self.origin = try Origin(from: decoder)
                self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
                self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
                self.memberPermissions = try values.decodeIfPresent([MemberPermission].self, forKey: "member_permissions")
            }
        }
    }
}

extension Paths.Orgs.WithOrgName.Users {
    public func userName(_ userName: String) -> WithUserName {
        WithUserName(path: "\(path)/\(userName)")
    }

    public struct WithUserName {
        /// Path: `/v0.1/orgs/{org_name}/users/{user_name}`
        public let path: String

        /// Get a user information from an organization by name - if there is explicit permission return it, if not if not return highest implicit permission
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Updates the given organization user
        public func patch(role: PatchRequest.Role? = nil) -> Request<[String: AnyJSON]> {
            .patch(path, body: PatchRequest(role: role))
        }

        public struct PatchRequest: Encodable {
            /// The user's role in the organizatiion
            public var role: Role?

            /// The user's role in the organizatiion
            public enum Role: String, Codable, CaseIterable {
                case admin
                case collaborator
                case member
            }

            public init(role: Role? = nil) {
                self.role = role
            }
        }

        /// Removes a user from an organization.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrgName {
    public var users: Users {
        Users(path: path + "/users")
    }

    public struct Users {
        /// Path: `/v0.1/orgs/{org_name}/users`
        public let path: String

        /// Returns a list of users that belong to an organization
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The email address of the user
            public var email: String
            /// The full name of the user. Might for example be first and last name
            public var displayName: String
            /// The date when the user joined the organization
            public var joinedAt: String
            /// The unique name that is used to identify the user.
            public var name: String
            /// The role the user has within the organization
            public var role: String

            public init(email: String, displayName: String, joinedAt: String, name: String, role: String) {
                self.email = email
                self.displayName = displayName
                self.joinedAt = joinedAt
                self.name = name
                self.role = role
            }

            private enum CodingKeys: String, CodingKey {
                case email
                case displayName = "display_name"
                case joinedAt = "joined_at"
                case name
                case role
            }
        }
    }
}

extension Paths.Orgs.WithOrgName {
    public var testers: Testers {
        Testers(path: path + "/testers")
    }

    public struct Testers {
        /// Path: `/v0.1/orgs/{org_name}/testers`
        public let path: String

        /// Returns a unique list of users including the whole organization members plus testers in any shared group of that org
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The full name of the tester. Might for example be first and last name
            public var displayName: String?
            /// The unique name that is used to identify the tester.
            public var name: String
            /// The email address of the tester
            public var email: String

            public init(displayName: String? = nil, name: String, email: String) {
                self.displayName = displayName
                self.name = name
                self.email = email
            }

            private enum CodingKeys: String, CodingKey {
                case displayName = "display_name"
                case name
                case email
            }
        }
    }
}

extension Paths.Orgs.WithOrgName.Teams.WithTeamName.Users {
    public func userName(_ userName: String) -> WithUserName {
        WithUserName(path: "\(path)/\(userName)")
    }

    public struct WithUserName {
        /// Path: `/v0.1/orgs/{org_name}/teams/{team_name}/users/{user_name}`
        public let path: String

        /// Removes a user from a team that is owned by an organization
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrgName.Teams.WithTeamName {
    public var users: Users {
        Users(path: path + "/users")
    }

    public struct Users {
        /// Path: `/v0.1/orgs/{org_name}/teams/{team_name}/users`
        public let path: String

        /// Returns the users of a team which is owned by an organization
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Adds a new user to a team that is owned by an organization
        public func post(userEmail: String) -> Request<[String: AnyJSON]> {
            .post(path, body: ["user_email": userEmail])
        }
    }
}

extension Paths.Orgs.WithOrgName.Teams.WithTeamName.Apps {
    public func appName(_ appName: String) -> WithAppName {
        WithAppName(path: "\(path)/\(appName)")
    }

    public struct WithAppName {
        /// Path: `/v0.1/orgs/{org_name}/teams/{team_name}/apps/{app_name}`
        public let path: String

        /// Updates the permissions the team has to the app
        public func patch(permissions: [PatchRequest.Permission]) -> Request<[String: AnyJSON]> {
            .patch(path, body: PatchRequest(permissions: permissions))
        }

        public struct PatchRequest: Encodable {
            /// The permissions all members of the team have on the app
            public var permissions: [Permission]

            public enum Permission: String, Codable, CaseIterable {
                case manager
                case developer
                case viewer
            }

            public init(permissions: [Permission]) {
                self.permissions = permissions
            }
        }

        /// Removes an app from a team
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrgName.Teams.WithTeamName {
    public var apps: Apps {
        Apps(path: path + "/apps")
    }

    public struct Apps {
        /// Path: `/v0.1/orgs/{org_name}/teams/{team_name}/apps`
        public let path: String

        /// Returns the apps a team has access to
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            public var a: A
            /// The permissions the team has for the app
            public var teamPermissions: [TeamPermission]?

            public struct A: Decodable {
                /// The unique ID (UUID) of the app
                public var id: String
                /// The description of the app
                public var description: String?
                /// The display name of the app
                public var displayName: String
                /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
                public var releaseType: String?
                /// The string representation of the URL pointing to the app's icon
                public var iconURL: String?
                /// The string representation of the source of the app's icon
                public var iconSource: String?
                /// The name of the app used in URLs
                public var name: String
                /// The OS the app will be running on
                public var os: Os
                /// The information about the app's owner
                public var owner: Owner
                /// A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics
                public var appSecret: String?
                public var azureSubscription: AzureSubscription?
                /// The platform of the app
                public var platform: Platform?
                /// The creation origin of this app
                public var origin: Origin?
                /// The created date of this app
                public var createdAt: String?
                /// The last updated date of this app
                public var updatedAt: String?
                /// The permissions of the calling user
                public var memberPermissions: [MemberPermission]?

                /// The OS the app will be running on
                public enum Os: String, Codable, CaseIterable {
                    case android = "Android"
                    case iOS
                    case macOS
                    case tizen = "Tizen"
                    case tvOS
                    case windows = "Windows"
                    case linux = "Linux"
                    case custom = "Custom"
                }

                /// The information about the app's owner
                public struct Owner: Decodable {
                    /// The unique id (UUID) of the owner
                    public var id: String
                    /// The avatar URL of the owner
                    public var avatarURL: String?
                    /// The owner's display name
                    public var displayName: String
                    /// The owner's email address
                    public var email: String?
                    /// The unique name that used to identify the owner
                    public var name: String
                    /// The owner type. Can either be 'org' or 'user'
                    public var type: `Type`

                    /// The owner type. Can either be 'org' or 'user'
                    public enum `Type`: String, Codable, CaseIterable {
                        case org
                        case user
                    }

                    public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
                        self.id = id
                        self.avatarURL = avatarURL
                        self.displayName = displayName
                        self.email = email
                        self.name = name
                        self.type = type
                    }

                    private enum CodingKeys: String, CodingKey {
                        case id
                        case avatarURL = "avatar_url"
                        case displayName = "display_name"
                        case email
                        case name
                        case type
                    }
                }

                public struct AzureSubscription: Decodable {
                    /// The azure subscription id
                    public var subscriptionID: String
                    /// The tenant id of the azure subscription belongs to
                    public var tenantID: String
                    /// The name of the azure subscription
                    public var subscriptionName: String
                    /// If the subscription is used for billing
                    public var isBilling: Bool?
                    /// If the subscription can be used for billing
                    public var isBillable: Bool?
                    /// If the subscription is internal Microsoft subscription
                    public var isMicrosoftInternal: Bool?

                    public init(subscriptionID: String, tenantID: String, subscriptionName: String, isBilling: Bool? = nil, isBillable: Bool? = nil, isMicrosoftInternal: Bool? = nil) {
                        self.subscriptionID = subscriptionID
                        self.tenantID = tenantID
                        self.subscriptionName = subscriptionName
                        self.isBilling = isBilling
                        self.isBillable = isBillable
                        self.isMicrosoftInternal = isMicrosoftInternal
                    }

                    private enum CodingKeys: String, CodingKey {
                        case subscriptionID = "subscription_id"
                        case tenantID = "tenant_id"
                        case subscriptionName = "subscription_name"
                        case isBilling = "is_billing"
                        case isBillable = "is_billable"
                        case isMicrosoftInternal = "is_microsoft_internal"
                    }
                }

                /// The platform of the app
                public enum Platform: String, Codable, CaseIterable {
                    case java = "Java"
                    case objectiveCSwift = "Objective-C-Swift"
                    case uwp = "UWP"
                    case cordova = "Cordova"
                    case reactNative = "React-Native"
                    case unity = "Unity"
                    case electron = "Electron"
                    case xamarin = "Xamarin"
                    case wpf = "WPF"
                    case winForms = "WinForms"
                    case unknown = "Unknown"
                    case custom = "Custom"
                }

                /// The creation origin of this app
                public enum Origin: String, Codable, CaseIterable {
                    case appcenter
                    case hockeyapp
                    case codepush
                }

                public enum MemberPermission: String, Codable, CaseIterable {
                    case manager
                    case developer
                    case viewer
                    case tester
                }

                public init(id: String, description: String? = nil, displayName: String, releaseType: String? = nil, iconURL: String? = nil, iconSource: String? = nil, name: String, os: Os, owner: Owner, appSecret: String? = nil, azureSubscription: AzureSubscription? = nil, platform: Platform? = nil, origin: Origin? = nil, createdAt: String? = nil, updatedAt: String? = nil, memberPermissions: [MemberPermission]? = nil) {
                    self.id = id
                    self.description = description
                    self.displayName = displayName
                    self.releaseType = releaseType
                    self.iconURL = iconURL
                    self.iconSource = iconSource
                    self.name = name
                    self.os = os
                    self.owner = owner
                    self.appSecret = appSecret
                    self.azureSubscription = azureSubscription
                    self.platform = platform
                    self.origin = origin
                    self.createdAt = createdAt
                    self.updatedAt = updatedAt
                    self.memberPermissions = memberPermissions
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.id = try values.decode(String.self, forKey: "id")
                    self.description = try values.decodeIfPresent(String.self, forKey: "description")
                    self.displayName = try values.decode(String.self, forKey: "display_name")
                    self.releaseType = try values.decodeIfPresent(String.self, forKey: "release_type")
                    self.iconURL = try values.decodeIfPresent(String.self, forKey: "icon_url")
                    self.iconSource = try values.decodeIfPresent(String.self, forKey: "icon_source")
                    self.name = try values.decode(String.self, forKey: "name")
                    self.os = try Os(from: decoder)
                    self.owner = try Owner(from: decoder)
                    self.appSecret = try values.decodeIfPresent(String.self, forKey: "app_secret")
                    self.azureSubscription = try AzureSubscription(from: decoder)
                    self.platform = try Platform(from: decoder)
                    self.origin = try Origin(from: decoder)
                    self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
                    self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
                    self.memberPermissions = try values.decodeIfPresent([MemberPermission].self, forKey: "member_permissions")
                }
            }

            public enum TeamPermission: String, Codable, CaseIterable {
                case manager
                case developer
                case viewer
            }

            public init(a: A, teamPermissions: [TeamPermission]? = nil) {
                self.a = a
                self.teamPermissions = teamPermissions
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.a = try A(from: decoder)
                self.teamPermissions = try values.decodeIfPresent([TeamPermission].self, forKey: "team_permissions")
            }
        }

        /// Adds an app to a team
        public func post(name: String) -> Request<[String: AnyJSON]> {
            .post(path, body: ["name": name])
        }
    }
}

extension Paths.Orgs.WithOrgName.Teams {
    public func teamName(_ teamName: String) -> WithTeamName {
        WithTeamName(path: "\(path)/\(teamName)")
    }

    public struct WithTeamName {
        /// Path: `/v0.1/orgs/{org_name}/teams/{team_name}`
        public let path: String

        /// Returns the details of a single team
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Updates a single team
        public func patch(displayName: String) -> Request<[String: AnyJSON]> {
            .patch(path, body: ["display_name": displayName])
        }

        /// Deletes a single team
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrgName {
    public var teams: Teams {
        Teams(path: path + "/teams")
    }

    public struct Teams {
        /// Path: `/v0.1/orgs/{org_name}/teams`
        public let path: String

        /// Returns the list of all teams in this org
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The internal unique id (UUID) of the team.
            public var id: String
            /// The name of the team
            public var name: String
            /// The display name of the team
            public var displayName: String
            /// The description of the team
            public var description: String?

            public init(id: String, name: String, displayName: String, description: String? = nil) {
                self.id = id
                self.name = name
                self.displayName = displayName
                self.description = description
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case name
                case displayName = "display_name"
                case description
            }
        }

        /// Creates a team and returns it
        public func post(_ body: PostRequest) -> Request<[PostResponseItem]> {
            .post(path, body: body)
        }

        public struct PostResponseItem: Decodable {
            /// The internal unique id (UUID) of the team.
            public var id: String
            /// The name of the team
            public var name: String
            /// The display name of the team
            public var displayName: String
            /// The description of the team
            public var description: String?

            public init(id: String, name: String, displayName: String, description: String? = nil) {
                self.id = id
                self.name = name
                self.displayName = displayName
                self.description = description
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case name
                case displayName = "display_name"
                case description
            }
        }

        public struct PostRequest: Encodable {
            /// The display name of the team
            public var displayName: String
            /// The name of the team
            public var name: String?
            /// The description of the team
            public var description: String?

            public init(displayName: String, name: String? = nil, description: String? = nil) {
                self.displayName = displayName
                self.name = name
                self.description = description
            }

            private enum CodingKeys: String, CodingKey {
                case displayName = "display_name"
                case name
                case description
            }
        }
    }
}

extension Paths.Orgs.WithOrgName.Invitations.WithEmail {
    public var revoke: Revoke {
        Revoke(path: path + "/revoke")
    }

    public struct Revoke {
        /// Path: `/v0.1/orgs/{org_name}/invitations/{email}/revoke`
        public let path: String

        /// Removes a user's invitation to an organization
        public func post(_ body: [String: AnyJSON]? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Orgs.WithOrgName.Invitations.WithEmail {
    public var resend: Resend {
        Resend(path: path + "/resend")
    }

    public struct Resend {
        /// Path: `/v0.1/orgs/{org_name}/invitations/{email}/resend`
        public let path: String

        /// Cancels an existing organization invitation for the user and sends a new one
        public func post(role: PostRequest.Role? = nil) -> Request<Void> {
            .post(path, body: PostRequest(role: role))
        }

        public struct PostRequest: Encodable {
            /// The role of the user to be added
            public var role: Role?

            /// The role of the user to be added
            public enum Role: String, Codable, CaseIterable {
                case admin
                case collaborator
                case member
            }

            public init(role: Role? = nil) {
                self.role = role
            }
        }
    }
}

extension Paths.Orgs.WithOrgName.Invitations {
    public func email(_ email: String) -> WithEmail {
        WithEmail(path: "\(path)/\(email)")
    }

    public struct WithEmail {
        /// Path: `/v0.1/orgs/{org_name}/invitations/{email}`
        public let path: String

        /// Allows the role of an invited user to be changed
        public func patch(role: PatchRequest.Role? = nil) -> Request<Void> {
            .patch(path, body: PatchRequest(role: role))
        }

        public struct PatchRequest: Encodable {
            /// The user's role in the organizatiion
            public var role: Role?

            /// The user's role in the organizatiion
            public enum Role: String, Codable, CaseIterable {
                case admin
                case collaborator
                case member
            }

            public init(role: Role? = nil) {
                self.role = role
            }
        }
    }
}

extension Paths.Orgs.WithOrgName {
    public var invitations: Invitations {
        Invitations(path: path + "/invitations")
    }

    public struct Invitations {
        /// Path: `/v0.1/orgs/{org_name}/invitations`
        public let path: String

        /// Gets the pending invitations for the organization
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The unique ID (UUID) of the invitation
            public var id: String
            /// The email address of the invited user
            public var email: String
            /// The role assigned to the invited user
            public var role: String

            public init(id: String, email: String, role: String) {
                self.id = id
                self.email = email
                self.role = role
            }
        }

        /// Invites a new or existing user to an organization
        public func post(_ body: PostRequest) -> Request<Void> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The user's email address
            public var userEmail: String
            /// The user's role
            public var role: Role?

            /// The user's role
            public enum Role: String, Codable, CaseIterable {
                case admin
                case collaborator
                case member
            }

            public init(userEmail: String, role: Role? = nil) {
                self.userEmail = userEmail
                self.role = role
            }

            private enum CodingKeys: String, CodingKey {
                case userEmail = "user_email"
                case role
            }
        }

        /// Removes a user's invitation to an organization
        public func delete(userEmail: String) -> Request<Void> {
            .delete(path, body: ["user_email": userEmail])
        }
    }
}

extension Paths.Orgs.WithOrgName {
    public var distributionGroupsDetails: DistributionGroupsDetails {
        DistributionGroupsDetails(path: path + "/distribution_groups_details")
    }

    public struct DistributionGroupsDetails {
        /// Path: `/v0.1/orgs/{org_name}/distribution_groups_details`
        public let path: String

        /// Returns a list of distribution groups with details for an organization
        public func get(appsLimit: Double? = nil) -> Request<[GetResponseItem]> {
            .get(path, query: makeGetQuery(appsLimit))
        }

        public struct GetResponseItem: Decodable {
            /// The unique ID of the distribution group
            public var id: String
            /// The name of the distribution group used in URLs
            public var name: String
            /// The name of the distribution group
            public var displayName: String?
            /// The creation origin of this distribution group
            public var origin: Origin
            /// Whether the distribution group is public
            public var isPublic: Bool
            /// The count of apps associated with this distribution group
            public var totalAppsCount: Double?
            /// The count of users in the distribution group
            public var totalUsersCount: Double?
            /// The apps associated with the distribution group
            public var apps: [App]?

            /// The creation origin of this distribution group
            public enum Origin: String, Codable, CaseIterable {
                case appcenter
                case hockeyapp
            }

            public struct App: Decodable {
                /// The unique ID (UUID) of the app
                public var id: String
                /// The description of the app
                public var description: String?
                /// The display name of the app
                public var displayName: String
                /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
                public var releaseType: String?
                /// The string representation of the URL pointing to the app's icon
                public var iconURL: String?
                /// The string representation of the source of the app's icon
                public var iconSource: String?
                /// The name of the app used in URLs
                public var name: String
                /// The OS the app will be running on
                public var os: Os
                /// The information about the app's owner
                public var owner: Owner
                /// A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics
                public var appSecret: String?
                public var azureSubscription: AzureSubscription?
                /// The platform of the app
                public var platform: Platform?
                /// The creation origin of this app
                public var origin: Origin?
                /// The created date of this app
                public var createdAt: String?
                /// The last updated date of this app
                public var updatedAt: String?
                /// The permissions of the calling user
                public var memberPermissions: [MemberPermission]?

                /// The OS the app will be running on
                public enum Os: String, Codable, CaseIterable {
                    case android = "Android"
                    case iOS
                    case macOS
                    case tizen = "Tizen"
                    case tvOS
                    case windows = "Windows"
                    case linux = "Linux"
                    case custom = "Custom"
                }

                /// The information about the app's owner
                public struct Owner: Decodable {
                    /// The unique id (UUID) of the owner
                    public var id: String
                    /// The avatar URL of the owner
                    public var avatarURL: String?
                    /// The owner's display name
                    public var displayName: String
                    /// The owner's email address
                    public var email: String?
                    /// The unique name that used to identify the owner
                    public var name: String
                    /// The owner type. Can either be 'org' or 'user'
                    public var type: `Type`

                    /// The owner type. Can either be 'org' or 'user'
                    public enum `Type`: String, Codable, CaseIterable {
                        case org
                        case user
                    }

                    public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
                        self.id = id
                        self.avatarURL = avatarURL
                        self.displayName = displayName
                        self.email = email
                        self.name = name
                        self.type = type
                    }

                    private enum CodingKeys: String, CodingKey {
                        case id
                        case avatarURL = "avatar_url"
                        case displayName = "display_name"
                        case email
                        case name
                        case type
                    }
                }

                public struct AzureSubscription: Decodable {
                    /// The azure subscription id
                    public var subscriptionID: String
                    /// The tenant id of the azure subscription belongs to
                    public var tenantID: String
                    /// The name of the azure subscription
                    public var subscriptionName: String
                    /// If the subscription is used for billing
                    public var isBilling: Bool?
                    /// If the subscription can be used for billing
                    public var isBillable: Bool?
                    /// If the subscription is internal Microsoft subscription
                    public var isMicrosoftInternal: Bool?

                    public init(subscriptionID: String, tenantID: String, subscriptionName: String, isBilling: Bool? = nil, isBillable: Bool? = nil, isMicrosoftInternal: Bool? = nil) {
                        self.subscriptionID = subscriptionID
                        self.tenantID = tenantID
                        self.subscriptionName = subscriptionName
                        self.isBilling = isBilling
                        self.isBillable = isBillable
                        self.isMicrosoftInternal = isMicrosoftInternal
                    }

                    private enum CodingKeys: String, CodingKey {
                        case subscriptionID = "subscription_id"
                        case tenantID = "tenant_id"
                        case subscriptionName = "subscription_name"
                        case isBilling = "is_billing"
                        case isBillable = "is_billable"
                        case isMicrosoftInternal = "is_microsoft_internal"
                    }
                }

                /// The platform of the app
                public enum Platform: String, Codable, CaseIterable {
                    case java = "Java"
                    case objectiveCSwift = "Objective-C-Swift"
                    case uwp = "UWP"
                    case cordova = "Cordova"
                    case reactNative = "React-Native"
                    case unity = "Unity"
                    case electron = "Electron"
                    case xamarin = "Xamarin"
                    case wpf = "WPF"
                    case winForms = "WinForms"
                    case unknown = "Unknown"
                    case custom = "Custom"
                }

                /// The creation origin of this app
                public enum Origin: String, Codable, CaseIterable {
                    case appcenter
                    case hockeyapp
                    case codepush
                }

                public enum MemberPermission: String, Codable, CaseIterable {
                    case manager
                    case developer
                    case viewer
                    case tester
                }

                public init(id: String, description: String? = nil, displayName: String, releaseType: String? = nil, iconURL: String? = nil, iconSource: String? = nil, name: String, os: Os, owner: Owner, appSecret: String? = nil, azureSubscription: AzureSubscription? = nil, platform: Platform? = nil, origin: Origin? = nil, createdAt: String? = nil, updatedAt: String? = nil, memberPermissions: [MemberPermission]? = nil) {
                    self.id = id
                    self.description = description
                    self.displayName = displayName
                    self.releaseType = releaseType
                    self.iconURL = iconURL
                    self.iconSource = iconSource
                    self.name = name
                    self.os = os
                    self.owner = owner
                    self.appSecret = appSecret
                    self.azureSubscription = azureSubscription
                    self.platform = platform
                    self.origin = origin
                    self.createdAt = createdAt
                    self.updatedAt = updatedAt
                    self.memberPermissions = memberPermissions
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.id = try values.decode(String.self, forKey: "id")
                    self.description = try values.decodeIfPresent(String.self, forKey: "description")
                    self.displayName = try values.decode(String.self, forKey: "display_name")
                    self.releaseType = try values.decodeIfPresent(String.self, forKey: "release_type")
                    self.iconURL = try values.decodeIfPresent(String.self, forKey: "icon_url")
                    self.iconSource = try values.decodeIfPresent(String.self, forKey: "icon_source")
                    self.name = try values.decode(String.self, forKey: "name")
                    self.os = try Os(from: decoder)
                    self.owner = try Owner(from: decoder)
                    self.appSecret = try values.decodeIfPresent(String.self, forKey: "app_secret")
                    self.azureSubscription = try AzureSubscription(from: decoder)
                    self.platform = try Platform(from: decoder)
                    self.origin = try Origin(from: decoder)
                    self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
                    self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
                    self.memberPermissions = try values.decodeIfPresent([MemberPermission].self, forKey: "member_permissions")
                }
            }

            public init(id: String, name: String, displayName: String? = nil, origin: Origin, isPublic: Bool, totalAppsCount: Double? = nil, totalUsersCount: Double? = nil, apps: [App]? = nil) {
                self.id = id
                self.name = name
                self.displayName = displayName
                self.origin = origin
                self.isPublic = isPublic
                self.totalAppsCount = totalAppsCount
                self.totalUsersCount = totalUsersCount
                self.apps = apps
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decode(String.self, forKey: "id")
                self.name = try values.decode(String.self, forKey: "name")
                self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
                self.origin = try Origin(from: decoder)
                self.isPublic = try values.decode(Bool.self, forKey: "is_public")
                self.totalAppsCount = try values.decodeIfPresent(Double.self, forKey: "total_apps_count")
                self.totalUsersCount = try values.decodeIfPresent(Double.self, forKey: "total_users_count")
                self.apps = try values.decodeIfPresent([App].self, forKey: "apps")
            }
        }

        private func makeGetQuery(_ appsLimit: Double?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(appsLimit, forKey: "apps_limit")
            return encoder.items
        }
    }
}

extension Paths.Orgs.WithOrgName.DistributionGroups.WithDistributionGroupName {
    public var resendInvite: ResendInvite {
        ResendInvite(path: path + "/resend_invite")
    }

    public struct ResendInvite {
        /// Path: `/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/resend_invite`
        public let path: String

        /// Resend shared distribution group invite notification to previously invited testers
        public func post(userEmails: [String]? = nil) -> Request<Void> {
            .post(path, body: ["user_emails": userEmails])
        }
    }
}

extension Paths.Orgs.WithOrgName.DistributionGroups.WithDistributionGroupName.Members {
    public var bulkDelete: BulkDelete {
        BulkDelete(path: path + "/bulk_delete")
    }

    public struct BulkDelete {
        /// Path: `/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/members/bulk_delete`
        public let path: String

        /// Delete testers from distribution group in an org
        public func post(userEmails: [String]? = nil) -> Request<Void> {
            .post(path, body: ["user_emails": userEmails])
        }
    }
}

extension Paths.Orgs.WithOrgName.DistributionGroups.WithDistributionGroupName {
    public var members: Members {
        Members(path: path + "/members")
    }

    public struct Members {
        /// Path: `/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/members`
        public let path: String

        /// Returns a list of member in the distribution group specified
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The unique id (UUID) of the user
            public var id: String?
            /// The avatar URL of the user
            public var avatarURL: String?
            /// User is required to send an old password in order to change the password.
            public var canChangePassword: Bool?
            /// The full name of the user. Might for example be first and last name
            public var displayName: String?
            /// The email address of the user
            public var email: String
            /// Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".
            public var isInvitePending: Bool?
            /// The unique name that is used to identify the user.
            public var name: String?

            public init(id: String? = nil, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String? = nil, email: String, isInvitePending: Bool? = nil, name: String? = nil) {
                self.id = id
                self.avatarURL = avatarURL
                self.canChangePassword = canChangePassword
                self.displayName = displayName
                self.email = email
                self.isInvitePending = isInvitePending
                self.name = name
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case avatarURL = "avatar_url"
                case canChangePassword = "can_change_password"
                case displayName = "display_name"
                case email
                case isInvitePending = "invite_pending"
                case name
            }
        }

        /// Accepts an array of user email addresses to get added to the specified group
        public func post(userEmails: [String]? = nil) -> Request<[PostResponseItem]> {
            .post(path, body: ["user_emails": userEmails])
        }

        public struct PostResponseItem: Decodable {
            /// The code of the result
            public var code: String?
            /// Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".
            public var isInvitePending: Bool?
            /// The message of the result
            public var message: String?
            /// The status code of the result
            public var status: Int
            /// The email of the user
            public var userEmail: String?

            public init(code: String? = nil, isInvitePending: Bool? = nil, message: String? = nil, status: Int, userEmail: String? = nil) {
                self.code = code
                self.isInvitePending = isInvitePending
                self.message = message
                self.status = status
                self.userEmail = userEmail
            }

            private enum CodingKeys: String, CodingKey {
                case code
                case isInvitePending = "invite_pending"
                case message
                case status
                case userEmail = "user_email"
            }
        }
    }
}

extension Paths.Orgs.WithOrgName.DistributionGroups.WithDistributionGroupName.Apps {
    public var bulkDelete: BulkDelete {
        BulkDelete(path: path + "/bulk_delete")
    }

    public struct BulkDelete {
        /// Path: `/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/apps/bulk_delete`
        public let path: String

        /// Delete apps from distribution group in an org
        public func post(apps: [PostRequest.App]? = nil) -> Request<Void> {
            .post(path, body: PostRequest(apps: apps))
        }

        public struct PostRequest: Encodable {
            /// The list of apps to delete from the distribution group
            public var apps: [App]?

            public struct App: Encodable {
                /// The name of the app to be deleted from the distribution group
                public var name: String

                public init(name: String) {
                    self.name = name
                }
            }

            public init(apps: [App]? = nil) {
                self.apps = apps
            }
        }
    }
}

extension Paths.Orgs.WithOrgName.DistributionGroups.WithDistributionGroupName {
    public var apps: Apps {
        Apps(path: path + "/apps")
    }

    public struct Apps {
        /// Path: `/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/apps`
        public let path: String

        /// Get apps from a distribution group in an org
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The unique ID (UUID) of the app
            public var id: String
            /// The description of the app
            public var description: String?
            /// The display name of the app
            public var displayName: String
            /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
            public var releaseType: String?
            /// The string representation of the URL pointing to the app's icon
            public var iconURL: String?
            /// The string representation of the source of the app's icon
            public var iconSource: String?
            /// The name of the app used in URLs
            public var name: String
            /// The OS the app will be running on
            public var os: Os
            /// The information about the app's owner
            public var owner: Owner
            /// The platform of the app
            public var platform: String?
            /// The creation origin of this app
            public var origin: String?

            /// The OS the app will be running on
            public enum Os: String, Codable, CaseIterable {
                case android = "Android"
                case iOS
                case macOS
                case tizen = "Tizen"
                case tvOS
                case windows = "Windows"
                case linux = "Linux"
                case custom = "Custom"
            }

            /// The information about the app's owner
            public struct Owner: Decodable {
                /// The unique id (UUID) of the owner
                public var id: String
                /// The avatar URL of the owner
                public var avatarURL: String?
                /// The owner's display name
                public var displayName: String
                /// The owner's email address
                public var email: String?
                /// The unique name that used to identify the owner
                public var name: String
                /// The owner type. Can either be 'org' or 'user'
                public var type: `Type`

                /// The owner type. Can either be 'org' or 'user'
                public enum `Type`: String, Codable, CaseIterable {
                    case org
                    case user
                }

                public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
                    self.id = id
                    self.avatarURL = avatarURL
                    self.displayName = displayName
                    self.email = email
                    self.name = name
                    self.type = type
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case avatarURL = "avatar_url"
                    case displayName = "display_name"
                    case email
                    case name
                    case type
                }
            }

            public init(id: String, description: String? = nil, displayName: String, releaseType: String? = nil, iconURL: String? = nil, iconSource: String? = nil, name: String, os: Os, owner: Owner, platform: String? = nil, origin: String? = nil) {
                self.id = id
                self.description = description
                self.displayName = displayName
                self.releaseType = releaseType
                self.iconURL = iconURL
                self.iconSource = iconSource
                self.name = name
                self.os = os
                self.owner = owner
                self.platform = platform
                self.origin = origin
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decode(String.self, forKey: "id")
                self.description = try values.decodeIfPresent(String.self, forKey: "description")
                self.displayName = try values.decode(String.self, forKey: "display_name")
                self.releaseType = try values.decodeIfPresent(String.self, forKey: "release_type")
                self.iconURL = try values.decodeIfPresent(String.self, forKey: "icon_url")
                self.iconSource = try values.decodeIfPresent(String.self, forKey: "icon_source")
                self.name = try values.decode(String.self, forKey: "name")
                self.os = try Os(from: decoder)
                self.owner = try Owner(from: decoder)
                self.platform = try values.decodeIfPresent(String.self, forKey: "platform")
                self.origin = try values.decodeIfPresent(String.self, forKey: "origin")
            }
        }

        /// Add apps to distribution group in an org
        public func post(apps: [PostRequest.App]? = nil) -> Request<Void> {
            .post(path, body: PostRequest(apps: apps))
        }

        public struct PostRequest: Encodable {
            /// The list of apps to add to distribution group
            public var apps: [App]?

            public struct App: Encodable {
                /// The name of the app to be added to the distribution group
                public var name: String

                public init(name: String) {
                    self.name = name
                }
            }

            public init(apps: [App]? = nil) {
                self.apps = apps
            }
        }
    }
}

extension Paths.Orgs.WithOrgName.DistributionGroups {
    public func distributionGroupName(_ distributionGroupName: String) -> WithDistributionGroupName {
        WithDistributionGroupName(path: "\(path)/\(distributionGroupName)")
    }

    public struct WithDistributionGroupName {
        /// Path: `/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}`
        public let path: String

        /// Returns a single distribution group in org for a given distribution group name
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Update one given distribution group name in an org
        public func patch(_ body: PatchRequest? = nil) -> Request<[String: AnyJSON]> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// The name of the distribution group
            public var name: String?
            /// Whether the distribution group is public
            public var isPublic: Bool?

            public init(name: String? = nil, isPublic: Bool? = nil) {
                self.name = name
                self.isPublic = isPublic
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case isPublic = "is_public"
            }
        }

        /// Deletes a single distribution group from an org with a given distribution group name
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrgName {
    public var distributionGroups: DistributionGroups {
        DistributionGroups(path: path + "/distribution_groups")
    }

    public struct DistributionGroups {
        /// Path: `/v0.1/orgs/{org_name}/distribution_groups`
        public let path: String

        /// Returns a list of distribution groups in the org specified
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The unique ID of the distribution group
            public var id: String
            /// The name of the distribution group used in URLs
            public var name: String
            /// The name of the distribution group
            public var displayName: String?
            /// The creation origin of this distribution group
            public var origin: Origin
            /// Whether the distribution group is public
            public var isPublic: Bool

            /// The creation origin of this distribution group
            public enum Origin: String, Codable, CaseIterable {
                case appcenter
                case hockeyapp
            }

            public init(id: String, name: String, displayName: String? = nil, origin: Origin, isPublic: Bool) {
                self.id = id
                self.name = name
                self.displayName = displayName
                self.origin = origin
                self.isPublic = isPublic
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case name
                case displayName = "display_name"
                case origin
                case isPublic = "is_public"
            }
        }

        /// Creates a disribution goup which can be shared across apps under an organization
        public func post(_ body: PostRequest) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The name of the distribution group
            public var name: String
            /// The display name of the distribution group. If not specified, the name will be used.
            public var displayName: String?

            public init(name: String, displayName: String? = nil) {
                self.name = name
                self.displayName = displayName
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case displayName = "display_name"
            }
        }
    }
}

extension Paths.Orgs.WithOrgName {
    public var azureSubscriptions: AzureSubscriptions {
        AzureSubscriptions(path: path + "/azure_subscriptions")
    }

    public struct AzureSubscriptions {
        /// Path: `/v0.1/orgs/{org_name}/azure_subscriptions`
        public let path: String

        /// Returns a list of azure subscriptions for the organization
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The azure subscription id
            public var subscriptionID: String
            /// The tenant id of the azure subscription belongs to
            public var tenantID: String
            /// The name of the azure subscription
            public var subscriptionName: String
            /// If the subscription is used for billing
            public var isBilling: Bool?
            /// If the subscription can be used for billing
            public var isBillable: Bool?
            /// If the subscription is internal Microsoft subscription
            public var isMicrosoftInternal: Bool?

            public init(subscriptionID: String, tenantID: String, subscriptionName: String, isBilling: Bool? = nil, isBillable: Bool? = nil, isMicrosoftInternal: Bool? = nil) {
                self.subscriptionID = subscriptionID
                self.tenantID = tenantID
                self.subscriptionName = subscriptionName
                self.isBilling = isBilling
                self.isBillable = isBillable
                self.isMicrosoftInternal = isMicrosoftInternal
            }

            private enum CodingKeys: String, CodingKey {
                case subscriptionID = "subscription_id"
                case tenantID = "tenant_id"
                case subscriptionName = "subscription_name"
                case isBilling = "is_billing"
                case isBillable = "is_billable"
                case isMicrosoftInternal = "is_microsoft_internal"
            }
        }
    }
}

extension Paths.Orgs.WithOrgName {
    public var avatar: Avatar {
        Avatar(path: path + "/avatar")
    }

    public struct Avatar {
        /// Path: `/v0.1/orgs/{org_name}/avatar`
        public let path: String

        /// Sets the organization avatar
        public func post(_ body: Data? = nil) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        /// Deletes the uploaded organization avatar
        public var delete: Request<[String: AnyJSON]> {
            .delete(path)
        }
    }
}

extension Paths.Orgs.WithOrgName {
    public var apps: Apps {
        Apps(path: path + "/apps")
    }

    public struct Apps {
        /// Path: `/v0.1/orgs/{org_name}/apps`
        public let path: String

        /// Returns a list of apps for the organization
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The unique ID (UUID) of the app
            public var id: String
            /// The description of the app
            public var description: String?
            /// The display name of the app
            public var displayName: String
            /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
            public var releaseType: String?
            /// The string representation of the URL pointing to the app's icon
            public var iconURL: String?
            /// The string representation of the source of the app's icon
            public var iconSource: String?
            /// The name of the app used in URLs
            public var name: String
            /// The OS the app will be running on
            public var os: Os
            /// The information about the app's owner
            public var owner: Owner
            /// A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics
            public var appSecret: String?
            public var azureSubscription: AzureSubscription?
            /// The platform of the app
            public var platform: Platform?
            /// The creation origin of this app
            public var origin: Origin?
            /// The created date of this app
            public var createdAt: String?
            /// The last updated date of this app
            public var updatedAt: String?
            /// The permissions of the calling user
            public var memberPermissions: [MemberPermission]?

            /// The OS the app will be running on
            public enum Os: String, Codable, CaseIterable {
                case android = "Android"
                case iOS
                case macOS
                case tizen = "Tizen"
                case tvOS
                case windows = "Windows"
                case linux = "Linux"
                case custom = "Custom"
            }

            /// The information about the app's owner
            public struct Owner: Decodable {
                /// The unique id (UUID) of the owner
                public var id: String
                /// The avatar URL of the owner
                public var avatarURL: String?
                /// The owner's display name
                public var displayName: String
                /// The owner's email address
                public var email: String?
                /// The unique name that used to identify the owner
                public var name: String
                /// The owner type. Can either be 'org' or 'user'
                public var type: `Type`

                /// The owner type. Can either be 'org' or 'user'
                public enum `Type`: String, Codable, CaseIterable {
                    case org
                    case user
                }

                public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
                    self.id = id
                    self.avatarURL = avatarURL
                    self.displayName = displayName
                    self.email = email
                    self.name = name
                    self.type = type
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case avatarURL = "avatar_url"
                    case displayName = "display_name"
                    case email
                    case name
                    case type
                }
            }

            public struct AzureSubscription: Decodable {
                /// The azure subscription id
                public var subscriptionID: String
                /// The tenant id of the azure subscription belongs to
                public var tenantID: String
                /// The name of the azure subscription
                public var subscriptionName: String
                /// If the subscription is used for billing
                public var isBilling: Bool?
                /// If the subscription can be used for billing
                public var isBillable: Bool?
                /// If the subscription is internal Microsoft subscription
                public var isMicrosoftInternal: Bool?

                public init(subscriptionID: String, tenantID: String, subscriptionName: String, isBilling: Bool? = nil, isBillable: Bool? = nil, isMicrosoftInternal: Bool? = nil) {
                    self.subscriptionID = subscriptionID
                    self.tenantID = tenantID
                    self.subscriptionName = subscriptionName
                    self.isBilling = isBilling
                    self.isBillable = isBillable
                    self.isMicrosoftInternal = isMicrosoftInternal
                }

                private enum CodingKeys: String, CodingKey {
                    case subscriptionID = "subscription_id"
                    case tenantID = "tenant_id"
                    case subscriptionName = "subscription_name"
                    case isBilling = "is_billing"
                    case isBillable = "is_billable"
                    case isMicrosoftInternal = "is_microsoft_internal"
                }
            }

            /// The platform of the app
            public enum Platform: String, Codable, CaseIterable {
                case java = "Java"
                case objectiveCSwift = "Objective-C-Swift"
                case uwp = "UWP"
                case cordova = "Cordova"
                case reactNative = "React-Native"
                case unity = "Unity"
                case electron = "Electron"
                case xamarin = "Xamarin"
                case wpf = "WPF"
                case winForms = "WinForms"
                case unknown = "Unknown"
                case custom = "Custom"
            }

            /// The creation origin of this app
            public enum Origin: String, Codable, CaseIterable {
                case appcenter
                case hockeyapp
                case codepush
            }

            public enum MemberPermission: String, Codable, CaseIterable {
                case manager
                case developer
                case viewer
                case tester
            }

            public init(id: String, description: String? = nil, displayName: String, releaseType: String? = nil, iconURL: String? = nil, iconSource: String? = nil, name: String, os: Os, owner: Owner, appSecret: String? = nil, azureSubscription: AzureSubscription? = nil, platform: Platform? = nil, origin: Origin? = nil, createdAt: String? = nil, updatedAt: String? = nil, memberPermissions: [MemberPermission]? = nil) {
                self.id = id
                self.description = description
                self.displayName = displayName
                self.releaseType = releaseType
                self.iconURL = iconURL
                self.iconSource = iconSource
                self.name = name
                self.os = os
                self.owner = owner
                self.appSecret = appSecret
                self.azureSubscription = azureSubscription
                self.platform = platform
                self.origin = origin
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.memberPermissions = memberPermissions
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decode(String.self, forKey: "id")
                self.description = try values.decodeIfPresent(String.self, forKey: "description")
                self.displayName = try values.decode(String.self, forKey: "display_name")
                self.releaseType = try values.decodeIfPresent(String.self, forKey: "release_type")
                self.iconURL = try values.decodeIfPresent(String.self, forKey: "icon_url")
                self.iconSource = try values.decodeIfPresent(String.self, forKey: "icon_source")
                self.name = try values.decode(String.self, forKey: "name")
                self.os = try Os(from: decoder)
                self.owner = try Owner(from: decoder)
                self.appSecret = try values.decodeIfPresent(String.self, forKey: "app_secret")
                self.azureSubscription = try AzureSubscription(from: decoder)
                self.platform = try Platform(from: decoder)
                self.origin = try Origin(from: decoder)
                self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
                self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
                self.memberPermissions = try values.decodeIfPresent([MemberPermission].self, forKey: "member_permissions")
            }
        }

        /// Creates a new app for the organization and returns it to the caller
        public func post(_ body: PostRequest) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// A short text describing the app
            public var description: String?
            /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
            public var releaseType: String?
            /// The descriptive name of the app. This can contain any characters
            public var displayName: String
            /// The name of the app used in URLs
            public var name: String?
            /// The OS the app will be running on
            public var os: Os
            /// The platform of the app
            public var platform: Platform

            /// The OS the app will be running on
            public enum Os: String, Codable, CaseIterable {
                case android = "Android"
                case iOS
                case macOS
                case tizen = "Tizen"
                case tvOS
                case windows = "Windows"
                case linux = "Linux"
                case custom = "Custom"
            }

            /// The platform of the app
            public enum Platform: String, Codable, CaseIterable {
                case java = "Java"
                case objectiveCSwift = "Objective-C-Swift"
                case uwp = "UWP"
                case cordova = "Cordova"
                case reactNative = "React-Native"
                case xamarin = "Xamarin"
                case unity = "Unity"
                case electron = "Electron"
                case wpf = "WPF"
                case winForms = "WinForms"
                case custom = "Custom"
            }

            public init(description: String? = nil, releaseType: String? = nil, displayName: String, name: String? = nil, os: Os, platform: Platform) {
                self.description = description
                self.releaseType = releaseType
                self.displayName = displayName
                self.name = name
                self.os = os
                self.platform = platform
            }

            private enum CodingKeys: String, CodingKey {
                case description
                case releaseType = "release_type"
                case displayName = "display_name"
                case name
                case os
                case platform
            }
        }
    }
}

extension Paths.Orgs {
    public func orgName(_ orgName: String) -> WithOrgName {
        WithOrgName(path: "\(path)/\(orgName)")
    }

    public struct WithOrgName {
        /// Path: `/v0.1/orgs/{org_name}`
        public let path: String

        /// Returns the details of a single organization
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Returns a list of organizations the requesting user has access to
        public func patch(_ body: PatchRequest) -> Request<[String: AnyJSON]> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// The full (friendly) name of the organization.
            public var displayName: String?
            /// The name of the organization used in URLs
            public var name: String?

            public init(displayName: String? = nil, name: String? = nil) {
                self.displayName = displayName
                self.name = name
            }

            private enum CodingKeys: String, CodingKey {
                case displayName = "display_name"
                case name
            }
        }

        /// Deletes a single organization
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Orgs {
    public func orgName(_ orgName: String) -> WithOrgName2 {
        WithOrgName2(path: "\(path)/\(orgName)")
    }

    public struct WithOrgName2 {
        /// Path: `/v0.1/orgs/{orgName}`
        public let path: String
    }
}

extension Paths.Orgs.WithOrgName {
    public var billing: Billing {
        Billing(path: path + "/billing")
    }

    public struct Billing {
        /// Path: `/v0.1/orgs/{orgName}/billing`
        public let path: String
    }
}

extension Paths.Orgs.WithOrgName.Billing {
    public var aggregated: Aggregated {
        Aggregated(path: path + "/aggregated")
    }

    public struct Aggregated {
        /// Path: `/v0.1/orgs/{orgName}/billing/aggregated`
        public let path: String

        /// Aggregated Billing Information for a given Organization.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// Aggregated Billing Information for a user or an organization
        public struct GetResponse: Decodable {
            /// Version of the Billing Information schema
            public var version: String?
            /// The ISO 8601 datetime of last modification
            public var timestamp: String?
            /// ID of the user or organization
            public var id: String?
            /// Billing Plans section in the Billing Information
            public var billingPlans: BillingPlans?
            /// Usage section in the Billing Information
            public var usage: Usage?
            /// Unique identifier for the Azure subscription used for billing
            public var azureSubscriptionID: String?
            /// State of the Azure subscription used for billing
            public var azureSubscriptionState: AzureSubscriptionState?

            /// Billing Plans section in the Billing Information
            public struct BillingPlans: Decodable {
                /// Billing Plans for a single service
                public var buildService: BuildService?
                /// Billing Plans for a single service
                public var testService: TestService?

                /// Billing Plans for a single service
                public struct BuildService: Decodable {
                    /// Can customer select trial plan for that service (if it exists)?
                    public var canSelectTrialPlan: Bool?
                    /// Expiration time of the last selected trial plan. Will be null if trial plan was not used.
                    public var lastTrialPlanExpirationTime: String?
                    /// Billing plans for a given period
                    public var currentBillingPeriod: CurrentBillingPeriod?

                    /// Billing plans for a given period
                    public struct CurrentBillingPeriod: Decodable {
                        /// Inclusive start of the period
                        public var startTime: String?
                        /// Exclusive end of the period.
                        public var endTime: String?
                        /// Selection of a billing plan
                        public var byAccount: ByAccount?

                        /// Selection of a billing plan
                        public struct ByAccount: Decodable {
                            /// Number of instances of the billing plan.
                            public var count: Int?
                            /// Billing Plan
                            public var plan: Plan?

                            /// Billing Plan
                            public struct Plan: Decodable {
                                /// The Billing Plan ID
                                public var id: String?
                                /// Version of the Billing Plan schema
                                public var version: String?
                                /// Price of the Billing Plan
                                public var price: Double?
                                /// Service that receives payments for this billing plan.
                                public var paymentSource: PaymentSource?
                                /// Name of the service that the plan applies to.
                                public var service: Service?
                                /// A collection of named numeric values
                                public var limits: [String: Double]?
                                /// Collection of attribute values.
                                public var attributes: [String: [String: AnyJSON]]?
                                public var parentID: String?

                                /// Service that receives payments for this billing plan.
                                public enum PaymentSource: String, Codable, CaseIterable {
                                    case `none` = "None"
                                    case appCenter = "AppCenter"
                                    case gitHub = "GitHub"
                                    case xtc = "Xtc"
                                }

                                /// Name of the service that the plan applies to.
                                public enum Service: String, Codable, CaseIterable {
                                    case build = "Build"
                                    case test = "Test"
                                }

                                public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
                                    self.id = id
                                    self.version = version
                                    self.price = price
                                    self.paymentSource = paymentSource
                                    self.service = service
                                    self.limits = limits
                                    self.attributes = attributes
                                    self.parentID = parentID
                                }

                                private enum CodingKeys: String, CodingKey {
                                    case id
                                    case version
                                    case price
                                    case paymentSource
                                    case service
                                    case limits
                                    case attributes
                                    case parentID = "parentId"
                                }
                            }

                            public init(count: Int? = nil, plan: Plan? = nil) {
                                self.count = count
                                self.plan = plan
                            }
                        }

                        public init(startTime: String? = nil, endTime: String? = nil, byAccount: ByAccount? = nil) {
                            self.startTime = startTime
                            self.endTime = endTime
                            self.byAccount = byAccount
                        }
                    }

                    public init(canSelectTrialPlan: Bool? = nil, lastTrialPlanExpirationTime: String? = nil, currentBillingPeriod: CurrentBillingPeriod? = nil) {
                        self.canSelectTrialPlan = canSelectTrialPlan
                        self.lastTrialPlanExpirationTime = lastTrialPlanExpirationTime
                        self.currentBillingPeriod = currentBillingPeriod
                    }
                }

                /// Billing Plans for a single service
                public struct TestService: Decodable {
                    /// Can customer select trial plan for that service (if it exists)?
                    public var canSelectTrialPlan: Bool?
                    /// Expiration time of the last selected trial plan. Will be null if trial plan was not used.
                    public var lastTrialPlanExpirationTime: String?
                    /// Billing plans for a given period
                    public var currentBillingPeriod: CurrentBillingPeriod?

                    /// Billing plans for a given period
                    public struct CurrentBillingPeriod: Decodable {
                        /// Inclusive start of the period
                        public var startTime: String?
                        /// Exclusive end of the period.
                        public var endTime: String?
                        /// Selection of a billing plan
                        public var byAccount: ByAccount?

                        /// Selection of a billing plan
                        public struct ByAccount: Decodable {
                            /// Number of instances of the billing plan.
                            public var count: Int?
                            /// Billing Plan
                            public var plan: Plan?

                            /// Billing Plan
                            public struct Plan: Decodable {
                                /// The Billing Plan ID
                                public var id: String?
                                /// Version of the Billing Plan schema
                                public var version: String?
                                /// Price of the Billing Plan
                                public var price: Double?
                                /// Service that receives payments for this billing plan.
                                public var paymentSource: PaymentSource?
                                /// Name of the service that the plan applies to.
                                public var service: Service?
                                /// A collection of named numeric values
                                public var limits: [String: Double]?
                                /// Collection of attribute values.
                                public var attributes: [String: [String: AnyJSON]]?
                                public var parentID: String?

                                /// Service that receives payments for this billing plan.
                                public enum PaymentSource: String, Codable, CaseIterable {
                                    case `none` = "None"
                                    case appCenter = "AppCenter"
                                    case gitHub = "GitHub"
                                    case xtc = "Xtc"
                                }

                                /// Name of the service that the plan applies to.
                                public enum Service: String, Codable, CaseIterable {
                                    case build = "Build"
                                    case test = "Test"
                                }

                                public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
                                    self.id = id
                                    self.version = version
                                    self.price = price
                                    self.paymentSource = paymentSource
                                    self.service = service
                                    self.limits = limits
                                    self.attributes = attributes
                                    self.parentID = parentID
                                }

                                private enum CodingKeys: String, CodingKey {
                                    case id
                                    case version
                                    case price
                                    case paymentSource
                                    case service
                                    case limits
                                    case attributes
                                    case parentID = "parentId"
                                }
                            }

                            public init(count: Int? = nil, plan: Plan? = nil) {
                                self.count = count
                                self.plan = plan
                            }
                        }

                        public init(startTime: String? = nil, endTime: String? = nil, byAccount: ByAccount? = nil) {
                            self.startTime = startTime
                            self.endTime = endTime
                            self.byAccount = byAccount
                        }
                    }

                    public init(canSelectTrialPlan: Bool? = nil, lastTrialPlanExpirationTime: String? = nil, currentBillingPeriod: CurrentBillingPeriod? = nil) {
                        self.canSelectTrialPlan = canSelectTrialPlan
                        self.lastTrialPlanExpirationTime = lastTrialPlanExpirationTime
                        self.currentBillingPeriod = currentBillingPeriod
                    }
                }

                public init(buildService: BuildService? = nil, testService: TestService? = nil) {
                    self.buildService = buildService
                    self.testService = testService
                }
            }

            /// Usage section in the Billing Information
            public struct Usage: Decodable {
                /// Resource usage for a single Mobile Center service
                public var buildService: BuildService?
                /// Resource usage for a single Mobile Center service
                public var testService: TestService?

                /// Resource usage for a single Mobile Center service
                public struct BuildService: Decodable {
                    /// Usage for a single period
                    public var currentUsagePeriod: CurrentUsagePeriod?

                    /// Usage for a single period
                    public struct CurrentUsagePeriod: Decodable {
                        /// Inclusive start time of the usage period
                        public var startTime: String?
                        /// Exclusive end time of the usage period.
                        public var endTime: String?
                        /// A collection of named numeric values
                        public var byAccount: [String: Double]?
                        /// A collection of  named numeric values grouped by app
                        public var byApp: [String: [String: Double]]?

                        public init(startTime: String? = nil, endTime: String? = nil, byAccount: [String: Double]? = nil, byApp: [String: [String: Double]]? = nil) {
                            self.startTime = startTime
                            self.endTime = endTime
                            self.byAccount = byAccount
                            self.byApp = byApp
                        }
                    }

                    public init(currentUsagePeriod: CurrentUsagePeriod? = nil) {
                        self.currentUsagePeriod = currentUsagePeriod
                    }
                }

                /// Resource usage for a single Mobile Center service
                public struct TestService: Decodable {
                    /// Usage for a single period
                    public var currentUsagePeriod: CurrentUsagePeriod?

                    /// Usage for a single period
                    public struct CurrentUsagePeriod: Decodable {
                        /// Inclusive start time of the usage period
                        public var startTime: String?
                        /// Exclusive end time of the usage period.
                        public var endTime: String?
                        /// A collection of named numeric values
                        public var byAccount: [String: Double]?
                        /// A collection of  named numeric values grouped by app
                        public var byApp: [String: [String: Double]]?

                        public init(startTime: String? = nil, endTime: String? = nil, byAccount: [String: Double]? = nil, byApp: [String: [String: Double]]? = nil) {
                            self.startTime = startTime
                            self.endTime = endTime
                            self.byAccount = byAccount
                            self.byApp = byApp
                        }
                    }

                    public init(currentUsagePeriod: CurrentUsagePeriod? = nil) {
                        self.currentUsagePeriod = currentUsagePeriod
                    }
                }

                public init(buildService: BuildService? = nil, testService: TestService? = nil) {
                    self.buildService = buildService
                    self.testService = testService
                }
            }

            /// State of the Azure subscription used for billing
            public enum AzureSubscriptionState: String, Codable, CaseIterable {
                case enabled = "Enabled"
                case disabled = "Disabled"
                case notSet = "NotSet"
            }

            public init(version: String? = nil, timestamp: String? = nil, id: String? = nil, billingPlans: BillingPlans? = nil, usage: Usage? = nil, azureSubscriptionID: String? = nil, azureSubscriptionState: AzureSubscriptionState? = nil) {
                self.version = version
                self.timestamp = timestamp
                self.id = id
                self.billingPlans = billingPlans
                self.usage = usage
                self.azureSubscriptionID = azureSubscriptionID
                self.azureSubscriptionState = azureSubscriptionState
            }

            private enum CodingKeys: String, CodingKey {
                case version
                case timestamp
                case id
                case billingPlans
                case usage
                case azureSubscriptionID = "azureSubscriptionId"
                case azureSubscriptionState
            }
        }

        public struct GetParameters {
            public var service: Service?
            public var period: Period?
            public var isShowOriginalPlans: Bool?

            public enum Service: String, Codable, CaseIterable {
                case test = "Test"
                case build = "Build"
            }

            public enum Period: String, Codable, CaseIterable {
                case previous = "Previous"
                case current = "Current"
                case next = "Next"
            }

            public init(service: Service? = nil, period: Period? = nil, isShowOriginalPlans: Bool? = nil) {
                self.service = service
                self.period = period
                self.isShowOriginalPlans = isShowOriginalPlans
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(service, forKey: "service")
                encoder.encode(period, forKey: "period")
                encoder.encode(isShowOriginalPlans, forKey: "showOriginalPlans")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var orgs: Orgs {
        Orgs(path: "/v0.1/orgs")
    }

    public struct Orgs {
        /// Path: `/v0.1/orgs`
        public let path: String

        /// Returns a list of organizations the requesting user has access to
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The display name of the organization
            public var displayName: String
            /// The slug name of the organization
            public var name: String
            /// The creation origin of this organization
            public var origin: Origin

            /// The creation origin of this organization
            public enum Origin: String, Codable, CaseIterable {
                case appcenter
                case hockeyapp
            }

            public init(displayName: String, name: String, origin: Origin) {
                self.displayName = displayName
                self.name = name
                self.origin = origin
            }

            private enum CodingKeys: String, CodingKey {
                case displayName = "display_name"
                case name
                case origin
            }
        }

        /// Creates a new organization and returns it to the caller
        public func post(_ body: PostRequest) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The display name of the organization
            public var displayName: String?
            /// The name of the organization used in URLs
            public var name: String?

            public init(displayName: String? = nil, name: String? = nil) {
                self.displayName = displayName
                self.name = name
            }

            private enum CodingKeys: String, CodingKey {
                case displayName = "display_name"
                case name
            }
        }
    }
}

extension Paths {
    public static var legacy: Legacy {
        Legacy(path: "/v0.1/legacy")
    }

    public struct Legacy {
        /// Path: `/v0.1/legacy`
        public let path: String
    }
}

extension Paths.Legacy {
    public var updateCheck: UpdateCheck {
        UpdateCheck(path: path + "/updateCheck")
    }

    public struct UpdateCheck {
        /// Path: `/v0.1/legacy/updateCheck`
        public let path: String

        /// Check for updates
        public func get(parameters: GetParameters? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var deploymentKey: String?
            public var appVersion: String?
            public var packageHash: String?
            public var label: String?
            public var clientUniqueID: String?
            public var isCompanion: String?

            public init(deploymentKey: String? = nil, appVersion: String? = nil, packageHash: String? = nil, label: String? = nil, clientUniqueID: String? = nil, isCompanion: String? = nil) {
                self.deploymentKey = deploymentKey
                self.appVersion = appVersion
                self.packageHash = packageHash
                self.label = label
                self.clientUniqueID = clientUniqueID
                self.isCompanion = isCompanion
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(deploymentKey, forKey: "deploymentKey")
                encoder.encode(appVersion, forKey: "appVersion")
                encoder.encode(packageHash, forKey: "packageHash")
                encoder.encode(label, forKey: "label")
                encoder.encode(clientUniqueID, forKey: "clientUniqueId")
                encoder.encode(isCompanion, forKey: "isCompanion")
                return encoder.items
            }
        }
    }
}

extension Paths.Legacy {
    public var reportStatus: ReportStatus {
        ReportStatus(path: path + "/reportStatus")
    }

    public struct ReportStatus {
        /// Path: `/v0.1/legacy/reportStatus`
        public let path: String
    }
}

extension Paths.Legacy.ReportStatus {
    public var download: Download {
        Download(path: path + "/download")
    }

    public struct Download {
        /// Path: `/v0.1/legacy/reportStatus/download`
        public let path: String

        /// Report download of specified release
        public func post(_ body: PostRequest) -> Request<Void> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            public var deploymentKey: String?
            public var label: String?
            public var appVersion: String?
            public var previousDeploymentKey: String?
            public var previousLabelOrAppVersion: String?
            public var status: String?
            public var clientUniqueID: String?

            public init(deploymentKey: String? = nil, label: String? = nil, appVersion: String? = nil, previousDeploymentKey: String? = nil, previousLabelOrAppVersion: String? = nil, status: String? = nil, clientUniqueID: String? = nil) {
                self.deploymentKey = deploymentKey
                self.label = label
                self.appVersion = appVersion
                self.previousDeploymentKey = previousDeploymentKey
                self.previousLabelOrAppVersion = previousLabelOrAppVersion
                self.status = status
                self.clientUniqueID = clientUniqueID
            }

            private enum CodingKeys: String, CodingKey {
                case deploymentKey
                case label
                case appVersion
                case previousDeploymentKey
                case previousLabelOrAppVersion
                case status
                case clientUniqueID = "clientUniqueId"
            }
        }
    }
}

extension Paths.Legacy.ReportStatus {
    public var deploy: Deploy {
        Deploy(path: path + "/deploy")
    }

    public struct Deploy {
        /// Path: `/v0.1/legacy/reportStatus/deploy`
        public let path: String

        /// Report deploy of specified release
        public func post(_ body: PostRequest) -> Request<Void> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            public var deploymentKey: String?
            public var label: String?
            public var appVersion: String?
            public var previousDeploymentKey: String?
            public var previousLabelOrAppVersion: String?
            public var status: String?
            public var clientUniqueID: String?

            public init(deploymentKey: String? = nil, label: String? = nil, appVersion: String? = nil, previousDeploymentKey: String? = nil, previousLabelOrAppVersion: String? = nil, status: String? = nil, clientUniqueID: String? = nil) {
                self.deploymentKey = deploymentKey
                self.label = label
                self.appVersion = appVersion
                self.previousDeploymentKey = previousDeploymentKey
                self.previousLabelOrAppVersion = previousLabelOrAppVersion
                self.status = status
                self.clientUniqueID = clientUniqueID
            }

            private enum CodingKeys: String, CodingKey {
                case deploymentKey
                case label
                case appVersion
                case previousDeploymentKey
                case previousLabelOrAppVersion
                case status
                case clientUniqueID = "clientUniqueId"
            }
        }
    }
}

extension Paths {
    public static var invitations: Invitations {
        Invitations(path: "/v0.1/invitations")
    }

    public struct Invitations {
        /// Path: `/v0.1/invitations`
        public let path: String
    }
}

extension Paths.Invitations {
    public var sent: Sent {
        Sent(path: path + "/sent")
    }

    public struct Sent {
        /// Path: `/v0.1/invitations/sent`
        public let path: String

        /// Returns all invitations sent by the caller
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The id of the invitation
            public var invitationID: String
            public var organization: Organization?
            public var app: App?

            public struct Organization: Decodable {
                /// The internal unique id (UUID) of the organization.
                public var id: String
                /// The display name of the organization
                public var displayName: String
                /// The slug name of the organization
                public var name: String
                /// The URL to a user-uploaded Avatar image
                public var avatarURL: String?
                /// The creation origin of this organization
                public var origin: Origin
                /// The creation date of this organization
                public var createdAt: String
                /// The date the organization was last updated at
                public var updatedAt: String

                /// The creation origin of this organization
                public enum Origin: String, Codable, CaseIterable {
                    case appcenter
                    case hockeyapp
                }

                public init(id: String, displayName: String, name: String, avatarURL: String? = nil, origin: Origin, createdAt: String, updatedAt: String) {
                    self.id = id
                    self.displayName = displayName
                    self.name = name
                    self.avatarURL = avatarURL
                    self.origin = origin
                    self.createdAt = createdAt
                    self.updatedAt = updatedAt
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case displayName = "display_name"
                    case name
                    case avatarURL = "avatar_url"
                    case origin
                    case createdAt = "created_at"
                    case updatedAt = "updated_at"
                }
            }

            public struct App: Decodable {
                /// The unique ID (UUID) of the app
                public var id: String
                /// The description of the app
                public var description: String?
                /// The display name of the app
                public var displayName: String
                /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
                public var releaseType: String?
                /// The string representation of the URL pointing to the app's icon
                public var iconURL: String?
                /// The string representation of the source of the app's icon
                public var iconSource: String?
                /// The name of the app used in URLs
                public var name: String
                /// The OS the app will be running on
                public var os: Os
                /// The information about the app's owner
                public var owner: Owner
                /// A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics
                public var appSecret: String?
                public var azureSubscription: AzureSubscription?
                /// The platform of the app
                public var platform: Platform?
                /// The creation origin of this app
                public var origin: Origin?
                /// The created date of this app
                public var createdAt: String?
                /// The last updated date of this app
                public var updatedAt: String?
                /// The permissions of the calling user
                public var memberPermissions: [MemberPermission]?

                /// The OS the app will be running on
                public enum Os: String, Codable, CaseIterable {
                    case android = "Android"
                    case iOS
                    case macOS
                    case tizen = "Tizen"
                    case tvOS
                    case windows = "Windows"
                    case linux = "Linux"
                    case custom = "Custom"
                }

                /// The information about the app's owner
                public struct Owner: Decodable {
                    /// The unique id (UUID) of the owner
                    public var id: String
                    /// The avatar URL of the owner
                    public var avatarURL: String?
                    /// The owner's display name
                    public var displayName: String
                    /// The owner's email address
                    public var email: String?
                    /// The unique name that used to identify the owner
                    public var name: String
                    /// The owner type. Can either be 'org' or 'user'
                    public var type: `Type`

                    /// The owner type. Can either be 'org' or 'user'
                    public enum `Type`: String, Codable, CaseIterable {
                        case org
                        case user
                    }

                    public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
                        self.id = id
                        self.avatarURL = avatarURL
                        self.displayName = displayName
                        self.email = email
                        self.name = name
                        self.type = type
                    }

                    private enum CodingKeys: String, CodingKey {
                        case id
                        case avatarURL = "avatar_url"
                        case displayName = "display_name"
                        case email
                        case name
                        case type
                    }
                }

                public struct AzureSubscription: Decodable {
                    /// The azure subscription id
                    public var subscriptionID: String
                    /// The tenant id of the azure subscription belongs to
                    public var tenantID: String
                    /// The name of the azure subscription
                    public var subscriptionName: String
                    /// If the subscription is used for billing
                    public var isBilling: Bool?
                    /// If the subscription can be used for billing
                    public var isBillable: Bool?
                    /// If the subscription is internal Microsoft subscription
                    public var isMicrosoftInternal: Bool?

                    public init(subscriptionID: String, tenantID: String, subscriptionName: String, isBilling: Bool? = nil, isBillable: Bool? = nil, isMicrosoftInternal: Bool? = nil) {
                        self.subscriptionID = subscriptionID
                        self.tenantID = tenantID
                        self.subscriptionName = subscriptionName
                        self.isBilling = isBilling
                        self.isBillable = isBillable
                        self.isMicrosoftInternal = isMicrosoftInternal
                    }

                    private enum CodingKeys: String, CodingKey {
                        case subscriptionID = "subscription_id"
                        case tenantID = "tenant_id"
                        case subscriptionName = "subscription_name"
                        case isBilling = "is_billing"
                        case isBillable = "is_billable"
                        case isMicrosoftInternal = "is_microsoft_internal"
                    }
                }

                /// The platform of the app
                public enum Platform: String, Codable, CaseIterable {
                    case java = "Java"
                    case objectiveCSwift = "Objective-C-Swift"
                    case uwp = "UWP"
                    case cordova = "Cordova"
                    case reactNative = "React-Native"
                    case unity = "Unity"
                    case electron = "Electron"
                    case xamarin = "Xamarin"
                    case wpf = "WPF"
                    case winForms = "WinForms"
                    case unknown = "Unknown"
                    case custom = "Custom"
                }

                /// The creation origin of this app
                public enum Origin: String, Codable, CaseIterable {
                    case appcenter
                    case hockeyapp
                    case codepush
                }

                public enum MemberPermission: String, Codable, CaseIterable {
                    case manager
                    case developer
                    case viewer
                    case tester
                }

                public init(id: String, description: String? = nil, displayName: String, releaseType: String? = nil, iconURL: String? = nil, iconSource: String? = nil, name: String, os: Os, owner: Owner, appSecret: String? = nil, azureSubscription: AzureSubscription? = nil, platform: Platform? = nil, origin: Origin? = nil, createdAt: String? = nil, updatedAt: String? = nil, memberPermissions: [MemberPermission]? = nil) {
                    self.id = id
                    self.description = description
                    self.displayName = displayName
                    self.releaseType = releaseType
                    self.iconURL = iconURL
                    self.iconSource = iconSource
                    self.name = name
                    self.os = os
                    self.owner = owner
                    self.appSecret = appSecret
                    self.azureSubscription = azureSubscription
                    self.platform = platform
                    self.origin = origin
                    self.createdAt = createdAt
                    self.updatedAt = updatedAt
                    self.memberPermissions = memberPermissions
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.id = try values.decode(String.self, forKey: "id")
                    self.description = try values.decodeIfPresent(String.self, forKey: "description")
                    self.displayName = try values.decode(String.self, forKey: "display_name")
                    self.releaseType = try values.decodeIfPresent(String.self, forKey: "release_type")
                    self.iconURL = try values.decodeIfPresent(String.self, forKey: "icon_url")
                    self.iconSource = try values.decodeIfPresent(String.self, forKey: "icon_source")
                    self.name = try values.decode(String.self, forKey: "name")
                    self.os = try Os(from: decoder)
                    self.owner = try Owner(from: decoder)
                    self.appSecret = try values.decodeIfPresent(String.self, forKey: "app_secret")
                    self.azureSubscription = try AzureSubscription(from: decoder)
                    self.platform = try Platform(from: decoder)
                    self.origin = try Origin(from: decoder)
                    self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
                    self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
                    self.memberPermissions = try values.decodeIfPresent([MemberPermission].self, forKey: "member_permissions")
                }
            }

            public init(invitationID: String, organization: Organization? = nil, app: App? = nil) {
                self.invitationID = invitationID
                self.organization = organization
                self.app = app
            }

            private enum CodingKeys: String, CodingKey {
                case invitationID = "invitation_id"
                case organization
                case app
            }
        }
    }
}

extension Paths {
    public static var billing: Billing {
        Billing(path: "/v0.1/billing")
    }

    public struct Billing {
        /// Path: `/v0.1/billing`
        public let path: String
    }
}

extension Paths.Billing {
    public var allAccountsAggregated: AllAccountsAggregated {
        AllAccountsAggregated(path: path + "/allAccountsAggregated")
    }

    public struct AllAccountsAggregated {
        /// Path: `/v0.1/billing/allAccountsAggregated`
        public let path: String

        /// Aggregated Billing Information for the requesting user and the organizations in which the user is an admin.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// Aggregated Billing Information for a user an the organizations in which the user is an admin.
        public struct GetResponse: Decodable {
            /// Aggregated Billing Information for a user or an organization
            public var aggregatedBillings: AggregatedBillings?

            /// Aggregated Billing Information for a user or an organization
            public struct AggregatedBillings: Decodable {
                /// Version of the Billing Information schema
                public var version: String?
                /// The ISO 8601 datetime of last modification
                public var timestamp: String?
                /// ID of the user or organization
                public var id: String?
                /// Billing Plans section in the Billing Information
                public var billingPlans: BillingPlans?
                /// Usage section in the Billing Information
                public var usage: Usage?
                /// Unique identifier for the Azure subscription used for billing
                public var azureSubscriptionID: String?
                /// State of the Azure subscription used for billing
                public var azureSubscriptionState: AzureSubscriptionState?

                /// Billing Plans section in the Billing Information
                public struct BillingPlans: Decodable {
                    /// Billing Plans for a single service
                    public var buildService: BuildService?
                    /// Billing Plans for a single service
                    public var testService: TestService?

                    /// Billing Plans for a single service
                    public struct BuildService: Decodable {
                        /// Can customer select trial plan for that service (if it exists)?
                        public var canSelectTrialPlan: Bool?
                        /// Expiration time of the last selected trial plan. Will be null if trial plan was not used.
                        public var lastTrialPlanExpirationTime: String?
                        /// Billing plans for a given period
                        public var currentBillingPeriod: CurrentBillingPeriod?

                        /// Billing plans for a given period
                        public struct CurrentBillingPeriod: Decodable {
                            /// Inclusive start of the period
                            public var startTime: String?
                            /// Exclusive end of the period.
                            public var endTime: String?
                            /// Selection of a billing plan
                            public var byAccount: ByAccount?

                            /// Selection of a billing plan
                            public struct ByAccount: Decodable {
                                /// Number of instances of the billing plan.
                                public var count: Int?
                                /// Billing Plan
                                public var plan: Plan?

                                /// Billing Plan
                                public struct Plan: Decodable {
                                    /// The Billing Plan ID
                                    public var id: String?
                                    /// Version of the Billing Plan schema
                                    public var version: String?
                                    /// Price of the Billing Plan
                                    public var price: Double?
                                    /// Service that receives payments for this billing plan.
                                    public var paymentSource: PaymentSource?
                                    /// Name of the service that the plan applies to.
                                    public var service: Service?
                                    /// A collection of named numeric values
                                    public var limits: [String: Double]?
                                    /// Collection of attribute values.
                                    public var attributes: [String: [String: AnyJSON]]?
                                    public var parentID: String?

                                    /// Service that receives payments for this billing plan.
                                    public enum PaymentSource: String, Codable, CaseIterable {
                                        case `none` = "None"
                                        case appCenter = "AppCenter"
                                        case gitHub = "GitHub"
                                        case xtc = "Xtc"
                                    }

                                    /// Name of the service that the plan applies to.
                                    public enum Service: String, Codable, CaseIterable {
                                        case build = "Build"
                                        case test = "Test"
                                    }

                                    public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
                                        self.id = id
                                        self.version = version
                                        self.price = price
                                        self.paymentSource = paymentSource
                                        self.service = service
                                        self.limits = limits
                                        self.attributes = attributes
                                        self.parentID = parentID
                                    }

                                    private enum CodingKeys: String, CodingKey {
                                        case id
                                        case version
                                        case price
                                        case paymentSource
                                        case service
                                        case limits
                                        case attributes
                                        case parentID = "parentId"
                                    }
                                }

                                public init(count: Int? = nil, plan: Plan? = nil) {
                                    self.count = count
                                    self.plan = plan
                                }
                            }

                            public init(startTime: String? = nil, endTime: String? = nil, byAccount: ByAccount? = nil) {
                                self.startTime = startTime
                                self.endTime = endTime
                                self.byAccount = byAccount
                            }
                        }

                        public init(canSelectTrialPlan: Bool? = nil, lastTrialPlanExpirationTime: String? = nil, currentBillingPeriod: CurrentBillingPeriod? = nil) {
                            self.canSelectTrialPlan = canSelectTrialPlan
                            self.lastTrialPlanExpirationTime = lastTrialPlanExpirationTime
                            self.currentBillingPeriod = currentBillingPeriod
                        }
                    }

                    /// Billing Plans for a single service
                    public struct TestService: Decodable {
                        /// Can customer select trial plan for that service (if it exists)?
                        public var canSelectTrialPlan: Bool?
                        /// Expiration time of the last selected trial plan. Will be null if trial plan was not used.
                        public var lastTrialPlanExpirationTime: String?
                        /// Billing plans for a given period
                        public var currentBillingPeriod: CurrentBillingPeriod?

                        /// Billing plans for a given period
                        public struct CurrentBillingPeriod: Decodable {
                            /// Inclusive start of the period
                            public var startTime: String?
                            /// Exclusive end of the period.
                            public var endTime: String?
                            /// Selection of a billing plan
                            public var byAccount: ByAccount?

                            /// Selection of a billing plan
                            public struct ByAccount: Decodable {
                                /// Number of instances of the billing plan.
                                public var count: Int?
                                /// Billing Plan
                                public var plan: Plan?

                                /// Billing Plan
                                public struct Plan: Decodable {
                                    /// The Billing Plan ID
                                    public var id: String?
                                    /// Version of the Billing Plan schema
                                    public var version: String?
                                    /// Price of the Billing Plan
                                    public var price: Double?
                                    /// Service that receives payments for this billing plan.
                                    public var paymentSource: PaymentSource?
                                    /// Name of the service that the plan applies to.
                                    public var service: Service?
                                    /// A collection of named numeric values
                                    public var limits: [String: Double]?
                                    /// Collection of attribute values.
                                    public var attributes: [String: [String: AnyJSON]]?
                                    public var parentID: String?

                                    /// Service that receives payments for this billing plan.
                                    public enum PaymentSource: String, Codable, CaseIterable {
                                        case `none` = "None"
                                        case appCenter = "AppCenter"
                                        case gitHub = "GitHub"
                                        case xtc = "Xtc"
                                    }

                                    /// Name of the service that the plan applies to.
                                    public enum Service: String, Codable, CaseIterable {
                                        case build = "Build"
                                        case test = "Test"
                                    }

                                    public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
                                        self.id = id
                                        self.version = version
                                        self.price = price
                                        self.paymentSource = paymentSource
                                        self.service = service
                                        self.limits = limits
                                        self.attributes = attributes
                                        self.parentID = parentID
                                    }

                                    private enum CodingKeys: String, CodingKey {
                                        case id
                                        case version
                                        case price
                                        case paymentSource
                                        case service
                                        case limits
                                        case attributes
                                        case parentID = "parentId"
                                    }
                                }

                                public init(count: Int? = nil, plan: Plan? = nil) {
                                    self.count = count
                                    self.plan = plan
                                }
                            }

                            public init(startTime: String? = nil, endTime: String? = nil, byAccount: ByAccount? = nil) {
                                self.startTime = startTime
                                self.endTime = endTime
                                self.byAccount = byAccount
                            }
                        }

                        public init(canSelectTrialPlan: Bool? = nil, lastTrialPlanExpirationTime: String? = nil, currentBillingPeriod: CurrentBillingPeriod? = nil) {
                            self.canSelectTrialPlan = canSelectTrialPlan
                            self.lastTrialPlanExpirationTime = lastTrialPlanExpirationTime
                            self.currentBillingPeriod = currentBillingPeriod
                        }
                    }

                    public init(buildService: BuildService? = nil, testService: TestService? = nil) {
                        self.buildService = buildService
                        self.testService = testService
                    }
                }

                /// Usage section in the Billing Information
                public struct Usage: Decodable {
                    /// Resource usage for a single Mobile Center service
                    public var buildService: BuildService?
                    /// Resource usage for a single Mobile Center service
                    public var testService: TestService?

                    /// Resource usage for a single Mobile Center service
                    public struct BuildService: Decodable {
                        /// Usage for a single period
                        public var currentUsagePeriod: CurrentUsagePeriod?

                        /// Usage for a single period
                        public struct CurrentUsagePeriod: Decodable {
                            /// Inclusive start time of the usage period
                            public var startTime: String?
                            /// Exclusive end time of the usage period.
                            public var endTime: String?
                            /// A collection of named numeric values
                            public var byAccount: [String: Double]?
                            /// A collection of  named numeric values grouped by app
                            public var byApp: [String: [String: Double]]?

                            public init(startTime: String? = nil, endTime: String? = nil, byAccount: [String: Double]? = nil, byApp: [String: [String: Double]]? = nil) {
                                self.startTime = startTime
                                self.endTime = endTime
                                self.byAccount = byAccount
                                self.byApp = byApp
                            }
                        }

                        public init(currentUsagePeriod: CurrentUsagePeriod? = nil) {
                            self.currentUsagePeriod = currentUsagePeriod
                        }
                    }

                    /// Resource usage for a single Mobile Center service
                    public struct TestService: Decodable {
                        /// Usage for a single period
                        public var currentUsagePeriod: CurrentUsagePeriod?

                        /// Usage for a single period
                        public struct CurrentUsagePeriod: Decodable {
                            /// Inclusive start time of the usage period
                            public var startTime: String?
                            /// Exclusive end time of the usage period.
                            public var endTime: String?
                            /// A collection of named numeric values
                            public var byAccount: [String: Double]?
                            /// A collection of  named numeric values grouped by app
                            public var byApp: [String: [String: Double]]?

                            public init(startTime: String? = nil, endTime: String? = nil, byAccount: [String: Double]? = nil, byApp: [String: [String: Double]]? = nil) {
                                self.startTime = startTime
                                self.endTime = endTime
                                self.byAccount = byAccount
                                self.byApp = byApp
                            }
                        }

                        public init(currentUsagePeriod: CurrentUsagePeriod? = nil) {
                            self.currentUsagePeriod = currentUsagePeriod
                        }
                    }

                    public init(buildService: BuildService? = nil, testService: TestService? = nil) {
                        self.buildService = buildService
                        self.testService = testService
                    }
                }

                /// State of the Azure subscription used for billing
                public enum AzureSubscriptionState: String, Codable, CaseIterable {
                    case enabled = "Enabled"
                    case disabled = "Disabled"
                    case notSet = "NotSet"
                }

                public init(version: String? = nil, timestamp: String? = nil, id: String? = nil, billingPlans: BillingPlans? = nil, usage: Usage? = nil, azureSubscriptionID: String? = nil, azureSubscriptionState: AzureSubscriptionState? = nil) {
                    self.version = version
                    self.timestamp = timestamp
                    self.id = id
                    self.billingPlans = billingPlans
                    self.usage = usage
                    self.azureSubscriptionID = azureSubscriptionID
                    self.azureSubscriptionState = azureSubscriptionState
                }

                private enum CodingKeys: String, CodingKey {
                    case version
                    case timestamp
                    case id
                    case billingPlans
                    case usage
                    case azureSubscriptionID = "azureSubscriptionId"
                    case azureSubscriptionState
                }
            }

            public init(aggregatedBillings: AggregatedBillings? = nil) {
                self.aggregatedBillings = aggregatedBillings
            }
        }

        public struct GetParameters {
            public var service: Service?
            public var period: Period?
            public var isShowOriginalPlans: Bool?

            public enum Service: String, Codable, CaseIterable {
                case test = "Test"
                case build = "Build"
            }

            public enum Period: String, Codable, CaseIterable {
                case previous = "Previous"
                case current = "Current"
                case next = "Next"
            }

            public init(service: Service? = nil, period: Period? = nil, isShowOriginalPlans: Bool? = nil) {
                self.service = service
                self.period = period
                self.isShowOriginalPlans = isShowOriginalPlans
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(service, forKey: "service")
                encoder.encode(period, forKey: "period")
                encoder.encode(isShowOriginalPlans, forKey: "showOriginalPlans")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var azureSubscriptions: AzureSubscriptions {
        AzureSubscriptions(path: "/v0.1/azure_subscriptions")
    }

    public struct AzureSubscriptions {
        /// Path: `/v0.1/azure_subscriptions`
        public let path: String

        /// Returns a list of azure subscriptions for the user
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The azure subscription id
            public var subscriptionID: String
            /// The tenant id of the azure subscription belongs to
            public var tenantID: String
            /// The name of the azure subscription
            public var subscriptionName: String
            /// If the subscription is used for billing
            public var isBilling: Bool?
            /// If the subscription can be used for billing
            public var isBillable: Bool?
            /// If the subscription is internal Microsoft subscription
            public var isMicrosoftInternal: Bool?

            public init(subscriptionID: String, tenantID: String, subscriptionName: String, isBilling: Bool? = nil, isBillable: Bool? = nil, isMicrosoftInternal: Bool? = nil) {
                self.subscriptionID = subscriptionID
                self.tenantID = tenantID
                self.subscriptionName = subscriptionName
                self.isBilling = isBilling
                self.isBillable = isBillable
                self.isMicrosoftInternal = isMicrosoftInternal
            }

            private enum CodingKeys: String, CodingKey {
                case subscriptionID = "subscription_id"
                case tenantID = "tenant_id"
                case subscriptionName = "subscription_name"
                case isBilling = "is_billing"
                case isBillable = "is_billable"
                case isMicrosoftInternal = "is_microsoft_internal"
            }
        }
    }
}

extension Paths.Apps {
    public func ownerName(_ ownerName: String) -> WithOwnerName {
        WithOwnerName(path: "\(path)/\(ownerName)")
    }

    public struct WithOwnerName {
        /// Path: `/v0.1/apps/{owner_name}`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var xcodeVersions: XcodeVersions {
        XcodeVersions(path: path + "/xcode_versions")
    }

    public struct XcodeVersions {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/xcode_versions`
        public let path: String

        /// Gets the Xcode versions available to this app
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        /// The Xcode version
        public struct GetResponseItem: Decodable {
            /// The version name
            public var name: String?
            /// If the Xcode is latest stable
            public var isCurrent: Bool?

            public init(name: String? = nil, isCurrent: Bool? = nil) {
                self.name = name
                self.isCurrent = isCurrent
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case isCurrent = "current"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var xamarinSdkBundles: XamarinSdkBundles {
        XamarinSdkBundles(path: path + "/xamarin_sdk_bundles")
    }

    public struct XamarinSdkBundles {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/xamarin_sdk_bundles`
        public let path: String

        /// Gets the Xamarin SDK bundles available to this app
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        /// The Xamarin SDK bundle
        public struct GetResponseItem: Decodable {
            /// The Mono version
            public var monoVersion: String?
            /// The Xamarin SDK version
            public var sdkBundle: String?
            /// If the SDK is latest stable
            public var isCurrent: Bool?
            /// If the SDK is stable
            public var isStable: Bool?
            /// Specific for iOS SDK. A list of Xcode versions supported by current SDK version
            public var xcodeVersions: [String]?

            public init(monoVersion: String? = nil, sdkBundle: String? = nil, isCurrent: Bool? = nil, isStable: Bool? = nil, xcodeVersions: [String]? = nil) {
                self.monoVersion = monoVersion
                self.sdkBundle = sdkBundle
                self.isCurrent = isCurrent
                self.isStable = isStable
                self.xcodeVersions = xcodeVersions
            }

            private enum CodingKeys: String, CodingKey {
                case monoVersion
                case sdkBundle
                case isCurrent = "current"
                case isStable = "stable"
                case xcodeVersions
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var webhooks: Webhooks {
        Webhooks(path: path + "/webhooks")
    }

    public struct Webhooks {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/webhooks`
        public let path: String

        /// Get web hooks configured for a particular app
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var versions: Versions {
        Versions(path: path + "/versions")
    }

    public struct Versions {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/versions`
        public let path: String

        /// Gets a list of application versions.
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            public var appVersionID: String
            public var appID: String
            public var displayName: String
            public var appVersion: String
            public var buildNumber: String?

            public init(appVersionID: String, appID: String, displayName: String, appVersion: String, buildNumber: String? = nil) {
                self.appVersionID = appVersionID
                self.appID = appID
                self.displayName = displayName
                self.appVersion = appVersion
                self.buildNumber = buildNumber
            }

            private enum CodingKeys: String, CodingKey {
                case appVersionID = "app_version_id"
                case appID = "app_id"
                case displayName = "display_name"
                case appVersion = "app_version"
                case buildNumber = "build_number"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Users {
    public func userEmail(_ userEmail: String) -> WithUserEmail {
        WithUserEmail(path: "\(path)/\(userEmail)")
    }

    public struct WithUserEmail {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/users/{user_email}`
        public let path: String

        /// Update user permission for the app
        public func patch(permissions: [PatchRequest.Permission]) -> Request<Void> {
            .patch(path, body: PatchRequest(permissions: permissions))
        }

        public struct PatchRequest: Encodable {
            /// The permissions the user has for the app
            public var permissions: [Permission]

            public enum Permission: String, Codable, CaseIterable {
                case manager
                case developer
                case viewer
            }

            public init(permissions: [Permission]) {
                self.permissions = permissions
            }
        }

        /// Removes the user from the app
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var users: Users {
        Users(path: path + "/users")
    }

    public struct Users {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/users`
        public let path: String

        /// Returns the users associated with the app specified with the given app name which belongs to the given owner.
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The unique id (UUID) of the user
            public var id: String
            /// The avatar URL of the user
            public var avatarURL: String?
            /// User is required to send an old password in order to change the password.
            public var canChangePassword: Bool?
            /// The full name of the user. Might for example be first and last name
            public var displayName: String
            /// The email address of the user
            public var email: String
            /// The unique name that is used to identify the user.
            public var name: String
            /// The permissions the user has for the app
            public var permissions: [Permission]?
            /// The creation origin of this user
            public var origin: Origin

            public enum Permission: String, Codable, CaseIterable {
                case manager
                case developer
                case viewer
                case tester
            }

            /// The creation origin of this user
            public enum Origin: String, Codable, CaseIterable {
                case appcenter
                case hockeyapp
                case codepush
            }

            public init(id: String, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String, email: String, name: String, permissions: [Permission]? = nil, origin: Origin) {
                self.id = id
                self.avatarURL = avatarURL
                self.canChangePassword = canChangePassword
                self.displayName = displayName
                self.email = email
                self.name = name
                self.permissions = permissions
                self.origin = origin
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case avatarURL = "avatar_url"
                case canChangePassword = "can_change_password"
                case displayName = "display_name"
                case email
                case name
                case permissions
                case origin
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var user: User {
        User(path: path + "/user")
    }

    public struct User {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/user`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.User.DeviceSets {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/user/device_sets/{id}`
        public let path: String

        /// Gets a device set belonging to the user
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Device Set
        ///
        /// The name and devices of the device set
        public struct GetResponse: Decodable {
            /// Identifier of the device set
            public var id: String
            /// The number of manufacturers in the device set's device selection
            public var manufacturerCount: Double?
            /// Name of the device set
            public var name: String
            /// Slug of the device set
            public var slug: String?
            /// Device Set Owner
            ///
            /// The owner of a device set
            public var owner: Owner
            /// The number of os versions in the device set's device selection
            public var osVersionCount: Double?
            public var deviceConfigurations: [DeviceConfiguration]

            /// Device Set Owner
            ///
            /// The owner of a device set
            public struct Owner: Decodable {
                /// Type of account
                public var type: String
                /// Account ID
                public var id: String
                /// Display name of the account
                public var displayName: String?
                /// Name of the account
                public var name: String

                public init(type: String, id: String, displayName: String? = nil, name: String) {
                    self.type = type
                    self.id = id
                    self.displayName = displayName
                    self.name = name
                }
            }

            public struct DeviceConfiguration: Decodable {
                /// The unique id of the device configuration
                public var id: String?
                public var image: Image?
                public var model: Model?
                public var os: String?
                public var osName: String?

                public struct Image: Decodable {
                    public var thumb: String?

                    public init(thumb: String? = nil) {
                        self.thumb = thumb
                    }
                }

                public struct Model: Decodable {
                    public var name: String?
                    public var manufacturer: String?
                    public var releaseDate: String?
                    public var formFactor: String?

                    public init(name: String? = nil, manufacturer: String? = nil, releaseDate: String? = nil, formFactor: String? = nil) {
                        self.name = name
                        self.manufacturer = manufacturer
                        self.releaseDate = releaseDate
                        self.formFactor = formFactor
                    }
                }

                public init(id: String? = nil, image: Image? = nil, model: Model? = nil, os: String? = nil, osName: String? = nil) {
                    self.id = id
                    self.image = image
                    self.model = model
                    self.os = os
                    self.osName = osName
                }
            }

            public init(id: String, manufacturerCount: Double? = nil, name: String, slug: String? = nil, owner: Owner, osVersionCount: Double? = nil, deviceConfigurations: [DeviceConfiguration]) {
                self.id = id
                self.manufacturerCount = manufacturerCount
                self.name = name
                self.slug = slug
                self.owner = owner
                self.osVersionCount = osVersionCount
                self.deviceConfigurations = deviceConfigurations
            }
        }

        /// Updates a device set belonging to the user
        public func put(_ body: PutRequest) -> Request<PutResponse> {
            .put(path, body: body)
        }

        /// Device Set
        ///
        /// The name and devices of the device set
        public struct PutResponse: Decodable {
            /// Identifier of the device set
            public var id: String
            /// The number of manufacturers in the device set's device selection
            public var manufacturerCount: Double?
            /// Name of the device set
            public var name: String
            /// Slug of the device set
            public var slug: String?
            /// Device Set Owner
            ///
            /// The owner of a device set
            public var owner: Owner
            /// The number of os versions in the device set's device selection
            public var osVersionCount: Double?
            public var deviceConfigurations: [DeviceConfiguration]

            /// Device Set Owner
            ///
            /// The owner of a device set
            public struct Owner: Decodable {
                /// Type of account
                public var type: String
                /// Account ID
                public var id: String
                /// Display name of the account
                public var displayName: String?
                /// Name of the account
                public var name: String

                public init(type: String, id: String, displayName: String? = nil, name: String) {
                    self.type = type
                    self.id = id
                    self.displayName = displayName
                    self.name = name
                }
            }

            public struct DeviceConfiguration: Decodable {
                /// The unique id of the device configuration
                public var id: String?
                public var image: Image?
                public var model: Model?
                public var os: String?
                public var osName: String?

                public struct Image: Decodable {
                    public var thumb: String?

                    public init(thumb: String? = nil) {
                        self.thumb = thumb
                    }
                }

                public struct Model: Decodable {
                    public var name: String?
                    public var manufacturer: String?
                    public var releaseDate: String?
                    public var formFactor: String?

                    public init(name: String? = nil, manufacturer: String? = nil, releaseDate: String? = nil, formFactor: String? = nil) {
                        self.name = name
                        self.manufacturer = manufacturer
                        self.releaseDate = releaseDate
                        self.formFactor = formFactor
                    }
                }

                public init(id: String? = nil, image: Image? = nil, model: Model? = nil, os: String? = nil, osName: String? = nil) {
                    self.id = id
                    self.image = image
                    self.model = model
                    self.os = os
                    self.osName = osName
                }
            }

            public init(id: String, manufacturerCount: Double? = nil, name: String, slug: String? = nil, owner: Owner, osVersionCount: Double? = nil, deviceConfigurations: [DeviceConfiguration]) {
                self.id = id
                self.manufacturerCount = manufacturerCount
                self.name = name
                self.slug = slug
                self.owner = owner
                self.osVersionCount = osVersionCount
                self.deviceConfigurations = deviceConfigurations
            }
        }

        /// Device Set update information
        ///
        /// The name of the device set and the list of device IDs
        public struct PutRequest: Encodable {
            /// List of device IDs
            public var devices: [String]
            /// The name of the device set
            public var name: String

            public init(devices: [String], name: String) {
                self.devices = devices
                self.name = name
            }
        }

        /// Deletes a device set belonging to the user
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.User {
    public var deviceSets: DeviceSets {
        DeviceSets(path: path + "/device_sets")
    }

    public struct DeviceSets {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/user/device_sets`
        public let path: String

        /// Lists device sets belonging to the user
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        /// Device Set
        ///
        /// The name and devices of the device set
        public struct GetResponseItem: Decodable {
            /// Identifier of the device set
            public var id: String
            /// The number of manufacturers in the device set's device selection
            public var manufacturerCount: Double?
            /// Name of the device set
            public var name: String
            /// Slug of the device set
            public var slug: String?
            /// Device Set Owner
            ///
            /// The owner of a device set
            public var owner: Owner
            /// The number of os versions in the device set's device selection
            public var osVersionCount: Double?
            public var deviceConfigurations: [DeviceConfiguration]

            /// Device Set Owner
            ///
            /// The owner of a device set
            public struct Owner: Decodable {
                /// Type of account
                public var type: String
                /// Account ID
                public var id: String
                /// Display name of the account
                public var displayName: String?
                /// Name of the account
                public var name: String

                public init(type: String, id: String, displayName: String? = nil, name: String) {
                    self.type = type
                    self.id = id
                    self.displayName = displayName
                    self.name = name
                }
            }

            public struct DeviceConfiguration: Decodable {
                /// The unique id of the device configuration
                public var id: String?
                public var image: Image?
                public var model: Model?
                public var os: String?
                public var osName: String?

                public struct Image: Decodable {
                    public var thumb: String?

                    public init(thumb: String? = nil) {
                        self.thumb = thumb
                    }
                }

                public struct Model: Decodable {
                    public var name: String?
                    public var manufacturer: String?
                    public var releaseDate: String?
                    public var formFactor: String?

                    public init(name: String? = nil, manufacturer: String? = nil, releaseDate: String? = nil, formFactor: String? = nil) {
                        self.name = name
                        self.manufacturer = manufacturer
                        self.releaseDate = releaseDate
                        self.formFactor = formFactor
                    }
                }

                public init(id: String? = nil, image: Image? = nil, model: Model? = nil, os: String? = nil, osName: String? = nil) {
                    self.id = id
                    self.image = image
                    self.model = model
                    self.os = os
                    self.osName = osName
                }
            }

            public init(id: String, manufacturerCount: Double? = nil, name: String, slug: String? = nil, owner: Owner, osVersionCount: Double? = nil, deviceConfigurations: [DeviceConfiguration]) {
                self.id = id
                self.manufacturerCount = manufacturerCount
                self.name = name
                self.slug = slug
                self.owner = owner
                self.osVersionCount = osVersionCount
                self.deviceConfigurations = deviceConfigurations
            }
        }

        /// Creates a device set belonging to the user
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        /// Device Set
        ///
        /// The name and devices of the device set
        public struct PostResponse: Decodable {
            /// Identifier of the device set
            public var id: String
            /// The number of manufacturers in the device set's device selection
            public var manufacturerCount: Double?
            /// Name of the device set
            public var name: String
            /// Slug of the device set
            public var slug: String?
            /// Device Set Owner
            ///
            /// The owner of a device set
            public var owner: Owner
            /// The number of os versions in the device set's device selection
            public var osVersionCount: Double?
            public var deviceConfigurations: [DeviceConfiguration]

            /// Device Set Owner
            ///
            /// The owner of a device set
            public struct Owner: Decodable {
                /// Type of account
                public var type: String
                /// Account ID
                public var id: String
                /// Display name of the account
                public var displayName: String?
                /// Name of the account
                public var name: String

                public init(type: String, id: String, displayName: String? = nil, name: String) {
                    self.type = type
                    self.id = id
                    self.displayName = displayName
                    self.name = name
                }
            }

            public struct DeviceConfiguration: Decodable {
                /// The unique id of the device configuration
                public var id: String?
                public var image: Image?
                public var model: Model?
                public var os: String?
                public var osName: String?

                public struct Image: Decodable {
                    public var thumb: String?

                    public init(thumb: String? = nil) {
                        self.thumb = thumb
                    }
                }

                public struct Model: Decodable {
                    public var name: String?
                    public var manufacturer: String?
                    public var releaseDate: String?
                    public var formFactor: String?

                    public init(name: String? = nil, manufacturer: String? = nil, releaseDate: String? = nil, formFactor: String? = nil) {
                        self.name = name
                        self.manufacturer = manufacturer
                        self.releaseDate = releaseDate
                        self.formFactor = formFactor
                    }
                }

                public init(id: String? = nil, image: Image? = nil, model: Model? = nil, os: String? = nil, osName: String? = nil) {
                    self.id = id
                    self.image = image
                    self.model = model
                    self.os = os
                    self.osName = osName
                }
            }

            public init(id: String, manufacturerCount: Double? = nil, name: String, slug: String? = nil, owner: Owner, osVersionCount: Double? = nil, deviceConfigurations: [DeviceConfiguration]) {
                self.id = id
                self.manufacturerCount = manufacturerCount
                self.name = name
                self.slug = slug
                self.owner = owner
                self.osVersionCount = osVersionCount
                self.deviceConfigurations = deviceConfigurations
            }
        }

        /// Device Set update information
        ///
        /// The name of the device set and the list of device IDs
        public struct PostRequest: Encodable {
            /// List of device IDs
            public var devices: [String]
            /// The name of the device set
            public var name: String

            public init(devices: [String], name: String) {
                self.devices = devices
                self.name = name
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var uploads: Uploads {
        Uploads(path: path + "/uploads")
    }

    public struct Uploads {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/uploads`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Uploads.Releases {
    public func uploadID(_ uploadID: String) -> WithUploadID {
        WithUploadID(path: "\(path)/\(uploadID)")
    }

    public struct WithUploadID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/uploads/releases/{upload_id}`
        public let path: String

        /// Get the current status of the release upload.
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Update the current status of the release upload.
        public func patch(isExtract: Bool? = nil, uploadStatus: PatchRequest.UploadStatus) -> Request<[String: AnyJSON]> {
            .patch(path, query: makePatchQuery(isExtract), body: PatchRequest(uploadStatus: uploadStatus))
        }

        private func makePatchQuery(_ isExtract: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isExtract, forKey: "extract")
            return encoder.items
        }

        public struct PatchRequest: Encodable {
            /// The new status of the release upload
            public var uploadStatus: UploadStatus

            /// The new status of the release upload
            public enum UploadStatus: String, Codable, CaseIterable {
                case uploadFinished
                case uploadCanceled
            }

            public init(uploadStatus: UploadStatus) {
                self.uploadStatus = uploadStatus
            }

            private enum CodingKeys: String, CodingKey {
                case uploadStatus = "upload_status"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Uploads {
    public var releases: Releases {
        Releases(path: path + "/releases")
    }

    public struct Releases {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/uploads/releases`
        public let path: String

        /// Initiate a new release upload. This API is part of multi-step upload process.
        public func post(_ body: PostRequest? = nil) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// User defined build version
            public var buildVersion: String?
            /// User defined build number
            public var buildNumber: String?

            public init(buildVersion: String? = nil, buildNumber: String? = nil) {
                self.buildVersion = buildVersion
                self.buildNumber = buildNumber
            }

            private enum CodingKeys: String, CodingKey {
                case buildVersion = "build_version"
                case buildNumber = "build_number"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var transferToOrg: TransferToOrg {
        TransferToOrg(path: path + "/transfer_to_org")
    }

    public struct TransferToOrg {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/transfer_to_org`
        public let path: String

        /// Transfers ownership of an app to a new organization
        public func post(_ body: [String: AnyJSON]? = nil) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var transfer: Transfer {
        Transfer(path: path + "/transfer")
    }

    public struct Transfer {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/transfer`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Transfer {
    public func destinationOwnerName(_ destinationOwnerName: String) -> WithDestinationOwnerName {
        WithDestinationOwnerName(path: "\(path)/\(destinationOwnerName)")
    }

    public struct WithDestinationOwnerName {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/transfer/{destination_owner_name}`
        public let path: String

        /// Transfers ownership of an app to a different user or organization
        public func post(_ body: [String: AnyJSON]? = nil) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var toolsets: Toolsets {
        Toolsets(path: path + "/toolsets")
    }

    public struct Toolsets {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/toolsets`
        public let path: String

        /// Returns available toolsets for application
        public func get(tools: Tools? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(tools))
        }

        /// Set of toolsets available for app
        public struct GetResponse: Decodable {
            /// A list of Xamarin SDK bundles
            public var xamarin: [XamarinItem]?
            /// A list of Xcode versions
            public var xcode: [XcodeItem]?
            /// A list of Node versions
            public var node: [NodeItem]?

            /// The Xamarin SDK bundle
            public struct XamarinItem: Decodable {
                /// The Mono version
                public var monoVersion: String?
                /// The Xamarin SDK version
                public var sdkBundle: String?
                /// If the SDK is latest stable
                public var isCurrent: Bool?
                /// If the SDK is stable
                public var isStable: Bool?
                /// Specific for iOS SDK. A list of Xcode versions supported by current SDK version
                public var xcodeVersions: [String]?

                public init(monoVersion: String? = nil, sdkBundle: String? = nil, isCurrent: Bool? = nil, isStable: Bool? = nil, xcodeVersions: [String]? = nil) {
                    self.monoVersion = monoVersion
                    self.sdkBundle = sdkBundle
                    self.isCurrent = isCurrent
                    self.isStable = isStable
                    self.xcodeVersions = xcodeVersions
                }

                private enum CodingKeys: String, CodingKey {
                    case monoVersion
                    case sdkBundle
                    case isCurrent = "current"
                    case isStable = "stable"
                    case xcodeVersions
                }
            }

            /// The Xcode version
            public struct XcodeItem: Decodable {
                /// The version name
                public var name: String?
                /// If the Xcode is latest stable
                public var isCurrent: Bool?

                public init(name: String? = nil, isCurrent: Bool? = nil) {
                    self.name = name
                    self.isCurrent = isCurrent
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case isCurrent = "current"
                }
            }

            /// The Node version
            public struct NodeItem: Decodable {
                /// The version name
                public var name: String?
                /// If the Node version is default for AppCenter
                public var isCurrent: Bool?

                public init(name: String? = nil, isCurrent: Bool? = nil) {
                    self.name = name
                    self.isCurrent = isCurrent
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case isCurrent = "current"
                }
            }

            public init(xamarin: [XamarinItem]? = nil, xcode: [XcodeItem]? = nil, node: [NodeItem]? = nil) {
                self.xamarin = xamarin
                self.xcode = xcode
                self.node = node
            }
        }

        private func makeGetQuery(_ tools: Tools?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tools, forKey: "tools")
            return encoder.items
        }

        public enum Tools: String, Codable, CaseIterable {
            case xamarin
            case xcode
            case node
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Testers {
    public func testerID(_ testerID: String) -> WithTesterID {
        WithTesterID(path: "\(path)/\(testerID)")
    }

    public struct WithTesterID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/testers/{tester_id}`
        public let path: String

        /// Delete the given tester from the all releases
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var testers: Testers {
        Testers(path: path + "/testers")
    }

    public struct Testers {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/testers`
        public let path: String

        /// Returns the testers associated with the app specified with the given app name which belongs to the given owner.
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The unique id (UUID) of the user
            public var id: String
            /// The avatar URL of the user
            public var avatarURL: String?
            /// User is required to send an old password in order to change the password.
            public var canChangePassword: Bool?
            /// The full name of the user. Might for example be first and last name
            public var displayName: String
            /// The email address of the user
            public var email: String
            /// The unique name that is used to identify the user.
            public var name: String
            /// The permissions the user has for the app
            public var permissions: [Permission]?
            /// The creation origin of this user
            public var origin: Origin

            public enum Permission: String, Codable, CaseIterable {
                case manager
                case developer
                case viewer
                case tester
            }

            /// The creation origin of this user
            public enum Origin: String, Codable, CaseIterable {
                case appcenter
                case hockeyapp
                case codepush
            }

            public init(id: String, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String, email: String, name: String, permissions: [Permission]? = nil, origin: Origin) {
                self.id = id
                self.avatarURL = avatarURL
                self.canChangePassword = canChangePassword
                self.displayName = displayName
                self.email = email
                self.name = name
                self.permissions = permissions
                self.origin = origin
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case avatarURL = "avatar_url"
                case canChangePassword = "can_change_password"
                case displayName = "display_name"
                case email
                case name
                case permissions
                case origin
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.TestSeries.WithTestSeriesSlug {
    public var testRuns: TestRuns {
        TestRuns(path: path + "/test_runs")
    }

    public struct TestRuns {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test_series/{test_series_slug}/test_runs`
        public let path: String

        /// Returns list of all test runs for a given test series
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        /// Test Run
        ///
        /// Summary single test run on Xamarin Test Cloud
        public struct GetResponseItem: Decodable {
            /// The unique id of the test upload
            public var id: String?
            /// The date and time the test was uploaded
            public var date: String?
            /// The compiled version of the app binary
            public var appVersion: String?
            /// The name of the test series with which this test upload is associated
            public var testSeries: String?
            /// The device platform targeted by the test. Possible values are 'ios' or 'android'
            public var platform: String?
            /// The current status of the test run, in relation to the various phases
            public var runStatus: String?
            /// The passed/failed state
            public var resultStatus: String?
            /// Deprecated. Use runStatus instead.
            public var state: String?
            /// Deprecated. Use resultStatus instead.
            public var status: String?
            /// Human readable explanation of the current test status
            public var description: String?
            /// Test Run Statistics
            ///
            /// Summary single test run on Xamarin Test Cloud
            public var stats: Stats?
            /// The name of the test framework used to run this test
            public var testType: String?

            /// Test Run Statistics
            ///
            /// Summary single test run on Xamarin Test Cloud
            public struct Stats: Decodable {
                /// Number of devices running the test
                public var devices: Double?
                /// Number of finished devices
                public var devicesFinished: Double?
                /// Number of failed devices
                public var devicesFailed: Double?
                /// Number of tests in total
                public var total: Double?
                /// Number of passed tests
                public var passed: Double?
                /// Number of failed tests
                public var failed: Double?
                /// Number of skipped tests
                public var skipped: Double?
                /// The max amount of MB used during the test run
                public var peakMemory: Double?
                /// The number of minutes of device time the test has been runnign
                public var totalDeviceMinutes: Double?

                public init(devices: Double? = nil, devicesFinished: Double? = nil, devicesFailed: Double? = nil, total: Double? = nil, passed: Double? = nil, failed: Double? = nil, skipped: Double? = nil, peakMemory: Double? = nil, totalDeviceMinutes: Double? = nil) {
                    self.devices = devices
                    self.devicesFinished = devicesFinished
                    self.devicesFailed = devicesFailed
                    self.total = total
                    self.passed = passed
                    self.failed = failed
                    self.skipped = skipped
                    self.peakMemory = peakMemory
                    self.totalDeviceMinutes = totalDeviceMinutes
                }
            }

            public init(id: String? = nil, date: String? = nil, appVersion: String? = nil, testSeries: String? = nil, platform: String? = nil, runStatus: String? = nil, resultStatus: String? = nil, state: String? = nil, status: String? = nil, description: String? = nil, stats: Stats? = nil, testType: String? = nil) {
                self.id = id
                self.date = date
                self.appVersion = appVersion
                self.testSeries = testSeries
                self.platform = platform
                self.runStatus = runStatus
                self.resultStatus = resultStatus
                self.state = state
                self.status = status
                self.description = description
                self.stats = stats
                self.testType = testType
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.TestSeries {
    public func testSeriesSlug(_ testSeriesSlug: String) -> WithTestSeriesSlug {
        WithTestSeriesSlug(path: "\(path)/\(testSeriesSlug)")
    }

    public struct WithTestSeriesSlug {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test_series/{test_series_slug}`
        public let path: String

        /// Updates name and slug of a test series
        public func patch(name: String) -> Request<PatchResponse> {
            .patch(path, body: ["name": name])
        }

        /// Test Series
        ///
        /// Summary of a single test series
        public struct PatchResponse: Decodable {
            /// Unique, human-readable identifier of the test series
            public var slug: String
            /// Name of the test series
            public var name: String
            /// Date of the latest test run that used this test series
            public var mostRecentActivity: String?
            /// Most recent test runs
            public var testRuns: [TestRun]?

            /// Test Run Summary
            ///
            /// Most important information about a test run.
            public struct TestRun: Decodable {
                /// Date of the test run.
                public var date: String?
                /// Human-readable status of the test run.
                public var statusDescription: String?
                /// Number of failed tests
                public var failed: Double?
                /// Number of passed tests
                public var passed: Double?
                /// Tells whether the test run has completed
                public var isCompleted: Bool?

                public init(date: String? = nil, statusDescription: String? = nil, failed: Double? = nil, passed: Double? = nil, isCompleted: Bool? = nil) {
                    self.date = date
                    self.statusDescription = statusDescription
                    self.failed = failed
                    self.passed = passed
                    self.isCompleted = isCompleted
                }

                private enum CodingKeys: String, CodingKey {
                    case date
                    case statusDescription
                    case failed
                    case passed
                    case isCompleted = "completed"
                }
            }

            public init(slug: String, name: String, mostRecentActivity: String? = nil, testRuns: [TestRun]? = nil) {
                self.slug = slug
                self.name = name
                self.mostRecentActivity = mostRecentActivity
                self.testRuns = testRuns
            }
        }

        /// Deletes a single test series
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var testSeries: TestSeries {
        TestSeries(path: path + "/test_series")
    }

    public struct TestSeries {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test_series`
        public let path: String

        /// Returns list of all test series for an application
        public func get(query: String? = nil) -> Request<[GetResponseItem]> {
            .get(path, query: makeGetQuery(query))
        }

        /// Test Series
        ///
        /// Summary of a single test series
        public struct GetResponseItem: Decodable {
            /// Unique, human-readable identifier of the test series
            public var slug: String
            /// Name of the test series
            public var name: String
            /// Date of the latest test run that used this test series
            public var mostRecentActivity: String?
            /// Most recent test runs
            public var testRuns: [TestRun]?

            /// Test Run Summary
            ///
            /// Most important information about a test run.
            public struct TestRun: Decodable {
                /// Date of the test run.
                public var date: String?
                /// Human-readable status of the test run.
                public var statusDescription: String?
                /// Number of failed tests
                public var failed: Double?
                /// Number of passed tests
                public var passed: Double?
                /// Tells whether the test run has completed
                public var isCompleted: Bool?

                public init(date: String? = nil, statusDescription: String? = nil, failed: Double? = nil, passed: Double? = nil, isCompleted: Bool? = nil) {
                    self.date = date
                    self.statusDescription = statusDescription
                    self.failed = failed
                    self.passed = passed
                    self.isCompleted = isCompleted
                }

                private enum CodingKeys: String, CodingKey {
                    case date
                    case statusDescription
                    case failed
                    case passed
                    case isCompleted = "completed"
                }
            }

            public init(slug: String, name: String, mostRecentActivity: String? = nil, testRuns: [TestRun]? = nil) {
                self.slug = slug
                self.name = name
                self.mostRecentActivity = mostRecentActivity
                self.testRuns = testRuns
            }
        }

        private func makeGetQuery(_ query: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(query, forKey: "query")
            return encoder.items
        }

        /// Creates new test series for an application
        public func post(name: String) -> Request<PostResponse> {
            .post(path, body: ["name": name])
        }

        /// Test Series
        ///
        /// Summary of a single test series
        public struct PostResponse: Decodable {
            /// Unique, human-readable identifier of the test series
            public var slug: String
            /// Name of the test series
            public var name: String
            /// Date of the latest test run that used this test series
            public var mostRecentActivity: String?
            /// Most recent test runs
            public var testRuns: [TestRun]?

            /// Test Run Summary
            ///
            /// Most important information about a test run.
            public struct TestRun: Decodable {
                /// Date of the test run.
                public var date: String?
                /// Human-readable status of the test run.
                public var statusDescription: String?
                /// Number of failed tests
                public var failed: Double?
                /// Number of passed tests
                public var passed: Double?
                /// Tells whether the test run has completed
                public var isCompleted: Bool?

                public init(date: String? = nil, statusDescription: String? = nil, failed: Double? = nil, passed: Double? = nil, isCompleted: Bool? = nil) {
                    self.date = date
                    self.statusDescription = statusDescription
                    self.failed = failed
                    self.passed = passed
                    self.isCompleted = isCompleted
                }

                private enum CodingKeys: String, CodingKey {
                    case date
                    case statusDescription
                    case failed
                    case passed
                    case isCompleted = "completed"
                }
            }

            public init(slug: String, name: String, mostRecentActivity: String? = nil, testRuns: [TestRun]? = nil) {
                self.slug = slug
                self.name = name
                self.mostRecentActivity = mostRecentActivity
                self.testRuns = testRuns
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.TestRuns.WithTestRunID {
    public var stop: Stop {
        Stop(path: path + "/stop")
    }

    public struct Stop {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test_runs/{test_run_id}/stop`
        public let path: String

        /// Stop a test run execution
        public var put: Request<PutResponse> {
            .put(path)
        }

        /// Test Run
        ///
        /// Summary single test run on Xamarin Test Cloud
        public struct PutResponse: Decodable {
            /// The unique id of the test upload
            public var id: String?
            /// The date and time the test was uploaded
            public var date: String?
            /// The compiled version of the app binary
            public var appVersion: String?
            /// The name of the test series with which this test upload is associated
            public var testSeries: String?
            /// The device platform targeted by the test. Possible values are 'ios' or 'android'
            public var platform: String?
            /// The current status of the test run, in relation to the various phases
            public var runStatus: String?
            /// The passed/failed state
            public var resultStatus: String?
            /// Deprecated. Use runStatus instead.
            public var state: String?
            /// Deprecated. Use resultStatus instead.
            public var status: String?
            /// Human readable explanation of the current test status
            public var description: String?
            /// Test Run Statistics
            ///
            /// Summary single test run on Xamarin Test Cloud
            public var stats: Stats?
            /// The name of the test framework used to run this test
            public var testType: String?

            /// Test Run Statistics
            ///
            /// Summary single test run on Xamarin Test Cloud
            public struct Stats: Decodable {
                /// Number of devices running the test
                public var devices: Double?
                /// Number of finished devices
                public var devicesFinished: Double?
                /// Number of failed devices
                public var devicesFailed: Double?
                /// Number of tests in total
                public var total: Double?
                /// Number of passed tests
                public var passed: Double?
                /// Number of failed tests
                public var failed: Double?
                /// Number of skipped tests
                public var skipped: Double?
                /// The max amount of MB used during the test run
                public var peakMemory: Double?
                /// The number of minutes of device time the test has been runnign
                public var totalDeviceMinutes: Double?

                public init(devices: Double? = nil, devicesFinished: Double? = nil, devicesFailed: Double? = nil, total: Double? = nil, passed: Double? = nil, failed: Double? = nil, skipped: Double? = nil, peakMemory: Double? = nil, totalDeviceMinutes: Double? = nil) {
                    self.devices = devices
                    self.devicesFinished = devicesFinished
                    self.devicesFailed = devicesFailed
                    self.total = total
                    self.passed = passed
                    self.failed = failed
                    self.skipped = skipped
                    self.peakMemory = peakMemory
                    self.totalDeviceMinutes = totalDeviceMinutes
                }
            }

            public init(id: String? = nil, date: String? = nil, appVersion: String? = nil, testSeries: String? = nil, platform: String? = nil, runStatus: String? = nil, resultStatus: String? = nil, state: String? = nil, status: String? = nil, description: String? = nil, stats: Stats? = nil, testType: String? = nil) {
                self.id = id
                self.date = date
                self.appVersion = appVersion
                self.testSeries = testSeries
                self.platform = platform
                self.runStatus = runStatus
                self.resultStatus = resultStatus
                self.state = state
                self.status = status
                self.description = description
                self.stats = stats
                self.testType = testType
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.TestRuns.WithTestRunID {
    public var state: State {
        State(path: path + "/state")
    }

    public struct State {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test_runs/{test_run_id}/state`
        public let path: String

        /// Gets state of the test run
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Test Run State
        ///
        /// Current status of a test run
        public struct GetResponse: Decodable {
            /// Multi-line message that describes the status
            public var message: [String]?
            /// Time (in seconds) that the client should wait for before checking the status again
            public var waitTime: Int?
            /// The exit code that the client should use when exiting. Used for indicating status to the caller of the client.
            /// 0: test run completes with no failing tests
            /// 1: test run completes with at least one failing test
            /// 2: test run failed to complete. Status for test run is unknown
            public var exitCode: Int?

            public init(message: [String]? = nil, waitTime: Int? = nil, exitCode: Int? = nil) {
                self.message = message
                self.waitTime = waitTime
                self.exitCode = exitCode
            }

            private enum CodingKeys: String, CodingKey {
                case message
                case waitTime = "wait_time"
                case exitCode = "exit_code"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.TestRuns.WithTestRunID {
    public var start: Start {
        Start(path: path + "/start")
    }

    public struct Start {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test_runs/{test_run_id}/start`
        public let path: String

        /// Starts test run
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        /// Test Cloud Test Run Start Result
        ///
        /// Result of starting a test run
        public struct PostResponse: Decodable {
            /// List with names of accepted devices
            public var acceptedDevices: [String]?
            /// List with names and descriptions of rejected devices
            public var rejectedDevices: [String]?

            public init(acceptedDevices: [String]? = nil, rejectedDevices: [String]? = nil) {
                self.acceptedDevices = acceptedDevices
                self.rejectedDevices = rejectedDevices
            }

            private enum CodingKeys: String, CodingKey {
                case acceptedDevices = "accepted_devices"
                case rejectedDevices = "rejected_devices"
            }
        }

        /// Test Cloud Start Test Run Options
        ///
        /// Options required to start the test run
        public struct PostRequest: Encodable {
            /// Test framework used by tests.
            public var testFramework: String
            /// Device selection string.
            public var deviceSelection: String
            /// Language that should be used to run tests.
            public var language: String?
            /// Locale that should be used to run tests.
            public var locale: String?
            /// Name of the test series.
            public var testSeries: String?
            /// A JSON dictionary with additional test parameters
            public var testParameters: [String: AnyJSON]?

            public init(testFramework: String, deviceSelection: String, language: String? = nil, locale: String? = nil, testSeries: String? = nil, testParameters: [String: AnyJSON]? = nil) {
                self.testFramework = testFramework
                self.deviceSelection = deviceSelection
                self.language = language
                self.locale = locale
                self.testSeries = testSeries
                self.testParameters = testParameters
            }

            private enum CodingKeys: String, CodingKey {
                case testFramework = "test_framework"
                case deviceSelection = "device_selection"
                case language
                case locale
                case testSeries = "test_series"
                case testParameters = "test_parameters"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.TestRuns.WithTestRunID {
    public var report: Report {
        Report(path: path + "/report")
    }

    public struct Report {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test_runs/{test_run_id}/report`
        public let path: String

        /// Returns a single test report
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.TestRuns.WithTestRunID.Hashes {
    public var batch: Batch {
        Batch(path: path + "/batch")
    }

    public struct Batch {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test_runs/{test_run_id}/hashes/batch`
        public let path: String

        /// Adds file with the given hash to a test run
        public func post(_ body: [PostRequestItem]) -> Request<[PostResponseItem]> {
            .post(path, body: body)
        }

        /// Test Cloud File Hash Response
        ///
        /// Response message for single uploaded file hash
        public struct PostResponseItem: Decodable {
            /// Type of the file
            public var fileType: FileType
            /// SHA256 hash of the file
            public var checksum: String
            /// Relative path of the file
            public var relativePath: String?
            /// Test Cloud Hash Upload Status
            ///
            /// Status of the upload
            public var uploadStatus: UploadStatus

            /// Type of the file
            public enum FileType: String, Codable, CaseIterable {
                case dsymFile = "dsym-file"
                case appFile = "app-file"
                case testFile = "test-file"
            }

            /// Test Cloud Hash Upload Status
            ///
            /// Status of the upload
            public struct UploadStatus: Decodable {
                /// HTTP status code that represent result of upload
                public var statusCode: Double
                /// URI that should be used to make POST request if file with given hash doesn't exist. This is set when status_code is equal to 412
                public var location: String?

                public init(statusCode: Double, location: String? = nil) {
                    self.statusCode = statusCode
                    self.location = location
                }
            }

            public init(fileType: FileType, checksum: String, relativePath: String? = nil, uploadStatus: UploadStatus) {
                self.fileType = fileType
                self.checksum = checksum
                self.relativePath = relativePath
                self.uploadStatus = uploadStatus
            }
        }

        /// Test Cloud File Hash
        ///
        /// Hash, type, path and byte range of a file that is required in test run
        public struct PostRequestItem: Encodable {
            /// Type of the file
            public var fileType: FileType
            /// SHA256 hash of the file
            public var checksum: String
            /// Relative path of the file
            public var relativePath: String

            /// Type of the file
            public enum FileType: String, Codable, CaseIterable {
                case dsymFile = "dsym-file"
                case appFile = "app-file"
                case testFile = "test-file"
            }

            public init(fileType: FileType, checksum: String, relativePath: String) {
                self.fileType = fileType
                self.checksum = checksum
                self.relativePath = relativePath
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.TestRuns.WithTestRunID {
    public var hashes: Hashes {
        Hashes(path: path + "/hashes")
    }

    public struct Hashes {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test_runs/{test_run_id}/hashes`
        public let path: String

        /// Adds file with the given hash to a test run
        public func post(_ body: PostRequest) -> Request<Void> {
            .post(path, body: body)
        }

        /// Test Cloud File Hash
        ///
        /// Hash, type, path and byte range of a file that is required in test run
        public struct PostRequest: Encodable {
            /// Type of the file
            public var fileType: FileType
            /// SHA256 hash of the file
            public var checksum: String
            /// Relative path of the file
            public var relativePath: String
            /// Range of bytes required to verify ownership of the file
            public var byteRange: String?

            /// Type of the file
            public enum FileType: String, Codable, CaseIterable {
                case dsymFile = "dsym-file"
                case appFile = "app-file"
                case testFile = "test-file"
            }

            public init(fileType: FileType, checksum: String, relativePath: String, byteRange: String? = nil) {
                self.fileType = fileType
                self.checksum = checksum
                self.relativePath = relativePath
                self.byteRange = byteRange
            }

            private enum CodingKeys: String, CodingKey {
                case fileType = "file_type"
                case checksum
                case relativePath = "relative_path"
                case byteRange = "byte_range"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.TestRuns.WithTestRunID {
    public var files: Files {
        Files(path: path + "/files")
    }

    public struct Files {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test_runs/{test_run_id}/files`
        public let path: String

        /// Uploads file for a test run
        public var post: Request<Void> {
            .post(path)
        }

        public enum PostResponseHeaders {
            /// Relative URL that points to the upload endpoint
            public static let location = HTTPHeader<String>(field: "Location")
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.TestRuns {
    public func testRunID(_ testRunID: String) -> WithTestRunID {
        WithTestRunID(path: "\(path)/\(testRunID)")
    }

    public struct WithTestRunID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test_runs/{test_run_id}`
        public let path: String

        /// Returns a single test runs
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Test Run
        ///
        /// Summary single test run on Xamarin Test Cloud
        public struct GetResponse: Decodable {
            /// The unique id of the test upload
            public var id: String?
            /// The date and time the test was uploaded
            public var date: String?
            /// The compiled version of the app binary
            public var appVersion: String?
            /// The name of the test series with which this test upload is associated
            public var testSeries: String?
            /// The device platform targeted by the test. Possible values are 'ios' or 'android'
            public var platform: String?
            /// The current status of the test run, in relation to the various phases
            public var runStatus: String?
            /// The passed/failed state
            public var resultStatus: String?
            /// Deprecated. Use runStatus instead.
            public var state: String?
            /// Deprecated. Use resultStatus instead.
            public var status: String?
            /// Human readable explanation of the current test status
            public var description: String?
            /// Test Run Statistics
            ///
            /// Summary single test run on Xamarin Test Cloud
            public var stats: Stats?
            /// The name of the test framework used to run this test
            public var testType: String?

            /// Test Run Statistics
            ///
            /// Summary single test run on Xamarin Test Cloud
            public struct Stats: Decodable {
                /// Number of devices running the test
                public var devices: Double?
                /// Number of finished devices
                public var devicesFinished: Double?
                /// Number of failed devices
                public var devicesFailed: Double?
                /// Number of tests in total
                public var total: Double?
                /// Number of passed tests
                public var passed: Double?
                /// Number of failed tests
                public var failed: Double?
                /// Number of skipped tests
                public var skipped: Double?
                /// The max amount of MB used during the test run
                public var peakMemory: Double?
                /// The number of minutes of device time the test has been runnign
                public var totalDeviceMinutes: Double?

                public init(devices: Double? = nil, devicesFinished: Double? = nil, devicesFailed: Double? = nil, total: Double? = nil, passed: Double? = nil, failed: Double? = nil, skipped: Double? = nil, peakMemory: Double? = nil, totalDeviceMinutes: Double? = nil) {
                    self.devices = devices
                    self.devicesFinished = devicesFinished
                    self.devicesFailed = devicesFailed
                    self.total = total
                    self.passed = passed
                    self.failed = failed
                    self.skipped = skipped
                    self.peakMemory = peakMemory
                    self.totalDeviceMinutes = totalDeviceMinutes
                }
            }

            public init(id: String? = nil, date: String? = nil, appVersion: String? = nil, testSeries: String? = nil, platform: String? = nil, runStatus: String? = nil, resultStatus: String? = nil, state: String? = nil, status: String? = nil, description: String? = nil, stats: Stats? = nil, testType: String? = nil) {
                self.id = id
                self.date = date
                self.appVersion = appVersion
                self.testSeries = testSeries
                self.platform = platform
                self.runStatus = runStatus
                self.resultStatus = resultStatus
                self.state = state
                self.status = status
                self.description = description
                self.stats = stats
                self.testType = testType
            }
        }

        /// Logically deletes a test run
        public var delete: Request<DeleteResponse> {
            .delete(path)
        }

        /// Test Run
        ///
        /// Summary single test run on Xamarin Test Cloud
        public struct DeleteResponse: Decodable {
            /// The unique id of the test upload
            public var id: String?
            /// The date and time the test was uploaded
            public var date: String?
            /// The compiled version of the app binary
            public var appVersion: String?
            /// The name of the test series with which this test upload is associated
            public var testSeries: String?
            /// The device platform targeted by the test. Possible values are 'ios' or 'android'
            public var platform: String?
            /// The current status of the test run, in relation to the various phases
            public var runStatus: String?
            /// The passed/failed state
            public var resultStatus: String?
            /// Deprecated. Use runStatus instead.
            public var state: String?
            /// Deprecated. Use resultStatus instead.
            public var status: String?
            /// Human readable explanation of the current test status
            public var description: String?
            /// Test Run Statistics
            ///
            /// Summary single test run on Xamarin Test Cloud
            public var stats: Stats?
            /// The name of the test framework used to run this test
            public var testType: String?

            /// Test Run Statistics
            ///
            /// Summary single test run on Xamarin Test Cloud
            public struct Stats: Decodable {
                /// Number of devices running the test
                public var devices: Double?
                /// Number of finished devices
                public var devicesFinished: Double?
                /// Number of failed devices
                public var devicesFailed: Double?
                /// Number of tests in total
                public var total: Double?
                /// Number of passed tests
                public var passed: Double?
                /// Number of failed tests
                public var failed: Double?
                /// Number of skipped tests
                public var skipped: Double?
                /// The max amount of MB used during the test run
                public var peakMemory: Double?
                /// The number of minutes of device time the test has been runnign
                public var totalDeviceMinutes: Double?

                public init(devices: Double? = nil, devicesFinished: Double? = nil, devicesFailed: Double? = nil, total: Double? = nil, passed: Double? = nil, failed: Double? = nil, skipped: Double? = nil, peakMemory: Double? = nil, totalDeviceMinutes: Double? = nil) {
                    self.devices = devices
                    self.devicesFinished = devicesFinished
                    self.devicesFailed = devicesFailed
                    self.total = total
                    self.passed = passed
                    self.failed = failed
                    self.skipped = skipped
                    self.peakMemory = peakMemory
                    self.totalDeviceMinutes = totalDeviceMinutes
                }
            }

            public init(id: String? = nil, date: String? = nil, appVersion: String? = nil, testSeries: String? = nil, platform: String? = nil, runStatus: String? = nil, resultStatus: String? = nil, state: String? = nil, status: String? = nil, description: String? = nil, stats: Stats? = nil, testType: String? = nil) {
                self.id = id
                self.date = date
                self.appVersion = appVersion
                self.testSeries = testSeries
                self.platform = platform
                self.runStatus = runStatus
                self.resultStatus = resultStatus
                self.state = state
                self.status = status
                self.description = description
                self.stats = stats
                self.testType = testType
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var testRuns: TestRuns {
        TestRuns(path: path + "/test_runs")
    }

    public struct TestRuns {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test_runs`
        public let path: String

        /// Returns a list of test runs
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        /// Test Run
        ///
        /// Summary single test run on Xamarin Test Cloud
        public struct GetResponseItem: Decodable {
            /// The unique id of the test upload
            public var id: String?
            /// The date and time the test was uploaded
            public var date: String?
            /// The compiled version of the app binary
            public var appVersion: String?
            /// The name of the test series with which this test upload is associated
            public var testSeries: String?
            /// The device platform targeted by the test. Possible values are 'ios' or 'android'
            public var platform: String?
            /// The current status of the test run, in relation to the various phases
            public var runStatus: String?
            /// The passed/failed state
            public var resultStatus: String?
            /// Deprecated. Use runStatus instead.
            public var state: String?
            /// Deprecated. Use resultStatus instead.
            public var status: String?
            /// Human readable explanation of the current test status
            public var description: String?
            /// Test Run Statistics
            ///
            /// Summary single test run on Xamarin Test Cloud
            public var stats: Stats?
            /// The name of the test framework used to run this test
            public var testType: String?

            /// Test Run Statistics
            ///
            /// Summary single test run on Xamarin Test Cloud
            public struct Stats: Decodable {
                /// Number of devices running the test
                public var devices: Double?
                /// Number of finished devices
                public var devicesFinished: Double?
                /// Number of failed devices
                public var devicesFailed: Double?
                /// Number of tests in total
                public var total: Double?
                /// Number of passed tests
                public var passed: Double?
                /// Number of failed tests
                public var failed: Double?
                /// Number of skipped tests
                public var skipped: Double?
                /// The max amount of MB used during the test run
                public var peakMemory: Double?
                /// The number of minutes of device time the test has been runnign
                public var totalDeviceMinutes: Double?

                public init(devices: Double? = nil, devicesFinished: Double? = nil, devicesFailed: Double? = nil, total: Double? = nil, passed: Double? = nil, failed: Double? = nil, skipped: Double? = nil, peakMemory: Double? = nil, totalDeviceMinutes: Double? = nil) {
                    self.devices = devices
                    self.devicesFinished = devicesFinished
                    self.devicesFailed = devicesFailed
                    self.total = total
                    self.passed = passed
                    self.failed = failed
                    self.skipped = skipped
                    self.peakMemory = peakMemory
                    self.totalDeviceMinutes = totalDeviceMinutes
                }
            }

            public init(id: String? = nil, date: String? = nil, appVersion: String? = nil, testSeries: String? = nil, platform: String? = nil, runStatus: String? = nil, resultStatus: String? = nil, state: String? = nil, status: String? = nil, description: String? = nil, stats: Stats? = nil, testType: String? = nil) {
                self.id = id
                self.date = date
                self.appVersion = appVersion
                self.testSeries = testSeries
                self.platform = platform
                self.runStatus = runStatus
                self.resultStatus = resultStatus
                self.state = state
                self.status = status
                self.description = description
                self.stats = stats
                self.testType = testType
            }
        }

        /// Creates a new test run
        public var post: Request<Void> {
            .post(path)
        }

        public enum PostResponseHeaders {
            /// Relative URL that points to the test run
            public static let location = HTTPHeader<String>(field: "Location")
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var test: Test {
        Test(path: path + "/test")
    }

    public struct Test {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Test.Export {
    public var testRuns: TestRuns {
        TestRuns(path: path + "/testRuns")
    }

    public struct TestRuns {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test/export/testRuns`
        public let path: String

        /// Lists test run data
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var id: String?
            public var appHashFileID: String?
            public var locale: String?
            public var dsymHashFileID: String?
            public var appHashFileURL: String?
            public var dsymHashFileURL: String?
            public var appIconURL: String?

            public init(id: String? = nil, appHashFileID: String? = nil, locale: String? = nil, dsymHashFileID: String? = nil, appHashFileURL: String? = nil, dsymHashFileURL: String? = nil, appIconURL: String? = nil) {
                self.id = id
                self.appHashFileID = appHashFileID
                self.locale = locale
                self.dsymHashFileID = dsymHashFileID
                self.appHashFileURL = appHashFileURL
                self.dsymHashFileURL = dsymHashFileURL
                self.appIconURL = appIconURL
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case appHashFileID = "app_hash_file_id"
                case locale
                case dsymHashFileID = "dsym_hash_file_id"
                case appHashFileURL = "app_hash_file_url"
                case dsymHashFileURL = "dsym_hash_file_url"
                case appIconURL = "app_icon_url"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Test.Export {
    public var pipelineTests: PipelineTests {
        PipelineTests(path: path + "/pipelineTests")
    }

    public struct PipelineTests {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test/export/pipelineTests`
        public let path: String

        /// Lists pipeline test data
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var appUploadID: String?
            public var testParameters: [String: AnyJSON]?

            public init(appUploadID: String? = nil, testParameters: [String: AnyJSON]? = nil) {
                self.appUploadID = appUploadID
                self.testParameters = testParameters
            }

            private enum CodingKeys: String, CodingKey {
                case appUploadID = "app_upload_id"
                case testParameters = "test_parameters"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Test.Export {
    public var hashFiles: HashFiles {
        HashFiles(path: path + "/hashFiles")
    }

    public struct HashFiles {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test/export/hashFiles`
        public let path: String

        /// Lists hash file data
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var id: String?
            public var filename: String?

            public init(id: String? = nil, filename: String? = nil) {
                self.id = id
                self.filename = filename
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Test.Export {
    public var fileSetFiles: FileSetFiles {
        FileSetFiles(path: path + "/fileSetFiles")
    }

    public struct FileSetFiles {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test/export/fileSetFiles`
        public let path: String

        /// Lists file set file data
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var path: String?
            public var hashFileID: String?
            public var appUploadID: String?
            public var hashFileURL: String?

            public init(path: String? = nil, hashFileID: String? = nil, appUploadID: String? = nil, hashFileURL: String? = nil) {
                self.path = path
                self.hashFileID = hashFileID
                self.appUploadID = appUploadID
                self.hashFileURL = hashFileURL
            }

            private enum CodingKeys: String, CodingKey {
                case path
                case hashFileID = "hash_file_id"
                case appUploadID = "app_upload_id"
                case hashFileURL = "hash_file_url"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Test.Export {
    public var apps: Apps {
        Apps(path: path + "/apps")
    }

    public struct Apps {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test/export/apps`
        public let path: String

        /// Lists app data
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var hashFilesURL: String?

            public init(hashFilesURL: String? = nil) {
                self.hashFilesURL = hashFilesURL
            }

            private enum CodingKeys: String, CodingKey {
                case hashFilesURL = "hash_files_url"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Test {
    public var export: Export {
        Export(path: path + "/export")
    }

    public struct Export {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/test/export`
        public let path: String

        /// Lists all the endpoints available for Test apps data
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var resources: [Resource]?

            public struct Resource: Decodable {
                public var rel: String?
                public var path: String?

                public init(rel: String? = nil, path: String? = nil) {
                    self.rel = rel
                    self.path = path
                }
            }

            public init(resources: [Resource]? = nil) {
                self.resources = resources
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var teams: Teams {
        Teams(path: path + "/teams")
    }

    public struct Teams {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/teams`
        public let path: String

        /// Returns the details of all teams that have access to the app.
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The internal unique id (UUID) of the team.
            public var id: String
            /// The name of the team
            public var name: String
            /// The display name of the team
            public var displayName: String
            /// The description of the team
            public var description: String?
            /// The permissions the team has for the app
            public var permissions: [Permission]?

            public enum Permission: String, Codable, CaseIterable {
                case manager
                case developer
                case viewer
                case tester
            }

            public init(id: String, name: String, displayName: String, description: String? = nil, permissions: [Permission]? = nil) {
                self.id = id
                self.name = name
                self.displayName = displayName
                self.description = description
                self.permissions = permissions
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decode(String.self, forKey: "id")
                self.name = try values.decode(String.self, forKey: "name")
                self.displayName = try values.decode(String.self, forKey: "display_name")
                self.description = try values.decodeIfPresent(String.self, forKey: "description")
                self.permissions = try values.decodeIfPresent([Permission].self, forKey: "permissions")
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Symbols.WithSymbolID {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/symbols/{symbol_id}/status`
        public let path: String

        /// Returns a particular symbol by id (uuid) for the provided application
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Symbols.WithSymbolID {
    public var location: Location {
        Location(path: path + "/location")
    }

    public struct Location {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/symbols/{symbol_id}/location`
        public let path: String

        /// Gets the URL to download the symbol
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Location for downloading symbol
        public struct GetResponse: Decodable {
            public var uri: String

            public init(uri: String) {
                self.uri = uri
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Symbols.WithSymbolID {
    public var ignore: Ignore {
        Ignore(path: path + "/ignore")
    }

    public struct Ignore {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/symbols/{symbol_id}/ignore`
        public let path: String

        /// Marks a symbol by id (uuid) as ignored
        public var post: Request<[String: AnyJSON]> {
            .post(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Symbols {
    public func symbolID(_ symbolID: String) -> WithSymbolID {
        WithSymbolID(path: "\(path)/\(symbolID)")
    }

    public struct WithSymbolID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/symbols/{symbol_id}`
        public let path: String

        /// Returns a particular symbol by id (uuid) for the provided application
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var symbols: Symbols {
        Symbols(path: path + "/symbols")
    }

    public struct Symbols {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/symbols`
        public let path: String

        /// Returns the list of all symbols for the provided application
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The unique id for this symbol (uuid)
            public var symbolID: String
            /// The type of the symbol for the current symbol upload
            public var type: `Type`
            /// The application that this symbol belongs to
            public var appID: String
            /// The platform that this symbol is associated with
            public var platform: String
            /// The path name of the symbol file in blob storage
            public var url: String
            /// The origin of the symbol file
            public var origin: Origin
            /// The other symbols in the same file
            public var alternateSymbolIDs: [String]
            /// Whether the symbol is ignored.
            public var status: Status
            /// The version number. Optional for Apple. Required for Android.
            public var version: String?
            /// The build number. Optional for Apple. Required for Android.
            public var build: String?
            /// The id of the symbol upload this symbol belongs to.
            public var symbolUploadID: String

            /// The type of the symbol for the current symbol upload
            public enum `Type`: String, Codable, CaseIterable {
                case apple = "Apple"
                case javaScript = "JavaScript"
                case breakpad = "Breakpad"
                case androidProguard = "AndroidProguard"
                case uwp = "UWP"
            }

            /// The origin of the symbol file
            public enum Origin: String, Codable, CaseIterable {
                case system = "System"
                case user = "User"
            }

            /// Whether the symbol is ignored.
            public enum Status: String, Codable, CaseIterable {
                case available
                case ignored
            }

            public init(symbolID: String, type: `Type`, appID: String, platform: String, url: String, origin: Origin, alternateSymbolIDs: [String], status: Status, version: String? = nil, build: String? = nil, symbolUploadID: String) {
                self.symbolID = symbolID
                self.type = type
                self.appID = appID
                self.platform = platform
                self.url = url
                self.origin = origin
                self.alternateSymbolIDs = alternateSymbolIDs
                self.status = status
                self.version = version
                self.build = build
                self.symbolUploadID = symbolUploadID
            }

            private enum CodingKeys: String, CodingKey {
                case symbolID = "symbol_id"
                case type
                case appID = "app_id"
                case platform
                case url
                case origin
                case alternateSymbolIDs = "alternate_symbol_ids"
                case status
                case version
                case build
                case symbolUploadID = "symbol_upload_id"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.SymbolUploads.WithSymbolUploadID {
    public var location: Location {
        Location(path: path + "/location")
    }

    public struct Location {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/symbol_uploads/{symbol_upload_id}/location`
        public let path: String

        /// Gets the URL to download the symbol upload
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Location for downloading symbol upload
        public struct GetResponse: Decodable {
            public var uri: String

            public init(uri: String) {
                self.uri = uri
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.SymbolUploads {
    public func symbolUploadID(_ symbolUploadID: String) -> WithSymbolUploadID {
        WithSymbolUploadID(path: "\(path)/\(symbolUploadID)")
    }

    public struct WithSymbolUploadID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/symbol_uploads/{symbol_upload_id}`
        public let path: String

        /// Gets a symbol upload by id for the specified application
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Commits or aborts the symbol upload process for a new set of symbols for the specified application
        public func patch(status: PatchRequest.Status) -> Request<[String: AnyJSON]> {
            .patch(path, body: PatchRequest(status: status))
        }

        /// A request containing information pertaining to completing a symbol upload process
        public struct PatchRequest: Encodable {
            /// The desired operation for the symbol upload
            public var status: Status

            /// The desired operation for the symbol upload
            public enum Status: String, Codable, CaseIterable {
                case committed
                case aborted
            }

            public init(status: Status) {
                self.status = status
            }
        }

        /// Deletes a symbol upload by id for the specified application
        public var delete: Request<[String: AnyJSON]> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var symbolUploads: SymbolUploads {
        SymbolUploads(path: path + "/symbol_uploads")
    }

    public struct SymbolUploads {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/symbol_uploads`
        public let path: String

        /// Gets a list of all uploads for the specified application
        public func get(parameters: GetParameters? = nil) -> Request<[GetResponseItem]> {
            .get(path, query: parameters?.asQuery)
        }

        /// A single symbol upload entity
        public struct GetResponseItem: Decodable {
            /// The id for the current symbol upload
            public var symbolUploadID: String
            /// The application that this symbol upload belongs to
            public var appID: String
            /// User information of the one who intitiated the symbol upload
            public var user: User?
            /// The current status for the symbol upload
            public var status: Status
            /// The type of the symbol for the current symbol upload
            public var symbolType: SymbolType
            /// The symbols found in the upload. This may be empty until the status is indexed
            public var symbolsUploaded: [SymbolsUploadedItem]?
            /// The origin of the symbol upload
            public var origin: Origin?
            /// The file name for the symbol upload
            public var fileName: String?
            /// The size of the file in Mebibytes. This may be 0 until the status is indexed
            public var fileSize: Double?
            /// When the symbol upload was committed, or last transaction time if not committed
            public var timestamp: Date?

            /// User information of the one who intitiated the symbol upload
            public struct User: Decodable {
                /// The email of the user
                public var email: String?
                /// The full name of the user. Might for example be first and last name
                public var displayName: String?

                public init(email: String? = nil, displayName: String? = nil) {
                    self.email = email
                    self.displayName = displayName
                }

                private enum CodingKeys: String, CodingKey {
                    case email
                    case displayName = "display_name"
                }
            }

            /// The current status for the symbol upload
            public enum Status: String, Codable, CaseIterable {
                case created
                case committed
                case aborted
                case processing
                case indexed
                case failed
            }

            /// The type of the symbol for the current symbol upload
            public enum SymbolType: String, Codable, CaseIterable {
                case apple = "Apple"
                case javaScript = "JavaScript"
                case breakpad = "Breakpad"
                case androidProguard = "AndroidProguard"
                case uwp = "UWP"
            }

            public struct SymbolsUploadedItem: Decodable {
                /// The symbol id of the symbol binary
                public var symbolID: String
                /// The platform the symbol is associated with
                public var platform: String

                public init(symbolID: String, platform: String) {
                    self.symbolID = symbolID
                    self.platform = platform
                }

                private enum CodingKeys: String, CodingKey {
                    case symbolID = "symbol_id"
                    case platform
                }
            }

            /// The origin of the symbol upload
            public enum Origin: String, Codable, CaseIterable {
                case user = "User"
                case system = "System"
            }

            public init(symbolUploadID: String, appID: String, user: User? = nil, status: Status, symbolType: SymbolType, symbolsUploaded: [SymbolsUploadedItem]? = nil, origin: Origin? = nil, fileName: String? = nil, fileSize: Double? = nil, timestamp: Date? = nil) {
                self.symbolUploadID = symbolUploadID
                self.appID = appID
                self.user = user
                self.status = status
                self.symbolType = symbolType
                self.symbolsUploaded = symbolsUploaded
                self.origin = origin
                self.fileName = fileName
                self.fileSize = fileSize
                self.timestamp = timestamp
            }

            private enum CodingKeys: String, CodingKey {
                case symbolUploadID = "symbol_upload_id"
                case appID = "app_id"
                case user
                case status
                case symbolType = "symbol_type"
                case symbolsUploaded = "symbols_uploaded"
                case origin
                case fileName = "file_name"
                case fileSize = "file_size"
                case timestamp
            }
        }

        public struct GetParameters {
            public var top: Int?
            public var status: Status?
            public var symbolType: SymbolType?

            public enum Status: String, Codable, CaseIterable {
                case all
                case uploaded
                case processed
            }

            public enum SymbolType: String, Codable, CaseIterable {
                case androidProguard = "AndroidProguard"
                case apple = "Apple"
                case breakpad = "Breakpad"
                case javaScript = "JavaScript"
                case uwp = "UWP"
            }

            public init(top: Int? = nil, status: Status? = nil, symbolType: SymbolType? = nil) {
                self.top = top
                self.status = status
                self.symbolType = symbolType
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(top, forKey: "top")
                encoder.encode(status, forKey: "status")
                encoder.encode(symbolType, forKey: "symbol_type")
                return encoder.items
            }
        }

        /// Begins the symbol upload process for a new set of symbols for the specified application
        public func post(_ body: PostRequest) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        /// A request containing information pertaining to starting a symbol upload process
        public struct PostRequest: Encodable {
            /// The type of the symbol for the current symbol upload
            public var symbolType: SymbolType
            /// The callback URL that the client can optionally provide to get status updates for the current symbol upload
            public var clientCallback: String?
            /// The file name for the symbol upload
            public var fileName: String?
            /// The build number. Optional for Apple. Required for Android.
            public var build: String?
            /// The version number. Optional for Apple. Required for Android.
            public var version: String?

            /// The type of the symbol for the current symbol upload
            public enum SymbolType: String, Codable, CaseIterable {
                case apple = "Apple"
                case javaScript = "JavaScript"
                case breakpad = "Breakpad"
                case androidProguard = "AndroidProguard"
                case uwp = "UWP"
            }

            public init(symbolType: SymbolType, clientCallback: String? = nil, fileName: String? = nil, build: String? = nil, version: String? = nil) {
                self.symbolType = symbolType
                self.clientCallback = clientCallback
                self.fileName = fileName
                self.build = build
                self.version = version
            }

            private enum CodingKeys: String, CodingKey {
                case symbolType = "symbol_type"
                case clientCallback = "client_callback"
                case fileName = "file_name"
                case build
                case version
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var subscriptions: Subscriptions {
        Subscriptions(path: path + "/subscriptions")
    }

    public struct Subscriptions {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/subscriptions`
        public let path: String

        /// Get information about the currently active subscriptions, if any
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Subscription
        ///
        /// Subscription information
        public struct GetResponse: Decodable {
            /// The date the subscription began
            public var startsAt: String?
            /// The date the subscription will end or ended
            public var endsAt: String?
            /// The number of days left in the subscription
            public var daysLeft: Double?
            /// Subscription Tier
            public var tier: Tier?
            /// Is the subscription currently active?
            public var isActive: Bool?
            /// Id of the subscription
            public var id: String?
            /// Customer limits on concurrent devices
            public var concurrentDevicesLimit: Int?
            /// Current device concurrency utilization
            public var runningDevices: Int?

            /// Subscription Tier
            public struct Tier: Decodable {
                /// The name of the tier
                public var name: String?

                public init(name: String? = nil) {
                    self.name = name
                }
            }

            public init(startsAt: String? = nil, endsAt: String? = nil, daysLeft: Double? = nil, tier: Tier? = nil, isActive: Bool? = nil, id: String? = nil, concurrentDevicesLimit: Int? = nil, runningDevices: Int? = nil) {
                self.startsAt = startsAt
                self.endsAt = endsAt
                self.daysLeft = daysLeft
                self.tier = tier
                self.isActive = isActive
                self.id = id
                self.concurrentDevicesLimit = concurrentDevicesLimit
                self.runningDevices = runningDevices
            }

            private enum CodingKeys: String, CodingKey {
                case startsAt
                case endsAt
                case daysLeft
                case tier
                case isActive = "active"
                case id
                case concurrentDevicesLimit
                case runningDevices
            }
        }

        /// Accept a free trial subscription
        public var post: Request<PostResponse> {
            .post(path)
        }

        /// Subscription
        ///
        /// Subscription information
        public struct PostResponse: Decodable {
            /// The date the subscription began
            public var startsAt: String?
            /// The date the subscription will end or ended
            public var endsAt: String?
            /// The number of days left in the subscription
            public var daysLeft: Double?
            /// Subscription Tier
            public var tier: Tier?
            /// Is the subscription currently active?
            public var isActive: Bool?
            /// Id of the subscription
            public var id: String?
            /// Customer limits on concurrent devices
            public var concurrentDevicesLimit: Int?
            /// Current device concurrency utilization
            public var runningDevices: Int?

            /// Subscription Tier
            public struct Tier: Decodable {
                /// The name of the tier
                public var name: String?

                public init(name: String? = nil) {
                    self.name = name
                }
            }

            public init(startsAt: String? = nil, endsAt: String? = nil, daysLeft: Double? = nil, tier: Tier? = nil, isActive: Bool? = nil, id: String? = nil, concurrentDevicesLimit: Int? = nil, runningDevices: Int? = nil) {
                self.startsAt = startsAt
                self.endsAt = endsAt
                self.daysLeft = daysLeft
                self.tier = tier
                self.isActive = isActive
                self.id = id
                self.concurrentDevicesLimit = concurrentDevicesLimit
                self.runningDevices = runningDevices
            }

            private enum CodingKeys: String, CodingKey {
                case startsAt
                case endsAt
                case daysLeft
                case tier
                case isActive = "active"
                case id
                case concurrentDevicesLimit
                case runningDevices
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var storeServiceStatus: StoreServiceStatus {
        StoreServiceStatus(path: path + "/store_service_status")
    }

    public struct StoreServiceStatus {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/store_service_status`
        public let path: String

        /// Application specific store service status
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var sourceHosts: SourceHosts {
        SourceHosts(path: path + "/source_hosts")
    }

    public struct SourceHosts {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/source_hosts`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.SourceHosts {
    public func sourceHost(_ sourceHost: String) -> WithSourceHost {
        WithSourceHost(path: "\(path)/\(sourceHost)")
    }

    public struct WithSourceHost {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/source_hosts/{source_host}`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.SourceHosts.WithSourceHost {
    public var repositories: Repositories {
        Repositories(path: path + "/repositories")
    }

    public struct Repositories {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/source_hosts/{source_host}/repositories`
        public let path: String

        /// Gets the repositories available from the source code host
        public func get(parameters: GetParameters? = nil) -> Request<[GetResponseItem]> {
            .get(path, query: parameters?.asQuery)
        }

        /// The source repository
        public struct GetResponseItem: Decodable {
            /// The repository name
            public var name: String?
            /// URL used to clone the repository
            public var cloneURL: String?

            public init(name: String? = nil, cloneURL: String? = nil) {
                self.name = name
                self.cloneURL = cloneURL
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case cloneURL = "clone_url"
            }
        }

        public struct GetParameters {
            public var vstsAccountName: String?
            public var vstsProjectID: String?
            public var serviceConnectionID: String?
            public var form: Form?

            public enum Form: String, Codable, CaseIterable {
                case lite
                case full
            }

            public init(vstsAccountName: String? = nil, vstsProjectID: String? = nil, serviceConnectionID: String? = nil, form: Form? = nil) {
                self.vstsAccountName = vstsAccountName
                self.vstsProjectID = vstsProjectID
                self.serviceConnectionID = serviceConnectionID
                self.form = form
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(vstsAccountName, forKey: "vstsAccountName")
                encoder.encode(vstsProjectID, forKey: "vstsProjectId")
                encoder.encode(serviceConnectionID, forKey: "service_connection_id")
                encoder.encode(form, forKey: "form")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var repoConfig: RepoConfig {
        RepoConfig(path: path + "/repo_config")
    }

    public struct RepoConfig {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/repo_config`
        public let path: String

        /// Returns the repository build configuration status of the app
        public func get(isIncludeInactive: Bool? = nil) -> Request<[GetResponseItem]> {
            .get(path, query: makeGetQuery(isIncludeInactive))
        }

        public struct GetResponseItem: Decodable {
            /// Repository configuration identifier
            public var id: String
            /// Type of repository
            public var type: String
            /// State of the configuration
            public var state: State
            /// Email of the user who linked the repository
            public var userEmail: String?

            /// State of the configuration
            public enum State: String, Codable, CaseIterable {
                case unauthorized
                case inactive
                case active
            }

            public init(id: String, type: String, state: State, userEmail: String? = nil) {
                self.id = id
                self.type = type
                self.state = state
                self.userEmail = userEmail
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case type
                case state
                case userEmail = "user_email"
            }
        }

        private func makeGetQuery(_ isIncludeInactive: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isIncludeInactive, forKey: "includeInactive")
            return encoder.items
        }

        /// Configures the repository for build
        public func post(_ body: PostRequest) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The repository's git url, must be a HTTPS URL
            ///
            /// Example: "https://github.com/foo/bar.git"
            public var repoURL: String?
            /// The repository id from the repository provider. Required for repositories connected from GitHub App and GitLab.com
            public var repoID: String?
            /// The external user id from the repository provider. Required for GitLab.com repositories
            public var externalUserID: String?
            /// The id of the service connection (private). Required for GitLab self-hosted repositories
            public var serviceConnectionID: String?

            public init(repoURL: String? = nil, repoID: String? = nil, externalUserID: String? = nil, serviceConnectionID: String? = nil) {
                self.repoURL = repoURL
                self.repoID = repoID
                self.externalUserID = externalUserID
                self.serviceConnectionID = serviceConnectionID
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(repoURL, forKey: "repo_url")
                try values.encodeIfPresent(repoID, forKey: "repo_id")
                try values.encodeIfPresent(externalUserID, forKey: "external_user_id")
                try values.encodeIfPresent(serviceConnectionID, forKey: "service_connection_id")
            }
        }

        /// Removes the configuration for the repository
        public var delete: Request<[String: AnyJSON]> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Releases.WithReleaseID {
    public var updateDevices: UpdateDevices {
        UpdateDevices(path: path + "/update_devices")
    }

    public struct UpdateDevices {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/update_devices`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Releases.WithReleaseID.UpdateDevices {
    public func resignID(_ resignID: String) -> WithResignID {
        WithResignID(path: "\(path)/\(resignID)")
    }

    public struct WithResignID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/update_devices/{resign_id}`
        public let path: String

        /// Returns the resign status to the caller
        public func get(isIncludeProvisioningProfile: Bool? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(isIncludeProvisioningProfile))
        }

        private func makeGetQuery(_ isIncludeProvisioningProfile: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isIncludeProvisioningProfile, forKey: "include_provisioning_profile")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Releases.WithReleaseID.Testers {
    public func testerID(_ testerID: String) -> WithTesterID {
        WithTesterID(path: "\(path)/\(testerID)")
    }

    public struct WithTesterID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/testers/{tester_id}`
        public let path: String

        /// Update details about the specified tester associated with the release
        public func put(isMandatoryUpdate: Bool) -> Request<Void> {
            .put(path, body: ["mandatory_update": isMandatoryUpdate])
        }

        /// Delete the given tester from the release
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Releases.WithReleaseID {
    public var testers: Testers {
        Testers(path: path + "/testers")
    }

    public struct Testers {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/testers`
        public let path: String

        /// Distributes a release to a user
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            /// Unique id for the release destination
            public var id: String
            /// Flag to mark the release for the provided destinations as mandatory
            public var isMandatoryUpdate: Bool
            /// The url to check provisioning status.
            public var provisioningStatusURL: String?

            public init(id: String, isMandatoryUpdate: Bool, provisioningStatusURL: String? = nil) {
                self.id = id
                self.isMandatoryUpdate = isMandatoryUpdate
                self.provisioningStatusURL = provisioningStatusURL
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case isMandatoryUpdate = "mandatory_update"
                case provisioningStatusURL = "provisioning_status_url"
            }
        }

        public struct PostRequest: Encodable {
            /// Flag to mark the release for the provided destinations as mandatory
            public var isMandatoryUpdate: Bool?
            /// Tester's email address
            public var email: String
            /// Flag to enable or disable notifications to testers
            public var isNotifyTesters: Bool

            public init(isMandatoryUpdate: Bool? = nil, email: String, isNotifyTesters: Bool? = nil) {
                self.isMandatoryUpdate = isMandatoryUpdate
                self.email = email
                self.isNotifyTesters = isNotifyTesters ?? true
            }

            private enum CodingKeys: String, CodingKey {
                case isMandatoryUpdate = "mandatory_update"
                case email
                case isNotifyTesters = "notify_testers"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Releases.WithReleaseID.Stores {
    public func storeID(_ storeID: String) -> WithStoreID {
        WithStoreID(path: "\(path)/\(storeID)")
    }

    public struct WithStoreID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/stores/{store_id}`
        public let path: String

        /// Delete the given distribution store from the release
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Releases.WithReleaseID {
    public var stores: Stores {
        Stores(path: path + "/stores")
    }

    public struct Stores {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/stores`
        public let path: String

        /// Distributes a release to a store
        public func post(id: String) -> Request<PostResponse> {
            .post(path, body: ["id": id])
        }

        public struct PostResponse: Decodable {
            /// Unique id for the release destination
            public var id: String

            public init(id: String) {
                self.id = id
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Releases.WithReleaseID {
    public var provisioningProfile: ProvisioningProfile {
        ProvisioningProfile(path: path + "/provisioning_profile")
    }

    public struct ProvisioningProfile {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/provisioning_profile`
        public let path: String

        /// Return information about the provisioning profile. Only available for iOS.
        public var get: Request<MicrosoftAppCenterAPI.ProvisioningProfileResponse> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Releases.WithReleaseID.Groups {
    public func groupID(_ groupID: String) -> WithGroupID {
        WithGroupID(path: "\(path)/\(groupID)")
    }

    public struct WithGroupID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/groups/{group_id}`
        public let path: String

        /// Update details about the specified distribution group associated with the release
        public func put(isMandatoryUpdate: Bool) -> Request<Void> {
            .put(path, body: ["mandatory_update": isMandatoryUpdate])
        }

        /// Delete the given distribution group from the release
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Releases.WithReleaseID {
    public var groups: Groups {
        Groups(path: path + "/groups")
    }

    public struct Groups {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/groups`
        public let path: String

        /// Distributes a release to a group
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            /// Unique id for the release destination
            public var id: String
            /// Flag to mark the release for the provided destinations as mandatory
            public var isMandatoryUpdate: Bool
            /// The url to check provisioning status.
            public var provisioningStatusURL: String?

            public init(id: String, isMandatoryUpdate: Bool, provisioningStatusURL: String? = nil) {
                self.id = id
                self.isMandatoryUpdate = isMandatoryUpdate
                self.provisioningStatusURL = provisioningStatusURL
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case isMandatoryUpdate = "mandatory_update"
                case provisioningStatusURL = "provisioning_status_url"
            }
        }

        public struct PostRequest: Encodable {
            /// Unique id of the release destination
            public var id: String
            /// Flag to mark the release for the provided destinations as mandatory
            public var isMandatoryUpdate: Bool?
            /// Flag to enable or disable notifications to testers
            public var isNotifyTesters: Bool

            public init(id: String, isMandatoryUpdate: Bool? = nil, isNotifyTesters: Bool? = nil) {
                self.id = id
                self.isMandatoryUpdate = isMandatoryUpdate
                self.isNotifyTesters = isNotifyTesters ?? true
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(id, forKey: "id")
                try values.encodeIfPresent(isMandatoryUpdate, forKey: "mandatory_update")
                try values.encodeIfPresent(isNotifyTesters, forKey: "notify_testers")
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Releases {
    public func releaseID(_ releaseID: String) -> WithReleaseID {
        WithReleaseID(path: "\(path)/\(releaseID)")
    }

    public struct WithReleaseID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}`
        public let path: String

        /// Get a release with id `release_id`. If `release_id` is `latest`, return the latest release that was distributed to the current user (from all the distribution groups).
        public func get(udid: String? = nil, isInstallPage: Bool? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(udid, isInstallPage))
        }

        private func makeGetQuery(_ udid: String?, _ isInstallPage: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(udid, forKey: "udid")
            encoder.encode(isInstallPage, forKey: "is_install_page")
            return encoder.items
        }

        /// Update details of a release.
        public func put(_ body: PutRequest) -> Request<[String: AnyJSON]> {
            .put(path, body: body)
        }

        /// A request containing information for updating details of a release
        public struct PutRequest: Encodable {
            /// Toggle this release to be enable distribute/download or not.
            public var isEnabled: Bool?
            /// Release notes for this release.
            public var releaseNotes: String?
            /// Contains metadata about the build that produced the release being uploaded
            public var build: Build?

            /// Contains metadata about the build that produced the release being uploaded
            public struct Build: Encodable {
                /// The branch name of the build producing the release
                public var branchName: String?
                /// The commit hash of the build producing the release
                public var commitHash: String?
                /// The commit message of the build producing the release
                public var commitMessage: String?

                public init(branchName: String? = nil, commitHash: String? = nil, commitMessage: String? = nil) {
                    self.branchName = branchName
                    self.commitHash = commitHash
                    self.commitMessage = commitMessage
                }

                private enum CodingKeys: String, CodingKey {
                    case branchName = "branch_name"
                    case commitHash = "commit_hash"
                    case commitMessage = "commit_message"
                }
            }

            public init(isEnabled: Bool? = nil, releaseNotes: String? = nil, build: Build? = nil) {
                self.isEnabled = isEnabled
                self.releaseNotes = releaseNotes
                self.build = build
            }

            private enum CodingKeys: String, CodingKey {
                case isEnabled = "enabled"
                case releaseNotes = "release_notes"
                case build
            }
        }

        /// Updates a release.
        public func patch(_ body: String) -> Request<[String: AnyJSON]> {
            .patch(path, body: body)
        }

        /// Deletes a release.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Releases {
    public var filterByTester: FilterByTester {
        FilterByTester(path: path + "/filter_by_tester")
    }

    public struct FilterByTester {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/releases/filter_by_tester`
        public let path: String

        /// Return detailed information about releases avaiable to a tester.
        @available(*, deprecated, message: "Deprecated")
        public func get(isPublishedOnly: Bool? = nil) -> Request<[GetResponseItem]> {
            .get(path, query: makeGetQuery(isPublishedOnly))
        }

        /// Basic information on a release
        public struct GetResponseItem: Decodable {
            /// ID identifying this unique release.
            public var id: Int
            /// The release's version.<br>
            /// For iOS: CFBundleVersion from info.plist.<br>
            /// For Android: android:versionCode from AppManifest.xml.
            public var version: String
            /// The release's origin
            public var origin: Origin?
            /// The release's short version.<br>
            /// For iOS: CFBundleShortVersionString from info.plist.<br>
            /// For Android: android:versionName from AppManifest.xml.
            public var shortVersion: String
            /// This value determines the whether a release currently is enabled or disabled.
            public var isEnabled: Bool
            /// UTC time in ISO 8601 format of the uploaded time.
            public var uploadedAt: String
            /// OBSOLETE. Will be removed in next version. The destination type.<br>
            /// <b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>
            /// <b>store</b>: The release distributed to external stores and distribution_stores details will be returned. <br>
            public var destinationType: DestinationType?
            /// OBSOLETE. Will be removed in next version. A list of distribution groups that are associated with this release.
            public var distributionGroups: [DistributionGroup]?
            /// OBSOLETE. Will be removed in next version. A list of distribution stores that are associated with this release.
            public var distributionStores: [DistributionStore]?
            /// A list of distribution groups or stores.
            public var destinations: [Destination]?
            /// Build information for the release
            public var build: Build?
            /// This value determines if a release is external or not.
            public var isExternalBuild: Bool?
            /// The file extension of the main (user-uploaded) package file.
            public var fileExtension: String?

            /// The release's origin
            public enum Origin: String, Codable, CaseIterable {
                case hockeyapp
                case appcenter
            }

            /// OBSOLETE. Will be removed in next version. The destination type.<br>
            /// <b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>
            /// <b>store</b>: The release distributed to external stores and distribution_stores details will be returned. <br>
            public enum DestinationType: String, Codable, CaseIterable {
                case group
                case store
                case tester
            }

            public struct DistributionGroup: Decodable {
                /// ID identifying a unique distribution group.
                public var id: String
                /// A name identifying a unique distribution group.
                public var name: String?
                /// Is the containing release the latest one in this distribution group.
                public var isLatest: Bool?

                public init(id: String, name: String? = nil, isLatest: Bool? = nil) {
                    self.id = id
                    self.name = name
                    self.isLatest = isLatest
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.id = try values.decode(String.self, forKey: "id")
                    self.name = try values.decodeIfPresent(String.self, forKey: "name")
                    self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
                }
            }

            public struct DistributionStore: Decodable {
                /// ID identifying a unique distribution store.
                public var id: String
                /// A name identifying a unique distribution store.
                public var name: String?
                /// Type of the distribution store currently stores type can be intune, googleplay or windows.
                public var type: `Type`?
                /// Publishing status of the release in the store.
                public var publishingStatus: String?
                /// Is the containing release the latest one in this distribution store.
                public var isLatest: Bool?

                /// Type of the distribution store currently stores type can be intune, googleplay or windows.
                public enum `Type`: String, Codable, CaseIterable {
                    case intune
                    case googleplay
                    case apple
                    case `none`
                }

                public init(id: String, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil, isLatest: Bool? = nil) {
                    self.id = id
                    self.name = name
                    self.type = type
                    self.publishingStatus = publishingStatus
                    self.isLatest = isLatest
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.id = try values.decode(String.self, forKey: "id")
                    self.name = try values.decodeIfPresent(String.self, forKey: "name")
                    self.type = try `Type`(from: decoder)
                    self.publishingStatus = try values.decodeIfPresent(String.self, forKey: "publishing_status")
                    self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
                }
            }

            public struct Destination: Decodable {
                public var a: A
                public var b: B
                /// Name of a distribution group / distribution store. The release will be associated with this distribution group or store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
                public var name: String?
                /// Id of a distribution group / store. The release will be associated with this distribution group / store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
                public var id: String?
                /// Destination can be either store or group.
                public var destinationType: DestinationType?
                /// Display name for the group or tester
                public var displayName: String?

                public struct A: Decodable {
                    /// ID identifying a unique distribution group.
                    public var id: String
                    /// A name identifying a unique distribution group.
                    public var name: String?
                    /// Is the containing release the latest one in this distribution group.
                    public var isLatest: Bool?

                    public init(id: String, name: String? = nil, isLatest: Bool? = nil) {
                        self.id = id
                        self.name = name
                        self.isLatest = isLatest
                    }

                    public init(from decoder: Decoder) throws {
                        let values = try decoder.container(keyedBy: StringCodingKey.self)
                        self.id = try values.decode(String.self, forKey: "id")
                        self.name = try values.decodeIfPresent(String.self, forKey: "name")
                        self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
                    }
                }

                public struct B: Decodable {
                    /// ID identifying a unique distribution store.
                    public var id: String
                    /// A name identifying a unique distribution store.
                    public var name: String?
                    /// Type of the distribution store currently stores type can be intune, googleplay or windows.
                    public var type: `Type`?
                    /// Publishing status of the release in the store.
                    public var publishingStatus: String?
                    /// Is the containing release the latest one in this distribution store.
                    public var isLatest: Bool?

                    /// Type of the distribution store currently stores type can be intune, googleplay or windows.
                    public enum `Type`: String, Codable, CaseIterable {
                        case intune
                        case googleplay
                        case apple
                        case `none`
                    }

                    public init(id: String, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil, isLatest: Bool? = nil) {
                        self.id = id
                        self.name = name
                        self.type = type
                        self.publishingStatus = publishingStatus
                        self.isLatest = isLatest
                    }

                    public init(from decoder: Decoder) throws {
                        let values = try decoder.container(keyedBy: StringCodingKey.self)
                        self.id = try values.decode(String.self, forKey: "id")
                        self.name = try values.decodeIfPresent(String.self, forKey: "name")
                        self.type = try `Type`(from: decoder)
                        self.publishingStatus = try values.decodeIfPresent(String.self, forKey: "publishing_status")
                        self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
                    }
                }

                /// Destination can be either store or group.
                public enum DestinationType: String, Codable, CaseIterable {
                    case group
                    case store
                    case tester
                }

                public init(a: A, b: B, name: String? = nil, id: String? = nil, destinationType: DestinationType? = nil, displayName: String? = nil) {
                    self.a = a
                    self.b = b
                    self.name = name
                    self.id = id
                    self.destinationType = destinationType
                    self.displayName = displayName
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.a = try A(from: decoder)
                    self.b = try B(from: decoder)
                    self.name = try values.decodeIfPresent(String.self, forKey: "name")
                    self.id = try values.decodeIfPresent(String.self, forKey: "id")
                    self.destinationType = try DestinationType(from: decoder)
                    self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
                }
            }

            /// Build information for the release
            public struct Build: Decodable {
                /// The branch name of the build producing the release
                public var branchName: String?
                /// The commit hash of the build producing the release
                public var commitHash: String?
                /// The commit message of the build producing the release
                public var commitMessage: String?

                public init(branchName: String? = nil, commitHash: String? = nil, commitMessage: String? = nil) {
                    self.branchName = branchName
                    self.commitHash = commitHash
                    self.commitMessage = commitMessage
                }

                private enum CodingKeys: String, CodingKey {
                    case branchName = "branch_name"
                    case commitHash = "commit_hash"
                    case commitMessage = "commit_message"
                }
            }

            public init(id: Int, version: String, origin: Origin? = nil, shortVersion: String, isEnabled: Bool, uploadedAt: String, destinationType: DestinationType? = nil, distributionGroups: [DistributionGroup]? = nil, distributionStores: [DistributionStore]? = nil, destinations: [Destination]? = nil, build: Build? = nil, isExternalBuild: Bool? = nil, fileExtension: String? = nil) {
                self.id = id
                self.version = version
                self.origin = origin
                self.shortVersion = shortVersion
                self.isEnabled = isEnabled
                self.uploadedAt = uploadedAt
                self.destinationType = destinationType
                self.distributionGroups = distributionGroups
                self.distributionStores = distributionStores
                self.destinations = destinations
                self.build = build
                self.isExternalBuild = isExternalBuild
                self.fileExtension = fileExtension
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case version
                case origin
                case shortVersion = "short_version"
                case isEnabled = "enabled"
                case uploadedAt = "uploaded_at"
                case destinationType = "destination_type"
                case distributionGroups = "distribution_groups"
                case distributionStores = "distribution_stores"
                case destinations
                case build
                case isExternalBuild = "is_external_build"
                case fileExtension = "file_extension"
            }
        }

        private func makeGetQuery(_ isPublishedOnly: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isPublishedOnly, forKey: "published_only")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var releases: Releases {
        Releases(path: path + "/releases")
    }

    public struct Releases {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/releases`
        public let path: String

        /// Return basic information about releases.
        public func get(isPublishedOnly: Bool? = nil, scope: String? = nil) -> Request<[GetResponseItem]> {
            .get(path, query: makeGetQuery(isPublishedOnly, scope))
        }

        /// Basic information on a release
        public struct GetResponseItem: Decodable {
            /// ID identifying this unique release.
            public var id: Int
            /// The release's version.<br>
            /// For iOS: CFBundleVersion from info.plist.<br>
            /// For Android: android:versionCode from AppManifest.xml.
            public var version: String
            /// The release's origin
            public var origin: Origin?
            /// The release's short version.<br>
            /// For iOS: CFBundleShortVersionString from info.plist.<br>
            /// For Android: android:versionName from AppManifest.xml.
            public var shortVersion: String
            /// This value determines the whether a release currently is enabled or disabled.
            public var isEnabled: Bool
            /// UTC time in ISO 8601 format of the uploaded time.
            public var uploadedAt: String
            /// OBSOLETE. Will be removed in next version. The destination type.<br>
            /// <b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>
            /// <b>store</b>: The release distributed to external stores and distribution_stores details will be returned. <br>
            public var destinationType: DestinationType?
            /// OBSOLETE. Will be removed in next version. A list of distribution groups that are associated with this release.
            public var distributionGroups: [DistributionGroup]?
            /// OBSOLETE. Will be removed in next version. A list of distribution stores that are associated with this release.
            public var distributionStores: [DistributionStore]?
            /// A list of distribution groups or stores.
            public var destinations: [Destination]?
            /// Build information for the release
            public var build: Build?
            /// This value determines if a release is external or not.
            public var isExternalBuild: Bool?
            /// The file extension of the main (user-uploaded) package file.
            public var fileExtension: String?

            /// The release's origin
            public enum Origin: String, Codable, CaseIterable {
                case hockeyapp
                case appcenter
            }

            /// OBSOLETE. Will be removed in next version. The destination type.<br>
            /// <b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>
            /// <b>store</b>: The release distributed to external stores and distribution_stores details will be returned. <br>
            public enum DestinationType: String, Codable, CaseIterable {
                case group
                case store
                case tester
            }

            public struct DistributionGroup: Decodable {
                /// ID identifying a unique distribution group.
                public var id: String
                /// A name identifying a unique distribution group.
                public var name: String?
                /// Is the containing release the latest one in this distribution group.
                public var isLatest: Bool?

                public init(id: String, name: String? = nil, isLatest: Bool? = nil) {
                    self.id = id
                    self.name = name
                    self.isLatest = isLatest
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.id = try values.decode(String.self, forKey: "id")
                    self.name = try values.decodeIfPresent(String.self, forKey: "name")
                    self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
                }
            }

            public struct DistributionStore: Decodable {
                /// ID identifying a unique distribution store.
                public var id: String
                /// A name identifying a unique distribution store.
                public var name: String?
                /// Type of the distribution store currently stores type can be intune, googleplay or windows.
                public var type: `Type`?
                /// Publishing status of the release in the store.
                public var publishingStatus: String?
                /// Is the containing release the latest one in this distribution store.
                public var isLatest: Bool?

                /// Type of the distribution store currently stores type can be intune, googleplay or windows.
                public enum `Type`: String, Codable, CaseIterable {
                    case intune
                    case googleplay
                    case apple
                    case `none`
                }

                public init(id: String, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil, isLatest: Bool? = nil) {
                    self.id = id
                    self.name = name
                    self.type = type
                    self.publishingStatus = publishingStatus
                    self.isLatest = isLatest
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.id = try values.decode(String.self, forKey: "id")
                    self.name = try values.decodeIfPresent(String.self, forKey: "name")
                    self.type = try `Type`(from: decoder)
                    self.publishingStatus = try values.decodeIfPresent(String.self, forKey: "publishing_status")
                    self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
                }
            }

            public struct Destination: Decodable {
                public var a: A
                public var b: B
                /// Name of a distribution group / distribution store. The release will be associated with this distribution group or store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
                public var name: String?
                /// Id of a distribution group / store. The release will be associated with this distribution group / store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
                public var id: String?
                /// Destination can be either store or group.
                public var destinationType: DestinationType?
                /// Display name for the group or tester
                public var displayName: String?

                public struct A: Decodable {
                    /// ID identifying a unique distribution group.
                    public var id: String
                    /// A name identifying a unique distribution group.
                    public var name: String?
                    /// Is the containing release the latest one in this distribution group.
                    public var isLatest: Bool?

                    public init(id: String, name: String? = nil, isLatest: Bool? = nil) {
                        self.id = id
                        self.name = name
                        self.isLatest = isLatest
                    }

                    public init(from decoder: Decoder) throws {
                        let values = try decoder.container(keyedBy: StringCodingKey.self)
                        self.id = try values.decode(String.self, forKey: "id")
                        self.name = try values.decodeIfPresent(String.self, forKey: "name")
                        self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
                    }
                }

                public struct B: Decodable {
                    /// ID identifying a unique distribution store.
                    public var id: String
                    /// A name identifying a unique distribution store.
                    public var name: String?
                    /// Type of the distribution store currently stores type can be intune, googleplay or windows.
                    public var type: `Type`?
                    /// Publishing status of the release in the store.
                    public var publishingStatus: String?
                    /// Is the containing release the latest one in this distribution store.
                    public var isLatest: Bool?

                    /// Type of the distribution store currently stores type can be intune, googleplay or windows.
                    public enum `Type`: String, Codable, CaseIterable {
                        case intune
                        case googleplay
                        case apple
                        case `none`
                    }

                    public init(id: String, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil, isLatest: Bool? = nil) {
                        self.id = id
                        self.name = name
                        self.type = type
                        self.publishingStatus = publishingStatus
                        self.isLatest = isLatest
                    }

                    public init(from decoder: Decoder) throws {
                        let values = try decoder.container(keyedBy: StringCodingKey.self)
                        self.id = try values.decode(String.self, forKey: "id")
                        self.name = try values.decodeIfPresent(String.self, forKey: "name")
                        self.type = try `Type`(from: decoder)
                        self.publishingStatus = try values.decodeIfPresent(String.self, forKey: "publishing_status")
                        self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
                    }
                }

                /// Destination can be either store or group.
                public enum DestinationType: String, Codable, CaseIterable {
                    case group
                    case store
                    case tester
                }

                public init(a: A, b: B, name: String? = nil, id: String? = nil, destinationType: DestinationType? = nil, displayName: String? = nil) {
                    self.a = a
                    self.b = b
                    self.name = name
                    self.id = id
                    self.destinationType = destinationType
                    self.displayName = displayName
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.a = try A(from: decoder)
                    self.b = try B(from: decoder)
                    self.name = try values.decodeIfPresent(String.self, forKey: "name")
                    self.id = try values.decodeIfPresent(String.self, forKey: "id")
                    self.destinationType = try DestinationType(from: decoder)
                    self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
                }
            }

            /// Build information for the release
            public struct Build: Decodable {
                /// The branch name of the build producing the release
                public var branchName: String?
                /// The commit hash of the build producing the release
                public var commitHash: String?
                /// The commit message of the build producing the release
                public var commitMessage: String?

                public init(branchName: String? = nil, commitHash: String? = nil, commitMessage: String? = nil) {
                    self.branchName = branchName
                    self.commitHash = commitHash
                    self.commitMessage = commitMessage
                }

                private enum CodingKeys: String, CodingKey {
                    case branchName = "branch_name"
                    case commitHash = "commit_hash"
                    case commitMessage = "commit_message"
                }
            }

            public init(id: Int, version: String, origin: Origin? = nil, shortVersion: String, isEnabled: Bool, uploadedAt: String, destinationType: DestinationType? = nil, distributionGroups: [DistributionGroup]? = nil, distributionStores: [DistributionStore]? = nil, destinations: [Destination]? = nil, build: Build? = nil, isExternalBuild: Bool? = nil, fileExtension: String? = nil) {
                self.id = id
                self.version = version
                self.origin = origin
                self.shortVersion = shortVersion
                self.isEnabled = isEnabled
                self.uploadedAt = uploadedAt
                self.destinationType = destinationType
                self.distributionGroups = distributionGroups
                self.distributionStores = distributionStores
                self.destinations = destinations
                self.build = build
                self.isExternalBuild = isExternalBuild
                self.fileExtension = fileExtension
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case version
                case origin
                case shortVersion = "short_version"
                case isEnabled = "enabled"
                case uploadedAt = "uploaded_at"
                case destinationType = "destination_type"
                case distributionGroups = "distribution_groups"
                case distributionStores = "distribution_stores"
                case destinations
                case build
                case isExternalBuild = "is_external_build"
                case fileExtension = "file_extension"
            }
        }

        private func makeGetQuery(_ isPublishedOnly: Bool?, _ scope: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isPublishedOnly, forKey: "published_only")
            encoder.encode(scope, forKey: "scope")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var recentReleases: RecentReleases {
        RecentReleases(path: path + "/recent_releases")
    }

    public struct RecentReleases {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/recent_releases`
        public let path: String

        /// Get the latest release from every distribution group associated with an application.
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        /// Basic information on a release
        public struct GetResponseItem: Decodable {
            /// ID identifying this unique release.
            public var id: Int
            /// The release's version.<br>
            /// For iOS: CFBundleVersion from info.plist.<br>
            /// For Android: android:versionCode from AppManifest.xml.
            public var version: String
            /// The release's origin
            public var origin: Origin?
            /// The release's short version.<br>
            /// For iOS: CFBundleShortVersionString from info.plist.<br>
            /// For Android: android:versionName from AppManifest.xml.
            public var shortVersion: String
            /// This value determines the whether a release currently is enabled or disabled.
            public var isEnabled: Bool
            /// UTC time in ISO 8601 format of the uploaded time.
            public var uploadedAt: String
            /// OBSOLETE. Will be removed in next version. The destination type.<br>
            /// <b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>
            /// <b>store</b>: The release distributed to external stores and distribution_stores details will be returned. <br>
            public var destinationType: DestinationType?
            /// OBSOLETE. Will be removed in next version. A list of distribution groups that are associated with this release.
            public var distributionGroups: [DistributionGroup]?
            /// OBSOLETE. Will be removed in next version. A list of distribution stores that are associated with this release.
            public var distributionStores: [DistributionStore]?
            /// A list of distribution groups or stores.
            public var destinations: [Destination]?
            /// Build information for the release
            public var build: Build?
            /// This value determines if a release is external or not.
            public var isExternalBuild: Bool?
            /// The file extension of the main (user-uploaded) package file.
            public var fileExtension: String?

            /// The release's origin
            public enum Origin: String, Codable, CaseIterable {
                case hockeyapp
                case appcenter
            }

            /// OBSOLETE. Will be removed in next version. The destination type.<br>
            /// <b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>
            /// <b>store</b>: The release distributed to external stores and distribution_stores details will be returned. <br>
            public enum DestinationType: String, Codable, CaseIterable {
                case group
                case store
                case tester
            }

            public struct DistributionGroup: Decodable {
                /// ID identifying a unique distribution group.
                public var id: String
                /// A name identifying a unique distribution group.
                public var name: String?
                /// Is the containing release the latest one in this distribution group.
                public var isLatest: Bool?

                public init(id: String, name: String? = nil, isLatest: Bool? = nil) {
                    self.id = id
                    self.name = name
                    self.isLatest = isLatest
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.id = try values.decode(String.self, forKey: "id")
                    self.name = try values.decodeIfPresent(String.self, forKey: "name")
                    self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
                }
            }

            public struct DistributionStore: Decodable {
                /// ID identifying a unique distribution store.
                public var id: String
                /// A name identifying a unique distribution store.
                public var name: String?
                /// Type of the distribution store currently stores type can be intune, googleplay or windows.
                public var type: `Type`?
                /// Publishing status of the release in the store.
                public var publishingStatus: String?
                /// Is the containing release the latest one in this distribution store.
                public var isLatest: Bool?

                /// Type of the distribution store currently stores type can be intune, googleplay or windows.
                public enum `Type`: String, Codable, CaseIterable {
                    case intune
                    case googleplay
                    case apple
                    case `none`
                }

                public init(id: String, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil, isLatest: Bool? = nil) {
                    self.id = id
                    self.name = name
                    self.type = type
                    self.publishingStatus = publishingStatus
                    self.isLatest = isLatest
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.id = try values.decode(String.self, forKey: "id")
                    self.name = try values.decodeIfPresent(String.self, forKey: "name")
                    self.type = try `Type`(from: decoder)
                    self.publishingStatus = try values.decodeIfPresent(String.self, forKey: "publishing_status")
                    self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
                }
            }

            public struct Destination: Decodable {
                public var a: A
                public var b: B
                /// Name of a distribution group / distribution store. The release will be associated with this distribution group or store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
                public var name: String?
                /// Id of a distribution group / store. The release will be associated with this distribution group / store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
                public var id: String?
                /// Destination can be either store or group.
                public var destinationType: DestinationType?
                /// Display name for the group or tester
                public var displayName: String?

                public struct A: Decodable {
                    /// ID identifying a unique distribution group.
                    public var id: String
                    /// A name identifying a unique distribution group.
                    public var name: String?
                    /// Is the containing release the latest one in this distribution group.
                    public var isLatest: Bool?

                    public init(id: String, name: String? = nil, isLatest: Bool? = nil) {
                        self.id = id
                        self.name = name
                        self.isLatest = isLatest
                    }

                    public init(from decoder: Decoder) throws {
                        let values = try decoder.container(keyedBy: StringCodingKey.self)
                        self.id = try values.decode(String.self, forKey: "id")
                        self.name = try values.decodeIfPresent(String.self, forKey: "name")
                        self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
                    }
                }

                public struct B: Decodable {
                    /// ID identifying a unique distribution store.
                    public var id: String
                    /// A name identifying a unique distribution store.
                    public var name: String?
                    /// Type of the distribution store currently stores type can be intune, googleplay or windows.
                    public var type: `Type`?
                    /// Publishing status of the release in the store.
                    public var publishingStatus: String?
                    /// Is the containing release the latest one in this distribution store.
                    public var isLatest: Bool?

                    /// Type of the distribution store currently stores type can be intune, googleplay or windows.
                    public enum `Type`: String, Codable, CaseIterable {
                        case intune
                        case googleplay
                        case apple
                        case `none`
                    }

                    public init(id: String, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil, isLatest: Bool? = nil) {
                        self.id = id
                        self.name = name
                        self.type = type
                        self.publishingStatus = publishingStatus
                        self.isLatest = isLatest
                    }

                    public init(from decoder: Decoder) throws {
                        let values = try decoder.container(keyedBy: StringCodingKey.self)
                        self.id = try values.decode(String.self, forKey: "id")
                        self.name = try values.decodeIfPresent(String.self, forKey: "name")
                        self.type = try `Type`(from: decoder)
                        self.publishingStatus = try values.decodeIfPresent(String.self, forKey: "publishing_status")
                        self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
                    }
                }

                /// Destination can be either store or group.
                public enum DestinationType: String, Codable, CaseIterable {
                    case group
                    case store
                    case tester
                }

                public init(a: A, b: B, name: String? = nil, id: String? = nil, destinationType: DestinationType? = nil, displayName: String? = nil) {
                    self.a = a
                    self.b = b
                    self.name = name
                    self.id = id
                    self.destinationType = destinationType
                    self.displayName = displayName
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.a = try A(from: decoder)
                    self.b = try B(from: decoder)
                    self.name = try values.decodeIfPresent(String.self, forKey: "name")
                    self.id = try values.decodeIfPresent(String.self, forKey: "id")
                    self.destinationType = try DestinationType(from: decoder)
                    self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
                }
            }

            /// Build information for the release
            public struct Build: Decodable {
                /// The branch name of the build producing the release
                public var branchName: String?
                /// The commit hash of the build producing the release
                public var commitHash: String?
                /// The commit message of the build producing the release
                public var commitMessage: String?

                public init(branchName: String? = nil, commitHash: String? = nil, commitMessage: String? = nil) {
                    self.branchName = branchName
                    self.commitHash = commitHash
                    self.commitMessage = commitMessage
                }

                private enum CodingKeys: String, CodingKey {
                    case branchName = "branch_name"
                    case commitHash = "commit_hash"
                    case commitMessage = "commit_message"
                }
            }

            public init(id: Int, version: String, origin: Origin? = nil, shortVersion: String, isEnabled: Bool, uploadedAt: String, destinationType: DestinationType? = nil, distributionGroups: [DistributionGroup]? = nil, distributionStores: [DistributionStore]? = nil, destinations: [Destination]? = nil, build: Build? = nil, isExternalBuild: Bool? = nil, fileExtension: String? = nil) {
                self.id = id
                self.version = version
                self.origin = origin
                self.shortVersion = shortVersion
                self.isEnabled = isEnabled
                self.uploadedAt = uploadedAt
                self.destinationType = destinationType
                self.distributionGroups = distributionGroups
                self.distributionStores = distributionStores
                self.destinations = destinations
                self.build = build
                self.isExternalBuild = isExternalBuild
                self.fileExtension = fileExtension
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case version
                case origin
                case shortVersion = "short_version"
                case isEnabled = "enabled"
                case uploadedAt = "uploaded_at"
                case destinationType = "destination_type"
                case distributionGroups = "distribution_groups"
                case distributionStores = "distribution_stores"
                case destinations
                case build
                case isExternalBuild = "is_external_build"
                case fileExtension = "file_extension"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var owner: Owner {
        Owner(path: path + "/owner")
    }

    public struct Owner {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/owner`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Owner.DeviceSets {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/owner/device_sets/{id}`
        public let path: String

        /// Gets a device set belonging to the owner
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Device Set
        ///
        /// The name and devices of the device set
        public struct GetResponse: Decodable {
            /// Identifier of the device set
            public var id: String
            /// The number of manufacturers in the device set's device selection
            public var manufacturerCount: Double?
            /// Name of the device set
            public var name: String
            /// Slug of the device set
            public var slug: String?
            /// Device Set Owner
            ///
            /// The owner of a device set
            public var owner: Owner
            /// The number of os versions in the device set's device selection
            public var osVersionCount: Double?
            public var deviceConfigurations: [DeviceConfiguration]

            /// Device Set Owner
            ///
            /// The owner of a device set
            public struct Owner: Decodable {
                /// Type of account
                public var type: String
                /// Account ID
                public var id: String
                /// Display name of the account
                public var displayName: String?
                /// Name of the account
                public var name: String

                public init(type: String, id: String, displayName: String? = nil, name: String) {
                    self.type = type
                    self.id = id
                    self.displayName = displayName
                    self.name = name
                }
            }

            public struct DeviceConfiguration: Decodable {
                /// The unique id of the device configuration
                public var id: String?
                public var image: Image?
                public var model: Model?
                public var os: String?
                public var osName: String?

                public struct Image: Decodable {
                    public var thumb: String?

                    public init(thumb: String? = nil) {
                        self.thumb = thumb
                    }
                }

                public struct Model: Decodable {
                    public var name: String?
                    public var manufacturer: String?
                    public var releaseDate: String?
                    public var formFactor: String?

                    public init(name: String? = nil, manufacturer: String? = nil, releaseDate: String? = nil, formFactor: String? = nil) {
                        self.name = name
                        self.manufacturer = manufacturer
                        self.releaseDate = releaseDate
                        self.formFactor = formFactor
                    }
                }

                public init(id: String? = nil, image: Image? = nil, model: Model? = nil, os: String? = nil, osName: String? = nil) {
                    self.id = id
                    self.image = image
                    self.model = model
                    self.os = os
                    self.osName = osName
                }
            }

            public init(id: String, manufacturerCount: Double? = nil, name: String, slug: String? = nil, owner: Owner, osVersionCount: Double? = nil, deviceConfigurations: [DeviceConfiguration]) {
                self.id = id
                self.manufacturerCount = manufacturerCount
                self.name = name
                self.slug = slug
                self.owner = owner
                self.osVersionCount = osVersionCount
                self.deviceConfigurations = deviceConfigurations
            }
        }

        /// Updates a device set belonging to the owner
        public func put(_ body: PutRequest) -> Request<PutResponse> {
            .put(path, body: body)
        }

        /// Device Set
        ///
        /// The name and devices of the device set
        public struct PutResponse: Decodable {
            /// Identifier of the device set
            public var id: String
            /// The number of manufacturers in the device set's device selection
            public var manufacturerCount: Double?
            /// Name of the device set
            public var name: String
            /// Slug of the device set
            public var slug: String?
            /// Device Set Owner
            ///
            /// The owner of a device set
            public var owner: Owner
            /// The number of os versions in the device set's device selection
            public var osVersionCount: Double?
            public var deviceConfigurations: [DeviceConfiguration]

            /// Device Set Owner
            ///
            /// The owner of a device set
            public struct Owner: Decodable {
                /// Type of account
                public var type: String
                /// Account ID
                public var id: String
                /// Display name of the account
                public var displayName: String?
                /// Name of the account
                public var name: String

                public init(type: String, id: String, displayName: String? = nil, name: String) {
                    self.type = type
                    self.id = id
                    self.displayName = displayName
                    self.name = name
                }
            }

            public struct DeviceConfiguration: Decodable {
                /// The unique id of the device configuration
                public var id: String?
                public var image: Image?
                public var model: Model?
                public var os: String?
                public var osName: String?

                public struct Image: Decodable {
                    public var thumb: String?

                    public init(thumb: String? = nil) {
                        self.thumb = thumb
                    }
                }

                public struct Model: Decodable {
                    public var name: String?
                    public var manufacturer: String?
                    public var releaseDate: String?
                    public var formFactor: String?

                    public init(name: String? = nil, manufacturer: String? = nil, releaseDate: String? = nil, formFactor: String? = nil) {
                        self.name = name
                        self.manufacturer = manufacturer
                        self.releaseDate = releaseDate
                        self.formFactor = formFactor
                    }
                }

                public init(id: String? = nil, image: Image? = nil, model: Model? = nil, os: String? = nil, osName: String? = nil) {
                    self.id = id
                    self.image = image
                    self.model = model
                    self.os = os
                    self.osName = osName
                }
            }

            public init(id: String, manufacturerCount: Double? = nil, name: String, slug: String? = nil, owner: Owner, osVersionCount: Double? = nil, deviceConfigurations: [DeviceConfiguration]) {
                self.id = id
                self.manufacturerCount = manufacturerCount
                self.name = name
                self.slug = slug
                self.owner = owner
                self.osVersionCount = osVersionCount
                self.deviceConfigurations = deviceConfigurations
            }
        }

        /// Device Set update information
        ///
        /// The name of the device set and the list of device IDs
        public struct PutRequest: Encodable {
            /// List of device IDs
            public var devices: [String]
            /// The name of the device set
            public var name: String

            public init(devices: [String], name: String) {
                self.devices = devices
                self.name = name
            }
        }

        /// Deletes a device set belonging to the owner
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Owner {
    public var deviceSets: DeviceSets {
        DeviceSets(path: path + "/device_sets")
    }

    public struct DeviceSets {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/owner/device_sets`
        public let path: String

        /// Lists device sets belonging to the owner
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        /// Device Set
        ///
        /// The name and devices of the device set
        public struct GetResponseItem: Decodable {
            /// Identifier of the device set
            public var id: String
            /// The number of manufacturers in the device set's device selection
            public var manufacturerCount: Double?
            /// Name of the device set
            public var name: String
            /// Slug of the device set
            public var slug: String?
            /// Device Set Owner
            ///
            /// The owner of a device set
            public var owner: Owner
            /// The number of os versions in the device set's device selection
            public var osVersionCount: Double?
            public var deviceConfigurations: [DeviceConfiguration]

            /// Device Set Owner
            ///
            /// The owner of a device set
            public struct Owner: Decodable {
                /// Type of account
                public var type: String
                /// Account ID
                public var id: String
                /// Display name of the account
                public var displayName: String?
                /// Name of the account
                public var name: String

                public init(type: String, id: String, displayName: String? = nil, name: String) {
                    self.type = type
                    self.id = id
                    self.displayName = displayName
                    self.name = name
                }
            }

            public struct DeviceConfiguration: Decodable {
                /// The unique id of the device configuration
                public var id: String?
                public var image: Image?
                public var model: Model?
                public var os: String?
                public var osName: String?

                public struct Image: Decodable {
                    public var thumb: String?

                    public init(thumb: String? = nil) {
                        self.thumb = thumb
                    }
                }

                public struct Model: Decodable {
                    public var name: String?
                    public var manufacturer: String?
                    public var releaseDate: String?
                    public var formFactor: String?

                    public init(name: String? = nil, manufacturer: String? = nil, releaseDate: String? = nil, formFactor: String? = nil) {
                        self.name = name
                        self.manufacturer = manufacturer
                        self.releaseDate = releaseDate
                        self.formFactor = formFactor
                    }
                }

                public init(id: String? = nil, image: Image? = nil, model: Model? = nil, os: String? = nil, osName: String? = nil) {
                    self.id = id
                    self.image = image
                    self.model = model
                    self.os = os
                    self.osName = osName
                }
            }

            public init(id: String, manufacturerCount: Double? = nil, name: String, slug: String? = nil, owner: Owner, osVersionCount: Double? = nil, deviceConfigurations: [DeviceConfiguration]) {
                self.id = id
                self.manufacturerCount = manufacturerCount
                self.name = name
                self.slug = slug
                self.owner = owner
                self.osVersionCount = osVersionCount
                self.deviceConfigurations = deviceConfigurations
            }
        }

        /// Creates a device set belonging to the owner
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        /// Device Set
        ///
        /// The name and devices of the device set
        public struct PostResponse: Decodable {
            /// Identifier of the device set
            public var id: String
            /// The number of manufacturers in the device set's device selection
            public var manufacturerCount: Double?
            /// Name of the device set
            public var name: String
            /// Slug of the device set
            public var slug: String?
            /// Device Set Owner
            ///
            /// The owner of a device set
            public var owner: Owner
            /// The number of os versions in the device set's device selection
            public var osVersionCount: Double?
            public var deviceConfigurations: [DeviceConfiguration]

            /// Device Set Owner
            ///
            /// The owner of a device set
            public struct Owner: Decodable {
                /// Type of account
                public var type: String
                /// Account ID
                public var id: String
                /// Display name of the account
                public var displayName: String?
                /// Name of the account
                public var name: String

                public init(type: String, id: String, displayName: String? = nil, name: String) {
                    self.type = type
                    self.id = id
                    self.displayName = displayName
                    self.name = name
                }
            }

            public struct DeviceConfiguration: Decodable {
                /// The unique id of the device configuration
                public var id: String?
                public var image: Image?
                public var model: Model?
                public var os: String?
                public var osName: String?

                public struct Image: Decodable {
                    public var thumb: String?

                    public init(thumb: String? = nil) {
                        self.thumb = thumb
                    }
                }

                public struct Model: Decodable {
                    public var name: String?
                    public var manufacturer: String?
                    public var releaseDate: String?
                    public var formFactor: String?

                    public init(name: String? = nil, manufacturer: String? = nil, releaseDate: String? = nil, formFactor: String? = nil) {
                        self.name = name
                        self.manufacturer = manufacturer
                        self.releaseDate = releaseDate
                        self.formFactor = formFactor
                    }
                }

                public init(id: String? = nil, image: Image? = nil, model: Model? = nil, os: String? = nil, osName: String? = nil) {
                    self.id = id
                    self.image = image
                    self.model = model
                    self.os = os
                    self.osName = osName
                }
            }

            public init(id: String, manufacturerCount: Double? = nil, name: String, slug: String? = nil, owner: Owner, osVersionCount: Double? = nil, deviceConfigurations: [DeviceConfiguration]) {
                self.id = id
                self.manufacturerCount = manufacturerCount
                self.name = name
                self.slug = slug
                self.owner = owner
                self.osVersionCount = osVersionCount
                self.deviceConfigurations = deviceConfigurations
            }
        }

        /// Device Set update information
        ///
        /// The name of the device set and the list of device IDs
        public struct PostRequest: Encodable {
            /// List of device IDs
            public var devices: [String]
            /// The name of the device set
            public var name: String

            public init(devices: [String], name: String) {
                self.devices = devices
                self.name = name
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var notifications: Notifications {
        Notifications(path: path + "/notifications")
    }

    public struct Notifications {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/notifications`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Notifications {
    public var emailSettings: EmailSettings {
        EmailSettings(path: path + "/emailSettings")
    }

    public struct EmailSettings {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/notifications/emailSettings`
        public let path: String

        /// Get Email notification settings of user for a particular app
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Alerting Email Settings of the user for a particular app
        public struct GetResponse: Decodable {
            /// Unique request identifier for tracking
            public var requestID: String

            public init(requestID: String) {
                self.requestID = requestID
            }

            private enum CodingKeys: String, CodingKey {
                case requestID = "request_id"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Invitations {
    public func userEmail(_ userEmail: String) -> WithUserEmail {
        WithUserEmail(path: "\(path)/\(userEmail)")
    }

    public struct WithUserEmail {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/invitations/{user_email}`
        public let path: String

        /// Invites a new or existing user to an app
        @available(*, deprecated, message: "Deprecated")
        public func post(role: PostRequest.Role? = nil) -> Request<Void> {
            .post(path, body: PostRequest(role: role))
        }

        public struct PostRequest: Encodable {
            /// The role of the user to be added
            public var role: Role?

            /// The role of the user to be added
            public enum Role: String, Codable, CaseIterable {
                case admin
                case collaborator
                case member
            }

            public init(role: Role? = nil) {
                self.role = role
            }
        }

        /// Update pending invitation permission
        public func patch(permissions: [PatchRequest.Permission]) -> Request<Void> {
            .patch(path, body: PatchRequest(permissions: permissions))
        }

        public struct PatchRequest: Encodable {
            /// The permissions the user has for the app in the invitation
            public var permissions: [Permission]

            public enum Permission: String, Codable, CaseIterable {
                case manager
                case developer
                case viewer
            }

            public init(permissions: [Permission]) {
                self.permissions = permissions
            }
        }

        /// Removes a user's invitation to an app
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var invitations: Invitations {
        Invitations(path: path + "/invitations")
    }

    public struct Invitations {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/invitations`
        public let path: String

        /// Gets the pending invitations for the app
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Invites a new or existing user to an app
        public func post(_ body: PostRequest? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The user's email address
            public var userEmail: String
            /// The user's role
            public var role: Role?

            /// The user's role
            public enum Role: String, Codable, CaseIterable {
                case admin
                case collaborator
                case member
            }

            public init(userEmail: String, role: Role? = nil) {
                self.userEmail = userEmail
                self.role = role
            }

            private enum CodingKeys: String, CodingKey {
                case userEmail = "user_email"
                case role
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var fileAsset: FileAsset {
        FileAsset(path: path + "/file_asset")
    }

    public struct FileAsset {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/file_asset`
        public let path: String

        /// Create a new asset to upload a file
        public func post(_ body: [String: AnyJSON]? = nil) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.ExportConfigurations.WithExportConfigurationID {
    public var enable: Enable {
        Enable(path: path + "/enable")
    }

    public struct Enable {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/export_configurations/{export_configuration_id}/enable`
        public let path: String

        /// Enable export configuration.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.ExportConfigurations.WithExportConfigurationID {
    public var disable: Disable {
        Disable(path: path + "/disable")
    }

    public struct Disable {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/export_configurations/{export_configuration_id}/disable`
        public let path: String

        /// Disable export configuration.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.ExportConfigurations {
    public func exportConfigurationID(_ exportConfigurationID: String) -> WithExportConfigurationID {
        WithExportConfigurationID(path: "\(path)/\(exportConfigurationID)")
    }

    public struct WithExportConfigurationID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/export_configurations/{export_configuration_id}`
        public let path: String

        /// Get export configuration.
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Export configuration result
        public struct GetResponse: Decodable {
            /// Export configuration id
            public var id: String
            /// Target resource type of export configuration
            public var exportType: ExportType
            /// Creation time in ISO 8601 format
            public var creationTime: String
            /// Latest time in ISO 8601 format when export completed successfully
            public var lastRunTime: String?
            public var exportEntities: [ExportEntity]?
            /// State of the export job
            public var state: State
            /// Additional information about export configuration state
            public var stateInfo: String?
            /// Resource group for the storage account/App Insights resource
            public var resourceGroup: String?
            /// Storage accout or Appinsights resource name
            public var resourceName: String?
            /// Export configuration
            public var exportConfiguration: ExportConfiguration?

            /// Target resource type of export configuration
            public enum ExportType: String, Codable, CaseIterable {
                case blobStorage = "BlobStorage"
                case appInsights = "AppInsights"
            }

            public enum ExportEntity: String, Codable, CaseIterable {
                case crashes
                case errors
                case attachments
                case noLogs = "no_logs"
            }

            /// State of the export job
            public enum State: String, Codable, CaseIterable {
                case enabled = "Enabled"
                case disabled = "Disabled"
                case pending = "Pending"
                case deleted = "Deleted"
                case invalid = "Invalid"
            }

            /// Export configuration
            public struct ExportConfiguration: Decodable {
                /// Type of export configuration
                public var type: `Type`
                public var exportEntities: [ExportEntity]?
                /// The resource name on azure
                public var resourceName: String?
                /// The resource group name on azure
                public var resourceGroup: String?
                /// Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.
                public var isBackfill: Bool?

                /// Type of export configuration
                public enum `Type`: String, Codable, CaseIterable {
                    case blobStorageConnectionString = "blob_storage_connection_string"
                    case applicationInsightsInstrumentationKey = "application_insights_instrumentation_key"
                    case blobStorageLinkedSubscription = "blob_storage_linked_subscription"
                    case applicationInsightsLinkedSubscription = "application_insights_linked_subscription"
                }

                public enum ExportEntity: String, Codable, CaseIterable {
                    case crashes
                    case errors
                    case attachments
                    case noLogs = "no_logs"
                }

                public init(type: `Type`, exportEntities: [ExportEntity]? = nil, resourceName: String? = nil, resourceGroup: String? = nil, isBackfill: Bool? = nil) {
                    self.type = type
                    self.exportEntities = exportEntities
                    self.resourceName = resourceName
                    self.resourceGroup = resourceGroup
                    self.isBackfill = isBackfill
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case exportEntities = "export_entities"
                    case resourceName = "resource_name"
                    case resourceGroup = "resource_group"
                    case isBackfill = "backfill"
                }
            }

            public init(id: String, exportType: ExportType, creationTime: String, lastRunTime: String? = nil, exportEntities: [ExportEntity]? = nil, state: State, stateInfo: String? = nil, resourceGroup: String? = nil, resourceName: String? = nil, exportConfiguration: ExportConfiguration? = nil) {
                self.id = id
                self.exportType = exportType
                self.creationTime = creationTime
                self.lastRunTime = lastRunTime
                self.exportEntities = exportEntities
                self.state = state
                self.stateInfo = stateInfo
                self.resourceGroup = resourceGroup
                self.resourceName = resourceName
                self.exportConfiguration = exportConfiguration
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case exportType = "export_type"
                case creationTime = "creation_time"
                case lastRunTime = "last_run_time"
                case exportEntities = "export_entities"
                case state
                case stateInfo = "state_info"
                case resourceGroup = "resource_group"
                case resourceName = "resource_name"
                case exportConfiguration = "export_configuration"
            }
        }

        /// Partially update export configuration.
        public func patch(_ body: PatchRequest) -> Request<PatchResponse> {
            .patch(path, body: body)
        }

        /// Export configuration result
        public struct PatchResponse: Decodable {
            /// Export configuration id
            public var id: String
            /// Target resource type of export configuration
            public var exportType: ExportType
            /// Creation time in ISO 8601 format
            public var creationTime: String
            /// Latest time in ISO 8601 format when export completed successfully
            public var lastRunTime: String?
            public var exportEntities: [ExportEntity]?
            /// State of the export job
            public var state: State
            /// Additional information about export configuration state
            public var stateInfo: String?
            /// Resource group for the storage account/App Insights resource
            public var resourceGroup: String?
            /// Storage accout or Appinsights resource name
            public var resourceName: String?
            /// Export configuration
            public var exportConfiguration: ExportConfiguration?

            /// Target resource type of export configuration
            public enum ExportType: String, Codable, CaseIterable {
                case blobStorage = "BlobStorage"
                case appInsights = "AppInsights"
            }

            public enum ExportEntity: String, Codable, CaseIterable {
                case crashes
                case errors
                case attachments
                case noLogs = "no_logs"
            }

            /// State of the export job
            public enum State: String, Codable, CaseIterable {
                case enabled = "Enabled"
                case disabled = "Disabled"
                case pending = "Pending"
                case deleted = "Deleted"
                case invalid = "Invalid"
            }

            /// Export configuration
            public struct ExportConfiguration: Decodable {
                /// Type of export configuration
                public var type: `Type`
                public var exportEntities: [ExportEntity]?
                /// The resource name on azure
                public var resourceName: String?
                /// The resource group name on azure
                public var resourceGroup: String?
                /// Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.
                public var isBackfill: Bool?

                /// Type of export configuration
                public enum `Type`: String, Codable, CaseIterable {
                    case blobStorageConnectionString = "blob_storage_connection_string"
                    case applicationInsightsInstrumentationKey = "application_insights_instrumentation_key"
                    case blobStorageLinkedSubscription = "blob_storage_linked_subscription"
                    case applicationInsightsLinkedSubscription = "application_insights_linked_subscription"
                }

                public enum ExportEntity: String, Codable, CaseIterable {
                    case crashes
                    case errors
                    case attachments
                    case noLogs = "no_logs"
                }

                public init(type: `Type`, exportEntities: [ExportEntity]? = nil, resourceName: String? = nil, resourceGroup: String? = nil, isBackfill: Bool? = nil) {
                    self.type = type
                    self.exportEntities = exportEntities
                    self.resourceName = resourceName
                    self.resourceGroup = resourceGroup
                    self.isBackfill = isBackfill
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case exportEntities = "export_entities"
                    case resourceName = "resource_name"
                    case resourceGroup = "resource_group"
                    case isBackfill = "backfill"
                }
            }

            public init(id: String, exportType: ExportType, creationTime: String, lastRunTime: String? = nil, exportEntities: [ExportEntity]? = nil, state: State, stateInfo: String? = nil, resourceGroup: String? = nil, resourceName: String? = nil, exportConfiguration: ExportConfiguration? = nil) {
                self.id = id
                self.exportType = exportType
                self.creationTime = creationTime
                self.lastRunTime = lastRunTime
                self.exportEntities = exportEntities
                self.state = state
                self.stateInfo = stateInfo
                self.resourceGroup = resourceGroup
                self.resourceName = resourceName
                self.exportConfiguration = exportConfiguration
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case exportType = "export_type"
                case creationTime = "creation_time"
                case lastRunTime = "last_run_time"
                case exportEntities = "export_entities"
                case state
                case stateInfo = "state_info"
                case resourceGroup = "resource_group"
                case resourceName = "resource_name"
                case exportConfiguration = "export_configuration"
            }
        }

        /// Export configuration
        public struct PatchRequest: Encodable {
            /// Type of export configuration
            public var type: `Type`
            public var exportEntities: [ExportEntity]?
            /// The resource name on azure
            public var resourceName: String?
            /// The resource group name on azure
            public var resourceGroup: String?
            /// Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.
            public var isBackfill: Bool?

            /// Type of export configuration
            public enum `Type`: String, Codable, CaseIterable {
                case blobStorageConnectionString = "blob_storage_connection_string"
                case applicationInsightsInstrumentationKey = "application_insights_instrumentation_key"
                case blobStorageLinkedSubscription = "blob_storage_linked_subscription"
                case applicationInsightsLinkedSubscription = "application_insights_linked_subscription"
            }

            public enum ExportEntity: String, Codable, CaseIterable {
                case crashes
                case errors
                case attachments
                case noLogs = "no_logs"
            }

            public init(type: `Type`, exportEntities: [ExportEntity]? = nil, resourceName: String? = nil, resourceGroup: String? = nil, isBackfill: Bool? = nil) {
                self.type = type
                self.exportEntities = exportEntities
                self.resourceName = resourceName
                self.resourceGroup = resourceGroup
                self.isBackfill = isBackfill
            }

            private enum CodingKeys: String, CodingKey {
                case type
                case exportEntities = "export_entities"
                case resourceName = "resource_name"
                case resourceGroup = "resource_group"
                case isBackfill = "backfill"
            }
        }

        /// Delete export configuration.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var exportConfigurations: ExportConfigurations {
        ExportConfigurations(path: path + "/export_configurations")
    }

    public struct ExportConfigurations {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/export_configurations`
        public let path: String

        /// List export configurations.
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// List of export configurations
        public struct GetResponse: Decodable {
            public var values: [Value]
            /// The total count of exports
            public var total: Int?
            public var nextLink: String?

            /// Export configuration result
            public struct Value: Decodable {
                /// Export configuration id
                public var id: String
                /// Target resource type of export configuration
                public var exportType: ExportType
                /// Creation time in ISO 8601 format
                public var creationTime: String
                /// Latest time in ISO 8601 format when export completed successfully
                public var lastRunTime: String?
                public var exportEntities: [ExportEntity]?
                /// State of the export job
                public var state: State
                /// Additional information about export configuration state
                public var stateInfo: String?
                /// Resource group for the storage account/App Insights resource
                public var resourceGroup: String?
                /// Storage accout or Appinsights resource name
                public var resourceName: String?
                /// Export configuration
                public var exportConfiguration: ExportConfiguration?

                /// Target resource type of export configuration
                public enum ExportType: String, Codable, CaseIterable {
                    case blobStorage = "BlobStorage"
                    case appInsights = "AppInsights"
                }

                public enum ExportEntity: String, Codable, CaseIterable {
                    case crashes
                    case errors
                    case attachments
                    case noLogs = "no_logs"
                }

                /// State of the export job
                public enum State: String, Codable, CaseIterable {
                    case enabled = "Enabled"
                    case disabled = "Disabled"
                    case pending = "Pending"
                    case deleted = "Deleted"
                    case invalid = "Invalid"
                }

                /// Export configuration
                public struct ExportConfiguration: Decodable {
                    /// Type of export configuration
                    public var type: `Type`
                    public var exportEntities: [ExportEntity]?
                    /// The resource name on azure
                    public var resourceName: String?
                    /// The resource group name on azure
                    public var resourceGroup: String?
                    /// Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.
                    public var isBackfill: Bool?

                    /// Type of export configuration
                    public enum `Type`: String, Codable, CaseIterable {
                        case blobStorageConnectionString = "blob_storage_connection_string"
                        case applicationInsightsInstrumentationKey = "application_insights_instrumentation_key"
                        case blobStorageLinkedSubscription = "blob_storage_linked_subscription"
                        case applicationInsightsLinkedSubscription = "application_insights_linked_subscription"
                    }

                    public enum ExportEntity: String, Codable, CaseIterable {
                        case crashes
                        case errors
                        case attachments
                        case noLogs = "no_logs"
                    }

                    public init(type: `Type`, exportEntities: [ExportEntity]? = nil, resourceName: String? = nil, resourceGroup: String? = nil, isBackfill: Bool? = nil) {
                        self.type = type
                        self.exportEntities = exportEntities
                        self.resourceName = resourceName
                        self.resourceGroup = resourceGroup
                        self.isBackfill = isBackfill
                    }

                    private enum CodingKeys: String, CodingKey {
                        case type
                        case exportEntities = "export_entities"
                        case resourceName = "resource_name"
                        case resourceGroup = "resource_group"
                        case isBackfill = "backfill"
                    }
                }

                public init(id: String, exportType: ExportType, creationTime: String, lastRunTime: String? = nil, exportEntities: [ExportEntity]? = nil, state: State, stateInfo: String? = nil, resourceGroup: String? = nil, resourceName: String? = nil, exportConfiguration: ExportConfiguration? = nil) {
                    self.id = id
                    self.exportType = exportType
                    self.creationTime = creationTime
                    self.lastRunTime = lastRunTime
                    self.exportEntities = exportEntities
                    self.state = state
                    self.stateInfo = stateInfo
                    self.resourceGroup = resourceGroup
                    self.resourceName = resourceName
                    self.exportConfiguration = exportConfiguration
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case exportType = "export_type"
                    case creationTime = "creation_time"
                    case lastRunTime = "last_run_time"
                    case exportEntities = "export_entities"
                    case state
                    case stateInfo = "state_info"
                    case resourceGroup = "resource_group"
                    case resourceName = "resource_name"
                    case exportConfiguration = "export_configuration"
                }
            }

            public init(values: [Value], total: Int? = nil, nextLink: String? = nil) {
                self.values = values
                self.total = total
                self.nextLink = nextLink
            }
        }

        /// Create new export configuration
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        /// Export configuration result
        public struct PostResponse: Decodable {
            /// Export configuration id
            public var id: String
            /// Target resource type of export configuration
            public var exportType: ExportType
            /// Creation time in ISO 8601 format
            public var creationTime: String
            /// Latest time in ISO 8601 format when export completed successfully
            public var lastRunTime: String?
            public var exportEntities: [ExportEntity]?
            /// State of the export job
            public var state: State
            /// Additional information about export configuration state
            public var stateInfo: String?
            /// Resource group for the storage account/App Insights resource
            public var resourceGroup: String?
            /// Storage accout or Appinsights resource name
            public var resourceName: String?
            /// Export configuration
            public var exportConfiguration: ExportConfiguration?

            /// Target resource type of export configuration
            public enum ExportType: String, Codable, CaseIterable {
                case blobStorage = "BlobStorage"
                case appInsights = "AppInsights"
            }

            public enum ExportEntity: String, Codable, CaseIterable {
                case crashes
                case errors
                case attachments
                case noLogs = "no_logs"
            }

            /// State of the export job
            public enum State: String, Codable, CaseIterable {
                case enabled = "Enabled"
                case disabled = "Disabled"
                case pending = "Pending"
                case deleted = "Deleted"
                case invalid = "Invalid"
            }

            /// Export configuration
            public struct ExportConfiguration: Decodable {
                /// Type of export configuration
                public var type: `Type`
                public var exportEntities: [ExportEntity]?
                /// The resource name on azure
                public var resourceName: String?
                /// The resource group name on azure
                public var resourceGroup: String?
                /// Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.
                public var isBackfill: Bool?

                /// Type of export configuration
                public enum `Type`: String, Codable, CaseIterable {
                    case blobStorageConnectionString = "blob_storage_connection_string"
                    case applicationInsightsInstrumentationKey = "application_insights_instrumentation_key"
                    case blobStorageLinkedSubscription = "blob_storage_linked_subscription"
                    case applicationInsightsLinkedSubscription = "application_insights_linked_subscription"
                }

                public enum ExportEntity: String, Codable, CaseIterable {
                    case crashes
                    case errors
                    case attachments
                    case noLogs = "no_logs"
                }

                public init(type: `Type`, exportEntities: [ExportEntity]? = nil, resourceName: String? = nil, resourceGroup: String? = nil, isBackfill: Bool? = nil) {
                    self.type = type
                    self.exportEntities = exportEntities
                    self.resourceName = resourceName
                    self.resourceGroup = resourceGroup
                    self.isBackfill = isBackfill
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case exportEntities = "export_entities"
                    case resourceName = "resource_name"
                    case resourceGroup = "resource_group"
                    case isBackfill = "backfill"
                }
            }

            public init(id: String, exportType: ExportType, creationTime: String, lastRunTime: String? = nil, exportEntities: [ExportEntity]? = nil, state: State, stateInfo: String? = nil, resourceGroup: String? = nil, resourceName: String? = nil, exportConfiguration: ExportConfiguration? = nil) {
                self.id = id
                self.exportType = exportType
                self.creationTime = creationTime
                self.lastRunTime = lastRunTime
                self.exportEntities = exportEntities
                self.state = state
                self.stateInfo = stateInfo
                self.resourceGroup = resourceGroup
                self.resourceName = resourceName
                self.exportConfiguration = exportConfiguration
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case exportType = "export_type"
                case creationTime = "creation_time"
                case lastRunTime = "last_run_time"
                case exportEntities = "export_entities"
                case state
                case stateInfo = "state_info"
                case resourceGroup = "resource_group"
                case resourceName = "resource_name"
                case exportConfiguration = "export_configuration"
            }
        }

        /// Export configuration
        public struct PostRequest: Encodable {
            /// Type of export configuration
            public var type: `Type`
            public var exportEntities: [ExportEntity]?
            /// The resource name on azure
            public var resourceName: String?
            /// The resource group name on azure
            public var resourceGroup: String?
            /// Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.
            public var isBackfill: Bool?

            /// Type of export configuration
            public enum `Type`: String, Codable, CaseIterable {
                case blobStorageConnectionString = "blob_storage_connection_string"
                case applicationInsightsInstrumentationKey = "application_insights_instrumentation_key"
                case blobStorageLinkedSubscription = "blob_storage_linked_subscription"
                case applicationInsightsLinkedSubscription = "application_insights_linked_subscription"
            }

            public enum ExportEntity: String, Codable, CaseIterable {
                case crashes
                case errors
                case attachments
                case noLogs = "no_logs"
            }

            public init(type: `Type`, exportEntities: [ExportEntity]? = nil, resourceName: String? = nil, resourceGroup: String? = nil, isBackfill: Bool? = nil) {
                self.type = type
                self.exportEntities = exportEntities
                self.resourceName = resourceName
                self.resourceGroup = resourceGroup
                self.isBackfill = isBackfill
            }

            private enum CodingKeys: String, CodingKey {
                case type
                case exportEntities = "export_entities"
                case resourceName = "resource_name"
                case resourceGroup = "resource_group"
                case isBackfill = "backfill"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var errors: Errors {
        Errors(path: path + "/errors")
    }

    public struct Errors {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors {
    public func errorID(_ errorID: String) -> WithErrorID {
        WithErrorID(path: "\(path)/\(errorID)")
    }

    public struct WithErrorID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/{errorId}`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors.WithErrorID {
    public var sessionLogs: SessionLogs {
        SessionLogs(path: path + "/sessionLogs")
    }

    public struct SessionLogs {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/{errorId}/sessionLogs`
        public let path: String

        /// Get session logs by error ID
        public func get(date: Date? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(date))
        }

        public struct GetResponse: Decodable {
            /// Indicates if the number of available logs are more than the max allowed return limit(100).
            public var isExceededMaxLimit: Bool?
            /// The timestamp of the last log received. This value can be used as the start time parameter in the consecutive API call.
            public var lastReceivedLogTimestamp: Date?
            /// The list of logs
            public var logs: [Log]

            /// Generic log.
            public struct Log: Decodable {
                /// Log type.
                public var type: `Type`
                /// Log creation timestamp.
                public var timestamp: Date
                /// Install ID.
                public var installID: String
                /// Session ID.
                public var sessionID: String?
                /// Event ID.
                public var eventID: String?
                /// Event name.
                public var eventName: String?
                /// Message ID.
                public var messageID: String?
                /// Event specific properties.
                public var properties: [String: String]?
                /// Device characteristics.
                public var device: Device

                /// Log type.
                public enum `Type`: String, Codable, CaseIterable {
                    case event
                    case page
                    case startSession = "start_session"
                    case error
                    case pushInstallation = "push_installation"
                    case startService = "start_service"
                    case customProperties = "custom_properties"
                }

                /// Device characteristics.
                public struct Device: Decodable {
                    /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
                    public var sdkName: String
                    /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
                    public var sdkVersion: String
                    /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
                    public var wrapperSdkVersion: String?
                    /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
                    public var wrapperSdkName: String?
                    /// Device model (example: iPad2,3).
                    public var model: String?
                    /// Device manufacturer (example: HTC).
                    public var oemName: String?
                    /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
                    public var osName: String
                    /// OS version (example: 9.3.0).
                    public var osVersion: String
                    /// OS build code (example: LMY47X).
                    public var osBuild: String?
                    /// API level when applicable like in Android (example: 15).
                    public var osAPILevel: Int?
                    /// Language code (example: en_US).
                    public var locale: String
                    /// The offset in minutes from UTC for the device time zone, including daylight savings time.
                    public var timeZoneOffset: Int
                    /// Screen size of the device in pixels (example: 640x480).
                    public var screenSize: String?
                    /// Application version name, e.g. 1.1.0
                    public var appVersion: String
                    /// Carrier name (for mobile devices).
                    public var carrierName: String?
                    /// Carrier country code (for mobile devices).
                    public var carrierCode: String?
                    /// Carrier country.
                    public var carrierCountry: String?
                    /// The app's build number, e.g. 42.
                    public var appBuild: String
                    /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
                    public var appNamespace: String?
                    /// Label that is used to identify application code 'version' released via Live Update beacon running on device
                    public var liveUpdateReleaseLabel: String?
                    /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
                    public var liveUpdateDeploymentKey: String?
                    /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
                    public var liveUpdatePackageHash: String?
                    /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
                    public var wrapperRuntimeVersion: String?

                    public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
                        self.sdkName = sdkName
                        self.sdkVersion = sdkVersion
                        self.wrapperSdkVersion = wrapperSdkVersion
                        self.wrapperSdkName = wrapperSdkName
                        self.model = model
                        self.oemName = oemName
                        self.osName = osName
                        self.osVersion = osVersion
                        self.osBuild = osBuild
                        self.osAPILevel = osAPILevel
                        self.locale = locale
                        self.timeZoneOffset = timeZoneOffset
                        self.screenSize = screenSize
                        self.appVersion = appVersion
                        self.carrierName = carrierName
                        self.carrierCode = carrierCode
                        self.carrierCountry = carrierCountry
                        self.appBuild = appBuild
                        self.appNamespace = appNamespace
                        self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
                        self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
                        self.liveUpdatePackageHash = liveUpdatePackageHash
                        self.wrapperRuntimeVersion = wrapperRuntimeVersion
                    }

                    private enum CodingKeys: String, CodingKey {
                        case sdkName = "sdk_name"
                        case sdkVersion = "sdk_version"
                        case wrapperSdkVersion = "wrapper_sdk_version"
                        case wrapperSdkName = "wrapper_sdk_name"
                        case model
                        case oemName = "oem_name"
                        case osName = "os_name"
                        case osVersion = "os_version"
                        case osBuild = "os_build"
                        case osAPILevel = "os_api_level"
                        case locale
                        case timeZoneOffset = "time_zone_offset"
                        case screenSize = "screen_size"
                        case appVersion = "app_version"
                        case carrierName = "carrier_name"
                        case carrierCode = "carrier_code"
                        case carrierCountry = "carrier_country"
                        case appBuild = "app_build"
                        case appNamespace = "app_namespace"
                        case liveUpdateReleaseLabel = "live_update_release_label"
                        case liveUpdateDeploymentKey = "live_update_deployment_key"
                        case liveUpdatePackageHash = "live_update_package_hash"
                        case wrapperRuntimeVersion = "wrapper_runtime_version"
                    }
                }

                public init(type: `Type`, timestamp: Date, installID: String, sessionID: String? = nil, eventID: String? = nil, eventName: String? = nil, messageID: String? = nil, properties: [String: String]? = nil, device: Device) {
                    self.type = type
                    self.timestamp = timestamp
                    self.installID = installID
                    self.sessionID = sessionID
                    self.eventID = eventID
                    self.eventName = eventName
                    self.messageID = messageID
                    self.properties = properties
                    self.device = device
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case timestamp
                    case installID = "install_id"
                    case sessionID = "session_id"
                    case eventID = "event_id"
                    case eventName = "event_name"
                    case messageID = "message_id"
                    case properties
                    case device
                }
            }

            public init(isExceededMaxLimit: Bool? = nil, lastReceivedLogTimestamp: Date? = nil, logs: [Log]) {
                self.isExceededMaxLimit = isExceededMaxLimit
                self.lastReceivedLogTimestamp = lastReceivedLogTimestamp
                self.logs = logs
            }

            private enum CodingKeys: String, CodingKey {
                case isExceededMaxLimit = "exceeded_max_limit"
                case lastReceivedLogTimestamp = "last_received_log_timestamp"
                case logs
            }
        }

        private func makeGetQuery(_ date: Date?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(date, forKey: "date")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors.WithErrorID.Attachments {
    public func attachmentID(_ attachmentID: String) -> WithAttachmentID {
        WithAttachmentID(path: "\(path)/\(attachmentID)")
    }

    public struct WithAttachmentID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/{errorId}/attachments/{attachmentId}`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors.WithErrorID.Attachments.WithAttachmentID {
    public var text: Text {
        Text(path: path + "/text")
    }

    public struct Text {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/{errorId}/attachments/{attachmentId}/text`
        public let path: String

        /// Error attachment text.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var content: String?

            public init(content: String? = nil) {
                self.content = content
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors.WithErrorID.Attachments.WithAttachmentID {
    public var location: Location {
        Location(path: path + "/location")
    }

    public struct Location {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/{errorId}/attachments/{attachmentId}/location`
        public let path: String

        /// Error attachment location.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var uri: String?

            public init(uri: String? = nil) {
                self.uri = uri
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors.WithErrorID {
    public var attachments: Attachments {
        Attachments(path: path + "/attachments")
    }

    public struct Attachments {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/{errorId}/attachments`
        public let path: String

        /// List error attachments.
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            public var appID: String?
            public var attachmentID: String?
            public var crashID: String?
            public var blobLocation: String?
            public var contentType: String?
            public var fileName: String?
            public var createdTime: Date?
            public var size: Int?

            public init(appID: String? = nil, attachmentID: String? = nil, crashID: String? = nil, blobLocation: String? = nil, contentType: String? = nil, fileName: String? = nil, createdTime: Date? = nil, size: Int? = nil) {
                self.appID = appID
                self.attachmentID = attachmentID
                self.crashID = crashID
                self.blobLocation = blobLocation
                self.contentType = contentType
                self.fileName = fileName
                self.createdTime = createdTime
                self.size = size
            }

            private enum CodingKeys: String, CodingKey {
                case appID = "appId"
                case attachmentID = "attachmentId"
                case crashID = "crashId"
                case blobLocation
                case contentType
                case fileName
                case createdTime
                case size
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors {
    public var search: Search {
        Search(path: path + "/search")
    }

    public struct Search {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/search`
        public let path: String

        /// Errors list based on search parameters
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var hasMoreResults: Bool?
            public var errors: [Error]?

            public struct Error: Decodable {
                public var errorID: String?
                public var timestamp: Date?
                public var deviceName: String?
                public var osVersion: String?
                public var osType: String?
                public var country: String?
                public var language: String?
                public var userID: String?
                public var hasBreadcrumbs: Bool?
                public var hasAttachments: Bool?

                public init(errorID: String? = nil, timestamp: Date? = nil, deviceName: String? = nil, osVersion: String? = nil, osType: String? = nil, country: String? = nil, language: String? = nil, userID: String? = nil, hasBreadcrumbs: Bool? = nil, hasAttachments: Bool? = nil) {
                    self.errorID = errorID
                    self.timestamp = timestamp
                    self.deviceName = deviceName
                    self.osVersion = osVersion
                    self.osType = osType
                    self.country = country
                    self.language = language
                    self.userID = userID
                    self.hasBreadcrumbs = hasBreadcrumbs
                    self.hasAttachments = hasAttachments
                }

                private enum CodingKeys: String, CodingKey {
                    case errorID = "errorId"
                    case timestamp
                    case deviceName
                    case osVersion
                    case osType
                    case country
                    case language
                    case userID = "userId"
                    case hasBreadcrumbs
                    case hasAttachments
                }
            }

            public init(hasMoreResults: Bool? = nil, errors: [Error]? = nil) {
                self.hasMoreResults = hasMoreResults
                self.errors = errors
            }
        }

        public struct GetParameters {
            public var filter: String?
            public var q: String?
            public var order: Order?
            public var sort: Sort?
            public var top: Int?
            public var skip: Int?

            public enum Order: String, Codable, CaseIterable {
                case desc
                case asc
            }

            public enum Sort: String, Codable, CaseIterable {
                case timestamp
                case errorGroupID = "errorGroupId"
                case exceptionClassName
                case exceptionFile
                case exceptionLine
                case exceptionMessage
                case exceptionMethod
                case deviceName
                case osVersion
                case userID = "userId"
            }

            public init(filter: String? = nil, q: String? = nil, order: Order? = nil, sort: Sort? = nil, top: Int? = nil, skip: Int? = nil) {
                self.filter = filter
                self.q = q
                self.order = order
                self.sort = sort
                self.top = top
                self.skip = skip
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(filter, forKey: "filter")
                encoder.encode(q, forKey: "q")
                encoder.encode(order, forKey: "order")
                encoder.encode(sort, forKey: "sort")
                encoder.encode(top, forKey: "$top")
                encoder.encode(skip, forKey: "$skip")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors {
    public var retentionSettings: RetentionSettings {
        RetentionSettings(path: path + "/retention_settings")
    }

    public struct RetentionSettings {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/retention_settings`
        public let path: String

        /// Gets the retention settings in days
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var retentionInDays: Int

            public init(retentionInDays: Int) {
                self.retentionInDays = retentionInDays
            }

            private enum CodingKeys: String, CodingKey {
                case retentionInDays = "retention_in_days"
            }
        }

        /// Creates and updates the retention settings in days
        public func put(retentionInDays: Int) -> Request<PutResponse> {
            .put(path, body: ["retention_in_days": retentionInDays])
        }

        public struct PutResponse: Decodable {
            public var retentionInDays: Int

            public init(retentionInDays: Int) {
                self.retentionInDays = retentionInDays
            }

            private enum CodingKeys: String, CodingKey {
                case retentionInDays = "retention_in_days"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors {
    public var errorfreeDevicePercentages: ErrorfreeDevicePercentages {
        ErrorfreeDevicePercentages(path: path + "/errorfreeDevicePercentages")
    }

    public struct ErrorfreeDevicePercentages {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/errorfreeDevicePercentages`
        public let path: String

        /// Percentage of error-free devices by day in the time range based on the selected versions. If SingleErrorTypeParameter is not provided, defaults to handlederror. API will return -1 if crash devices is greater than active devices
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// Average percentage
            public var averagePercentage: Double?
            /// The error-free percentage per day.
            public var dailyPercentages: [DailyPercentage]?

            public struct DailyPercentage: Decodable {
                /// The ISO 8601 datetime
                public var datetime: String?
                /// Percentage of the object
                public var percentage: Double?

                public init(datetime: String? = nil, percentage: Double? = nil) {
                    self.datetime = datetime
                    self.percentage = percentage
                }
            }

            public init(averagePercentage: Double? = nil, dailyPercentages: [DailyPercentage]? = nil) {
                self.averagePercentage = averagePercentage
                self.dailyPercentages = dailyPercentages
            }
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var versions: [String]?
            public var appBuild: String?
            public var errorType: ErrorType?

            public enum ErrorType: String, Codable, CaseIterable {
                case unhandledError
                case handledError
            }

            public init(start: Date, end: Date? = nil, versions: [String]? = nil, appBuild: String? = nil, errorType: ErrorType? = nil) {
                self.start = start
                self.end = end
                self.versions = versions
                self.appBuild = appBuild
                self.errorType = errorType
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(versions, forKey: "versions", explode: false, delimiter: "|")
                encoder.encode(appBuild, forKey: "app_build")
                encoder.encode(errorType, forKey: "errorType")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors.ErrorGroups.WithErrorGroupID {
    public var stacktrace: Stacktrace {
        Stacktrace(path: path + "/stacktrace")
    }

    public struct Stacktrace {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/stacktrace`
        public let path: String

        /// Gets the stack trace for the error group.
        public var get: Request<MicrosoftAppCenterAPI.DiagnosticsStackTrace> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors.ErrorGroups.WithErrorGroupID {
    public var operatingSystems: OperatingSystems {
        OperatingSystems(path: path + "/operatingSystems")
    }

    public struct OperatingSystems {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/operatingSystems`
        public let path: String

        /// Top OSes of the selected error group.
        public func get(top: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(top))
        }

        public struct GetResponse: Decodable {
            public var errorCount: Int?
            public var operatingSystems: [OperatingSystem]?

            public struct OperatingSystem: Decodable {
                /// OS name
                public var operatingSystemName: String?
                /// Count of OS
                public var errorCount: Int?

                public init(operatingSystemName: String? = nil, errorCount: Int? = nil) {
                    self.operatingSystemName = operatingSystemName
                    self.errorCount = errorCount
                }
            }

            public init(errorCount: Int? = nil, operatingSystems: [OperatingSystem]? = nil) {
                self.errorCount = errorCount
                self.operatingSystems = operatingSystems
            }
        }

        private func makeGetQuery(_ top: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(top, forKey: "$top")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors.ErrorGroups.WithErrorGroupID {
    public var models: Models {
        Models(path: path + "/models")
    }

    public struct Models {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/models`
        public let path: String

        /// Top models of the selected error group.
        public func get(top: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(top))
        }

        public struct GetResponse: Decodable {
            public var errorCount: Int?
            public var models: [Model]?

            public struct Model: Decodable {
                /// Model name
                public var modelName: String?
                /// Model code
                public var modelCode: String?
                /// Count of errors in a model
                public var errorCount: Int?

                public init(modelName: String? = nil, modelCode: String? = nil, errorCount: Int? = nil) {
                    self.modelName = modelName
                    self.modelCode = modelCode
                    self.errorCount = errorCount
                }
            }

            public init(errorCount: Int? = nil, models: [Model]? = nil) {
                self.errorCount = errorCount
                self.models = models
            }
        }

        private func makeGetQuery(_ top: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(top, forKey: "$top")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors.ErrorGroups.WithErrorGroupID.Errors.WithErrorID {
    public var stacktrace: Stacktrace {
        Stacktrace(path: path + "/stacktrace")
    }

    public struct Stacktrace {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}/stacktrace`
        public let path: String

        /// Error Stacktrace details.
        public var get: Request<MicrosoftAppCenterAPI.DiagnosticsStackTrace> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors.ErrorGroups.WithErrorGroupID.Errors.WithErrorID {
    public var location: Location {
        Location(path: path + "/location")
    }

    public struct Location {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}/location`
        public let path: String

        /// Error location.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var uri: String?

            public init(uri: String? = nil) {
                self.uri = uri
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors.ErrorGroups.WithErrorGroupID.Errors.WithErrorID {
    public var download: Download {
        Download(path: path + "/download")
    }

    public struct Download {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}/download`
        public let path: String

        /// Download details for a specific error.
        public func get(format: Format? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(format))
        }

        private func makeGetQuery(_ format: Format?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(format, forKey: "format")
            return encoder.items
        }

        public enum Format: String, Codable, CaseIterable {
            case json
            case txt
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors.ErrorGroups.WithErrorGroupID.Errors {
    public func errorID(_ errorID: String) -> WithErrorID {
        WithErrorID(path: "\(path)/\(errorID)")
    }

    public struct WithErrorID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}`
        public let path: String

        /// Error details.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var country: String?
            public var deviceName: String?
            public var errorID: String?
            public var hasAttachments: Bool?
            public var hasBreadcrumbs: Bool?
            public var language: String?
            public var osType: String?
            public var osVersion: String?
            public var timestamp: Date?
            public var userID: String?

            public init(country: String? = nil, deviceName: String? = nil, errorID: String? = nil, hasAttachments: Bool? = nil, hasBreadcrumbs: Bool? = nil, language: String? = nil, osType: String? = nil, osVersion: String? = nil, timestamp: Date? = nil, userID: String? = nil) {
                self.country = country
                self.deviceName = deviceName
                self.errorID = errorID
                self.hasAttachments = hasAttachments
                self.hasBreadcrumbs = hasBreadcrumbs
                self.language = language
                self.osType = osType
                self.osVersion = osVersion
                self.timestamp = timestamp
                self.userID = userID
            }

            private enum CodingKeys: String, CodingKey {
                case country
                case deviceName
                case errorID = "errorId"
                case hasAttachments
                case hasBreadcrumbs
                case language
                case osType
                case osVersion
                case timestamp
                case userID = "userId"
            }
        }

        /// Delete a specific error and related attachments and blobs for an app. Searchable data will not be deleted immediately and may take up to 30 days.
        public var delete: Request<DeleteResponse> {
            .delete(path)
        }

        public struct DeleteResponse: Decodable {
            public var appID: String?
            public var errorGroupID: String?
            public var errorID: String?
            public var errorsDeleted: Int?
            public var attachmentsDeleted: Int?
            public var blobsSucceeded: Int?
            public var blobsFailed: Int?

            public init(appID: String? = nil, errorGroupID: String? = nil, errorID: String? = nil, errorsDeleted: Int? = nil, attachmentsDeleted: Int? = nil, blobsSucceeded: Int? = nil, blobsFailed: Int? = nil) {
                self.appID = appID
                self.errorGroupID = errorGroupID
                self.errorID = errorID
                self.errorsDeleted = errorsDeleted
                self.attachmentsDeleted = attachmentsDeleted
                self.blobsSucceeded = blobsSucceeded
                self.blobsFailed = blobsFailed
            }

            private enum CodingKeys: String, CodingKey {
                case appID = "appId"
                case errorGroupID = "errorGroupId"
                case errorID = "errorId"
                case errorsDeleted
                case attachmentsDeleted
                case blobsSucceeded
                case blobsFailed
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors.ErrorGroups.WithErrorGroupID.Errors {
    public var latest: Latest {
        Latest(path: path + "/latest")
    }

    public struct Latest {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/latest`
        public let path: String

        /// Latest error details.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var country: String?
            public var deviceName: String?
            public var errorID: String?
            public var hasAttachments: Bool?
            public var hasBreadcrumbs: Bool?
            public var language: String?
            public var osType: String?
            public var osVersion: String?
            public var timestamp: Date?
            public var userID: String?

            public init(country: String? = nil, deviceName: String? = nil, errorID: String? = nil, hasAttachments: Bool? = nil, hasBreadcrumbs: Bool? = nil, language: String? = nil, osType: String? = nil, osVersion: String? = nil, timestamp: Date? = nil, userID: String? = nil) {
                self.country = country
                self.deviceName = deviceName
                self.errorID = errorID
                self.hasAttachments = hasAttachments
                self.hasBreadcrumbs = hasBreadcrumbs
                self.language = language
                self.osType = osType
                self.osVersion = osVersion
                self.timestamp = timestamp
                self.userID = userID
            }

            private enum CodingKeys: String, CodingKey {
                case country
                case deviceName
                case errorID = "errorId"
                case hasAttachments
                case hasBreadcrumbs
                case language
                case osType
                case osVersion
                case timestamp
                case userID = "userId"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors.ErrorGroups.WithErrorGroupID {
    public var errors: Errors {
        Errors(path: path + "/errors")
    }

    public struct Errors {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors`
        public let path: String

        /// Get all errors for group
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            public var nextLink: String?
            /// Errors list.
            public var errors: [Error]?

            public struct Error: Decodable {
                public var errorID: String?
                public var timestamp: Date?
                public var deviceName: String?
                public var osVersion: String?
                public var osType: String?
                public var country: String?
                public var language: String?
                public var userID: String?
                public var hasBreadcrumbs: Bool?
                public var hasAttachments: Bool?

                public init(errorID: String? = nil, timestamp: Date? = nil, deviceName: String? = nil, osVersion: String? = nil, osType: String? = nil, country: String? = nil, language: String? = nil, userID: String? = nil, hasBreadcrumbs: Bool? = nil, hasAttachments: Bool? = nil) {
                    self.errorID = errorID
                    self.timestamp = timestamp
                    self.deviceName = deviceName
                    self.osVersion = osVersion
                    self.osType = osType
                    self.country = country
                    self.language = language
                    self.userID = userID
                    self.hasBreadcrumbs = hasBreadcrumbs
                    self.hasAttachments = hasAttachments
                }

                private enum CodingKeys: String, CodingKey {
                    case errorID = "errorId"
                    case timestamp
                    case deviceName
                    case osVersion
                    case osType
                    case country
                    case language
                    case userID = "userId"
                    case hasBreadcrumbs
                    case hasAttachments
                }
            }

            public init(nextLink: String? = nil, errors: [Error]? = nil) {
                self.nextLink = nextLink
                self.errors = errors
            }
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var top: Int?
            public var model: String?
            public var os: String?

            public init(start: Date, end: Date? = nil, top: Int? = nil, model: String? = nil, os: String? = nil) {
                self.start = start
                self.end = end
                self.top = top
                self.model = model
                self.os = os
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(top, forKey: "$top")
                encoder.encode(model, forKey: "model")
                encoder.encode(os, forKey: "os")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors.ErrorGroups.WithErrorGroupID {
    public var errorfreeDevicePercentages: ErrorfreeDevicePercentages {
        ErrorfreeDevicePercentages(path: path + "/errorfreeDevicePercentages")
    }

    public struct ErrorfreeDevicePercentages {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errorfreeDevicePercentages`
        public let path: String

        /// Percentage of error-free devices by day in the time range. Api will return -1 if crash devices is greater than active devices
        public func get(start: Date, end: Date? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(start, end))
        }

        public struct GetResponse: Decodable {
            /// Average percentage
            public var averagePercentage: Double?
            /// The error-free percentage per day.
            public var dailyPercentages: [DailyPercentage]?

            public struct DailyPercentage: Decodable {
                /// The ISO 8601 datetime
                public var datetime: String?
                /// Percentage of the object
                public var percentage: Double?

                public init(datetime: String? = nil, percentage: Double? = nil) {
                    self.datetime = datetime
                    self.percentage = percentage
                }
            }

            public init(averagePercentage: Double? = nil, dailyPercentages: [DailyPercentage]? = nil) {
                self.averagePercentage = averagePercentage
                self.dailyPercentages = dailyPercentages
            }
        }

        private func makeGetQuery(_ start: Date, _ end: Date?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(start, forKey: "start")
            encoder.encode(end, forKey: "end")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors.ErrorGroups.WithErrorGroupID {
    public var errorCountsPerDay: ErrorCountsPerDay {
        ErrorCountsPerDay(path: path + "/errorCountsPerDay")
    }

    public struct ErrorCountsPerDay {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errorCountsPerDay`
        public let path: String

        /// Count of errors by day in the time range of the selected error group with selected version
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// Total error count
            public var count: Int?
            /// The total error count for day
            public var errors: [Error]?

            public struct Error: Decodable {
                /// The ISO 8601 datetime
                public var datetime: String?
                /// Count of the object
                public var count: Int?

                public init(datetime: String? = nil, count: Int? = nil) {
                    self.datetime = datetime
                    self.count = count
                }
            }

            public init(count: Int? = nil, errors: [Error]? = nil) {
                self.count = count
                self.errors = errors
            }
        }

        public struct GetParameters {
            public var version: String?
            public var start: Date
            public var end: Date?

            public init(version: String? = nil, start: Date, end: Date? = nil) {
                self.version = version
                self.start = start
                self.end = end
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(version, forKey: "version")
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors.ErrorGroups {
    public func errorGroupID(_ errorGroupID: String) -> WithErrorGroupID {
        WithErrorGroupID(path: "\(path)/\(errorGroupID)")
    }

    public struct WithErrorGroupID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}`
        public let path: String

        /// Error group details
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var annotation: String?
            public var state: State

            public enum State: String, Codable, CaseIterable {
                case `open`
                case closed
                case ignored
            }

            public init(annotation: String? = nil, state: State) {
                self.annotation = annotation
                self.state = state
            }
        }

        /// Update error group state
        public func patch(_ body: PatchRequest) -> Request<PatchResponse> {
            .patch(path, body: body)
        }

        public struct PatchResponse: Decodable {
            public var annotation: String?
            public var state: State

            public enum State: String, Codable, CaseIterable {
                case `open`
                case closed
                case ignored
            }

            public init(annotation: String? = nil, state: State) {
                self.annotation = annotation
                self.state = state
            }
        }

        public struct PatchRequest: Encodable {
            public var state: State
            public var annotation: String?

            public enum State: String, Codable, CaseIterable {
                case `open`
                case closed
                case ignored
            }

            public init(state: State, annotation: String? = nil) {
                self.state = state
                self.annotation = annotation
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors.ErrorGroups {
    public var search: Search {
        Search(path: path + "/search")
    }

    public struct Search {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/search`
        public let path: String

        /// Error groups list based on search parameters
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var hasMoreResults: Bool?
            public var errorGroups: [ErrorGroup]?

            public struct ErrorGroup: Decodable {
                public var errorGroupID: String
                public var appVersion: String
                public var appBuild: String?
                public var count: Int
                public var deviceCount: Int
                public var firstOccurrence: Date
                public var lastOccurrence: Date
                public var exceptionType: String?
                public var exceptionMessage: String?
                public var exceptionClassName: String?
                public var isExceptionClassMethod: Bool?
                public var exceptionMethod: String?
                public var isExceptionAppCode: Bool?
                public var exceptionFile: String?
                public var exceptionLine: String?
                public var codeRaw: String?
                public var reasonFrames: [ReasonFrame]?
                public var isHidden: Bool?

                public struct ReasonFrame: Decodable {
                    /// Name of the class
                    public var className: String?
                    /// Name of the method
                    public var method: String?
                    /// Is a class method
                    public var isClassMethod: Bool?
                    /// Name of the file
                    public var file: String?
                    /// Line number
                    public var line: Int?
                    /// This line isn't from any framework
                    public var isAppCode: Bool?
                    /// Name of the framework
                    public var frameworkName: String?
                    /// Formatted frame string
                    public var codeFormatted: String?
                    /// Unformatted Frame string
                    public var codeRaw: String?
                    /// Programming language of the frame
                    public var language: Language?
                    /// Parameters of the frames method
                    public var methodParams: String?
                    /// Exception type.
                    public var exceptionType: String?
                    /// OS exception type. (aka. SIGNAL)
                    public var osExceptionType: String?

                    /// Programming language of the frame
                    public enum Language: String, Codable, CaseIterable {
                        case javaScript = "JavaScript"
                        case cSharp = "CSharp"
                        case objectiveC = "Objective-C"
                        case objectiveCpp = "Objective-Cpp"
                        case cpp = "Cpp"
                        case c = "C"
                        case swift = "Swift"
                        case java = "Java"
                        case unknown = "Unknown"
                    }

                    public init(className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool? = nil, frameworkName: String? = nil, codeFormatted: String? = nil, codeRaw: String? = nil, language: Language? = nil, methodParams: String? = nil, exceptionType: String? = nil, osExceptionType: String? = nil) {
                        self.className = className
                        self.method = method
                        self.isClassMethod = isClassMethod
                        self.file = file
                        self.line = line
                        self.isAppCode = isAppCode
                        self.frameworkName = frameworkName
                        self.codeFormatted = codeFormatted
                        self.codeRaw = codeRaw
                        self.language = language
                        self.methodParams = methodParams
                        self.exceptionType = exceptionType
                        self.osExceptionType = osExceptionType
                    }

                    private enum CodingKeys: String, CodingKey {
                        case className
                        case method
                        case isClassMethod = "classMethod"
                        case file
                        case line
                        case isAppCode = "appCode"
                        case frameworkName
                        case codeFormatted
                        case codeRaw
                        case language
                        case methodParams
                        case exceptionType
                        case osExceptionType
                    }
                }

                public init(errorGroupID: String, appVersion: String, appBuild: String? = nil, count: Int, deviceCount: Int, firstOccurrence: Date, lastOccurrence: Date, exceptionType: String? = nil, exceptionMessage: String? = nil, exceptionClassName: String? = nil, isExceptionClassMethod: Bool? = nil, exceptionMethod: String? = nil, isExceptionAppCode: Bool? = nil, exceptionFile: String? = nil, exceptionLine: String? = nil, codeRaw: String? = nil, reasonFrames: [ReasonFrame]? = nil, isHidden: Bool? = nil) {
                    self.errorGroupID = errorGroupID
                    self.appVersion = appVersion
                    self.appBuild = appBuild
                    self.count = count
                    self.deviceCount = deviceCount
                    self.firstOccurrence = firstOccurrence
                    self.lastOccurrence = lastOccurrence
                    self.exceptionType = exceptionType
                    self.exceptionMessage = exceptionMessage
                    self.exceptionClassName = exceptionClassName
                    self.isExceptionClassMethod = isExceptionClassMethod
                    self.exceptionMethod = exceptionMethod
                    self.isExceptionAppCode = isExceptionAppCode
                    self.exceptionFile = exceptionFile
                    self.exceptionLine = exceptionLine
                    self.codeRaw = codeRaw
                    self.reasonFrames = reasonFrames
                    self.isHidden = isHidden
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.errorGroupID = try values.decode(String.self, forKey: "errorGroupId")
                    self.appVersion = try values.decode(String.self, forKey: "appVersion")
                    self.appBuild = try values.decodeIfPresent(String.self, forKey: "appBuild")
                    self.count = try values.decode(Int.self, forKey: "count")
                    self.deviceCount = try values.decode(Int.self, forKey: "deviceCount")
                    self.firstOccurrence = try values.decode(Date.self, forKey: "firstOccurrence")
                    self.lastOccurrence = try values.decode(Date.self, forKey: "lastOccurrence")
                    self.exceptionType = try values.decodeIfPresent(String.self, forKey: "exceptionType")
                    self.exceptionMessage = try values.decodeIfPresent(String.self, forKey: "exceptionMessage")
                    self.exceptionClassName = try values.decodeIfPresent(String.self, forKey: "exceptionClassName")
                    self.isExceptionClassMethod = try values.decodeIfPresent(Bool.self, forKey: "exceptionClassMethod")
                    self.exceptionMethod = try values.decodeIfPresent(String.self, forKey: "exceptionMethod")
                    self.isExceptionAppCode = try values.decodeIfPresent(Bool.self, forKey: "exceptionAppCode")
                    self.exceptionFile = try values.decodeIfPresent(String.self, forKey: "exceptionFile")
                    self.exceptionLine = try values.decodeIfPresent(String.self, forKey: "exceptionLine")
                    self.codeRaw = try values.decodeIfPresent(String.self, forKey: "codeRaw")
                    self.reasonFrames = try values.decodeIfPresent([ReasonFrame].self, forKey: "reasonFrames")
                    self.isHidden = try values.decodeIfPresent(Bool.self, forKey: "hidden")
                }
            }

            public init(hasMoreResults: Bool? = nil, errorGroups: [ErrorGroup]? = nil) {
                self.hasMoreResults = hasMoreResults
                self.errorGroups = errorGroups
            }
        }

        public struct GetParameters {
            public var filter: String?
            public var q: String?
            public var order: Order?
            public var sort: Sort?
            public var top: Int?
            public var skip: Int?

            public enum Order: String, Codable, CaseIterable {
                case desc
                case asc
            }

            public enum Sort: String, Codable, CaseIterable {
                case matchingReportsCount
                case exceptionClassName
                case exceptionMessage
                case exceptionMethod
                case lastOccurrence
            }

            public init(filter: String? = nil, q: String? = nil, order: Order? = nil, sort: Sort? = nil, top: Int? = nil, skip: Int? = nil) {
                self.filter = filter
                self.q = q
                self.order = order
                self.sort = sort
                self.top = top
                self.skip = skip
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(filter, forKey: "filter")
                encoder.encode(q, forKey: "q")
                encoder.encode(order, forKey: "order")
                encoder.encode(sort, forKey: "sort")
                encoder.encode(top, forKey: "$top")
                encoder.encode(skip, forKey: "$skip")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors {
    public var errorGroups: ErrorGroups {
        ErrorGroups(path: path + "/errorGroups")
    }

    public struct ErrorGroups {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups`
        public let path: String

        /// List of error groups
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            public var nextLink: String?
            public var errorGroups: [ErrorGroup]?

            public struct ErrorGroup: Decodable {
                public var errorGroupID: String
                public var appVersion: String
                public var appBuild: String?
                public var count: Int
                public var deviceCount: Int
                public var firstOccurrence: Date
                public var lastOccurrence: Date
                public var exceptionType: String?
                public var exceptionMessage: String?
                public var exceptionClassName: String?
                public var isExceptionClassMethod: Bool?
                public var exceptionMethod: String?
                public var isExceptionAppCode: Bool?
                public var exceptionFile: String?
                public var exceptionLine: String?
                public var codeRaw: String?
                public var reasonFrames: [ReasonFrame]?
                public var isHidden: Bool?

                public struct ReasonFrame: Decodable {
                    /// Name of the class
                    public var className: String?
                    /// Name of the method
                    public var method: String?
                    /// Is a class method
                    public var isClassMethod: Bool?
                    /// Name of the file
                    public var file: String?
                    /// Line number
                    public var line: Int?
                    /// This line isn't from any framework
                    public var isAppCode: Bool?
                    /// Name of the framework
                    public var frameworkName: String?
                    /// Formatted frame string
                    public var codeFormatted: String?
                    /// Unformatted Frame string
                    public var codeRaw: String?
                    /// Programming language of the frame
                    public var language: Language?
                    /// Parameters of the frames method
                    public var methodParams: String?
                    /// Exception type.
                    public var exceptionType: String?
                    /// OS exception type. (aka. SIGNAL)
                    public var osExceptionType: String?

                    /// Programming language of the frame
                    public enum Language: String, Codable, CaseIterable {
                        case javaScript = "JavaScript"
                        case cSharp = "CSharp"
                        case objectiveC = "Objective-C"
                        case objectiveCpp = "Objective-Cpp"
                        case cpp = "Cpp"
                        case c = "C"
                        case swift = "Swift"
                        case java = "Java"
                        case unknown = "Unknown"
                    }

                    public init(className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool? = nil, frameworkName: String? = nil, codeFormatted: String? = nil, codeRaw: String? = nil, language: Language? = nil, methodParams: String? = nil, exceptionType: String? = nil, osExceptionType: String? = nil) {
                        self.className = className
                        self.method = method
                        self.isClassMethod = isClassMethod
                        self.file = file
                        self.line = line
                        self.isAppCode = isAppCode
                        self.frameworkName = frameworkName
                        self.codeFormatted = codeFormatted
                        self.codeRaw = codeRaw
                        self.language = language
                        self.methodParams = methodParams
                        self.exceptionType = exceptionType
                        self.osExceptionType = osExceptionType
                    }

                    private enum CodingKeys: String, CodingKey {
                        case className
                        case method
                        case isClassMethod = "classMethod"
                        case file
                        case line
                        case isAppCode = "appCode"
                        case frameworkName
                        case codeFormatted
                        case codeRaw
                        case language
                        case methodParams
                        case exceptionType
                        case osExceptionType
                    }
                }

                public init(errorGroupID: String, appVersion: String, appBuild: String? = nil, count: Int, deviceCount: Int, firstOccurrence: Date, lastOccurrence: Date, exceptionType: String? = nil, exceptionMessage: String? = nil, exceptionClassName: String? = nil, isExceptionClassMethod: Bool? = nil, exceptionMethod: String? = nil, isExceptionAppCode: Bool? = nil, exceptionFile: String? = nil, exceptionLine: String? = nil, codeRaw: String? = nil, reasonFrames: [ReasonFrame]? = nil, isHidden: Bool? = nil) {
                    self.errorGroupID = errorGroupID
                    self.appVersion = appVersion
                    self.appBuild = appBuild
                    self.count = count
                    self.deviceCount = deviceCount
                    self.firstOccurrence = firstOccurrence
                    self.lastOccurrence = lastOccurrence
                    self.exceptionType = exceptionType
                    self.exceptionMessage = exceptionMessage
                    self.exceptionClassName = exceptionClassName
                    self.isExceptionClassMethod = isExceptionClassMethod
                    self.exceptionMethod = exceptionMethod
                    self.isExceptionAppCode = isExceptionAppCode
                    self.exceptionFile = exceptionFile
                    self.exceptionLine = exceptionLine
                    self.codeRaw = codeRaw
                    self.reasonFrames = reasonFrames
                    self.isHidden = isHidden
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.errorGroupID = try values.decode(String.self, forKey: "errorGroupId")
                    self.appVersion = try values.decode(String.self, forKey: "appVersion")
                    self.appBuild = try values.decodeIfPresent(String.self, forKey: "appBuild")
                    self.count = try values.decode(Int.self, forKey: "count")
                    self.deviceCount = try values.decode(Int.self, forKey: "deviceCount")
                    self.firstOccurrence = try values.decode(Date.self, forKey: "firstOccurrence")
                    self.lastOccurrence = try values.decode(Date.self, forKey: "lastOccurrence")
                    self.exceptionType = try values.decodeIfPresent(String.self, forKey: "exceptionType")
                    self.exceptionMessage = try values.decodeIfPresent(String.self, forKey: "exceptionMessage")
                    self.exceptionClassName = try values.decodeIfPresent(String.self, forKey: "exceptionClassName")
                    self.isExceptionClassMethod = try values.decodeIfPresent(Bool.self, forKey: "exceptionClassMethod")
                    self.exceptionMethod = try values.decodeIfPresent(String.self, forKey: "exceptionMethod")
                    self.isExceptionAppCode = try values.decodeIfPresent(Bool.self, forKey: "exceptionAppCode")
                    self.exceptionFile = try values.decodeIfPresent(String.self, forKey: "exceptionFile")
                    self.exceptionLine = try values.decodeIfPresent(String.self, forKey: "exceptionLine")
                    self.codeRaw = try values.decodeIfPresent(String.self, forKey: "codeRaw")
                    self.reasonFrames = try values.decodeIfPresent([ReasonFrame].self, forKey: "reasonFrames")
                    self.isHidden = try values.decodeIfPresent(Bool.self, forKey: "hidden")
                }
            }

            public init(nextLink: String? = nil, errorGroups: [ErrorGroup]? = nil) {
                self.nextLink = nextLink
                self.errorGroups = errorGroups
            }
        }

        public struct GetParameters {
            public var version: String?
            public var appBuild: String?
            public var groupState: String?
            public var start: Date
            public var end: Date?
            public var orderby: String?
            public var top: Int?
            public var errorType: ErrorType?

            public enum ErrorType: String, Codable, CaseIterable {
                case all
                case unhandledError
                case handledError
            }

            public init(version: String? = nil, appBuild: String? = nil, groupState: String? = nil, start: Date, end: Date? = nil, orderby: String? = nil, top: Int? = nil, errorType: ErrorType? = nil) {
                self.version = version
                self.appBuild = appBuild
                self.groupState = groupState
                self.start = start
                self.end = end
                self.orderby = orderby
                self.top = top
                self.errorType = errorType
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(version, forKey: "version")
                encoder.encode(appBuild, forKey: "app_build")
                encoder.encode(groupState, forKey: "groupState")
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(orderby, forKey: "$orderby")
                encoder.encode(top, forKey: "$top")
                encoder.encode(errorType, forKey: "errorType")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors {
    public var errorCountsPerDay: ErrorCountsPerDay {
        ErrorCountsPerDay(path: path + "/errorCountsPerDay")
    }

    public struct ErrorCountsPerDay {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/errorCountsPerDay`
        public let path: String

        /// Count of crashes or errors by day in the time range based the selected versions. If SingleErrorTypeParameter is not provided, defaults to handlederror.
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// Total error count
            public var count: Int?
            /// The total error count for day
            public var errors: [Error]?

            public struct Error: Decodable {
                /// The ISO 8601 datetime
                public var datetime: String?
                /// Count of the object
                public var count: Int?

                public init(datetime: String? = nil, count: Int? = nil) {
                    self.datetime = datetime
                    self.count = count
                }
            }

            public init(count: Int? = nil, errors: [Error]? = nil) {
                self.count = count
                self.errors = errors
            }
        }

        public struct GetParameters {
            public var version: String?
            public var start: Date
            public var end: Date?
            public var appBuild: String?
            public var errorType: ErrorType?

            public enum ErrorType: String, Codable, CaseIterable {
                case unhandledError
                case handledError
            }

            public init(version: String? = nil, start: Date, end: Date? = nil, appBuild: String? = nil, errorType: ErrorType? = nil) {
                self.version = version
                self.start = start
                self.end = end
                self.appBuild = appBuild
                self.errorType = errorType
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(version, forKey: "version")
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(appBuild, forKey: "app_build")
                encoder.encode(errorType, forKey: "errorType")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors {
    public var availableVersions: AvailableVersions {
        AvailableVersions(path: path + "/available_versions")
    }

    public struct AvailableVersions {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/available_versions`
        public let path: String

        /// Get all available versions in the time range.
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// List of available versions.
            public var versions: [String]?
            /// The full number of versions across all pages.
            public var totalCount: Int?

            public init(versions: [String]? = nil, totalCount: Int? = nil) {
                self.versions = versions
                self.totalCount = totalCount
            }

            private enum CodingKeys: String, CodingKey {
                case versions
                case totalCount = "total_count"
            }
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var top: Int?
            public var skip: Int?
            public var filter: String?
            public var inlinecount: Inlinecount?
            public var errorType: ErrorType?

            public enum Inlinecount: String, Codable, CaseIterable {
                case allpages
                case `none`
            }

            public enum ErrorType: String, Codable, CaseIterable {
                case all
                case unhandledError
                case handledError
            }

            public init(start: Date, end: Date? = nil, top: Int? = nil, skip: Int? = nil, filter: String? = nil, inlinecount: Inlinecount? = nil, errorType: ErrorType? = nil) {
                self.start = start
                self.end = end
                self.top = top
                self.skip = skip
                self.filter = filter
                self.inlinecount = inlinecount
                self.errorType = errorType
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(top, forKey: "$top")
                encoder.encode(skip, forKey: "$skip")
                encoder.encode(filter, forKey: "$filter")
                encoder.encode(inlinecount, forKey: "$inlinecount")
                encoder.encode(errorType, forKey: "errorType")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Errors {
    public var availableAppBuilds: AvailableAppBuilds {
        AvailableAppBuilds(path: path + "/availableAppBuilds")
    }

    public struct AvailableAppBuilds {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/availableAppBuilds`
        public let path: String

        /// List of app builds
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            public var appBuilds: [String]?

            public init(appBuilds: [String]? = nil) {
                self.appBuilds = appBuilds
            }
        }

        public struct GetParameters {
            public var version: String
            public var start: Date
            public var end: Date?
            public var top: Int?
            public var errorType: ErrorType?

            public enum ErrorType: String, Codable, CaseIterable {
                case all
                case unhandledError
                case handledError
            }

            public init(version: String, start: Date, end: Date? = nil, top: Int? = nil, errorType: ErrorType? = nil) {
                self.version = version
                self.start = start
                self.end = end
                self.top = top
                self.errorType = errorType
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(version, forKey: "version")
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(top, forKey: "$top")
                encoder.encode(errorType, forKey: "errorType")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.DistributionStores.WithStoreName.Releases.WithReleaseID {
    public var realtimestatus: Realtimestatus {
        Realtimestatus(path: path + "/realtimestatus")
    }

    public struct Realtimestatus {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}/realtimestatus`
        public let path: String

        /// Return the Real time Status publishing of release from store.
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.DistributionStores.WithStoreName.Releases.WithReleaseID {
    public var publishLogs: PublishLogs {
        PublishLogs(path: path + "/publish_logs")
    }

    public struct PublishLogs {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}/publish_logs`
        public let path: String

        /// Returns publish logs for a particular release published to a particular store
        public var get: Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.DistributionStores.WithStoreName.Releases.WithReleaseID {
    public var publishErrorDetails: PublishErrorDetails {
        PublishErrorDetails(path: path + "/publish_error_details")
    }

    public struct PublishErrorDetails {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}/publish_error_details`
        public let path: String

        /// Return the Error Details of release which failed in publishing.
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.DistributionStores.WithStoreName.Releases {
    public func releaseID(_ releaseID: String) -> WithReleaseID {
        WithReleaseID(path: "\(path)/\(releaseID)")
    }

    public struct WithReleaseID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}`
        public let path: String

        /// Return releases published in a store for releaseId and storeId
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        /// Details of an uploaded release
        public struct GetResponseItem: Decodable {
            /// ID identifying this unique release.
            public var id: Double?
            /// OBSOLETE. Will be removed in next version. The availability concept is now replaced with distributed. Any 'available' release will be associated with the default distribution group of an app.</br>
            /// The release state.<br>
            /// <b>available</b>: The uploaded release has been distributed.<br>
            /// <b>unavailable</b>: The uploaded release is not visible to the user. <br>
            public var status: Status?
            /// The app's name (extracted from the uploaded release).
            public var appName: String?
            /// The app's display name.
            public var appDisplayName: String?
            /// The release's version.<br>
            /// For iOS: CFBundleVersion from info.plist.
            /// For Android: android:versionCode from AppManifest.xml.
            public var version: String?
            /// The release's short version.<br>
            /// For iOS: CFBundleShortVersionString from info.plist.
            /// For Android: android:versionName from AppManifest.xml.
            public var shortVersion: String?
            /// The release's release notes.
            public var releaseNotes: String?
            /// The release's size in bytes.
            public var size: Double?
            /// The release's minimum required operating system.
            public var minOs: String?
            /// The release's minimum required Android API level.
            public var androidMinAPILevel: String?
            /// The identifier of the apps bundle.
            public var bundleIdentifier: String?
            /// MD5 checksum of the release binary.
            public var fingerprint: String?
            /// UTC time in ISO 8601 format of the uploaded time.
            public var uploadedAt: String?
            /// The URL that hosts the binary for this release.
            public var downloadURL: String?
            /// The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`
            public var installURL: InstallURL?
            /// A list of distribution stores that are associated with this release.
            public var distributionStores: [DistributionStore]?

            /// OBSOLETE. Will be removed in next version. The availability concept is now replaced with distributed. Any 'available' release will be associated with the default distribution group of an app.</br>
            /// The release state.<br>
            /// <b>available</b>: The uploaded release has been distributed.<br>
            /// <b>unavailable</b>: The uploaded release is not visible to the user. <br>
            public enum Status: String, Codable, CaseIterable {
                case available
                case unavailable
            }

            /// The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`
            public enum InstallURL: String, Codable, CaseIterable {
                case group
                case store
            }

            public struct DistributionStore: Decodable {
                /// ID identifying a unique distribution store.
                public var id: String?
                /// A name identifying a unique distribution store.
                public var name: String?
                /// Type of the distribution store currently stores type can be intune or googleplay.
                public var type: `Type`?
                /// Publishing status of the release in the store.
                public var publishingStatus: String?

                /// Type of the distribution store currently stores type can be intune or googleplay.
                public enum `Type`: String, Codable, CaseIterable {
                    case intune
                    case googleplay
                }

                public init(id: String? = nil, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil) {
                    self.id = id
                    self.name = name
                    self.type = type
                    self.publishingStatus = publishingStatus
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case name
                    case type
                    case publishingStatus = "publishing_status"
                }
            }

            public init(id: Double? = nil, status: Status? = nil, appName: String? = nil, appDisplayName: String? = nil, version: String? = nil, shortVersion: String? = nil, releaseNotes: String? = nil, size: Double? = nil, minOs: String? = nil, androidMinAPILevel: String? = nil, bundleIdentifier: String? = nil, fingerprint: String? = nil, uploadedAt: String? = nil, downloadURL: String? = nil, installURL: InstallURL? = nil, distributionStores: [DistributionStore]? = nil) {
                self.id = id
                self.status = status
                self.appName = appName
                self.appDisplayName = appDisplayName
                self.version = version
                self.shortVersion = shortVersion
                self.releaseNotes = releaseNotes
                self.size = size
                self.minOs = minOs
                self.androidMinAPILevel = androidMinAPILevel
                self.bundleIdentifier = bundleIdentifier
                self.fingerprint = fingerprint
                self.uploadedAt = uploadedAt
                self.downloadURL = downloadURL
                self.installURL = installURL
                self.distributionStores = distributionStores
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case status
                case appName = "app_name"
                case appDisplayName = "app_display_name"
                case version
                case shortVersion = "short_version"
                case releaseNotes = "release_notes"
                case size
                case minOs = "min_os"
                case androidMinAPILevel = "android_min_api_level"
                case bundleIdentifier = "bundle_identifier"
                case fingerprint
                case uploadedAt = "uploaded_at"
                case downloadURL = "download_url"
                case installURL = "install_url"
                case distributionStores = "distribution_stores"
            }
        }

        /// Delete the release with release Id
        public func delete(_ body: String? = nil) -> Request<Void> {
            .delete(path, body: body)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.DistributionStores.WithStoreName {
    public var releases: Releases {
        Releases(path: path + "/releases")
    }

    public struct Releases {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases`
        public let path: String

        /// Return all releases published  in a store
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        /// Basic information on a release
        public struct GetResponseItem: Decodable {
            /// ID identifying this unique release.
            public var id: Double?
            /// The release's version.
            /// For iOS: CFBundleVersion from info.plist.
            /// For Android: android:versionCode from AppManifest.xml.
            public var version: String?
            /// The release's short version.
            /// For iOS: CFBundleShortVersionString from info.plist.
            /// For Android: android:versionName from AppManifest.xml.
            public var shortVersion: String?
            /// UTC time in ISO 8601 format of the uploaded time.
            public var uploadedAt: String?
            /// Destination for this release.
            public var destinationType: DestinationType?
            /// A list of distribution stores that are associated with this release.
            public var distributionStores: [DistributionStore]?

            /// Destination for this release.
            public enum DestinationType: String, Codable, CaseIterable {
                case group
                case store
                case tester
            }

            public struct DistributionStore: Decodable {
                /// ID identifying a unique distribution store.
                public var id: String?
                /// A name identifying a unique distribution store.
                public var name: String?
                /// A type identifying the type of distribution store.
                public var type: `Type`?
                /// A status identifying the status of release in the distribution store.
                public var publishingStatus: String?
                /// Is the containing release the latest one in this distribution store.
                public var isLatest: Bool?

                /// A type identifying the type of distribution store.
                public enum `Type`: String, Codable, CaseIterable {
                    case googleplay
                    case intune
                    case apple
                }

                public init(id: String? = nil, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil, isLatest: Bool? = nil) {
                    self.id = id
                    self.name = name
                    self.type = type
                    self.publishingStatus = publishingStatus
                    self.isLatest = isLatest
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case name
                    case type
                    case publishingStatus = "publishing_status"
                    case isLatest = "is_latest"
                }
            }

            public init(id: Double? = nil, version: String? = nil, shortVersion: String? = nil, uploadedAt: String? = nil, destinationType: DestinationType? = nil, distributionStores: [DistributionStore]? = nil) {
                self.id = id
                self.version = version
                self.shortVersion = shortVersion
                self.uploadedAt = uploadedAt
                self.destinationType = destinationType
                self.distributionStores = distributionStores
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case version
                case shortVersion = "short_version"
                case uploadedAt = "uploaded_at"
                case destinationType = "destination_type"
                case distributionStores = "distribution_stores"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.DistributionStores.WithStoreName {
    public var latestRelease: LatestRelease {
        LatestRelease(path: path + "/latest_release")
    }

    public struct LatestRelease {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/latest_release`
        public let path: String

        /// Returns the latest release published in a store.
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        /// Details of an uploaded release
        public struct GetResponseItem: Decodable {
            /// ID identifying this unique release.
            public var id: Double?
            /// OBSOLETE. Will be removed in next version. The availability concept is now replaced with distributed. Any 'available' release will be associated with the default distribution group of an app.</br>
            /// The release state.<br>
            /// <b>available</b>: The uploaded release has been distributed.<br>
            /// <b>unavailable</b>: The uploaded release is not visible to the user. <br>
            public var status: Status?
            /// The app's name (extracted from the uploaded release).
            public var appName: String?
            /// The app's display name.
            public var appDisplayName: String?
            /// The release's version.<br>
            /// For iOS: CFBundleVersion from info.plist.
            /// For Android: android:versionCode from AppManifest.xml.
            public var version: String?
            /// The release's short version.<br>
            /// For iOS: CFBundleShortVersionString from info.plist.
            /// For Android: android:versionName from AppManifest.xml.
            public var shortVersion: String?
            /// The release's release notes.
            public var releaseNotes: String?
            /// The release's size in bytes.
            public var size: Double?
            /// The release's minimum required operating system.
            public var minOs: String?
            /// The release's minimum required Android API level.
            public var androidMinAPILevel: String?
            /// The identifier of the apps bundle.
            public var bundleIdentifier: String?
            /// MD5 checksum of the release binary.
            public var fingerprint: String?
            /// UTC time in ISO 8601 format of the uploaded time.
            public var uploadedAt: String?
            /// The URL that hosts the binary for this release.
            public var downloadURL: String?
            /// The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`
            public var installURL: InstallURL?
            /// A list of distribution stores that are associated with this release.
            public var distributionStores: [DistributionStore]?

            /// OBSOLETE. Will be removed in next version. The availability concept is now replaced with distributed. Any 'available' release will be associated with the default distribution group of an app.</br>
            /// The release state.<br>
            /// <b>available</b>: The uploaded release has been distributed.<br>
            /// <b>unavailable</b>: The uploaded release is not visible to the user. <br>
            public enum Status: String, Codable, CaseIterable {
                case available
                case unavailable
            }

            /// The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`
            public enum InstallURL: String, Codable, CaseIterable {
                case group
                case store
            }

            public struct DistributionStore: Decodable {
                /// ID identifying a unique distribution store.
                public var id: String?
                /// A name identifying a unique distribution store.
                public var name: String?
                /// Type of the distribution store currently stores type can be intune or googleplay.
                public var type: `Type`?
                /// Publishing status of the release in the store.
                public var publishingStatus: String?

                /// Type of the distribution store currently stores type can be intune or googleplay.
                public enum `Type`: String, Codable, CaseIterable {
                    case intune
                    case googleplay
                }

                public init(id: String? = nil, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil) {
                    self.id = id
                    self.name = name
                    self.type = type
                    self.publishingStatus = publishingStatus
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case name
                    case type
                    case publishingStatus = "publishing_status"
                }
            }

            public init(id: Double? = nil, status: Status? = nil, appName: String? = nil, appDisplayName: String? = nil, version: String? = nil, shortVersion: String? = nil, releaseNotes: String? = nil, size: Double? = nil, minOs: String? = nil, androidMinAPILevel: String? = nil, bundleIdentifier: String? = nil, fingerprint: String? = nil, uploadedAt: String? = nil, downloadURL: String? = nil, installURL: InstallURL? = nil, distributionStores: [DistributionStore]? = nil) {
                self.id = id
                self.status = status
                self.appName = appName
                self.appDisplayName = appDisplayName
                self.version = version
                self.shortVersion = shortVersion
                self.releaseNotes = releaseNotes
                self.size = size
                self.minOs = minOs
                self.androidMinAPILevel = androidMinAPILevel
                self.bundleIdentifier = bundleIdentifier
                self.fingerprint = fingerprint
                self.uploadedAt = uploadedAt
                self.downloadURL = downloadURL
                self.installURL = installURL
                self.distributionStores = distributionStores
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case status
                case appName = "app_name"
                case appDisplayName = "app_display_name"
                case version
                case shortVersion = "short_version"
                case releaseNotes = "release_notes"
                case size
                case minOs = "min_os"
                case androidMinAPILevel = "android_min_api_level"
                case bundleIdentifier = "bundle_identifier"
                case fingerprint
                case uploadedAt = "uploaded_at"
                case downloadURL = "download_url"
                case installURL = "install_url"
                case distributionStores = "distribution_stores"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.DistributionStores {
    public func storeName(_ storeName: String) -> WithStoreName {
        WithStoreName(path: "\(path)/\(storeName)")
    }

    public struct WithStoreName {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}`
        public let path: String

        /// Return the store details for specified store name.
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Update the store.
        public func patch(serviceConnectionID: String) -> Request<Void> {
            .patch(path, body: ["service_connection_id": serviceConnectionID])
        }

        /// Delete the store based on specific store name.
        public func delete(_ body: String? = nil) -> Request<Void> {
            .delete(path, body: body)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var distributionStores: DistributionStores {
        DistributionStores(path: path + "/distribution_stores")
    }

    public struct DistributionStores {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_stores`
        public let path: String

        /// Get all the store details from Storage store table for a particular application.
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        /// ExternalStoreResponse
        public struct GetResponseItem: Decodable {
            /// Store id
            public var id: String?
            /// Store Name
            public var name: String?
            /// Store Type
            public var type: String?
            /// Store track
            public var track: Track?
            /// Store details for intune
            public var intuneDetails: IntuneDetails?
            /// Id for the shared service connection. In case of Apple / GooglePlay stores, this connection will be used to connect to the Apple / Google stores in App Center.
            public var serviceConnectionID: String?
            /// The ID of the principal that created the store.
            public var createdBy: String?
            /// The type of the principal that created the store.
            public var createdByPrincipalType: String?

            /// Store track
            public enum Track: String, Codable, CaseIterable {
                case production
                case alpha
                case beta
                case testflightInternal = "testflight-internal"
                case testflightExternal = "testflight-external"
            }

            /// Store details for intune
            public struct IntuneDetails: Decodable {
                public var targetAudience: TargetAudience?
                public var appCategory: AppCategory?

                public struct TargetAudience: Decodable {
                    /// Display name for the target audience/group
                    public var name: String?
                    /// ID for the target audience/group.
                    public var id: String?

                    public init(name: String? = nil, id: String? = nil) {
                        self.name = name
                        self.id = id
                    }
                }

                public struct AppCategory: Decodable {
                    /// Display name for the app category
                    public var name: String?
                    /// ID for the category.
                    public var id: String?

                    public init(name: String? = nil, id: String? = nil) {
                        self.name = name
                        self.id = id
                    }
                }

                public init(targetAudience: TargetAudience? = nil, appCategory: AppCategory? = nil) {
                    self.targetAudience = targetAudience
                    self.appCategory = appCategory
                }

                private enum CodingKeys: String, CodingKey {
                    case targetAudience = "target_audience"
                    case appCategory = "app_category"
                }
            }

            public init(id: String? = nil, name: String? = nil, type: String? = nil, track: Track? = nil, intuneDetails: IntuneDetails? = nil, serviceConnectionID: String? = nil, createdBy: String? = nil, createdByPrincipalType: String? = nil) {
                self.id = id
                self.name = name
                self.type = type
                self.track = track
                self.intuneDetails = intuneDetails
                self.serviceConnectionID = serviceConnectionID
                self.createdBy = createdBy
                self.createdByPrincipalType = createdByPrincipalType
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case name
                case type
                case track
                case intuneDetails = "intune_details"
                case serviceConnectionID = "service_connection_id"
                case createdBy = "created_by"
                case createdByPrincipalType = "created_by_principal_type"
            }
        }

        /// Create a new external store for the specified application.
        public func post(_ body: PostRequest) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        /// ExternalStoreRequest
        public struct PostRequest: Encodable {
            /// Store Type
            public var type: `Type`?
            /// Name of the store. In case of googleplay, and Apple store this is fixed to Production.
            public var name: String?
            /// Track of the store. Can be production, alpha & beta for googleplay. Can be production, testflight-internal & testflight-external for Apple Store.
            public var track: Track?
            public var intuneDetails: IntuneDetails?
            /// Id for the shared service connection. In case of Apple AppStore, this connection will be used to create and connect to the Apple AppStore in Mobile Center.
            public var serviceConnectionID: String?

            /// Store Type
            public enum `Type`: String, Codable, CaseIterable {
                case googleplay
                case apple
                case intune
            }

            /// Track of the store. Can be production, alpha & beta for googleplay. Can be production, testflight-internal & testflight-external for Apple Store.
            public enum Track: String, Codable, CaseIterable {
                case production
                case alpha
                case beta
                case testflightInternal = "testflight-internal"
                case testflightExternal = "testflight-external"
            }

            public struct IntuneDetails: Encodable {
                public var secretJSON: SecretJSON?
                public var targetAudience: TargetAudience?
                public var appCategory: AppCategory?
                /// Tenant id of the intune store
                public var tenantID: String?

                public struct SecretJSON: Encodable {
                    /// The id token of user
                    public var idToken: String?
                    /// The refresh token for user
                    public var refreshToken: String?
                    /// The expiry of refresh token
                    public var refreshTokenExpiry: String?

                    public init(idToken: String? = nil, refreshToken: String? = nil, refreshTokenExpiry: String? = nil) {
                        self.idToken = idToken
                        self.refreshToken = refreshToken
                        self.refreshTokenExpiry = refreshTokenExpiry
                    }

                    private enum CodingKeys: String, CodingKey {
                        case idToken = "id_token"
                        case refreshToken = "refresh_token"
                        case refreshTokenExpiry = "refresh_token_expiry"
                    }
                }

                public struct TargetAudience: Encodable {
                    /// Display name for the target audience/group
                    public var name: String?

                    public init(name: String? = nil) {
                        self.name = name
                    }
                }

                public struct AppCategory: Encodable {
                    /// Display name for the app category
                    public var name: String?

                    public init(name: String? = nil) {
                        self.name = name
                    }
                }

                public init(secretJSON: SecretJSON? = nil, targetAudience: TargetAudience? = nil, appCategory: AppCategory? = nil, tenantID: String? = nil) {
                    self.secretJSON = secretJSON
                    self.targetAudience = targetAudience
                    self.appCategory = appCategory
                    self.tenantID = tenantID
                }

                private enum CodingKeys: String, CodingKey {
                    case secretJSON = "secret_json"
                    case targetAudience = "target_audience"
                    case appCategory = "app_category"
                    case tenantID = "tenant_id"
                }
            }

            public init(type: `Type`? = nil, name: String? = nil, track: Track? = nil, intuneDetails: IntuneDetails? = nil, serviceConnectionID: String? = nil) {
                self.type = type
                self.name = name
                self.track = track
                self.intuneDetails = intuneDetails
                self.serviceConnectionID = serviceConnectionID
            }

            private enum CodingKeys: String, CodingKey {
                case type
                case name
                case track
                case intuneDetails = "intune_details"
                case serviceConnectionID = "service_connection_id"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.DistributionGroups.WithDistributionGroupName {
    public var resendInvite: ResendInvite {
        ResendInvite(path: path + "/resend_invite")
    }

    public struct ResendInvite {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/resend_invite`
        public let path: String

        /// Resend distribution group app invite notification to previously invited testers
        public func post(userEmails: [String]? = nil) -> Request<Void> {
            .post(path, body: ["user_emails": userEmails])
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.DistributionGroups.WithDistributionGroupName.Releases {
    public func releaseID(_ releaseID: String) -> WithReleaseID {
        WithReleaseID(path: "\(path)/\(releaseID)")
    }

    public struct WithReleaseID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/releases/{release_id}`
        public let path: String

        /// Return detailed information about a distributed release in a given distribution group.
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Deletes a release with id 'release_id' in a given distribution group.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.DistributionGroups.WithDistributionGroupName {
    public var releases: Releases {
        Releases(path: path + "/releases")
    }

    public struct Releases {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/releases`
        public let path: String

        /// Return basic information about distributed releases in a given distribution group.
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        /// Response for getting a list of releases in a distribution group
        public struct GetResponseItem: Decodable {
            /// ID identifying this unique release.
            public var id: Int
            /// The release's version.<br>
            /// For iOS: CFBundleVersion from info.plist.<br>
            /// For Android: android:versionCode from AppManifest.xml.
            public var version: String
            /// The release's origin
            public var origin: Origin?
            /// The release's short version.<br>
            /// For iOS: CFBundleShortVersionString from info.plist.<br>
            /// For Android: android:versionName from AppManifest.xml.
            public var shortVersion: String
            /// A boolean which determines whether the release is a mandatory update or not.
            public var isMandatoryUpdate: Bool
            /// UTC time in ISO 8601 format of the uploaded time.
            public var uploadedAt: String
            /// This value determines the whether a release currently is enabled or disabled.
            public var isEnabled: Bool
            /// This value determines if a release is external or not.
            public var isExternalBuild: Bool?

            /// The release's origin
            public enum Origin: String, Codable, CaseIterable {
                case hockeyapp
                case appcenter
            }

            public init(id: Int, version: String, origin: Origin? = nil, shortVersion: String, isMandatoryUpdate: Bool, uploadedAt: String, isEnabled: Bool, isExternalBuild: Bool? = nil) {
                self.id = id
                self.version = version
                self.origin = origin
                self.shortVersion = shortVersion
                self.isMandatoryUpdate = isMandatoryUpdate
                self.uploadedAt = uploadedAt
                self.isEnabled = isEnabled
                self.isExternalBuild = isExternalBuild
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case version
                case origin
                case shortVersion = "short_version"
                case isMandatoryUpdate = "mandatory_update"
                case uploadedAt = "uploaded_at"
                case isEnabled = "enabled"
                case isExternalBuild = "is_external_build"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.DistributionGroups.WithDistributionGroupName.Members {
    public var bulkDelete: BulkDelete {
        BulkDelete(path: path + "/bulk_delete")
    }

    public struct BulkDelete {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/members/bulk_delete`
        public let path: String

        /// Remove the users from the distribution group
        public func post(userEmails: [String]? = nil) -> Request<[PostResponseItem]> {
            .post(path, body: ["user_emails": userEmails])
        }

        public struct PostResponseItem: Decodable {
            /// The code of the result
            public var code: String?
            /// The message of the result
            public var message: Int?
            /// The status code of the result
            public var status: Int
            /// The email of the user
            public var userEmail: String?

            public init(code: String? = nil, message: Int? = nil, status: Int, userEmail: String? = nil) {
                self.code = code
                self.message = message
                self.status = status
                self.userEmail = userEmail
            }

            private enum CodingKeys: String, CodingKey {
                case code
                case message
                case status
                case userEmail = "user_email"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.DistributionGroups.WithDistributionGroupName {
    public var members: Members {
        Members(path: path + "/members")
    }

    public struct Members {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/members`
        public let path: String

        /// Returns a list of member details in the distribution group specified
        public func get(excludePendingInvitations: Bool? = nil) -> Request<[GetResponseItem]> {
            .get(path, query: makeGetQuery(excludePendingInvitations))
        }

        public struct GetResponseItem: Decodable {
            /// The unique id (UUID) of the user
            public var id: String?
            /// The avatar URL of the user
            public var avatarURL: String?
            /// User is required to send an old password in order to change the password.
            public var canChangePassword: Bool?
            /// The full name of the user. Might for example be first and last name
            public var displayName: String?
            /// The email address of the user
            public var email: String
            /// Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".
            public var isInvitePending: Bool?
            /// The unique name that is used to identify the user.
            public var name: String?

            public init(id: String? = nil, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String? = nil, email: String, isInvitePending: Bool? = nil, name: String? = nil) {
                self.id = id
                self.avatarURL = avatarURL
                self.canChangePassword = canChangePassword
                self.displayName = displayName
                self.email = email
                self.isInvitePending = isInvitePending
                self.name = name
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case avatarURL = "avatar_url"
                case canChangePassword = "can_change_password"
                case displayName = "display_name"
                case email
                case isInvitePending = "invite_pending"
                case name
            }
        }

        private func makeGetQuery(_ excludePendingInvitations: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(excludePendingInvitations, forKey: "exclude_pending_invitations")
            return encoder.items
        }

        /// Adds the members to the specified distribution group
        public func post(userEmails: [String]? = nil) -> Request<[PostResponseItem]> {
            .post(path, body: ["user_emails": userEmails])
        }

        public struct PostResponseItem: Decodable {
            /// The code of the result
            public var code: String?
            /// Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".
            public var isInvitePending: Bool?
            /// The message of the result
            public var message: String?
            /// The status code of the result
            public var status: Int
            /// The email of the user
            public var userEmail: String?

            public init(code: String? = nil, isInvitePending: Bool? = nil, message: String? = nil, status: Int, userEmail: String? = nil) {
                self.code = code
                self.isInvitePending = isInvitePending
                self.message = message
                self.status = status
                self.userEmail = userEmail
            }

            private enum CodingKeys: String, CodingKey {
                case code
                case isInvitePending = "invite_pending"
                case message
                case status
                case userEmail = "user_email"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.DistributionGroups.WithDistributionGroupName.Devices {
    public var downloadDevicesList: DownloadDevicesList {
        DownloadDevicesList(path: path + "/download_devices_list")
    }

    public struct DownloadDevicesList {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/devices/download_devices_list`
        public let path: String

        /// Returns all devices associated with the given distribution group.
        public func get(isUnprovisionedOnly: Bool? = nil, udids: [String]? = nil) -> Request<Void> {
            .get(path, query: makeGetQuery(isUnprovisionedOnly, udids))
        }

        private func makeGetQuery(_ isUnprovisionedOnly: Bool?, _ udids: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isUnprovisionedOnly, forKey: "unprovisioned_only")
            encoder.encode(udids, forKey: "udids", explode: false)
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.DistributionGroups.WithDistributionGroupName {
    public var devices: Devices {
        Devices(path: path + "/devices")
    }

    public struct Devices {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/devices`
        public let path: String

        /// Returns all devices associated with the given distribution group
        public func get(releaseID: Double? = nil) -> Request<[GetResponseItem]> {
            .get(path, query: makeGetQuery(releaseID))
        }

        /// The information for a single iOS device
        public struct GetResponseItem: Decodable {
            /// The Unique Device IDentifier of the device
            public var udid: String
            /// The model identifier of the device, in the format iDeviceM,N
            public var model: String
            /// The device description, in the format "iPhone 7 Plus (A1784)"
            public var deviceName: String
            /// A combination of the device model name and the owner name.
            public var fullDeviceName: String?
            /// The last known OS version running on the device
            public var osBuild: String
            /// The last known OS version running on the device
            public var osVersion: String
            /// The device's serial number. Always empty or undefined at present.
            public var serial: String?
            /// The device's International Mobile Equipment Identity number. Always empty or undefined at present.
            public var imei: String?
            /// The user ID of the device owner.
            public var ownerID: String?
            /// The provisioning status of the device.
            public var status: String
            /// Timestamp of when the device was registered in ISO format.
            public var registeredAt: String?

            public init(udid: String, model: String, deviceName: String, fullDeviceName: String? = nil, osBuild: String, osVersion: String, serial: String? = nil, imei: String? = nil, ownerID: String? = nil, status: String, registeredAt: String? = nil) {
                self.udid = udid
                self.model = model
                self.deviceName = deviceName
                self.fullDeviceName = fullDeviceName
                self.osBuild = osBuild
                self.osVersion = osVersion
                self.serial = serial
                self.imei = imei
                self.ownerID = ownerID
                self.status = status
                self.registeredAt = registeredAt
            }

            private enum CodingKeys: String, CodingKey {
                case udid
                case model
                case deviceName = "device_name"
                case fullDeviceName = "full_device_name"
                case osBuild = "os_build"
                case osVersion = "os_version"
                case serial
                case imei
                case ownerID = "owner_id"
                case status
                case registeredAt = "registered_at"
            }
        }

        private func makeGetQuery(_ releaseID: Double?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(releaseID, forKey: "release_id")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.DistributionGroups {
    public func distributionGroupName(_ distributionGroupName: String) -> WithDistributionGroupName {
        WithDistributionGroupName(path: "\(path)/\(distributionGroupName)")
    }

    public struct WithDistributionGroupName {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}`
        public let path: String

        /// Returns a single distribution group for a given distribution group name
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Updates the attributes of distribution group
        public func patch(_ body: PatchRequest) -> Request<[String: AnyJSON]> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// The name of the distribution group
            public var name: String?
            /// Whether the distribution group is public
            public var isPublic: Bool?

            public init(name: String? = nil, isPublic: Bool? = nil) {
                self.name = name
                self.isPublic = isPublic
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case isPublic = "is_public"
            }
        }

        /// Deletes a distribution group
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var distributionGroups: DistributionGroups {
        DistributionGroups(path: path + "/distribution_groups")
    }

    public struct DistributionGroups {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_groups`
        public let path: String

        /// Returns a list of distribution groups in the app specified
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The unique ID of the distribution group
            public var id: String
            /// The name of the distribution group used in URLs
            public var name: String
            /// The name of the distribution group
            public var displayName: String?
            /// The creation origin of this distribution group
            public var origin: Origin
            /// Whether the distribution group is public
            public var isPublic: Bool

            /// The creation origin of this distribution group
            public enum Origin: String, Codable, CaseIterable {
                case appcenter
                case hockeyapp
            }

            public init(id: String, name: String, displayName: String? = nil, origin: Origin, isPublic: Bool) {
                self.id = id
                self.name = name
                self.displayName = displayName
                self.origin = origin
                self.isPublic = isPublic
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case name
                case displayName = "display_name"
                case origin
                case isPublic = "is_public"
            }
        }

        /// Creates a new distribution group and returns it to the caller
        public func post(_ body: PostRequest) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The name of the distribution group
            public var name: String
            /// The display name of the distribution group. If not specified, the name will be used.
            public var displayName: String?

            public init(name: String, displayName: String? = nil) {
                self.name = name
                self.displayName = displayName
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case displayName = "display_name"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var diagnostics: Diagnostics {
        Diagnostics(path: path + "/diagnostics")
    }

    public struct Diagnostics {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/diagnostics`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Diagnostics {
    public var symbolGroupsInfo: SymbolGroupsInfo {
        SymbolGroupsInfo(path: path + "/symbol_groups_info")
    }

    public struct SymbolGroupsInfo {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/diagnostics/symbol_groups_info`
        public let path: String

        /// Gets application level statistics for all missing symbol groups
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Diagnostics.SymbolGroups {
    public func symbolGroupID(_ symbolGroupID: String) -> WithSymbolGroupID {
        WithSymbolGroupID(path: "\(path)/\(symbolGroupID)")
    }

    public struct WithSymbolGroupID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/diagnostics/symbol_groups/{symbol_group_id}`
        public let path: String

        /// Gets missing symbol crash group by its id
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Diagnostics {
    public var symbolGroups: SymbolGroups {
        SymbolGroups(path: path + "/symbol_groups")
    }

    public struct SymbolGroups {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/diagnostics/symbol_groups`
        public let path: String

        /// Gets top N (ordered by crash count) of crash groups by missing symbol
        public func get(top: Int, filter: String? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(top, filter))
        }

        private func makeGetQuery(_ top: Int, _ filter: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(top, forKey: "top")
            encoder.encode(filter, forKey: "filter")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var devices: Devices {
        Devices(path: path + "/devices")
    }

    public struct Devices {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/devices`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Devices.BlockLogs {
    public func installID(_ installID: String) -> WithInstallID {
        WithInstallID(path: "\(path)/\(installID)")
    }

    public struct WithInstallID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/devices/block_logs/{install_id}`
        public let path: String

        /// **Warning, this operation is not reversible.**
        /// 
        ///  A successful call to this API will permanently stop ingesting any logs received via SDK for the given installation ID, and cannot be restored. We advise caution when using this API, it is designed to permanently disable collection from a specific installation of the app on a device, usually following the request from a user.
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Devices {
    public var blockLogs: BlockLogs {
        BlockLogs(path: path + "/block_logs")
    }

    public struct BlockLogs {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/devices/block_logs`
        public let path: String

        /// **Warning, this operation is not reversible.** 
        /// 
        /// A successful call to this API will permanently stop ingesting any logs received via SDK by app_id, and cannot be restored. We advise caution when using this API, it is designed to permanently disable an app_id.
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var deviceSelection: DeviceSelection {
        DeviceSelection(path: path + "/device_selection")
    }

    public struct DeviceSelection {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/device_selection`
        public let path: String

        /// Creates a short ID for a list of devices
        public func post(devices: [String]) -> Request<PostResponse> {
            .post(path, body: ["devices": devices])
        }

        /// Device Selection
        ///
        /// Short ID for a list of device IDs
        public struct PostResponse: Decodable {
            /// Identifier of the device selection
            public var shortID: String

            public init(shortID: String) {
                self.shortID = shortID
            }

            private enum CodingKeys: String, CodingKey {
                case shortID = "shortId"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var deviceConfigurations: DeviceConfigurations {
        DeviceConfigurations(path: path + "/device_configurations")
    }

    public struct DeviceConfigurations {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/device_configurations`
        public let path: String

        /// Returns a list of available devices
        public func get(appUploadID: String? = nil) -> Request<[GetResponseItem]> {
            .get(path, query: makeGetQuery(appUploadID))
        }

        public struct GetResponseItem: Decodable {
            /// The name of the device model and OS version
            public var name: String?
            /// The unique id of the device configuration
            public var id: String?
            /// The tier
            public var tier: Double?
            public var image: Image?
            public var model: Model?
            public var os: String?
            public var osName: String?
            public var marketShare: Double?

            public struct Image: Decodable {
                public var full: String?
                public var thumb: String?

                public init(full: String? = nil, thumb: String? = nil) {
                    self.full = full
                    self.thumb = thumb
                }
            }

            public struct Model: Decodable {
                public var name: String?
                public var manufacturer: String?
                public var model: String?
                public var platform: String?
                /// Physical device dimensions
                public var dimensions: Dimensions?
                /// Device screen resolution
                public var resolution: Resolution?
                public var releaseDate: String?
                public var formFactor: String?
                /// Physical device screen dimensions
                public var screenSize: ScreenSize?
                /// CPU data for device
                public var cpu: Cpu?
                /// Memory data for device
                public var memory: Memory?
                public var screenRotation: Double?
                public var deviceFrame: DeviceFrame?
                public var availabilityCount: Double?

                /// Physical device dimensions
                public struct Dimensions: Decodable {
                    public var depth: [String: AnyJSON]?
                    public var height: [String: AnyJSON]?
                    public var width: [String: AnyJSON]?

                    public init(depth: [String: AnyJSON]? = nil, height: [String: AnyJSON]? = nil, width: [String: AnyJSON]? = nil) {
                        self.depth = depth
                        self.height = height
                        self.width = width
                    }
                }

                /// Device screen resolution
                public struct Resolution: Decodable {
                    public var height: String?
                    public var width: String?
                    public var ppi: String?

                    public init(height: String? = nil, width: String? = nil, ppi: String? = nil) {
                        self.height = height
                        self.width = width
                        self.ppi = ppi
                    }
                }

                /// Physical device screen dimensions
                public struct ScreenSize: Decodable {
                    public var cm: String?
                    public var `in`: String?

                    public init(cm: String? = nil, `in`: String? = nil) {
                        self.cm = cm
                        self.in = `in`
                    }

                    private enum CodingKeys: String, CodingKey {
                        case cm
                        case `in` = "in"
                    }
                }

                /// CPU data for device
                public struct Cpu: Decodable {
                    public var frequency: String?
                    public var core: String?
                    public var text: String?

                    public init(frequency: String? = nil, core: String? = nil, text: String? = nil) {
                        self.frequency = frequency
                        self.core = core
                        self.text = text
                    }
                }

                /// Memory data for device
                public struct Memory: Decodable {
                    public var formattedSize: String?

                    public init(formattedSize: String? = nil) {
                        self.formattedSize = formattedSize
                    }
                }

                public struct DeviceFrame: Decodable {
                    public var grid: Grid?
                    public var full: Full?

                    public struct Grid: Decodable {
                        public var width: Double?
                        public var height: Double?
                        public var frameURL: String?
                        public var screen: [Double]?

                        public init(width: Double? = nil, height: Double? = nil, frameURL: String? = nil, screen: [Double]? = nil) {
                            self.width = width
                            self.height = height
                            self.frameURL = frameURL
                            self.screen = screen
                        }

                        private enum CodingKeys: String, CodingKey {
                            case width
                            case height
                            case frameURL = "frameUrl"
                            case screen
                        }
                    }

                    public struct Full: Decodable {
                        public var width: Double?
                        public var height: Double?
                        public var frameURL: String?
                        public var screen: [Double]?

                        public init(width: Double? = nil, height: Double? = nil, frameURL: String? = nil, screen: [Double]? = nil) {
                            self.width = width
                            self.height = height
                            self.frameURL = frameURL
                            self.screen = screen
                        }

                        private enum CodingKeys: String, CodingKey {
                            case width
                            case height
                            case frameURL = "frameUrl"
                            case screen
                        }
                    }

                    public init(grid: Grid? = nil, full: Full? = nil) {
                        self.grid = grid
                        self.full = full
                    }
                }

                public init(name: String? = nil, manufacturer: String? = nil, model: String? = nil, platform: String? = nil, dimensions: Dimensions? = nil, resolution: Resolution? = nil, releaseDate: String? = nil, formFactor: String? = nil, screenSize: ScreenSize? = nil, cpu: Cpu? = nil, memory: Memory? = nil, screenRotation: Double? = nil, deviceFrame: DeviceFrame? = nil, availabilityCount: Double? = nil) {
                    self.name = name
                    self.manufacturer = manufacturer
                    self.model = model
                    self.platform = platform
                    self.dimensions = dimensions
                    self.resolution = resolution
                    self.releaseDate = releaseDate
                    self.formFactor = formFactor
                    self.screenSize = screenSize
                    self.cpu = cpu
                    self.memory = memory
                    self.screenRotation = screenRotation
                    self.deviceFrame = deviceFrame
                    self.availabilityCount = availabilityCount
                }
            }

            public init(name: String? = nil, id: String? = nil, tier: Double? = nil, image: Image? = nil, model: Model? = nil, os: String? = nil, osName: String? = nil, marketShare: Double? = nil) {
                self.name = name
                self.id = id
                self.tier = tier
                self.image = image
                self.model = model
                self.os = os
                self.osName = osName
                self.marketShare = marketShare
            }
        }

        private func makeGetQuery(_ appUploadID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(appUploadID, forKey: "app_upload_id")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Deployments.WithDeploymentName {
    public var uploads: Uploads {
        Uploads(path: path + "/uploads")
    }

    public struct Uploads {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/uploads`
        public let path: String

        /// Create a new CodePush release upload for the specified deployment
        public var post: Request<[String: AnyJSON]> {
            .post(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Deployments.WithDeploymentName {
    public var rollbackRelease: RollbackRelease {
        RollbackRelease(path: path + "/rollback_release")
    }

    public struct RollbackRelease {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/rollback_release`
        public let path: String

        /// Rollback the latest or a specific release for an app deployment
        public func post(label: String? = nil) -> Request<[String: AnyJSON]> {
            .post(path, body: ["label": label])
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Deployments.WithDeploymentName.Releases {
    public func releaseLabel(_ releaseLabel: String) -> WithReleaseLabel {
        WithReleaseLabel(path: "\(path)/\(releaseLabel)")
    }

    public struct WithReleaseLabel {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/releases/{release_label}`
        public let path: String

        /// Modifies a CodePush release metadata under the given Deployment
        public func patch(_ body: PatchRequest) -> Request<[String: AnyJSON]> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            public var targetBinaryRange: String?
            public var description: String?
            public var isDisabled: Bool?
            public var isMandatory: Bool?
            public var rollout: Int?

            public init(targetBinaryRange: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil) {
                self.targetBinaryRange = targetBinaryRange
                self.description = description
                self.isDisabled = isDisabled
                self.isMandatory = isMandatory
                self.rollout = rollout
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(targetBinaryRange, forKey: "target_binary_range")
                try values.encodeIfPresent(description, forKey: "description")
                try values.encodeIfPresent(isDisabled, forKey: "is_disabled")
                try values.encodeIfPresent(isMandatory, forKey: "is_mandatory")
                try values.encodeIfPresent(rollout, forKey: "rollout")
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Deployments.WithDeploymentName {
    public var releases: Releases {
        Releases(path: path + "/releases")
    }

    public struct Releases {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/releases`
        public let path: String

        /// Gets the history of releases on a Deployment
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            public var targetBinaryRange: String?
            public var description: String?
            public var isDisabled: Bool?
            public var isMandatory: Bool?
            public var rollout: Int?
            public var label: String?
            public var packageHash: String?
            public var blobURL: String?
            public var diffPackageMap: [String: DiffPackageMapItem]?
            /// Set on 'Promote'
            public var originalDeployment: String?
            /// Set on 'Promote' and 'Rollback'
            public var originalLabel: String?
            public var releasedBy: String?
            /// The release method is unknown if unspecified
            public var releaseMethod: ReleaseMethod?
            public var size: Double?
            public var uploadTime: Int?

            public struct DiffPackageMapItem: Decodable {
                public var size: Double
                public var url: String

                public init(size: Double, url: String) {
                    self.size = size
                    self.url = url
                }
            }

            /// The release method is unknown if unspecified
            public enum ReleaseMethod: String, Codable, CaseIterable {
                case upload = "Upload"
                case promote = "Promote"
                case rollback = "Rollback"
            }

            public init(targetBinaryRange: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, label: String? = nil, packageHash: String? = nil, blobURL: String? = nil, diffPackageMap: [String: DiffPackageMapItem]? = nil, originalDeployment: String? = nil, originalLabel: String? = nil, releasedBy: String? = nil, releaseMethod: ReleaseMethod? = nil, size: Double? = nil, uploadTime: Int? = nil) {
                self.targetBinaryRange = targetBinaryRange
                self.description = description
                self.isDisabled = isDisabled
                self.isMandatory = isMandatory
                self.rollout = rollout
                self.label = label
                self.packageHash = packageHash
                self.blobURL = blobURL
                self.diffPackageMap = diffPackageMap
                self.originalDeployment = originalDeployment
                self.originalLabel = originalLabel
                self.releasedBy = releasedBy
                self.releaseMethod = releaseMethod
                self.size = size
                self.uploadTime = uploadTime
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.targetBinaryRange = try values.decodeIfPresent(String.self, forKey: "target_binary_range")
                self.description = try values.decodeIfPresent(String.self, forKey: "description")
                self.isDisabled = try values.decodeIfPresent(Bool.self, forKey: "is_disabled")
                self.isMandatory = try values.decodeIfPresent(Bool.self, forKey: "is_mandatory")
                self.rollout = try values.decodeIfPresent(Int.self, forKey: "rollout")
                self.label = try values.decodeIfPresent(String.self, forKey: "label")
                self.packageHash = try values.decodeIfPresent(String.self, forKey: "package_hash")
                self.blobURL = try values.decodeIfPresent(String.self, forKey: "blob_url")
                self.diffPackageMap = try values.decodeIfPresent([String: DiffPackageMapItem].self, forKey: "diff_package_map")
                self.originalDeployment = try values.decodeIfPresent(String.self, forKey: "original_deployment")
                self.originalLabel = try values.decodeIfPresent(String.self, forKey: "original_label")
                self.releasedBy = try values.decodeIfPresent(String.self, forKey: "released_by")
                self.releaseMethod = try ReleaseMethod(from: decoder)
                self.size = try values.decodeIfPresent(Double.self, forKey: "size")
                self.uploadTime = try values.decodeIfPresent(Int.self, forKey: "upload_time")
            }
        }

        /// Create a new CodePush release for the specified deployment
        public func post(_ body: PostRequest) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The upload metadata from the release initialization step.
            public var releaseUpload: ReleaseUpload
            /// The binary version of the application
            public var targetBinaryVersion: String
            /// This specifies which deployment you want to release the update to. Default is Staging.
            public var deploymentName: String?
            /// This provides an optional "change log" for the deployment.
            public var description: String?
            /// This specifies whether an update should be downloadable by end users or not.
            public var isDisabled: Bool?
            /// This specifies whether the update should be considered mandatory or not (e.g. it includes a critical security fix).
            public var isMandatory: Bool?
            /// This specifies that if the update is identical to the latest release on the deployment, the CLI should generate a warning instead of an error.
            public var isNoDuplicateReleaseError: Bool?
            /// This specifies the percentage of users (as an integer between 1 and 100) that should be eligible to receive this update.
            public var rollout: Int?

            /// The upload metadata from the release initialization step.
            public struct ReleaseUpload: Encodable {
                /// The ID for the newly created upload. It is going to be required later in the process.
                public var id: String
                /// The URL domain used to upload the release.
                public var uploadDomain: String
                /// The URL encoded token used for upload permissions.
                public var token: String

                public init(id: String, uploadDomain: String, token: String) {
                    self.id = id
                    self.uploadDomain = uploadDomain
                    self.token = token
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case uploadDomain = "upload_domain"
                    case token
                }
            }

            public init(releaseUpload: ReleaseUpload, targetBinaryVersion: String, deploymentName: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, isNoDuplicateReleaseError: Bool? = nil, rollout: Int? = nil) {
                self.releaseUpload = releaseUpload
                self.targetBinaryVersion = targetBinaryVersion
                self.deploymentName = deploymentName
                self.description = description
                self.isDisabled = isDisabled
                self.isMandatory = isMandatory
                self.isNoDuplicateReleaseError = isNoDuplicateReleaseError
                self.rollout = rollout
            }

            private enum CodingKeys: String, CodingKey {
                case releaseUpload = "release_upload"
                case targetBinaryVersion = "target_binary_version"
                case deploymentName = "deployment_name"
                case description
                case isDisabled = "disabled"
                case isMandatory = "mandatory"
                case isNoDuplicateReleaseError = "no_duplicate_release_error"
                case rollout
            }
        }

        /// Clears a Deployment of releases
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Deployments.WithDeploymentName {
    public var promoteRelease: PromoteRelease {
        PromoteRelease(path: path + "/promote_release")
    }

    public struct PromoteRelease {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/promote_release`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Deployments.WithDeploymentName.PromoteRelease {
    public func promoteDeploymentName(_ promoteDeploymentName: String) -> WithPromoteDeploymentName {
        WithPromoteDeploymentName(path: "\(path)/\(promoteDeploymentName)")
    }

    public struct WithPromoteDeploymentName {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/promote_release/{promote_deployment_name}`
        public let path: String

        /// Promote one release (default latest one) from one deployment to another
        public func post(_ body: PostRequest? = nil) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            public var targetBinaryRange: String?
            public var description: String?
            public var isDisabled: Bool?
            public var isMandatory: Bool?
            public var rollout: Int?
            public var label: String?

            public init(targetBinaryRange: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, label: String? = nil) {
                self.targetBinaryRange = targetBinaryRange
                self.description = description
                self.isDisabled = isDisabled
                self.isMandatory = isMandatory
                self.rollout = rollout
                self.label = label
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(targetBinaryRange, forKey: "target_binary_range")
                try values.encodeIfPresent(description, forKey: "description")
                try values.encodeIfPresent(isDisabled, forKey: "is_disabled")
                try values.encodeIfPresent(isMandatory, forKey: "is_mandatory")
                try values.encodeIfPresent(rollout, forKey: "rollout")
                try values.encodeIfPresent(label, forKey: "label")
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Deployments.WithDeploymentName {
    public var metrics: Metrics {
        Metrics(path: path + "/metrics")
    }

    public struct Metrics {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/metrics`
        public let path: String

        /// Gets all releases metrics for specified Deployment
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            public var label: String
            public var active: Int
            public var downloaded: Int?
            public var failed: Int?
            public var installed: Int?

            public init(label: String, active: Int, downloaded: Int? = nil, failed: Int? = nil, installed: Int? = nil) {
                self.label = label
                self.active = active
                self.downloaded = downloaded
                self.failed = failed
                self.installed = installed
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Deployments {
    public func deploymentName(_ deploymentName: String) -> WithDeploymentName {
        WithDeploymentName(path: "\(path)/\(deploymentName)")
    }

    public struct WithDeploymentName {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}`
        public let path: String

        /// Gets a CodePush Deployment for the given app
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var key: String?
            public var name: String
            public var latestRelease: LatestRelease?

            public struct LatestRelease: Decodable {
                public var targetBinaryRange: String?
                public var description: String?
                public var isDisabled: Bool?
                public var isMandatory: Bool?
                public var rollout: Int?
                public var label: String?
                public var packageHash: String?
                public var blobURL: String?
                public var diffPackageMap: [String: DiffPackageMapItem]?
                /// Set on 'Promote'
                public var originalDeployment: String?
                /// Set on 'Promote' and 'Rollback'
                public var originalLabel: String?
                public var releasedBy: String?
                /// The release method is unknown if unspecified
                public var releaseMethod: ReleaseMethod?
                public var size: Double?
                public var uploadTime: Int?

                public struct DiffPackageMapItem: Decodable {
                    public var size: Double
                    public var url: String

                    public init(size: Double, url: String) {
                        self.size = size
                        self.url = url
                    }
                }

                /// The release method is unknown if unspecified
                public enum ReleaseMethod: String, Codable, CaseIterable {
                    case upload = "Upload"
                    case promote = "Promote"
                    case rollback = "Rollback"
                }

                public init(targetBinaryRange: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, label: String? = nil, packageHash: String? = nil, blobURL: String? = nil, diffPackageMap: [String: DiffPackageMapItem]? = nil, originalDeployment: String? = nil, originalLabel: String? = nil, releasedBy: String? = nil, releaseMethod: ReleaseMethod? = nil, size: Double? = nil, uploadTime: Int? = nil) {
                    self.targetBinaryRange = targetBinaryRange
                    self.description = description
                    self.isDisabled = isDisabled
                    self.isMandatory = isMandatory
                    self.rollout = rollout
                    self.label = label
                    self.packageHash = packageHash
                    self.blobURL = blobURL
                    self.diffPackageMap = diffPackageMap
                    self.originalDeployment = originalDeployment
                    self.originalLabel = originalLabel
                    self.releasedBy = releasedBy
                    self.releaseMethod = releaseMethod
                    self.size = size
                    self.uploadTime = uploadTime
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.targetBinaryRange = try values.decodeIfPresent(String.self, forKey: "target_binary_range")
                    self.description = try values.decodeIfPresent(String.self, forKey: "description")
                    self.isDisabled = try values.decodeIfPresent(Bool.self, forKey: "is_disabled")
                    self.isMandatory = try values.decodeIfPresent(Bool.self, forKey: "is_mandatory")
                    self.rollout = try values.decodeIfPresent(Int.self, forKey: "rollout")
                    self.label = try values.decodeIfPresent(String.self, forKey: "label")
                    self.packageHash = try values.decodeIfPresent(String.self, forKey: "package_hash")
                    self.blobURL = try values.decodeIfPresent(String.self, forKey: "blob_url")
                    self.diffPackageMap = try values.decodeIfPresent([String: DiffPackageMapItem].self, forKey: "diff_package_map")
                    self.originalDeployment = try values.decodeIfPresent(String.self, forKey: "original_deployment")
                    self.originalLabel = try values.decodeIfPresent(String.self, forKey: "original_label")
                    self.releasedBy = try values.decodeIfPresent(String.self, forKey: "released_by")
                    self.releaseMethod = try ReleaseMethod(from: decoder)
                    self.size = try values.decodeIfPresent(Double.self, forKey: "size")
                    self.uploadTime = try values.decodeIfPresent(Int.self, forKey: "upload_time")
                }
            }

            public init(key: String? = nil, name: String, latestRelease: LatestRelease? = nil) {
                self.key = key
                self.name = name
                self.latestRelease = latestRelease
            }

            private enum CodingKeys: String, CodingKey {
                case key
                case name
                case latestRelease = "latest_release"
            }
        }

        /// Modifies a CodePush Deployment for the given app
        public func patch(name: String) -> Request<Void> {
            .patch(path, body: ["name": name])
        }

        /// Deletes a CodePush Deployment for the given app
        public func delete(_ body: [String: AnyJSON]? = nil) -> Request<Void> {
            .delete(path, body: body)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var deployments: Deployments {
        Deployments(path: path + "/deployments")
    }

    public struct Deployments {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/deployments`
        public let path: String

        /// Gets a list of CodePush deployments for the given app
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            public var key: String?
            public var name: String
            public var latestRelease: LatestRelease?

            public struct LatestRelease: Decodable {
                public var targetBinaryRange: String?
                public var description: String?
                public var isDisabled: Bool?
                public var isMandatory: Bool?
                public var rollout: Int?
                public var label: String?
                public var packageHash: String?
                public var blobURL: String?
                public var diffPackageMap: [String: DiffPackageMapItem]?
                /// Set on 'Promote'
                public var originalDeployment: String?
                /// Set on 'Promote' and 'Rollback'
                public var originalLabel: String?
                public var releasedBy: String?
                /// The release method is unknown if unspecified
                public var releaseMethod: ReleaseMethod?
                public var size: Double?
                public var uploadTime: Int?

                public struct DiffPackageMapItem: Decodable {
                    public var size: Double
                    public var url: String

                    public init(size: Double, url: String) {
                        self.size = size
                        self.url = url
                    }
                }

                /// The release method is unknown if unspecified
                public enum ReleaseMethod: String, Codable, CaseIterable {
                    case upload = "Upload"
                    case promote = "Promote"
                    case rollback = "Rollback"
                }

                public init(targetBinaryRange: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, label: String? = nil, packageHash: String? = nil, blobURL: String? = nil, diffPackageMap: [String: DiffPackageMapItem]? = nil, originalDeployment: String? = nil, originalLabel: String? = nil, releasedBy: String? = nil, releaseMethod: ReleaseMethod? = nil, size: Double? = nil, uploadTime: Int? = nil) {
                    self.targetBinaryRange = targetBinaryRange
                    self.description = description
                    self.isDisabled = isDisabled
                    self.isMandatory = isMandatory
                    self.rollout = rollout
                    self.label = label
                    self.packageHash = packageHash
                    self.blobURL = blobURL
                    self.diffPackageMap = diffPackageMap
                    self.originalDeployment = originalDeployment
                    self.originalLabel = originalLabel
                    self.releasedBy = releasedBy
                    self.releaseMethod = releaseMethod
                    self.size = size
                    self.uploadTime = uploadTime
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.targetBinaryRange = try values.decodeIfPresent(String.self, forKey: "target_binary_range")
                    self.description = try values.decodeIfPresent(String.self, forKey: "description")
                    self.isDisabled = try values.decodeIfPresent(Bool.self, forKey: "is_disabled")
                    self.isMandatory = try values.decodeIfPresent(Bool.self, forKey: "is_mandatory")
                    self.rollout = try values.decodeIfPresent(Int.self, forKey: "rollout")
                    self.label = try values.decodeIfPresent(String.self, forKey: "label")
                    self.packageHash = try values.decodeIfPresent(String.self, forKey: "package_hash")
                    self.blobURL = try values.decodeIfPresent(String.self, forKey: "blob_url")
                    self.diffPackageMap = try values.decodeIfPresent([String: DiffPackageMapItem].self, forKey: "diff_package_map")
                    self.originalDeployment = try values.decodeIfPresent(String.self, forKey: "original_deployment")
                    self.originalLabel = try values.decodeIfPresent(String.self, forKey: "original_label")
                    self.releasedBy = try values.decodeIfPresent(String.self, forKey: "released_by")
                    self.releaseMethod = try ReleaseMethod(from: decoder)
                    self.size = try values.decodeIfPresent(Double.self, forKey: "size")
                    self.uploadTime = try values.decodeIfPresent(Int.self, forKey: "upload_time")
                }
            }

            public init(key: String? = nil, name: String, latestRelease: LatestRelease? = nil) {
                self.key = key
                self.name = name
                self.latestRelease = latestRelease
            }

            private enum CodingKeys: String, CodingKey {
                case key
                case name
                case latestRelease = "latest_release"
            }
        }

        /// Creates a CodePush Deployment for the given app
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            public var key: String?
            public var name: String
            public var latestRelease: LatestRelease?

            public struct LatestRelease: Decodable {
                public var targetBinaryRange: String?
                public var description: String?
                public var isDisabled: Bool?
                public var isMandatory: Bool?
                public var rollout: Int?
                public var label: String?
                public var packageHash: String?
                public var blobURL: String?
                public var diffPackageMap: [String: DiffPackageMapItem]?
                /// Set on 'Promote'
                public var originalDeployment: String?
                /// Set on 'Promote' and 'Rollback'
                public var originalLabel: String?
                public var releasedBy: String?
                /// The release method is unknown if unspecified
                public var releaseMethod: ReleaseMethod?
                public var size: Double?
                public var uploadTime: Int?

                public struct DiffPackageMapItem: Decodable {
                    public var size: Double
                    public var url: String

                    public init(size: Double, url: String) {
                        self.size = size
                        self.url = url
                    }
                }

                /// The release method is unknown if unspecified
                public enum ReleaseMethod: String, Codable, CaseIterable {
                    case upload = "Upload"
                    case promote = "Promote"
                    case rollback = "Rollback"
                }

                public init(targetBinaryRange: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, label: String? = nil, packageHash: String? = nil, blobURL: String? = nil, diffPackageMap: [String: DiffPackageMapItem]? = nil, originalDeployment: String? = nil, originalLabel: String? = nil, releasedBy: String? = nil, releaseMethod: ReleaseMethod? = nil, size: Double? = nil, uploadTime: Int? = nil) {
                    self.targetBinaryRange = targetBinaryRange
                    self.description = description
                    self.isDisabled = isDisabled
                    self.isMandatory = isMandatory
                    self.rollout = rollout
                    self.label = label
                    self.packageHash = packageHash
                    self.blobURL = blobURL
                    self.diffPackageMap = diffPackageMap
                    self.originalDeployment = originalDeployment
                    self.originalLabel = originalLabel
                    self.releasedBy = releasedBy
                    self.releaseMethod = releaseMethod
                    self.size = size
                    self.uploadTime = uploadTime
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.targetBinaryRange = try values.decodeIfPresent(String.self, forKey: "target_binary_range")
                    self.description = try values.decodeIfPresent(String.self, forKey: "description")
                    self.isDisabled = try values.decodeIfPresent(Bool.self, forKey: "is_disabled")
                    self.isMandatory = try values.decodeIfPresent(Bool.self, forKey: "is_mandatory")
                    self.rollout = try values.decodeIfPresent(Int.self, forKey: "rollout")
                    self.label = try values.decodeIfPresent(String.self, forKey: "label")
                    self.packageHash = try values.decodeIfPresent(String.self, forKey: "package_hash")
                    self.blobURL = try values.decodeIfPresent(String.self, forKey: "blob_url")
                    self.diffPackageMap = try values.decodeIfPresent([String: DiffPackageMapItem].self, forKey: "diff_package_map")
                    self.originalDeployment = try values.decodeIfPresent(String.self, forKey: "original_deployment")
                    self.originalLabel = try values.decodeIfPresent(String.self, forKey: "original_label")
                    self.releasedBy = try values.decodeIfPresent(String.self, forKey: "released_by")
                    self.releaseMethod = try ReleaseMethod(from: decoder)
                    self.size = try values.decodeIfPresent(Double.self, forKey: "size")
                    self.uploadTime = try values.decodeIfPresent(Int.self, forKey: "upload_time")
                }
            }

            public init(key: String? = nil, name: String, latestRelease: LatestRelease? = nil) {
                self.key = key
                self.name = name
                self.latestRelease = latestRelease
            }

            private enum CodingKeys: String, CodingKey {
                case key
                case name
                case latestRelease = "latest_release"
            }
        }

        public struct PostRequest: Encodable {
            public var key: String?
            public var name: String
            public var latestRelease: LatestRelease?

            public struct LatestRelease: Encodable {
                public var targetBinaryRange: String?
                public var description: String?
                public var isDisabled: Bool?
                public var isMandatory: Bool?
                public var rollout: Int?
                public var label: String?
                public var packageHash: String?
                public var blobURL: String?
                public var diffPackageMap: [String: DiffPackageMapItem]?
                /// Set on 'Promote'
                public var originalDeployment: String?
                /// Set on 'Promote' and 'Rollback'
                public var originalLabel: String?
                public var releasedBy: String?
                /// The release method is unknown if unspecified
                public var releaseMethod: ReleaseMethod?
                public var size: Double?
                public var uploadTime: Int?

                public struct DiffPackageMapItem: Encodable {
                    public var size: Double
                    public var url: String

                    public init(size: Double, url: String) {
                        self.size = size
                        self.url = url
                    }
                }

                /// The release method is unknown if unspecified
                public enum ReleaseMethod: String, Codable, CaseIterable {
                    case upload = "Upload"
                    case promote = "Promote"
                    case rollback = "Rollback"
                }

                public init(targetBinaryRange: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, label: String? = nil, packageHash: String? = nil, blobURL: String? = nil, diffPackageMap: [String: DiffPackageMapItem]? = nil, originalDeployment: String? = nil, originalLabel: String? = nil, releasedBy: String? = nil, releaseMethod: ReleaseMethod? = nil, size: Double? = nil, uploadTime: Int? = nil) {
                    self.targetBinaryRange = targetBinaryRange
                    self.description = description
                    self.isDisabled = isDisabled
                    self.isMandatory = isMandatory
                    self.rollout = rollout
                    self.label = label
                    self.packageHash = packageHash
                    self.blobURL = blobURL
                    self.diffPackageMap = diffPackageMap
                    self.originalDeployment = originalDeployment
                    self.originalLabel = originalLabel
                    self.releasedBy = releasedBy
                    self.releaseMethod = releaseMethod
                    self.size = size
                    self.uploadTime = uploadTime
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(targetBinaryRange, forKey: "target_binary_range")
                    try values.encodeIfPresent(description, forKey: "description")
                    try values.encodeIfPresent(isDisabled, forKey: "is_disabled")
                    try values.encodeIfPresent(isMandatory, forKey: "is_mandatory")
                    try values.encodeIfPresent(rollout, forKey: "rollout")
                    try values.encodeIfPresent(label, forKey: "label")
                    try values.encodeIfPresent(packageHash, forKey: "package_hash")
                    try values.encodeIfPresent(blobURL, forKey: "blob_url")
                    try values.encodeIfPresent(diffPackageMap, forKey: "diff_package_map")
                    try values.encodeIfPresent(originalDeployment, forKey: "original_deployment")
                    try values.encodeIfPresent(originalLabel, forKey: "original_label")
                    try values.encodeIfPresent(releasedBy, forKey: "released_by")
                    try values.encodeIfPresent(releaseMethod, forKey: "release_method")
                    try values.encodeIfPresent(size, forKey: "size")
                    try values.encodeIfPresent(uploadTime, forKey: "upload_time")
                }
            }

            public init(key: String? = nil, name: String, latestRelease: LatestRelease? = nil) {
                self.key = key
                self.name = name
                self.latestRelease = latestRelease
            }

            private enum CodingKeys: String, CodingKey {
                case key
                case name
                case latestRelease = "latest_release"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var crashesInfo: CrashesInfo {
        CrashesInfo(path: path + "/crashes_info")
    }

    public struct CrashesInfo {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/crashes_info`
        public let path: String

        /// Gets whether the application has any crashes.
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var hasCrashes: Bool
            public var features: Features

            public struct Features: Decodable {
                /// App supports modification of crashgroup status
                public var isCrashgroupModifyStatus: Bool?
                /// App supports modification of crashgroup annotation
                public var isCrashgroupModifyAnnotation: Bool?
                /// App supports search API
                public var isSearch: Bool?
                /// App supports the 'crash free user' metric
                public var isCrashgroupAnalyticsCrashfreeusers: Bool?
                /// App supports the 'impacted users' metric
                public var isCrashgroupAnalyticsImpactedusers: Bool?
                /// App supports download of raw crashes
                public var isCrashDownloadRaw: Bool?

                public init(isCrashgroupModifyStatus: Bool? = nil, isCrashgroupModifyAnnotation: Bool? = nil, isSearch: Bool? = nil, isCrashgroupAnalyticsCrashfreeusers: Bool? = nil, isCrashgroupAnalyticsImpactedusers: Bool? = nil, isCrashDownloadRaw: Bool? = nil) {
                    self.isCrashgroupModifyStatus = isCrashgroupModifyStatus
                    self.isCrashgroupModifyAnnotation = isCrashgroupModifyAnnotation
                    self.isSearch = isSearch
                    self.isCrashgroupAnalyticsCrashfreeusers = isCrashgroupAnalyticsCrashfreeusers
                    self.isCrashgroupAnalyticsImpactedusers = isCrashgroupAnalyticsImpactedusers
                    self.isCrashDownloadRaw = isCrashDownloadRaw
                }

                private enum CodingKeys: String, CodingKey {
                    case isCrashgroupModifyStatus = "crashgroup_modify_status"
                    case isCrashgroupModifyAnnotation = "crashgroup_modify_annotation"
                    case isSearch = "search"
                    case isCrashgroupAnalyticsCrashfreeusers = "crashgroup_analytics_crashfreeusers"
                    case isCrashgroupAnalyticsImpactedusers = "crashgroup_analytics_impactedusers"
                    case isCrashDownloadRaw = "crash_download_raw"
                }
            }

            public init(hasCrashes: Bool, features: Features) {
                self.hasCrashes = hasCrashes
                self.features = features
            }

            private enum CodingKeys: String, CodingKey {
                case hasCrashes = "has_crashes"
                case features
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var crashes: Crashes {
        Crashes(path: path + "/crashes")
    }

    public struct Crashes {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/crashes`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Crashes {
    public func crashID(_ crashID: String) -> WithCrashID {
        WithCrashID(path: "\(path)/\(crashID)")
    }

    public struct WithCrashID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/crashes/{crash_id}`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Crashes.WithCrashID {
    public var sessionLogs: SessionLogs {
        SessionLogs(path: path + "/session_logs")
    }

    public struct SessionLogs {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/crashes/{crash_id}/session_logs`
        public let path: String

        /// Get session logs by crash ID
        public func get(date: Date? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(date))
        }

        public struct GetResponse: Decodable {
            /// Indicates if the number of available logs are more than the max allowed return limit(100).
            public var isExceededMaxLimit: Bool?
            /// The timestamp of the last log received. This value can be used as the start time parameter in the consecutive API call.
            public var lastReceivedLogTimestamp: Date?
            /// The list of logs
            public var logs: [Log]

            /// Generic log.
            public struct Log: Decodable {
                /// Log type.
                public var type: `Type`
                /// Log creation timestamp.
                public var timestamp: Date
                /// Install ID.
                public var installID: String
                /// Session ID.
                public var sessionID: String?
                /// Event ID.
                public var eventID: String?
                /// Event name.
                public var eventName: String?
                /// Message ID.
                public var messageID: String?
                /// Event specific properties.
                public var properties: [String: String]?
                /// Device characteristics.
                public var device: Device
                /// Auth service provider.
                public var authProvider: String?
                /// Account ID of the authenticated user.
                public var accountID: String?

                /// Log type.
                public enum `Type`: String, Codable, CaseIterable {
                    case event
                    case page
                    case startSession = "start_session"
                    case error
                    case pushInstallation = "push_installation"
                    case startService = "start_service"
                    case customProperties = "custom_properties"
                }

                /// Device characteristics.
                public struct Device: Decodable {
                    /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
                    public var sdkName: String
                    /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
                    public var sdkVersion: String
                    /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
                    public var wrapperSdkVersion: String?
                    /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
                    public var wrapperSdkName: String?
                    /// Device model (example: iPad2,3).
                    public var model: String?
                    /// Device manufacturer (example: HTC).
                    public var oemName: String?
                    /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
                    public var osName: String
                    /// OS version (example: 9.3.0).
                    public var osVersion: String
                    /// OS build code (example: LMY47X).
                    public var osBuild: String?
                    /// API level when applicable like in Android (example: 15).
                    public var osAPILevel: Int?
                    /// Language code (example: en_US).
                    public var locale: String
                    /// The offset in minutes from UTC for the device time zone, including daylight savings time.
                    public var timeZoneOffset: Int
                    /// Screen size of the device in pixels (example: 640x480).
                    public var screenSize: String?
                    /// Application version name, e.g. 1.1.0
                    public var appVersion: String
                    /// Carrier name (for mobile devices).
                    public var carrierName: String?
                    /// Carrier country code (for mobile devices).
                    public var carrierCode: String?
                    /// Carrier country.
                    public var carrierCountry: String?
                    /// The app's build number, e.g. 42.
                    public var appBuild: String
                    /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
                    public var appNamespace: String?
                    /// Label that is used to identify application code 'version' released via Live Update beacon running on device
                    public var liveUpdateReleaseLabel: String?
                    /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
                    public var liveUpdateDeploymentKey: String?
                    /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
                    public var liveUpdatePackageHash: String?
                    /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
                    public var wrapperRuntimeVersion: String?

                    public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
                        self.sdkName = sdkName
                        self.sdkVersion = sdkVersion
                        self.wrapperSdkVersion = wrapperSdkVersion
                        self.wrapperSdkName = wrapperSdkName
                        self.model = model
                        self.oemName = oemName
                        self.osName = osName
                        self.osVersion = osVersion
                        self.osBuild = osBuild
                        self.osAPILevel = osAPILevel
                        self.locale = locale
                        self.timeZoneOffset = timeZoneOffset
                        self.screenSize = screenSize
                        self.appVersion = appVersion
                        self.carrierName = carrierName
                        self.carrierCode = carrierCode
                        self.carrierCountry = carrierCountry
                        self.appBuild = appBuild
                        self.appNamespace = appNamespace
                        self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
                        self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
                        self.liveUpdatePackageHash = liveUpdatePackageHash
                        self.wrapperRuntimeVersion = wrapperRuntimeVersion
                    }

                    private enum CodingKeys: String, CodingKey {
                        case sdkName = "sdk_name"
                        case sdkVersion = "sdk_version"
                        case wrapperSdkVersion = "wrapper_sdk_version"
                        case wrapperSdkName = "wrapper_sdk_name"
                        case model
                        case oemName = "oem_name"
                        case osName = "os_name"
                        case osVersion = "os_version"
                        case osBuild = "os_build"
                        case osAPILevel = "os_api_level"
                        case locale
                        case timeZoneOffset = "time_zone_offset"
                        case screenSize = "screen_size"
                        case appVersion = "app_version"
                        case carrierName = "carrier_name"
                        case carrierCode = "carrier_code"
                        case carrierCountry = "carrier_country"
                        case appBuild = "app_build"
                        case appNamespace = "app_namespace"
                        case liveUpdateReleaseLabel = "live_update_release_label"
                        case liveUpdateDeploymentKey = "live_update_deployment_key"
                        case liveUpdatePackageHash = "live_update_package_hash"
                        case wrapperRuntimeVersion = "wrapper_runtime_version"
                    }
                }

                public init(type: `Type`, timestamp: Date, installID: String, sessionID: String? = nil, eventID: String? = nil, eventName: String? = nil, messageID: String? = nil, properties: [String: String]? = nil, device: Device, authProvider: String? = nil, accountID: String? = nil) {
                    self.type = type
                    self.timestamp = timestamp
                    self.installID = installID
                    self.sessionID = sessionID
                    self.eventID = eventID
                    self.eventName = eventName
                    self.messageID = messageID
                    self.properties = properties
                    self.device = device
                    self.authProvider = authProvider
                    self.accountID = accountID
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case timestamp
                    case installID = "install_id"
                    case sessionID = "session_id"
                    case eventID = "event_id"
                    case eventName = "event_name"
                    case messageID = "message_id"
                    case properties
                    case device
                    case authProvider = "auth_provider"
                    case accountID = "account_id"
                }
            }

            public init(isExceededMaxLimit: Bool? = nil, lastReceivedLogTimestamp: Date? = nil, logs: [Log]) {
                self.isExceededMaxLimit = isExceededMaxLimit
                self.lastReceivedLogTimestamp = lastReceivedLogTimestamp
                self.logs = logs
            }

            private enum CodingKeys: String, CodingKey {
                case isExceededMaxLimit = "exceeded_max_limit"
                case lastReceivedLogTimestamp = "last_received_log_timestamp"
                case logs
            }
        }

        private func makeGetQuery(_ date: Date?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(date, forKey: "date")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Crashes.WithCrashID.Attachments {
    public func attachmentID(_ attachmentID: String) -> WithAttachmentID {
        WithAttachmentID(path: "\(path)/\(attachmentID)")
    }

    public struct WithAttachmentID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/crashes/{crash_id}/attachments/{attachment_id}`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Crashes.WithCrashID.Attachments.WithAttachmentID {
    public var text: Text {
        Text(path: path + "/text")
    }

    public struct Text {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/crashes/{crash_id}/attachments/{attachment_id}/text`
        public let path: String

        /// Gets content of the text attachment.
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Crashes.WithCrashID.Attachments.WithAttachmentID {
    public var location: Location {
        Location(path: path + "/location")
    }

    public struct Location {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/crashes/{crash_id}/attachments/{attachment_id}/location`
        public let path: String

        /// Gets the URI location to download crash attachment.
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Location for downloading crash attachment
        public struct GetResponse: Decodable {
            public var uri: String

            public init(uri: String) {
                self.uri = uri
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Crashes.WithCrashID {
    public var attachments: Attachments {
        Attachments(path: path + "/attachments")
    }

    public struct Attachments {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/crashes/{crash_id}/attachments`
        public let path: String

        /// Gets all attachments for a specific crash.
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            public var appID: String
            public var attachmentID: String
            public var crashID: String
            public var blobLocation: String
            public var contentType: String
            public var fileName: String
            public var createdTime: Date
            public var size: Double

            public init(appID: String, attachmentID: String, crashID: String, blobLocation: String, contentType: String, fileName: String, createdTime: Date, size: Double) {
                self.appID = appID
                self.attachmentID = attachmentID
                self.crashID = crashID
                self.blobLocation = blobLocation
                self.contentType = contentType
                self.fileName = fileName
                self.createdTime = createdTime
                self.size = size
            }

            private enum CodingKeys: String, CodingKey {
                case appID = "app_id"
                case attachmentID = "attachment_id"
                case crashID = "crash_id"
                case blobLocation = "blob_location"
                case contentType = "content_type"
                case fileName = "file_name"
                case createdTime = "created_time"
                case size
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.CrashGroups.WithCrashGroupID {
    public var stacktrace: Stacktrace {
        Stacktrace(path: path + "/stacktrace")
    }

    public struct Stacktrace {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/stacktrace`
        public let path: String

        /// Gets a stacktrace for a specific crash.
        @available(*, deprecated, message: "Deprecated")
        public func get(isGroupingOnly: Bool? = nil) -> Request<MicrosoftAppCenterAPI.Stacktrace> {
            .get(path, query: makeGetQuery(isGroupingOnly))
        }

        private func makeGetQuery(_ isGroupingOnly: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isGroupingOnly, forKey: "grouping_only")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.CrashGroups.WithCrashGroupID.Crashes.WithCrashID {
    public var stacktrace: Stacktrace {
        Stacktrace(path: path + "/stacktrace")
    }

    public struct Stacktrace {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/crashes/{crash_id}/stacktrace`
        public let path: String

        /// Gets a stacktrace for a specific crash.
        @available(*, deprecated, message: "Deprecated")
        public func get(isGroupingOnly: Bool? = nil) -> Request<MicrosoftAppCenterAPI.Stacktrace> {
            .get(path, query: makeGetQuery(isGroupingOnly))
        }

        private func makeGetQuery(_ isGroupingOnly: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isGroupingOnly, forKey: "grouping_only")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.CrashGroups.WithCrashGroupID.Crashes.WithCrashID {
    public var raw: Raw {
        Raw(path: path + "/raw")
    }

    public struct Raw {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/crashes/{crash_id}/raw`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.CrashGroups.WithCrashGroupID.Crashes.WithCrashID.Raw {
    public var location: Location {
        Location(path: path + "/location")
    }

    public struct Location {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/crashes/{crash_id}/raw/location`
        public let path: String

        /// Gets the URI location to download json of a specific crash.
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Location for downloading crash raw
        public struct GetResponse: Decodable {
            public var uri: String

            public init(uri: String) {
                self.uri = uri
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.CrashGroups.WithCrashGroupID.Crashes.WithCrashID.Native {
    public var download: Download {
        Download(path: path + "/download")
    }

    public struct Download {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/crashes/{crash_id}/native/download`
        public let path: String

        /// Gets the native log of a specific crash as a text attachment.
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.CrashGroups.WithCrashGroupID.Crashes.WithCrashID {
    public var native: Native {
        Native(path: path + "/native")
    }

    public struct Native {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/crashes/{crash_id}/native`
        public let path: String

        /// Gets the native log of a specific crash.
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.CrashGroups.WithCrashGroupID.Crashes {
    public func crashID(_ crashID: String) -> WithCrashID {
        WithCrashID(path: "\(path)/\(crashID)")
    }

    public struct WithCrashID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/crashes/{crash_id}`
        public let path: String

        /// Gets a specific crash for an app.
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters? = nil) -> Request<MicrosoftAppCenterAPI.Crash> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isIncludeReport: Bool?
            public var isIncludeLog: Bool?
            public var isIncludeDetails: Bool?
            public var isIncludeStacktrace: Bool?
            public var isGroupingOnly: Bool?

            public init(isIncludeReport: Bool? = nil, isIncludeLog: Bool? = nil, isIncludeDetails: Bool? = nil, isIncludeStacktrace: Bool? = nil, isGroupingOnly: Bool? = nil) {
                self.isIncludeReport = isIncludeReport
                self.isIncludeLog = isIncludeLog
                self.isIncludeDetails = isIncludeDetails
                self.isIncludeStacktrace = isIncludeStacktrace
                self.isGroupingOnly = isGroupingOnly
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isIncludeReport, forKey: "include_report")
                encoder.encode(isIncludeLog, forKey: "include_log")
                encoder.encode(isIncludeDetails, forKey: "include_details")
                encoder.encode(isIncludeStacktrace, forKey: "include_stacktrace")
                encoder.encode(isGroupingOnly, forKey: "grouping_only")
                return encoder.items
            }
        }

        /// Delete a specific crash and related attachments and blobs for an app.
        @available(*, deprecated, message: "Deprecated")
        public func delete(retentionDelete: Bool? = nil) -> Request<DeleteResponse> {
            .delete(path, query: makeDeleteQuery(retentionDelete))
        }

        public struct DeleteResponse: Decodable {
            public var appID: String?
            public var crashGroupID: String?
            public var crashID: String?
            public var crashesDeleted: Int?
            public var attachmentsDeleted: Int?
            public var blobsSucceeded: Int?
            public var blobsFailed: Int?

            public init(appID: String? = nil, crashGroupID: String? = nil, crashID: String? = nil, crashesDeleted: Int? = nil, attachmentsDeleted: Int? = nil, blobsSucceeded: Int? = nil, blobsFailed: Int? = nil) {
                self.appID = appID
                self.crashGroupID = crashGroupID
                self.crashID = crashID
                self.crashesDeleted = crashesDeleted
                self.attachmentsDeleted = attachmentsDeleted
                self.blobsSucceeded = blobsSucceeded
                self.blobsFailed = blobsFailed
            }

            private enum CodingKeys: String, CodingKey {
                case appID = "app_id"
                case crashGroupID = "crash_group_id"
                case crashID = "crash_id"
                case crashesDeleted = "crashes_deleted"
                case attachmentsDeleted = "attachments_deleted"
                case blobsSucceeded = "blobs_succeeded"
                case blobsFailed = "blobs_failed"
            }
        }

        private func makeDeleteQuery(_ retentionDelete: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(retentionDelete, forKey: "retention_delete")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.CrashGroups.WithCrashGroupID {
    public var crashes: Crashes {
        Crashes(path: path + "/crashes")
    }

    public struct Crashes {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}/crashes`
        public let path: String

        /// Gets all crashes of a group.
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters? = nil) -> Request<[MicrosoftAppCenterAPI.Crash]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isIncludeReport: Bool?
            public var isIncludeLog: Bool?
            public var dateFrom: Date?
            public var dateTo: Date?
            public var appVersion: String?
            public var errorType: ErrorType?

            public enum ErrorType: String, Codable, CaseIterable {
                case crashingErrors = "CrashingErrors"
                case handledErrors = "HandledErrors"
            }

            public init(isIncludeReport: Bool? = nil, isIncludeLog: Bool? = nil, dateFrom: Date? = nil, dateTo: Date? = nil, appVersion: String? = nil, errorType: ErrorType? = nil) {
                self.isIncludeReport = isIncludeReport
                self.isIncludeLog = isIncludeLog
                self.dateFrom = dateFrom
                self.dateTo = dateTo
                self.appVersion = appVersion
                self.errorType = errorType
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isIncludeReport, forKey: "include_report")
                encoder.encode(isIncludeLog, forKey: "include_log")
                encoder.encode(dateFrom, forKey: "date_from")
                encoder.encode(dateTo, forKey: "date_to")
                encoder.encode(appVersion, forKey: "app_version")
                encoder.encode(errorType, forKey: "error_type")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.CrashGroups {
    public func crashGroupID(_ crashGroupID: String) -> WithCrashGroupID {
        WithCrashGroupID(path: "\(path)/\(crashGroupID)")
    }

    public struct WithCrashGroupID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}`
        public let path: String

        /// Gets a specific group.
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var crashGroupID: String
            public var newCrashGroupID: String
            public var displayID: String
            public var appVersion: String
            public var build: String
            public var status: Status
            public var count: Int
            public var impactedUsers: Int?
            public var firstOccurrence: Date
            public var lastOccurrence: Date
            public var exception: String?
            public var crashReason: String
            /// Frame belonging to the reason of the crash
            public var reasonFrame: ReasonFrame?
            /// Crash or handled exception
            public var isFatal: Bool
            public var annotation: String

            public enum Status: String, Codable, CaseIterable {
                case `open`
                case closed
                case ignored
            }

            /// Frame belonging to the reason of the crash
            public struct ReasonFrame: Decodable {
                /// Name of the class
                public var className: String?
                /// Name of the method
                public var method: String?
                /// Is a class method
                public var isClassMethod: Bool?
                /// Name of the file
                public var file: String?
                /// Line number
                public var line: Int?
                /// This line isn't from any framework
                public var isAppCode: Bool?
                /// Name of the framework
                public var frameworkName: String?
                /// Formatted frame string
                public var codeFormatted: String?
                /// Unformatted Frame string
                public var codeRaw: String?
                /// Programming language of the frame
                public var language: Language?
                /// Parameters of the frames method
                public var methodParams: String?
                /// Exception type.
                public var exceptionType: String?
                /// OS exception type. (aka. SIGNAL)
                public var osExceptionType: String?

                /// Programming language of the frame
                public enum Language: String, Codable, CaseIterable {
                    case javaScript = "JavaScript"
                    case cSharp = "CSharp"
                    case objectiveC = "Objective-C"
                    case objectiveCpp = "Objective-Cpp"
                    case cpp = "Cpp"
                    case c = "C"
                    case swift = "Swift"
                    case java = "Java"
                    case unknown = "Unknown"
                }

                public init(className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool? = nil, frameworkName: String? = nil, codeFormatted: String? = nil, codeRaw: String? = nil, language: Language? = nil, methodParams: String? = nil, exceptionType: String? = nil, osExceptionType: String? = nil) {
                    self.className = className
                    self.method = method
                    self.isClassMethod = isClassMethod
                    self.file = file
                    self.line = line
                    self.isAppCode = isAppCode
                    self.frameworkName = frameworkName
                    self.codeFormatted = codeFormatted
                    self.codeRaw = codeRaw
                    self.language = language
                    self.methodParams = methodParams
                    self.exceptionType = exceptionType
                    self.osExceptionType = osExceptionType
                }

                private enum CodingKeys: String, CodingKey {
                    case className = "class_name"
                    case method
                    case isClassMethod = "class_method"
                    case file
                    case line
                    case isAppCode = "app_code"
                    case frameworkName = "framework_name"
                    case codeFormatted = "code_formatted"
                    case codeRaw = "code_raw"
                    case language
                    case methodParams = "method_params"
                    case exceptionType = "exception_type"
                    case osExceptionType = "os_exception_type"
                }
            }

            public init(crashGroupID: String, newCrashGroupID: String, displayID: String, appVersion: String, build: String, status: Status, count: Int, impactedUsers: Int? = nil, firstOccurrence: Date, lastOccurrence: Date, exception: String? = nil, crashReason: String, reasonFrame: ReasonFrame? = nil, isFatal: Bool, annotation: String) {
                self.crashGroupID = crashGroupID
                self.newCrashGroupID = newCrashGroupID
                self.displayID = displayID
                self.appVersion = appVersion
                self.build = build
                self.status = status
                self.count = count
                self.impactedUsers = impactedUsers
                self.firstOccurrence = firstOccurrence
                self.lastOccurrence = lastOccurrence
                self.exception = exception
                self.crashReason = crashReason
                self.reasonFrame = reasonFrame
                self.isFatal = isFatal
                self.annotation = annotation
            }

            private enum CodingKeys: String, CodingKey {
                case crashGroupID = "crash_group_id"
                case newCrashGroupID = "new_crash_group_id"
                case displayID = "display_id"
                case appVersion = "app_version"
                case build
                case status
                case count
                case impactedUsers = "impacted_users"
                case firstOccurrence = "first_occurrence"
                case lastOccurrence = "last_occurrence"
                case exception
                case crashReason = "crash_reason"
                case reasonFrame = "reason_frame"
                case isFatal = "fatal"
                case annotation
            }
        }

        /// Updates a group.
        @available(*, deprecated, message: "Deprecated")
        public func patch(_ body: PatchRequest) -> Request<PatchResponse> {
            .patch(path, body: body)
        }

        public struct PatchResponse: Decodable {
            public var crashGroupID: String
            public var newCrashGroupID: String
            public var displayID: String
            public var appVersion: String
            public var build: String
            public var status: Status
            public var count: Int
            public var impactedUsers: Int?
            public var firstOccurrence: Date
            public var lastOccurrence: Date
            public var exception: String?
            public var crashReason: String
            /// Frame belonging to the reason of the crash
            public var reasonFrame: ReasonFrame?
            /// Crash or handled exception
            public var isFatal: Bool
            public var annotation: String

            public enum Status: String, Codable, CaseIterable {
                case `open`
                case closed
                case ignored
            }

            /// Frame belonging to the reason of the crash
            public struct ReasonFrame: Decodable {
                /// Name of the class
                public var className: String?
                /// Name of the method
                public var method: String?
                /// Is a class method
                public var isClassMethod: Bool?
                /// Name of the file
                public var file: String?
                /// Line number
                public var line: Int?
                /// This line isn't from any framework
                public var isAppCode: Bool?
                /// Name of the framework
                public var frameworkName: String?
                /// Formatted frame string
                public var codeFormatted: String?
                /// Unformatted Frame string
                public var codeRaw: String?
                /// Programming language of the frame
                public var language: Language?
                /// Parameters of the frames method
                public var methodParams: String?
                /// Exception type.
                public var exceptionType: String?
                /// OS exception type. (aka. SIGNAL)
                public var osExceptionType: String?

                /// Programming language of the frame
                public enum Language: String, Codable, CaseIterable {
                    case javaScript = "JavaScript"
                    case cSharp = "CSharp"
                    case objectiveC = "Objective-C"
                    case objectiveCpp = "Objective-Cpp"
                    case cpp = "Cpp"
                    case c = "C"
                    case swift = "Swift"
                    case java = "Java"
                    case unknown = "Unknown"
                }

                public init(className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool? = nil, frameworkName: String? = nil, codeFormatted: String? = nil, codeRaw: String? = nil, language: Language? = nil, methodParams: String? = nil, exceptionType: String? = nil, osExceptionType: String? = nil) {
                    self.className = className
                    self.method = method
                    self.isClassMethod = isClassMethod
                    self.file = file
                    self.line = line
                    self.isAppCode = isAppCode
                    self.frameworkName = frameworkName
                    self.codeFormatted = codeFormatted
                    self.codeRaw = codeRaw
                    self.language = language
                    self.methodParams = methodParams
                    self.exceptionType = exceptionType
                    self.osExceptionType = osExceptionType
                }

                private enum CodingKeys: String, CodingKey {
                    case className = "class_name"
                    case method
                    case isClassMethod = "class_method"
                    case file
                    case line
                    case isAppCode = "app_code"
                    case frameworkName = "framework_name"
                    case codeFormatted = "code_formatted"
                    case codeRaw = "code_raw"
                    case language
                    case methodParams = "method_params"
                    case exceptionType = "exception_type"
                    case osExceptionType = "os_exception_type"
                }
            }

            public init(crashGroupID: String, newCrashGroupID: String, displayID: String, appVersion: String, build: String, status: Status, count: Int, impactedUsers: Int? = nil, firstOccurrence: Date, lastOccurrence: Date, exception: String? = nil, crashReason: String, reasonFrame: ReasonFrame? = nil, isFatal: Bool, annotation: String) {
                self.crashGroupID = crashGroupID
                self.newCrashGroupID = newCrashGroupID
                self.displayID = displayID
                self.appVersion = appVersion
                self.build = build
                self.status = status
                self.count = count
                self.impactedUsers = impactedUsers
                self.firstOccurrence = firstOccurrence
                self.lastOccurrence = lastOccurrence
                self.exception = exception
                self.crashReason = crashReason
                self.reasonFrame = reasonFrame
                self.isFatal = isFatal
                self.annotation = annotation
            }

            private enum CodingKeys: String, CodingKey {
                case crashGroupID = "crash_group_id"
                case newCrashGroupID = "new_crash_group_id"
                case displayID = "display_id"
                case appVersion = "app_version"
                case build
                case status
                case count
                case impactedUsers = "impacted_users"
                case firstOccurrence = "first_occurrence"
                case lastOccurrence = "last_occurrence"
                case exception
                case crashReason = "crash_reason"
                case reasonFrame = "reason_frame"
                case isFatal = "fatal"
                case annotation
            }
        }

        public struct PatchRequest: Encodable {
            public var status: Status?
            public var annotation: String?

            public enum Status: String, Codable, CaseIterable {
                case `open`
                case closed
                case ignored
            }

            public init(status: Status? = nil, annotation: String? = nil) {
                self.status = status
                self.annotation = annotation
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var crashGroups: CrashGroups {
        CrashGroups(path: path + "/crash_groups")
    }

    public struct CrashGroups {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/crash_groups`
        public let path: String

        /// Gets a list of crash groups and whether the list contains all available groups.
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var isLimitedResultSet: Bool
            /// Cassandra request continuation token. The token is used for pagination.
            public var continuationToken: String?
            public var crashGroups: [CrashGroup]

            public struct CrashGroup: Decodable {
                public var crashGroupID: String
                public var newCrashGroupID: String
                public var displayID: String
                public var appVersion: String
                public var build: String
                public var status: Status
                public var count: Int
                public var impactedUsers: Int?
                public var firstOccurrence: Date
                public var lastOccurrence: Date
                public var exception: String?
                public var crashReason: String
                /// Frame belonging to the reason of the crash
                public var reasonFrame: ReasonFrame?
                /// Crash or handled exception
                public var isFatal: Bool
                public var annotation: String

                public enum Status: String, Codable, CaseIterable {
                    case `open`
                    case closed
                    case ignored
                }

                /// Frame belonging to the reason of the crash
                public struct ReasonFrame: Decodable {
                    /// Name of the class
                    public var className: String?
                    /// Name of the method
                    public var method: String?
                    /// Is a class method
                    public var isClassMethod: Bool?
                    /// Name of the file
                    public var file: String?
                    /// Line number
                    public var line: Int?
                    /// This line isn't from any framework
                    public var isAppCode: Bool?
                    /// Name of the framework
                    public var frameworkName: String?
                    /// Formatted frame string
                    public var codeFormatted: String?
                    /// Unformatted Frame string
                    public var codeRaw: String?
                    /// Programming language of the frame
                    public var language: Language?
                    /// Parameters of the frames method
                    public var methodParams: String?
                    /// Exception type.
                    public var exceptionType: String?
                    /// OS exception type. (aka. SIGNAL)
                    public var osExceptionType: String?

                    /// Programming language of the frame
                    public enum Language: String, Codable, CaseIterable {
                        case javaScript = "JavaScript"
                        case cSharp = "CSharp"
                        case objectiveC = "Objective-C"
                        case objectiveCpp = "Objective-Cpp"
                        case cpp = "Cpp"
                        case c = "C"
                        case swift = "Swift"
                        case java = "Java"
                        case unknown = "Unknown"
                    }

                    public init(className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool? = nil, frameworkName: String? = nil, codeFormatted: String? = nil, codeRaw: String? = nil, language: Language? = nil, methodParams: String? = nil, exceptionType: String? = nil, osExceptionType: String? = nil) {
                        self.className = className
                        self.method = method
                        self.isClassMethod = isClassMethod
                        self.file = file
                        self.line = line
                        self.isAppCode = isAppCode
                        self.frameworkName = frameworkName
                        self.codeFormatted = codeFormatted
                        self.codeRaw = codeRaw
                        self.language = language
                        self.methodParams = methodParams
                        self.exceptionType = exceptionType
                        self.osExceptionType = osExceptionType
                    }

                    private enum CodingKeys: String, CodingKey {
                        case className = "class_name"
                        case method
                        case isClassMethod = "class_method"
                        case file
                        case line
                        case isAppCode = "app_code"
                        case frameworkName = "framework_name"
                        case codeFormatted = "code_formatted"
                        case codeRaw = "code_raw"
                        case language
                        case methodParams = "method_params"
                        case exceptionType = "exception_type"
                        case osExceptionType = "os_exception_type"
                    }
                }

                public init(crashGroupID: String, newCrashGroupID: String, displayID: String, appVersion: String, build: String, status: Status, count: Int, impactedUsers: Int? = nil, firstOccurrence: Date, lastOccurrence: Date, exception: String? = nil, crashReason: String, reasonFrame: ReasonFrame? = nil, isFatal: Bool, annotation: String) {
                    self.crashGroupID = crashGroupID
                    self.newCrashGroupID = newCrashGroupID
                    self.displayID = displayID
                    self.appVersion = appVersion
                    self.build = build
                    self.status = status
                    self.count = count
                    self.impactedUsers = impactedUsers
                    self.firstOccurrence = firstOccurrence
                    self.lastOccurrence = lastOccurrence
                    self.exception = exception
                    self.crashReason = crashReason
                    self.reasonFrame = reasonFrame
                    self.isFatal = isFatal
                    self.annotation = annotation
                }

                private enum CodingKeys: String, CodingKey {
                    case crashGroupID = "crash_group_id"
                    case newCrashGroupID = "new_crash_group_id"
                    case displayID = "display_id"
                    case appVersion = "app_version"
                    case build
                    case status
                    case count
                    case impactedUsers = "impacted_users"
                    case firstOccurrence = "first_occurrence"
                    case lastOccurrence = "last_occurrence"
                    case exception
                    case crashReason = "crash_reason"
                    case reasonFrame = "reason_frame"
                    case isFatal = "fatal"
                    case annotation
                }
            }

            public init(isLimitedResultSet: Bool, continuationToken: String? = nil, crashGroups: [CrashGroup]) {
                self.isLimitedResultSet = isLimitedResultSet
                self.continuationToken = continuationToken
                self.crashGroups = crashGroups
            }

            private enum CodingKeys: String, CodingKey {
                case isLimitedResultSet = "limited_result_set"
                case continuationToken = "continuation_token"
                case crashGroups = "crash_groups"
            }
        }

        public struct GetParameters {
            public var lastOccurrenceFrom: Date?
            public var lastOccurrenceTo: Date?
            public var appVersion: String?
            public var groupType: GroupType?
            public var groupStatus: GroupStatus?
            public var groupTextSearch: String?
            public var orderby: Orderby?
            public var continuationToken: String?

            public enum GroupType: String, Codable, CaseIterable {
                case groupType1 = "GroupType1"
                case groupType2 = "GroupType2"
            }

            public enum GroupStatus: String, Codable, CaseIterable {
                case `open`
                case closed
                case ignored
            }

            public enum Orderby: String, Codable, CaseIterable {
                case lastOccurrenceAsc = "last_occurrence asc"
                case lastOccurrenceDesc = "last_occurrence desc"
                case countAsc = "count asc"
                case countDesc = "count desc"
                case displayIDAsc = "display_id asc"
                case displayIDDesc = "display_id desc"
                case impactedUsersAsc = "impacted_users asc"
                case impactedUsersDesc = "impacted_users desc"
            }

            public init(lastOccurrenceFrom: Date? = nil, lastOccurrenceTo: Date? = nil, appVersion: String? = nil, groupType: GroupType? = nil, groupStatus: GroupStatus? = nil, groupTextSearch: String? = nil, orderby: Orderby? = nil, continuationToken: String? = nil) {
                self.lastOccurrenceFrom = lastOccurrenceFrom
                self.lastOccurrenceTo = lastOccurrenceTo
                self.appVersion = appVersion
                self.groupType = groupType
                self.groupStatus = groupStatus
                self.groupTextSearch = groupTextSearch
                self.orderby = orderby
                self.continuationToken = continuationToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(lastOccurrenceFrom, forKey: "last_occurrence_from")
                encoder.encode(lastOccurrenceTo, forKey: "last_occurrence_to")
                encoder.encode(appVersion, forKey: "app_version")
                encoder.encode(groupType, forKey: "group_type")
                encoder.encode(groupStatus, forKey: "group_status")
                encoder.encode(groupTextSearch, forKey: "group_text_search")
                encoder.encode(orderby, forKey: "$orderby")
                encoder.encode(continuationToken, forKey: "continuation_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var commits: Commits {
        Commits(path: path + "/commits")
    }

    public struct Commits {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/commits`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Commits {
    public var batch: Batch {
        Batch(path: path + "/batch")
    }

    public struct Batch {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/commits/batch`
        public let path: String

        /// Returns commit information for a batch of shas
        public func get(hashes: [String]) -> Request<[GetResponseItem]> {
            .get(path, query: makeGetQuery(hashes))
        }

        public struct GetResponseItem: Decodable {
            /// The commit SHA
            public var sha: String?
            /// The URL to the commit
            public var url: String?
            public var commit: Commit?

            public struct Commit: Decodable {
                /// Commit message
                public var message: String?
                public var author: Author?

                public struct Author: Decodable {
                    /// Date and time of the commit
                    public var date: String?
                    /// Author name
                    public var name: String?
                    /// Author's email
                    public var email: String?

                    public init(date: String? = nil, name: String? = nil, email: String? = nil) {
                        self.date = date
                        self.name = name
                        self.email = email
                    }
                }

                public init(message: String? = nil, author: Author? = nil) {
                    self.message = message
                    self.author = author
                }
            }

            public init(sha: String? = nil, url: String? = nil, commit: Commit? = nil) {
                self.sha = sha
                self.url = url
                self.commit = commit
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.sha = try values.decodeIfPresent(String.self, forKey: "sha")
                self.url = try values.decodeIfPresent(String.self, forKey: "url")
                self.commit = try Commit(from: decoder)
            }
        }

        private func makeGetQuery(_ hashes: [String]) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(hashes, forKey: "hashes", explode: false)
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var builds: Builds {
        Builds(path: path + "/builds")
    }

    public struct Builds {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/builds`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Builds.WithBuildID {
    public var logs: Logs {
        Logs(path: path + "/logs")
    }

    public struct Logs {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}/logs`
        public let path: String

        /// Get the build log
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Builds.WithBuildID {
    public var downloads: Downloads {
        Downloads(path: path + "/downloads")
    }

    public struct Downloads {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}/downloads`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Builds.WithBuildID.Downloads {
    public func downloadType(_ downloadType: String) -> WithDownloadType {
        WithDownloadType(path: "\(path)/\(downloadType)")
    }

    public struct WithDownloadType {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}/downloads/{download_type}`
        public let path: String

        /// Gets the download URI
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Builds.WithBuildID {
    public var distribute: Distribute {
        Distribute(path: path + "/distribute")
    }

    public struct Distribute {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}/distribute`
        public let path: String

        /// Distribute a build
        public func post(_ body: PostRequest) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Array of objects {id:string, type:string} with "id" being the distribution group ID, store ID, or tester email, and "type" being "group", "store", or "tester"
            public var destinations: [Destination]?
            /// The release notes
            public var releaseNotes: String?
            public var isMandatoryUpdate: Bool?
            public var isNotifyTesters: Bool

            /// Destination details for distributing build releases
            public struct Destination: Encodable {
                public var id: String
                public var type: `Type`

                public enum `Type`: String, Codable, CaseIterable {
                    case store
                    case group
                    case tester
                }

                public init(id: String, type: `Type`) {
                    self.id = id
                    self.type = type
                }
            }

            public init(destinations: [Destination]? = nil, releaseNotes: String? = nil, isMandatoryUpdate: Bool? = nil, isNotifyTesters: Bool? = nil) {
                self.destinations = destinations
                self.releaseNotes = releaseNotes
                self.isMandatoryUpdate = isMandatoryUpdate
                self.isNotifyTesters = isNotifyTesters ?? true
            }

            private enum CodingKeys: String, CodingKey {
                case destinations
                case releaseNotes
                case isMandatoryUpdate = "mandatoryUpdate"
                case isNotifyTesters = "notifyTesters"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Builds {
    public func buildID(_ buildID: Int) -> WithBuildID {
        WithBuildID(path: "\(path)/\(buildID)")
    }

    public struct WithBuildID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}`
        public let path: String

        /// Returns the build detail for the given build ID
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Cancels a build
        public func patch(status: PatchRequest.Status? = nil) -> Request<[String: AnyJSON]> {
            .patch(path, body: PatchRequest(status: status))
        }

        public struct PatchRequest: Encodable {
            /// The build status; used to cancel builds
            public var status: Status?

            /// The build status; used to cancel builds
            public enum Status: String, Codable, CaseIterable {
                case cancelling
            }

            public init(status: Status? = nil) {
                self.status = status
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var buildServiceStatus: BuildServiceStatus {
        BuildServiceStatus(path: path + "/build_service_status")
    }

    public struct BuildServiceStatus {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/build_service_status`
        public let path: String

        /// Application specific build service status
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Bugtracker {
    public var crashGroup: CrashGroup {
        CrashGroup(path: path + "/crashGroup")
    }

    public struct CrashGroup {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/bugtracker/crashGroup`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Bugtracker.CrashGroup {
    public func crashGroupID(_ crashGroupID: String) -> WithCrashGroupID {
        WithCrashGroupID(path: "\(path)/\(crashGroupID)")
    }

    public struct WithCrashGroupID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/bugtracker/crashGroup/{crash_group_id}`
        public let path: String

        /// Get project issue related to a crash group
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var bugtracker: Bugtracker {
        Bugtracker(path: path + "/bugtracker")
    }

    public struct Bugtracker {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/bugtracker`
        public let path: String

        /// Get bug tracker settings for a particular app
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Branches {
    public func branch(_ branch: String) -> WithBranch {
        WithBranch(path: "\(path)/\(branch)")
    }

    public struct WithBranch {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/branches/{branch}`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Branches.WithBranch {
    public var toolsetProjects: ToolsetProjects {
        ToolsetProjects(path: path + "/toolset_projects")
    }

    public struct ToolsetProjects {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/toolset_projects`
        public let path: String

        /// Returns the projects in the repository for the branch, for all toolsets
        public func get(parameters: GetParameters) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var os: Os
            public var platform: Platform
            public var maxSearchDepth: Int?

            public enum Os: String, Codable, CaseIterable {
                case iOS
                case android = "Android"
                case windows = "Windows"
                case macOS
            }

            public enum Platform: String, Codable, CaseIterable {
                case objectiveCSwift = "Objective-C-Swift"
                case reactNative = "React-Native"
                case xamarin = "Xamarin"
                case java = "Java"
                case uwp = "UWP"
            }

            public init(os: Os, platform: Platform, maxSearchDepth: Int? = nil) {
                self.os = os
                self.platform = platform
                self.maxSearchDepth = maxSearchDepth
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(os, forKey: "os")
                encoder.encode(platform, forKey: "platform")
                encoder.encode(maxSearchDepth, forKey: "maxSearchDepth")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Branches.WithBranch {
    public var config: Config {
        Config(path: path + "/config")
    }

    public struct Config {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/config`
        public let path: String

        /// Gets the branch configuration
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var id: Int

            public init(id: Int) {
                self.id = id
            }
        }

        /// Configures the branch for build
        public func post(_ body: [String: PostRequestItem]) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            public var id: Int

            public init(id: Int) {
                self.id = id
            }
        }

        /// The branch build core properties
        public struct PostRequestItem: Encodable {
            public var branch: Branch?
            public var isEnabled: Bool?

            public struct Branch: Encodable {
                /// The branch name
                public var name: String
                public var commit: Commit

                public struct Commit: Encodable {
                    /// The commit SHA
                    public var sha: String?
                    /// The URL to the commit
                    public var url: String?

                    public init(sha: String? = nil, url: String? = nil) {
                        self.sha = sha
                        self.url = url
                    }
                }

                public init(name: String, commit: Commit) {
                    self.name = name
                    self.commit = commit
                }
            }

            public init(branch: Branch? = nil, isEnabled: Bool? = nil) {
                self.branch = branch
                self.isEnabled = isEnabled
            }

            private enum CodingKeys: String, CodingKey {
                case branch
                case isEnabled = "enabled"
            }
        }

        /// Reconfigures the branch for build
        public func put(_ body: [String: PutRequestItem]) -> Request<PutResponse> {
            .put(path, body: body)
        }

        public struct PutResponse: Decodable {
            public var id: Int

            public init(id: Int) {
                self.id = id
            }
        }

        /// The branch build core properties
        public struct PutRequestItem: Encodable {
            public var branch: Branch?
            public var isEnabled: Bool?

            public struct Branch: Encodable {
                /// The branch name
                public var name: String
                public var commit: Commit

                public struct Commit: Encodable {
                    /// The commit SHA
                    public var sha: String?
                    /// The URL to the commit
                    public var url: String?

                    public init(sha: String? = nil, url: String? = nil) {
                        self.sha = sha
                        self.url = url
                    }
                }

                public init(name: String, commit: Commit) {
                    self.name = name
                    self.commit = commit
                }
            }

            public init(branch: Branch? = nil, isEnabled: Bool? = nil) {
                self.branch = branch
                self.isEnabled = isEnabled
            }

            private enum CodingKeys: String, CodingKey {
                case branch
                case isEnabled = "enabled"
            }
        }

        /// Deletes the branch build configuration
        public func delete(_ body: [String: AnyJSON]? = nil) -> Request<[String: AnyJSON]> {
            .delete(path, body: body)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Branches.WithBranch {
    public var builds: Builds {
        Builds(path: path + "/builds")
    }

    public struct Builds {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/builds`
        public let path: String

        /// Returns the list of builds for the branch
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The build ID
            public var id: Int
            /// The build number
            public var buildNumber: String
            /// The time the build was queued
            public var queueTime: String
            /// The time the build was started
            public var startTime: String?
            /// The time the build was finished
            public var finishTime: String?
            /// The time the build status was last changed
            public var lastChangedDate: String?
            /// The build status
            public var status: String
            /// The build result
            public var result: String
            /// The source branch name
            public var sourceBranch: String
            /// The source SHA
            public var sourceVersion: String

            public init(id: Int, buildNumber: String, queueTime: String, startTime: String? = nil, finishTime: String? = nil, lastChangedDate: String? = nil, status: String, result: String, sourceBranch: String, sourceVersion: String) {
                self.id = id
                self.buildNumber = buildNumber
                self.queueTime = queueTime
                self.startTime = startTime
                self.finishTime = finishTime
                self.lastChangedDate = lastChangedDate
                self.status = status
                self.result = result
                self.sourceBranch = sourceBranch
                self.sourceVersion = sourceVersion
            }
        }

        /// Create a build
        public func post(_ body: PostRequest? = nil) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Version to build which represents the full Git commit reference
            public var sourceVersion: String?
            /// Run build in debug mode
            public var isDebug: Bool?

            public init(sourceVersion: String? = nil, isDebug: Bool? = nil) {
                self.sourceVersion = sourceVersion
                self.isDebug = isDebug
            }

            private enum CodingKeys: String, CodingKey {
                case sourceVersion
                case isDebug = "debug"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var branches: Branches {
        Branches(path: path + "/branches")
    }

    public struct Branches {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/branches`
        public let path: String

        /// Returns the list of Git branches for this application
        public var get: Request<[[String: GetResponseItemItem]]> {
            .get(path)
        }

        /// The branch build core properties
        public struct GetResponseItemItem: Decodable {
            public var branch: Branch?
            public var isEnabled: Bool?

            public struct Branch: Decodable {
                /// The branch name
                public var name: String
                public var commit: Commit

                public struct Commit: Decodable {
                    /// The commit SHA
                    public var sha: String?
                    /// The URL to the commit
                    public var url: String?

                    public init(sha: String? = nil, url: String? = nil) {
                        self.sha = sha
                        self.url = url
                    }
                }

                public init(name: String, commit: Commit) {
                    self.name = name
                    self.commit = commit
                }
            }

            public init(branch: Branch? = nil, isEnabled: Bool? = nil) {
                self.branch = branch
                self.isEnabled = isEnabled
            }

            private enum CodingKeys: String, CodingKey {
                case branch
                case isEnabled = "enabled"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var billing: Billing {
        Billing(path: path + "/billing")
    }

    public struct Billing {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/billing`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Billing {
    public var aggregated: Aggregated {
        Aggregated(path: path + "/aggregated")
    }

    public struct Aggregated {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/billing/aggregated`
        public let path: String

        /// Aggregated Billing Information for owner of a given app.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// Aggregated Billing Information for a user or an organization
        public struct GetResponse: Decodable {
            /// Version of the Billing Information schema
            public var version: String?
            /// The ISO 8601 datetime of last modification
            public var timestamp: String?
            /// ID of the user or organization
            public var id: String?
            /// Billing Plans section in the Billing Information
            public var billingPlans: BillingPlans?
            /// Usage section in the Billing Information
            public var usage: Usage?
            /// Unique identifier for the Azure subscription used for billing
            public var azureSubscriptionID: String?
            /// State of the Azure subscription used for billing
            public var azureSubscriptionState: AzureSubscriptionState?

            /// Billing Plans section in the Billing Information
            public struct BillingPlans: Decodable {
                /// Billing Plans for a single service
                public var buildService: BuildService?
                /// Billing Plans for a single service
                public var testService: TestService?

                /// Billing Plans for a single service
                public struct BuildService: Decodable {
                    /// Can customer select trial plan for that service (if it exists)?
                    public var canSelectTrialPlan: Bool?
                    /// Expiration time of the last selected trial plan. Will be null if trial plan was not used.
                    public var lastTrialPlanExpirationTime: String?
                    /// Billing plans for a given period
                    public var currentBillingPeriod: CurrentBillingPeriod?

                    /// Billing plans for a given period
                    public struct CurrentBillingPeriod: Decodable {
                        /// Inclusive start of the period
                        public var startTime: String?
                        /// Exclusive end of the period.
                        public var endTime: String?
                        /// Selection of a billing plan
                        public var byAccount: ByAccount?

                        /// Selection of a billing plan
                        public struct ByAccount: Decodable {
                            /// Number of instances of the billing plan.
                            public var count: Int?
                            /// Billing Plan
                            public var plan: Plan?

                            /// Billing Plan
                            public struct Plan: Decodable {
                                /// The Billing Plan ID
                                public var id: String?
                                /// Version of the Billing Plan schema
                                public var version: String?
                                /// Price of the Billing Plan
                                public var price: Double?
                                /// Service that receives payments for this billing plan.
                                public var paymentSource: PaymentSource?
                                /// Name of the service that the plan applies to.
                                public var service: Service?
                                /// A collection of named numeric values
                                public var limits: [String: Double]?
                                /// Collection of attribute values.
                                public var attributes: [String: [String: AnyJSON]]?
                                public var parentID: String?

                                /// Service that receives payments for this billing plan.
                                public enum PaymentSource: String, Codable, CaseIterable {
                                    case `none` = "None"
                                    case appCenter = "AppCenter"
                                    case gitHub = "GitHub"
                                    case xtc = "Xtc"
                                }

                                /// Name of the service that the plan applies to.
                                public enum Service: String, Codable, CaseIterable {
                                    case build = "Build"
                                    case test = "Test"
                                }

                                public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
                                    self.id = id
                                    self.version = version
                                    self.price = price
                                    self.paymentSource = paymentSource
                                    self.service = service
                                    self.limits = limits
                                    self.attributes = attributes
                                    self.parentID = parentID
                                }

                                private enum CodingKeys: String, CodingKey {
                                    case id
                                    case version
                                    case price
                                    case paymentSource
                                    case service
                                    case limits
                                    case attributes
                                    case parentID = "parentId"
                                }
                            }

                            public init(count: Int? = nil, plan: Plan? = nil) {
                                self.count = count
                                self.plan = plan
                            }
                        }

                        public init(startTime: String? = nil, endTime: String? = nil, byAccount: ByAccount? = nil) {
                            self.startTime = startTime
                            self.endTime = endTime
                            self.byAccount = byAccount
                        }
                    }

                    public init(canSelectTrialPlan: Bool? = nil, lastTrialPlanExpirationTime: String? = nil, currentBillingPeriod: CurrentBillingPeriod? = nil) {
                        self.canSelectTrialPlan = canSelectTrialPlan
                        self.lastTrialPlanExpirationTime = lastTrialPlanExpirationTime
                        self.currentBillingPeriod = currentBillingPeriod
                    }
                }

                /// Billing Plans for a single service
                public struct TestService: Decodable {
                    /// Can customer select trial plan for that service (if it exists)?
                    public var canSelectTrialPlan: Bool?
                    /// Expiration time of the last selected trial plan. Will be null if trial plan was not used.
                    public var lastTrialPlanExpirationTime: String?
                    /// Billing plans for a given period
                    public var currentBillingPeriod: CurrentBillingPeriod?

                    /// Billing plans for a given period
                    public struct CurrentBillingPeriod: Decodable {
                        /// Inclusive start of the period
                        public var startTime: String?
                        /// Exclusive end of the period.
                        public var endTime: String?
                        /// Selection of a billing plan
                        public var byAccount: ByAccount?

                        /// Selection of a billing plan
                        public struct ByAccount: Decodable {
                            /// Number of instances of the billing plan.
                            public var count: Int?
                            /// Billing Plan
                            public var plan: Plan?

                            /// Billing Plan
                            public struct Plan: Decodable {
                                /// The Billing Plan ID
                                public var id: String?
                                /// Version of the Billing Plan schema
                                public var version: String?
                                /// Price of the Billing Plan
                                public var price: Double?
                                /// Service that receives payments for this billing plan.
                                public var paymentSource: PaymentSource?
                                /// Name of the service that the plan applies to.
                                public var service: Service?
                                /// A collection of named numeric values
                                public var limits: [String: Double]?
                                /// Collection of attribute values.
                                public var attributes: [String: [String: AnyJSON]]?
                                public var parentID: String?

                                /// Service that receives payments for this billing plan.
                                public enum PaymentSource: String, Codable, CaseIterable {
                                    case `none` = "None"
                                    case appCenter = "AppCenter"
                                    case gitHub = "GitHub"
                                    case xtc = "Xtc"
                                }

                                /// Name of the service that the plan applies to.
                                public enum Service: String, Codable, CaseIterable {
                                    case build = "Build"
                                    case test = "Test"
                                }

                                public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
                                    self.id = id
                                    self.version = version
                                    self.price = price
                                    self.paymentSource = paymentSource
                                    self.service = service
                                    self.limits = limits
                                    self.attributes = attributes
                                    self.parentID = parentID
                                }

                                private enum CodingKeys: String, CodingKey {
                                    case id
                                    case version
                                    case price
                                    case paymentSource
                                    case service
                                    case limits
                                    case attributes
                                    case parentID = "parentId"
                                }
                            }

                            public init(count: Int? = nil, plan: Plan? = nil) {
                                self.count = count
                                self.plan = plan
                            }
                        }

                        public init(startTime: String? = nil, endTime: String? = nil, byAccount: ByAccount? = nil) {
                            self.startTime = startTime
                            self.endTime = endTime
                            self.byAccount = byAccount
                        }
                    }

                    public init(canSelectTrialPlan: Bool? = nil, lastTrialPlanExpirationTime: String? = nil, currentBillingPeriod: CurrentBillingPeriod? = nil) {
                        self.canSelectTrialPlan = canSelectTrialPlan
                        self.lastTrialPlanExpirationTime = lastTrialPlanExpirationTime
                        self.currentBillingPeriod = currentBillingPeriod
                    }
                }

                public init(buildService: BuildService? = nil, testService: TestService? = nil) {
                    self.buildService = buildService
                    self.testService = testService
                }
            }

            /// Usage section in the Billing Information
            public struct Usage: Decodable {
                /// Resource usage for a single Mobile Center service
                public var buildService: BuildService?
                /// Resource usage for a single Mobile Center service
                public var testService: TestService?

                /// Resource usage for a single Mobile Center service
                public struct BuildService: Decodable {
                    /// Usage for a single period
                    public var currentUsagePeriod: CurrentUsagePeriod?

                    /// Usage for a single period
                    public struct CurrentUsagePeriod: Decodable {
                        /// Inclusive start time of the usage period
                        public var startTime: String?
                        /// Exclusive end time of the usage period.
                        public var endTime: String?
                        /// A collection of named numeric values
                        public var byAccount: [String: Double]?
                        /// A collection of  named numeric values grouped by app
                        public var byApp: [String: [String: Double]]?

                        public init(startTime: String? = nil, endTime: String? = nil, byAccount: [String: Double]? = nil, byApp: [String: [String: Double]]? = nil) {
                            self.startTime = startTime
                            self.endTime = endTime
                            self.byAccount = byAccount
                            self.byApp = byApp
                        }
                    }

                    public init(currentUsagePeriod: CurrentUsagePeriod? = nil) {
                        self.currentUsagePeriod = currentUsagePeriod
                    }
                }

                /// Resource usage for a single Mobile Center service
                public struct TestService: Decodable {
                    /// Usage for a single period
                    public var currentUsagePeriod: CurrentUsagePeriod?

                    /// Usage for a single period
                    public struct CurrentUsagePeriod: Decodable {
                        /// Inclusive start time of the usage period
                        public var startTime: String?
                        /// Exclusive end time of the usage period.
                        public var endTime: String?
                        /// A collection of named numeric values
                        public var byAccount: [String: Double]?
                        /// A collection of  named numeric values grouped by app
                        public var byApp: [String: [String: Double]]?

                        public init(startTime: String? = nil, endTime: String? = nil, byAccount: [String: Double]? = nil, byApp: [String: [String: Double]]? = nil) {
                            self.startTime = startTime
                            self.endTime = endTime
                            self.byAccount = byAccount
                            self.byApp = byApp
                        }
                    }

                    public init(currentUsagePeriod: CurrentUsagePeriod? = nil) {
                        self.currentUsagePeriod = currentUsagePeriod
                    }
                }

                public init(buildService: BuildService? = nil, testService: TestService? = nil) {
                    self.buildService = buildService
                    self.testService = testService
                }
            }

            /// State of the Azure subscription used for billing
            public enum AzureSubscriptionState: String, Codable, CaseIterable {
                case enabled = "Enabled"
                case disabled = "Disabled"
                case notSet = "NotSet"
            }

            public init(version: String? = nil, timestamp: String? = nil, id: String? = nil, billingPlans: BillingPlans? = nil, usage: Usage? = nil, azureSubscriptionID: String? = nil, azureSubscriptionState: AzureSubscriptionState? = nil) {
                self.version = version
                self.timestamp = timestamp
                self.id = id
                self.billingPlans = billingPlans
                self.usage = usage
                self.azureSubscriptionID = azureSubscriptionID
                self.azureSubscriptionState = azureSubscriptionState
            }

            private enum CodingKeys: String, CodingKey {
                case version
                case timestamp
                case id
                case billingPlans
                case usage
                case azureSubscriptionID = "azureSubscriptionId"
                case azureSubscriptionState
            }
        }

        public struct GetParameters {
            public var service: Service?
            public var period: Period?
            public var isShowOriginalPlans: Bool?

            public enum Service: String, Codable, CaseIterable {
                case test = "Test"
                case build = "Build"
            }

            public enum Period: String, Codable, CaseIterable {
                case previous = "Previous"
                case current = "Current"
                case next = "Next"
            }

            public init(service: Service? = nil, period: Period? = nil, isShowOriginalPlans: Bool? = nil) {
                self.service = service
                self.period = period
                self.isShowOriginalPlans = isShowOriginalPlans
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(service, forKey: "service")
                encoder.encode(period, forKey: "period")
                encoder.encode(isShowOriginalPlans, forKey: "showOriginalPlans")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.AzureSubscriptions {
    public func azureSubscriptionID(_ azureSubscriptionID: String) -> WithAzureSubscriptionID {
        WithAzureSubscriptionID(path: "\(path)/\(azureSubscriptionID)")
    }

    public struct WithAzureSubscriptionID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/azure_subscriptions/{azure_subscription_id}`
        public let path: String

        /// Delete the azure subscriptions for the app
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var azureSubscriptions: AzureSubscriptions {
        AzureSubscriptions(path: path + "/azure_subscriptions")
    }

    public struct AzureSubscriptions {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/azure_subscriptions`
        public let path: String

        /// Returns a list of azure subscriptions for the app
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The azure subscription id
            public var subscriptionID: String
            /// The tenant id of the azure subscription belongs to
            public var tenantID: String
            /// The name of the azure subscription
            public var subscriptionName: String
            /// If the subscription is used for billing
            public var isBilling: Bool?
            /// If the subscription can be used for billing
            public var isBillable: Bool?
            /// If the subscription is internal Microsoft subscription
            public var isMicrosoftInternal: Bool?

            public init(subscriptionID: String, tenantID: String, subscriptionName: String, isBilling: Bool? = nil, isBillable: Bool? = nil, isMicrosoftInternal: Bool? = nil) {
                self.subscriptionID = subscriptionID
                self.tenantID = tenantID
                self.subscriptionName = subscriptionName
                self.isBilling = isBilling
                self.isBillable = isBillable
                self.isMicrosoftInternal = isMicrosoftInternal
            }

            private enum CodingKeys: String, CodingKey {
                case subscriptionID = "subscription_id"
                case tenantID = "tenant_id"
                case subscriptionName = "subscription_name"
                case isBilling = "is_billing"
                case isBillable = "is_billable"
                case isMicrosoftInternal = "is_microsoft_internal"
            }
        }

        /// Link azure subscription to an app
        public func post(subscriptionID: String) -> Request<Void> {
            .post(path, body: ["subscription_id": subscriptionID])
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var avatar: Avatar {
        Avatar(path: path + "/avatar")
    }

    public struct Avatar {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/avatar`
        public let path: String

        /// Sets the app avatar
        public func post(_ body: Data? = nil) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        /// Deletes the uploaded app avatar
        public var delete: Request<[String: AnyJSON]> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var appleTestFlightGroups: AppleTestFlightGroups {
        AppleTestFlightGroups(path: path + "/apple_test_flight_groups")
    }

    public struct AppleTestFlightGroups {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/apple_test_flight_groups`
        public let path: String

        /// Fetch all apple test flight groups
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        /// Apple Test Flight Groups Response Type
        public struct GetResponseItem: Decodable {
            /// Id of the group.
            public var id: String?
            /// Provider id of the group.
            public var providerID: Double?
            /// Apple id of the group.
            public var appleID: Double?
            /// Name of the group.
            public var name: String?

            public init(id: String? = nil, providerID: Double? = nil, appleID: Double? = nil, name: String? = nil) {
                self.id = id
                self.providerID = providerID
                self.appleID = appleID
                self.name = name
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case providerID = "providerId"
                case appleID = "appleId"
                case name
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var appleMapping: AppleMapping {
        AppleMapping(path: path + "/apple_mapping")
    }

    public struct AppleMapping {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/apple_mapping`
        public let path: String

        /// Get mapping of apple app to an existing app in apple store.
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Create a mapping for an existing app in apple store for the specified application.
        public func post(_ body: PostRequest) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        /// Apple Mapping Request Type
        public struct PostRequest: Encodable {
            /// Id for the shared service connection. In case of Apple AppStore, this connection will be used to create and connect to the Apple AppStore in Mobile Center.
            public var serviceConnectionID: String
            /// ID of the apple application in apple store, takes precedence over bundle_identifier when both are provided
            public var appleID: String?
            /// Bundle Identifier of the apple package
            public var bundleIdentifier: String?
            /// ID of the Team associated with the app in apple store
            public var teamIdentifier: String

            public init(serviceConnectionID: String, appleID: String? = nil, bundleIdentifier: String? = nil, teamIdentifier: String) {
                self.serviceConnectionID = serviceConnectionID
                self.appleID = appleID
                self.bundleIdentifier = bundleIdentifier
                self.teamIdentifier = teamIdentifier
            }

            private enum CodingKeys: String, CodingKey {
                case serviceConnectionID = "service_connection_id"
                case appleID = "apple_id"
                case bundleIdentifier = "bundle_identifier"
                case teamIdentifier = "team_identifier"
            }
        }

        /// Delete mapping of apple app to an existing app in apple store.
        public func delete(_ body: String? = nil) -> Request<Void> {
            .delete(path, body: body)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.APITokens {
    public func apiTokenID(_ apiTokenID: String) -> WithAPITokenID {
        WithAPITokenID(path: "\(path)/\(apiTokenID)")
    }

    public struct WithAPITokenID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/api_tokens/{api_token_id}`
        public let path: String

        /// Delete the App Api Token object with the specific ID
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var apiTokens: APITokens {
        APITokens(path: path + "/api_tokens")
    }

    public struct APITokens {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/api_tokens`
        public let path: String

        /// Returns App API tokens for the app
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The unique id (UUID) of the api token
            public var id: String
            /// The description of the token
            public var description: String?
            /// The scope for this token.
            public var scope: [ScopeItem]?
            /// The creation time
            public var createdAt: String

            public enum ScopeItem: String, Codable, CaseIterable {
                case all
                case viewer
            }

            public init(id: String, description: String? = nil, scope: [ScopeItem]? = nil, createdAt: String) {
                self.id = id
                self.description = description
                self.scope = scope
                self.createdAt = createdAt
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case description
                case scope
                case createdAt = "created_at"
            }
        }

        /// Creates a new App API token
        public func post(_ body: PostRequest? = nil) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The description of the token
            public var description: String?
            /// The scope for this token.
            public var scope: [ScopeItem]?

            public enum ScopeItem: String, Codable, CaseIterable {
                case all
                case viewer
            }

            public init(description: String? = nil, scope: [ScopeItem]? = nil) {
                self.description = description
                self.scope = scope
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName {
    public var analytics: Analytics {
        Analytics(path: path + "/analytics")
    }

    public struct Analytics {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics {
    public var versions: Versions {
        Versions(path: path + "/versions")
    }

    public struct Versions {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/versions`
        public let path: String

        /// Count of active versions in the time range ordered by version.
        public func get(parameters: GetParameters) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var top: Int?
            public var versions: [String]?

            public init(start: Date, end: Date? = nil, top: Int? = nil, versions: [String]? = nil) {
                self.start = start
                self.end = end
                self.top = top
                self.versions = versions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(top, forKey: "$top")
                encoder.encode(versions, forKey: "versions", explode: false, delimiter: "|")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics {
    public var sessionsPerDevice: SessionsPerDevice {
        SessionsPerDevice(path: path + "/sessions_per_device")
    }

    public struct SessionsPerDevice {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/sessions_per_device`
        public let path: String

        /// Count of sessions per device in the time range.
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// Average seesion per user.
            public var averageSessionsPerUser: Double?
            /// Previous average session per user.
            public var previousAverageSessionsPerUser: Double?
            /// Total session per device count.
            public var totalCount: Int?
            /// Previous total count.
            public var previousTotalCount: Int?
            /// The session count for each interval per device.
            public var sessionsPerUser: [SessionsPerUserItem]?

            public struct SessionsPerUserItem: Decodable {
                /// The ISO 8601 datetime.
                public var datetime: String?
                /// Count.
                public var count: Double?

                public init(datetime: String? = nil, count: Double? = nil) {
                    self.datetime = datetime
                    self.count = count
                }
            }

            public init(averageSessionsPerUser: Double? = nil, previousAverageSessionsPerUser: Double? = nil, totalCount: Int? = nil, previousTotalCount: Int? = nil, sessionsPerUser: [SessionsPerUserItem]? = nil) {
                self.averageSessionsPerUser = averageSessionsPerUser
                self.previousAverageSessionsPerUser = previousAverageSessionsPerUser
                self.totalCount = totalCount
                self.previousTotalCount = previousTotalCount
                self.sessionsPerUser = sessionsPerUser
            }

            private enum CodingKeys: String, CodingKey {
                case averageSessionsPerUser = "average_sessions_per_user"
                case previousAverageSessionsPerUser = "previous_average_sessions_per_user"
                case totalCount = "total_count"
                case previousTotalCount = "previous_total_count"
                case sessionsPerUser = "sessions_per_user"
            }
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var interval: String
            public var versions: [String]?

            public init(start: Date, end: Date? = nil, interval: String, versions: [String]? = nil) {
                self.start = start
                self.end = end
                self.interval = interval
                self.versions = versions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(interval, forKey: "interval")
                encoder.encode(versions, forKey: "versions", explode: false, delimiter: "|")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics {
    public var sessionDurationsDistribution: SessionDurationsDistribution {
        SessionDurationsDistribution(path: path + "/session_durations_distribution")
    }

    public struct SessionDurationsDistribution {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/session_durations_distribution`
        public let path: String

        /// Gets session duration.
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The count of sessions in these buckets.
            public var distribution: [DistributionItem]?
            /// The previous average session duration for previous time range.
            public var previousAverageDuration: String?
            /// The average session duration for current time range.
            public var averageDuration: String?

            public struct DistributionItem: Decodable {
                /// The bucket name.
                public var bucket: String?
                /// The count of sessions in current bucket.
                public var count: Int?

                public init(bucket: String? = nil, count: Int? = nil) {
                    self.bucket = bucket
                    self.count = count
                }
            }

            public init(distribution: [DistributionItem]? = nil, previousAverageDuration: String? = nil, averageDuration: String? = nil) {
                self.distribution = distribution
                self.previousAverageDuration = previousAverageDuration
                self.averageDuration = averageDuration
            }

            private enum CodingKeys: String, CodingKey {
                case distribution
                case previousAverageDuration = "previous_average_duration"
                case averageDuration = "average_duration"
            }
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var versions: [String]?

            public init(start: Date, end: Date? = nil, versions: [String]? = nil) {
                self.start = start
                self.end = end
                self.versions = versions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(versions, forKey: "versions", explode: false, delimiter: "|")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics {
    public var sessionCounts: SessionCounts {
        SessionCounts(path: path + "/session_counts")
    }

    public struct SessionCounts {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/session_counts`
        public let path: String

        /// Count of sessions in the time range.
        public func get(parameters: GetParameters) -> Request<[GetResponseItem]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponseItem: Decodable {
            /// The ISO 8601 datetime.
            public var datetime: String?
            /// Count of the object.
            public var count: Int?

            public init(datetime: String? = nil, count: Int? = nil) {
                self.datetime = datetime
                self.count = count
            }
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var interval: String
            public var versions: [String]?

            public init(start: Date, end: Date? = nil, interval: String, versions: [String]? = nil) {
                self.start = start
                self.end = end
                self.interval = interval
                self.versions = versions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(interval, forKey: "interval")
                encoder.encode(versions, forKey: "versions", explode: false, delimiter: "|")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics {
    public var places: Places {
        Places(path: path + "/places")
    }

    public struct Places {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/places`
        public let path: String

        /// Places in the time range.
        public func get(parameters: GetParameters) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var top: Int?
            public var versions: [String]?

            public init(start: Date, end: Date? = nil, top: Int? = nil, versions: [String]? = nil) {
                self.start = start
                self.end = end
                self.top = top
                self.versions = versions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(top, forKey: "$top")
                encoder.encode(versions, forKey: "versions", explode: false, delimiter: "|")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics {
    public var oses: Oses {
        Oses(path: path + "/oses")
    }

    public struct Oses {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/oses`
        public let path: String

        /// OSes in the time range.
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            public var total: Int?
            public var oses: [Ose]?

            public struct Ose: Decodable {
                /// OS name.
                public var osName: String?
                /// Count current of OS.
                public var count: Int?
                /// Count of previous OS.
                public var previousCount: Int?

                public init(osName: String? = nil, count: Int? = nil, previousCount: Int? = nil) {
                    self.osName = osName
                    self.count = count
                    self.previousCount = previousCount
                }

                private enum CodingKeys: String, CodingKey {
                    case osName = "os_name"
                    case count
                    case previousCount = "previous_count"
                }
            }

            public init(total: Int? = nil, oses: [Ose]? = nil) {
                self.total = total
                self.oses = oses
            }
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var top: Int?
            public var versions: [String]?

            public init(start: Date, end: Date? = nil, top: Int? = nil, versions: [String]? = nil) {
                self.start = start
                self.end = end
                self.top = top
                self.versions = versions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(top, forKey: "$top")
                encoder.encode(versions, forKey: "versions", explode: false, delimiter: "|")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics {
    public var models: Models {
        Models(path: path + "/models")
    }

    public struct Models {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/models`
        public let path: String

        /// Models in the time range.
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            public var total: Int?
            public var models: [Model]?

            public struct Model: Decodable {
                /// Model's name.
                public var modelName: String?
                /// Count current of model.
                public var count: Int?
                /// Count of previous model.
                public var previousCount: Int?

                public init(modelName: String? = nil, count: Int? = nil, previousCount: Int? = nil) {
                    self.modelName = modelName
                    self.count = count
                    self.previousCount = previousCount
                }

                private enum CodingKeys: String, CodingKey {
                    case modelName = "model_name"
                    case count
                    case previousCount = "previous_count"
                }
            }

            public init(total: Int? = nil, models: [Model]? = nil) {
                self.total = total
                self.models = models
            }
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var top: Int?
            public var versions: [String]?

            public init(start: Date, end: Date? = nil, top: Int? = nil, versions: [String]? = nil) {
                self.start = start
                self.end = end
                self.top = top
                self.versions = versions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(top, forKey: "$top")
                encoder.encode(versions, forKey: "versions", explode: false, delimiter: "|")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics {
    public var logFlow: LogFlow {
        LogFlow(path: path + "/log_flow")
    }

    public struct LogFlow {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/log_flow`
        public let path: String

        /// Logs received between the specified start time and the current time. The API will return a maximum of 100 logs per call.
        public func get(start: Date? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(start))
        }

        public struct GetResponse: Decodable {
            /// Indicates if the number of available logs are more than the max allowed return limit(100).
            public var isExceededMaxLimit: Bool?
            /// The timestamp of the last log received. This value can be used as the start time parameter in the consecutive API call.
            public var lastReceivedLogTimestamp: Date?
            /// The list of logs
            public var logs: [Log]

            public struct Log: Decodable {
                /// Log type.
                public var type: `Type`
                /// Log creation timestamp.
                public var timestamp: Date
                /// Install ID.
                public var installID: String
                /// Device characteristics.
                public var device: Device

                /// Log type.
                public enum `Type`: String, Codable, CaseIterable {
                    case event
                    case page
                    case startSession = "start_session"
                    case error
                    case startService = "start_service"
                    case customProperties = "custom_properties"
                }

                /// Device characteristics.
                public struct Device: Decodable {
                    /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
                    public var sdkName: String
                    /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
                    public var sdkVersion: String
                    /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
                    public var wrapperSdkVersion: String?
                    /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
                    public var wrapperSdkName: String?
                    /// Device model (example: iPad2,3).
                    public var model: String?
                    /// Device manufacturer (example: HTC).
                    public var oemName: String?
                    /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
                    public var osName: String
                    /// OS version (example: 9.3.0).
                    public var osVersion: String
                    /// OS build code (example: LMY47X).
                    public var osBuild: String?
                    /// API level when applicable like in Android (example: 15).
                    public var osAPILevel: Int?
                    /// Language code (example: en_US).
                    public var locale: String
                    /// The offset in minutes from UTC for the device time zone, including daylight savings time.
                    public var timeZoneOffset: Int
                    /// Screen size of the device in pixels (example: 640x480).
                    public var screenSize: String?
                    /// Application version name, e.g. 1.1.0
                    public var appVersion: String
                    /// Carrier name (for mobile devices).
                    public var carrierName: String?
                    /// Carrier country code (for mobile devices).
                    public var carrierCode: String?
                    /// Carrier country.
                    public var carrierCountry: String?
                    /// The app's build number, e.g. 42.
                    public var appBuild: String
                    /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
                    public var appNamespace: String?
                    /// Label that is used to identify application code 'version' released via Live Update beacon running on device
                    public var liveUpdateReleaseLabel: String?
                    /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
                    public var liveUpdateDeploymentKey: String?
                    /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
                    public var liveUpdatePackageHash: String?
                    /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
                    public var wrapperRuntimeVersion: String?

                    public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
                        self.sdkName = sdkName
                        self.sdkVersion = sdkVersion
                        self.wrapperSdkVersion = wrapperSdkVersion
                        self.wrapperSdkName = wrapperSdkName
                        self.model = model
                        self.oemName = oemName
                        self.osName = osName
                        self.osVersion = osVersion
                        self.osBuild = osBuild
                        self.osAPILevel = osAPILevel
                        self.locale = locale
                        self.timeZoneOffset = timeZoneOffset
                        self.screenSize = screenSize
                        self.appVersion = appVersion
                        self.carrierName = carrierName
                        self.carrierCode = carrierCode
                        self.carrierCountry = carrierCountry
                        self.appBuild = appBuild
                        self.appNamespace = appNamespace
                        self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
                        self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
                        self.liveUpdatePackageHash = liveUpdatePackageHash
                        self.wrapperRuntimeVersion = wrapperRuntimeVersion
                    }

                    private enum CodingKeys: String, CodingKey {
                        case sdkName = "sdk_name"
                        case sdkVersion = "sdk_version"
                        case wrapperSdkVersion = "wrapper_sdk_version"
                        case wrapperSdkName = "wrapper_sdk_name"
                        case model
                        case oemName = "oem_name"
                        case osName = "os_name"
                        case osVersion = "os_version"
                        case osBuild = "os_build"
                        case osAPILevel = "os_api_level"
                        case locale
                        case timeZoneOffset = "time_zone_offset"
                        case screenSize = "screen_size"
                        case appVersion = "app_version"
                        case carrierName = "carrier_name"
                        case carrierCode = "carrier_code"
                        case carrierCountry = "carrier_country"
                        case appBuild = "app_build"
                        case appNamespace = "app_namespace"
                        case liveUpdateReleaseLabel = "live_update_release_label"
                        case liveUpdateDeploymentKey = "live_update_deployment_key"
                        case liveUpdatePackageHash = "live_update_package_hash"
                        case wrapperRuntimeVersion = "wrapper_runtime_version"
                    }
                }

                public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
                    self.type = type
                    self.timestamp = timestamp
                    self.installID = installID
                    self.device = device
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case timestamp
                    case installID = "install_id"
                    case device
                }
            }

            public init(isExceededMaxLimit: Bool? = nil, lastReceivedLogTimestamp: Date? = nil, logs: [Log]) {
                self.isExceededMaxLimit = isExceededMaxLimit
                self.lastReceivedLogTimestamp = lastReceivedLogTimestamp
                self.logs = logs
            }

            private enum CodingKeys: String, CodingKey {
                case isExceededMaxLimit = "exceeded_max_limit"
                case lastReceivedLogTimestamp = "last_received_log_timestamp"
                case logs
            }
        }

        private func makeGetQuery(_ start: Date?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(start, forKey: "start")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics {
    public var languages: Languages {
        Languages(path: path + "/languages")
    }

    public struct Languages {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/languages`
        public let path: String

        /// Languages in the time range.
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            public var total: Int?
            public var languages: [Language]?

            public struct Language: Decodable {
                /// Language's name.
                public var languageName: String?
                /// Count current of language.
                public var count: Int?
                /// Count of previous lanugage.
                public var previousCount: Int?

                public init(languageName: String? = nil, count: Int? = nil, previousCount: Int? = nil) {
                    self.languageName = languageName
                    self.count = count
                    self.previousCount = previousCount
                }

                private enum CodingKeys: String, CodingKey {
                    case languageName = "language_name"
                    case count
                    case previousCount = "previous_count"
                }
            }

            public init(total: Int? = nil, languages: [Language]? = nil) {
                self.total = total
                self.languages = languages
            }
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var top: Int?
            public var versions: [String]?

            public init(start: Date, end: Date? = nil, top: Int? = nil, versions: [String]? = nil) {
                self.start = start
                self.end = end
                self.top = top
                self.versions = versions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(top, forKey: "$top")
                encoder.encode(versions, forKey: "versions", explode: false, delimiter: "|")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics {
    public var genericLogFlow: GenericLogFlow {
        GenericLogFlow(path: path + "/generic_log_flow")
    }

    public struct GenericLogFlow {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/generic_log_flow`
        public let path: String

        /// Logs received between the specified start time and the current time. The API will return a maximum of 100 logs per call.
        public func get(start: Date? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(start))
        }

        public struct GetResponse: Decodable {
            /// Indicates if the number of available logs are more than the max allowed return limit(100).
            public var isExceededMaxLimit: Bool?
            /// The timestamp of the last log received. This value can be used as the start time parameter in the consecutive API call.
            public var lastReceivedLogTimestamp: Date?
            /// The list of logs
            public var logs: [Log]

            /// Generic log.
            public struct Log: Decodable {
                /// Log type.
                public var type: `Type`
                /// Log creation timestamp.
                public var timestamp: Date
                /// Install ID.
                public var installID: String
                /// Session ID.
                public var sessionID: String?
                /// Event ID.
                public var eventID: String?
                /// Event name.
                public var eventName: String?
                /// Message ID.
                public var messageID: String?
                /// Event specific properties.
                public var properties: [String: String]?
                /// Device characteristics.
                public var device: Device
                /// Auth service provider.
                public var authProvider: String?
                /// Account ID of the authenticated user.
                public var accountID: String?

                /// Log type.
                public enum `Type`: String, Codable, CaseIterable {
                    case event
                    case page
                    case startSession = "start_session"
                    case error
                    case startService = "start_service"
                    case customProperties = "custom_properties"
                }

                /// Device characteristics.
                public struct Device: Decodable {
                    /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
                    public var sdkName: String
                    /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
                    public var sdkVersion: String
                    /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
                    public var wrapperSdkVersion: String?
                    /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
                    public var wrapperSdkName: String?
                    /// Device model (example: iPad2,3).
                    public var model: String?
                    /// Device manufacturer (example: HTC).
                    public var oemName: String?
                    /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
                    public var osName: String
                    /// OS version (example: 9.3.0).
                    public var osVersion: String
                    /// OS build code (example: LMY47X).
                    public var osBuild: String?
                    /// API level when applicable like in Android (example: 15).
                    public var osAPILevel: Int?
                    /// Language code (example: en_US).
                    public var locale: String
                    /// The offset in minutes from UTC for the device time zone, including daylight savings time.
                    public var timeZoneOffset: Int
                    /// Screen size of the device in pixels (example: 640x480).
                    public var screenSize: String?
                    /// Application version name, e.g. 1.1.0
                    public var appVersion: String
                    /// Carrier name (for mobile devices).
                    public var carrierName: String?
                    /// Carrier country code (for mobile devices).
                    public var carrierCode: String?
                    /// Carrier country.
                    public var carrierCountry: String?
                    /// The app's build number, e.g. 42.
                    public var appBuild: String
                    /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
                    public var appNamespace: String?
                    /// Label that is used to identify application code 'version' released via Live Update beacon running on device
                    public var liveUpdateReleaseLabel: String?
                    /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
                    public var liveUpdateDeploymentKey: String?
                    /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
                    public var liveUpdatePackageHash: String?
                    /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
                    public var wrapperRuntimeVersion: String?

                    public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
                        self.sdkName = sdkName
                        self.sdkVersion = sdkVersion
                        self.wrapperSdkVersion = wrapperSdkVersion
                        self.wrapperSdkName = wrapperSdkName
                        self.model = model
                        self.oemName = oemName
                        self.osName = osName
                        self.osVersion = osVersion
                        self.osBuild = osBuild
                        self.osAPILevel = osAPILevel
                        self.locale = locale
                        self.timeZoneOffset = timeZoneOffset
                        self.screenSize = screenSize
                        self.appVersion = appVersion
                        self.carrierName = carrierName
                        self.carrierCode = carrierCode
                        self.carrierCountry = carrierCountry
                        self.appBuild = appBuild
                        self.appNamespace = appNamespace
                        self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
                        self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
                        self.liveUpdatePackageHash = liveUpdatePackageHash
                        self.wrapperRuntimeVersion = wrapperRuntimeVersion
                    }

                    private enum CodingKeys: String, CodingKey {
                        case sdkName = "sdk_name"
                        case sdkVersion = "sdk_version"
                        case wrapperSdkVersion = "wrapper_sdk_version"
                        case wrapperSdkName = "wrapper_sdk_name"
                        case model
                        case oemName = "oem_name"
                        case osName = "os_name"
                        case osVersion = "os_version"
                        case osBuild = "os_build"
                        case osAPILevel = "os_api_level"
                        case locale
                        case timeZoneOffset = "time_zone_offset"
                        case screenSize = "screen_size"
                        case appVersion = "app_version"
                        case carrierName = "carrier_name"
                        case carrierCode = "carrier_code"
                        case carrierCountry = "carrier_country"
                        case appBuild = "app_build"
                        case appNamespace = "app_namespace"
                        case liveUpdateReleaseLabel = "live_update_release_label"
                        case liveUpdateDeploymentKey = "live_update_deployment_key"
                        case liveUpdatePackageHash = "live_update_package_hash"
                        case wrapperRuntimeVersion = "wrapper_runtime_version"
                    }
                }

                public init(type: `Type`, timestamp: Date, installID: String, sessionID: String? = nil, eventID: String? = nil, eventName: String? = nil, messageID: String? = nil, properties: [String: String]? = nil, device: Device, authProvider: String? = nil, accountID: String? = nil) {
                    self.type = type
                    self.timestamp = timestamp
                    self.installID = installID
                    self.sessionID = sessionID
                    self.eventID = eventID
                    self.eventName = eventName
                    self.messageID = messageID
                    self.properties = properties
                    self.device = device
                    self.authProvider = authProvider
                    self.accountID = accountID
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case timestamp
                    case installID = "install_id"
                    case sessionID = "session_id"
                    case eventID = "event_id"
                    case eventName = "event_name"
                    case messageID = "message_id"
                    case properties
                    case device
                    case authProvider = "auth_provider"
                    case accountID = "account_id"
                }
            }

            public init(isExceededMaxLimit: Bool? = nil, lastReceivedLogTimestamp: Date? = nil, logs: [Log]) {
                self.isExceededMaxLimit = isExceededMaxLimit
                self.lastReceivedLogTimestamp = lastReceivedLogTimestamp
                self.logs = logs
            }

            private enum CodingKeys: String, CodingKey {
                case isExceededMaxLimit = "exceeded_max_limit"
                case lastReceivedLogTimestamp = "last_received_log_timestamp"
                case logs
            }
        }

        private func makeGetQuery(_ start: Date?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(start, forKey: "start")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.Events.WithEventName.Properties {
    public func eventPropertyName(_ eventPropertyName: String) -> WithEventPropertyName {
        WithEventPropertyName(path: "\(path)/\(eventPropertyName)")
    }

    public struct WithEventPropertyName {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/events/{event_name}/properties/{event_property_name}`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.Events.WithEventName.Properties.WithEventPropertyName {
    public var counts: Counts {
        Counts(path: path + "/counts")
    }

    public struct Counts {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/events/{event_name}/properties/{event_property_name}/counts`
        public let path: String

        /// Event properties value counts during the time range in descending order.
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        /// Event property value counts during the time range in descending order.
        public struct GetResponse: Decodable {
            /// The total property value counts.
            public var total: Int?
            /// The event property values.
            public var values: [Value]?

            /// An event property value with counts.
            public struct Value: Decodable {
                /// The event property value name.
                public var name: String?
                /// The count of the the event property value.
                public var count: Int?
                /// The count of previous time range of the event property value.
                public var previousCount: Int?

                public init(name: String? = nil, count: Int? = nil, previousCount: Int? = nil) {
                    self.name = name
                    self.count = count
                    self.previousCount = previousCount
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case count
                    case previousCount = "previous_count"
                }
            }

            public init(total: Int? = nil, values: [Value]? = nil) {
                self.total = total
                self.values = values
            }
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var versions: [String]?
            public var top: Int?

            public init(start: Date, end: Date? = nil, versions: [String]? = nil, top: Int? = nil) {
                self.start = start
                self.end = end
                self.versions = versions
                self.top = top
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(versions, forKey: "versions", explode: false, delimiter: "|")
                encoder.encode(top, forKey: "$top")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.Events.WithEventName {
    public var properties: Properties {
        Properties(path: path + "/properties")
    }

    public struct Properties {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/events/{event_name}/properties`
        public let path: String

        /// Event properties.
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Event properties during the time range.
        public struct GetResponse: Decodable {
            public var eventProperties: [String]?

            public init(eventProperties: [String]? = nil) {
                self.eventProperties = eventProperties
            }

            private enum CodingKeys: String, CodingKey {
                case eventProperties = "event_properties"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.Events.WithEventName {
    public var eventCount: EventCount {
        EventCount(path: path + "/event_count")
    }

    public struct EventCount {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/events/{event_name}/event_count`
        public let path: String

        /// Count of events by interval in the time range.
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            public var totalCount: Int?
            public var previousTotalCount: Int?
            public var count: [CountItem]?

            public struct CountItem: Decodable {
                /// The ISO 8601 datetime.
                public var datetime: String?
                /// Count of the object.
                public var count: Int?

                public init(datetime: String? = nil, count: Int? = nil) {
                    self.datetime = datetime
                    self.count = count
                }
            }

            public init(totalCount: Int? = nil, previousTotalCount: Int? = nil, count: [CountItem]? = nil) {
                self.totalCount = totalCount
                self.previousTotalCount = previousTotalCount
                self.count = count
            }

            private enum CodingKeys: String, CodingKey {
                case totalCount = "total_count"
                case previousTotalCount = "previous_total_count"
                case count
            }
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var versions: [String]?

            public init(start: Date, end: Date? = nil, versions: [String]? = nil) {
                self.start = start
                self.end = end
                self.versions = versions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(versions, forKey: "versions", explode: false, delimiter: "|")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.Events.WithEventName {
    public var deviceCount: DeviceCount {
        DeviceCount(path: path + "/device_count")
    }

    public struct DeviceCount {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/events/{event_name}/device_count`
        public let path: String

        /// Count of devices for an event by interval in the time range.
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            public var totalDevices: Int?
            public var totalDevicesWithEvent: Int?
            public var previousTotalDevicesWithEvent: Int?
            public var devicesCount: [DevicesCountItem]?

            public struct DevicesCountItem: Decodable {
                /// The ISO 8601 datetime.
                public var datetime: String?
                /// Count of the object.
                public var count: Int?

                public init(datetime: String? = nil, count: Int? = nil) {
                    self.datetime = datetime
                    self.count = count
                }
            }

            public init(totalDevices: Int? = nil, totalDevicesWithEvent: Int? = nil, previousTotalDevicesWithEvent: Int? = nil, devicesCount: [DevicesCountItem]? = nil) {
                self.totalDevices = totalDevices
                self.totalDevicesWithEvent = totalDevicesWithEvent
                self.previousTotalDevicesWithEvent = previousTotalDevicesWithEvent
                self.devicesCount = devicesCount
            }

            private enum CodingKeys: String, CodingKey {
                case totalDevices = "total_devices"
                case totalDevicesWithEvent = "total_devices_with_event"
                case previousTotalDevicesWithEvent = "previous_total_devices_with_event"
                case devicesCount = "devices_count"
            }
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var versions: [String]?

            public init(start: Date, end: Date? = nil, versions: [String]? = nil) {
                self.start = start
                self.end = end
                self.versions = versions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(versions, forKey: "versions", explode: false, delimiter: "|")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.Events.WithEventName {
    public var countPerSession: CountPerSession {
        CountPerSession(path: path + "/count_per_session")
    }

    public struct CountPerSession {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/events/{event_name}/count_per_session`
        public let path: String

        /// Count of events per session by interval in the time range.
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            public var avgCountPerSession: Double?
            public var previousAvgCountPerSession: Double?
            public var countPerSession: [CountPerSessionItem]?

            public struct CountPerSessionItem: Decodable {
                /// The ISO 8601 datetime.
                public var datetime: String?
                /// Decimal count of the object.
                public var count: Double?

                public init(datetime: String? = nil, count: Double? = nil) {
                    self.datetime = datetime
                    self.count = count
                }
            }

            public init(avgCountPerSession: Double? = nil, previousAvgCountPerSession: Double? = nil, countPerSession: [CountPerSessionItem]? = nil) {
                self.avgCountPerSession = avgCountPerSession
                self.previousAvgCountPerSession = previousAvgCountPerSession
                self.countPerSession = countPerSession
            }

            private enum CodingKeys: String, CodingKey {
                case avgCountPerSession = "avg_count_per_session"
                case previousAvgCountPerSession = "previous_avg_count_per_session"
                case countPerSession = "count_per_session"
            }
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var versions: [String]?

            public init(start: Date, end: Date? = nil, versions: [String]? = nil) {
                self.start = start
                self.end = end
                self.versions = versions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(versions, forKey: "versions", explode: false, delimiter: "|")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.Events.WithEventName {
    public var countPerDevice: CountPerDevice {
        CountPerDevice(path: path + "/count_per_device")
    }

    public struct CountPerDevice {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/events/{event_name}/count_per_device`
        public let path: String

        /// Count of events per device by interval in the time range.
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            public var avgCountPerDevice: Double?
            public var previousAvgCountPerDevice: Double?
            public var countPerDevice: [CountPerDeviceItem]?

            public struct CountPerDeviceItem: Decodable {
                /// The ISO 8601 datetime.
                public var datetime: String?
                /// Decimal count of the object.
                public var count: Double?

                public init(datetime: String? = nil, count: Double? = nil) {
                    self.datetime = datetime
                    self.count = count
                }
            }

            public init(avgCountPerDevice: Double? = nil, previousAvgCountPerDevice: Double? = nil, countPerDevice: [CountPerDeviceItem]? = nil) {
                self.avgCountPerDevice = avgCountPerDevice
                self.previousAvgCountPerDevice = previousAvgCountPerDevice
                self.countPerDevice = countPerDevice
            }

            private enum CodingKeys: String, CodingKey {
                case avgCountPerDevice = "avg_count_per_device"
                case previousAvgCountPerDevice = "previous_avg_count_per_device"
                case countPerDevice = "count_per_device"
            }
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var versions: [String]?

            public init(start: Date, end: Date? = nil, versions: [String]? = nil) {
                self.start = start
                self.end = end
                self.versions = versions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(versions, forKey: "versions", explode: false, delimiter: "|")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.Events {
    public func eventName(_ eventName: String) -> WithEventName {
        WithEventName(path: "\(path)/\(eventName)")
    }

    public struct WithEventName {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/events/{event_name}`
        public let path: String

        /// Delete the set of Events with the specified event names.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics {
    public var events: Events {
        Events(path: path + "/events")
    }

    public struct Events {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/events`
        public let path: String

        /// Count of active events in the time range ordered by event.
        public func get(parameters: GetParameters) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var versions: [String]?
            public var eventName: [String]?
            public var top: Int?
            public var skip: Int?
            public var inlinecount: Inlinecount?
            public var orderby: String?

            public enum Inlinecount: String, Codable, CaseIterable {
                case allpages
                case `none`
            }

            public init(start: Date, end: Date? = nil, versions: [String]? = nil, eventName: [String]? = nil, top: Int? = nil, skip: Int? = nil, inlinecount: Inlinecount? = nil, orderby: String? = nil) {
                self.start = start
                self.end = end
                self.versions = versions
                self.eventName = eventName
                self.top = top
                self.skip = skip
                self.inlinecount = inlinecount
                self.orderby = orderby
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(versions, forKey: "versions", explode: false, delimiter: "|")
                encoder.encode(eventName, forKey: "event_name", explode: false, delimiter: "|")
                encoder.encode(top, forKey: "$top")
                encoder.encode(skip, forKey: "$skip")
                encoder.encode(inlinecount, forKey: "$inlinecount")
                encoder.encode(orderby, forKey: "$orderby")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics {
    public var eventLogs: EventLogs {
        EventLogs(path: path + "/event_logs")
    }

    public struct EventLogs {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/event_logs`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.EventLogs {
    public func eventName(_ eventName: String) -> WithEventName {
        WithEventName(path: "\(path)/\(eventName)")
    }

    public struct WithEventName {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/event_logs/{event_name}`
        public let path: String

        /// Delete the set of Events with the specified event names.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics {
    public var distribution: Distribution {
        Distribution(path: path + "/distribution")
    }

    public struct Distribution {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/distribution`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.Distribution {
    public var releaseCounts: ReleaseCounts {
        ReleaseCounts(path: path + "/release_counts")
    }

    public struct ReleaseCounts {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/distribution/release_counts`
        public let path: String

        /// Count of total downloads for the provided distribution releases.
        public func post(releases: [PostRequest.Release]) -> Request<PostResponse> {
            .post(path, body: PostRequest(releases: releases))
        }

        public struct PostResponse: Decodable {
            public var total: Int?
            public var counts: [Count]

            public struct Count: Decodable {
                public var releaseID: String
                /// Distribution group queried.
                public var distributionGroup: String?
                /// Count of unique downloads against user id.
                public var uniqueCount: Int
                /// Total count of downloads.
                public var totalCount: Int

                public init(releaseID: String, distributionGroup: String? = nil, uniqueCount: Int, totalCount: Int) {
                    self.releaseID = releaseID
                    self.distributionGroup = distributionGroup
                    self.uniqueCount = uniqueCount
                    self.totalCount = totalCount
                }

                private enum CodingKeys: String, CodingKey {
                    case releaseID = "release_id"
                    case distributionGroup = "distribution_group"
                    case uniqueCount = "unique_count"
                    case totalCount = "total_count"
                }
            }

            public init(total: Int? = nil, counts: [Count]) {
                self.total = total
                self.counts = counts
            }
        }

        public struct PostRequest: Encodable {
            public var releases: [Release]

            public struct Release: Encodable {
                /// Distribution group Id.
                public var distributionGroup: String?

                public init(distributionGroup: String? = nil) {
                    self.distributionGroup = distributionGroup
                }

                private enum CodingKeys: String, CodingKey {
                    case distributionGroup = "distribution_group"
                }
            }

            public init(releases: [Release]) {
                self.releases = releases
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics {
    public var crashfreeDevicePercentages: CrashfreeDevicePercentages {
        CrashfreeDevicePercentages(path: path + "/crashfree_device_percentages")
    }

    public struct CrashfreeDevicePercentages {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/crashfree_device_percentages`
        public let path: String

        /// Percentage of crash-free device by day in the time range based on the selected versions. Api will return -1 if crash devices is greater than active devices.
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// Average percentage.
            public var averagePercentage: Double?
            /// The crash-free percentage per day.
            public var dailyPercentages: [DailyPercentage]?

            public struct DailyPercentage: Decodable {
                /// The ISO 8601 datetime.
                public var datetime: String?
                /// Percentage of the object.
                public var percentage: Double?

                public init(datetime: String? = nil, percentage: Double? = nil) {
                    self.datetime = datetime
                    self.percentage = percentage
                }
            }

            public init(averagePercentage: Double? = nil, dailyPercentages: [DailyPercentage]? = nil) {
                self.averagePercentage = averagePercentage
                self.dailyPercentages = dailyPercentages
            }

            private enum CodingKeys: String, CodingKey {
                case averagePercentage = "average_percentage"
                case dailyPercentages = "daily_percentages"
            }
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var version: String

            public init(start: Date, end: Date? = nil, version: String) {
                self.start = start
                self.end = end
                self.version = version
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(version, forKey: "version")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.CrashGroups {
    public func crashGroupID(_ crashGroupID: String) -> WithCrashGroupID {
        WithCrashGroupID(path: "\(path)/\(crashGroupID)")
    }

    public struct WithCrashGroupID {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/crash_groups/{crash_group_id}`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.CrashGroups.WithCrashGroupID {
    public var overall: Overall {
        Overall(path: path + "/overall")
    }

    public struct Overall {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/crash_groups/{crash_group_id}/overall`
        public let path: String

        /// Available for UWP apps only.
        ///
        /// Overall crashes and affected users count of the selected crash group with selected version. Available for UWP apps only.
        @available(*, deprecated, message: "Deprecated")
        public func get(version: String) -> Request<GetResponse> {
            .get(path, query: [("version", version)])
        }

        public struct GetResponse: Decodable {
            public var crashCount: Int?
            public var deviceCount: Int?

            public init(crashCount: Int? = nil, deviceCount: Int? = nil) {
                self.crashCount = crashCount
                self.deviceCount = deviceCount
            }

            private enum CodingKeys: String, CodingKey {
                case crashCount = "crash_count"
                case deviceCount = "device_count"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.CrashGroups.WithCrashGroupID {
    public var operatingSystems: OperatingSystems {
        OperatingSystems(path: path + "/operating_systems")
    }

    public struct OperatingSystems {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/crash_groups/{crash_group_id}/operating_systems`
        public let path: String

        /// Available for UWP apps only.
        ///
        /// Top OSes of the selected crash group with selected version. Available for UWP apps only.
        @available(*, deprecated, message: "Deprecated")
        public func get(version: String, top: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(version, top))
        }

        public struct GetResponse: Decodable {
            public var crashCount: Int?
            public var operatingSystems: [OperatingSystem]?

            public struct OperatingSystem: Decodable {
                /// OS name.
                public var operatingSystemName: String?
                /// Count of OS.
                public var crashCount: Int?

                public init(operatingSystemName: String? = nil, crashCount: Int? = nil) {
                    self.operatingSystemName = operatingSystemName
                    self.crashCount = crashCount
                }

                private enum CodingKeys: String, CodingKey {
                    case operatingSystemName = "operating_system_name"
                    case crashCount = "crash_count"
                }
            }

            public init(crashCount: Int? = nil, operatingSystems: [OperatingSystem]? = nil) {
                self.crashCount = crashCount
                self.operatingSystems = operatingSystems
            }

            private enum CodingKeys: String, CodingKey {
                case crashCount = "crash_count"
                case operatingSystems = "operating_systems"
            }
        }

        private func makeGetQuery(_ version: String, _ top: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(version, forKey: "version")
            encoder.encode(top, forKey: "$top")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.CrashGroups.WithCrashGroupID {
    public var models: Models {
        Models(path: path + "/models")
    }

    public struct Models {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/crash_groups/{crash_group_id}/models`
        public let path: String

        /// Available for UWP apps only.
        ///
        /// Top models of the selected crash group with selected version. Available for UWP apps only.
        @available(*, deprecated, message: "Deprecated")
        public func get(version: String, top: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(version, top))
        }

        public struct GetResponse: Decodable {
            public var crashCount: Int?
            public var models: [Model]?

            public struct Model: Decodable {
                /// Model's name.
                public var modelName: String?
                /// Count of model.
                public var crashCount: Int?

                public init(modelName: String? = nil, crashCount: Int? = nil) {
                    self.modelName = modelName
                    self.crashCount = crashCount
                }

                private enum CodingKeys: String, CodingKey {
                    case modelName = "model_name"
                    case crashCount = "crash_count"
                }
            }

            public init(crashCount: Int? = nil, models: [Model]? = nil) {
                self.crashCount = crashCount
                self.models = models
            }

            private enum CodingKeys: String, CodingKey {
                case crashCount = "crash_count"
                case models
            }
        }

        private func makeGetQuery(_ version: String, _ top: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(version, forKey: "version")
            encoder.encode(top, forKey: "$top")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.CrashGroups.WithCrashGroupID {
    public var crashCounts: CrashCounts {
        CrashCounts(path: path + "/crash_counts")
    }

    public struct CrashCounts {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/crash_groups/{crash_group_id}/crash_counts`
        public let path: String

        /// Available for UWP apps only.
        ///
        /// Count of crashes by day in the time range of the selected crash group with selected version. Available for UWP apps only.
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// Total crash count.
            public var count: Int?
            /// The total crash count for day.
            public var crashes: [Crash]?

            public struct Crash: Decodable {
                /// The ISO 8601 datetime.
                public var datetime: String?
                /// Count of the object.
                public var count: Int?

                public init(datetime: String? = nil, count: Int? = nil) {
                    self.datetime = datetime
                    self.count = count
                }
            }

            public init(count: Int? = nil, crashes: [Crash]? = nil) {
                self.count = count
                self.crashes = crashes
            }
        }

        public struct GetParameters {
            public var version: String
            public var start: Date
            public var end: Date?

            public init(version: String, start: Date, end: Date? = nil) {
                self.version = version
                self.start = start
                self.end = end
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(version, forKey: "version")
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics {
    public var crashGroups: CrashGroups {
        CrashGroups(path: path + "/crash_groups")
    }

    public struct CrashGroups {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/crash_groups`
        public let path: String

        /// Overall crashes and affected users count of the selected crash groups with selected versions.
        public func post(crashGroups: [PostRequest.CrashGroup]) -> Request<[PostResponseItem]> {
            .post(path, body: PostRequest(crashGroups: crashGroups))
        }

        public struct PostResponseItem: Decodable {
            public var crashGroupID: String?
            public var appVersion: String?
            public var overall: Overall?

            public struct Overall: Decodable {
                public var crashCount: Int?
                public var deviceCount: Int?

                public init(crashCount: Int? = nil, deviceCount: Int? = nil) {
                    self.crashCount = crashCount
                    self.deviceCount = deviceCount
                }

                private enum CodingKeys: String, CodingKey {
                    case crashCount = "crash_count"
                    case deviceCount = "device_count"
                }
            }

            public init(crashGroupID: String? = nil, appVersion: String? = nil, overall: Overall? = nil) {
                self.crashGroupID = crashGroupID
                self.appVersion = appVersion
                self.overall = overall
            }

            private enum CodingKeys: String, CodingKey {
                case crashGroupID = "crash_group_id"
                case appVersion = "app_version"
                case overall
            }
        }

        public struct PostRequest: Encodable {
            public var crashGroups: [CrashGroup]

            public struct CrashGroup: Encodable {
                public var crashGroupID: String?
                public var appVersion: String?

                public init(crashGroupID: String? = nil, appVersion: String? = nil) {
                    self.crashGroupID = crashGroupID
                    self.appVersion = appVersion
                }

                private enum CodingKeys: String, CodingKey {
                    case crashGroupID = "crash_group_id"
                    case appVersion = "app_version"
                }
            }

            public init(crashGroups: [CrashGroup]) {
                self.crashGroups = crashGroups
            }

            private enum CodingKeys: String, CodingKey {
                case crashGroups = "crash_groups"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics {
    public var crashCounts: CrashCounts {
        CrashCounts(path: path + "/crash_counts")
    }

    public struct CrashCounts {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/crash_counts`
        public let path: String

        /// Available for UWP apps only.
        ///
        /// Count of crashes by day in the time range based the selected versions. Available for UWP apps only.
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// Total crash count.
            public var count: Int?
            /// The total crash count for day.
            public var crashes: [Crash]?

            public struct Crash: Decodable {
                /// The ISO 8601 datetime.
                public var datetime: String?
                /// Count of the object.
                public var count: Int?

                public init(datetime: String? = nil, count: Int? = nil) {
                    self.datetime = datetime
                    self.count = count
                }
            }

            public init(count: Int? = nil, crashes: [Crash]? = nil) {
                self.count = count
                self.crashes = crashes
            }
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var versions: [String]?

            public init(start: Date, end: Date? = nil, versions: [String]? = nil) {
                self.start = start
                self.end = end
                self.versions = versions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(versions, forKey: "versions", explode: false, delimiter: "|")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.Audiences {
    public func audienceName(_ audienceName: String) -> WithAudienceName {
        WithAudienceName(path: "\(path)/\(audienceName)")
    }

    public struct WithAudienceName {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/{audience_name}`
        public let path: String

        /// Gets audience definition.
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Creates or updates audience definition.
        public func put(_ body: PutRequest) -> Request<[String: AnyJSON]> {
            .put(path, body: body)
        }

        /// Audience definition.
        public struct PutRequest: Encodable {
            /// Audience description.
            public var description: String?
            /// Audience definition in OData format.
            public var definition: String
            public var isEnabled: Bool
            /// Custom properties used in the definition.
            public var customProperties: [String: CustomProperty]?

            public enum CustomProperty: String, Codable, CaseIterable {
                case string
                case number
                case boolean
                case dateTime = "date_time"
            }

            public init(description: String? = nil, definition: String, isEnabled: Bool? = nil, customProperties: [String: CustomProperty]? = nil) {
                self.description = description
                self.definition = definition
                self.isEnabled = isEnabled ?? true
                self.customProperties = customProperties
            }

            private enum CodingKeys: String, CodingKey {
                case description
                case definition
                case isEnabled = "enabled"
                case customProperties = "custom_properties"
            }
        }

        /// Deletes audience definition.
        public var delete: Request<Void> {
            .delete(path)
        }

        /// Returns whether audience definition exists.
        public var head: Request<Void> {
            .head(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.Audiences {
    public var metadata: Metadata {
        Metadata(path: path + "/metadata")
    }

    public struct Metadata {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/metadata`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.Audiences.Metadata.DeviceProperties {
    public func propertyName(_ propertyName: String) -> WithPropertyName {
        WithPropertyName(path: "\(path)/\(propertyName)")
    }

    public struct WithPropertyName {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/metadata/device_properties/{property_name}`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.Audiences.Metadata.DeviceProperties.WithPropertyName {
    public var values: Values {
        Values(path: path + "/values")
    }

    public struct Values {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/metadata/device_properties/{property_name}/values`
        public let path: String

        /// Get list of device property values.
        public func get(contains: String? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(contains))
        }

        private func makeGetQuery(_ contains: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(contains, forKey: "contains")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.Audiences.Metadata {
    public var deviceProperties: DeviceProperties {
        DeviceProperties(path: path + "/device_properties")
    }

    public struct DeviceProperties {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/metadata/device_properties`
        public let path: String

        /// Get list of device properties.
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.Audiences.Metadata {
    public var customProperties: CustomProperties {
        CustomProperties(path: path + "/custom_properties")
    }

    public struct CustomProperties {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/metadata/custom_properties`
        public let path: String

        /// Get list of custom properties.
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.Audiences {
    public var definition: Definition {
        Definition(path: path + "/definition")
    }

    public struct Definition {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/definition`
        public let path: String
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics.Audiences.Definition {
    public var test: Test {
        Test(path: path + "/test")
    }

    public struct Test {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/definition/test`
        public let path: String

        /// Tests audience definition.
        public func post(_ body: PostRequest) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        /// Audience definition.
        public struct PostRequest: Encodable {
            /// Audience description.
            public var description: String?
            /// Audience definition in OData format.
            public var definition: String
            public var isEnabled: Bool
            /// Custom properties used in the definition.
            public var customProperties: [String: CustomProperty]?

            public enum CustomProperty: String, Codable, CaseIterable {
                case string
                case number
                case boolean
                case dateTime = "date_time"
            }

            public init(description: String? = nil, definition: String, isEnabled: Bool? = nil, customProperties: [String: CustomProperty]? = nil) {
                self.description = description
                self.definition = definition
                self.isEnabled = isEnabled ?? true
                self.customProperties = customProperties
            }

            private enum CodingKeys: String, CodingKey {
                case description
                case definition
                case isEnabled = "enabled"
                case customProperties = "custom_properties"
            }
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics {
    public var audiences: Audiences {
        Audiences(path: path + "/audiences")
    }

    public struct Audiences {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/audiences`
        public let path: String

        /// Get list of audiences.
        public func get(isIncludeDisabled: Bool? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(isIncludeDisabled))
        }

        private func makeGetQuery(_ isIncludeDisabled: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isIncludeDisabled, forKey: "include_disabled")
            return encoder.items
        }
    }
}

extension Paths.Apps.WithOwnerName.WithAppName.Analytics {
    public var activeDeviceCounts: ActiveDeviceCounts {
        ActiveDeviceCounts(path: path + "/active_device_counts")
    }

    public struct ActiveDeviceCounts {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}/analytics/active_device_counts`
        public let path: String

        /// Count of active devices by interval in the time range.
        public func get(parameters: GetParameters) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var start: Date
            public var end: Date?
            public var versions: [String]?
            public var appBuild: String

            public init(start: Date, end: Date? = nil, versions: [String]? = nil, appBuild: String) {
                self.start = start
                self.end = end
                self.versions = versions
                self.appBuild = appBuild
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(versions, forKey: "versions", explode: false, delimiter: "|")
                encoder.encode(appBuild, forKey: "app_build")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.WithOwnerName {
    public func appName(_ appName: String) -> WithAppName {
        WithAppName(path: "\(path)/\(appName)")
    }

    public struct WithAppName {
        /// Path: `/v0.1/apps/{owner_name}/{app_name}`
        public let path: String

        /// Return a specific app with the given app name which belongs to the given owner.
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Partially updates a single app
        public func patch(_ body: PatchRequest? = nil) -> Request<[String: AnyJSON]> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// A short text describing the app
            public var description: String?
            /// The display name of the app
            public var displayName: String?
            /// A one-word descriptive release type value that starts with a capital letter but is otherwise lowercase
            public var releaseType: String?
            /// The name of the app used in URLs
            public var name: String?
            /// The string representation of the URL pointing to the app's icon
            public var iconURL: String?
            /// The uuid for the icon's asset id from ACFUS
            public var iconAssetID: String?

            public init(description: String? = nil, displayName: String? = nil, releaseType: String? = nil, name: String? = nil, iconURL: String? = nil, iconAssetID: String? = nil) {
                self.description = description
                self.displayName = displayName
                self.releaseType = releaseType
                self.name = name
                self.iconURL = iconURL
                self.iconAssetID = iconAssetID
            }

            private enum CodingKeys: String, CodingKey {
                case description
                case displayName = "display_name"
                case releaseType = "release_type"
                case name
                case iconURL = "icon_url"
                case iconAssetID = "icon_asset_id"
            }
        }

        /// Delete an app
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var apps: Apps {
        Apps(path: "/v0.1/apps")
    }

    public struct Apps {
        /// Path: `/v0.1/apps`
        public let path: String

        /// Returns a list of apps
        public func get(orderBy: OrderBy? = nil) -> Request<[GetResponseItem]> {
            .get(path, query: makeGetQuery(orderBy))
        }

        public struct GetResponseItem: Decodable {
            /// The unique ID (UUID) of the app
            public var id: String
            /// The description of the app
            public var description: String?
            /// The display name of the app
            public var displayName: String
            /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
            public var releaseType: String?
            /// The string representation of the URL pointing to the app's icon
            public var iconURL: String?
            /// The string representation of the source of the app's icon
            public var iconSource: String?
            /// The name of the app used in URLs
            public var name: String
            /// The OS the app will be running on
            public var os: Os
            /// The information about the app's owner
            public var owner: Owner
            /// A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics
            public var appSecret: String?
            public var azureSubscription: AzureSubscription?
            /// The platform of the app
            public var platform: Platform?
            /// The creation origin of this app
            public var origin: Origin?
            /// The created date of this app
            public var createdAt: String?
            /// The last updated date of this app
            public var updatedAt: String?
            /// The permissions of the calling user
            public var memberPermissions: [MemberPermission]?

            /// The OS the app will be running on
            public enum Os: String, Codable, CaseIterable {
                case android = "Android"
                case iOS
                case macOS
                case tizen = "Tizen"
                case tvOS
                case windows = "Windows"
                case linux = "Linux"
                case custom = "Custom"
            }

            /// The information about the app's owner
            public struct Owner: Decodable {
                /// The unique id (UUID) of the owner
                public var id: String
                /// The avatar URL of the owner
                public var avatarURL: String?
                /// The owner's display name
                public var displayName: String
                /// The owner's email address
                public var email: String?
                /// The unique name that used to identify the owner
                public var name: String
                /// The owner type. Can either be 'org' or 'user'
                public var type: `Type`

                /// The owner type. Can either be 'org' or 'user'
                public enum `Type`: String, Codable, CaseIterable {
                    case org
                    case user
                }

                public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
                    self.id = id
                    self.avatarURL = avatarURL
                    self.displayName = displayName
                    self.email = email
                    self.name = name
                    self.type = type
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case avatarURL = "avatar_url"
                    case displayName = "display_name"
                    case email
                    case name
                    case type
                }
            }

            public struct AzureSubscription: Decodable {
                /// The azure subscription id
                public var subscriptionID: String
                /// The tenant id of the azure subscription belongs to
                public var tenantID: String
                /// The name of the azure subscription
                public var subscriptionName: String
                /// If the subscription is used for billing
                public var isBilling: Bool?
                /// If the subscription can be used for billing
                public var isBillable: Bool?
                /// If the subscription is internal Microsoft subscription
                public var isMicrosoftInternal: Bool?

                public init(subscriptionID: String, tenantID: String, subscriptionName: String, isBilling: Bool? = nil, isBillable: Bool? = nil, isMicrosoftInternal: Bool? = nil) {
                    self.subscriptionID = subscriptionID
                    self.tenantID = tenantID
                    self.subscriptionName = subscriptionName
                    self.isBilling = isBilling
                    self.isBillable = isBillable
                    self.isMicrosoftInternal = isMicrosoftInternal
                }

                private enum CodingKeys: String, CodingKey {
                    case subscriptionID = "subscription_id"
                    case tenantID = "tenant_id"
                    case subscriptionName = "subscription_name"
                    case isBilling = "is_billing"
                    case isBillable = "is_billable"
                    case isMicrosoftInternal = "is_microsoft_internal"
                }
            }

            /// The platform of the app
            public enum Platform: String, Codable, CaseIterable {
                case java = "Java"
                case objectiveCSwift = "Objective-C-Swift"
                case uwp = "UWP"
                case cordova = "Cordova"
                case reactNative = "React-Native"
                case unity = "Unity"
                case electron = "Electron"
                case xamarin = "Xamarin"
                case wpf = "WPF"
                case winForms = "WinForms"
                case unknown = "Unknown"
                case custom = "Custom"
            }

            /// The creation origin of this app
            public enum Origin: String, Codable, CaseIterable {
                case appcenter
                case hockeyapp
                case codepush
            }

            public enum MemberPermission: String, Codable, CaseIterable {
                case manager
                case developer
                case viewer
                case tester
            }

            public init(id: String, description: String? = nil, displayName: String, releaseType: String? = nil, iconURL: String? = nil, iconSource: String? = nil, name: String, os: Os, owner: Owner, appSecret: String? = nil, azureSubscription: AzureSubscription? = nil, platform: Platform? = nil, origin: Origin? = nil, createdAt: String? = nil, updatedAt: String? = nil, memberPermissions: [MemberPermission]? = nil) {
                self.id = id
                self.description = description
                self.displayName = displayName
                self.releaseType = releaseType
                self.iconURL = iconURL
                self.iconSource = iconSource
                self.name = name
                self.os = os
                self.owner = owner
                self.appSecret = appSecret
                self.azureSubscription = azureSubscription
                self.platform = platform
                self.origin = origin
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.memberPermissions = memberPermissions
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decode(String.self, forKey: "id")
                self.description = try values.decodeIfPresent(String.self, forKey: "description")
                self.displayName = try values.decode(String.self, forKey: "display_name")
                self.releaseType = try values.decodeIfPresent(String.self, forKey: "release_type")
                self.iconURL = try values.decodeIfPresent(String.self, forKey: "icon_url")
                self.iconSource = try values.decodeIfPresent(String.self, forKey: "icon_source")
                self.name = try values.decode(String.self, forKey: "name")
                self.os = try Os(from: decoder)
                self.owner = try Owner(from: decoder)
                self.appSecret = try values.decodeIfPresent(String.self, forKey: "app_secret")
                self.azureSubscription = try AzureSubscription(from: decoder)
                self.platform = try Platform(from: decoder)
                self.origin = try Origin(from: decoder)
                self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
                self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
                self.memberPermissions = try values.decodeIfPresent([MemberPermission].self, forKey: "member_permissions")
            }
        }

        private func makeGetQuery(_ orderBy: OrderBy?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(orderBy, forKey: "$orderBy")
            return encoder.items
        }

        public enum OrderBy: String, Codable, CaseIterable {
            case displayName = "display_name"
            case name
        }

        /// Creates a new app and returns it to the caller
        public func post(_ body: PostRequest) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// A short text describing the app
            public var description: String?
            /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
            public var releaseType: String?
            /// The descriptive name of the app. This can contain any characters
            public var displayName: String
            /// The name of the app used in URLs
            public var name: String?
            /// The OS the app will be running on
            public var os: Os
            /// The platform of the app
            public var platform: Platform

            /// The OS the app will be running on
            public enum Os: String, Codable, CaseIterable {
                case android = "Android"
                case iOS
                case macOS
                case tizen = "Tizen"
                case tvOS
                case windows = "Windows"
                case linux = "Linux"
                case custom = "Custom"
            }

            /// The platform of the app
            public enum Platform: String, Codable, CaseIterable {
                case java = "Java"
                case objectiveCSwift = "Objective-C-Swift"
                case uwp = "UWP"
                case cordova = "Cordova"
                case reactNative = "React-Native"
                case xamarin = "Xamarin"
                case unity = "Unity"
                case electron = "Electron"
                case wpf = "WPF"
                case winForms = "WinForms"
                case custom = "Custom"
            }

            public init(description: String? = nil, releaseType: String? = nil, displayName: String, name: String? = nil, os: Os, platform: Platform) {
                self.description = description
                self.releaseType = releaseType
                self.displayName = displayName
                self.name = name
                self.os = os
                self.platform = platform
            }

            private enum CodingKeys: String, CodingKey {
                case description
                case releaseType = "release_type"
                case displayName = "display_name"
                case name
                case os
                case platform
            }
        }
    }
}

extension Paths.APITokens {
    public func apiTokenID(_ apiTokenID: String) -> WithAPITokenID {
        WithAPITokenID(path: "\(path)/\(apiTokenID)")
    }

    public struct WithAPITokenID {
        /// Path: `/v0.1/api_tokens/{api_token_id}`
        public let path: String

        /// Delete the user api_token object with the specific id
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var apiTokens: APITokens {
        APITokens(path: "/v0.1/api_tokens")
    }

    public struct APITokens {
        /// Path: `/v0.1/api_tokens`
        public let path: String

        /// Returns api tokens for the authenticated user
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// The unique id (UUID) of the api token
            public var id: String
            /// The description of the token
            public var description: String?
            /// The scope for this token.
            public var scope: [ScopeItem]?
            /// The creation time
            public var createdAt: String

            public enum ScopeItem: String, Codable, CaseIterable {
                case all
                case viewer
            }

            public init(id: String, description: String? = nil, scope: [ScopeItem]? = nil, createdAt: String) {
                self.id = id
                self.description = description
                self.scope = scope
                self.createdAt = createdAt
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case description
                case scope
                case createdAt = "created_at"
            }
        }

        /// Creates a new User API token
        public func post(_ body: PostRequest? = nil) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The description of the token
            public var description: String?
            /// The scope for this token.
            public var scope: [ScopeItem]?

            public enum ScopeItem: String, Codable, CaseIterable {
                case all
                case viewer
            }

            public init(description: String? = nil, scope: [ScopeItem]? = nil) {
                self.description = description
                self.scope = scope
            }
        }
    }
}

extension Paths {
    public static var administeredOrgs: AdministeredOrgs {
        AdministeredOrgs(path: "/v0.1/administeredOrgs")
    }

    public struct AdministeredOrgs {
        /// Path: `/v0.1/administeredOrgs`
        public let path: String

        /// Returns a list organizations in which the requesting user is an admin
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var organizations: Organizations

            public struct Organizations: Decodable {
                /// The internal unique id (UUID) of the organization.
                public var id: String
                /// The display name of the organization
                public var displayName: String
                /// The slug name of the organization
                public var name: String
                /// The URL to a user-uploaded Avatar image
                public var avatarURL: String?
                /// The creation origin of this organization
                public var origin: Origin
                /// The creation date of this organization
                public var createdAt: String
                /// The date the organization was last updated at
                public var updatedAt: String

                /// The creation origin of this organization
                public enum Origin: String, Codable, CaseIterable {
                    case appcenter
                    case hockeyapp
                }

                public init(id: String, displayName: String, name: String, avatarURL: String? = nil, origin: Origin, createdAt: String, updatedAt: String) {
                    self.id = id
                    self.displayName = displayName
                    self.name = name
                    self.avatarURL = avatarURL
                    self.origin = origin
                    self.createdAt = createdAt
                    self.updatedAt = updatedAt
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case displayName = "display_name"
                    case name
                    case avatarURL = "avatar_url"
                    case origin
                    case createdAt = "created_at"
                    case updatedAt = "updated_at"
                }
            }

            public init(organizations: Organizations) {
                self.organizations = organizations
            }
        }
    }
}

extension Paths {
    public static var account: Account {
        Account(path: "/v0.1/account")
    }

    public struct Account {
        /// Path: `/v0.1/account`
        public let path: String
    }
}

extension Paths.Account {
    public var test: Test {
        Test(path: path + "/test")
    }

    public struct Test {
        /// Path: `/v0.1/account/test`
        public let path: String
    }
}

extension Paths.Account.Test.Export {
    public var featureFlags: FeatureFlags {
        FeatureFlags(path: path + "/featureFlags")
    }

    public struct FeatureFlags {
        /// Path: `/v0.1/account/test/export/featureFlags`
        public let path: String

        /// Lists feature flag data
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var name: String?
            public var targetID: String?

            public init(name: String? = nil, targetID: String? = nil) {
                self.name = name
                self.targetID = targetID
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case targetID = "target_id"
            }
        }
    }
}

extension Paths.Account.Test.Export {
    public var accounts: Accounts {
        Accounts(path: path + "/accounts")
    }

    public struct Accounts {
        /// Path: `/v0.1/account/test/export/accounts`
        public let path: String

        /// Lists account data
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var id: String?

            public init(id: String? = nil) {
                self.id = id
            }
        }
    }
}

extension Paths.Account.Test {
    public var export: Export {
        Export(path: path + "/export")
    }

    public struct Export {
        /// Path: `/v0.1/account/test/export`
        public let path: String

        /// Lists all the endpoints available for Test accounts data
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var resources: [Resource]?

            public struct Resource: Decodable {
                public var rel: String?
                public var path: String?

                public init(rel: String? = nil, path: String? = nil) {
                    self.rel = rel
                    self.path = path
                }
            }

            public init(resources: [Resource]? = nil) {
                self.resources = resources
            }
        }
    }
}

public enum Paths {}
