// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

public struct GetInAppUpdateTokenResponse: Codable {
    /// The api token generated will not be accessible again
    public var token: String

    public init(token: String) {
        self.token = token
    }
}

public struct APITokensCreateResponse: Codable {
    /// The unique id (UUID) of the api token
    public var id: String
    /// The api token generated will not be accessible again
    public var apiToken: String
    /// The description of the token
    public var description: String?
    /// The scope for this token.
    public var scope: [ScopeItem]?
    /// The creation time
    public var createdAt: String

    public enum ScopeItem: String, Codable, CaseIterable {
        case all
        case viewer
    }

    public init(id: String, apiToken: String, description: String? = nil, scope: [ScopeItem]? = nil, createdAt: String) {
        self.id = id
        self.apiToken = apiToken
        self.description = description
        self.scope = scope
        self.createdAt = createdAt
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case apiToken = "api_token"
        case description
        case scope
        case createdAt = "created_at"
    }
}

public struct APITokensCreateRequest: Codable {
    /// The description of the token
    public var description: String?
    /// The scope for this token.
    public var scope: [ScopeItem]?

    public enum ScopeItem: String, Codable, CaseIterable {
        case all
        case viewer
    }

    public init(description: String? = nil, scope: [ScopeItem]? = nil) {
        self.description = description
        self.scope = scope
    }
}

public struct APITokensGetResponse: Codable {
    /// The unique id (UUID) of the api token
    public var id: String
    /// The description of the token
    public var description: String?
    /// The scope for this token.
    public var scope: [ScopeItem]?
    /// The creation time
    public var createdAt: String

    public enum ScopeItem: String, Codable, CaseIterable {
        case all
        case viewer
    }

    public init(id: String, description: String? = nil, scope: [ScopeItem]? = nil, createdAt: String) {
        self.id = id
        self.description = description
        self.scope = scope
        self.createdAt = createdAt
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case description
        case scope
        case createdAt = "created_at"
    }
}

public struct Status: Codable {
    public var status: String

    public init(status: String) {
        self.status = status
    }
}

public struct Failure: Codable {
    public var message: String

    public init(message: String) {
        self.message = message
    }
}

public struct ErrorResponse: Codable {
    public var error: Error

    public struct Error: Codable {
        public var code: Code
        public var message: String

        public enum Code: String, Codable, CaseIterable {
            case badRequest = "BadRequest"
            case conflict = "Conflict"
            case notAcceptable = "NotAcceptable"
            case notFound = "NotFound"
            case internalServerError = "InternalServerError"
            case unauthorized = "Unauthorized"
            case tooManyRequests = "TooManyRequests"
        }

        public init(code: Code, message: String) {
            self.code = code
            self.message = message
        }
    }

    public init(error: Error) {
        self.error = error
    }
}

public struct ErrorDetails: Codable {
    public var code: Code
    public var message: String

    public enum Code: String, Codable, CaseIterable {
        case badRequest = "BadRequest"
        case conflict = "Conflict"
        case notAcceptable = "NotAcceptable"
        case notFound = "NotFound"
        case internalServerError = "InternalServerError"
        case unauthorized = "Unauthorized"
        case tooManyRequests = "TooManyRequests"
    }

    public init(code: Code, message: String) {
        self.code = code
        self.message = message
    }
}

public struct SuccessResponse: Codable {
    public var message: String

    public init(message: String) {
        self.message = message
    }
}

public struct APITokenResponsev2: Codable {
    /// The unique id (UUID) of the api token
    public var id: String
    /// The creation time
    public var createdAt: String
    /// The token's scope. A list of allowed roles.
    public var scope: [ScopeItem]?
    /// The encrypted value of a token. This value will only be returned for token of type in_app_update.
    public var encryptedToken: String?
    /// The description of the token
    public var description: String?

    public enum ScopeItem: String, Codable, CaseIterable {
        case all
        case inAppUpdate = "in_app_update"
        case viewer
    }

    public init(id: String, createdAt: String, scope: [ScopeItem]? = nil, encryptedToken: String? = nil, description: String? = nil) {
        self.id = id
        self.createdAt = createdAt
        self.scope = scope
        self.encryptedToken = encryptedToken
        self.description = description
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case createdAt = "created_at"
        case scope
        case encryptedToken = "encrypted_token"
        case description
    }
}

public struct UserDataResponse: Codable {
    /// The unique id (UUID) of the user
    public var id: String?
    /// The display name of the user
    public var displayName: String?
    /// The name of the user
    public var name: String?
    /// The url at which the user's avatar can be reached
    public var avatarURL: String?

    public init(id: String? = nil, displayName: String? = nil, name: String? = nil, avatarURL: String? = nil) {
        self.id = id
        self.displayName = displayName
        self.name = name
        self.avatarURL = avatarURL
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case displayName = "display_name"
        case name
        case avatarURL = "avatar_url"
    }
}

public struct UserProfileResponsev2: Codable {
    /// The unique id (UUID) of the user
    public var id: String
    /// The avatar URL of the user
    public var avatarURL: String?
    /// User is required to send an old password in order to change the password.
    public var canChangePassword: Bool?
    /// The full name of the user. Might for example be first and last name
    public var displayName: String
    /// The email address of the user
    public var email: String
    /// The unique name that is used to identify the user.
    public var name: String
    /// The created date of the user
    public var createdAt: String?
    /// The date in the future when the user should be checked again for NPS eligibility
    public var nextNpsSurveyDate: String?
    /// The creation origin of this user
    public var origin: Origin
    /// The feature flags that are enabled for this user
    public var featureFlags: [String]?
    /// The new admin_role
    public var adminRole: AdminRole?
    /// The user's settings
    public var settings: [String: AnyJSON]?
    /// The session hash of the user
    public var sessionHash: String?

    /// The creation origin of this user
    public enum Origin: String, Codable, CaseIterable {
        case appcenter
        case hockeyapp
        case codepush
    }

    /// The new admin_role
    public enum AdminRole: String, Codable, CaseIterable {
        case superAdmin
        case admin
        case devOps
        case customerSupport
        case notAdmin
    }

    public init(id: String, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String, email: String, name: String, createdAt: String? = nil, nextNpsSurveyDate: String? = nil, origin: Origin, featureFlags: [String]? = nil, adminRole: AdminRole? = nil, settings: [String: AnyJSON]? = nil, sessionHash: String? = nil) {
        self.id = id
        self.avatarURL = avatarURL
        self.canChangePassword = canChangePassword
        self.displayName = displayName
        self.email = email
        self.name = name
        self.createdAt = createdAt
        self.nextNpsSurveyDate = nextNpsSurveyDate
        self.origin = origin
        self.featureFlags = featureFlags
        self.adminRole = adminRole
        self.settings = settings
        self.sessionHash = sessionHash
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case avatarURL = "avatar_url"
        case canChangePassword = "can_change_password"
        case displayName = "display_name"
        case email
        case name
        case createdAt = "created_at"
        case nextNpsSurveyDate = "next_nps_survey_date"
        case origin
        case featureFlags = "feature_flags"
        case adminRole = "admin_role"
        case settings
        case sessionHash = "session_hash"
    }
}

public struct ErrorDetailsv2: Codable {
    public var code: Code
    public var message: String

    public enum Code: String, Codable, CaseIterable {
        case badRequest = "BadRequest"
        case conflict = "Conflict"
        case notAcceptable = "NotAcceptable"
        case notFound = "NotFound"
        case internalServerError = "InternalServerError"
        case unauthorized = "Unauthorized"
    }

    public init(code: Code, message: String) {
        self.code = code
        self.message = message
    }
}

public struct ErrorResponsev2: Codable {
    public var error: Error

    public struct Error: Codable {
        public var code: Code
        public var message: String

        public enum Code: String, Codable, CaseIterable {
            case badRequest = "BadRequest"
            case conflict = "Conflict"
            case notAcceptable = "NotAcceptable"
            case notFound = "NotFound"
            case internalServerError = "InternalServerError"
            case unauthorized = "Unauthorized"
        }

        public init(code: Code, message: String) {
            self.code = code
            self.message = message
        }
    }

    public init(error: Error) {
        self.error = error
    }
}

public struct OptimizelyUserMetaDataResponse: Codable {
    public var userID: String?
    public var metadata: [String: AnyJSON]?

    public init(userID: String? = nil, metadata: [String: AnyJSON]? = nil) {
        self.userID = userID
        self.metadata = metadata
    }

    private enum CodingKeys: String, CodingKey {
        case userID = "userId"
        case metadata
    }
}

public struct OptimizelyUserMetaDataRequest: Codable {
    public var metadata: [String: AnyJSON]?

    public init(metadata: [String: AnyJSON]? = nil) {
        self.metadata = metadata
    }
}

public struct AADTenantAddRequest: Codable {
    /// The user wanting to add this tenant to the organization, must be an admin of the organization
    public var userID: String
    /// The AAD tenant id
    public var aadTenantID: String
    /// The name of the AAD Tenant
    public var displayName: String

    public init(userID: String, aadTenantID: String, displayName: String) {
        self.userID = userID
        self.aadTenantID = aadTenantID
        self.displayName = displayName
    }

    private enum CodingKeys: String, CodingKey {
        case userID = "user_id"
        case aadTenantID = "aad_tenant_id"
        case displayName = "display_name"
    }
}

public struct AADTenantResponse: Codable {
    /// The AAD tenant id
    public var aadTenantID: String
    /// The name of the AAD Tenant
    public var displayName: String

    public init(aadTenantID: String, displayName: String) {
        self.aadTenantID = aadTenantID
        self.displayName = displayName
    }

    private enum CodingKeys: String, CodingKey {
        case aadTenantID = "aad_tenant_id"
        case displayName = "display_name"
    }
}

public struct AddAppTesterRequest: Codable {
    /// The user ID of the tester that needs to be added
    public var userID: String
    /// The ID of the release the user was added to
    public var releaseID: Int

    public init(userID: String, releaseID: Int) {
        self.userID = userID
        self.releaseID = releaseID
    }

    private enum CodingKeys: String, CodingKey {
        case userID = "user_id"
        case releaseID = "release_id"
    }
}

public struct AddAppTesterResponse: Codable {
    /// The user ID of the tester that needs to be added
    public var userID: String
    /// The ID of the release the user was added to
    public var releaseID: Int

    public init(userID: String, releaseID: Int) {
        self.userID = userID
        self.releaseID = releaseID
    }

    private enum CodingKeys: String, CodingKey {
        case userID = "user_id"
        case releaseID = "release_id"
    }
}

public struct APITokensPostRequest: Codable {
    /// The description of the token
    public var description: String?
    /// An encrypted value of the token.
    public var encryptedToken: String?
    /// The scope for this token. An array of supported roles.
    public var scope: [ScopeItem]?
    /// The hashed value of api token
    public var tokenHash: String?
    /// The token's type. public:managed by the user; in_app_update:special token for in-app update scenario; buid:dedicated for CI usage for now; session:for CLI session management; tester_app: used for tester mobile app; default is "public".'
    public var tokenType: TokenType?

    public enum ScopeItem: String, Codable, CaseIterable {
        case all
        case inAppUpdate = "in_app_update"
        case viewer
    }

    /// The token's type. public:managed by the user; in_app_update:special token for in-app update scenario; buid:dedicated for CI usage for now; session:for CLI session management; tester_app: used for tester mobile app; default is "public".'
    public enum TokenType: String, Codable, CaseIterable {
        case `public`
        case inAppUpdate = "in_app_update"
        case build
        case session
        case testerApp = "tester_app"
    }

    public init(description: String? = nil, encryptedToken: String? = nil, scope: [ScopeItem]? = nil, tokenHash: String? = nil, tokenType: TokenType? = nil) {
        self.description = description
        self.encryptedToken = encryptedToken
        self.scope = scope
        self.tokenHash = tokenHash
        self.tokenType = tokenType
    }

    private enum CodingKeys: String, CodingKey {
        case description
        case encryptedToken = "encrypted_token"
        case scope
        case tokenHash = "token_hash"
        case tokenType = "token_type"
    }
}

public struct APITokensPrivateCreateRequest: Codable {
    /// The principal ID assigned to the API token
    public var principalID: String
    /// The principal type assigned to the API token
    public var principalType: PrincipalType
    /// The description of the token
    public var description: String?
    /// The scope for this token (default "all").
    public var scope: [ScopeItem]?
    /// The token's type (default "public")
    ///   public: managed by the user
    ///   in_app_update: special token for in-app update scenario
    ///   buid: dedicated for CI usage for now
    ///   session: for CLI session management
    ///   tester_app: used for tester mobile app
    public var tokenType: TokenType?

    /// The principal type assigned to the API token
    public enum PrincipalType: String, Codable, CaseIterable {
        case app
        case user
    }

    public enum ScopeItem: String, Codable, CaseIterable {
        case all
        case inAppUpdate = "in_app_update"
        case viewer
    }

    /// The token's type (default "public")
    ///   public: managed by the user
    ///   in_app_update: special token for in-app update scenario
    ///   buid: dedicated for CI usage for now
    ///   session: for CLI session management
    ///   tester_app: used for tester mobile app
    public enum TokenType: String, Codable, CaseIterable {
        case `public`
        case inAppUpdate = "in_app_update"
        case build
        case session
        case testerApp = "tester_app"
    }

    public init(principalID: String, principalType: PrincipalType, description: String? = nil, scope: [ScopeItem]? = nil, tokenType: TokenType? = nil) {
        self.principalID = principalID
        self.principalType = principalType
        self.description = description
        self.scope = scope
        self.tokenType = tokenType
    }

    private enum CodingKeys: String, CodingKey {
        case principalID = "principal_id"
        case principalType = "principal_type"
        case description
        case scope
        case tokenType = "token_type"
    }
}

public struct AppPatchRequest: Codable {
    /// A short text describing the app
    public var description: String?
    /// The display name of the app
    public var displayName: String?
    /// A one-word descriptive release type value that starts with a capital letter but is otherwise lowercase
    public var releaseType: String?
    /// The name of the app used in URLs
    public var name: String?
    /// The string representation of the URL pointing to the app's icon
    public var iconURL: String?
    /// The uuid for the icon's asset id from ACFUS
    public var iconAssetID: String?

    public init(description: String? = nil, displayName: String? = nil, releaseType: String? = nil, name: String? = nil, iconURL: String? = nil, iconAssetID: String? = nil) {
        self.description = description
        self.displayName = displayName
        self.releaseType = releaseType
        self.name = name
        self.iconURL = iconURL
        self.iconAssetID = iconAssetID
    }

    private enum CodingKeys: String, CodingKey {
        case description
        case displayName = "display_name"
        case releaseType = "release_type"
        case name
        case iconURL = "icon_url"
        case iconAssetID = "icon_asset_id"
    }
}

public struct AppRepoPatchRequest: Codable {
    /// The absolute URL of the repository
    public var repoURL: String?
    /// The unique id (UUID) of the user
    public var userID: String?
    /// The external user id from the provider
    public var externalUserID: String?
    /// The id of the service connection stored in customer credential store
    public var serviceConnectionID: String?

    public init(repoURL: String? = nil, userID: String? = nil, externalUserID: String? = nil, serviceConnectionID: String? = nil) {
        self.repoURL = repoURL
        self.userID = userID
        self.externalUserID = externalUserID
        self.serviceConnectionID = serviceConnectionID
    }

    private enum CodingKeys: String, CodingKey {
        case repoURL = "repo_url"
        case userID = "user_id"
        case externalUserID = "external_user_id"
        case serviceConnectionID = "service_connection_id"
    }
}

public struct AppRepoPostRequest: Codable {
    /// The absolute URL of the repository
    public var repoURL: String
    /// The provider of the repository
    public var repoProvider: RepoProvider?
    /// The unique id (UUID) of the user who configured the repository
    public var userID: String
    /// Installation id from the provider
    public var installationID: String?
    /// Repository id from the provider
    public var repoID: String?
    /// The external user id from the provider
    public var externalUserID: String?
    /// The id of the service connection stored in customer credential store
    public var serviceConnectionID: String?

    /// The provider of the repository
    public enum RepoProvider: String, Codable, CaseIterable {
        case github
        case bitbucket
        case vsts
        case gitlab
    }

    public init(repoURL: String, repoProvider: RepoProvider? = nil, userID: String, installationID: String? = nil, repoID: String? = nil, externalUserID: String? = nil, serviceConnectionID: String? = nil) {
        self.repoURL = repoURL
        self.repoProvider = repoProvider
        self.userID = userID
        self.installationID = installationID
        self.repoID = repoID
        self.externalUserID = externalUserID
        self.serviceConnectionID = serviceConnectionID
    }

    private enum CodingKeys: String, CodingKey {
        case repoURL = "repo_url"
        case repoProvider = "repo_provider"
        case userID = "user_id"
        case installationID = "installation_id"
        case repoID = "repo_id"
        case externalUserID = "external_user_id"
        case serviceConnectionID = "service_connection_id"
    }
}

public struct AppRequest: Codable {
    /// A short text describing the app
    public var description: String?
    /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
    public var releaseType: String?
    /// The descriptive name of the app. This can contain any characters
    public var displayName: String
    /// The name of the app used in URLs
    public var name: String?
    /// The OS the app will be running on
    public var os: Os
    /// The platform of the app
    public var platform: Platform

    /// The OS the app will be running on
    public enum Os: String, Codable, CaseIterable {
        case android = "Android"
        case iOS
        case macOS
        case tizen = "Tizen"
        case tvOS
        case windows = "Windows"
        case linux = "Linux"
        case custom = "Custom"
    }

    /// The platform of the app
    public enum Platform: String, Codable, CaseIterable {
        case java = "Java"
        case objectiveCSwift = "Objective-C-Swift"
        case uwp = "UWP"
        case cordova = "Cordova"
        case reactNative = "React-Native"
        case xamarin = "Xamarin"
        case unity = "Unity"
        case electron = "Electron"
        case wpf = "WPF"
        case winForms = "WinForms"
        case custom = "Custom"
    }

    public init(description: String? = nil, releaseType: String? = nil, displayName: String, name: String? = nil, os: Os, platform: Platform) {
        self.description = description
        self.releaseType = releaseType
        self.displayName = displayName
        self.name = name
        self.os = os
        self.platform = platform
    }

    private enum CodingKeys: String, CodingKey {
        case description
        case releaseType = "release_type"
        case displayName = "display_name"
        case name
        case os
        case platform
    }
}

public struct AppAddRequest: Codable {
    /// The name of the app to be added to the distribution group
    public var name: String

    public init(name: String) {
        self.name = name
    }
}

public struct AppDeleteRequest: Codable {
    /// The name of the app to be deleted from the distribution group
    public var name: String

    public init(name: String) {
        self.name = name
    }
}

public struct AzureSubscriptionAddRequest: Codable {
    /// The azure subscription id
    public var subscriptionID: String
    /// The tenant id of the azure subscription belongs to
    public var tenantID: String
    /// The name of the azure subscription
    public var subscriptionName: String
    /// If the subscription is used for billing
    public var isBilling: Bool?

    public init(subscriptionID: String, tenantID: String, subscriptionName: String, isBilling: Bool? = nil) {
        self.subscriptionID = subscriptionID
        self.tenantID = tenantID
        self.subscriptionName = subscriptionName
        self.isBilling = isBilling
    }

    private enum CodingKeys: String, CodingKey {
        case subscriptionID = "subscription_id"
        case tenantID = "tenant_id"
        case subscriptionName = "subscription_name"
        case isBilling = "is_billing"
    }
}

public struct AzureSubscriptionUpdateBillableRequest: Codable {
    /// Billable status of the subscription
    public var isBillable: Bool

    public init(isBillable: Bool) {
        self.isBillable = isBillable
    }

    private enum CodingKeys: String, CodingKey {
        case isBillable = "is_billable"
    }
}

public struct AzureSubscriptionPatchRequest: Codable {
    /// If the subscription is used for billing
    public var isBilling: Bool

    public init(isBilling: Bool) {
        self.isBilling = isBilling
    }

    private enum CodingKeys: String, CodingKey {
        case isBilling = "is_billing"
    }
}

public struct AzureSubscriptionAddToAppRequest: Codable {
    /// The azure subscription id
    public var subscriptionID: String

    public init(subscriptionID: String) {
        self.subscriptionID = subscriptionID
    }

    private enum CodingKeys: String, CodingKey {
        case subscriptionID = "subscription_id"
    }
}

public struct DistributionGroupPatchRequest: Codable {
    /// The name of the distribution group
    public var name: String?
    /// Whether the distribution group is public
    public var isPublic: Bool?

    public init(name: String? = nil, isPublic: Bool? = nil) {
        self.name = name
        self.isPublic = isPublic
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case isPublic = "is_public"
    }
}

public struct DistributionGroupRequest: Codable {
    /// The name of the distribution group
    public var name: String
    /// The display name of the distribution group. If not specified, the name will be used.
    public var displayName: String?

    public init(name: String, displayName: String? = nil) {
        self.name = name
        self.displayName = displayName
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case displayName = "display_name"
    }
}

public struct AppDistributionGroupUsersRequest: Codable {
    public var memberIDs: [String]?

    public init(memberIDs: [String]? = nil) {
        self.memberIDs = memberIDs
    }

    private enum CodingKeys: String, CodingKey {
        case memberIDs = "member_ids"
    }
}

public struct DistributionGroupUserRequest: Codable {
    /// The list of emails of the users
    public var userEmails: [String]?

    public init(userEmails: [String]? = nil) {
        self.userEmails = userEmails
    }

    private enum CodingKeys: String, CodingKey {
        case userEmails = "user_emails"
    }
}

public struct DistributionGroupAppAddRequest: Codable {
    /// The list of apps to add to distribution group
    public var apps: [App]?

    public struct App: Codable {
        /// The name of the app to be added to the distribution group
        public var name: String

        public init(name: String) {
            self.name = name
        }
    }

    public init(apps: [App]? = nil) {
        self.apps = apps
    }
}

public struct DistributionGroupAppsDeleteRequest: Codable {
    /// The list of apps to delete from the distribution group
    public var apps: [App]?

    public struct App: Codable {
        /// The name of the app to be deleted from the distribution group
        public var name: String

        public init(name: String) {
            self.name = name
        }
    }

    public init(apps: [App]? = nil) {
        self.apps = apps
    }
}

public struct DistributionGroupAADGroupsDeleteRequest: Codable {
    /// The list of aad group ids
    public var aadGroupIDs: [String]?

    public init(aadGroupIDs: [String]? = nil) {
        self.aadGroupIDs = aadGroupIDs
    }

    private enum CodingKeys: String, CodingKey {
        case aadGroupIDs = "aad_group_ids"
    }
}

public struct DistributionGroupAADGroupRequest: Codable {
    /// The list of aad group ids and names to add
    public var aadGroups: [AadGroup]?

    public struct AadGroup: Codable {
        /// The id of the aad group
        public var aadGroupID: String?
        /// The display name of the aad group
        public var displayName: String?

        public init(aadGroupID: String? = nil, displayName: String? = nil) {
            self.aadGroupID = aadGroupID
            self.displayName = displayName
        }

        private enum CodingKeys: String, CodingKey {
            case aadGroupID = "aad_group_id"
            case displayName = "display_name"
        }
    }

    public init(aadGroups: [AadGroup]? = nil) {
        self.aadGroups = aadGroups
    }

    private enum CodingKeys: String, CodingKey {
        case aadGroups = "aad_groups"
    }
}

public struct DistributionGroupAADGroupBase: Codable {
    /// The id of the aad group
    public var aadGroupID: String?
    /// The display name of the aad group
    public var displayName: String?

    public init(aadGroupID: String? = nil, displayName: String? = nil) {
        self.aadGroupID = aadGroupID
        self.displayName = displayName
    }

    private enum CodingKeys: String, CodingKey {
        case aadGroupID = "aad_group_id"
        case displayName = "display_name"
    }
}

public struct DistributionGroupsUserVerifyRequest: Codable {
    /// An array of distribution group ids
    public var distributionGroupIDs: [String]

    public init(distributionGroupIDs: [String]) {
        self.distributionGroupIDs = distributionGroupIDs
    }

    private enum CodingKeys: String, CodingKey {
        case distributionGroupIDs = "distribution_group_ids"
    }
}

public struct EmailVerificationRequest: Codable {
    /// The verification token that was sent to the user
    public var token: String

    public init(token: String) {
        self.token = token
    }
}

/// Supported external providers of source control repositories
public enum ExternalRepositoryProvider: String, Codable, CaseIterable {
    case github
}

public struct ExternalUserRequest: Codable {
    /// The token of the app invitation which lead to signup
    public var appInvitation: String?
    /// The token of the test invitation which lead to signup
    public var testerInvitation: String?
    /// The token of the organization invitation which lead to signup
    public var organizationInvitation: String?
    /// The avatar URL of the user
    public var avatarURL: String?
    /// The full name of the user. Might for example be first and last name
    public var displayName: String?
    /// The email address of the user
    public var email: String
    /// The unique name that is used to identify the user. If no explicit value is given, a default will be auto-generated from the `display_name` value
    public var name: String?

    public init(appInvitation: String? = nil, testerInvitation: String? = nil, organizationInvitation: String? = nil, avatarURL: String? = nil, displayName: String? = nil, email: String, name: String? = nil) {
        self.appInvitation = appInvitation
        self.testerInvitation = testerInvitation
        self.organizationInvitation = organizationInvitation
        self.avatarURL = avatarURL
        self.displayName = displayName
        self.email = email
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case appInvitation = "app_invitation"
        case testerInvitation = "tester_invitation"
        case organizationInvitation = "organization_invitation"
        case avatarURL = "avatar_url"
        case displayName = "display_name"
        case email
        case name
    }
}

public struct FeaturePatchRequest: Codable {
    /// The friendly name of the feature
    public var description: String?
    /// The full (friendly) name of the feature.
    public var displayName: String?
    /// The state of the feature
    public var state: Int?

    public init(description: String? = nil, displayName: String? = nil, state: Int? = nil) {
        self.description = description
        self.displayName = displayName
        self.state = state
    }

    private enum CodingKeys: String, CodingKey {
        case description
        case displayName = "display_name"
        case state
    }
}

public struct FeatureCreateRequest: Codable {
    /// The unique name of the feature
    public var name: String
    /// The full (friendly) name of the feature.
    public var displayName: String
    /// The state of the feature
    public var state: Int?
    /// The friendly name of the feature
    public var description: String?

    public init(name: String, displayName: String, state: Int? = nil, description: String? = nil) {
        self.name = name
        self.displayName = displayName
        self.state = state
        self.description = description
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case displayName = "display_name"
        case state
        case description
    }
}

public struct GrantAdminRoleRequest: Codable {
    /// The new admin_role
    public var adminRole: AdminRole

    /// The new admin_role
    public enum AdminRole: String, Codable, CaseIterable {
        case superAdmin
        case admin
        case devOps
        case customerSupport
        case notAdmin
    }

    public init(adminRole: AdminRole) {
        self.adminRole = adminRole
    }

    private enum CodingKeys: String, CodingKey {
        case adminRole = "admin_role"
    }
}

public struct InternalBulkAppResponse: Codable {
    /// The name of the app
    public var appName: String?
    /// The display name of the owner
    public var ownerDisplayName: String?

    public init(appName: String? = nil, ownerDisplayName: String? = nil) {
        self.appName = appName
        self.ownerDisplayName = ownerDisplayName
    }

    private enum CodingKeys: String, CodingKey {
        case appName = "app_name"
        case ownerDisplayName = "owner_display_name"
    }
}

public struct InternalUserRequest: Codable {
    /// The token of the app invitation which lead to signup
    public var appInvitation: String?
    /// The token of the test invitation which lead to signup
    public var testerInvitation: String?
    /// The token of the organization invitation which lead to signup
    public var organizationInvitation: String?
    /// The avatar URL of the user
    public var avatarURL: String?
    /// The full name of the user. Might for example be first and last name
    public var displayName: String?
    /// The email address of the user
    public var email: String
    /// The unique name that is used to identify the user.
    public var name: String
    /// The password of the user. Needs to be at least 8 characters long and contain at least one lower- and one uppercase letter.
    public var password: String
    /// The sub-domain of the portal from which this request was made. Will be used to build the invitation link.
    public var portalSubdomain: PortalSubdomain?

    /// The sub-domain of the portal from which this request was made. Will be used to build the invitation link.
    public enum PortalSubdomain: String, Codable, CaseIterable {
        case install = "install."
    }

    public init(appInvitation: String? = nil, testerInvitation: String? = nil, organizationInvitation: String? = nil, avatarURL: String? = nil, displayName: String? = nil, email: String, name: String, password: String, portalSubdomain: PortalSubdomain? = nil) {
        self.appInvitation = appInvitation
        self.testerInvitation = testerInvitation
        self.organizationInvitation = organizationInvitation
        self.avatarURL = avatarURL
        self.displayName = displayName
        self.email = email
        self.name = name
        self.password = password
        self.portalSubdomain = portalSubdomain
    }

    private enum CodingKeys: String, CodingKey {
        case appInvitation = "app_invitation"
        case testerInvitation = "tester_invitation"
        case organizationInvitation = "organization_invitation"
        case avatarURL = "avatar_url"
        case displayName = "display_name"
        case email
        case name
        case password
        case portalSubdomain = "portal_subdomain"
    }
}

public struct OrganizationPatchRequest: Codable {
    /// The full (friendly) name of the organization.
    public var displayName: String?
    /// The name of the organization used in URLs
    public var name: String?

    public init(displayName: String? = nil, name: String? = nil) {
        self.displayName = displayName
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case displayName = "display_name"
        case name
    }
}

public struct OrganizationRequest: Codable {
    /// The display name of the organization
    public var displayName: String?
    /// The name of the organization used in URLs
    public var name: String?

    public init(displayName: String? = nil, name: String? = nil) {
        self.displayName = displayName
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case displayName = "display_name"
        case name
    }
}

public struct OrganizationUserPatchRequest: Codable {
    /// The user's role in the organizatiion
    public var role: Role?

    /// The user's role in the organizatiion
    public enum Role: String, Codable, CaseIterable {
        case admin
        case collaborator
        case member
    }

    public init(role: Role? = nil) {
        self.role = role
    }
}

public struct AddOrganizationAdminRequest: Codable {
    /// The internal unique id (UUID) of the account.
    public var userID: String

    public init(userID: String) {
        self.userID = userID
    }

    private enum CodingKeys: String, CodingKey {
        case userID = "user_id"
    }
}

public struct TransferAppAdminRequest: Codable {
    /// The internal unique id (UUID) of the user/org.
    public var newOwnerID: String

    public init(newOwnerID: String) {
        self.newOwnerID = newOwnerID
    }

    private enum CodingKeys: String, CodingKey {
        case newOwnerID = "new_owner_id"
    }
}

public struct PasswordUpdateRequest: Codable {
    /// The new password that will be set for the user. Needs to be at least 8 characters long and contain at least one lower- and one uppercase letter.
    public var newPassword: String
    /// The old password, if needed.
    public var oldPassword: String?

    public init(newPassword: String, oldPassword: String? = nil) {
        self.newPassword = newPassword
        self.oldPassword = oldPassword
    }

    private enum CodingKeys: String, CodingKey {
        case newPassword = "new_password"
        case oldPassword = "old_password"
    }
}

public struct PostRepositoryProviderMappingRequest: Codable {
    /// Id of user in the external provider service
    public var externalAccountID: String
    /// Supported external providers of source control repositories
    public var provider: Provider
    /// App Center account id to link to this provider and external id
    public var accountID: String

    /// Supported external providers of source control repositories
    public enum Provider: String, Codable, CaseIterable {
        case github
    }

    public init(externalAccountID: String, provider: Provider, accountID: String) {
        self.externalAccountID = externalAccountID
        self.provider = provider
        self.accountID = accountID
    }

    private enum CodingKeys: String, CodingKey {
        case externalAccountID = "external_account_id"
        case provider
        case accountID = "account_id"
    }
}

public struct GetOrCreateRepositoryProviderMappingRequest: Codable {
    /// The account name given by the external provider. If provided, create an organization and the mapping. If not, create mapping with user.
    public var externalAccountName: String?

    public init(externalAccountName: String? = nil) {
        self.externalAccountName = externalAccountName
    }

    private enum CodingKeys: String, CodingKey {
        case externalAccountName = "external_account_name"
    }
}

public struct ResendVerificationRequest: Codable {
    /// The email or name of the user to resend verification
    public var name: String

    public init(name: String) {
        self.name = name
    }
}

public struct ResetPasswordUsingTokenRequest: Codable {
    /// The new password. Needs to be at least 8 characters long and contain at least one lower- and one uppercase letter.
    public var newPassword: String
    /// The reset password token that was sent to the user
    public var token: String

    public init(newPassword: String, token: String) {
        self.newPassword = newPassword
        self.token = token
    }

    private enum CodingKeys: String, CodingKey {
        case newPassword = "new_password"
        case token
    }
}

public struct UserAppPermissionsUpdateRequest: Codable {
    /// The permissions the user has for the app
    public var permissions: [Permission]

    public enum Permission: String, Codable, CaseIterable {
        case manager
        case developer
        case viewer
    }

    public init(permissions: [Permission]) {
        self.permissions = permissions
    }
}

public struct UserInvitationPermissionsUpdateRequest: Codable {
    /// The permissions the user has for the app in the invitation
    public var permissions: [Permission]

    public enum Permission: String, Codable, CaseIterable {
        case manager
        case developer
        case viewer
    }

    public init(permissions: [Permission]) {
        self.permissions = permissions
    }
}

public struct UserEmailOrgRoleRequest: Codable {
    /// The user's email address
    public var userEmail: String
    /// The user's role
    public var role: Role?

    /// The user's role
    public enum Role: String, Codable, CaseIterable {
        case admin
        case collaborator
        case member
    }

    public init(userEmail: String, role: Role? = nil) {
        self.userEmail = userEmail
        self.role = role
    }

    private enum CodingKeys: String, CodingKey {
        case userEmail = "user_email"
        case role
    }
}

public struct UserEmailRequest: Codable {
    /// The user's email address
    public var userEmail: String

    public init(userEmail: String) {
        self.userEmail = userEmail
    }

    private enum CodingKeys: String, CodingKey {
        case userEmail = "user_email"
    }
}

public struct UserNameUpdateRequest: Codable {
    /// The new, unique name that is used to identify.
    public var name: String?

    public init(name: String? = nil) {
        self.name = name
    }
}

public struct UserUpdateRequest: Codable {
    /// The full name of the user. Might for example be first and last name
    public var displayName: String?

    public init(displayName: String? = nil) {
        self.displayName = displayName
    }

    private enum CodingKeys: String, CodingKey {
        case displayName = "display_name"
    }
}

public struct UserUpdateRequestInternal: Codable {
    /// The full name of the user. Might for example be first and last name
    public var displayName: String?
    /// The new, unique name that is used to identify.
    public var name: String?
    /// The date in the future when the user should be checked again for NPS eligibility
    public var nextNpsSurveyDate: String?
    /// The email address for this user
    public var email: String?

    public init(displayName: String? = nil, name: String? = nil, nextNpsSurveyDate: String? = nil, email: String? = nil) {
        self.displayName = displayName
        self.name = name
        self.nextNpsSurveyDate = nextNpsSurveyDate
        self.email = email
    }

    private enum CodingKeys: String, CodingKey {
        case displayName = "display_name"
        case name
        case nextNpsSurveyDate = "next_nps_survey_date"
        case email
    }
}

public struct UserSettingRequest: Codable {
    /// The setting value
    public var value: String

    public init(value: String) {
        self.value = value
    }
}

public struct AccountResponse: Codable {
    /// The internal unique id (UUID) of the account.
    public var id: String
    /// The display name of the account
    public var displayName: String
    /// The slug name of the account
    public var name: String
    /// The account's email. For org that value might be empty.
    public var email: String?
    /// The creation origin of this account
    public var origin: Origin
    /// The type of this account
    public var type: `Type`

    /// The creation origin of this account
    public enum Origin: String, Codable, CaseIterable {
        case appcenter
        case hockeyapp
    }

    /// The type of this account
    public enum `Type`: String, Codable, CaseIterable {
        case user
        case org
    }

    public init(id: String, displayName: String, name: String, email: String? = nil, origin: Origin, type: `Type`) {
        self.id = id
        self.displayName = displayName
        self.name = name
        self.email = email
        self.origin = origin
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case displayName = "display_name"
        case name
        case email
        case origin
        case type
    }
}

public struct APITokenDeleteResponse: Codable {
    /// The unique id (UUID) of the api token
    public var id: String
    /// The hashed value of api token
    public var tokenHash: String

    public init(id: String, tokenHash: String) {
        self.id = id
        self.tokenHash = tokenHash
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case tokenHash = "token_hash"
    }
}

public struct APITokenGetUserResponse: Codable {
    /// The token's unique id (UUID)
    public var tokenID: String
    /// The token's scope. A list of allowed roles.
    public var tokenScope: [TokenScopeItem]
    /// The user email
    public var userEmail: String
    /// The unique id (UUID) of the user
    public var userID: String
    /// The creation origin of the user who created this api token
    public var userOrigin: UserOrigin

    public enum TokenScopeItem: String, Codable, CaseIterable {
        case all
        case inAppUpdate = "in_app_update"
        case viewer
    }

    /// The creation origin of the user who created this api token
    public enum UserOrigin: String, Codable, CaseIterable {
        case appcenter
        case hockeyapp
        case codepush
    }

    public init(tokenID: String, tokenScope: [TokenScopeItem], userEmail: String, userID: String, userOrigin: UserOrigin) {
        self.tokenID = tokenID
        self.tokenScope = tokenScope
        self.userEmail = userEmail
        self.userID = userID
        self.userOrigin = userOrigin
    }

    private enum CodingKeys: String, CodingKey {
        case tokenID = "token_id"
        case tokenScope = "token_scope"
        case userEmail = "user_email"
        case userID = "user_id"
        case userOrigin = "user_origin"
    }
}

public struct ValidatedAPITokenResponse: Codable {
    /// The token's unique id (UUID)
    public var tokenID: String
    /// The token's scope. A list of allowed roles.
    public var tokenScope: [TokenScopeItem]
    /// The ID of the owner of the API Token (user_id or app_id)
    public var principalID: String
    /// Indicates the type of the principal (app or user)
    public var principalType: PrincipalType
    /// Collection of attributes that describe the principal of the specified API Token
    public var claims: [Claim]

    public enum TokenScopeItem: String, Codable, CaseIterable {
        case all
        case inAppUpdate = "in_app_update"
        case viewer
    }

    /// Indicates the type of the principal (app or user)
    public enum PrincipalType: String, Codable, CaseIterable {
        case app
        case user
    }

    public struct Claim: Codable {
        public var claimType: ClaimType?
        public var claimValue: String?

        public enum ClaimType: String, Codable, CaseIterable {
            case userEmail = "user_email"
            case userOrigin = "user_origin"
            case appOwnerName = "app_owner_name"
            case appName = "app_name"
            case appOrigin = "app_origin"
            case appOs = "app_os"
            case appPlatform = "app_platform"
            case appSecret = "app_secret"
        }

        public init(claimType: ClaimType? = nil, claimValue: String? = nil) {
            self.claimType = claimType
            self.claimValue = claimValue
        }

        private enum CodingKeys: String, CodingKey {
            case claimType = "claim_type"
            case claimValue = "claim_value"
        }
    }

    public init(tokenID: String, tokenScope: [TokenScopeItem], principalID: String, principalType: PrincipalType, claims: [Claim]) {
        self.tokenID = tokenID
        self.tokenScope = tokenScope
        self.principalID = principalID
        self.principalType = principalType
        self.claims = claims
    }

    private enum CodingKeys: String, CodingKey {
        case tokenID = "token_id"
        case tokenScope = "token_scope"
        case principalID = "principal_id"
        case principalType = "principal_type"
        case claims
    }
}

public struct APITokenClaim: Codable {
    public var claimType: ClaimType?
    public var claimValue: String?

    public enum ClaimType: String, Codable, CaseIterable {
        case userEmail = "user_email"
        case userOrigin = "user_origin"
        case appOwnerName = "app_owner_name"
        case appName = "app_name"
        case appOrigin = "app_origin"
        case appOs = "app_os"
        case appPlatform = "app_platform"
        case appSecret = "app_secret"
    }

    public init(claimType: ClaimType? = nil, claimValue: String? = nil) {
        self.claimType = claimType
        self.claimValue = claimValue
    }

    private enum CodingKeys: String, CodingKey {
        case claimType = "claim_type"
        case claimValue = "claim_value"
    }
}

public struct APITokenResponse: Codable {
    /// The unique id (UUID) of the api token
    public var id: String
    /// The creation time
    public var createdAt: String
    /// The token's scope. A list of allowed roles.
    public var scope: [ScopeItem]?
    /// The encrypted value of a token. This value will only be returned for token of type in_app_update.
    public var encryptedToken: String?
    /// The description of the token
    public var description: String?

    public enum ScopeItem: String, Codable, CaseIterable {
        case all
        case inAppUpdate = "in_app_update"
        case viewer
    }

    public init(id: String, createdAt: String, scope: [ScopeItem]? = nil, encryptedToken: String? = nil, description: String? = nil) {
        self.id = id
        self.createdAt = createdAt
        self.scope = scope
        self.encryptedToken = encryptedToken
        self.description = description
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case createdAt = "created_at"
        case scope
        case encryptedToken = "encrypted_token"
        case description
    }
}

public struct APITokensPrivateCreateResponse: Codable {
    /// The unique id (UUID) of the api token
    public var id: String
    /// The creation time
    public var createdAt: String
    /// The scope for this token.
    public var scope: [ScopeItem]?
    /// The encrypted value of a token. This value will only be returned for token of type in_app_update.
    public var encryptedToken: String?
    /// The description of the token
    public var description: String?
    /// The api token generated will not be accessible again
    public var apiToken: String

    public enum ScopeItem: String, Codable, CaseIterable {
        case all
        case inAppUpdate = "in_app_update"
        case viewer
    }

    public init(id: String, createdAt: String, scope: [ScopeItem]? = nil, encryptedToken: String? = nil, description: String? = nil, apiToken: String) {
        self.id = id
        self.createdAt = createdAt
        self.scope = scope
        self.encryptedToken = encryptedToken
        self.description = description
        self.apiToken = apiToken
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case createdAt = "created_at"
        case scope
        case encryptedToken = "encrypted_token"
        case description
        case apiToken = "api_token"
    }
}

public struct AppGroupResponse: Codable {
    /// The unique ID (UUID) of the app
    public var id: String
    /// The unique ID (UUID) of the group that the app belongs to
    public var groupID: String
    /// The display name of the app
    public var displayName: String?
    /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
    public var releaseType: String?
    /// The name of the app used in URLs
    public var name: String
    /// The OS the app will be running on
    public var os: Os
    /// The platform of the app
    public var platform: Platform

    /// The OS the app will be running on
    public enum Os: String, Codable, CaseIterable {
        case android = "Android"
        case iOS
        case macOS
        case tizen = "Tizen"
        case tvOS
        case windows = "Windows"
        case linux = "Linux"
        case custom = "Custom"
    }

    /// The platform of the app
    public enum Platform: String, Codable, CaseIterable {
        case java = "Java"
        case objectiveCSwift = "Objective-C-Swift"
        case uwp = "UWP"
        case cordova = "Cordova"
        case reactNative = "React-Native"
        case unity = "Unity"
        case electron = "Electron"
        case xamarin = "Xamarin"
        case wpf = "WPF"
        case winForms = "WinForms"
        case unknown = "Unknown"
        case custom = "Custom"
    }

    public init(id: String, groupID: String, displayName: String? = nil, releaseType: String? = nil, name: String, os: Os, platform: Platform) {
        self.id = id
        self.groupID = groupID
        self.displayName = displayName
        self.releaseType = releaseType
        self.name = name
        self.os = os
        self.platform = platform
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case groupID = "group_id"
        case displayName = "display_name"
        case releaseType = "release_type"
        case name
        case os
        case platform
    }
}

public struct AppInvitationDetailResponse: Codable {
    /// The unique ID (UUID) of the invitation
    public var id: String
    public var app: App
    /// The email address of the invited user
    public var email: String
    /// The invitation type
    public var inviteType: InviteType
    public var invitedBy: InvitedBy
    /// Indicates whether the invited user already exists
    public var isExistingUser: Bool
    /// The permissions the user has for the app
    public var permissions: [Permission]?
    /// The number of apps in the group
    public var appCount: Double?
    /// The organization that owns the distribution group, if it exists
    public var distributionGroup: DistributionGroup?

    public struct App: Codable {
        /// The unique ID (UUID) of the app
        public var id: String
        /// The description of the app
        public var description: String?
        /// The display name of the app
        public var displayName: String
        /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
        public var releaseType: String?
        /// The string representation of the URL pointing to the app's icon
        public var iconURL: String?
        /// The string representation of the source of the app's icon
        public var iconSource: String?
        /// The name of the app used in URLs
        public var name: String
        /// The OS the app will be running on
        public var os: Os
        /// The information about the app's owner
        public var owner: Owner
        /// A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics
        public var appSecret: String?
        public var azureSubscription: AzureSubscription?
        /// The platform of the app
        public var platform: Platform?
        /// The creation origin of this app
        public var origin: Origin?
        /// The created date of this app
        public var createdAt: String?
        /// The last updated date of this app
        public var updatedAt: String?
        /// The permissions of the calling user
        public var memberPermissions: [MemberPermission]?

        /// The OS the app will be running on
        public enum Os: String, Codable, CaseIterable {
            case android = "Android"
            case iOS
            case macOS
            case tizen = "Tizen"
            case tvOS
            case windows = "Windows"
            case linux = "Linux"
            case custom = "Custom"
        }

        /// The information about the app's owner
        public struct Owner: Codable {
            /// The unique id (UUID) of the owner
            public var id: String
            /// The avatar URL of the owner
            public var avatarURL: String?
            /// The owner's display name
            public var displayName: String
            /// The owner's email address
            public var email: String?
            /// The unique name that used to identify the owner
            public var name: String
            /// The owner type. Can either be 'org' or 'user'
            public var type: `Type`

            /// The owner type. Can either be 'org' or 'user'
            public enum `Type`: String, Codable, CaseIterable {
                case org
                case user
            }

            public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
                self.id = id
                self.avatarURL = avatarURL
                self.displayName = displayName
                self.email = email
                self.name = name
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case avatarURL = "avatar_url"
                case displayName = "display_name"
                case email
                case name
                case type
            }
        }

        public struct AzureSubscription: Codable {
            /// The azure subscription id
            public var subscriptionID: String
            /// The tenant id of the azure subscription belongs to
            public var tenantID: String
            /// The name of the azure subscription
            public var subscriptionName: String
            /// If the subscription is used for billing
            public var isBilling: Bool?
            /// If the subscription can be used for billing
            public var isBillable: Bool?
            /// If the subscription is internal Microsoft subscription
            public var isMicrosoftInternal: Bool?

            public init(subscriptionID: String, tenantID: String, subscriptionName: String, isBilling: Bool? = nil, isBillable: Bool? = nil, isMicrosoftInternal: Bool? = nil) {
                self.subscriptionID = subscriptionID
                self.tenantID = tenantID
                self.subscriptionName = subscriptionName
                self.isBilling = isBilling
                self.isBillable = isBillable
                self.isMicrosoftInternal = isMicrosoftInternal
            }

            private enum CodingKeys: String, CodingKey {
                case subscriptionID = "subscription_id"
                case tenantID = "tenant_id"
                case subscriptionName = "subscription_name"
                case isBilling = "is_billing"
                case isBillable = "is_billable"
                case isMicrosoftInternal = "is_microsoft_internal"
            }
        }

        /// The platform of the app
        public enum Platform: String, Codable, CaseIterable {
            case java = "Java"
            case objectiveCSwift = "Objective-C-Swift"
            case uwp = "UWP"
            case cordova = "Cordova"
            case reactNative = "React-Native"
            case unity = "Unity"
            case electron = "Electron"
            case xamarin = "Xamarin"
            case wpf = "WPF"
            case winForms = "WinForms"
            case unknown = "Unknown"
            case custom = "Custom"
        }

        /// The creation origin of this app
        public enum Origin: String, Codable, CaseIterable {
            case appcenter
            case hockeyapp
            case codepush
        }

        public enum MemberPermission: String, Codable, CaseIterable {
            case manager
            case developer
            case viewer
            case tester
        }

        public init(id: String, description: String? = nil, displayName: String, releaseType: String? = nil, iconURL: String? = nil, iconSource: String? = nil, name: String, os: Os, owner: Owner, appSecret: String? = nil, azureSubscription: AzureSubscription? = nil, platform: Platform? = nil, origin: Origin? = nil, createdAt: String? = nil, updatedAt: String? = nil, memberPermissions: [MemberPermission]? = nil) {
            self.id = id
            self.description = description
            self.displayName = displayName
            self.releaseType = releaseType
            self.iconURL = iconURL
            self.iconSource = iconSource
            self.name = name
            self.os = os
            self.owner = owner
            self.appSecret = appSecret
            self.azureSubscription = azureSubscription
            self.platform = platform
            self.origin = origin
            self.createdAt = createdAt
            self.updatedAt = updatedAt
            self.memberPermissions = memberPermissions
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(String.self, forKey: "id")
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
            self.displayName = try values.decode(String.self, forKey: "display_name")
            self.releaseType = try values.decodeIfPresent(String.self, forKey: "release_type")
            self.iconURL = try values.decodeIfPresent(String.self, forKey: "icon_url")
            self.iconSource = try values.decodeIfPresent(String.self, forKey: "icon_source")
            self.name = try values.decode(String.self, forKey: "name")
            self.os = try Os(from: decoder)
            self.owner = try Owner(from: decoder)
            self.appSecret = try values.decodeIfPresent(String.self, forKey: "app_secret")
            self.azureSubscription = try AzureSubscription(from: decoder)
            self.platform = try Platform(from: decoder)
            self.origin = try Origin(from: decoder)
            self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
            self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
            self.memberPermissions = try values.decodeIfPresent([MemberPermission].self, forKey: "member_permissions")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encodeIfPresent(description, forKey: "description")
            try values.encode(displayName, forKey: "display_name")
            try values.encodeIfPresent(releaseType, forKey: "release_type")
            try values.encodeIfPresent(iconURL, forKey: "icon_url")
            try values.encodeIfPresent(iconSource, forKey: "icon_source")
            try values.encode(name, forKey: "name")
            try values.encode(os, forKey: "os")
            try values.encode(owner, forKey: "owner")
            try values.encodeIfPresent(appSecret, forKey: "app_secret")
            try values.encodeIfPresent(azureSubscription, forKey: "azure_subscription")
            try values.encodeIfPresent(platform, forKey: "platform")
            try values.encodeIfPresent(origin, forKey: "origin")
            try values.encodeIfPresent(createdAt, forKey: "created_at")
            try values.encodeIfPresent(updatedAt, forKey: "updated_at")
            try values.encodeIfPresent(memberPermissions, forKey: "member_permissions")
        }
    }

    /// The invitation type
    public enum InviteType: String, Codable, CaseIterable {
        case developer
        case tester
    }

    public struct InvitedBy: Codable {
        /// The unique id (UUID) of the user
        public var id: String
        /// The avatar URL of the user
        public var avatarURL: String?
        /// User is required to send an old password in order to change the password.
        public var canChangePassword: Bool?
        /// The full name of the user. Might for example be first and last name
        public var displayName: String
        /// The email address of the user
        public var email: String
        /// The unique name that is used to identify the user.
        public var name: String
        /// The permissions the user has for the app
        public var permissions: [Permission]?
        /// The creation origin of this user
        public var origin: Origin

        public enum Permission: String, Codable, CaseIterable {
            case manager
            case developer
            case viewer
            case tester
        }

        /// The creation origin of this user
        public enum Origin: String, Codable, CaseIterable {
            case appcenter
            case hockeyapp
            case codepush
        }

        public init(id: String, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String, email: String, name: String, permissions: [Permission]? = nil, origin: Origin) {
            self.id = id
            self.avatarURL = avatarURL
            self.canChangePassword = canChangePassword
            self.displayName = displayName
            self.email = email
            self.name = name
            self.permissions = permissions
            self.origin = origin
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case avatarURL = "avatar_url"
            case canChangePassword = "can_change_password"
            case displayName = "display_name"
            case email
            case name
            case permissions
            case origin
        }
    }

    public enum Permission: String, Codable, CaseIterable {
        case manager
        case developer
        case viewer
        case tester
    }

    /// The organization that owns the distribution group, if it exists
    public struct DistributionGroup: Codable {
        /// The information about the app's owner
        public var owner: Owner?

        /// The information about the app's owner
        public struct Owner: Codable {
            /// The unique id (UUID) of the owner
            public var id: String
            /// The avatar URL of the owner
            public var avatarURL: String?
            /// The owner's display name
            public var displayName: String
            /// The owner's email address
            public var email: String?
            /// The unique name that used to identify the owner
            public var name: String
            /// The owner type. Can either be 'org' or 'user'
            public var type: `Type`

            /// The owner type. Can either be 'org' or 'user'
            public enum `Type`: String, Codable, CaseIterable {
                case org
                case user
            }

            public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
                self.id = id
                self.avatarURL = avatarURL
                self.displayName = displayName
                self.email = email
                self.name = name
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case avatarURL = "avatar_url"
                case displayName = "display_name"
                case email
                case name
                case type
            }
        }

        public init(owner: Owner? = nil) {
            self.owner = owner
        }
    }

    public init(id: String, app: App, email: String, inviteType: InviteType, invitedBy: InvitedBy, isExistingUser: Bool, permissions: [Permission]? = nil, appCount: Double? = nil, distributionGroup: DistributionGroup? = nil) {
        self.id = id
        self.app = app
        self.email = email
        self.inviteType = inviteType
        self.invitedBy = invitedBy
        self.isExistingUser = isExistingUser
        self.permissions = permissions
        self.appCount = appCount
        self.distributionGroup = distributionGroup
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case app
        case email
        case inviteType = "invite_type"
        case invitedBy = "invited_by"
        case isExistingUser = "is_existing_user"
        case permissions
        case appCount = "app_count"
        case distributionGroup = "distribution_group"
    }
}

public struct AppRepoResponse: Codable {
    /// The unique id (UUID) of the repository integration
    public var id: String
    /// The unique id (UUID) of the app that this repository integration belongs to
    public var appID: String
    /// The absolute URL of the repository
    public var repoURL: String
    /// The provider of the repository
    public var repoProvider: RepoProvider?
    /// The unique id (UUID) of the user who configured the repository
    public var userID: String
    /// Installation id from the provider
    public var installationID: String?
    /// Repository id from the provider
    public var repoID: String?
    /// User id from the provider
    public var externalUserID: String?
    /// The id of the service connection stored in customer credential store
    public var serviceConnectionID: String?

    /// The provider of the repository
    public enum RepoProvider: String, Codable, CaseIterable {
        case github
        case bitbucket
        case vsts
        case gitlab
    }

    public init(id: String, appID: String, repoURL: String, repoProvider: RepoProvider? = nil, userID: String, installationID: String? = nil, repoID: String? = nil, externalUserID: String? = nil, serviceConnectionID: String? = nil) {
        self.id = id
        self.appID = appID
        self.repoURL = repoURL
        self.repoProvider = repoProvider
        self.userID = userID
        self.installationID = installationID
        self.repoID = repoID
        self.externalUserID = externalUserID
        self.serviceConnectionID = serviceConnectionID
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case appID = "app_id"
        case repoURL = "repo_url"
        case repoProvider = "repo_provider"
        case userID = "user_id"
        case installationID = "installation_id"
        case repoID = "repo_id"
        case externalUserID = "external_user_id"
        case serviceConnectionID = "service_connection_id"
    }
}

public struct BasicAppResponse: Codable {
    /// The unique ID (UUID) of the app
    public var id: String
    /// The description of the app
    public var description: String?
    /// The display name of the app
    public var displayName: String
    /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
    public var releaseType: String?
    /// The string representation of the URL pointing to the app's icon
    public var iconURL: String?
    /// The string representation of the source of the app's icon
    public var iconSource: String?
    /// The name of the app used in URLs
    public var name: String
    /// The OS the app will be running on
    public var os: Os
    /// The information about the app's owner
    public var owner: Owner

    /// The OS the app will be running on
    public enum Os: String, Codable, CaseIterable {
        case android = "Android"
        case iOS
        case macOS
        case tizen = "Tizen"
        case tvOS
        case windows = "Windows"
        case linux = "Linux"
        case custom = "Custom"
    }

    /// The information about the app's owner
    public struct Owner: Codable {
        /// The unique id (UUID) of the owner
        public var id: String
        /// The avatar URL of the owner
        public var avatarURL: String?
        /// The owner's display name
        public var displayName: String
        /// The owner's email address
        public var email: String?
        /// The unique name that used to identify the owner
        public var name: String
        /// The owner type. Can either be 'org' or 'user'
        public var type: `Type`

        /// The owner type. Can either be 'org' or 'user'
        public enum `Type`: String, Codable, CaseIterable {
            case org
            case user
        }

        public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
            self.id = id
            self.avatarURL = avatarURL
            self.displayName = displayName
            self.email = email
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case avatarURL = "avatar_url"
            case displayName = "display_name"
            case email
            case name
            case type
        }
    }

    public init(id: String, description: String? = nil, displayName: String, releaseType: String? = nil, iconURL: String? = nil, iconSource: String? = nil, name: String, os: Os, owner: Owner) {
        self.id = id
        self.description = description
        self.displayName = displayName
        self.releaseType = releaseType
        self.iconURL = iconURL
        self.iconSource = iconSource
        self.name = name
        self.os = os
        self.owner = owner
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case description
        case displayName = "display_name"
        case releaseType = "release_type"
        case iconURL = "icon_url"
        case iconSource = "icon_source"
        case name
        case os
        case owner
    }
}

public struct AppResponse: Codable {
    /// The unique ID (UUID) of the app
    public var id: String
    /// The description of the app
    public var description: String?
    /// The display name of the app
    public var displayName: String
    /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
    public var releaseType: String?
    /// The string representation of the URL pointing to the app's icon
    public var iconURL: String?
    /// The string representation of the source of the app's icon
    public var iconSource: String?
    /// The name of the app used in URLs
    public var name: String
    /// The OS the app will be running on
    public var os: Os
    /// The information about the app's owner
    public var owner: Owner
    /// A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics
    public var appSecret: String?
    public var azureSubscription: AzureSubscription?
    /// The platform of the app
    public var platform: Platform?
    /// The creation origin of this app
    public var origin: Origin?
    /// The created date of this app
    public var createdAt: String?
    /// The last updated date of this app
    public var updatedAt: String?
    /// The permissions of the calling user
    public var memberPermissions: [MemberPermission]?

    /// The OS the app will be running on
    public enum Os: String, Codable, CaseIterable {
        case android = "Android"
        case iOS
        case macOS
        case tizen = "Tizen"
        case tvOS
        case windows = "Windows"
        case linux = "Linux"
        case custom = "Custom"
    }

    /// The information about the app's owner
    public struct Owner: Codable {
        /// The unique id (UUID) of the owner
        public var id: String
        /// The avatar URL of the owner
        public var avatarURL: String?
        /// The owner's display name
        public var displayName: String
        /// The owner's email address
        public var email: String?
        /// The unique name that used to identify the owner
        public var name: String
        /// The owner type. Can either be 'org' or 'user'
        public var type: `Type`

        /// The owner type. Can either be 'org' or 'user'
        public enum `Type`: String, Codable, CaseIterable {
            case org
            case user
        }

        public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
            self.id = id
            self.avatarURL = avatarURL
            self.displayName = displayName
            self.email = email
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case avatarURL = "avatar_url"
            case displayName = "display_name"
            case email
            case name
            case type
        }
    }

    public struct AzureSubscription: Codable {
        /// The azure subscription id
        public var subscriptionID: String
        /// The tenant id of the azure subscription belongs to
        public var tenantID: String
        /// The name of the azure subscription
        public var subscriptionName: String
        /// If the subscription is used for billing
        public var isBilling: Bool?
        /// If the subscription can be used for billing
        public var isBillable: Bool?
        /// If the subscription is internal Microsoft subscription
        public var isMicrosoftInternal: Bool?

        public init(subscriptionID: String, tenantID: String, subscriptionName: String, isBilling: Bool? = nil, isBillable: Bool? = nil, isMicrosoftInternal: Bool? = nil) {
            self.subscriptionID = subscriptionID
            self.tenantID = tenantID
            self.subscriptionName = subscriptionName
            self.isBilling = isBilling
            self.isBillable = isBillable
            self.isMicrosoftInternal = isMicrosoftInternal
        }

        private enum CodingKeys: String, CodingKey {
            case subscriptionID = "subscription_id"
            case tenantID = "tenant_id"
            case subscriptionName = "subscription_name"
            case isBilling = "is_billing"
            case isBillable = "is_billable"
            case isMicrosoftInternal = "is_microsoft_internal"
        }
    }

    /// The platform of the app
    public enum Platform: String, Codable, CaseIterable {
        case java = "Java"
        case objectiveCSwift = "Objective-C-Swift"
        case uwp = "UWP"
        case cordova = "Cordova"
        case reactNative = "React-Native"
        case unity = "Unity"
        case electron = "Electron"
        case xamarin = "Xamarin"
        case wpf = "WPF"
        case winForms = "WinForms"
        case unknown = "Unknown"
        case custom = "Custom"
    }

    /// The creation origin of this app
    public enum Origin: String, Codable, CaseIterable {
        case appcenter
        case hockeyapp
        case codepush
    }

    public enum MemberPermission: String, Codable, CaseIterable {
        case manager
        case developer
        case viewer
        case tester
    }

    public init(id: String, description: String? = nil, displayName: String, releaseType: String? = nil, iconURL: String? = nil, iconSource: String? = nil, name: String, os: Os, owner: Owner, appSecret: String? = nil, azureSubscription: AzureSubscription? = nil, platform: Platform? = nil, origin: Origin? = nil, createdAt: String? = nil, updatedAt: String? = nil, memberPermissions: [MemberPermission]? = nil) {
        self.id = id
        self.description = description
        self.displayName = displayName
        self.releaseType = releaseType
        self.iconURL = iconURL
        self.iconSource = iconSource
        self.name = name
        self.os = os
        self.owner = owner
        self.appSecret = appSecret
        self.azureSubscription = azureSubscription
        self.platform = platform
        self.origin = origin
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.memberPermissions = memberPermissions
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.displayName = try values.decode(String.self, forKey: "display_name")
        self.releaseType = try values.decodeIfPresent(String.self, forKey: "release_type")
        self.iconURL = try values.decodeIfPresent(String.self, forKey: "icon_url")
        self.iconSource = try values.decodeIfPresent(String.self, forKey: "icon_source")
        self.name = try values.decode(String.self, forKey: "name")
        self.os = try Os(from: decoder)
        self.owner = try Owner(from: decoder)
        self.appSecret = try values.decodeIfPresent(String.self, forKey: "app_secret")
        self.azureSubscription = try AzureSubscription(from: decoder)
        self.platform = try Platform(from: decoder)
        self.origin = try Origin(from: decoder)
        self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
        self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
        self.memberPermissions = try values.decodeIfPresent([MemberPermission].self, forKey: "member_permissions")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(displayName, forKey: "display_name")
        try values.encodeIfPresent(releaseType, forKey: "release_type")
        try values.encodeIfPresent(iconURL, forKey: "icon_url")
        try values.encodeIfPresent(iconSource, forKey: "icon_source")
        try values.encode(name, forKey: "name")
        try values.encode(os, forKey: "os")
        try values.encode(owner, forKey: "owner")
        try values.encodeIfPresent(appSecret, forKey: "app_secret")
        try values.encodeIfPresent(azureSubscription, forKey: "azure_subscription")
        try values.encodeIfPresent(platform, forKey: "platform")
        try values.encodeIfPresent(origin, forKey: "origin")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(memberPermissions, forKey: "member_permissions")
    }
}

public struct TesterAppResponse: Codable {
    /// The unique ID (UUID) of the app
    public var id: String
    /// The description of the app
    public var description: String?
    /// The display name of the app
    public var displayName: String
    /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
    public var releaseType: String?
    /// The string representation of the URL pointing to the app's icon
    public var iconURL: String?
    /// The string representation of the source of the app's icon
    public var iconSource: String?
    /// The name of the app used in URLs
    public var name: String
    /// The OS the app will be running on
    public var os: Os
    /// The information about the app's owner
    public var owner: Owner
    /// It indicates if the app is microsoft internal
    public var isMicrosoftInternal: Bool?
    /// The permissions associated with the app
    public var permissions: [Permission]?

    /// The OS the app will be running on
    public enum Os: String, Codable, CaseIterable {
        case android = "Android"
        case iOS
        case macOS
        case tizen = "Tizen"
        case tvOS
        case windows = "Windows"
        case linux = "Linux"
        case custom = "Custom"
    }

    /// The information about the app's owner
    public struct Owner: Codable {
        /// The unique id (UUID) of the owner
        public var id: String
        /// The avatar URL of the owner
        public var avatarURL: String?
        /// The owner's display name
        public var displayName: String
        /// The owner's email address
        public var email: String?
        /// The unique name that used to identify the owner
        public var name: String
        /// The owner type. Can either be 'org' or 'user'
        public var type: `Type`

        /// The owner type. Can either be 'org' or 'user'
        public enum `Type`: String, Codable, CaseIterable {
            case org
            case user
        }

        public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
            self.id = id
            self.avatarURL = avatarURL
            self.displayName = displayName
            self.email = email
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case avatarURL = "avatar_url"
            case displayName = "display_name"
            case email
            case name
            case type
        }
    }

    public enum Permission: String, Codable, CaseIterable {
        case canRemoveFromApp = "can_remove_from_app"
    }

    public init(id: String, description: String? = nil, displayName: String, releaseType: String? = nil, iconURL: String? = nil, iconSource: String? = nil, name: String, os: Os, owner: Owner, isMicrosoftInternal: Bool? = nil, permissions: [Permission]? = nil) {
        self.id = id
        self.description = description
        self.displayName = displayName
        self.releaseType = releaseType
        self.iconURL = iconURL
        self.iconSource = iconSource
        self.name = name
        self.os = os
        self.owner = owner
        self.isMicrosoftInternal = isMicrosoftInternal
        self.permissions = permissions
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.displayName = try values.decode(String.self, forKey: "display_name")
        self.releaseType = try values.decodeIfPresent(String.self, forKey: "release_type")
        self.iconURL = try values.decodeIfPresent(String.self, forKey: "icon_url")
        self.iconSource = try values.decodeIfPresent(String.self, forKey: "icon_source")
        self.name = try values.decode(String.self, forKey: "name")
        self.os = try Os(from: decoder)
        self.owner = try Owner(from: decoder)
        self.isMicrosoftInternal = try values.decodeIfPresent(Bool.self, forKey: "microsoft_internal")
        self.permissions = try values.decodeIfPresent([Permission].self, forKey: "permissions")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(displayName, forKey: "display_name")
        try values.encodeIfPresent(releaseType, forKey: "release_type")
        try values.encodeIfPresent(iconURL, forKey: "icon_url")
        try values.encodeIfPresent(iconSource, forKey: "icon_source")
        try values.encode(name, forKey: "name")
        try values.encode(os, forKey: "os")
        try values.encode(owner, forKey: "owner")
        try values.encodeIfPresent(isMicrosoftInternal, forKey: "microsoft_internal")
        try values.encodeIfPresent(permissions, forKey: "permissions")
    }
}

public struct OrgDistributionGroupAppResponse: Codable {
    /// The unique ID (UUID) of the app
    public var id: String
    /// The description of the app
    public var description: String?
    /// The display name of the app
    public var displayName: String
    /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
    public var releaseType: String?
    /// The string representation of the URL pointing to the app's icon
    public var iconURL: String?
    /// The string representation of the source of the app's icon
    public var iconSource: String?
    /// The name of the app used in URLs
    public var name: String
    /// The OS the app will be running on
    public var os: Os
    /// The information about the app's owner
    public var owner: Owner
    /// The platform of the app
    public var platform: String?
    /// The creation origin of this app
    public var origin: String?

    /// The OS the app will be running on
    public enum Os: String, Codable, CaseIterable {
        case android = "Android"
        case iOS
        case macOS
        case tizen = "Tizen"
        case tvOS
        case windows = "Windows"
        case linux = "Linux"
        case custom = "Custom"
    }

    /// The information about the app's owner
    public struct Owner: Codable {
        /// The unique id (UUID) of the owner
        public var id: String
        /// The avatar URL of the owner
        public var avatarURL: String?
        /// The owner's display name
        public var displayName: String
        /// The owner's email address
        public var email: String?
        /// The unique name that used to identify the owner
        public var name: String
        /// The owner type. Can either be 'org' or 'user'
        public var type: `Type`

        /// The owner type. Can either be 'org' or 'user'
        public enum `Type`: String, Codable, CaseIterable {
            case org
            case user
        }

        public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
            self.id = id
            self.avatarURL = avatarURL
            self.displayName = displayName
            self.email = email
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case avatarURL = "avatar_url"
            case displayName = "display_name"
            case email
            case name
            case type
        }
    }

    public init(id: String, description: String? = nil, displayName: String, releaseType: String? = nil, iconURL: String? = nil, iconSource: String? = nil, name: String, os: Os, owner: Owner, platform: String? = nil, origin: String? = nil) {
        self.id = id
        self.description = description
        self.displayName = displayName
        self.releaseType = releaseType
        self.iconURL = iconURL
        self.iconSource = iconSource
        self.name = name
        self.os = os
        self.owner = owner
        self.platform = platform
        self.origin = origin
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.displayName = try values.decode(String.self, forKey: "display_name")
        self.releaseType = try values.decodeIfPresent(String.self, forKey: "release_type")
        self.iconURL = try values.decodeIfPresent(String.self, forKey: "icon_url")
        self.iconSource = try values.decodeIfPresent(String.self, forKey: "icon_source")
        self.name = try values.decode(String.self, forKey: "name")
        self.os = try Os(from: decoder)
        self.owner = try Owner(from: decoder)
        self.platform = try values.decodeIfPresent(String.self, forKey: "platform")
        self.origin = try values.decodeIfPresent(String.self, forKey: "origin")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(displayName, forKey: "display_name")
        try values.encodeIfPresent(releaseType, forKey: "release_type")
        try values.encodeIfPresent(iconURL, forKey: "icon_url")
        try values.encodeIfPresent(iconSource, forKey: "icon_source")
        try values.encode(name, forKey: "name")
        try values.encode(os, forKey: "os")
        try values.encode(owner, forKey: "owner")
        try values.encodeIfPresent(platform, forKey: "platform")
        try values.encodeIfPresent(origin, forKey: "origin")
    }
}

public struct AppResponseInternal: Codable {
    public var a: A
    /// The feature flags that are enabled for this app
    public var featureFlags: [String]?
    /// The repositories associated with this app
    public var repositories: [Repository]?
    /// The permissions for the specified app user
    public var userPermissions: UserPermissions?
    /// The cutover date of this app
    public var cutoverFromHockeyappAt: String?

    public struct A: Codable {
        /// The unique ID (UUID) of the app
        public var id: String
        /// The description of the app
        public var description: String?
        /// The display name of the app
        public var displayName: String
        /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
        public var releaseType: String?
        /// The string representation of the URL pointing to the app's icon
        public var iconURL: String?
        /// The string representation of the source of the app's icon
        public var iconSource: String?
        /// The name of the app used in URLs
        public var name: String
        /// The OS the app will be running on
        public var os: Os
        /// The information about the app's owner
        public var owner: Owner
        /// A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics
        public var appSecret: String?
        public var azureSubscription: AzureSubscription?
        /// The platform of the app
        public var platform: Platform?
        /// The creation origin of this app
        public var origin: Origin?
        /// The created date of this app
        public var createdAt: String?
        /// The last updated date of this app
        public var updatedAt: String?
        /// The permissions of the calling user
        public var memberPermissions: [MemberPermission]?

        /// The OS the app will be running on
        public enum Os: String, Codable, CaseIterable {
            case android = "Android"
            case iOS
            case macOS
            case tizen = "Tizen"
            case tvOS
            case windows = "Windows"
            case linux = "Linux"
            case custom = "Custom"
        }

        /// The information about the app's owner
        public struct Owner: Codable {
            /// The unique id (UUID) of the owner
            public var id: String
            /// The avatar URL of the owner
            public var avatarURL: String?
            /// The owner's display name
            public var displayName: String
            /// The owner's email address
            public var email: String?
            /// The unique name that used to identify the owner
            public var name: String
            /// The owner type. Can either be 'org' or 'user'
            public var type: `Type`

            /// The owner type. Can either be 'org' or 'user'
            public enum `Type`: String, Codable, CaseIterable {
                case org
                case user
            }

            public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
                self.id = id
                self.avatarURL = avatarURL
                self.displayName = displayName
                self.email = email
                self.name = name
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case avatarURL = "avatar_url"
                case displayName = "display_name"
                case email
                case name
                case type
            }
        }

        public struct AzureSubscription: Codable {
            /// The azure subscription id
            public var subscriptionID: String
            /// The tenant id of the azure subscription belongs to
            public var tenantID: String
            /// The name of the azure subscription
            public var subscriptionName: String
            /// If the subscription is used for billing
            public var isBilling: Bool?
            /// If the subscription can be used for billing
            public var isBillable: Bool?
            /// If the subscription is internal Microsoft subscription
            public var isMicrosoftInternal: Bool?

            public init(subscriptionID: String, tenantID: String, subscriptionName: String, isBilling: Bool? = nil, isBillable: Bool? = nil, isMicrosoftInternal: Bool? = nil) {
                self.subscriptionID = subscriptionID
                self.tenantID = tenantID
                self.subscriptionName = subscriptionName
                self.isBilling = isBilling
                self.isBillable = isBillable
                self.isMicrosoftInternal = isMicrosoftInternal
            }

            private enum CodingKeys: String, CodingKey {
                case subscriptionID = "subscription_id"
                case tenantID = "tenant_id"
                case subscriptionName = "subscription_name"
                case isBilling = "is_billing"
                case isBillable = "is_billable"
                case isMicrosoftInternal = "is_microsoft_internal"
            }
        }

        /// The platform of the app
        public enum Platform: String, Codable, CaseIterable {
            case java = "Java"
            case objectiveCSwift = "Objective-C-Swift"
            case uwp = "UWP"
            case cordova = "Cordova"
            case reactNative = "React-Native"
            case unity = "Unity"
            case electron = "Electron"
            case xamarin = "Xamarin"
            case wpf = "WPF"
            case winForms = "WinForms"
            case unknown = "Unknown"
            case custom = "Custom"
        }

        /// The creation origin of this app
        public enum Origin: String, Codable, CaseIterable {
            case appcenter
            case hockeyapp
            case codepush
        }

        public enum MemberPermission: String, Codable, CaseIterable {
            case manager
            case developer
            case viewer
            case tester
        }

        public init(id: String, description: String? = nil, displayName: String, releaseType: String? = nil, iconURL: String? = nil, iconSource: String? = nil, name: String, os: Os, owner: Owner, appSecret: String? = nil, azureSubscription: AzureSubscription? = nil, platform: Platform? = nil, origin: Origin? = nil, createdAt: String? = nil, updatedAt: String? = nil, memberPermissions: [MemberPermission]? = nil) {
            self.id = id
            self.description = description
            self.displayName = displayName
            self.releaseType = releaseType
            self.iconURL = iconURL
            self.iconSource = iconSource
            self.name = name
            self.os = os
            self.owner = owner
            self.appSecret = appSecret
            self.azureSubscription = azureSubscription
            self.platform = platform
            self.origin = origin
            self.createdAt = createdAt
            self.updatedAt = updatedAt
            self.memberPermissions = memberPermissions
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(String.self, forKey: "id")
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
            self.displayName = try values.decode(String.self, forKey: "display_name")
            self.releaseType = try values.decodeIfPresent(String.self, forKey: "release_type")
            self.iconURL = try values.decodeIfPresent(String.self, forKey: "icon_url")
            self.iconSource = try values.decodeIfPresent(String.self, forKey: "icon_source")
            self.name = try values.decode(String.self, forKey: "name")
            self.os = try Os(from: decoder)
            self.owner = try Owner(from: decoder)
            self.appSecret = try values.decodeIfPresent(String.self, forKey: "app_secret")
            self.azureSubscription = try AzureSubscription(from: decoder)
            self.platform = try Platform(from: decoder)
            self.origin = try Origin(from: decoder)
            self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
            self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
            self.memberPermissions = try values.decodeIfPresent([MemberPermission].self, forKey: "member_permissions")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encodeIfPresent(description, forKey: "description")
            try values.encode(displayName, forKey: "display_name")
            try values.encodeIfPresent(releaseType, forKey: "release_type")
            try values.encodeIfPresent(iconURL, forKey: "icon_url")
            try values.encodeIfPresent(iconSource, forKey: "icon_source")
            try values.encode(name, forKey: "name")
            try values.encode(os, forKey: "os")
            try values.encode(owner, forKey: "owner")
            try values.encodeIfPresent(appSecret, forKey: "app_secret")
            try values.encodeIfPresent(azureSubscription, forKey: "azure_subscription")
            try values.encodeIfPresent(platform, forKey: "platform")
            try values.encodeIfPresent(origin, forKey: "origin")
            try values.encodeIfPresent(createdAt, forKey: "created_at")
            try values.encodeIfPresent(updatedAt, forKey: "updated_at")
            try values.encodeIfPresent(memberPermissions, forKey: "member_permissions")
        }
    }

    public struct Repository: Codable {
        public var repoProvider: String?
        public var repoURL: String?

        public init(repoProvider: String? = nil, repoURL: String? = nil) {
            self.repoProvider = repoProvider
            self.repoURL = repoURL
        }

        private enum CodingKeys: String, CodingKey {
            case repoProvider = "repo_provider"
            case repoURL = "repo_url"
        }
    }

    /// The permissions for the specified app user
    public struct UserPermissions: Codable {
        public var permissions: [Permission]?
        public var userID: String?

        public enum Permission: String, Codable, CaseIterable {
            case manager
            case developer
            case viewer
            case tester
        }

        public init(permissions: [Permission]? = nil, userID: String? = nil) {
            self.permissions = permissions
            self.userID = userID
        }

        private enum CodingKeys: String, CodingKey {
            case permissions
            case userID = "user_id"
        }
    }

    public init(a: A, featureFlags: [String]? = nil, repositories: [Repository]? = nil, userPermissions: UserPermissions? = nil, cutoverFromHockeyappAt: String? = nil) {
        self.a = a
        self.featureFlags = featureFlags
        self.repositories = repositories
        self.userPermissions = userPermissions
        self.cutoverFromHockeyappAt = cutoverFromHockeyappAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.a = try A(from: decoder)
        self.featureFlags = try values.decodeIfPresent([String].self, forKey: "feature_flags")
        self.repositories = try values.decodeIfPresent([Repository].self, forKey: "repositories")
        self.userPermissions = try UserPermissions(from: decoder)
        self.cutoverFromHockeyappAt = try values.decodeIfPresent(String.self, forKey: "cutover_from_hockeyapp_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(a, forKey: "a")
        try values.encodeIfPresent(featureFlags, forKey: "feature_flags")
        try values.encodeIfPresent(repositories, forKey: "repositories")
        try values.encodeIfPresent(userPermissions, forKey: "user_permissions")
        try values.encodeIfPresent(cutoverFromHockeyappAt, forKey: "cutover_from_hockeyapp_at")
    }
}

public struct AppUserPermissionResponse: Codable {
    /// The unique id (UUID) of the app
    public var appID: String
    /// The permissions the user has for the app
    public var permissions: [Permission]
    /// The email of the user
    public var userEmail: String
    /// The unique id (UUID) of the user
    public var userID: String
    /// The creation origin of this app
    public var appOrigin: AppOrigin
    /// A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics
    public var appSecret: String

    public enum Permission: String, Codable, CaseIterable {
        case manager
        case developer
        case viewer
        case tester
    }

    /// The creation origin of this app
    public enum AppOrigin: String, Codable, CaseIterable {
        case appcenter
        case codepush
    }

    public init(appID: String, permissions: [Permission], userEmail: String, userID: String, appOrigin: AppOrigin, appSecret: String) {
        self.appID = appID
        self.permissions = permissions
        self.userEmail = userEmail
        self.userID = userID
        self.appOrigin = appOrigin
        self.appSecret = appSecret
    }

    private enum CodingKeys: String, CodingKey {
        case appID = "app_id"
        case permissions
        case userEmail = "user_email"
        case userID = "user_id"
        case appOrigin = "app_origin"
        case appSecret = "app_secret"
    }
}

public struct AppWithTeamPermissionsResponse: Codable {
    public var a: A
    /// The permissions the team has for the app
    public var teamPermissions: [TeamPermission]?

    public struct A: Codable {
        /// The unique ID (UUID) of the app
        public var id: String
        /// The description of the app
        public var description: String?
        /// The display name of the app
        public var displayName: String
        /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
        public var releaseType: String?
        /// The string representation of the URL pointing to the app's icon
        public var iconURL: String?
        /// The string representation of the source of the app's icon
        public var iconSource: String?
        /// The name of the app used in URLs
        public var name: String
        /// The OS the app will be running on
        public var os: Os
        /// The information about the app's owner
        public var owner: Owner
        /// A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics
        public var appSecret: String?
        public var azureSubscription: AzureSubscription?
        /// The platform of the app
        public var platform: Platform?
        /// The creation origin of this app
        public var origin: Origin?
        /// The created date of this app
        public var createdAt: String?
        /// The last updated date of this app
        public var updatedAt: String?
        /// The permissions of the calling user
        public var memberPermissions: [MemberPermission]?

        /// The OS the app will be running on
        public enum Os: String, Codable, CaseIterable {
            case android = "Android"
            case iOS
            case macOS
            case tizen = "Tizen"
            case tvOS
            case windows = "Windows"
            case linux = "Linux"
            case custom = "Custom"
        }

        /// The information about the app's owner
        public struct Owner: Codable {
            /// The unique id (UUID) of the owner
            public var id: String
            /// The avatar URL of the owner
            public var avatarURL: String?
            /// The owner's display name
            public var displayName: String
            /// The owner's email address
            public var email: String?
            /// The unique name that used to identify the owner
            public var name: String
            /// The owner type. Can either be 'org' or 'user'
            public var type: `Type`

            /// The owner type. Can either be 'org' or 'user'
            public enum `Type`: String, Codable, CaseIterable {
                case org
                case user
            }

            public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
                self.id = id
                self.avatarURL = avatarURL
                self.displayName = displayName
                self.email = email
                self.name = name
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case avatarURL = "avatar_url"
                case displayName = "display_name"
                case email
                case name
                case type
            }
        }

        public struct AzureSubscription: Codable {
            /// The azure subscription id
            public var subscriptionID: String
            /// The tenant id of the azure subscription belongs to
            public var tenantID: String
            /// The name of the azure subscription
            public var subscriptionName: String
            /// If the subscription is used for billing
            public var isBilling: Bool?
            /// If the subscription can be used for billing
            public var isBillable: Bool?
            /// If the subscription is internal Microsoft subscription
            public var isMicrosoftInternal: Bool?

            public init(subscriptionID: String, tenantID: String, subscriptionName: String, isBilling: Bool? = nil, isBillable: Bool? = nil, isMicrosoftInternal: Bool? = nil) {
                self.subscriptionID = subscriptionID
                self.tenantID = tenantID
                self.subscriptionName = subscriptionName
                self.isBilling = isBilling
                self.isBillable = isBillable
                self.isMicrosoftInternal = isMicrosoftInternal
            }

            private enum CodingKeys: String, CodingKey {
                case subscriptionID = "subscription_id"
                case tenantID = "tenant_id"
                case subscriptionName = "subscription_name"
                case isBilling = "is_billing"
                case isBillable = "is_billable"
                case isMicrosoftInternal = "is_microsoft_internal"
            }
        }

        /// The platform of the app
        public enum Platform: String, Codable, CaseIterable {
            case java = "Java"
            case objectiveCSwift = "Objective-C-Swift"
            case uwp = "UWP"
            case cordova = "Cordova"
            case reactNative = "React-Native"
            case unity = "Unity"
            case electron = "Electron"
            case xamarin = "Xamarin"
            case wpf = "WPF"
            case winForms = "WinForms"
            case unknown = "Unknown"
            case custom = "Custom"
        }

        /// The creation origin of this app
        public enum Origin: String, Codable, CaseIterable {
            case appcenter
            case hockeyapp
            case codepush
        }

        public enum MemberPermission: String, Codable, CaseIterable {
            case manager
            case developer
            case viewer
            case tester
        }

        public init(id: String, description: String? = nil, displayName: String, releaseType: String? = nil, iconURL: String? = nil, iconSource: String? = nil, name: String, os: Os, owner: Owner, appSecret: String? = nil, azureSubscription: AzureSubscription? = nil, platform: Platform? = nil, origin: Origin? = nil, createdAt: String? = nil, updatedAt: String? = nil, memberPermissions: [MemberPermission]? = nil) {
            self.id = id
            self.description = description
            self.displayName = displayName
            self.releaseType = releaseType
            self.iconURL = iconURL
            self.iconSource = iconSource
            self.name = name
            self.os = os
            self.owner = owner
            self.appSecret = appSecret
            self.azureSubscription = azureSubscription
            self.platform = platform
            self.origin = origin
            self.createdAt = createdAt
            self.updatedAt = updatedAt
            self.memberPermissions = memberPermissions
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(String.self, forKey: "id")
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
            self.displayName = try values.decode(String.self, forKey: "display_name")
            self.releaseType = try values.decodeIfPresent(String.self, forKey: "release_type")
            self.iconURL = try values.decodeIfPresent(String.self, forKey: "icon_url")
            self.iconSource = try values.decodeIfPresent(String.self, forKey: "icon_source")
            self.name = try values.decode(String.self, forKey: "name")
            self.os = try Os(from: decoder)
            self.owner = try Owner(from: decoder)
            self.appSecret = try values.decodeIfPresent(String.self, forKey: "app_secret")
            self.azureSubscription = try AzureSubscription(from: decoder)
            self.platform = try Platform(from: decoder)
            self.origin = try Origin(from: decoder)
            self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
            self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
            self.memberPermissions = try values.decodeIfPresent([MemberPermission].self, forKey: "member_permissions")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encodeIfPresent(description, forKey: "description")
            try values.encode(displayName, forKey: "display_name")
            try values.encodeIfPresent(releaseType, forKey: "release_type")
            try values.encodeIfPresent(iconURL, forKey: "icon_url")
            try values.encodeIfPresent(iconSource, forKey: "icon_source")
            try values.encode(name, forKey: "name")
            try values.encode(os, forKey: "os")
            try values.encode(owner, forKey: "owner")
            try values.encodeIfPresent(appSecret, forKey: "app_secret")
            try values.encodeIfPresent(azureSubscription, forKey: "azure_subscription")
            try values.encodeIfPresent(platform, forKey: "platform")
            try values.encodeIfPresent(origin, forKey: "origin")
            try values.encodeIfPresent(createdAt, forKey: "created_at")
            try values.encodeIfPresent(updatedAt, forKey: "updated_at")
            try values.encodeIfPresent(memberPermissions, forKey: "member_permissions")
        }
    }

    public enum TeamPermission: String, Codable, CaseIterable {
        case manager
        case developer
        case viewer
    }

    public init(a: A, teamPermissions: [TeamPermission]? = nil) {
        self.a = a
        self.teamPermissions = teamPermissions
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.a = try A(from: decoder)
        self.teamPermissions = try values.decodeIfPresent([TeamPermission].self, forKey: "team_permissions")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(a, forKey: "a")
        try values.encodeIfPresent(teamPermissions, forKey: "team_permissions")
    }
}

public struct OrgUserPermissionResponse: Codable {
    /// The unique id (UUID) of the org
    public var orgID: String
    /// The user role for the org
    public var userRole: UserRole

    /// The user role for the org
    public enum UserRole: String, Codable, CaseIterable {
        case admin
        case collaborator
    }

    public init(orgID: String, userRole: UserRole) {
        self.orgID = orgID
        self.userRole = userRole
    }

    private enum CodingKeys: String, CodingKey {
        case orgID = "orgId"
        case userRole
    }
}

public struct AzureSubscriptionResponse: Codable {
    /// The azure subscription id
    public var subscriptionID: String
    /// The tenant id of the azure subscription belongs to
    public var tenantID: String
    /// The name of the azure subscription
    public var subscriptionName: String
    /// If the subscription is used for billing
    public var isBilling: Bool?
    /// If the subscription can be used for billing
    public var isBillable: Bool?
    /// If the subscription is internal Microsoft subscription
    public var isMicrosoftInternal: Bool?

    public init(subscriptionID: String, tenantID: String, subscriptionName: String, isBilling: Bool? = nil, isBillable: Bool? = nil, isMicrosoftInternal: Bool? = nil) {
        self.subscriptionID = subscriptionID
        self.tenantID = tenantID
        self.subscriptionName = subscriptionName
        self.isBilling = isBilling
        self.isBillable = isBillable
        self.isMicrosoftInternal = isMicrosoftInternal
    }

    private enum CodingKeys: String, CodingKey {
        case subscriptionID = "subscription_id"
        case tenantID = "tenant_id"
        case subscriptionName = "subscription_name"
        case isBilling = "is_billing"
        case isBillable = "is_billable"
        case isMicrosoftInternal = "is_microsoft_internal"
    }
}

public struct DistributionGroupResponse: Codable {
    /// The unique ID of the distribution group
    public var id: String
    /// The name of the distribution group used in URLs
    public var name: String
    /// The name of the distribution group
    public var displayName: String?
    /// The creation origin of this distribution group
    public var origin: Origin
    /// Whether the distribution group is public
    public var isPublic: Bool

    /// The creation origin of this distribution group
    public enum Origin: String, Codable, CaseIterable {
        case appcenter
        case hockeyapp
    }

    public init(id: String, name: String, displayName: String? = nil, origin: Origin, isPublic: Bool) {
        self.id = id
        self.name = name
        self.displayName = displayName
        self.origin = origin
        self.isPublic = isPublic
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case displayName = "display_name"
        case origin
        case isPublic = "is_public"
    }
}

public struct DistributionGroupPrivateResponse: Codable {
    /// The unique ID of the distribution group
    public var id: String
    /// The name of the distribution group used in URLs
    public var name: String
    /// The name of the distribution group
    public var displayName: String?
    /// The creation origin of this distribution group
    public var origin: Origin
    /// Whether the distribution group is public
    public var isPublic: Bool
    /// Type of group
    public var groupType: GroupType?

    /// The creation origin of this distribution group
    public enum Origin: String, Codable, CaseIterable {
        case appcenter
        case hockeyapp
    }

    /// Type of group
    public enum GroupType: String, Codable, CaseIterable {
        case `default` = "Default"
        case hockeyAppDefault = "HockeyAppDefault"
        case microsoftDogfooding = "MicrosoftDogfooding"
    }

    public init(id: String, name: String, displayName: String? = nil, origin: Origin, isPublic: Bool, groupType: GroupType? = nil) {
        self.id = id
        self.name = name
        self.displayName = displayName
        self.origin = origin
        self.isPublic = isPublic
        self.groupType = groupType
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.name = try values.decode(String.self, forKey: "name")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
        self.origin = try Origin(from: decoder)
        self.isPublic = try values.decode(Bool.self, forKey: "is_public")
        self.groupType = try GroupType(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(displayName, forKey: "display_name")
        try values.encode(origin, forKey: "origin")
        try values.encode(isPublic, forKey: "is_public")
        try values.encodeIfPresent(groupType, forKey: "group_type")
    }
}

public struct DistributionGroupDetailsResponse: Codable {
    /// The unique ID of the distribution group
    public var id: String
    /// The name of the distribution group used in URLs
    public var name: String
    /// The name of the distribution group
    public var displayName: String?
    /// The creation origin of this distribution group
    public var origin: Origin
    /// Whether the distribution group is public
    public var isPublic: Bool
    /// Whether the distribution group is shared group or not
    public var isShared: Bool?
    /// The count of apps associated with this distribution group
    public var totalAppsCount: Double?
    /// The count of users in the distribution group
    public var totalUserCount: Double?
    /// The count of non-pending users in the distribution group who will be notified by new releases
    public var notifiedUserCount: Double?
    /// Type of group (Default, HockeyAppDefault or MicrosoftDogfooding)
    public var groupType: GroupType?
    /// The distribution group users
    public var users: [User]?

    /// The creation origin of this distribution group
    public enum Origin: String, Codable, CaseIterable {
        case appcenter
        case hockeyapp
    }

    /// Type of group (Default, HockeyAppDefault or MicrosoftDogfooding)
    public enum GroupType: String, Codable, CaseIterable {
        case `default` = "Default"
        case hockeyAppDefault = "HockeyAppDefault"
        case microsoftDogfooding = "MicrosoftDogfooding"
    }

    public struct User: Codable {
        /// The unique id (UUID) of the user
        public var id: String?
        /// The avatar URL of the user
        public var avatarURL: String?
        /// User is required to send an old password in order to change the password.
        public var canChangePassword: Bool?
        /// The full name of the user. Might for example be first and last name
        public var displayName: String?
        /// The email address of the user
        public var email: String
        /// Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".
        public var isInvitePending: Bool?
        /// The unique name that is used to identify the user.
        public var name: String?

        public init(id: String? = nil, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String? = nil, email: String, isInvitePending: Bool? = nil, name: String? = nil) {
            self.id = id
            self.avatarURL = avatarURL
            self.canChangePassword = canChangePassword
            self.displayName = displayName
            self.email = email
            self.isInvitePending = isInvitePending
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case avatarURL = "avatar_url"
            case canChangePassword = "can_change_password"
            case displayName = "display_name"
            case email
            case isInvitePending = "invite_pending"
            case name
        }
    }

    public init(id: String, name: String, displayName: String? = nil, origin: Origin, isPublic: Bool, isShared: Bool? = nil, totalAppsCount: Double? = nil, totalUserCount: Double? = nil, notifiedUserCount: Double? = nil, groupType: GroupType? = nil, users: [User]? = nil) {
        self.id = id
        self.name = name
        self.displayName = displayName
        self.origin = origin
        self.isPublic = isPublic
        self.isShared = isShared
        self.totalAppsCount = totalAppsCount
        self.totalUserCount = totalUserCount
        self.notifiedUserCount = notifiedUserCount
        self.groupType = groupType
        self.users = users
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.name = try values.decode(String.self, forKey: "name")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
        self.origin = try Origin(from: decoder)
        self.isPublic = try values.decode(Bool.self, forKey: "is_public")
        self.isShared = try values.decodeIfPresent(Bool.self, forKey: "is_shared")
        self.totalAppsCount = try values.decodeIfPresent(Double.self, forKey: "total_apps_count")
        self.totalUserCount = try values.decodeIfPresent(Double.self, forKey: "total_user_count")
        self.notifiedUserCount = try values.decodeIfPresent(Double.self, forKey: "notified_user_count")
        self.groupType = try GroupType(from: decoder)
        self.users = try values.decodeIfPresent([User].self, forKey: "users")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(displayName, forKey: "display_name")
        try values.encode(origin, forKey: "origin")
        try values.encode(isPublic, forKey: "is_public")
        try values.encodeIfPresent(isShared, forKey: "is_shared")
        try values.encodeIfPresent(totalAppsCount, forKey: "total_apps_count")
        try values.encodeIfPresent(totalUserCount, forKey: "total_user_count")
        try values.encodeIfPresent(notifiedUserCount, forKey: "notified_user_count")
        try values.encodeIfPresent(groupType, forKey: "group_type")
        try values.encodeIfPresent(users, forKey: "users")
    }
}

public struct OrgDistributionGroupDetailsResponse: Codable {
    /// The unique ID of the distribution group
    public var id: String
    /// The name of the distribution group used in URLs
    public var name: String
    /// The name of the distribution group
    public var displayName: String?
    /// The creation origin of this distribution group
    public var origin: Origin
    /// Whether the distribution group is public
    public var isPublic: Bool
    /// The count of apps associated with this distribution group
    public var totalAppsCount: Double?
    /// The count of users in the distribution group
    public var totalUsersCount: Double?
    /// The apps associated with the distribution group
    public var apps: [App]?

    /// The creation origin of this distribution group
    public enum Origin: String, Codable, CaseIterable {
        case appcenter
        case hockeyapp
    }

    public struct App: Codable {
        /// The unique ID (UUID) of the app
        public var id: String
        /// The description of the app
        public var description: String?
        /// The display name of the app
        public var displayName: String
        /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
        public var releaseType: String?
        /// The string representation of the URL pointing to the app's icon
        public var iconURL: String?
        /// The string representation of the source of the app's icon
        public var iconSource: String?
        /// The name of the app used in URLs
        public var name: String
        /// The OS the app will be running on
        public var os: Os
        /// The information about the app's owner
        public var owner: Owner
        /// A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics
        public var appSecret: String?
        public var azureSubscription: AzureSubscription?
        /// The platform of the app
        public var platform: Platform?
        /// The creation origin of this app
        public var origin: Origin?
        /// The created date of this app
        public var createdAt: String?
        /// The last updated date of this app
        public var updatedAt: String?
        /// The permissions of the calling user
        public var memberPermissions: [MemberPermission]?

        /// The OS the app will be running on
        public enum Os: String, Codable, CaseIterable {
            case android = "Android"
            case iOS
            case macOS
            case tizen = "Tizen"
            case tvOS
            case windows = "Windows"
            case linux = "Linux"
            case custom = "Custom"
        }

        /// The information about the app's owner
        public struct Owner: Codable {
            /// The unique id (UUID) of the owner
            public var id: String
            /// The avatar URL of the owner
            public var avatarURL: String?
            /// The owner's display name
            public var displayName: String
            /// The owner's email address
            public var email: String?
            /// The unique name that used to identify the owner
            public var name: String
            /// The owner type. Can either be 'org' or 'user'
            public var type: `Type`

            /// The owner type. Can either be 'org' or 'user'
            public enum `Type`: String, Codable, CaseIterable {
                case org
                case user
            }

            public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
                self.id = id
                self.avatarURL = avatarURL
                self.displayName = displayName
                self.email = email
                self.name = name
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case avatarURL = "avatar_url"
                case displayName = "display_name"
                case email
                case name
                case type
            }
        }

        public struct AzureSubscription: Codable {
            /// The azure subscription id
            public var subscriptionID: String
            /// The tenant id of the azure subscription belongs to
            public var tenantID: String
            /// The name of the azure subscription
            public var subscriptionName: String
            /// If the subscription is used for billing
            public var isBilling: Bool?
            /// If the subscription can be used for billing
            public var isBillable: Bool?
            /// If the subscription is internal Microsoft subscription
            public var isMicrosoftInternal: Bool?

            public init(subscriptionID: String, tenantID: String, subscriptionName: String, isBilling: Bool? = nil, isBillable: Bool? = nil, isMicrosoftInternal: Bool? = nil) {
                self.subscriptionID = subscriptionID
                self.tenantID = tenantID
                self.subscriptionName = subscriptionName
                self.isBilling = isBilling
                self.isBillable = isBillable
                self.isMicrosoftInternal = isMicrosoftInternal
            }

            private enum CodingKeys: String, CodingKey {
                case subscriptionID = "subscription_id"
                case tenantID = "tenant_id"
                case subscriptionName = "subscription_name"
                case isBilling = "is_billing"
                case isBillable = "is_billable"
                case isMicrosoftInternal = "is_microsoft_internal"
            }
        }

        /// The platform of the app
        public enum Platform: String, Codable, CaseIterable {
            case java = "Java"
            case objectiveCSwift = "Objective-C-Swift"
            case uwp = "UWP"
            case cordova = "Cordova"
            case reactNative = "React-Native"
            case unity = "Unity"
            case electron = "Electron"
            case xamarin = "Xamarin"
            case wpf = "WPF"
            case winForms = "WinForms"
            case unknown = "Unknown"
            case custom = "Custom"
        }

        /// The creation origin of this app
        public enum Origin: String, Codable, CaseIterable {
            case appcenter
            case hockeyapp
            case codepush
        }

        public enum MemberPermission: String, Codable, CaseIterable {
            case manager
            case developer
            case viewer
            case tester
        }

        public init(id: String, description: String? = nil, displayName: String, releaseType: String? = nil, iconURL: String? = nil, iconSource: String? = nil, name: String, os: Os, owner: Owner, appSecret: String? = nil, azureSubscription: AzureSubscription? = nil, platform: Platform? = nil, origin: Origin? = nil, createdAt: String? = nil, updatedAt: String? = nil, memberPermissions: [MemberPermission]? = nil) {
            self.id = id
            self.description = description
            self.displayName = displayName
            self.releaseType = releaseType
            self.iconURL = iconURL
            self.iconSource = iconSource
            self.name = name
            self.os = os
            self.owner = owner
            self.appSecret = appSecret
            self.azureSubscription = azureSubscription
            self.platform = platform
            self.origin = origin
            self.createdAt = createdAt
            self.updatedAt = updatedAt
            self.memberPermissions = memberPermissions
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(String.self, forKey: "id")
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
            self.displayName = try values.decode(String.self, forKey: "display_name")
            self.releaseType = try values.decodeIfPresent(String.self, forKey: "release_type")
            self.iconURL = try values.decodeIfPresent(String.self, forKey: "icon_url")
            self.iconSource = try values.decodeIfPresent(String.self, forKey: "icon_source")
            self.name = try values.decode(String.self, forKey: "name")
            self.os = try Os(from: decoder)
            self.owner = try Owner(from: decoder)
            self.appSecret = try values.decodeIfPresent(String.self, forKey: "app_secret")
            self.azureSubscription = try AzureSubscription(from: decoder)
            self.platform = try Platform(from: decoder)
            self.origin = try Origin(from: decoder)
            self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
            self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
            self.memberPermissions = try values.decodeIfPresent([MemberPermission].self, forKey: "member_permissions")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encodeIfPresent(description, forKey: "description")
            try values.encode(displayName, forKey: "display_name")
            try values.encodeIfPresent(releaseType, forKey: "release_type")
            try values.encodeIfPresent(iconURL, forKey: "icon_url")
            try values.encodeIfPresent(iconSource, forKey: "icon_source")
            try values.encode(name, forKey: "name")
            try values.encode(os, forKey: "os")
            try values.encode(owner, forKey: "owner")
            try values.encodeIfPresent(appSecret, forKey: "app_secret")
            try values.encodeIfPresent(azureSubscription, forKey: "azure_subscription")
            try values.encodeIfPresent(platform, forKey: "platform")
            try values.encodeIfPresent(origin, forKey: "origin")
            try values.encodeIfPresent(createdAt, forKey: "created_at")
            try values.encodeIfPresent(updatedAt, forKey: "updated_at")
            try values.encodeIfPresent(memberPermissions, forKey: "member_permissions")
        }
    }

    public init(id: String, name: String, displayName: String? = nil, origin: Origin, isPublic: Bool, totalAppsCount: Double? = nil, totalUsersCount: Double? = nil, apps: [App]? = nil) {
        self.id = id
        self.name = name
        self.displayName = displayName
        self.origin = origin
        self.isPublic = isPublic
        self.totalAppsCount = totalAppsCount
        self.totalUsersCount = totalUsersCount
        self.apps = apps
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.name = try values.decode(String.self, forKey: "name")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
        self.origin = try Origin(from: decoder)
        self.isPublic = try values.decode(Bool.self, forKey: "is_public")
        self.totalAppsCount = try values.decodeIfPresent(Double.self, forKey: "total_apps_count")
        self.totalUsersCount = try values.decodeIfPresent(Double.self, forKey: "total_users_count")
        self.apps = try values.decodeIfPresent([App].self, forKey: "apps")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(displayName, forKey: "display_name")
        try values.encode(origin, forKey: "origin")
        try values.encode(isPublic, forKey: "is_public")
        try values.encodeIfPresent(totalAppsCount, forKey: "total_apps_count")
        try values.encodeIfPresent(totalUsersCount, forKey: "total_users_count")
        try values.encodeIfPresent(apps, forKey: "apps")
    }
}

public struct GeneralDistributionGroupDetailsResponse: Codable {
    /// The unique ID of the distribution group
    public var id: String
    /// The name of the distribution group used in URLs
    public var name: String
    /// The name of the distribution group
    public var displayName: String?
    /// The creation origin of this distribution group
    public var origin: Origin
    /// Whether the distribution group is public
    public var isPublic: Bool
    /// Whether the distribution group is shared group or not
    public var isShared: Bool?
    /// If distribution group is owned by an app, this is the unique app ID
    public var ownerAppID: String?
    /// If distribution group is owned by an org, this is the unique org ID
    public var ownerOrgID: String?

    /// The creation origin of this distribution group
    public enum Origin: String, Codable, CaseIterable {
        case appcenter
        case hockeyapp
    }

    public init(id: String, name: String, displayName: String? = nil, origin: Origin, isPublic: Bool, isShared: Bool? = nil, ownerAppID: String? = nil, ownerOrgID: String? = nil) {
        self.id = id
        self.name = name
        self.displayName = displayName
        self.origin = origin
        self.isPublic = isPublic
        self.isShared = isShared
        self.ownerAppID = ownerAppID
        self.ownerOrgID = ownerOrgID
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.name = try values.decode(String.self, forKey: "name")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
        self.origin = try Origin(from: decoder)
        self.isPublic = try values.decode(Bool.self, forKey: "is_public")
        self.isShared = try values.decodeIfPresent(Bool.self, forKey: "is_shared")
        self.ownerAppID = try values.decodeIfPresent(String.self, forKey: "owner_app_id")
        self.ownerOrgID = try values.decodeIfPresent(String.self, forKey: "owner_org_id")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(displayName, forKey: "display_name")
        try values.encode(origin, forKey: "origin")
        try values.encode(isPublic, forKey: "is_public")
        try values.encodeIfPresent(isShared, forKey: "is_shared")
        try values.encodeIfPresent(ownerAppID, forKey: "owner_app_id")
        try values.encodeIfPresent(ownerOrgID, forKey: "owner_org_id")
    }
}

public struct DistributionGroupUserDeleteResponse: Codable {
    /// The code of the result
    public var code: String?
    /// The message of the result
    public var message: Int?
    /// The status code of the result
    public var status: Int
    /// The email of the user
    public var userEmail: String?

    public init(code: String? = nil, message: Int? = nil, status: Int, userEmail: String? = nil) {
        self.code = code
        self.message = message
        self.status = status
        self.userEmail = userEmail
    }

    private enum CodingKeys: String, CodingKey {
        case code
        case message
        case status
        case userEmail = "user_email"
    }
}

public struct CloseAccountOrganizationResponse: Codable {
    /// The internal unique id (UUID) of the organization.
    public var id: String
    /// The display name of the organization
    public var displayName: String
    /// The slug name of the organization
    public var name: String
    /// The URL to a user-uploaded Avatar image
    public var avatarURL: String?
    /// The creation origin of this organization
    public var origin: Origin
    /// The creation date of this organization
    public var createdAt: String
    /// The date the organization was last updated at
    public var updatedAt: String
    /// The number of collaborators from the organization
    public var collaboratorsCount: Double?

    /// The creation origin of this organization
    public enum Origin: String, Codable, CaseIterable {
        case appcenter
        case hockeyapp
    }

    public init(id: String, displayName: String, name: String, avatarURL: String? = nil, origin: Origin, createdAt: String, updatedAt: String, collaboratorsCount: Double? = nil) {
        self.id = id
        self.displayName = displayName
        self.name = name
        self.avatarURL = avatarURL
        self.origin = origin
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.collaboratorsCount = collaboratorsCount
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.displayName = try values.decode(String.self, forKey: "display_name")
        self.name = try values.decode(String.self, forKey: "name")
        self.avatarURL = try values.decodeIfPresent(String.self, forKey: "avatar_url")
        self.origin = try Origin(from: decoder)
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.updatedAt = try values.decode(String.self, forKey: "updated_at")
        self.collaboratorsCount = try values.decodeIfPresent(Double.self, forKey: "collaborators_count")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(displayName, forKey: "display_name")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(avatarURL, forKey: "avatar_url")
        try values.encode(origin, forKey: "origin")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(collaboratorsCount, forKey: "collaborators_count")
    }
}

public struct DistributionGroupUserGetResponse: Codable {
    /// The unique id (UUID) of the user
    public var id: String?
    /// The avatar URL of the user
    public var avatarURL: String?
    /// User is required to send an old password in order to change the password.
    public var canChangePassword: Bool?
    /// The full name of the user. Might for example be first and last name
    public var displayName: String?
    /// The email address of the user
    public var email: String
    /// Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".
    public var isInvitePending: Bool?
    /// The unique name that is used to identify the user.
    public var name: String?

    public init(id: String? = nil, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String? = nil, email: String, isInvitePending: Bool? = nil, name: String? = nil) {
        self.id = id
        self.avatarURL = avatarURL
        self.canChangePassword = canChangePassword
        self.displayName = displayName
        self.email = email
        self.isInvitePending = isInvitePending
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case avatarURL = "avatar_url"
        case canChangePassword = "can_change_password"
        case displayName = "display_name"
        case email
        case isInvitePending = "invite_pending"
        case name
    }
}

public struct DistributionGroupUserPostResponse: Codable {
    /// The code of the result
    public var code: String?
    /// Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".
    public var isInvitePending: Bool?
    /// The message of the result
    public var message: String?
    /// The status code of the result
    public var status: Int
    /// The email of the user
    public var userEmail: String?

    public init(code: String? = nil, isInvitePending: Bool? = nil, message: String? = nil, status: Int, userEmail: String? = nil) {
        self.code = code
        self.isInvitePending = isInvitePending
        self.message = message
        self.status = status
        self.userEmail = userEmail
    }

    private enum CodingKeys: String, CodingKey {
        case code
        case isInvitePending = "invite_pending"
        case message
        case status
        case userEmail = "user_email"
    }
}

public struct DistributionGroupTesterGetResponse: Codable {
    /// The full name of the tester. Might for example be first and last name
    public var displayName: String?
    /// The unique name that is used to identify the tester.
    public var name: String
    /// The email address of the tester
    public var email: String

    public init(displayName: String? = nil, name: String, email: String) {
        self.displayName = displayName
        self.name = name
        self.email = email
    }

    private enum CodingKeys: String, CodingKey {
        case displayName = "display_name"
        case name
        case email
    }
}

public struct DistributionGroupAADGroupPostResponse: Codable {
    /// The internal unique id (UUID) of the AAD group.
    public var id: String?
    /// The AAD unique id (UUID) of the AAD group.
    public var aadGroupID: String?
    /// The display name of the AAD group
    public var displayName: String?

    public init(id: String? = nil, aadGroupID: String? = nil, displayName: String? = nil) {
        self.id = id
        self.aadGroupID = aadGroupID
        self.displayName = displayName
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case aadGroupID = "aad_group_id"
        case displayName = "display_name"
    }
}

public struct DistributionGroupAADGroupResponse: Codable {
    /// The internal unique id (UUID) of the AAD group.
    public var id: String?
    /// The AAD unique id (UUID) of the AAD group.
    public var aadGroupID: String?
    /// The display name of the AAD group
    public var displayName: String?
    public var isAadGroup: Bool?
    /// The distribution group of the AAD group
    public var distributionGroupName: String?

    public init(id: String? = nil, aadGroupID: String? = nil, displayName: String? = nil, isAadGroup: Bool? = nil, distributionGroupName: String? = nil) {
        self.id = id
        self.aadGroupID = aadGroupID
        self.displayName = displayName
        self.isAadGroup = isAadGroup
        self.distributionGroupName = distributionGroupName
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case aadGroupID = "aad_group_id"
        case displayName = "display_name"
        case isAadGroup = "is_aad_group"
        case distributionGroupName = "distribution_group_name"
    }
}

public struct DistributionGroupAadGroupsDeleteResponse: Codable {
    /// The code of the result
    public var code: String?
    /// The message of the result
    public var message: Int?
    /// The status code of the result
    public var status: Int
    /// The aad id of the group
    public var aadGroupID: String?

    public init(code: String? = nil, message: Int? = nil, status: Int, aadGroupID: String? = nil) {
        self.code = code
        self.message = message
        self.status = status
        self.aadGroupID = aadGroupID
    }

    private enum CodingKeys: String, CodingKey {
        case code
        case message
        case status
        case aadGroupID = "aad_group_id"
    }
}

public struct DistributionGroupWithUsersResponse: Codable {
    /// The unique ID of the distribution group
    public var id: String
    /// The name of the distribution group used in URLs
    public var name: String
    /// The count of users in the distribution group
    public var totalUserCount: Double
    /// The count of aad groups in the distribution group
    public var totalGroupsCount: Double?
    /// The count of non-pending users in the distribution group who will be notified by new releases
    public var notifiedUserCount: Double
    /// Whether the distribution group is public
    public var isPublic: Bool?
    /// The distribution group users
    public var users: [User]
    /// The distribution group aad groups
    public var aadGroups: [AadGroup]?

    public struct User: Codable {
        /// The unique id (UUID) of the user
        public var id: String?
        /// The avatar URL of the user
        public var avatarURL: String?
        /// User is required to send an old password in order to change the password.
        public var canChangePassword: Bool?
        /// The full name of the user. Might for example be first and last name
        public var displayName: String?
        /// The email address of the user
        public var email: String
        /// Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".
        public var isInvitePending: Bool?
        /// The unique name that is used to identify the user.
        public var name: String?

        public init(id: String? = nil, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String? = nil, email: String, isInvitePending: Bool? = nil, name: String? = nil) {
            self.id = id
            self.avatarURL = avatarURL
            self.canChangePassword = canChangePassword
            self.displayName = displayName
            self.email = email
            self.isInvitePending = isInvitePending
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case avatarURL = "avatar_url"
            case canChangePassword = "can_change_password"
            case displayName = "display_name"
            case email
            case isInvitePending = "invite_pending"
            case name
        }
    }

    public struct AadGroup: Codable {
        /// The internal unique id (UUID) of the AAD group.
        public var id: String?
        /// The AAD unique id (UUID) of the AAD group.
        public var aadGroupID: String?
        /// The display name of the AAD group
        public var displayName: String?

        public init(id: String? = nil, aadGroupID: String? = nil, displayName: String? = nil) {
            self.id = id
            self.aadGroupID = aadGroupID
            self.displayName = displayName
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case aadGroupID = "aad_group_id"
            case displayName = "display_name"
        }
    }

    public init(id: String, name: String, totalUserCount: Double, totalGroupsCount: Double? = nil, notifiedUserCount: Double, isPublic: Bool? = nil, users: [User], aadGroups: [AadGroup]? = nil) {
        self.id = id
        self.name = name
        self.totalUserCount = totalUserCount
        self.totalGroupsCount = totalGroupsCount
        self.notifiedUserCount = notifiedUserCount
        self.isPublic = isPublic
        self.users = users
        self.aadGroups = aadGroups
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case totalUserCount = "total_user_count"
        case totalGroupsCount = "total_groups_count"
        case notifiedUserCount = "notified_user_count"
        case isPublic = "is_public"
        case users
        case aadGroups = "aad_groups"
    }
}

public struct FeatureFlagsResponse: Codable {
    public var featureFlags: [String]

    public init(featureFlags: [String]) {
        self.featureFlags = featureFlags
    }

    private enum CodingKeys: String, CodingKey {
        case featureFlags = "feature_flags"
    }
}

public struct FeatureResponse: Codable {
    /// The description of the feature
    public var description: String?
    /// The friendly name of the feature
    public var displayName: String
    /// The unique name of the feature
    public var name: String
    /// The state (unset, enabled, disabled) of the feature
    public var state: Int
    /// The creation date of the feature
    public var createdAt: String?
    /// The date the feature was last updated at
    public var updatedAt: String?

    public init(description: String? = nil, displayName: String, name: String, state: Int, createdAt: String? = nil, updatedAt: String? = nil) {
        self.description = description
        self.displayName = displayName
        self.name = name
        self.state = state
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    private enum CodingKeys: String, CodingKey {
        case description
        case displayName = "display_name"
        case name
        case state
        case createdAt = "created_at"
        case updatedAt = "updated_at"
    }
}

public struct GlobalFeatureFlagsResponse: Codable {
    /// The dictionary of global state values indexed by feature flag names
    public var value: [String: String]

    public init(value: [String: String]) {
        self.value = value
    }
}

public struct InternalUserSignupResponse: Codable {
    /// The unique id (UUID) of the user
    public var id: String
    /// The full name of the user. Might for example be first and last name
    public var displayName: String
    /// The email address of the user
    public var email: String
    /// The name of the external auth provider
    public var externalProvider: String?
    /// The user ID given by the external provider
    public var externalUserID: String?
    /// The unique name that is used to identify the user.
    public var name: String
    /// The current status of the user record after signup
    public var status: Status?

    /// The current status of the user record after signup
    public enum Status: String, Codable, CaseIterable {
        case complete = "Complete"
        case needsVerification = "NeedsVerification"
    }

    public init(id: String, displayName: String, email: String, externalProvider: String? = nil, externalUserID: String? = nil, name: String, status: Status? = nil) {
        self.id = id
        self.displayName = displayName
        self.email = email
        self.externalProvider = externalProvider
        self.externalUserID = externalUserID
        self.name = name
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case displayName = "display_name"
        case email
        case externalProvider = "external_provider"
        case externalUserID = "external_user_id"
        case name
        case status
    }
}

public struct InvitationDetailResponse: Codable {
    /// The id of the invitation
    public var invitationID: String
    public var invitedBy: InvitedBy
    public var organization: Organization?
    public var app: App?

    public struct InvitedBy: Codable {
        /// The unique id (UUID) of the user
        public var id: String
        /// The avatar URL of the user
        public var avatarURL: String?
        /// User is required to send an old password in order to change the password.
        public var canChangePassword: Bool?
        /// The full name of the user. Might for example be first and last name
        public var displayName: String
        /// The email address of the user
        public var email: String
        /// The unique name that is used to identify the user.
        public var name: String
        /// The permissions the user has for the app
        public var permissions: [Permission]?
        /// The creation origin of this user
        public var origin: Origin

        public enum Permission: String, Codable, CaseIterable {
            case manager
            case developer
            case viewer
            case tester
        }

        /// The creation origin of this user
        public enum Origin: String, Codable, CaseIterable {
            case appcenter
            case hockeyapp
            case codepush
        }

        public init(id: String, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String, email: String, name: String, permissions: [Permission]? = nil, origin: Origin) {
            self.id = id
            self.avatarURL = avatarURL
            self.canChangePassword = canChangePassword
            self.displayName = displayName
            self.email = email
            self.name = name
            self.permissions = permissions
            self.origin = origin
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case avatarURL = "avatar_url"
            case canChangePassword = "can_change_password"
            case displayName = "display_name"
            case email
            case name
            case permissions
            case origin
        }
    }

    public struct Organization: Codable {
        /// The internal unique id (UUID) of the organization.
        public var id: String
        /// The display name of the organization
        public var displayName: String
        /// The slug name of the organization
        public var name: String
        /// The URL to a user-uploaded Avatar image
        public var avatarURL: String?
        /// The creation origin of this organization
        public var origin: Origin
        /// The creation date of this organization
        public var createdAt: String
        /// The date the organization was last updated at
        public var updatedAt: String

        /// The creation origin of this organization
        public enum Origin: String, Codable, CaseIterable {
            case appcenter
            case hockeyapp
        }

        public init(id: String, displayName: String, name: String, avatarURL: String? = nil, origin: Origin, createdAt: String, updatedAt: String) {
            self.id = id
            self.displayName = displayName
            self.name = name
            self.avatarURL = avatarURL
            self.origin = origin
            self.createdAt = createdAt
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case displayName = "display_name"
            case name
            case avatarURL = "avatar_url"
            case origin
            case createdAt = "created_at"
            case updatedAt = "updated_at"
        }
    }

    public struct App: Codable {
        /// The unique ID (UUID) of the app
        public var id: String
        /// The description of the app
        public var description: String?
        /// The display name of the app
        public var displayName: String
        /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
        public var releaseType: String?
        /// The string representation of the URL pointing to the app's icon
        public var iconURL: String?
        /// The string representation of the source of the app's icon
        public var iconSource: String?
        /// The name of the app used in URLs
        public var name: String
        /// The OS the app will be running on
        public var os: Os
        /// The information about the app's owner
        public var owner: Owner
        /// A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics
        public var appSecret: String?
        public var azureSubscription: AzureSubscription?
        /// The platform of the app
        public var platform: Platform?
        /// The creation origin of this app
        public var origin: Origin?
        /// The created date of this app
        public var createdAt: String?
        /// The last updated date of this app
        public var updatedAt: String?
        /// The permissions of the calling user
        public var memberPermissions: [MemberPermission]?

        /// The OS the app will be running on
        public enum Os: String, Codable, CaseIterable {
            case android = "Android"
            case iOS
            case macOS
            case tizen = "Tizen"
            case tvOS
            case windows = "Windows"
            case linux = "Linux"
            case custom = "Custom"
        }

        /// The information about the app's owner
        public struct Owner: Codable {
            /// The unique id (UUID) of the owner
            public var id: String
            /// The avatar URL of the owner
            public var avatarURL: String?
            /// The owner's display name
            public var displayName: String
            /// The owner's email address
            public var email: String?
            /// The unique name that used to identify the owner
            public var name: String
            /// The owner type. Can either be 'org' or 'user'
            public var type: `Type`

            /// The owner type. Can either be 'org' or 'user'
            public enum `Type`: String, Codable, CaseIterable {
                case org
                case user
            }

            public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
                self.id = id
                self.avatarURL = avatarURL
                self.displayName = displayName
                self.email = email
                self.name = name
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case avatarURL = "avatar_url"
                case displayName = "display_name"
                case email
                case name
                case type
            }
        }

        public struct AzureSubscription: Codable {
            /// The azure subscription id
            public var subscriptionID: String
            /// The tenant id of the azure subscription belongs to
            public var tenantID: String
            /// The name of the azure subscription
            public var subscriptionName: String
            /// If the subscription is used for billing
            public var isBilling: Bool?
            /// If the subscription can be used for billing
            public var isBillable: Bool?
            /// If the subscription is internal Microsoft subscription
            public var isMicrosoftInternal: Bool?

            public init(subscriptionID: String, tenantID: String, subscriptionName: String, isBilling: Bool? = nil, isBillable: Bool? = nil, isMicrosoftInternal: Bool? = nil) {
                self.subscriptionID = subscriptionID
                self.tenantID = tenantID
                self.subscriptionName = subscriptionName
                self.isBilling = isBilling
                self.isBillable = isBillable
                self.isMicrosoftInternal = isMicrosoftInternal
            }

            private enum CodingKeys: String, CodingKey {
                case subscriptionID = "subscription_id"
                case tenantID = "tenant_id"
                case subscriptionName = "subscription_name"
                case isBilling = "is_billing"
                case isBillable = "is_billable"
                case isMicrosoftInternal = "is_microsoft_internal"
            }
        }

        /// The platform of the app
        public enum Platform: String, Codable, CaseIterable {
            case java = "Java"
            case objectiveCSwift = "Objective-C-Swift"
            case uwp = "UWP"
            case cordova = "Cordova"
            case reactNative = "React-Native"
            case unity = "Unity"
            case electron = "Electron"
            case xamarin = "Xamarin"
            case wpf = "WPF"
            case winForms = "WinForms"
            case unknown = "Unknown"
            case custom = "Custom"
        }

        /// The creation origin of this app
        public enum Origin: String, Codable, CaseIterable {
            case appcenter
            case hockeyapp
            case codepush
        }

        public enum MemberPermission: String, Codable, CaseIterable {
            case manager
            case developer
            case viewer
            case tester
        }

        public init(id: String, description: String? = nil, displayName: String, releaseType: String? = nil, iconURL: String? = nil, iconSource: String? = nil, name: String, os: Os, owner: Owner, appSecret: String? = nil, azureSubscription: AzureSubscription? = nil, platform: Platform? = nil, origin: Origin? = nil, createdAt: String? = nil, updatedAt: String? = nil, memberPermissions: [MemberPermission]? = nil) {
            self.id = id
            self.description = description
            self.displayName = displayName
            self.releaseType = releaseType
            self.iconURL = iconURL
            self.iconSource = iconSource
            self.name = name
            self.os = os
            self.owner = owner
            self.appSecret = appSecret
            self.azureSubscription = azureSubscription
            self.platform = platform
            self.origin = origin
            self.createdAt = createdAt
            self.updatedAt = updatedAt
            self.memberPermissions = memberPermissions
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(String.self, forKey: "id")
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
            self.displayName = try values.decode(String.self, forKey: "display_name")
            self.releaseType = try values.decodeIfPresent(String.self, forKey: "release_type")
            self.iconURL = try values.decodeIfPresent(String.self, forKey: "icon_url")
            self.iconSource = try values.decodeIfPresent(String.self, forKey: "icon_source")
            self.name = try values.decode(String.self, forKey: "name")
            self.os = try Os(from: decoder)
            self.owner = try Owner(from: decoder)
            self.appSecret = try values.decodeIfPresent(String.self, forKey: "app_secret")
            self.azureSubscription = try AzureSubscription(from: decoder)
            self.platform = try Platform(from: decoder)
            self.origin = try Origin(from: decoder)
            self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
            self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
            self.memberPermissions = try values.decodeIfPresent([MemberPermission].self, forKey: "member_permissions")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encodeIfPresent(description, forKey: "description")
            try values.encode(displayName, forKey: "display_name")
            try values.encodeIfPresent(releaseType, forKey: "release_type")
            try values.encodeIfPresent(iconURL, forKey: "icon_url")
            try values.encodeIfPresent(iconSource, forKey: "icon_source")
            try values.encode(name, forKey: "name")
            try values.encode(os, forKey: "os")
            try values.encode(owner, forKey: "owner")
            try values.encodeIfPresent(appSecret, forKey: "app_secret")
            try values.encodeIfPresent(azureSubscription, forKey: "azure_subscription")
            try values.encodeIfPresent(platform, forKey: "platform")
            try values.encodeIfPresent(origin, forKey: "origin")
            try values.encodeIfPresent(createdAt, forKey: "created_at")
            try values.encodeIfPresent(updatedAt, forKey: "updated_at")
            try values.encodeIfPresent(memberPermissions, forKey: "member_permissions")
        }
    }

    public init(invitationID: String, invitedBy: InvitedBy, organization: Organization? = nil, app: App? = nil) {
        self.invitationID = invitationID
        self.invitedBy = invitedBy
        self.organization = organization
        self.app = app
    }

    private enum CodingKeys: String, CodingKey {
        case invitationID = "invitation_id"
        case invitedBy = "invited_by"
        case organization
        case app
    }
}

public struct GDPRInvitationDetailResponse: Codable {
    /// The id of the invitation
    public var invitationID: String
    public var organization: Organization?
    public var app: App?

    public struct Organization: Codable {
        /// The internal unique id (UUID) of the organization.
        public var id: String
        /// The display name of the organization
        public var displayName: String
        /// The slug name of the organization
        public var name: String
        /// The URL to a user-uploaded Avatar image
        public var avatarURL: String?
        /// The creation origin of this organization
        public var origin: Origin
        /// The creation date of this organization
        public var createdAt: String
        /// The date the organization was last updated at
        public var updatedAt: String

        /// The creation origin of this organization
        public enum Origin: String, Codable, CaseIterable {
            case appcenter
            case hockeyapp
        }

        public init(id: String, displayName: String, name: String, avatarURL: String? = nil, origin: Origin, createdAt: String, updatedAt: String) {
            self.id = id
            self.displayName = displayName
            self.name = name
            self.avatarURL = avatarURL
            self.origin = origin
            self.createdAt = createdAt
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case displayName = "display_name"
            case name
            case avatarURL = "avatar_url"
            case origin
            case createdAt = "created_at"
            case updatedAt = "updated_at"
        }
    }

    public struct App: Codable {
        /// The unique ID (UUID) of the app
        public var id: String
        /// The description of the app
        public var description: String?
        /// The display name of the app
        public var displayName: String
        /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
        public var releaseType: String?
        /// The string representation of the URL pointing to the app's icon
        public var iconURL: String?
        /// The string representation of the source of the app's icon
        public var iconSource: String?
        /// The name of the app used in URLs
        public var name: String
        /// The OS the app will be running on
        public var os: Os
        /// The information about the app's owner
        public var owner: Owner
        /// A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics
        public var appSecret: String?
        public var azureSubscription: AzureSubscription?
        /// The platform of the app
        public var platform: Platform?
        /// The creation origin of this app
        public var origin: Origin?
        /// The created date of this app
        public var createdAt: String?
        /// The last updated date of this app
        public var updatedAt: String?
        /// The permissions of the calling user
        public var memberPermissions: [MemberPermission]?

        /// The OS the app will be running on
        public enum Os: String, Codable, CaseIterable {
            case android = "Android"
            case iOS
            case macOS
            case tizen = "Tizen"
            case tvOS
            case windows = "Windows"
            case linux = "Linux"
            case custom = "Custom"
        }

        /// The information about the app's owner
        public struct Owner: Codable {
            /// The unique id (UUID) of the owner
            public var id: String
            /// The avatar URL of the owner
            public var avatarURL: String?
            /// The owner's display name
            public var displayName: String
            /// The owner's email address
            public var email: String?
            /// The unique name that used to identify the owner
            public var name: String
            /// The owner type. Can either be 'org' or 'user'
            public var type: `Type`

            /// The owner type. Can either be 'org' or 'user'
            public enum `Type`: String, Codable, CaseIterable {
                case org
                case user
            }

            public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
                self.id = id
                self.avatarURL = avatarURL
                self.displayName = displayName
                self.email = email
                self.name = name
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case avatarURL = "avatar_url"
                case displayName = "display_name"
                case email
                case name
                case type
            }
        }

        public struct AzureSubscription: Codable {
            /// The azure subscription id
            public var subscriptionID: String
            /// The tenant id of the azure subscription belongs to
            public var tenantID: String
            /// The name of the azure subscription
            public var subscriptionName: String
            /// If the subscription is used for billing
            public var isBilling: Bool?
            /// If the subscription can be used for billing
            public var isBillable: Bool?
            /// If the subscription is internal Microsoft subscription
            public var isMicrosoftInternal: Bool?

            public init(subscriptionID: String, tenantID: String, subscriptionName: String, isBilling: Bool? = nil, isBillable: Bool? = nil, isMicrosoftInternal: Bool? = nil) {
                self.subscriptionID = subscriptionID
                self.tenantID = tenantID
                self.subscriptionName = subscriptionName
                self.isBilling = isBilling
                self.isBillable = isBillable
                self.isMicrosoftInternal = isMicrosoftInternal
            }

            private enum CodingKeys: String, CodingKey {
                case subscriptionID = "subscription_id"
                case tenantID = "tenant_id"
                case subscriptionName = "subscription_name"
                case isBilling = "is_billing"
                case isBillable = "is_billable"
                case isMicrosoftInternal = "is_microsoft_internal"
            }
        }

        /// The platform of the app
        public enum Platform: String, Codable, CaseIterable {
            case java = "Java"
            case objectiveCSwift = "Objective-C-Swift"
            case uwp = "UWP"
            case cordova = "Cordova"
            case reactNative = "React-Native"
            case unity = "Unity"
            case electron = "Electron"
            case xamarin = "Xamarin"
            case wpf = "WPF"
            case winForms = "WinForms"
            case unknown = "Unknown"
            case custom = "Custom"
        }

        /// The creation origin of this app
        public enum Origin: String, Codable, CaseIterable {
            case appcenter
            case hockeyapp
            case codepush
        }

        public enum MemberPermission: String, Codable, CaseIterable {
            case manager
            case developer
            case viewer
            case tester
        }

        public init(id: String, description: String? = nil, displayName: String, releaseType: String? = nil, iconURL: String? = nil, iconSource: String? = nil, name: String, os: Os, owner: Owner, appSecret: String? = nil, azureSubscription: AzureSubscription? = nil, platform: Platform? = nil, origin: Origin? = nil, createdAt: String? = nil, updatedAt: String? = nil, memberPermissions: [MemberPermission]? = nil) {
            self.id = id
            self.description = description
            self.displayName = displayName
            self.releaseType = releaseType
            self.iconURL = iconURL
            self.iconSource = iconSource
            self.name = name
            self.os = os
            self.owner = owner
            self.appSecret = appSecret
            self.azureSubscription = azureSubscription
            self.platform = platform
            self.origin = origin
            self.createdAt = createdAt
            self.updatedAt = updatedAt
            self.memberPermissions = memberPermissions
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(String.self, forKey: "id")
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
            self.displayName = try values.decode(String.self, forKey: "display_name")
            self.releaseType = try values.decodeIfPresent(String.self, forKey: "release_type")
            self.iconURL = try values.decodeIfPresent(String.self, forKey: "icon_url")
            self.iconSource = try values.decodeIfPresent(String.self, forKey: "icon_source")
            self.name = try values.decode(String.self, forKey: "name")
            self.os = try Os(from: decoder)
            self.owner = try Owner(from: decoder)
            self.appSecret = try values.decodeIfPresent(String.self, forKey: "app_secret")
            self.azureSubscription = try AzureSubscription(from: decoder)
            self.platform = try Platform(from: decoder)
            self.origin = try Origin(from: decoder)
            self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
            self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
            self.memberPermissions = try values.decodeIfPresent([MemberPermission].self, forKey: "member_permissions")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encodeIfPresent(description, forKey: "description")
            try values.encode(displayName, forKey: "display_name")
            try values.encodeIfPresent(releaseType, forKey: "release_type")
            try values.encodeIfPresent(iconURL, forKey: "icon_url")
            try values.encodeIfPresent(iconSource, forKey: "icon_source")
            try values.encode(name, forKey: "name")
            try values.encode(os, forKey: "os")
            try values.encode(owner, forKey: "owner")
            try values.encodeIfPresent(appSecret, forKey: "app_secret")
            try values.encodeIfPresent(azureSubscription, forKey: "azure_subscription")
            try values.encodeIfPresent(platform, forKey: "platform")
            try values.encodeIfPresent(origin, forKey: "origin")
            try values.encodeIfPresent(createdAt, forKey: "created_at")
            try values.encodeIfPresent(updatedAt, forKey: "updated_at")
            try values.encodeIfPresent(memberPermissions, forKey: "member_permissions")
        }
    }

    public init(invitationID: String, organization: Organization? = nil, app: App? = nil) {
        self.invitationID = invitationID
        self.organization = organization
        self.app = app
    }

    private enum CodingKeys: String, CodingKey {
        case invitationID = "invitation_id"
        case organization
        case app
    }
}

public struct OrgNameAvailabilityResponse: Codable {
    /// The availability status of the requested org name
    public var isAvailable: Bool
    /// The generated org name
    public var name: String

    public init(isAvailable: Bool, name: String) {
        self.isAvailable = isAvailable
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case isAvailable = "available"
        case name
    }
}

public struct OrganizationInvitationDetailResponse: Codable {
    /// The unique ID (UUID) of the invitation
    public var id: String
    public var organization: Organization
    /// The email address of the invited user
    public var email: String
    public var invitedBy: InvitedBy
    /// Indicates whether the invited user already exists
    public var isExistingUser: Bool
    /// The role assigned to the invited user
    public var role: String?

    public struct Organization: Codable {
        /// The internal unique id (UUID) of the organization.
        public var id: String
        /// The display name of the organization
        public var displayName: String
        /// The slug name of the organization
        public var name: String
        /// The URL to a user-uploaded Avatar image
        public var avatarURL: String?
        /// The creation origin of this organization
        public var origin: Origin
        /// The creation date of this organization
        public var createdAt: String
        /// The date the organization was last updated at
        public var updatedAt: String

        /// The creation origin of this organization
        public enum Origin: String, Codable, CaseIterable {
            case appcenter
            case hockeyapp
        }

        public init(id: String, displayName: String, name: String, avatarURL: String? = nil, origin: Origin, createdAt: String, updatedAt: String) {
            self.id = id
            self.displayName = displayName
            self.name = name
            self.avatarURL = avatarURL
            self.origin = origin
            self.createdAt = createdAt
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case displayName = "display_name"
            case name
            case avatarURL = "avatar_url"
            case origin
            case createdAt = "created_at"
            case updatedAt = "updated_at"
        }
    }

    public struct InvitedBy: Codable {
        /// The unique id (UUID) of the user
        public var id: String
        /// The avatar URL of the user
        public var avatarURL: String?
        /// User is required to send an old password in order to change the password.
        public var canChangePassword: Bool?
        /// The full name of the user. Might for example be first and last name
        public var displayName: String
        /// The email address of the user
        public var email: String
        /// The unique name that is used to identify the user.
        public var name: String
        /// The permissions the user has for the app
        public var permissions: [Permission]?
        /// The creation origin of this user
        public var origin: Origin

        public enum Permission: String, Codable, CaseIterable {
            case manager
            case developer
            case viewer
            case tester
        }

        /// The creation origin of this user
        public enum Origin: String, Codable, CaseIterable {
            case appcenter
            case hockeyapp
            case codepush
        }

        public init(id: String, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String, email: String, name: String, permissions: [Permission]? = nil, origin: Origin) {
            self.id = id
            self.avatarURL = avatarURL
            self.canChangePassword = canChangePassword
            self.displayName = displayName
            self.email = email
            self.name = name
            self.permissions = permissions
            self.origin = origin
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case avatarURL = "avatar_url"
            case canChangePassword = "can_change_password"
            case displayName = "display_name"
            case email
            case name
            case permissions
            case origin
        }
    }

    public init(id: String, organization: Organization, email: String, invitedBy: InvitedBy, isExistingUser: Bool, role: String? = nil) {
        self.id = id
        self.organization = organization
        self.email = email
        self.invitedBy = invitedBy
        self.isExistingUser = isExistingUser
        self.role = role
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case organization
        case email
        case invitedBy = "invited_by"
        case isExistingUser = "is_existing_user"
        case role
    }
}

public struct OrganizationInvitationSimpleDetailResponse: Codable {
    /// The unique ID (UUID) of the invitation
    public var id: String
    /// The email address of the invited user
    public var email: String
    /// The role assigned to the invited user
    public var role: String

    public init(id: String, email: String, role: String) {
        self.id = id
        self.email = email
        self.role = role
    }
}

public struct AdministeredOrgsResponse: Codable {
    public var organizations: Organizations

    public struct Organizations: Codable {
        /// The internal unique id (UUID) of the organization.
        public var id: String
        /// The display name of the organization
        public var displayName: String
        /// The slug name of the organization
        public var name: String
        /// The URL to a user-uploaded Avatar image
        public var avatarURL: String?
        /// The creation origin of this organization
        public var origin: Origin
        /// The creation date of this organization
        public var createdAt: String
        /// The date the organization was last updated at
        public var updatedAt: String

        /// The creation origin of this organization
        public enum Origin: String, Codable, CaseIterable {
            case appcenter
            case hockeyapp
        }

        public init(id: String, displayName: String, name: String, avatarURL: String? = nil, origin: Origin, createdAt: String, updatedAt: String) {
            self.id = id
            self.displayName = displayName
            self.name = name
            self.avatarURL = avatarURL
            self.origin = origin
            self.createdAt = createdAt
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case displayName = "display_name"
            case name
            case avatarURL = "avatar_url"
            case origin
            case createdAt = "created_at"
            case updatedAt = "updated_at"
        }
    }

    public init(organizations: Organizations) {
        self.organizations = organizations
    }
}

public struct OrganizationResponse: Codable {
    /// The internal unique id (UUID) of the organization.
    public var id: String
    /// The display name of the organization
    public var displayName: String
    /// The slug name of the organization
    public var name: String
    /// The URL to a user-uploaded Avatar image
    public var avatarURL: String?
    /// The creation origin of this organization
    public var origin: Origin
    /// The creation date of this organization
    public var createdAt: String
    /// The date the organization was last updated at
    public var updatedAt: String

    /// The creation origin of this organization
    public enum Origin: String, Codable, CaseIterable {
        case appcenter
        case hockeyapp
    }

    public init(id: String, displayName: String, name: String, avatarURL: String? = nil, origin: Origin, createdAt: String, updatedAt: String) {
        self.id = id
        self.displayName = displayName
        self.name = name
        self.avatarURL = avatarURL
        self.origin = origin
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case displayName = "display_name"
        case name
        case avatarURL = "avatar_url"
        case origin
        case createdAt = "created_at"
        case updatedAt = "updated_at"
    }
}

public struct OrganizationResponseInternal: Codable {
    /// The internal unique id (UUID) of the organization.
    public var id: String
    /// The display name of the organization
    public var displayName: String
    /// The slug name of the organization
    public var name: String
    /// The URL to a user-uploaded Avatar image
    public var avatarURL: String?
    /// The creation origin of this organization
    public var origin: Origin
    /// The creation date of this organization
    public var createdAt: String
    /// The date the organization was last updated at
    public var updatedAt: String
    /// The feature flags that are enabled for this organization
    public var featureFlags: [String]?

    /// The creation origin of this organization
    public enum Origin: String, Codable, CaseIterable {
        case appcenter
        case hockeyapp
    }

    public init(id: String, displayName: String, name: String, avatarURL: String? = nil, origin: Origin, createdAt: String, updatedAt: String, featureFlags: [String]? = nil) {
        self.id = id
        self.displayName = displayName
        self.name = name
        self.avatarURL = avatarURL
        self.origin = origin
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.featureFlags = featureFlags
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.displayName = try values.decode(String.self, forKey: "display_name")
        self.name = try values.decode(String.self, forKey: "name")
        self.avatarURL = try values.decodeIfPresent(String.self, forKey: "avatar_url")
        self.origin = try Origin(from: decoder)
        self.createdAt = try values.decode(String.self, forKey: "created_at")
        self.updatedAt = try values.decode(String.self, forKey: "updated_at")
        self.featureFlags = try values.decodeIfPresent([String].self, forKey: "feature_flags")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(displayName, forKey: "display_name")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(avatarURL, forKey: "avatar_url")
        try values.encode(origin, forKey: "origin")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(featureFlags, forKey: "feature_flags")
    }
}

public struct OrganizationResponseManagement: Codable {
    public var a: A
    /// The organization email, if the app was synced from HockeyApp
    public var email: String?
    /// The date when the organization was created
    public var createdAt: String?
    /// The date when the organization was updated
    public var updatedAt: String?

    public struct A: Codable {
        /// The internal unique id (UUID) of the organization.
        public var id: String
        /// The display name of the organization
        public var displayName: String
        /// The slug name of the organization
        public var name: String
        /// The URL to a user-uploaded Avatar image
        public var avatarURL: String?
        /// The creation origin of this organization
        public var origin: Origin
        /// The creation date of this organization
        public var createdAt: String
        /// The date the organization was last updated at
        public var updatedAt: String
        /// The feature flags that are enabled for this organization
        public var featureFlags: [String]?

        /// The creation origin of this organization
        public enum Origin: String, Codable, CaseIterable {
            case appcenter
            case hockeyapp
        }

        public init(id: String, displayName: String, name: String, avatarURL: String? = nil, origin: Origin, createdAt: String, updatedAt: String, featureFlags: [String]? = nil) {
            self.id = id
            self.displayName = displayName
            self.name = name
            self.avatarURL = avatarURL
            self.origin = origin
            self.createdAt = createdAt
            self.updatedAt = updatedAt
            self.featureFlags = featureFlags
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(String.self, forKey: "id")
            self.displayName = try values.decode(String.self, forKey: "display_name")
            self.name = try values.decode(String.self, forKey: "name")
            self.avatarURL = try values.decodeIfPresent(String.self, forKey: "avatar_url")
            self.origin = try Origin(from: decoder)
            self.createdAt = try values.decode(String.self, forKey: "created_at")
            self.updatedAt = try values.decode(String.self, forKey: "updated_at")
            self.featureFlags = try values.decodeIfPresent([String].self, forKey: "feature_flags")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encode(displayName, forKey: "display_name")
            try values.encode(name, forKey: "name")
            try values.encodeIfPresent(avatarURL, forKey: "avatar_url")
            try values.encode(origin, forKey: "origin")
            try values.encode(createdAt, forKey: "created_at")
            try values.encode(updatedAt, forKey: "updated_at")
            try values.encodeIfPresent(featureFlags, forKey: "feature_flags")
        }
    }

    public init(a: A, email: String? = nil, createdAt: String? = nil, updatedAt: String? = nil) {
        self.a = a
        self.email = email
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.a = try A(from: decoder)
        self.email = try values.decodeIfPresent(String.self, forKey: "email")
        self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
        self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(a, forKey: "a")
        try values.encodeIfPresent(email, forKey: "email")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(updatedAt, forKey: "updated_at")
    }
}

public struct OrganizationUserResponse: Codable {
    /// The email address of the user
    public var email: String
    /// The full name of the user. Might for example be first and last name
    public var displayName: String
    /// The date when the user joined the organization
    public var joinedAt: String
    /// The unique name that is used to identify the user.
    public var name: String
    /// The role the user has within the organization
    public var role: String

    public init(email: String, displayName: String, joinedAt: String, name: String, role: String) {
        self.email = email
        self.displayName = displayName
        self.joinedAt = joinedAt
        self.name = name
        self.role = role
    }

    private enum CodingKeys: String, CodingKey {
        case email
        case displayName = "display_name"
        case joinedAt = "joined_at"
        case name
        case role
    }
}

public struct TeamAppUpdateRequest: Codable {
    /// The permissions all members of the team have on the app
    public var permissions: [Permission]

    public enum Permission: String, Codable, CaseIterable {
        case manager
        case developer
        case viewer
    }

    public init(permissions: [Permission]) {
        self.permissions = permissions
    }
}

public struct TeamRequest: Codable {
    /// The display name of the team
    public var displayName: String
    /// The name of the team
    public var name: String?
    /// The description of the team
    public var description: String?

    public init(displayName: String, name: String? = nil, description: String? = nil) {
        self.displayName = displayName
        self.name = name
        self.description = description
    }

    private enum CodingKeys: String, CodingKey {
        case displayName = "display_name"
        case name
        case description
    }
}

public struct TeamUpdateRequest: Codable {
    /// The new display name of the team
    public var displayName: String

    public init(displayName: String) {
        self.displayName = displayName
    }

    private enum CodingKeys: String, CodingKey {
        case displayName = "display_name"
    }
}

public struct TeamResponse: Codable {
    /// The internal unique id (UUID) of the team.
    public var id: String
    /// The name of the team
    public var name: String
    /// The display name of the team
    public var displayName: String
    /// The description of the team
    public var description: String?

    public init(id: String, name: String, displayName: String, description: String? = nil) {
        self.id = id
        self.name = name
        self.displayName = displayName
        self.description = description
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case displayName = "display_name"
        case description
    }
}

public struct TeamAppResponse: Codable {
    /// The internal unique id (UUID) of the team.
    public var id: String
    /// The name of the team
    public var name: String
    /// The display name of the team
    public var displayName: String
    /// The description of the team
    public var description: String?
    /// The permissions the team has for the app
    public var permissions: [Permission]?

    public enum Permission: String, Codable, CaseIterable {
        case manager
        case developer
        case viewer
        case tester
    }

    public init(id: String, name: String, displayName: String, description: String? = nil, permissions: [Permission]? = nil) {
        self.id = id
        self.name = name
        self.displayName = displayName
        self.description = description
        self.permissions = permissions
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.name = try values.decode(String.self, forKey: "name")
        self.displayName = try values.decode(String.self, forKey: "display_name")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.permissions = try values.decodeIfPresent([Permission].self, forKey: "permissions")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(name, forKey: "name")
        try values.encode(displayName, forKey: "display_name")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(permissions, forKey: "permissions")
    }
}

public struct StatusResponse: Codable {
    public var status: String

    public init(status: String) {
        self.status = status
    }
}

public struct ServiceBusStatusResponse: Codable {
    public var status: String
    public var subscriptions: [Subscription]?

    public struct Subscription: Codable {
        /// The name of the subsciption (prefixed with the topic name)
        public var name: String
        /// The number of messages in the subscription
        public var messageCount: Double

        public init(name: String, messageCount: Double) {
            self.name = name
            self.messageCount = messageCount
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case messageCount = "message_count"
        }
    }

    public init(status: String, subscriptions: [Subscription]? = nil) {
        self.status = status
        self.subscriptions = subscriptions
    }
}

public struct SubscriptionMetrics: Codable {
    /// The name of the subsciption (prefixed with the topic name)
    public var name: String
    /// The number of messages in the subscription
    public var messageCount: Double

    public init(name: String, messageCount: Double) {
        self.name = name
        self.messageCount = messageCount
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case messageCount = "message_count"
    }
}

public struct TeamUserResponse: Codable {
    /// The email address of the user
    public var email: String
    /// The full name of the user. Might for example be first and last name
    public var displayName: String
    /// The unique name that is used to identify the user.
    public var name: String
    /// The role of the user has within the team
    public var role: Role

    /// The role of the user has within the team
    public enum Role: String, Codable, CaseIterable {
        case maintainer
        case collaborator
    }

    public init(email: String, displayName: String, name: String, role: Role) {
        self.email = email
        self.displayName = displayName
        self.name = name
        self.role = role
    }

    private enum CodingKeys: String, CodingKey {
        case email
        case displayName = "display_name"
        case name
        case role
    }
}

public struct UserAuthResponse: Codable {
    /// The unique id (UUID) of the user
    public var id: String
    /// The full name of the user. Might for example be first and last name
    public var displayName: String
    /// The email address of the user
    public var email: String
    /// The name of the external auth provider
    public var externalProvider: String?
    /// The user ID given by the external provider
    public var externalUserID: String?
    /// The unique name that is used to identify the user
    public var name: String
    /// The creation origin of this user
    public var origin: Origin

    /// The creation origin of this user
    public enum Origin: String, Codable, CaseIterable {
        case appcenter
        case hockeyapp
        case codepush
    }

    public init(id: String, displayName: String, email: String, externalProvider: String? = nil, externalUserID: String? = nil, name: String, origin: Origin) {
        self.id = id
        self.displayName = displayName
        self.email = email
        self.externalProvider = externalProvider
        self.externalUserID = externalUserID
        self.name = name
        self.origin = origin
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case displayName = "display_name"
        case email
        case externalProvider = "external_provider"
        case externalUserID = "external_user_id"
        case name
        case origin
    }
}

public struct UserLiteProfileResponse: Codable {
    /// The unique id (UUID) of the user
    public var id: String
    /// The full name of the user. Might for example be first and last name
    public var displayName: String
    /// The email address of the user
    public var email: String

    public init(id: String, displayName: String, email: String) {
        self.id = id
        self.displayName = displayName
        self.email = email
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case displayName = "display_name"
        case email
    }
}

public struct UserNameAvailabilityResponse: Codable {
    /// The availability status of the requested user name
    public var isAvailable: Bool
    /// The requested user name
    public var name: String

    public init(isAvailable: Bool, name: String) {
        self.isAvailable = isAvailable
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case isAvailable = "available"
        case name
    }
}

public struct AppMembershipsResponse: Codable {
    /// The app's origin
    public var appOrigin: String?
    /// An array of all ways a user has access to the app, based on the app_memberships table.
    public var memberships: [Membership]?

    public struct Membership: Codable {
        public var appID: String?
        public var userID: String?
        public var permissions: [String]?
        public var origin: Origin?
        public var sourceType: SourceType?
        public var sourceID: String?

        public enum Origin: String, Codable, CaseIterable {
            case appcenter
            case hockeyapp
            case codepush
            case testcloud
            case hockeyappDogfood = "hockeyapp-dogfood"
        }

        public enum SourceType: String, Codable, CaseIterable {
            case user
            case org
            case distributionGroup = "distribution_group"
            case team
            case release
        }

        public init(appID: String? = nil, userID: String? = nil, permissions: [String]? = nil, origin: Origin? = nil, sourceType: SourceType? = nil, sourceID: String? = nil) {
            self.appID = appID
            self.userID = userID
            self.permissions = permissions
            self.origin = origin
            self.sourceType = sourceType
            self.sourceID = sourceID
        }

        private enum CodingKeys: String, CodingKey {
            case appID = "app_id"
            case userID = "user_id"
            case permissions
            case origin
            case sourceType = "source_type"
            case sourceID = "source_id"
        }
    }

    public init(appOrigin: String? = nil, memberships: [Membership]? = nil) {
        self.appOrigin = appOrigin
        self.memberships = memberships
    }

    private enum CodingKeys: String, CodingKey {
        case appOrigin = "app_origin"
        case memberships
    }
}

public struct AppMembership: Codable {
    public var appID: String?
    public var userID: String?
    public var permissions: [String]?
    public var origin: Origin?
    public var sourceType: SourceType?
    public var sourceID: String?

    public enum Origin: String, Codable, CaseIterable {
        case appcenter
        case hockeyapp
        case codepush
        case testcloud
        case hockeyappDogfood = "hockeyapp-dogfood"
    }

    public enum SourceType: String, Codable, CaseIterable {
        case user
        case org
        case distributionGroup = "distribution_group"
        case team
        case release
    }

    public init(appID: String? = nil, userID: String? = nil, permissions: [String]? = nil, origin: Origin? = nil, sourceType: SourceType? = nil, sourceID: String? = nil) {
        self.appID = appID
        self.userID = userID
        self.permissions = permissions
        self.origin = origin
        self.sourceType = sourceType
        self.sourceID = sourceID
    }

    private enum CodingKeys: String, CodingKey {
        case appID = "app_id"
        case userID = "user_id"
        case permissions
        case origin
        case sourceType = "source_type"
        case sourceID = "source_id"
    }
}

public struct AppMembershipsValidationResponse: Codable {
    public var excessAppMemberships: ExcessAppMemberships?
    public var appUsersWithMissingMemberships: [AppUsersWithMissingMembership]?
    public var distributionGroupUsersWithMissingMemberships: [DistributionGroupUsersWithMissingMembership]?
    public var organizationAdminsWithMissingMemberships: [OrganizationAdminsWithMissingMembership]?

    public struct ExcessAppMemberships: Codable {
        public var appUsersMemberships: [AppUsersMembership]?
        public var distributionGroupMemberships: [DistributionGroupMembership]?
        public var organizationAdminMemberships: [OrganizationAdminMembership]?

        public struct AppUsersMembership: Codable {
            public var appID: String?
            public var userID: String?
            public var permissions: [String]?
            public var origin: Origin?
            public var sourceType: SourceType?
            public var sourceID: String?

            public enum Origin: String, Codable, CaseIterable {
                case appcenter
                case hockeyapp
                case codepush
                case testcloud
                case hockeyappDogfood = "hockeyapp-dogfood"
            }

            public enum SourceType: String, Codable, CaseIterable {
                case user
                case org
                case distributionGroup = "distribution_group"
                case team
                case release
            }

            public init(appID: String? = nil, userID: String? = nil, permissions: [String]? = nil, origin: Origin? = nil, sourceType: SourceType? = nil, sourceID: String? = nil) {
                self.appID = appID
                self.userID = userID
                self.permissions = permissions
                self.origin = origin
                self.sourceType = sourceType
                self.sourceID = sourceID
            }

            private enum CodingKeys: String, CodingKey {
                case appID = "app_id"
                case userID = "user_id"
                case permissions
                case origin
                case sourceType = "source_type"
                case sourceID = "source_id"
            }
        }

        public struct DistributionGroupMembership: Codable {
            public var appID: String?
            public var userID: String?
            public var permissions: [String]?
            public var origin: Origin?
            public var sourceType: SourceType?
            public var sourceID: String?

            public enum Origin: String, Codable, CaseIterable {
                case appcenter
                case hockeyapp
                case codepush
                case testcloud
                case hockeyappDogfood = "hockeyapp-dogfood"
            }

            public enum SourceType: String, Codable, CaseIterable {
                case user
                case org
                case distributionGroup = "distribution_group"
                case team
                case release
            }

            public init(appID: String? = nil, userID: String? = nil, permissions: [String]? = nil, origin: Origin? = nil, sourceType: SourceType? = nil, sourceID: String? = nil) {
                self.appID = appID
                self.userID = userID
                self.permissions = permissions
                self.origin = origin
                self.sourceType = sourceType
                self.sourceID = sourceID
            }

            private enum CodingKeys: String, CodingKey {
                case appID = "app_id"
                case userID = "user_id"
                case permissions
                case origin
                case sourceType = "source_type"
                case sourceID = "source_id"
            }
        }

        public struct OrganizationAdminMembership: Codable {
            public var appID: String?
            public var userID: String?
            public var permissions: [String]?
            public var origin: Origin?
            public var sourceType: SourceType?
            public var sourceID: String?

            public enum Origin: String, Codable, CaseIterable {
                case appcenter
                case hockeyapp
                case codepush
                case testcloud
                case hockeyappDogfood = "hockeyapp-dogfood"
            }

            public enum SourceType: String, Codable, CaseIterable {
                case user
                case org
                case distributionGroup = "distribution_group"
                case team
                case release
            }

            public init(appID: String? = nil, userID: String? = nil, permissions: [String]? = nil, origin: Origin? = nil, sourceType: SourceType? = nil, sourceID: String? = nil) {
                self.appID = appID
                self.userID = userID
                self.permissions = permissions
                self.origin = origin
                self.sourceType = sourceType
                self.sourceID = sourceID
            }

            private enum CodingKeys: String, CodingKey {
                case appID = "app_id"
                case userID = "user_id"
                case permissions
                case origin
                case sourceType = "source_type"
                case sourceID = "source_id"
            }
        }

        public init(appUsersMemberships: [AppUsersMembership]? = nil, distributionGroupMemberships: [DistributionGroupMembership]? = nil, organizationAdminMemberships: [OrganizationAdminMembership]? = nil) {
            self.appUsersMemberships = appUsersMemberships
            self.distributionGroupMemberships = distributionGroupMemberships
            self.organizationAdminMemberships = organizationAdminMemberships
        }

        private enum CodingKeys: String, CodingKey {
            case appUsersMemberships = "app_users_memberships"
            case distributionGroupMemberships = "distribution_group_memberships"
            case organizationAdminMemberships = "organization_admin_memberships"
        }
    }

    public struct AppUsersWithMissingMembership: Codable {
        public var appID: String?
        public var userID: String?
        public var permissions: [String]?
        public var origin: String?

        public init(appID: String? = nil, userID: String? = nil, permissions: [String]? = nil, origin: String? = nil) {
            self.appID = appID
            self.userID = userID
            self.permissions = permissions
            self.origin = origin
        }

        private enum CodingKeys: String, CodingKey {
            case appID = "app_id"
            case userID = "user_id"
            case permissions
            case origin
        }
    }

    public struct DistributionGroupUsersWithMissingMembership: Codable {
        public var distributionGroupID: String?
        public var userID: String?
        public var origin: String?

        public init(distributionGroupID: String? = nil, userID: String? = nil, origin: String? = nil) {
            self.distributionGroupID = distributionGroupID
            self.userID = userID
            self.origin = origin
        }

        private enum CodingKeys: String, CodingKey {
            case distributionGroupID = "distribution_group_id"
            case userID = "user_id"
            case origin
        }
    }

    public struct OrganizationAdminsWithMissingMembership: Codable {
        public var organizationID: String?
        public var userID: String?
        public var role: String?
        public var origin: String?

        public init(organizationID: String? = nil, userID: String? = nil, role: String? = nil, origin: String? = nil) {
            self.organizationID = organizationID
            self.userID = userID
            self.role = role
            self.origin = origin
        }

        private enum CodingKeys: String, CodingKey {
            case organizationID = "organization_id"
            case userID = "user_id"
            case role
            case origin
        }
    }

    public init(excessAppMemberships: ExcessAppMemberships? = nil, appUsersWithMissingMemberships: [AppUsersWithMissingMembership]? = nil, distributionGroupUsersWithMissingMemberships: [DistributionGroupUsersWithMissingMembership]? = nil, organizationAdminsWithMissingMemberships: [OrganizationAdminsWithMissingMembership]? = nil) {
        self.excessAppMemberships = excessAppMemberships
        self.appUsersWithMissingMemberships = appUsersWithMissingMemberships
        self.distributionGroupUsersWithMissingMemberships = distributionGroupUsersWithMissingMemberships
        self.organizationAdminsWithMissingMemberships = organizationAdminsWithMissingMemberships
    }

    private enum CodingKeys: String, CodingKey {
        case excessAppMemberships = "excess_app_memberships"
        case appUsersWithMissingMemberships = "app_users_with_missing_memberships"
        case distributionGroupUsersWithMissingMemberships = "distribution_group_users_with_missing_memberships"
        case organizationAdminsWithMissingMemberships = "organization_admins_with_missing_memberships"
    }
}

public struct UserProfileResponse: Codable {
    /// The unique id (UUID) of the user
    public var id: String
    /// The avatar URL of the user
    public var avatarURL: String?
    /// User is required to send an old password in order to change the password.
    public var canChangePassword: Bool?
    /// The full name of the user. Might for example be first and last name
    public var displayName: String
    /// The email address of the user
    public var email: String
    /// The unique name that is used to identify the user.
    public var name: String
    /// The permissions the user has for the app
    public var permissions: [Permission]?
    /// The creation origin of this user
    public var origin: Origin

    public enum Permission: String, Codable, CaseIterable {
        case manager
        case developer
        case viewer
        case tester
    }

    /// The creation origin of this user
    public enum Origin: String, Codable, CaseIterable {
        case appcenter
        case hockeyapp
        case codepush
    }

    public init(id: String, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String, email: String, name: String, permissions: [Permission]? = nil, origin: Origin) {
        self.id = id
        self.avatarURL = avatarURL
        self.canChangePassword = canChangePassword
        self.displayName = displayName
        self.email = email
        self.name = name
        self.permissions = permissions
        self.origin = origin
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case avatarURL = "avatar_url"
        case canChangePassword = "can_change_password"
        case displayName = "display_name"
        case email
        case name
        case permissions
        case origin
    }
}

public struct UserProfileAdminResponse: Codable {
    /// The unique id (UUID) of the user
    public var id: String
    /// The avatar URL of the user
    public var avatarURL: String?
    /// User is required to send an old password in order to change the password.
    public var canChangePassword: Bool?
    /// The full name of the user. Might for example be first and last name
    public var displayName: String
    /// The email address of the user
    public var email: String
    /// The unique name that is used to identify the user.
    public var name: String
    /// The permissions the user has for the app
    public var permissions: [Permission]?
    /// The creation origin of this user
    public var origin: Origin
    /// The user's role in the organization
    public var role: Role?

    public enum Permission: String, Codable, CaseIterable {
        case manager
        case developer
        case viewer
        case tester
    }

    /// The creation origin of this user
    public enum Origin: String, Codable, CaseIterable {
        case appcenter
        case hockeyapp
        case codepush
    }

    /// The user's role in the organization
    public enum Role: String, Codable, CaseIterable {
        case admin
        case collaborator
        case member
    }

    public init(id: String, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String, email: String, name: String, permissions: [Permission]? = nil, origin: Origin, role: Role? = nil) {
        self.id = id
        self.avatarURL = avatarURL
        self.canChangePassword = canChangePassword
        self.displayName = displayName
        self.email = email
        self.name = name
        self.permissions = permissions
        self.origin = origin
        self.role = role
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.avatarURL = try values.decodeIfPresent(String.self, forKey: "avatar_url")
        self.canChangePassword = try values.decodeIfPresent(Bool.self, forKey: "can_change_password")
        self.displayName = try values.decode(String.self, forKey: "display_name")
        self.email = try values.decode(String.self, forKey: "email")
        self.name = try values.decode(String.self, forKey: "name")
        self.permissions = try values.decodeIfPresent([Permission].self, forKey: "permissions")
        self.origin = try Origin(from: decoder)
        self.role = try Role(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(avatarURL, forKey: "avatar_url")
        try values.encodeIfPresent(canChangePassword, forKey: "can_change_password")
        try values.encode(displayName, forKey: "display_name")
        try values.encode(email, forKey: "email")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(permissions, forKey: "permissions")
        try values.encode(origin, forKey: "origin")
        try values.encodeIfPresent(role, forKey: "role")
    }
}

public struct UserProfileResponseInternal: Codable {
    /// The unique id (UUID) of the user
    public var id: String
    /// The avatar URL of the user
    public var avatarURL: String?
    /// User is required to send an old password in order to change the password.
    public var canChangePassword: Bool?
    /// The full name of the user. Might for example be first and last name
    public var displayName: String
    /// The email address of the user
    public var email: String
    /// The unique name that is used to identify the user.
    public var name: String
    /// The permissions the user has for the app
    public var permissions: [Permission]?
    /// The creation origin of this user
    public var origin: Origin
    /// The feature flags that are enabled for this app
    public var featureFlags: [String]?
    /// The new admin_role
    public var adminRole: AdminRole?
    /// The user's settings
    public var settings: Settings?

    public enum Permission: String, Codable, CaseIterable {
        case manager
        case developer
        case viewer
        case tester
    }

    /// The creation origin of this user
    public enum Origin: String, Codable, CaseIterable {
        case appcenter
        case hockeyapp
        case codepush
    }

    /// The new admin_role
    public enum AdminRole: String, Codable, CaseIterable {
        case superAdmin
        case admin
        case devOps
        case customerSupport
        case notAdmin
    }

    /// The user's settings
    public struct Settings: Codable {
        /// The marketing opt-in setting
        public var marketingOptIn: String?

        public init(marketingOptIn: String? = nil) {
            self.marketingOptIn = marketingOptIn
        }

        private enum CodingKeys: String, CodingKey {
            case marketingOptIn = "marketing_opt_in"
        }
    }

    public init(id: String, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String, email: String, name: String, permissions: [Permission]? = nil, origin: Origin, featureFlags: [String]? = nil, adminRole: AdminRole? = nil, settings: Settings? = nil) {
        self.id = id
        self.avatarURL = avatarURL
        self.canChangePassword = canChangePassword
        self.displayName = displayName
        self.email = email
        self.name = name
        self.permissions = permissions
        self.origin = origin
        self.featureFlags = featureFlags
        self.adminRole = adminRole
        self.settings = settings
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.avatarURL = try values.decodeIfPresent(String.self, forKey: "avatar_url")
        self.canChangePassword = try values.decodeIfPresent(Bool.self, forKey: "can_change_password")
        self.displayName = try values.decode(String.self, forKey: "display_name")
        self.email = try values.decode(String.self, forKey: "email")
        self.name = try values.decode(String.self, forKey: "name")
        self.permissions = try values.decodeIfPresent([Permission].self, forKey: "permissions")
        self.origin = try Origin(from: decoder)
        self.featureFlags = try values.decodeIfPresent([String].self, forKey: "feature_flags")
        self.adminRole = try AdminRole(from: decoder)
        self.settings = try Settings(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(avatarURL, forKey: "avatar_url")
        try values.encodeIfPresent(canChangePassword, forKey: "can_change_password")
        try values.encode(displayName, forKey: "display_name")
        try values.encode(email, forKey: "email")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(permissions, forKey: "permissions")
        try values.encode(origin, forKey: "origin")
        try values.encodeIfPresent(featureFlags, forKey: "feature_flags")
        try values.encodeIfPresent(adminRole, forKey: "admin_role")
        try values.encodeIfPresent(settings, forKey: "settings")
    }
}

public struct UserProfileResponseManagement: Codable {
    public var a: A
    /// The date when the app was last updated
    public var updatedAt: String?
    /// A boolean flag that indicates if the user is already verified
    public var isVerified: Bool?
    /// The identity providers associated with the user's account
    public var identityProviders: [IdentityProvider]?

    public struct A: Codable {
        /// The unique id (UUID) of the user
        public var id: String
        /// The avatar URL of the user
        public var avatarURL: String?
        /// User is required to send an old password in order to change the password.
        public var canChangePassword: Bool?
        /// The full name of the user. Might for example be first and last name
        public var displayName: String
        /// The email address of the user
        public var email: String
        /// The unique name that is used to identify the user.
        public var name: String
        /// The permissions the user has for the app
        public var permissions: [Permission]?
        /// The creation origin of this user
        public var origin: Origin
        /// The feature flags that are enabled for this app
        public var featureFlags: [String]?
        /// The new admin_role
        public var adminRole: AdminRole?
        /// The user's settings
        public var settings: Settings?

        public enum Permission: String, Codable, CaseIterable {
            case manager
            case developer
            case viewer
            case tester
        }

        /// The creation origin of this user
        public enum Origin: String, Codable, CaseIterable {
            case appcenter
            case hockeyapp
            case codepush
        }

        /// The new admin_role
        public enum AdminRole: String, Codable, CaseIterable {
            case superAdmin
            case admin
            case devOps
            case customerSupport
            case notAdmin
        }

        /// The user's settings
        public struct Settings: Codable {
            /// The marketing opt-in setting
            public var marketingOptIn: String?

            public init(marketingOptIn: String? = nil) {
                self.marketingOptIn = marketingOptIn
            }

            private enum CodingKeys: String, CodingKey {
                case marketingOptIn = "marketing_opt_in"
            }
        }

        public init(id: String, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String, email: String, name: String, permissions: [Permission]? = nil, origin: Origin, featureFlags: [String]? = nil, adminRole: AdminRole? = nil, settings: Settings? = nil) {
            self.id = id
            self.avatarURL = avatarURL
            self.canChangePassword = canChangePassword
            self.displayName = displayName
            self.email = email
            self.name = name
            self.permissions = permissions
            self.origin = origin
            self.featureFlags = featureFlags
            self.adminRole = adminRole
            self.settings = settings
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(String.self, forKey: "id")
            self.avatarURL = try values.decodeIfPresent(String.self, forKey: "avatar_url")
            self.canChangePassword = try values.decodeIfPresent(Bool.self, forKey: "can_change_password")
            self.displayName = try values.decode(String.self, forKey: "display_name")
            self.email = try values.decode(String.self, forKey: "email")
            self.name = try values.decode(String.self, forKey: "name")
            self.permissions = try values.decodeIfPresent([Permission].self, forKey: "permissions")
            self.origin = try Origin(from: decoder)
            self.featureFlags = try values.decodeIfPresent([String].self, forKey: "feature_flags")
            self.adminRole = try AdminRole(from: decoder)
            self.settings = try Settings(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encodeIfPresent(avatarURL, forKey: "avatar_url")
            try values.encodeIfPresent(canChangePassword, forKey: "can_change_password")
            try values.encode(displayName, forKey: "display_name")
            try values.encode(email, forKey: "email")
            try values.encode(name, forKey: "name")
            try values.encodeIfPresent(permissions, forKey: "permissions")
            try values.encode(origin, forKey: "origin")
            try values.encodeIfPresent(featureFlags, forKey: "feature_flags")
            try values.encodeIfPresent(adminRole, forKey: "admin_role")
            try values.encodeIfPresent(settings, forKey: "settings")
        }
    }

    public struct IdentityProvider: Codable {
        /// The name of the identity provider type
        public var providerName: ProviderName?
        /// Whether the identity provider originated in HockeyApp or App Center
        public var origin: String?

        /// The name of the identity provider type
        public enum ProviderName: String, Codable, CaseIterable {
            case github
            case aad
            case facebook
            case google
        }

        public init(providerName: ProviderName? = nil, origin: String? = nil) {
            self.providerName = providerName
            self.origin = origin
        }

        private enum CodingKeys: String, CodingKey {
            case providerName = "provider_name"
            case origin
        }
    }

    public init(a: A, updatedAt: String? = nil, isVerified: Bool? = nil, identityProviders: [IdentityProvider]? = nil) {
        self.a = a
        self.updatedAt = updatedAt
        self.isVerified = isVerified
        self.identityProviders = identityProviders
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.a = try A(from: decoder)
        self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
        self.isVerified = try values.decodeIfPresent(Bool.self, forKey: "verified")
        self.identityProviders = try values.decodeIfPresent([IdentityProvider].self, forKey: "identity_providers")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(a, forKey: "a")
        try values.encodeIfPresent(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(isVerified, forKey: "verified")
        try values.encodeIfPresent(identityProviders, forKey: "identity_providers")
    }
}

/// A user's setting
public struct UserSettingResponse: Codable {
    /// The marketing opt-in setting
    public var marketingOptIn: String?

    public init(marketingOptIn: String? = nil) {
        self.marketingOptIn = marketingOptIn
    }

    private enum CodingKeys: String, CodingKey {
        case marketingOptIn = "marketing_opt_in"
    }
}

/// The information about the app's owner
public struct Owner: Codable {
    /// The unique id (UUID) of the owner
    public var id: String
    /// The avatar URL of the owner
    public var avatarURL: String?
    /// The owner's display name
    public var displayName: String
    /// The owner's email address
    public var email: String?
    /// The unique name that used to identify the owner
    public var name: String
    /// The owner type. Can either be 'org' or 'user'
    public var type: `Type`

    /// The owner type. Can either be 'org' or 'user'
    public enum `Type`: String, Codable, CaseIterable {
        case org
        case user
    }

    public init(id: String, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
        self.id = id
        self.avatarURL = avatarURL
        self.displayName = displayName
        self.email = email
        self.name = name
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case avatarURL = "avatar_url"
        case displayName = "display_name"
        case email
        case name
        case type
    }
}

public struct AADGroup: Codable {
    /// The id of the aad group
    public var aadGroupID: String
    /// The id of the aad tenant
    public var tenantID: String
    /// The display name of the aad group
    public var displayName: String

    public init(aadGroupID: String, tenantID: String, displayName: String) {
        self.aadGroupID = aadGroupID
        self.tenantID = tenantID
        self.displayName = displayName
    }

    private enum CodingKeys: String, CodingKey {
        case aadGroupID = "aad_group_id"
        case tenantID = "tenant_id"
        case displayName = "display_name"
    }
}

/// An AAD user's id and tenant id
public struct AADUser: Codable {
    /// The aad user's id
    public var objectID: String
    /// The aad user's tenant id
    public var tenantID: String

    public init(objectID: String, tenantID: String) {
        self.objectID = objectID
        self.tenantID = tenantID
    }

    private enum CodingKeys: String, CodingKey {
        case objectID = "object_id"
        case tenantID = "tenant_id"
    }
}

/// An MSA user's hex CID
public struct MSAUser: Codable {
    /// The user's CID
    public var hexcid: String

    public init(hexcid: String) {
        self.hexcid = hexcid
    }
}

public struct LinkAADtoUserRequest: Codable {
    /// An array of AAD tenant data needed to link the user to the tenants
    public var aadTenantIDs: [String]
    /// The role of the user to be added
    public var role: Role?

    /// The role of the user to be added
    public enum Role: String, Codable, CaseIterable {
        case admin
        case collaborator
        case member
    }

    public init(aadTenantIDs: [String], role: Role? = nil) {
        self.aadTenantIDs = aadTenantIDs
        self.role = role
    }

    private enum CodingKeys: String, CodingKey {
        case aadTenantIDs = "aad_tenant_ids"
        case role
    }
}

public struct AddUserAsRoleRequest: Codable {
    /// The role of the user to be added
    public var role: Role?

    /// The role of the user to be added
    public enum Role: String, Codable, CaseIterable {
        case admin
        case collaborator
        case member
    }

    public init(role: Role? = nil) {
        self.role = role
    }
}

public struct OrganizationAadGroupPatchRequest: Codable {
    /// The user's role in the organizatiion
    public var role: Role?

    /// The user's role in the organizatiion
    public enum Role: String, Codable, CaseIterable {
        case admin
        case collaborator
        case member
    }

    public init(role: Role? = nil) {
        self.role = role
    }
}

public struct AddAADGroupResponse: Codable {
    /// The unique ID (UUID) of the aad group
    public var id: String?

    public init(id: String? = nil) {
        self.id = id
    }
}

/// Shared connection patch request
public struct SharedConnectionPatchRequest: Codable {
    /// Display name of the shared connection
    public var displayName: String?
    /// Represents the data for connecting to service
    public var data: [String: AnyJSON]

    public init(displayName: String? = nil, data: [String: AnyJSON]) {
        self.displayName = displayName
        self.data = data
    }
}

/// SharedConnectionRequest
public struct SharedConnectionRequest: Codable {
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public var serviceType: ServiceType
    /// Credential type of the shared connection. Values can be credentials|certificate
    public var credentialType: CredentialType?
    /// Shared connection details
    public var data: Data?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// Credential type of the shared connection. Values can be credentials|certificate
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    /// Shared connection details
    public struct Data: Codable {
        /// Username to connect to shared connection.
        public var username: String?
        /// Password to connect to shared connection.
        public var password: String?

        public init(username: String? = nil, password: String? = nil) {
            self.username = username
            self.password = password
        }
    }

    public init(displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType? = nil, data: Data? = nil) {
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.data = data
    }
}

/// SharedConnectionResponse
public struct SharedConnectionResponse: Codable {
    /// Id of the shared connection
    public var id: String
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public var serviceType: ServiceType
    /// The type of the credential
    public var credentialType: CredentialType
    /// Whether the credentials are valid or not
    public var isValid: Bool?
    /// If the account is a 2FA account or not
    public var isIs2FA: Bool?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// The type of the credential
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    public init(id: String, displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.isValid = isValid
        self.isIs2FA = isIs2FA
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case displayName
        case serviceType
        case credentialType
        case isValid
        case isIs2FA = "is2FA"
    }
}

/// Shared connection details
public struct SharedConnectionDetails: Codable {
    /// Username to connect to shared connection.
    public var username: String?
    /// Password to connect to shared connection.
    public var password: String?

    public init(username: String? = nil, password: String? = nil) {
        self.username = username
        self.password = password
    }
}

/// PrivateSharedConnectionResponse
public struct PrivateSharedConnectionResponse: Codable {
    /// Id of the shared connection
    public var id: String
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public var serviceType: ServiceType
    /// Whether the credentials are valid or not
    public var isValid: Bool?
    /// If the account is a 2FA account or not
    public var isIs2FA: Bool?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    public init(id: String, displayName: String? = nil, serviceType: ServiceType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.serviceType = serviceType
        self.isValid = isValid
        self.isIs2FA = isIs2FA
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case displayName
        case serviceType
        case isValid
        case isIs2FA = "is2FA"
    }
}

/// Apple connection secrets
public struct AppleConnectionSecretRequest: Codable {
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public var serviceType: ServiceType
    /// Credential type of the shared connection. Values can be credentials|certificate
    public var credentialType: CredentialType?
    /// Shared connection details
    public var data: Data?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// Credential type of the shared connection. Values can be credentials|certificate
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    /// Shared connection details
    public struct Data: Codable {
        /// Username to connect to shared connection.
        public var username: String?
        /// Password to connect to shared connection.
        public var password: String?

        public init(username: String? = nil, password: String? = nil) {
            self.username = username
            self.password = password
        }
    }

    public init(displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType? = nil, data: Data? = nil) {
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.data = data
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.credentialType = try CredentialType(from: decoder)
        self.data = try Data(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encodeIfPresent(credentialType, forKey: "credentialType")
        try values.encodeIfPresent(data, forKey: "data")
    }
}

/// Apple connection secrets
public struct AppleCredentialsMultifactorSecretRequest: Codable {
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public var serviceType: ServiceType
    /// Credential type of the shared connection. Values can be credentials|certificate
    public var credentialType: CredentialType?
    /// Shared connection details
    public var data: Data?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// Credential type of the shared connection. Values can be credentials|certificate
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    /// Shared connection details
    public struct Data: Codable {
        /// Username to connect to shared connection.
        public var username: String?
        /// Password to connect to shared connection.
        public var password: String?

        public init(username: String? = nil, password: String? = nil) {
            self.username = username
            self.password = password
        }
    }

    public init(displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType? = nil, data: Data? = nil) {
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.data = data
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.credentialType = try CredentialType(from: decoder)
        self.data = try Data(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encodeIfPresent(credentialType, forKey: "credentialType")
        try values.encodeIfPresent(data, forKey: "data")
    }
}

/// Apple connection secrets
public struct AppleCredentialsSecretRequest: Codable {
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public var serviceType: ServiceType
    /// Credential type of the shared connection. Values can be credentials|certificate
    public var credentialType: CredentialType?
    /// Shared connection details
    public var data: Data?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// Credential type of the shared connection. Values can be credentials|certificate
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    /// Shared connection details
    public struct Data: Codable {
        /// Username to connect to shared connection.
        public var username: String?
        /// Password to connect to shared connection.
        public var password: String?

        public init(username: String? = nil, password: String? = nil) {
            self.username = username
            self.password = password
        }
    }

    public init(displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType? = nil, data: Data? = nil) {
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.data = data
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.credentialType = try CredentialType(from: decoder)
        self.data = try Data(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encodeIfPresent(credentialType, forKey: "credentialType")
        try values.encodeIfPresent(data, forKey: "data")
    }
}

/// Apple connection secrets
public struct AppleCertificateSecretRequest: Codable {
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public var serviceType: ServiceType
    /// Credential type of the shared connection. Values can be credentials|certificate
    public var credentialType: CredentialType?
    /// Shared connection details
    public var data: Data?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// Credential type of the shared connection. Values can be credentials|certificate
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    /// Shared connection details
    public struct Data: Codable {
        /// Username to connect to shared connection.
        public var username: String?
        /// Password to connect to shared connection.
        public var password: String?

        public init(username: String? = nil, password: String? = nil) {
            self.username = username
            self.password = password
        }
    }

    public init(displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType? = nil, data: Data? = nil) {
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.data = data
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.credentialType = try CredentialType(from: decoder)
        self.data = try Data(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encodeIfPresent(credentialType, forKey: "credentialType")
        try values.encodeIfPresent(data, forKey: "data")
    }
}

/// Private Apple connection secrets response
public struct PrivateAppleSecretResponse: Codable {
    /// Id of the shared connection
    public var id: String
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public var serviceType: ServiceType
    /// Whether the credentials are valid or not
    public var isValid: Bool?
    /// If the account is a 2FA account or not
    public var isIs2FA: Bool?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    public init(id: String, displayName: String? = nil, serviceType: ServiceType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.serviceType = serviceType
        self.isValid = isValid
        self.isIs2FA = isIs2FA
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.isValid = try values.decodeIfPresent(Bool.self, forKey: "isValid")
        self.isIs2FA = try values.decodeIfPresent(Bool.self, forKey: "is2FA")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encodeIfPresent(isValid, forKey: "isValid")
        try values.encodeIfPresent(isIs2FA, forKey: "is2FA")
    }
}

/// Private Apple connection secrets response
public struct PrivateAppleCredentialsSecretResponse: Codable {
    /// Id of the shared connection
    public var id: String
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public var serviceType: ServiceType
    /// Whether the credentials are valid or not
    public var isValid: Bool?
    /// If the account is a 2FA account or not
    public var isIs2FA: Bool?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    public init(id: String, displayName: String? = nil, serviceType: ServiceType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.serviceType = serviceType
        self.isValid = isValid
        self.isIs2FA = isIs2FA
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.isValid = try values.decodeIfPresent(Bool.self, forKey: "isValid")
        self.isIs2FA = try values.decodeIfPresent(Bool.self, forKey: "is2FA")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encodeIfPresent(isValid, forKey: "isValid")
        try values.encodeIfPresent(isIs2FA, forKey: "is2FA")
    }
}

/// Private Apple connection secrets response
public struct PrivateAppleCertificateSecretResponse: Codable {
    /// Id of the shared connection
    public var id: String
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public var serviceType: ServiceType
    /// Whether the credentials are valid or not
    public var isValid: Bool?
    /// If the account is a 2FA account or not
    public var isIs2FA: Bool?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    public init(id: String, displayName: String? = nil, serviceType: ServiceType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.serviceType = serviceType
        self.isValid = isValid
        self.isIs2FA = isIs2FA
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.isValid = try values.decodeIfPresent(Bool.self, forKey: "isValid")
        self.isIs2FA = try values.decodeIfPresent(Bool.self, forKey: "is2FA")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encodeIfPresent(isValid, forKey: "isValid")
        try values.encodeIfPresent(isIs2FA, forKey: "is2FA")
    }
}

/// Apple secret details
public struct AppleSecretDetails: Codable {
    /// Username to connect to apple store.
    public var username: String?
    /// 6 digit auth code
    public var authCode: String?
    /// Password to connect to apple store.
    public var password: String?

    public init(username: String? = nil, authCode: String? = nil, password: String? = nil) {
        self.username = username
        self.authCode = authCode
        self.password = password
    }
}

/// Apple secret details
public struct AppleMultifactorSecretDetails: Codable {
    /// Username to connect to apple store.
    public var username: String
    /// Password to connect to apple store.
    public var password: String
    /// The 6 digit Apple OTP for Multifactor accounts
    public var authCode: String
    /// The app specific password required for app publishing for 2FA accounts
    public var appSpecificPassword: String?

    public init(username: String, password: String, authCode: String, appSpecificPassword: String? = nil) {
        self.username = username
        self.password = password
        self.authCode = authCode
        self.appSpecificPassword = appSpecificPassword
    }
}

/// Apple secret details
public struct AppleSecretDetailsResponse: Codable {
    /// Username to connect to apple store
    public var username: String

    public init(username: String) {
        self.username = username
    }
}

/// Apple connection secrets
public struct AppleConnectionSecretResponse: Codable {
    /// Id of the shared connection
    public var id: String
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public var serviceType: ServiceType
    /// The type of the credential
    public var credentialType: CredentialType
    /// Whether the credentials are valid or not
    public var isValid: Bool?
    /// If the account is a 2FA account or not
    public var isIs2FA: Bool?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// The type of the credential
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    public init(id: String, displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.isValid = isValid
        self.isIs2FA = isIs2FA
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.credentialType = try CredentialType(from: decoder)
        self.isValid = try values.decodeIfPresent(Bool.self, forKey: "isValid")
        self.isIs2FA = try values.decodeIfPresent(Bool.self, forKey: "is2FA")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encode(credentialType, forKey: "credentialType")
        try values.encodeIfPresent(isValid, forKey: "isValid")
        try values.encodeIfPresent(isIs2FA, forKey: "is2FA")
    }
}

/// Apple connection secrets
public struct AppleConnectionNonSecretResponse: Codable {
    /// Id of the shared connection
    public var id: String
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public var serviceType: ServiceType
    /// The type of the credential
    public var credentialType: CredentialType
    /// Whether the credentials are valid or not
    public var isValid: Bool?
    /// If the account is a 2FA account or not
    public var isIs2FA: Bool?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// The type of the credential
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    public init(id: String, displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.isValid = isValid
        self.isIs2FA = isIs2FA
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.credentialType = try CredentialType(from: decoder)
        self.isValid = try values.decodeIfPresent(Bool.self, forKey: "isValid")
        self.isIs2FA = try values.decodeIfPresent(Bool.self, forKey: "is2FA")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encode(credentialType, forKey: "credentialType")
        try values.encodeIfPresent(isValid, forKey: "isValid")
        try values.encodeIfPresent(isIs2FA, forKey: "is2FA")
    }
}

/// Apple connection secrets
public struct AppleCredentialNonSecretDetailsResponse: Codable {
    /// Id of the shared connection
    public var id: String
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public var serviceType: ServiceType
    /// The type of the credential
    public var credentialType: CredentialType
    /// Whether the credentials are valid or not
    public var isValid: Bool?
    /// If the account is a 2FA account or not
    public var isIs2FA: Bool?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// The type of the credential
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    public init(id: String, displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.isValid = isValid
        self.isIs2FA = isIs2FA
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.credentialType = try CredentialType(from: decoder)
        self.isValid = try values.decodeIfPresent(Bool.self, forKey: "isValid")
        self.isIs2FA = try values.decodeIfPresent(Bool.self, forKey: "is2FA")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encode(credentialType, forKey: "credentialType")
        try values.encodeIfPresent(isValid, forKey: "isValid")
        try values.encodeIfPresent(isIs2FA, forKey: "is2FA")
    }
}

/// Apple connection secrets
public struct AppleCertificateNonSecretDetailsResponse: Codable {
    /// Id of the shared connection
    public var id: String
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public var serviceType: ServiceType
    /// The type of the credential
    public var credentialType: CredentialType
    /// Whether the credentials are valid or not
    public var isValid: Bool?
    /// If the account is a 2FA account or not
    public var isIs2FA: Bool?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// The type of the credential
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    public init(id: String, displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.isValid = isValid
        self.isIs2FA = isIs2FA
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.credentialType = try CredentialType(from: decoder)
        self.isValid = try values.decodeIfPresent(Bool.self, forKey: "isValid")
        self.isIs2FA = try values.decodeIfPresent(Bool.self, forKey: "is2FA")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encode(credentialType, forKey: "credentialType")
        try values.encodeIfPresent(isValid, forKey: "isValid")
        try values.encodeIfPresent(isIs2FA, forKey: "is2FA")
    }
}

/// Apple connection secrets
public struct AppleCertificateSecretDetailsResponse: Codable {
    /// Id of the shared connection
    public var id: String
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public var serviceType: ServiceType
    /// The type of the credential
    public var credentialType: CredentialType
    /// Whether the credentials are valid or not
    public var isValid: Bool?
    /// If the account is a 2FA account or not
    public var isIs2FA: Bool?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// The type of the credential
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    public init(id: String, displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.isValid = isValid
        self.isIs2FA = isIs2FA
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.credentialType = try CredentialType(from: decoder)
        self.isValid = try values.decodeIfPresent(Bool.self, forKey: "isValid")
        self.isIs2FA = try values.decodeIfPresent(Bool.self, forKey: "is2FA")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encode(credentialType, forKey: "credentialType")
        try values.encodeIfPresent(isValid, forKey: "isValid")
        try values.encodeIfPresent(isIs2FA, forKey: "is2FA")
    }
}

/// Apple Certificate Secret Details
public struct AppleCertificateSecretDetails: Codable {
    /// The certificate contents in base 64 encoded string
    public var base64Certificate: String
    /// The password for the certificate
    public var password: String
    /// The display name (CN) of the certificate
    public var displayName: String
    /// The date-time from which the certificate is valid
    public var certificateValidityStartDate: String
    /// The date-time till which the certificate is valid
    public var certificateValidityEndDate: String

    public init(base64Certificate: String, password: String, displayName: String, certificateValidityStartDate: String, certificateValidityEndDate: String) {
        self.base64Certificate = base64Certificate
        self.password = password
        self.displayName = displayName
        self.certificateValidityStartDate = certificateValidityStartDate
        self.certificateValidityEndDate = certificateValidityEndDate
    }
}

/// Apple Certificate Details
public struct AppleCertificateDetails: Codable {
    /// The certificate contents in base 64 encoded string
    public var base64Certificate: String
    /// The password for the certificate
    public var password: String

    public init(base64Certificate: String, password: String) {
        self.base64Certificate = base64Certificate
        self.password = password
    }
}

/// Apple Certificate Secret Details
public struct AppleCertificateNonSecretDetails: Codable {
    /// The display name (CN) of the certificate
    public var displayName: String
    /// The date-time from which the certificate is valid
    public var certificateValidityStartDate: String
    /// The date-time till which the certificate is valid
    public var certificateValidityEndDate: String

    public init(displayName: String, certificateValidityStartDate: String, certificateValidityEndDate: String) {
        self.displayName = displayName
        self.certificateValidityStartDate = certificateValidityStartDate
        self.certificateValidityEndDate = certificateValidityEndDate
    }
}

/// Jira connection secrets
public struct JiraConnectionSecretRequest: Codable {
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public var serviceType: ServiceType
    /// Credential type of the shared connection. Values can be credentials|certificate
    public var credentialType: CredentialType?
    /// Shared connection details
    public var data: Data?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// Credential type of the shared connection. Values can be credentials|certificate
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    /// Shared connection details
    public struct Data: Codable {
        /// Username to connect to shared connection.
        public var username: String?
        /// Password to connect to shared connection.
        public var password: String?

        public init(username: String? = nil, password: String? = nil) {
            self.username = username
            self.password = password
        }
    }

    public init(displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType? = nil, data: Data? = nil) {
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.data = data
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.credentialType = try CredentialType(from: decoder)
        self.data = try Data(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encodeIfPresent(credentialType, forKey: "credentialType")
        try values.encodeIfPresent(data, forKey: "data")
    }
}

/// Jira connection secrets
public struct JiraConnectionSecretResponse: Codable {
    /// Id of the shared connection
    public var id: String
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public var serviceType: ServiceType
    /// The type of the credential
    public var credentialType: CredentialType
    /// Whether the credentials are valid or not
    public var isValid: Bool?
    /// If the account is a 2FA account or not
    public var isIs2FA: Bool?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// The type of the credential
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    public init(id: String, displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.isValid = isValid
        self.isIs2FA = isIs2FA
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.credentialType = try CredentialType(from: decoder)
        self.isValid = try values.decodeIfPresent(Bool.self, forKey: "isValid")
        self.isIs2FA = try values.decodeIfPresent(Bool.self, forKey: "is2FA")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encode(credentialType, forKey: "credentialType")
        try values.encodeIfPresent(isValid, forKey: "isValid")
        try values.encodeIfPresent(isIs2FA, forKey: "is2FA")
    }
}

/// Private Jira connection secrets response
public struct PrivateJiraConnectionSecretResponse: Codable {
    /// Id of the shared connection
    public var id: String
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public var serviceType: ServiceType
    /// Whether the credentials are valid or not
    public var isValid: Bool?
    /// If the account is a 2FA account or not
    public var isIs2FA: Bool?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    public init(id: String, displayName: String? = nil, serviceType: ServiceType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.serviceType = serviceType
        self.isValid = isValid
        self.isIs2FA = isIs2FA
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.isValid = try values.decodeIfPresent(Bool.self, forKey: "isValid")
        self.isIs2FA = try values.decodeIfPresent(Bool.self, forKey: "is2FA")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encodeIfPresent(isValid, forKey: "isValid")
        try values.encodeIfPresent(isIs2FA, forKey: "is2FA")
    }
}

/// Jira secret details
public struct JiraSecretDetails: Codable {
    /// BaseUrl to connect to jira instance
    public var baseURL: String
    /// Username to connect to jira instance
    public var username: String
    /// Password to connect to jira instance
    public var password: String

    public init(baseURL: String, username: String, password: String) {
        self.baseURL = baseURL
        self.username = username
        self.password = password
    }

    private enum CodingKeys: String, CodingKey {
        case baseURL = "baseUrl"
        case username
        case password
    }
}

/// Jira secret details
public struct JiraSecretDetailsResponse: Codable {
    /// BaseUrl to connect to jira instance
    public var baseURL: String
    /// Username to connect to jira instance
    public var username: String

    public init(baseURL: String, username: String) {
        self.baseURL = baseURL
        self.username = username
    }

    private enum CodingKeys: String, CodingKey {
        case baseURL = "baseUrl"
        case username
    }
}

/// Google Play connection secrets this should be the JSON file data which is provided by google play
public struct GooglePlayConnectionSecretRequest: Codable {
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public var serviceType: ServiceType
    /// Credential type of the shared connection. Values can be credentials|certificate
    public var credentialType: CredentialType?
    /// Shared connection details
    public var data: Data?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// Credential type of the shared connection. Values can be credentials|certificate
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    /// Shared connection details
    public struct Data: Codable {
        /// Username to connect to shared connection.
        public var username: String?
        /// Password to connect to shared connection.
        public var password: String?

        public init(username: String? = nil, password: String? = nil) {
            self.username = username
            self.password = password
        }
    }

    public init(displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType? = nil, data: Data? = nil) {
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.data = data
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.credentialType = try CredentialType(from: decoder)
        self.data = try Data(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encodeIfPresent(credentialType, forKey: "credentialType")
        try values.encodeIfPresent(data, forKey: "data")
    }
}

/// Google Play connection secrets
public struct GooglePlayConnectionSecretResponse: Codable {
    /// Id of the shared connection
    public var id: String
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public var serviceType: ServiceType
    /// The type of the credential
    public var credentialType: CredentialType
    /// Whether the credentials are valid or not
    public var isValid: Bool?
    /// If the account is a 2FA account or not
    public var isIs2FA: Bool?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// The type of the credential
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    public init(id: String, displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.isValid = isValid
        self.isIs2FA = isIs2FA
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.credentialType = try CredentialType(from: decoder)
        self.isValid = try values.decodeIfPresent(Bool.self, forKey: "isValid")
        self.isIs2FA = try values.decodeIfPresent(Bool.self, forKey: "is2FA")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encode(credentialType, forKey: "credentialType")
        try values.encodeIfPresent(isValid, forKey: "isValid")
        try values.encodeIfPresent(isIs2FA, forKey: "is2FA")
    }
}

/// Private google connection secrets response
public struct PrivateGooglePlayConnectionSecretResponse: Codable {
    /// Id of the shared connection
    public var id: String
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public var serviceType: ServiceType
    /// Whether the credentials are valid or not
    public var isValid: Bool?
    /// If the account is a 2FA account or not
    public var isIs2FA: Bool?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    public init(id: String, displayName: String? = nil, serviceType: ServiceType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.serviceType = serviceType
        self.isValid = isValid
        self.isIs2FA = isIs2FA
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.isValid = try values.decodeIfPresent(Bool.self, forKey: "isValid")
        self.isIs2FA = try values.decodeIfPresent(Bool.self, forKey: "is2FA")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encodeIfPresent(isValid, forKey: "isValid")
        try values.encodeIfPresent(isIs2FA, forKey: "is2FA")
    }
}

/// Google Play non-secret data
public struct GooglePlayConnectionNonSecretResponse: Codable {
    /// Id of the shared connection
    public var id: String
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public var serviceType: ServiceType
    /// The type of the credential
    public var credentialType: CredentialType
    /// Whether the credentials are valid or not
    public var isValid: Bool?
    /// If the account is a 2FA account or not
    public var isIs2FA: Bool?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// The type of the credential
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    public init(id: String, displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.isValid = isValid
        self.isIs2FA = isIs2FA
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.credentialType = try CredentialType(from: decoder)
        self.isValid = try values.decodeIfPresent(Bool.self, forKey: "isValid")
        self.isIs2FA = try values.decodeIfPresent(Bool.self, forKey: "is2FA")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encode(credentialType, forKey: "credentialType")
        try values.encodeIfPresent(isValid, forKey: "isValid")
        try values.encodeIfPresent(isIs2FA, forKey: "is2FA")
    }
}

/// Google Play non-secret data
public struct GooglePlayCredentialNonSecretDetailsResponse: Codable {
    /// Id of the shared connection
    public var id: String
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public var serviceType: ServiceType
    /// The type of the credential
    public var credentialType: CredentialType
    /// Whether the credentials are valid or not
    public var isValid: Bool?
    /// If the account is a 2FA account or not
    public var isIs2FA: Bool?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// The type of the credential
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    public init(id: String, displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.isValid = isValid
        self.isIs2FA = isIs2FA
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.credentialType = try CredentialType(from: decoder)
        self.isValid = try values.decodeIfPresent(Bool.self, forKey: "isValid")
        self.isIs2FA = try values.decodeIfPresent(Bool.self, forKey: "is2FA")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encode(credentialType, forKey: "credentialType")
        try values.encodeIfPresent(isValid, forKey: "isValid")
        try values.encodeIfPresent(isIs2FA, forKey: "is2FA")
    }
}

/// Jira non-secret data
public struct JiraConnectionNonSecretResponse: Codable {
    /// Id of the shared connection
    public var id: String
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public var serviceType: ServiceType
    /// The type of the credential
    public var credentialType: CredentialType
    /// Whether the credentials are valid or not
    public var isValid: Bool?
    /// If the account is a 2FA account or not
    public var isIs2FA: Bool?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// The type of the credential
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    public init(id: String, displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.isValid = isValid
        self.isIs2FA = isIs2FA
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.credentialType = try CredentialType(from: decoder)
        self.isValid = try values.decodeIfPresent(Bool.self, forKey: "isValid")
        self.isIs2FA = try values.decodeIfPresent(Bool.self, forKey: "is2FA")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encode(credentialType, forKey: "credentialType")
        try values.encodeIfPresent(isValid, forKey: "isValid")
        try values.encodeIfPresent(isIs2FA, forKey: "is2FA")
    }
}

/// Google Play non-secret data
public struct JiraCredentialNonSecretDetailsResponse: Codable {
    /// Id of the shared connection
    public var id: String
    /// Display name of shared connection
    public var displayName: String?
    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public var serviceType: ServiceType
    /// The type of the credential
    public var credentialType: CredentialType
    /// Whether the credentials are valid or not
    public var isValid: Bool?
    /// If the account is a 2FA account or not
    public var isIs2FA: Bool?

    /// Service type of shared connection can be apple|gitlab|googleplay|jira
    public enum ServiceType: String, Codable, CaseIterable {
        case apple
        case jira
        case googleplay
        case gitlab
    }

    /// The type of the credential
    public enum CredentialType: String, Codable, CaseIterable {
        case credentials
        case certificate
    }

    public init(id: String, displayName: String? = nil, serviceType: ServiceType, credentialType: CredentialType, isValid: Bool? = nil, isIs2FA: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.serviceType = serviceType
        self.credentialType = credentialType
        self.isValid = isValid
        self.isIs2FA = isIs2FA
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.serviceType = try ServiceType(from: decoder)
        self.credentialType = try CredentialType(from: decoder)
        self.isValid = try values.decodeIfPresent(Bool.self, forKey: "isValid")
        self.isIs2FA = try values.decodeIfPresent(Bool.self, forKey: "is2FA")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encode(serviceType, forKey: "serviceType")
        try values.encode(credentialType, forKey: "credentialType")
        try values.encodeIfPresent(isValid, forKey: "isValid")
        try values.encodeIfPresent(isIs2FA, forKey: "is2FA")
    }
}

/// Generic result for any alerting API operation
public struct AlertOperationResult: Codable {
    /// Unique request identifier for tracking
    public var requestID: String

    public init(requestID: String) {
        self.requestID = requestID
    }

    private enum CodingKeys: String, CodingKey {
        case requestID = "request_id"
    }
}

/// Alerting webhook
public struct AlertWebhook: Codable {
    /// The unique id (UUID) of the webhook
    public var id: String?
    /// Display name of the webhook
    public var name: String
    /// Target url of the webhook
    public var url: String
    /// Allows eanble/disable webhook
    public var isEnabled: Bool?
    /// Event types enabled for webhook
    public var eventTypes: [EventType]

    /// Alerting EventTypes enum
    public enum EventType: String, Codable, CaseIterable {
        case newCrashGroupCreated
        case newAppReleased
    }

    public init(id: String? = nil, name: String, url: String, isEnabled: Bool? = nil, eventTypes: [EventType]) {
        self.id = id
        self.name = name
        self.url = url
        self.isEnabled = isEnabled
        self.eventTypes = eventTypes
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case url
        case isEnabled = "enabled"
        case eventTypes = "event_types"
    }
}

/// Alerting EventTypes enum
public enum AlertingEventTypes: String, Codable, CaseIterable {
    case newCrashGroupCreated
    case newAppReleased
}

/// List of alerting webhooks wrapped as operation result
public struct AlertWebhookListResult: Codable {
    public var values: [Value]

    /// Alerting webhook
    public struct Value: Codable {
        /// The unique id (UUID) of the webhook
        public var id: String?
        /// Display name of the webhook
        public var name: String
        /// Target url of the webhook
        public var url: String
        /// Allows eanble/disable webhook
        public var isEnabled: Bool?
        /// Event types enabled for webhook
        public var eventTypes: [EventType]

        /// Alerting EventTypes enum
        public enum EventType: String, Codable, CaseIterable {
            case newCrashGroupCreated
            case newAppReleased
        }

        public init(id: String? = nil, name: String, url: String, isEnabled: Bool? = nil, eventTypes: [EventType]) {
            self.id = id
            self.name = name
            self.url = url
            self.isEnabled = isEnabled
            self.eventTypes = eventTypes
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case name
            case url
            case isEnabled = "enabled"
            case eventTypes = "event_types"
        }
    }

    public init(values: [Value]) {
        self.values = values
    }
}

/// Alerting webhook ping operation result
public struct AlertWebhookPingResult: Codable {
    /// Unique request identifier for tracking
    public var requestID: String
    /// HTTP status code returned in response from calling webhook
    public var responseStatusCode: Int
    /// Reason returned in response from calling webhook
    public var responseReason: String?

    public init(requestID: String, responseStatusCode: Int, responseReason: String? = nil) {
        self.requestID = requestID
        self.responseStatusCode = responseStatusCode
        self.responseReason = responseReason
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.requestID = try values.decode(String.self, forKey: "request_id")
        self.responseStatusCode = try values.decode(Int.self, forKey: "response_status_code")
        self.responseReason = try values.decodeIfPresent(String.self, forKey: "response_reason")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(requestID, forKey: "request_id")
        try values.encode(responseStatusCode, forKey: "response_status_code")
        try values.encodeIfPresent(responseReason, forKey: "response_reason")
    }
}

/// Alerting Email Settings
public struct AlertEmailSettings: Codable {
    /// The settings the user has for the app
    public var settings: [Setting]

    /// Event Setting
    public struct Setting: Codable {
        /// Event Name
        public var eventType: EventType
        /// Frequency of event
        public var value: Value
        /// Default frequency of event
        public var defaultValue: DefaultValue?

        /// Event Name
        public enum EventType: String, Codable, CaseIterable {
            case crashNewCrashGroupCreated = "crash_newCrashGroupCreated"
        }

        /// Frequency of event
        public enum Value: String, Codable, CaseIterable {
            case disabled = "Disabled"
            case individual = "Individual"
            case daily = "Daily"
            case dailyAndIndividual = "DailyAndIndividual"
            case `default` = "Default"
        }

        /// Default frequency of event
        public enum DefaultValue: String, Codable, CaseIterable {
            case disabled = "Disabled"
            case individual = "Individual"
            case daily = "Daily"
            case dailyAndIndividual = "DailyAndIndividual"
        }

        public init(eventType: EventType, value: Value, defaultValue: DefaultValue? = nil) {
            self.eventType = eventType
            self.value = value
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case eventType = "event_type"
            case value
            case defaultValue = "default_value"
        }
    }

    public init(settings: [Setting]) {
        self.settings = settings
    }
}

/// Alerting Default Email Settings of the user
public struct AlertUserEmailSettingsResult: Codable {
    /// Unique request identifier for tracking
    public var requestID: String
    /// The ETag of the entity
    public var eTag: String?
    /// Allows to forcefully disable emails on app or user level
    public var isEnabled: Bool
    /// The unique id (UUID) of the user
    public var userID: String?
    /// The settings the user has for the app
    public var settings: [Setting]

    /// Event Setting
    public struct Setting: Codable {
        /// Event Name
        public var eventType: EventType
        /// Frequency of event
        public var value: Value
        /// Default frequency of event
        public var defaultValue: DefaultValue?

        /// Event Name
        public enum EventType: String, Codable, CaseIterable {
            case crashNewCrashGroupCreated = "crash_newCrashGroupCreated"
        }

        /// Frequency of event
        public enum Value: String, Codable, CaseIterable {
            case disabled = "Disabled"
            case individual = "Individual"
            case daily = "Daily"
            case dailyAndIndividual = "DailyAndIndividual"
            case `default` = "Default"
        }

        /// Default frequency of event
        public enum DefaultValue: String, Codable, CaseIterable {
            case disabled = "Disabled"
            case individual = "Individual"
            case daily = "Daily"
            case dailyAndIndividual = "DailyAndIndividual"
        }

        public init(eventType: EventType, value: Value, defaultValue: DefaultValue? = nil) {
            self.eventType = eventType
            self.value = value
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case eventType = "event_type"
            case value
            case defaultValue = "default_value"
        }
    }

    public init(requestID: String, eTag: String? = nil, isEnabled: Bool, userID: String? = nil, settings: [Setting]) {
        self.requestID = requestID
        self.eTag = eTag
        self.isEnabled = isEnabled
        self.userID = userID
        self.settings = settings
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.requestID = try values.decode(String.self, forKey: "request_id")
        self.eTag = try values.decodeIfPresent(String.self, forKey: "eTag")
        self.isEnabled = try values.decode(Bool.self, forKey: "enabled")
        self.userID = try values.decodeIfPresent(String.self, forKey: "userId")
        self.settings = try values.decode([Setting].self, forKey: "settings")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(requestID, forKey: "request_id")
        try values.encodeIfPresent(eTag, forKey: "eTag")
        try values.encode(isEnabled, forKey: "enabled")
        try values.encodeIfPresent(userID, forKey: "userId")
        try values.encode(settings, forKey: "settings")
    }
}

/// Alerting Email Settings of the user for a particular app
public struct AlertUserAppEmailSettingsResult: Codable {
    /// Alerting Default Email Settings of the user
    public var a: A
    /// Unique request
    public var requestID: String?
    /// Application ID
    public var appID: String?
    /// A flag indicating if settings are enabled at user/global level
    public var isUserEnabled: Bool?

    /// Alerting Default Email Settings of the user
    public struct A: Codable {
        /// Unique request identifier for tracking
        public var requestID: String
        /// The ETag of the entity
        public var eTag: String?
        /// Allows to forcefully disable emails on app or user level
        public var isEnabled: Bool
        /// The unique id (UUID) of the user
        public var userID: String?
        /// The settings the user has for the app
        public var settings: [Setting]

        /// Event Setting
        public struct Setting: Codable {
            /// Event Name
            public var eventType: EventType
            /// Frequency of event
            public var value: Value
            /// Default frequency of event
            public var defaultValue: DefaultValue?

            /// Event Name
            public enum EventType: String, Codable, CaseIterable {
                case crashNewCrashGroupCreated = "crash_newCrashGroupCreated"
            }

            /// Frequency of event
            public enum Value: String, Codable, CaseIterable {
                case disabled = "Disabled"
                case individual = "Individual"
                case daily = "Daily"
                case dailyAndIndividual = "DailyAndIndividual"
                case `default` = "Default"
            }

            /// Default frequency of event
            public enum DefaultValue: String, Codable, CaseIterable {
                case disabled = "Disabled"
                case individual = "Individual"
                case daily = "Daily"
                case dailyAndIndividual = "DailyAndIndividual"
            }

            public init(eventType: EventType, value: Value, defaultValue: DefaultValue? = nil) {
                self.eventType = eventType
                self.value = value
                self.defaultValue = defaultValue
            }

            private enum CodingKeys: String, CodingKey {
                case eventType = "event_type"
                case value
                case defaultValue = "default_value"
            }
        }

        public init(requestID: String, eTag: String? = nil, isEnabled: Bool, userID: String? = nil, settings: [Setting]) {
            self.requestID = requestID
            self.eTag = eTag
            self.isEnabled = isEnabled
            self.userID = userID
            self.settings = settings
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.requestID = try values.decode(String.self, forKey: "request_id")
            self.eTag = try values.decodeIfPresent(String.self, forKey: "eTag")
            self.isEnabled = try values.decode(Bool.self, forKey: "enabled")
            self.userID = try values.decodeIfPresent(String.self, forKey: "userId")
            self.settings = try values.decode([Setting].self, forKey: "settings")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(requestID, forKey: "request_id")
            try values.encodeIfPresent(eTag, forKey: "eTag")
            try values.encode(isEnabled, forKey: "enabled")
            try values.encodeIfPresent(userID, forKey: "userId")
            try values.encode(settings, forKey: "settings")
        }
    }

    public init(a: A, requestID: String? = nil, appID: String? = nil, isUserEnabled: Bool? = nil) {
        self.a = a
        self.requestID = requestID
        self.appID = appID
        self.isUserEnabled = isUserEnabled
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.a = try A(from: decoder)
        self.requestID = try values.decodeIfPresent(String.self, forKey: "request_id")
        self.appID = try values.decodeIfPresent(String.self, forKey: "appId")
        self.isUserEnabled = try values.decodeIfPresent(Bool.self, forKey: "user_enabled")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(a, forKey: "a")
        try values.encodeIfPresent(requestID, forKey: "request_id")
        try values.encodeIfPresent(appID, forKey: "appId")
        try values.encodeIfPresent(isUserEnabled, forKey: "user_enabled")
    }
}

/// Bugtracker specific settings
public struct AlertingBugtrackerSettings: Codable {
    public var callbackURL: String?
    public var ownerName: String
    /// Type of bugtracker
    public var type: `Type`

    /// Type of bugtracker
    public enum `Type`: String, Codable, CaseIterable {
        case github
        case vsts
        case jira
    }

    public init(callbackURL: String? = nil, ownerName: String, type: `Type`) {
        self.callbackURL = callbackURL
        self.ownerName = ownerName
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case callbackURL = "callback_url"
        case ownerName = "owner_name"
        case type
    }
}

/// VSTS bugtracker specific settings
public struct AlertingVstsBugtrackerSettings: Codable {
    public var callbackURL: String?
    public var ownerName: String
    /// Type of bugtracker
    public var type: `Type`

    /// Type of bugtracker
    public enum `Type`: String, Codable, CaseIterable {
        case github
        case vsts
        case jira
    }

    public init(callbackURL: String? = nil, ownerName: String, type: `Type`) {
        self.callbackURL = callbackURL
        self.ownerName = ownerName
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.callbackURL = try values.decodeIfPresent(String.self, forKey: "callback_url")
        self.ownerName = try values.decode(String.self, forKey: "owner_name")
        self.type = try `Type`(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(callbackURL, forKey: "callback_url")
        try values.encode(ownerName, forKey: "owner_name")
        try values.encode(type, forKey: "type")
    }
}

/// Github bugtracker specific settings
public struct AlertingGithubBugtrackerSettings: Codable {
    public var callbackURL: String?
    public var ownerName: String
    /// Type of bugtracker
    public var type: `Type`

    /// Type of bugtracker
    public enum `Type`: String, Codable, CaseIterable {
        case github
        case vsts
        case jira
    }

    public init(callbackURL: String? = nil, ownerName: String, type: `Type`) {
        self.callbackURL = callbackURL
        self.ownerName = ownerName
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.callbackURL = try values.decodeIfPresent(String.self, forKey: "callback_url")
        self.ownerName = try values.decode(String.self, forKey: "owner_name")
        self.type = try `Type`(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(callbackURL, forKey: "callback_url")
        try values.encode(ownerName, forKey: "owner_name")
        try values.encode(type, forKey: "type")
    }
}

/// Jira bugtracker specific settings
public struct AlertingJiraBugtrackerSettings: Codable {
    public var callbackURL: String?
    public var ownerName: String
    /// Type of bugtracker
    public var type: `Type`

    /// Type of bugtracker
    public enum `Type`: String, Codable, CaseIterable {
        case github
        case vsts
        case jira
    }

    public init(callbackURL: String? = nil, ownerName: String, type: `Type`) {
        self.callbackURL = callbackURL
        self.ownerName = ownerName
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.callbackURL = try values.decodeIfPresent(String.self, forKey: "callback_url")
        self.ownerName = try values.decode(String.self, forKey: "owner_name")
        self.type = try `Type`(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(callbackURL, forKey: "callback_url")
        try values.encode(ownerName, forKey: "owner_name")
        try values.encode(type, forKey: "type")
    }
}

/// Alerting bugtracker resource
public struct AlertingBugtracker: Codable {
    /// Type of bugtracker
    public var type: `Type`?
    /// Bugtracker state
    public var state: State?
    /// ID of OAuth token
    public var tokenID: String?
    /// Event types enabled for bugtracker
    public var eventTypes: [EventType]?
    /// Bugtracker specific settings
    public var settings: Settings?

    /// Type of bugtracker
    public enum `Type`: String, Codable, CaseIterable {
        case github
        case vsts
        case jira
    }

    /// Bugtracker state
    public enum State: String, Codable, CaseIterable {
        case enabled
        case disabled
        case unauthorized
    }

    /// Alerting EventTypes enum
    public enum EventType: String, Codable, CaseIterable {
        case newCrashGroupCreated
        case newAppReleased
    }

    /// Bugtracker specific settings
    public struct Settings: Codable {
        public var callbackURL: String?
        public var ownerName: String
        /// Type of bugtracker
        public var type: `Type`

        /// Type of bugtracker
        public enum `Type`: String, Codable, CaseIterable {
            case github
            case vsts
            case jira
        }

        public init(callbackURL: String? = nil, ownerName: String, type: `Type`) {
            self.callbackURL = callbackURL
            self.ownerName = ownerName
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case callbackURL = "callback_url"
            case ownerName = "owner_name"
            case type
        }
    }

    public init(type: `Type`? = nil, state: State? = nil, tokenID: String? = nil, eventTypes: [EventType]? = nil, settings: Settings? = nil) {
        self.type = type
        self.state = state
        self.tokenID = tokenID
        self.eventTypes = eventTypes
        self.settings = settings
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case state
        case tokenID = "token_id"
        case eventTypes = "event_types"
        case settings
    }
}

/// Contains the token ID for a bug tracker
public struct BugTrackerTokenID: Codable {
    public var tokenID: String?

    public init(tokenID: String? = nil) {
        self.tokenID = tokenID
    }

    private enum CodingKeys: String, CodingKey {
        case tokenID = "token_id"
    }
}

/// List of bug tracker repositories
public struct AlertBugTrackerReposResult: Codable {
    public var repoType: RepoType?
    public var repositories: [Repository]

    public enum RepoType: String, Codable, CaseIterable {
        case github
        case vsts
        case jira
    }

    /// Repostiory object
    public struct Repository: Codable {
        public var name: String
        public var url: String
        public var id: String
        public var description: String?
        public var isPrivate: Bool?
        /// Repository owner object
        public var owner: Owner?

        /// Repository owner object
        public struct Owner: Codable {
            public var name: String?
            public var id: String?
            public var login: String?

            public init(name: String? = nil, id: String? = nil, login: String? = nil) {
                self.name = name
                self.id = id
                self.login = login
            }
        }

        public init(name: String, url: String, id: String, description: String? = nil, isPrivate: Bool? = nil, owner: Owner? = nil) {
            self.name = name
            self.url = url
            self.id = id
            self.description = description
            self.isPrivate = isPrivate
            self.owner = owner
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case url
            case id
            case description
            case isPrivate = "private"
            case owner
        }
    }

    public init(repoType: RepoType? = nil, repositories: [Repository]) {
        self.repoType = repoType
        self.repositories = repositories
    }

    private enum CodingKeys: String, CodingKey {
        case repoType = "repo_type"
        case repositories
    }
}

/// Repostiory object
public struct AlertBugTrackerRepo: Codable {
    public var name: String
    public var url: String
    public var id: String
    public var description: String?
    public var isPrivate: Bool?
    /// Repository owner object
    public var owner: Owner?

    /// Repository owner object
    public struct Owner: Codable {
        public var name: String?
        public var id: String?
        public var login: String?

        public init(name: String? = nil, id: String? = nil, login: String? = nil) {
            self.name = name
            self.id = id
            self.login = login
        }
    }

    public init(name: String, url: String, id: String, description: String? = nil, isPrivate: Bool? = nil, owner: Owner? = nil) {
        self.name = name
        self.url = url
        self.id = id
        self.description = description
        self.isPrivate = isPrivate
        self.owner = owner
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case url
        case id
        case description
        case isPrivate = "private"
        case owner
    }
}

/// Repository owner object
public struct AlertBugTrackerRepoOwner: Codable {
    public var name: String?
    public var id: String?
    public var login: String?

    public init(name: String? = nil, id: String? = nil, login: String? = nil) {
        self.name = name
        self.id = id
        self.login = login
    }
}

/// AlertCrashGroup patching parameter
public struct AlertCrashGroupStateChange: Codable {
    public var state: State?

    public enum State: String, Codable, CaseIterable {
        case `open` = "Open"
        case closed = "Closed"
        case ignored = "Ignored"
    }

    public init(state: State? = nil) {
        self.state = state
    }
}

/// Access token details
public struct AlertingAccessTokenResponse: Codable {
    /// ID of the access token
    public var accessTokenID: String
    /// External provider name
    public var externalProviderName: ExternalProviderName
    /// The email of external user that used to authenticate aginst the external oauth provider
    public var externalUserEmail: String
    /// The account name of external user that used to authenticate against the external oauth provider or basic auth
    public var externalAccountName: String

    /// External provider name
    public enum ExternalProviderName: String, Codable, CaseIterable {
        case github
        case vsts
        case jira
    }

    public init(accessTokenID: String, externalProviderName: ExternalProviderName, externalUserEmail: String, externalAccountName: String) {
        self.accessTokenID = accessTokenID
        self.externalProviderName = externalProviderName
        self.externalUserEmail = externalUserEmail
        self.externalAccountName = externalAccountName
    }

    private enum CodingKeys: String, CodingKey {
        case accessTokenID = "access_token_id"
        case externalProviderName = "external_provider_name"
        case externalUserEmail = "external_user_email"
        case externalAccountName = "external_account_name"
    }
}

/// Event Setting
public struct EventSetting: Codable {
    /// Event Name
    public var eventType: EventType
    /// Frequency of event
    public var value: Value
    /// Default frequency of event
    public var defaultValue: DefaultValue?

    /// Event Name
    public enum EventType: String, Codable, CaseIterable {
        case crashNewCrashGroupCreated = "crash_newCrashGroupCreated"
    }

    /// Frequency of event
    public enum Value: String, Codable, CaseIterable {
        case disabled = "Disabled"
        case individual = "Individual"
        case daily = "Daily"
        case dailyAndIndividual = "DailyAndIndividual"
        case `default` = "Default"
    }

    /// Default frequency of event
    public enum DefaultValue: String, Codable, CaseIterable {
        case disabled = "Disabled"
        case individual = "Individual"
        case daily = "Daily"
        case dailyAndIndividual = "DailyAndIndividual"
    }

    public init(eventType: EventType, value: Value, defaultValue: DefaultValue? = nil) {
        self.eventType = eventType
        self.value = value
        self.defaultValue = defaultValue
    }

    private enum CodingKeys: String, CodingKey {
        case eventType = "event_type"
        case value
        case defaultValue = "default_value"
    }
}

/// Alerting event
public struct AlertingEvent: Codable {
    /// ISO 8601 date time when event was generated
    public var eventTimestamp: String
    /// A unique identifier for this event instance. Useful for deduplication
    public var eventID: String
    /// Obsolete. Use emailProperties.
    public var properties: [String: AnyJSON]?

    public init(eventTimestamp: String, eventID: String, properties: [String: AnyJSON]? = nil) {
        self.eventTimestamp = eventTimestamp
        self.eventID = eventID
        self.properties = properties
    }

    private enum CodingKeys: String, CodingKey {
        case eventTimestamp = "event_timestamp"
        case eventID = "event_id"
        case properties
    }
}

/// New crash group alerting event
public struct NewCrashGroupAlertingEvent: Codable {
    /// ISO 8601 date time when event was generated
    public var eventTimestamp: String
    /// A unique identifier for this event instance. Useful for deduplication
    public var eventID: String
    /// Obsolete. Use emailProperties.
    public var properties: [String: AnyJSON]?
    /// Properties of new crash group
    public var crashGroupProperties: CrashGroupProperties?

    /// Properties of new crash group
    public struct CrashGroupProperties: Codable {
        public var id: String
        public var name: String
        public var reason: String
        public var url: String
        public var appDisplayName: String
        public var appPlatform: String
        public var appVersion: String
        public var stackTrace: [String]

        public init(id: String, name: String, reason: String, url: String, appDisplayName: String, appPlatform: String, appVersion: String, stackTrace: [String]) {
            self.id = id
            self.name = name
            self.reason = reason
            self.url = url
            self.appDisplayName = appDisplayName
            self.appPlatform = appPlatform
            self.appVersion = appVersion
            self.stackTrace = stackTrace
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case name
            case reason
            case url
            case appDisplayName = "app_display_name"
            case appPlatform = "app_platform"
            case appVersion = "app_version"
            case stackTrace = "stack_trace"
        }
    }

    public init(eventTimestamp: String, eventID: String, properties: [String: AnyJSON]? = nil, crashGroupProperties: CrashGroupProperties? = nil) {
        self.eventTimestamp = eventTimestamp
        self.eventID = eventID
        self.properties = properties
        self.crashGroupProperties = crashGroupProperties
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.eventTimestamp = try values.decode(String.self, forKey: "event_timestamp")
        self.eventID = try values.decode(String.self, forKey: "event_id")
        self.properties = try values.decodeIfPresent([String: AnyJSON].self, forKey: "properties")
        self.crashGroupProperties = try CrashGroupProperties(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(eventTimestamp, forKey: "event_timestamp")
        try values.encode(eventID, forKey: "event_id")
        try values.encodeIfPresent(properties, forKey: "properties")
        try values.encodeIfPresent(crashGroupProperties, forKey: "crash_group_properties")
    }
}

/// New app release alerting event
public struct NewAppReleaseAlertingEvent: Codable {
    /// ISO 8601 date time when event was generated
    public var eventTimestamp: String
    /// A unique identifier for this event instance. Useful for deduplication
    public var eventID: String
    /// Obsolete. Use emailProperties.
    public var properties: [String: AnyJSON]?
    /// List of users who need to receive an email notification. If this is not null, then only sending emails will be triggered even if the event requires calling webhooks or doing other actions.
    public var userIDs: [String]?
    /// Indicate whether notify via webhook or not
    public var isDisableWebhook: Bool?
    /// Properties of new application release
    public var appReleaseProperties: AppReleaseProperties?

    /// Properties of new application release
    public struct AppReleaseProperties: Codable {
        public var appName: String
        public var appDisplayName: String
        public var releaseID: String
        public var platform: String
        /// Date and time in ISO 8601 format
        public var uploadedAt: String
        public var fingerprint: String?
        public var releaseNotes: String?
        public var version: String
        public var shortVersion: String
        public var minOs: String?
        public var isMandatoryUpdate: Bool?
        public var size: Int
        public var provisioningProfileName: String?
        public var provisioningProfileType: String?
        public var bundleIdentifier: String
        public var installLink: String
        public var iconLink: String?
        public var distributionGroupID: String?
        public var isInstallable: Bool?

        public init(appName: String, appDisplayName: String, releaseID: String, platform: String, uploadedAt: String, fingerprint: String? = nil, releaseNotes: String? = nil, version: String, shortVersion: String, minOs: String? = nil, isMandatoryUpdate: Bool? = nil, size: Int, provisioningProfileName: String? = nil, provisioningProfileType: String? = nil, bundleIdentifier: String, installLink: String, iconLink: String? = nil, distributionGroupID: String? = nil, isInstallable: Bool? = nil) {
            self.appName = appName
            self.appDisplayName = appDisplayName
            self.releaseID = releaseID
            self.platform = platform
            self.uploadedAt = uploadedAt
            self.fingerprint = fingerprint
            self.releaseNotes = releaseNotes
            self.version = version
            self.shortVersion = shortVersion
            self.minOs = minOs
            self.isMandatoryUpdate = isMandatoryUpdate
            self.size = size
            self.provisioningProfileName = provisioningProfileName
            self.provisioningProfileType = provisioningProfileType
            self.bundleIdentifier = bundleIdentifier
            self.installLink = installLink
            self.iconLink = iconLink
            self.distributionGroupID = distributionGroupID
            self.isInstallable = isInstallable
        }

        private enum CodingKeys: String, CodingKey {
            case appName = "app_name"
            case appDisplayName = "app_display_name"
            case releaseID = "release_id"
            case platform
            case uploadedAt = "uploaded_at"
            case fingerprint
            case releaseNotes = "release_notes"
            case version
            case shortVersion = "short_version"
            case minOs = "min_os"
            case isMandatoryUpdate = "mandatory_update"
            case size
            case provisioningProfileName = "provisioning_profile_name"
            case provisioningProfileType = "provisioning_profile_type"
            case bundleIdentifier = "bundle_identifier"
            case installLink = "install_link"
            case iconLink = "icon_link"
            case distributionGroupID = "distribution_group_id"
            case isInstallable = "installable"
        }
    }

    public init(eventTimestamp: String, eventID: String, properties: [String: AnyJSON]? = nil, userIDs: [String]? = nil, isDisableWebhook: Bool? = nil, appReleaseProperties: AppReleaseProperties? = nil) {
        self.eventTimestamp = eventTimestamp
        self.eventID = eventID
        self.properties = properties
        self.userIDs = userIDs
        self.isDisableWebhook = isDisableWebhook
        self.appReleaseProperties = appReleaseProperties
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.eventTimestamp = try values.decode(String.self, forKey: "event_timestamp")
        self.eventID = try values.decode(String.self, forKey: "event_id")
        self.properties = try values.decodeIfPresent([String: AnyJSON].self, forKey: "properties")
        self.userIDs = try values.decodeIfPresent([String].self, forKey: "user_ids")
        self.isDisableWebhook = try values.decodeIfPresent(Bool.self, forKey: "disable_webhook")
        self.appReleaseProperties = try AppReleaseProperties(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(eventTimestamp, forKey: "event_timestamp")
        try values.encode(eventID, forKey: "event_id")
        try values.encodeIfPresent(properties, forKey: "properties")
        try values.encodeIfPresent(userIDs, forKey: "user_ids")
        try values.encodeIfPresent(isDisableWebhook, forKey: "disable_webhook")
        try values.encodeIfPresent(appReleaseProperties, forKey: "app_release_properties")
    }
}

/// Returns a list of all issues associated with a repo
public struct BugTrackerIssuesResult: Codable {
    public var issues: [Issue]?

    /// Object returned in response to getting a bug tracker issue related to a crash group id
    public struct Issue: Codable {
        public var id: String?
        public var url: String?
        public var title: String?
        public var bugTrackerType: BugTrackerType?
        public var repoName: String?
        public var mobileCenterID: String?
        public var eventType: String?

        public enum BugTrackerType: String, Codable, CaseIterable {
            case github
            case vsts
            case jira
        }

        public init(id: String? = nil, url: String? = nil, title: String? = nil, bugTrackerType: BugTrackerType? = nil, repoName: String? = nil, mobileCenterID: String? = nil, eventType: String? = nil) {
            self.id = id
            self.url = url
            self.title = title
            self.bugTrackerType = bugTrackerType
            self.repoName = repoName
            self.mobileCenterID = mobileCenterID
            self.eventType = eventType
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case url
            case title
            case bugTrackerType = "bug_tracker_type"
            case repoName = "repo_name"
            case mobileCenterID = "mobile_center_id"
            case eventType = "event_type"
        }
    }

    public init(issues: [Issue]? = nil) {
        self.issues = issues
    }
}

/// Object returned in response to getting a bug tracker issue related to a crash group id
public struct BugTrackerIssueResult: Codable {
    public var id: String?
    public var url: String?
    public var title: String?
    public var bugTrackerType: BugTrackerType?
    public var repoName: String?
    public var mobileCenterID: String?
    public var eventType: String?

    public enum BugTrackerType: String, Codable, CaseIterable {
        case github
        case vsts
        case jira
    }

    public init(id: String? = nil, url: String? = nil, title: String? = nil, bugTrackerType: BugTrackerType? = nil, repoName: String? = nil, mobileCenterID: String? = nil, eventType: String? = nil) {
        self.id = id
        self.url = url
        self.title = title
        self.bugTrackerType = bugTrackerType
        self.repoName = repoName
        self.mobileCenterID = mobileCenterID
        self.eventType = eventType
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case url
        case title
        case bugTrackerType = "bug_tracker_type"
        case repoName = "repo_name"
        case mobileCenterID = "mobile_center_id"
        case eventType = "event_type"
    }
}

/// Object returned in response to getting or updating the state of a bugtracker
public struct BugTrackerStateResult: Codable {
    /// Bugtracker state
    public var state: State?

    /// Bugtracker state
    public enum State: String, Codable, CaseIterable {
        case enabled
        case disabled
        case unauthorized
    }

    public init(state: State? = nil) {
        self.state = state
    }
}

/// Alerting service error
public struct AlertingError: Codable {
    /// Unique request identifier for tracking
    public var requestID: String
    /// The status code return by the API. It can be 400 or 404 or 409 or 500.
    public var code: Int
    /// The reason for the request failed
    public var message: String?

    public init(requestID: String, code: Int, message: String? = nil) {
        self.requestID = requestID
        self.code = code
        self.message = message
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.requestID = try values.decode(String.self, forKey: "request_id")
        self.code = try values.decode(Int.self, forKey: "code")
        self.message = try values.decodeIfPresent(String.self, forKey: "message")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(requestID, forKey: "request_id")
        try values.encode(code, forKey: "code")
        try values.encodeIfPresent(message, forKey: "message")
    }
}

public struct ActiveCrashingAppDetails: Codable {
    public var nextLink: String?
    /// Details of the apps with crashes
    public var appsWithCrashes: [AppsWithCrash]?

    public struct AppsWithCrash: Codable {
        /// Application identifier
        public var appID: String?
        /// Application version
        public var appVersion: String?
        /// Crash group identifier
        public var crashGroupID: String?

        public init(appID: String? = nil, appVersion: String? = nil, crashGroupID: String? = nil) {
            self.appID = appID
            self.appVersion = appVersion
            self.crashGroupID = crashGroupID
        }

        private enum CodingKeys: String, CodingKey {
            case appID = "appId"
            case appVersion
            case crashGroupID = "crashGroupId"
        }
    }

    public init(nextLink: String? = nil, appsWithCrashes: [AppsWithCrash]? = nil) {
        self.nextLink = nextLink
        self.appsWithCrashes = appsWithCrashes
    }
}

public struct LogTraceDefinition: Codable {
    public var appSecret: String
    public var installID: String?
    public var expiration: Date?

    public init(appSecret: String, installID: String? = nil, expiration: Date? = nil) {
        self.appSecret = appSecret
        self.installID = installID
        self.expiration = expiration
    }

    private enum CodingKeys: String, CodingKey {
        case appSecret = "app_secret"
        case installID = "install_id"
        case expiration
    }
}

public struct CrashingAppDetail: Codable {
    /// Application identifier
    public var appID: String?
    /// Application version
    public var appVersion: String?
    /// Crash group identifier
    public var crashGroupID: String?

    public init(appID: String? = nil, appVersion: String? = nil, crashGroupID: String? = nil) {
        self.appID = appID
        self.appVersion = appVersion
        self.crashGroupID = crashGroupID
    }

    private enum CodingKeys: String, CodingKey {
        case appID = "appId"
        case appVersion
        case crashGroupID = "crashGroupId"
    }
}

public struct LogContainer: Codable {
    /// Indicates if the number of available logs are more than the max allowed return limit(100).
    public var isExceededMaxLimit: Bool?
    /// The timestamp of the last log received. This value can be used as the start time parameter in the consecutive API call.
    public var lastReceivedLogTimestamp: Date?
    /// The list of logs
    public var logs: [Log]

    public struct Log: Codable {
        /// Log type.
        public var type: `Type`
        /// Log creation timestamp.
        public var timestamp: Date
        /// Install ID.
        public var installID: String
        /// Device characteristics.
        public var device: Device

        /// Log type.
        public enum `Type`: String, Codable, CaseIterable {
            case event
            case page
            case startSession = "start_session"
            case error
            case pushInstallation = "push_installation"
            case startService = "start_service"
            case customProperties = "custom_properties"
        }

        /// Device characteristics.
        public struct Device: Codable {
            /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
            public var sdkName: String
            /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
            public var sdkVersion: String
            /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
            public var wrapperSdkVersion: String?
            /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
            public var wrapperSdkName: String?
            /// Device model (example: iPad2,3).
            public var model: String?
            /// Device manufacturer (example: HTC).
            public var oemName: String?
            /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
            public var osName: String
            /// OS version (example: 9.3.0).
            public var osVersion: String
            /// OS build code (example: LMY47X).
            public var osBuild: String?
            /// API level when applicable like in Android (example: 15).
            public var osAPILevel: Int?
            /// Language code (example: en_US).
            public var locale: String
            /// The offset in minutes from UTC for the device time zone, including daylight savings time.
            public var timeZoneOffset: Int
            /// Screen size of the device in pixels (example: 640x480).
            public var screenSize: String?
            /// Application version name, e.g. 1.1.0
            public var appVersion: String
            /// Carrier name (for mobile devices).
            public var carrierName: String?
            /// Carrier country code (for mobile devices).
            public var carrierCode: String?
            /// Carrier country.
            public var carrierCountry: String?
            /// The app's build number, e.g. 42.
            public var appBuild: String
            /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
            public var appNamespace: String?
            /// Label that is used to identify application code 'version' released via Live Update beacon running on device
            public var liveUpdateReleaseLabel: String?
            /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
            public var liveUpdateDeploymentKey: String?
            /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
            public var liveUpdatePackageHash: String?
            /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
            public var wrapperRuntimeVersion: String?

            public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
                self.sdkName = sdkName
                self.sdkVersion = sdkVersion
                self.wrapperSdkVersion = wrapperSdkVersion
                self.wrapperSdkName = wrapperSdkName
                self.model = model
                self.oemName = oemName
                self.osName = osName
                self.osVersion = osVersion
                self.osBuild = osBuild
                self.osAPILevel = osAPILevel
                self.locale = locale
                self.timeZoneOffset = timeZoneOffset
                self.screenSize = screenSize
                self.appVersion = appVersion
                self.carrierName = carrierName
                self.carrierCode = carrierCode
                self.carrierCountry = carrierCountry
                self.appBuild = appBuild
                self.appNamespace = appNamespace
                self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
                self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
                self.liveUpdatePackageHash = liveUpdatePackageHash
                self.wrapperRuntimeVersion = wrapperRuntimeVersion
            }

            private enum CodingKeys: String, CodingKey {
                case sdkName = "sdk_name"
                case sdkVersion = "sdk_version"
                case wrapperSdkVersion = "wrapper_sdk_version"
                case wrapperSdkName = "wrapper_sdk_name"
                case model
                case oemName = "oem_name"
                case osName = "os_name"
                case osVersion = "os_version"
                case osBuild = "os_build"
                case osAPILevel = "os_api_level"
                case locale
                case timeZoneOffset = "time_zone_offset"
                case screenSize = "screen_size"
                case appVersion = "app_version"
                case carrierName = "carrier_name"
                case carrierCode = "carrier_code"
                case carrierCountry = "carrier_country"
                case appBuild = "app_build"
                case appNamespace = "app_namespace"
                case liveUpdateReleaseLabel = "live_update_release_label"
                case liveUpdateDeploymentKey = "live_update_deployment_key"
                case liveUpdatePackageHash = "live_update_package_hash"
                case wrapperRuntimeVersion = "wrapper_runtime_version"
            }
        }

        public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
            self.type = type
            self.timestamp = timestamp
            self.installID = installID
            self.device = device
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case timestamp
            case installID = "install_id"
            case device
        }
    }

    public init(isExceededMaxLimit: Bool? = nil, lastReceivedLogTimestamp: Date? = nil, logs: [Log]) {
        self.isExceededMaxLimit = isExceededMaxLimit
        self.lastReceivedLogTimestamp = lastReceivedLogTimestamp
        self.logs = logs
    }

    private enum CodingKeys: String, CodingKey {
        case isExceededMaxLimit = "exceeded_max_limit"
        case lastReceivedLogTimestamp = "last_received_log_timestamp"
        case logs
    }
}

public struct GenericLogContainer: Codable {
    /// Indicates if the number of available logs are more than the max allowed return limit(100).
    public var isExceededMaxLimit: Bool?
    /// The timestamp of the last log received. This value can be used as the start time parameter in the consecutive API call.
    public var lastReceivedLogTimestamp: Date?
    /// The list of logs
    public var logs: [Log]

    /// Generic log.
    public struct Log: Codable {
        /// Log type.
        public var type: `Type`
        /// Log creation timestamp.
        public var timestamp: Date
        /// Install ID.
        public var installID: String
        /// Session ID.
        public var sessionID: String?
        /// Event ID.
        public var eventID: String?
        /// Event name.
        public var eventName: String?
        /// Message ID.
        public var messageID: String?
        /// Event specific properties.
        public var properties: [String: String]?
        /// Device characteristics.
        public var device: Device
        /// Auth service provider.
        public var authProvider: String?
        /// Account ID of the authenticated user.
        public var accountID: String?

        /// Log type.
        public enum `Type`: String, Codable, CaseIterable {
            case event
            case page
            case startSession = "start_session"
            case error
            case pushInstallation = "push_installation"
            case startService = "start_service"
            case customProperties = "custom_properties"
        }

        /// Device characteristics.
        public struct Device: Codable {
            /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
            public var sdkName: String
            /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
            public var sdkVersion: String
            /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
            public var wrapperSdkVersion: String?
            /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
            public var wrapperSdkName: String?
            /// Device model (example: iPad2,3).
            public var model: String?
            /// Device manufacturer (example: HTC).
            public var oemName: String?
            /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
            public var osName: String
            /// OS version (example: 9.3.0).
            public var osVersion: String
            /// OS build code (example: LMY47X).
            public var osBuild: String?
            /// API level when applicable like in Android (example: 15).
            public var osAPILevel: Int?
            /// Language code (example: en_US).
            public var locale: String
            /// The offset in minutes from UTC for the device time zone, including daylight savings time.
            public var timeZoneOffset: Int
            /// Screen size of the device in pixels (example: 640x480).
            public var screenSize: String?
            /// Application version name, e.g. 1.1.0
            public var appVersion: String
            /// Carrier name (for mobile devices).
            public var carrierName: String?
            /// Carrier country code (for mobile devices).
            public var carrierCode: String?
            /// Carrier country.
            public var carrierCountry: String?
            /// The app's build number, e.g. 42.
            public var appBuild: String
            /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
            public var appNamespace: String?
            /// Label that is used to identify application code 'version' released via Live Update beacon running on device
            public var liveUpdateReleaseLabel: String?
            /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
            public var liveUpdateDeploymentKey: String?
            /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
            public var liveUpdatePackageHash: String?
            /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
            public var wrapperRuntimeVersion: String?

            public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
                self.sdkName = sdkName
                self.sdkVersion = sdkVersion
                self.wrapperSdkVersion = wrapperSdkVersion
                self.wrapperSdkName = wrapperSdkName
                self.model = model
                self.oemName = oemName
                self.osName = osName
                self.osVersion = osVersion
                self.osBuild = osBuild
                self.osAPILevel = osAPILevel
                self.locale = locale
                self.timeZoneOffset = timeZoneOffset
                self.screenSize = screenSize
                self.appVersion = appVersion
                self.carrierName = carrierName
                self.carrierCode = carrierCode
                self.carrierCountry = carrierCountry
                self.appBuild = appBuild
                self.appNamespace = appNamespace
                self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
                self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
                self.liveUpdatePackageHash = liveUpdatePackageHash
                self.wrapperRuntimeVersion = wrapperRuntimeVersion
            }

            private enum CodingKeys: String, CodingKey {
                case sdkName = "sdk_name"
                case sdkVersion = "sdk_version"
                case wrapperSdkVersion = "wrapper_sdk_version"
                case wrapperSdkName = "wrapper_sdk_name"
                case model
                case oemName = "oem_name"
                case osName = "os_name"
                case osVersion = "os_version"
                case osBuild = "os_build"
                case osAPILevel = "os_api_level"
                case locale
                case timeZoneOffset = "time_zone_offset"
                case screenSize = "screen_size"
                case appVersion = "app_version"
                case carrierName = "carrier_name"
                case carrierCode = "carrier_code"
                case carrierCountry = "carrier_country"
                case appBuild = "app_build"
                case appNamespace = "app_namespace"
                case liveUpdateReleaseLabel = "live_update_release_label"
                case liveUpdateDeploymentKey = "live_update_deployment_key"
                case liveUpdatePackageHash = "live_update_package_hash"
                case wrapperRuntimeVersion = "wrapper_runtime_version"
            }
        }

        public init(type: `Type`, timestamp: Date, installID: String, sessionID: String? = nil, eventID: String? = nil, eventName: String? = nil, messageID: String? = nil, properties: [String: String]? = nil, device: Device, authProvider: String? = nil, accountID: String? = nil) {
            self.type = type
            self.timestamp = timestamp
            self.installID = installID
            self.sessionID = sessionID
            self.eventID = eventID
            self.eventName = eventName
            self.messageID = messageID
            self.properties = properties
            self.device = device
            self.authProvider = authProvider
            self.accountID = accountID
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case timestamp
            case installID = "install_id"
            case sessionID = "session_id"
            case eventID = "event_id"
            case eventName = "event_name"
            case messageID = "message_id"
            case properties
            case device
            case authProvider = "auth_provider"
            case accountID = "account_id"
        }
    }

    public init(isExceededMaxLimit: Bool? = nil, lastReceivedLogTimestamp: Date? = nil, logs: [Log]) {
        self.isExceededMaxLimit = isExceededMaxLimit
        self.lastReceivedLogTimestamp = lastReceivedLogTimestamp
        self.logs = logs
    }

    private enum CodingKeys: String, CodingKey {
        case isExceededMaxLimit = "exceeded_max_limit"
        case lastReceivedLogTimestamp = "last_received_log_timestamp"
        case logs
    }
}

/// Generic log.
public struct GenericLog: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Session ID.
    public var sessionID: String?
    /// Event ID.
    public var eventID: String?
    /// Event name.
    public var eventName: String?
    /// Message ID.
    public var messageID: String?
    /// Event specific properties.
    public var properties: [String: String]?
    /// Device characteristics.
    public var device: Device
    /// Auth service provider.
    public var authProvider: String?
    /// Account ID of the authenticated user.
    public var accountID: String?

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, sessionID: String? = nil, eventID: String? = nil, eventName: String? = nil, messageID: String? = nil, properties: [String: String]? = nil, device: Device, authProvider: String? = nil, accountID: String? = nil) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.sessionID = sessionID
        self.eventID = eventID
        self.eventName = eventName
        self.messageID = messageID
        self.properties = properties
        self.device = device
        self.authProvider = authProvider
        self.accountID = accountID
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case timestamp
        case installID = "install_id"
        case sessionID = "session_id"
        case eventID = "event_id"
        case eventName = "event_name"
        case messageID = "message_id"
        case properties
        case device
        case authProvider = "auth_provider"
        case accountID = "account_id"
    }
}

public struct Log: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case timestamp
        case installID = "install_id"
        case device
    }
}

public struct LogWithProperties: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

/// Device characteristics.
public struct Device: Codable {
    /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
    public var sdkName: String
    /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
    public var sdkVersion: String
    /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
    public var wrapperSdkVersion: String?
    /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
    public var wrapperSdkName: String?
    /// Device model (example: iPad2,3).
    public var model: String?
    /// Device manufacturer (example: HTC).
    public var oemName: String?
    /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
    public var osName: String
    /// OS version (example: 9.3.0).
    public var osVersion: String
    /// OS build code (example: LMY47X).
    public var osBuild: String?
    /// API level when applicable like in Android (example: 15).
    public var osAPILevel: Int?
    /// Language code (example: en_US).
    public var locale: String
    /// The offset in minutes from UTC for the device time zone, including daylight savings time.
    public var timeZoneOffset: Int
    /// Screen size of the device in pixels (example: 640x480).
    public var screenSize: String?
    /// Application version name, e.g. 1.1.0
    public var appVersion: String
    /// Carrier name (for mobile devices).
    public var carrierName: String?
    /// Carrier country code (for mobile devices).
    public var carrierCode: String?
    /// Carrier country.
    public var carrierCountry: String?
    /// The app's build number, e.g. 42.
    public var appBuild: String
    /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
    public var appNamespace: String?
    /// Label that is used to identify application code 'version' released via Live Update beacon running on device
    public var liveUpdateReleaseLabel: String?
    /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
    public var liveUpdateDeploymentKey: String?
    /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
    public var liveUpdatePackageHash: String?
    /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
    public var wrapperRuntimeVersion: String?

    public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
        self.sdkName = sdkName
        self.sdkVersion = sdkVersion
        self.wrapperSdkVersion = wrapperSdkVersion
        self.wrapperSdkName = wrapperSdkName
        self.model = model
        self.oemName = oemName
        self.osName = osName
        self.osVersion = osVersion
        self.osBuild = osBuild
        self.osAPILevel = osAPILevel
        self.locale = locale
        self.timeZoneOffset = timeZoneOffset
        self.screenSize = screenSize
        self.appVersion = appVersion
        self.carrierName = carrierName
        self.carrierCode = carrierCode
        self.carrierCountry = carrierCountry
        self.appBuild = appBuild
        self.appNamespace = appNamespace
        self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
        self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
        self.liveUpdatePackageHash = liveUpdatePackageHash
        self.wrapperRuntimeVersion = wrapperRuntimeVersion
    }

    private enum CodingKeys: String, CodingKey {
        case sdkName = "sdk_name"
        case sdkVersion = "sdk_version"
        case wrapperSdkVersion = "wrapper_sdk_version"
        case wrapperSdkName = "wrapper_sdk_name"
        case model
        case oemName = "oem_name"
        case osName = "os_name"
        case osVersion = "os_version"
        case osBuild = "os_build"
        case osAPILevel = "os_api_level"
        case locale
        case timeZoneOffset = "time_zone_offset"
        case screenSize = "screen_size"
        case appVersion = "app_version"
        case carrierName = "carrier_name"
        case carrierCode = "carrier_code"
        case carrierCountry = "carrier_country"
        case appBuild = "app_build"
        case appNamespace = "app_namespace"
        case liveUpdateReleaseLabel = "live_update_release_label"
        case liveUpdateDeploymentKey = "live_update_deployment_key"
        case liveUpdatePackageHash = "live_update_package_hash"
        case wrapperRuntimeVersion = "wrapper_runtime_version"
    }
}

/// Required explicit begin session log (a marker event for analytics service).
public struct StartSessionLog: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

/// Log is used to update distribution group identifier for session (a marker event for analytics service).
public struct DistributionStartSessionLog: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

/// Required explicit begin session log (a marker event for analytics service).
public struct HandledErrorLog: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

/// Required explicit begin session log (a marker event for analytics service).
public struct UnhandledErrorLog: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

/// Describe a AppCenter.Start API call from the SDK.
public struct StartServiceLog: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

/// Set or remove custom properties.
public struct CustomPropertyLog: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

public struct CustomProperty: Codable {
    public var type: String
    public var name: String

    public init(type: String, name: String) {
        self.type = type
        self.name = name
    }
}

/// String property.
public struct StringProperty: Codable {
    public var type: String
    public var name: String

    public init(type: String, name: String) {
        self.type = type
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.name = try values.decode(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(name, forKey: "name")
    }
}

/// Number property.
public struct NumberProperty: Codable {
    public var type: String
    public var name: String

    public init(type: String, name: String) {
        self.type = type
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.name = try values.decode(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(name, forKey: "name")
    }
}

/// Boolean property.
public struct BooleanProperty: Codable {
    public var type: String
    public var name: String

    public init(type: String, name: String) {
        self.type = type
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.name = try values.decode(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(name, forKey: "name")
    }
}

/// Date and time property.
public struct DateTimeProperty: Codable {
    public var type: String
    public var name: String

    public init(type: String, name: String) {
        self.type = type
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.name = try values.decode(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(name, forKey: "name")
    }
}

/// Clear an existing property.
public struct ClearProperty: Codable {
    public var type: String
    public var name: String

    public init(type: String, name: String) {
        self.type = type
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.name = try values.decode(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(name, forKey: "name")
    }
}

public struct PageLog: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

public struct EventLog: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

/// Error log.
public struct ErrorLog: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

/// List of audiences.
public struct AudienceListResult: Codable {
    /// List of audiences.
    public var values: [Value]
    public var nextLink: String?

    /// Audience definition.
    public struct Value: Codable {
        /// Audience name.
        public var name: String?
        /// Audience description.
        public var description: String?
        /// Estimated audience size.
        public var estimatedCount: Int?
        /// Audience definition in OData format.
        public var definition: String?
        /// Audience state.
        public var state: State?

        /// Audience state.
        public enum State: String, Codable, CaseIterable {
            case calculating = "Calculating"
            case ready = "Ready"
            case disabled = "Disabled"
        }

        public init(name: String? = nil, description: String? = nil, estimatedCount: Int? = nil, definition: String? = nil, state: State? = nil) {
            self.name = name
            self.description = description
            self.estimatedCount = estimatedCount
            self.definition = definition
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case description
            case estimatedCount = "estimated_count"
            case definition
            case state
        }
    }

    public init(values: [Value], nextLink: String? = nil) {
        self.values = values
        self.nextLink = nextLink
    }
}

/// Audience definition.
public struct AudienceSummary: Codable {
    /// Audience name.
    public var name: String?
    /// Audience description.
    public var description: String?
    /// Estimated audience size.
    public var estimatedCount: Int?
    /// Audience definition in OData format.
    public var definition: String?
    /// Audience state.
    public var state: State?

    /// Audience state.
    public enum State: String, Codable, CaseIterable {
        case calculating = "Calculating"
        case ready = "Ready"
        case disabled = "Disabled"
    }

    public init(name: String? = nil, description: String? = nil, estimatedCount: Int? = nil, definition: String? = nil, state: State? = nil) {
        self.name = name
        self.description = description
        self.estimatedCount = estimatedCount
        self.definition = definition
        self.state = state
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case description
        case estimatedCount = "estimated_count"
        case definition
        case state
    }
}

/// Audience with details.
public struct Audience: Codable {
    /// Audience name.
    public var name: String?
    /// Audience description.
    public var description: String?
    /// Estimated audience size.
    public var estimatedCount: Int?
    /// Audience definition in OData format.
    public var definition: String?
    /// Audience state.
    public var state: State?

    /// Audience state.
    public enum State: String, Codable, CaseIterable {
        case calculating = "Calculating"
        case ready = "Ready"
        case disabled = "Disabled"
    }

    public init(name: String? = nil, description: String? = nil, estimatedCount: Int? = nil, definition: String? = nil, state: State? = nil) {
        self.name = name
        self.description = description
        self.estimatedCount = estimatedCount
        self.definition = definition
        self.state = state
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.estimatedCount = try values.decodeIfPresent(Int.self, forKey: "estimated_count")
        self.definition = try values.decodeIfPresent(String.self, forKey: "definition")
        self.state = try State(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(estimatedCount, forKey: "estimated_count")
        try values.encodeIfPresent(definition, forKey: "definition")
        try values.encodeIfPresent(state, forKey: "state")
    }
}

/// Audience test result.
public struct AudienceTestResult: Codable {
    /// Audience definition in OData format.
    public var definition: String?
    /// Custom properties used in the definition.
    public var customProperties: [String: CustomProperty]?
    /// Estimated audience size.
    public var estimatedCount: Int?
    /// Estimated total audience size.
    public var estimatedTotalCount: Int?

    public enum CustomProperty: String, Codable, CaseIterable {
        case string
        case number
        case boolean
        case dateTime = "date_time"
    }

    public init(definition: String? = nil, customProperties: [String: CustomProperty]? = nil, estimatedCount: Int? = nil, estimatedTotalCount: Int? = nil) {
        self.definition = definition
        self.customProperties = customProperties
        self.estimatedCount = estimatedCount
        self.estimatedTotalCount = estimatedTotalCount
    }

    private enum CodingKeys: String, CodingKey {
        case definition
        case customProperties = "custom_properties"
        case estimatedCount = "estimated_count"
        case estimatedTotalCount = "estimated_total_count"
    }
}

/// Token query result.
public struct TokenQueryResult: Codable {
    /// List of tokens.
    public var tokens: [String]?

    public init(tokens: [String]? = nil) {
        self.tokens = tokens
    }
}

/// Audience definition.
public struct AudienceDefinition: Codable {
    /// Audience description.
    public var description: String?
    /// Audience definition in OData format.
    public var definition: String
    public var isEnabled: Bool
    /// Custom properties used in the definition.
    public var customProperties: [String: CustomProperty]?

    public enum CustomProperty: String, Codable, CaseIterable {
        case string
        case number
        case boolean
        case dateTime = "date_time"
    }

    public init(description: String? = nil, definition: String, isEnabled: Bool? = nil, customProperties: [String: CustomProperty]? = nil) {
        self.description = description
        self.definition = definition
        self.isEnabled = isEnabled ?? true
        self.customProperties = customProperties
    }

    private enum CodingKeys: String, CodingKey {
        case description
        case definition
        case isEnabled = "enabled"
        case customProperties = "custom_properties"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.description = try values.decodeIfPresent(String.self, forKey: .description)
        self.definition = try values.decode(String.self, forKey: .definition)
        self.isEnabled = try values.decodeIfPresent(Bool.self, forKey: .isEnabled) ?? true
        self.customProperties = try values.decodeIfPresent([String: CustomProperty].self, forKey: .customProperties)
    }
}

/// Audience Query definition.
public struct AudienceQueryDefinition: Codable {
    /// Audience Query Type
    public var queryType: QueryType
    /// List of identifiers.
    public var identifiers: [String]?

    /// Audience Query Type
    public enum QueryType: String, Codable, CaseIterable {
        case broadcast
        case userIDs = "user_ids"
        case accountIDs = "account_ids"
        case installIDs = "install_ids"
    }

    public init(queryType: QueryType, identifiers: [String]? = nil) {
        self.queryType = queryType
        self.identifiers = identifiers
    }
}

/// Audience definition.
public struct AudienceBlobResult: Codable {
    /// Location of the audience blob.
    public var url: String?

    public init(url: String? = nil) {
        self.url = url
    }
}

/// List of device properties.
public struct AudienceDevicePropertiesListResult: Codable {
    /// List of device properties.
    public var values: [String: Value]

    /// Type of the property.
    public enum Value: String, Codable, CaseIterable {
        case string
        case number
        case boolean
        case dateTime = "date_time"
    }

    public init(values: [String: Value]) {
        self.values = values
    }
}

/// List of device property values.
public struct AudienceDevicePropertyValuesListResult: Codable {
    /// List of device property values.
    public var values: [String]

    public init(values: [String]) {
        self.values = values
    }
}

public struct CrashCounts: Codable {
    /// Total crash count.
    public var count: Int?
    /// The total crash count for day.
    public var crashes: [Crash]?

    public struct Crash: Codable {
        /// The ISO 8601 datetime.
        public var datetime: String?
        /// Count of the object.
        public var count: Int?

        public init(datetime: String? = nil, count: Int? = nil) {
            self.datetime = datetime
            self.count = count
        }
    }

    public init(count: Int? = nil, crashes: [Crash]? = nil) {
        self.count = count
        self.crashes = crashes
    }
}

public struct ActiveDeviceCounts: Codable {
    /// The active device count for each interval.
    public var daily: [DailyItem]?
    /// The active device count for each interval with a week's retention.
    public var weekly: [WeeklyItem]?
    /// The active device count for each interval with a month's retention.
    public var monthly: [MonthlyItem]?

    public struct DailyItem: Codable {
        /// The ISO 8601 datetime.
        public var datetime: String?
        /// Count of the object.
        public var count: Int?

        public init(datetime: String? = nil, count: Int? = nil) {
            self.datetime = datetime
            self.count = count
        }
    }

    public struct WeeklyItem: Codable {
        /// The ISO 8601 datetime.
        public var datetime: String?
        /// Count of the object.
        public var count: Int?

        public init(datetime: String? = nil, count: Int? = nil) {
            self.datetime = datetime
            self.count = count
        }
    }

    public struct MonthlyItem: Codable {
        /// The ISO 8601 datetime.
        public var datetime: String?
        /// Count of the object.
        public var count: Int?

        public init(datetime: String? = nil, count: Int? = nil) {
            self.datetime = datetime
            self.count = count
        }
    }

    public init(daily: [DailyItem]? = nil, weekly: [WeeklyItem]? = nil, monthly: [MonthlyItem]? = nil) {
        self.daily = daily
        self.weekly = weekly
        self.monthly = monthly
    }
}

/// Places and count during the time range in descending order.
public struct Places: Codable {
    public var total: Int?
    public var places: [Place]?

    /// The place code and the count.
    public struct Place: Codable {
        /// The place code.
        public var code: String?
        /// The count of the this place.
        public var count: Int?
        /// The count of previous time range of the place.
        public var previousCount: Int?

        public init(code: String? = nil, count: Int? = nil, previousCount: Int? = nil) {
            self.code = code
            self.count = count
            self.previousCount = previousCount
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case count
            case previousCount = "previous_count"
        }
    }

    public init(total: Int? = nil, places: [Place]? = nil) {
        self.total = total
        self.places = places
    }
}

/// The place code and the count.
public struct Place: Codable {
    /// The place code.
    public var code: String?
    /// The count of the this place.
    public var count: Int?
    /// The count of previous time range of the place.
    public var previousCount: Int?

    public init(code: String? = nil, count: Int? = nil, previousCount: Int? = nil) {
        self.code = code
        self.count = count
        self.previousCount = previousCount
    }

    private enum CodingKeys: String, CodingKey {
        case code
        case count
        case previousCount = "previous_count"
    }
}

/// Error
public struct Error: Codable {
    public var error: Error?

    public struct Error: Codable {
        /// The status code return by the API. It can be 400 or 403 or 500.
        public var code: Int?
        /// The reason for the request failed.
        public var message: String?

        public init(code: Int? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }
    }

    public init(error: Error? = nil) {
        self.error = error
    }
}

public struct SessionDurationsDistribution: Codable {
    /// The count of sessions in these buckets.
    public var distribution: [DistributionItem]?
    /// The previous average session duration for previous time range.
    public var previousAverageDuration: String?
    /// The average session duration for current time range.
    public var averageDuration: String?

    public struct DistributionItem: Codable {
        /// The bucket name.
        public var bucket: String?
        /// The count of sessions in current bucket.
        public var count: Int?

        public init(bucket: String? = nil, count: Int? = nil) {
            self.bucket = bucket
            self.count = count
        }
    }

    public init(distribution: [DistributionItem]? = nil, previousAverageDuration: String? = nil, averageDuration: String? = nil) {
        self.distribution = distribution
        self.previousAverageDuration = previousAverageDuration
        self.averageDuration = averageDuration
    }

    private enum CodingKeys: String, CodingKey {
        case distribution
        case previousAverageDuration = "previous_average_duration"
        case averageDuration = "average_duration"
    }
}

public struct Versions: Codable {
    /// List of version count.
    public var versions: [Version]?
    /// The total count of versions.
    public var total: Int?

    public struct Version: Codable {
        /// Version.
        public var version: String?
        /// Version count.
        public var count: Int?
        /// The count of previous time range of the version.
        public var previousCount: Int?

        public init(version: String? = nil, count: Int? = nil, previousCount: Int? = nil) {
            self.version = version
            self.count = count
            self.previousCount = previousCount
        }

        private enum CodingKeys: String, CodingKey {
            case version
            case count
            case previousCount = "previous_count"
        }
    }

    public init(versions: [Version]? = nil, total: Int? = nil) {
        self.versions = versions
        self.total = total
    }
}

public struct Version: Codable {
    /// Version.
    public var version: String?
    /// Version count.
    public var count: Int?
    /// The count of previous time range of the version.
    public var previousCount: Int?

    public init(version: String? = nil, count: Int? = nil, previousCount: Int? = nil) {
        self.version = version
        self.count = count
        self.previousCount = previousCount
    }

    private enum CodingKeys: String, CodingKey {
        case version
        case count
        case previousCount = "previous_count"
    }
}

public struct SessionCount: Codable {
    /// The ISO 8601 datetime.
    public var datetime: String?
    /// Count of the object.
    public var count: Int?

    public init(datetime: String? = nil, count: Int? = nil) {
        self.datetime = datetime
        self.count = count
    }
}

public struct SessionsPerDevice: Codable {
    /// Average seesion per user.
    public var averageSessionsPerUser: Double?
    /// Previous average session per user.
    public var previousAverageSessionsPerUser: Double?
    /// Total session per device count.
    public var totalCount: Int?
    /// Previous total count.
    public var previousTotalCount: Int?
    /// The session count for each interval per device.
    public var sessionsPerUser: [SessionsPerUserItem]?

    public struct SessionsPerUserItem: Codable {
        /// The ISO 8601 datetime.
        public var datetime: String?
        /// Count.
        public var count: Double?

        public init(datetime: String? = nil, count: Double? = nil) {
            self.datetime = datetime
            self.count = count
        }
    }

    public init(averageSessionsPerUser: Double? = nil, previousAverageSessionsPerUser: Double? = nil, totalCount: Int? = nil, previousTotalCount: Int? = nil, sessionsPerUser: [SessionsPerUserItem]? = nil) {
        self.averageSessionsPerUser = averageSessionsPerUser
        self.previousAverageSessionsPerUser = previousAverageSessionsPerUser
        self.totalCount = totalCount
        self.previousTotalCount = previousTotalCount
        self.sessionsPerUser = sessionsPerUser
    }

    private enum CodingKeys: String, CodingKey {
        case averageSessionsPerUser = "average_sessions_per_user"
        case previousAverageSessionsPerUser = "previous_average_sessions_per_user"
        case totalCount = "total_count"
        case previousTotalCount = "previous_total_count"
        case sessionsPerUser = "sessions_per_user"
    }
}

public struct AnalyticsModels: Codable {
    public var total: Int?
    public var models: [Model]?

    public struct Model: Codable {
        /// Model's name.
        public var modelName: String?
        /// Count current of model.
        public var count: Int?
        /// Count of previous model.
        public var previousCount: Int?

        public init(modelName: String? = nil, count: Int? = nil, previousCount: Int? = nil) {
            self.modelName = modelName
            self.count = count
            self.previousCount = previousCount
        }

        private enum CodingKeys: String, CodingKey {
            case modelName = "model_name"
            case count
            case previousCount = "previous_count"
        }
    }

    public init(total: Int? = nil, models: [Model]? = nil) {
        self.total = total
        self.models = models
    }
}

public struct Model: Codable {
    /// Model's name.
    public var modelName: String?
    /// Count current of model.
    public var count: Int?
    /// Count of previous model.
    public var previousCount: Int?

    public init(modelName: String? = nil, count: Int? = nil, previousCount: Int? = nil) {
        self.modelName = modelName
        self.count = count
        self.previousCount = previousCount
    }

    private enum CodingKeys: String, CodingKey {
        case modelName = "model_name"
        case count
        case previousCount = "previous_count"
    }
}

public struct Languages: Codable {
    public var total: Int?
    public var languages: [Language]?

    public struct Language: Codable {
        /// Language's name.
        public var languageName: String?
        /// Count current of language.
        public var count: Int?
        /// Count of previous lanugage.
        public var previousCount: Int?

        public init(languageName: String? = nil, count: Int? = nil, previousCount: Int? = nil) {
            self.languageName = languageName
            self.count = count
            self.previousCount = previousCount
        }

        private enum CodingKeys: String, CodingKey {
            case languageName = "language_name"
            case count
            case previousCount = "previous_count"
        }
    }

    public init(total: Int? = nil, languages: [Language]? = nil) {
        self.total = total
        self.languages = languages
    }
}

public struct Language: Codable {
    /// Language's name.
    public var languageName: String?
    /// Count current of language.
    public var count: Int?
    /// Count of previous lanugage.
    public var previousCount: Int?

    public init(languageName: String? = nil, count: Int? = nil, previousCount: Int? = nil) {
        self.languageName = languageName
        self.count = count
        self.previousCount = previousCount
    }

    private enum CodingKeys: String, CodingKey {
        case languageName = "language_name"
        case count
        case previousCount = "previous_count"
    }
}

public struct OSes: Codable {
    public var total: Int?
    public var oses: [Ose]?

    public struct Ose: Codable {
        /// OS name.
        public var osName: String?
        /// Count current of OS.
        public var count: Int?
        /// Count of previous OS.
        public var previousCount: Int?

        public init(osName: String? = nil, count: Int? = nil, previousCount: Int? = nil) {
            self.osName = osName
            self.count = count
            self.previousCount = previousCount
        }

        private enum CodingKeys: String, CodingKey {
            case osName = "os_name"
            case count
            case previousCount = "previous_count"
        }
    }

    public init(total: Int? = nil, oses: [Ose]? = nil) {
        self.total = total
        self.oses = oses
    }
}

public struct Os: Codable {
    /// OS name.
    public var osName: String?
    /// Count current of OS.
    public var count: Int?
    /// Count of previous OS.
    public var previousCount: Int?

    public init(osName: String? = nil, count: Int? = nil, previousCount: Int? = nil) {
        self.osName = osName
        self.count = count
        self.previousCount = previousCount
    }

    private enum CodingKeys: String, CodingKey {
        case osName = "os_name"
        case count
        case previousCount = "previous_count"
    }
}

public struct DateTimeCounts: Codable {
    /// The ISO 8601 datetime.
    public var datetime: String?
    /// Count of the object.
    public var count: Int?

    public init(datetime: String? = nil, count: Int? = nil) {
        self.datetime = datetime
        self.count = count
    }
}

public struct DateTimeDecimalCounts: Codable {
    /// The ISO 8601 datetime.
    public var datetime: String?
    /// Decimal count of the object.
    public var count: Double?

    public init(datetime: String? = nil, count: Double? = nil) {
        self.datetime = datetime
        self.count = count
    }
}

public struct AvailableVersions: Codable {
    /// List of available versions.
    public var versions: [String]?
    /// The full number of versions across all pages.
    public var totalCount: Int?

    public init(versions: [String]? = nil, totalCount: Int? = nil) {
        self.versions = versions
        self.totalCount = totalCount
    }

    private enum CodingKeys: String, CodingKey {
        case versions
        case totalCount = "total_count"
    }
}

public struct AvailableAppBuilds: Codable {
    /// List of available app builds.
    public var appBuilds: [String]?

    public init(appBuilds: [String]? = nil) {
        self.appBuilds = appBuilds
    }

    private enum CodingKeys: String, CodingKey {
        case appBuilds = "app_builds"
    }
}

public struct CrashFreeDevicePercentages: Codable {
    /// Average percentage.
    public var averagePercentage: Double?
    /// The crash-free percentage per day.
    public var dailyPercentages: [DailyPercentage]?

    public struct DailyPercentage: Codable {
        /// The ISO 8601 datetime.
        public var datetime: String?
        /// Percentage of the object.
        public var percentage: Double?

        public init(datetime: String? = nil, percentage: Double? = nil) {
            self.datetime = datetime
            self.percentage = percentage
        }
    }

    public init(averagePercentage: Double? = nil, dailyPercentages: [DailyPercentage]? = nil) {
        self.averagePercentage = averagePercentage
        self.dailyPercentages = dailyPercentages
    }

    private enum CodingKeys: String, CodingKey {
        case averagePercentage = "average_percentage"
        case dailyPercentages = "daily_percentages"
    }
}

public struct Modules: Codable {
    public var modules: [String: [String: Bool]]?

    public init(modules: [String: [String: Bool]]? = nil) {
        self.modules = modules
    }
}

public struct DateTimePercentages: Codable {
    /// The ISO 8601 datetime.
    public var datetime: String?
    /// Percentage of the object.
    public var percentage: Double?

    public init(datetime: String? = nil, percentage: Double? = nil) {
        self.datetime = datetime
        self.percentage = percentage
    }
}

public struct CrashesOverallItem: Codable {
    public var crashGroupID: String?
    public var appVersion: String?
    public var overall: Overall?

    public struct Overall: Codable {
        public var crashCount: Int?
        public var deviceCount: Int?

        public init(crashCount: Int? = nil, deviceCount: Int? = nil) {
            self.crashCount = crashCount
            self.deviceCount = deviceCount
        }

        private enum CodingKeys: String, CodingKey {
            case crashCount = "crash_count"
            case deviceCount = "device_count"
        }
    }

    public init(crashGroupID: String? = nil, appVersion: String? = nil, overall: Overall? = nil) {
        self.crashGroupID = crashGroupID
        self.appVersion = appVersion
        self.overall = overall
    }

    private enum CodingKeys: String, CodingKey {
        case crashGroupID = "crash_group_id"
        case appVersion = "app_version"
        case overall
    }
}

public struct CrashOverall: Codable {
    public var crashCount: Int?
    public var deviceCount: Int?

    public init(crashCount: Int? = nil, deviceCount: Int? = nil) {
        self.crashCount = crashCount
        self.deviceCount = deviceCount
    }

    private enum CodingKeys: String, CodingKey {
        case crashCount = "crash_count"
        case deviceCount = "device_count"
    }
}

public struct CrashGroupModels: Codable {
    public var crashCount: Int?
    public var models: [Model]?

    public struct Model: Codable {
        /// Model's name.
        public var modelName: String?
        /// Count of model.
        public var crashCount: Int?

        public init(modelName: String? = nil, crashCount: Int? = nil) {
            self.modelName = modelName
            self.crashCount = crashCount
        }

        private enum CodingKeys: String, CodingKey {
            case modelName = "model_name"
            case crashCount = "crash_count"
        }
    }

    public init(crashCount: Int? = nil, models: [Model]? = nil) {
        self.crashCount = crashCount
        self.models = models
    }

    private enum CodingKeys: String, CodingKey {
        case crashCount = "crash_count"
        case models
    }
}

public struct CrashGroupModel: Codable {
    /// Model's name.
    public var modelName: String?
    /// Count of model.
    public var crashCount: Int?

    public init(modelName: String? = nil, crashCount: Int? = nil) {
        self.modelName = modelName
        self.crashCount = crashCount
    }

    private enum CodingKeys: String, CodingKey {
        case modelName = "model_name"
        case crashCount = "crash_count"
    }
}

public struct CrashGroupOperatingSystems: Codable {
    public var crashCount: Int?
    public var operatingSystems: [OperatingSystem]?

    public struct OperatingSystem: Codable {
        /// OS name.
        public var operatingSystemName: String?
        /// Count of OS.
        public var crashCount: Int?

        public init(operatingSystemName: String? = nil, crashCount: Int? = nil) {
            self.operatingSystemName = operatingSystemName
            self.crashCount = crashCount
        }

        private enum CodingKeys: String, CodingKey {
            case operatingSystemName = "operating_system_name"
            case crashCount = "crash_count"
        }
    }

    public init(crashCount: Int? = nil, operatingSystems: [OperatingSystem]? = nil) {
        self.crashCount = crashCount
        self.operatingSystems = operatingSystems
    }

    private enum CodingKeys: String, CodingKey {
        case crashCount = "crash_count"
        case operatingSystems = "operating_systems"
    }
}

public struct CrashGroupOperatingSystem: Codable {
    /// OS name.
    public var operatingSystemName: String?
    /// Count of OS.
    public var crashCount: Int?

    public init(operatingSystemName: String? = nil, crashCount: Int? = nil) {
        self.operatingSystemName = operatingSystemName
        self.crashCount = crashCount
    }

    private enum CodingKeys: String, CodingKey {
        case operatingSystemName = "operating_system_name"
        case crashCount = "crash_count"
    }
}

public struct CrashGroupPlaces: Codable {
    public var crashCount: Int?
    public var places: [Place]?

    public struct Place: Codable {
        /// Place name.
        public var placeName: String?
        /// Count of places.
        public var crashCount: Int?

        public init(placeName: String? = nil, crashCount: Int? = nil) {
            self.placeName = placeName
            self.crashCount = crashCount
        }

        private enum CodingKeys: String, CodingKey {
            case placeName = "place_name"
            case crashCount = "crash_count"
        }
    }

    public init(crashCount: Int? = nil, places: [Place]? = nil) {
        self.crashCount = crashCount
        self.places = places
    }

    private enum CodingKeys: String, CodingKey {
        case crashCount = "crash_count"
        case places
    }
}

public struct CrashGroupPlace: Codable {
    /// Place name.
    public var placeName: String?
    /// Count of places.
    public var crashCount: Int?

    public init(placeName: String? = nil, crashCount: Int? = nil) {
        self.placeName = placeName
        self.crashCount = crashCount
    }

    private enum CodingKeys: String, CodingKey {
        case placeName = "place_name"
        case crashCount = "crash_count"
    }
}

public struct CrashGroupLanguages: Codable {
    public var crashCount: Int?
    public var languages: [Language]?

    public struct Language: Codable {
        /// Language name.
        public var languageName: String?
        /// Count of languages.
        public var crashCount: Int?

        public init(languageName: String? = nil, crashCount: Int? = nil) {
            self.languageName = languageName
            self.crashCount = crashCount
        }

        private enum CodingKeys: String, CodingKey {
            case languageName = "language_name"
            case crashCount = "crash_count"
        }
    }

    public init(crashCount: Int? = nil, languages: [Language]? = nil) {
        self.crashCount = crashCount
        self.languages = languages
    }

    private enum CodingKeys: String, CodingKey {
        case crashCount = "crash_count"
        case languages
    }
}

public struct CrashGroupLanguage: Codable {
    /// Language name.
    public var languageName: String?
    /// Count of languages.
    public var crashCount: Int?

    public init(languageName: String? = nil, crashCount: Int? = nil) {
        self.languageName = languageName
        self.crashCount = crashCount
    }

    private enum CodingKeys: String, CodingKey {
        case languageName = "language_name"
        case crashCount = "crash_count"
    }
}

public struct CrashGroupCarriers: Codable {
    public var crashCount: Int?
    public var carriers: [Carrier]?

    public struct Carrier: Codable {
        /// Carrier name.
        public var carrierName: String?
        /// Crash count of carrier.
        public var crashCount: Int?

        public init(carrierName: String? = nil, crashCount: Int? = nil) {
            self.carrierName = carrierName
            self.crashCount = crashCount
        }

        private enum CodingKeys: String, CodingKey {
            case carrierName = "carrier_name"
            case crashCount = "crash_count"
        }
    }

    public init(crashCount: Int? = nil, carriers: [Carrier]? = nil) {
        self.crashCount = crashCount
        self.carriers = carriers
    }

    private enum CodingKeys: String, CodingKey {
        case crashCount = "crash_count"
        case carriers
    }
}

public struct CrashGroupCarrier: Codable {
    /// Carrier name.
    public var carrierName: String?
    /// Crash count of carrier.
    public var crashCount: Int?

    public init(carrierName: String? = nil, crashCount: Int? = nil) {
        self.carrierName = carrierName
        self.crashCount = crashCount
    }

    private enum CodingKeys: String, CodingKey {
        case carrierName = "carrier_name"
        case crashCount = "crash_count"
    }
}

public struct CrashGroupContainer: Codable {
    public var crashGroups: [CrashGroup]

    public struct CrashGroup: Codable {
        public var crashGroupID: String?
        public var appVersion: String?

        public init(crashGroupID: String? = nil, appVersion: String? = nil) {
            self.crashGroupID = crashGroupID
            self.appVersion = appVersion
        }

        private enum CodingKeys: String, CodingKey {
            case crashGroupID = "crash_group_id"
            case appVersion = "app_version"
        }
    }

    public init(crashGroups: [CrashGroup]) {
        self.crashGroups = crashGroups
    }

    private enum CodingKeys: String, CodingKey {
        case crashGroups = "crash_groups"
    }
}

public struct CrashGroupAndVersion: Codable {
    public var crashGroupID: String?
    public var appVersion: String?

    public init(crashGroupID: String? = nil, appVersion: String? = nil) {
        self.crashGroupID = crashGroupID
        self.appVersion = appVersion
    }

    private enum CodingKeys: String, CodingKey {
        case crashGroupID = "crash_group_id"
        case appVersion = "app_version"
    }
}

public struct Events: Codable {
    public var events: [Event]?
    /// The total count of events.
    public var total: Int?
    /// The active device over this period.
    public var totalDevices: Int?

    public struct Event: Codable {
        public var id: String?
        public var name: String?
        public var deviceCount: Int?
        /// The device count of previous time range of the event.
        public var previousDeviceCount: Int?
        public var count: Int?
        /// The event count of previous time range of the event.
        public var previousCount: Int?
        public var countPerDevice: Double?
        public var countPerSession: Double?

        public init(id: String? = nil, name: String? = nil, deviceCount: Int? = nil, previousDeviceCount: Int? = nil, count: Int? = nil, previousCount: Int? = nil, countPerDevice: Double? = nil, countPerSession: Double? = nil) {
            self.id = id
            self.name = name
            self.deviceCount = deviceCount
            self.previousDeviceCount = previousDeviceCount
            self.count = count
            self.previousCount = previousCount
            self.countPerDevice = countPerDevice
            self.countPerSession = countPerSession
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case name
            case deviceCount = "device_count"
            case previousDeviceCount = "previous_device_count"
            case count
            case previousCount = "previous_count"
            case countPerDevice = "count_per_device"
            case countPerSession = "count_per_session"
        }
    }

    public init(events: [Event]? = nil, total: Int? = nil, totalDevices: Int? = nil) {
        self.events = events
        self.total = total
        self.totalDevices = totalDevices
    }

    private enum CodingKeys: String, CodingKey {
        case events
        case total
        case totalDevices = "total_devices"
    }
}

public struct Event: Codable {
    public var id: String?
    public var name: String?
    public var deviceCount: Int?
    /// The device count of previous time range of the event.
    public var previousDeviceCount: Int?
    public var count: Int?
    /// The event count of previous time range of the event.
    public var previousCount: Int?
    public var countPerDevice: Double?
    public var countPerSession: Double?

    public init(id: String? = nil, name: String? = nil, deviceCount: Int? = nil, previousDeviceCount: Int? = nil, count: Int? = nil, previousCount: Int? = nil, countPerDevice: Double? = nil, countPerSession: Double? = nil) {
        self.id = id
        self.name = name
        self.deviceCount = deviceCount
        self.previousDeviceCount = previousDeviceCount
        self.count = count
        self.previousCount = previousCount
        self.countPerDevice = countPerDevice
        self.countPerSession = countPerSession
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case deviceCount = "device_count"
        case previousDeviceCount = "previous_device_count"
        case count
        case previousCount = "previous_count"
        case countPerDevice = "count_per_device"
        case countPerSession = "count_per_session"
    }
}

public struct EventCount: Codable {
    public var totalCount: Int?
    public var previousTotalCount: Int?
    public var count: [CountItem]?

    public struct CountItem: Codable {
        /// The ISO 8601 datetime.
        public var datetime: String?
        /// Count of the object.
        public var count: Int?

        public init(datetime: String? = nil, count: Int? = nil) {
            self.datetime = datetime
            self.count = count
        }
    }

    public init(totalCount: Int? = nil, previousTotalCount: Int? = nil, count: [CountItem]? = nil) {
        self.totalCount = totalCount
        self.previousTotalCount = previousTotalCount
        self.count = count
    }

    private enum CodingKeys: String, CodingKey {
        case totalCount = "total_count"
        case previousTotalCount = "previous_total_count"
        case count
    }
}

public struct EventDeviceCount: Codable {
    public var totalDevices: Int?
    public var totalDevicesWithEvent: Int?
    public var previousTotalDevicesWithEvent: Int?
    public var devicesCount: [DevicesCountItem]?

    public struct DevicesCountItem: Codable {
        /// The ISO 8601 datetime.
        public var datetime: String?
        /// Count of the object.
        public var count: Int?

        public init(datetime: String? = nil, count: Int? = nil) {
            self.datetime = datetime
            self.count = count
        }
    }

    public init(totalDevices: Int? = nil, totalDevicesWithEvent: Int? = nil, previousTotalDevicesWithEvent: Int? = nil, devicesCount: [DevicesCountItem]? = nil) {
        self.totalDevices = totalDevices
        self.totalDevicesWithEvent = totalDevicesWithEvent
        self.previousTotalDevicesWithEvent = previousTotalDevicesWithEvent
        self.devicesCount = devicesCount
    }

    private enum CodingKeys: String, CodingKey {
        case totalDevices = "total_devices"
        case totalDevicesWithEvent = "total_devices_with_event"
        case previousTotalDevicesWithEvent = "previous_total_devices_with_event"
        case devicesCount = "devices_count"
    }
}

public struct EventCountPerDevice: Codable {
    public var avgCountPerDevice: Double?
    public var previousAvgCountPerDevice: Double?
    public var countPerDevice: [CountPerDeviceItem]?

    public struct CountPerDeviceItem: Codable {
        /// The ISO 8601 datetime.
        public var datetime: String?
        /// Decimal count of the object.
        public var count: Double?

        public init(datetime: String? = nil, count: Double? = nil) {
            self.datetime = datetime
            self.count = count
        }
    }

    public init(avgCountPerDevice: Double? = nil, previousAvgCountPerDevice: Double? = nil, countPerDevice: [CountPerDeviceItem]? = nil) {
        self.avgCountPerDevice = avgCountPerDevice
        self.previousAvgCountPerDevice = previousAvgCountPerDevice
        self.countPerDevice = countPerDevice
    }

    private enum CodingKeys: String, CodingKey {
        case avgCountPerDevice = "avg_count_per_device"
        case previousAvgCountPerDevice = "previous_avg_count_per_device"
        case countPerDevice = "count_per_device"
    }
}

public struct EventCountPerSession: Codable {
    public var avgCountPerSession: Double?
    public var previousAvgCountPerSession: Double?
    public var countPerSession: [CountPerSessionItem]?

    public struct CountPerSessionItem: Codable {
        /// The ISO 8601 datetime.
        public var datetime: String?
        /// Decimal count of the object.
        public var count: Double?

        public init(datetime: String? = nil, count: Double? = nil) {
            self.datetime = datetime
            self.count = count
        }
    }

    public init(avgCountPerSession: Double? = nil, previousAvgCountPerSession: Double? = nil, countPerSession: [CountPerSessionItem]? = nil) {
        self.avgCountPerSession = avgCountPerSession
        self.previousAvgCountPerSession = previousAvgCountPerSession
        self.countPerSession = countPerSession
    }

    private enum CodingKeys: String, CodingKey {
        case avgCountPerSession = "avg_count_per_session"
        case previousAvgCountPerSession = "previous_avg_count_per_session"
        case countPerSession = "count_per_session"
    }
}

/// Event properties during the time range.
public struct EventProperties: Codable {
    public var eventProperties: [String]?

    public init(eventProperties: [String]? = nil) {
        self.eventProperties = eventProperties
    }

    private enum CodingKeys: String, CodingKey {
        case eventProperties = "event_properties"
    }
}

/// Event property value counts during the time range in descending order.
public struct EventPropertyValues: Codable {
    /// The total property value counts.
    public var total: Int?
    /// The event property values.
    public var values: [Value]?

    /// An event property value with counts.
    public struct Value: Codable {
        /// The event property value name.
        public var name: String?
        /// The count of the the event property value.
        public var count: Int?
        /// The count of previous time range of the event property value.
        public var previousCount: Int?

        public init(name: String? = nil, count: Int? = nil, previousCount: Int? = nil) {
            self.name = name
            self.count = count
            self.previousCount = previousCount
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case count
            case previousCount = "previous_count"
        }
    }

    public init(total: Int? = nil, values: [Value]? = nil) {
        self.total = total
        self.values = values
    }
}

/// An event property value with counts.
public struct EventPropertyValue: Codable {
    /// The event property value name.
    public var name: String?
    /// The count of the the event property value.
    public var count: Int?
    /// The count of previous time range of the event property value.
    public var previousCount: Int?

    public init(name: String? = nil, count: Int? = nil, previousCount: Int? = nil) {
        self.name = name
        self.count = count
        self.previousCount = previousCount
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case count
        case previousCount = "previous_count"
    }
}

public struct NotifyReleasesContainer: Codable {
    public var releases: [Release]

    public struct Release: Codable {
        /// Unique user Id.  Will generate a new user Id if not provided.
        public var userID: String?

        public init(userID: String? = nil) {
            self.userID = userID
        }

        private enum CodingKeys: String, CodingKey {
            case userID = "user_id"
        }
    }

    public init(releases: [Release]) {
        self.releases = releases
    }
}

public struct DeleteReleasesContainer: Codable {
    public var releases: [Release]

    public struct Release: Codable {
        /// Release Id.
        public var release: String

        public init(release: String) {
            self.release = release
        }
    }

    public init(releases: [Release]) {
        self.releases = releases
    }
}

public struct GetReleasesContainer: Codable {
    public var releases: [Release]

    public struct Release: Codable {
        /// Distribution group Id.
        public var distributionGroup: String?

        public init(distributionGroup: String? = nil) {
            self.distributionGroup = distributionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case distributionGroup = "distribution_group"
        }
    }

    public init(releases: [Release]) {
        self.releases = releases
    }
}

public struct FilterReleasesContainer: Codable {
    public var releases: [Release]?

    public struct Release: Codable {
        /// Release Id.
        public var release: String

        public init(release: String) {
            self.release = release
        }
    }

    public init(releases: [Release]? = nil) {
        self.releases = releases
    }
}

public struct FilterVersionsContainer: Codable {
    public var versions: [Version]?

    public struct Version: Codable {
        /// App version.
        public var version: String
        /// App build number.
        public var build: String

        public init(version: String, build: String) {
            self.version = version
            self.build = build
        }
    }

    public init(versions: [Version]? = nil) {
        self.versions = versions
    }
}

public struct Release: Codable {
    /// Release Id.
    public var release: String

    public init(release: String) {
        self.release = release
    }
}

public struct ReleaseCounts: Codable {
    public var total: Int?
    public var counts: [Count]

    public struct Count: Codable {
        public var releaseID: String
        /// Distribution group queried.
        public var distributionGroup: String?
        /// Count of unique downloads against user id.
        public var uniqueCount: Int
        /// Total count of downloads.
        public var totalCount: Int

        public init(releaseID: String, distributionGroup: String? = nil, uniqueCount: Int, totalCount: Int) {
            self.releaseID = releaseID
            self.distributionGroup = distributionGroup
            self.uniqueCount = uniqueCount
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case releaseID = "release_id"
            case distributionGroup = "distribution_group"
            case uniqueCount = "unique_count"
            case totalCount = "total_count"
        }
    }

    public init(total: Int? = nil, counts: [Count]) {
        self.total = total
        self.counts = counts
    }
}

public struct ReleaseDailySessions: Codable {
    public var totalSessionCounts: Int?
    public var avgSessionsPerDay: Double?
    /// Sessions per day.
    public var sessions: [Session]?

    public struct Session: Codable {
        /// The ISO 8601 datetime.
        public var datetime: String?
        public var count: Int?

        public init(datetime: String? = nil, count: Int? = nil) {
            self.datetime = datetime
            self.count = count
        }
    }

    public init(totalSessionCounts: Int? = nil, avgSessionsPerDay: Double? = nil, sessions: [Session]? = nil) {
        self.totalSessionCounts = totalSessionCounts
        self.avgSessionsPerDay = avgSessionsPerDay
        self.sessions = sessions
    }
}

public struct DailySession: Codable {
    /// The ISO 8601 datetime.
    public var datetime: String?
    public var count: Int?

    public init(datetime: String? = nil, count: Int? = nil) {
        self.datetime = datetime
        self.count = count
    }
}

public struct DateTimeDownloadReleaseCounts: Codable {
    public var total: Int?
    public var unique: Int?
    /// Release counts per day.
    public var counts: [Count]?

    public struct Count: Codable {
        /// The ISO 8601 datetime.
        public var datetime: String?
        public var total: Int?
        public var unique: Int?

        public init(datetime: String? = nil, total: Int? = nil, unique: Int? = nil) {
            self.datetime = datetime
            self.total = total
            self.unique = unique
        }
    }

    public init(total: Int? = nil, unique: Int? = nil, counts: [Count]? = nil) {
        self.total = total
        self.unique = unique
        self.counts = counts
    }
}

public struct DateTimeDownloadReleaseCount: Codable {
    /// The ISO 8601 datetime.
    public var datetime: String?
    public var total: Int?
    public var unique: Int?

    public init(datetime: String? = nil, total: Int? = nil, unique: Int? = nil) {
        self.datetime = datetime
        self.total = total
        self.unique = unique
    }
}

public struct ReleaseCount: Codable {
    public var releaseID: String
    /// Distribution group queried.
    public var distributionGroup: String?
    /// Count of unique downloads against user id.
    public var uniqueCount: Int
    /// Total count of downloads.
    public var totalCount: Int

    public init(releaseID: String, distributionGroup: String? = nil, uniqueCount: Int, totalCount: Int) {
        self.releaseID = releaseID
        self.distributionGroup = distributionGroup
        self.uniqueCount = uniqueCount
        self.totalCount = totalCount
    }

    private enum CodingKeys: String, CodingKey {
        case releaseID = "release_id"
        case distributionGroup = "distribution_group"
        case uniqueCount = "unique_count"
        case totalCount = "total_count"
    }
}

public struct LogFlowLogContainer: Codable {
    /// Indicates if the number of available logs are more than the max allowed return limit(100).
    public var isExceededMaxLimit: Bool?
    /// The timestamp of the last log received. This value can be used as the start time parameter in the consecutive API call.
    public var lastReceivedLogTimestamp: Date?
    /// The list of logs
    public var logs: [Log]

    public struct Log: Codable {
        /// Log type.
        public var type: `Type`
        /// Log creation timestamp.
        public var timestamp: Date
        /// Install ID.
        public var installID: String
        /// Device characteristics.
        public var device: Device

        /// Log type.
        public enum `Type`: String, Codable, CaseIterable {
            case event
            case page
            case startSession = "start_session"
            case error
            case startService = "start_service"
            case customProperties = "custom_properties"
        }

        /// Device characteristics.
        public struct Device: Codable {
            /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
            public var sdkName: String
            /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
            public var sdkVersion: String
            /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
            public var wrapperSdkVersion: String?
            /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
            public var wrapperSdkName: String?
            /// Device model (example: iPad2,3).
            public var model: String?
            /// Device manufacturer (example: HTC).
            public var oemName: String?
            /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
            public var osName: String
            /// OS version (example: 9.3.0).
            public var osVersion: String
            /// OS build code (example: LMY47X).
            public var osBuild: String?
            /// API level when applicable like in Android (example: 15).
            public var osAPILevel: Int?
            /// Language code (example: en_US).
            public var locale: String
            /// The offset in minutes from UTC for the device time zone, including daylight savings time.
            public var timeZoneOffset: Int
            /// Screen size of the device in pixels (example: 640x480).
            public var screenSize: String?
            /// Application version name, e.g. 1.1.0
            public var appVersion: String
            /// Carrier name (for mobile devices).
            public var carrierName: String?
            /// Carrier country code (for mobile devices).
            public var carrierCode: String?
            /// Carrier country.
            public var carrierCountry: String?
            /// The app's build number, e.g. 42.
            public var appBuild: String
            /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
            public var appNamespace: String?
            /// Label that is used to identify application code 'version' released via Live Update beacon running on device
            public var liveUpdateReleaseLabel: String?
            /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
            public var liveUpdateDeploymentKey: String?
            /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
            public var liveUpdatePackageHash: String?
            /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
            public var wrapperRuntimeVersion: String?

            public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
                self.sdkName = sdkName
                self.sdkVersion = sdkVersion
                self.wrapperSdkVersion = wrapperSdkVersion
                self.wrapperSdkName = wrapperSdkName
                self.model = model
                self.oemName = oemName
                self.osName = osName
                self.osVersion = osVersion
                self.osBuild = osBuild
                self.osAPILevel = osAPILevel
                self.locale = locale
                self.timeZoneOffset = timeZoneOffset
                self.screenSize = screenSize
                self.appVersion = appVersion
                self.carrierName = carrierName
                self.carrierCode = carrierCode
                self.carrierCountry = carrierCountry
                self.appBuild = appBuild
                self.appNamespace = appNamespace
                self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
                self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
                self.liveUpdatePackageHash = liveUpdatePackageHash
                self.wrapperRuntimeVersion = wrapperRuntimeVersion
            }

            private enum CodingKeys: String, CodingKey {
                case sdkName = "sdk_name"
                case sdkVersion = "sdk_version"
                case wrapperSdkVersion = "wrapper_sdk_version"
                case wrapperSdkName = "wrapper_sdk_name"
                case model
                case oemName = "oem_name"
                case osName = "os_name"
                case osVersion = "os_version"
                case osBuild = "os_build"
                case osAPILevel = "os_api_level"
                case locale
                case timeZoneOffset = "time_zone_offset"
                case screenSize = "screen_size"
                case appVersion = "app_version"
                case carrierName = "carrier_name"
                case carrierCode = "carrier_code"
                case carrierCountry = "carrier_country"
                case appBuild = "app_build"
                case appNamespace = "app_namespace"
                case liveUpdateReleaseLabel = "live_update_release_label"
                case liveUpdateDeploymentKey = "live_update_deployment_key"
                case liveUpdatePackageHash = "live_update_package_hash"
                case wrapperRuntimeVersion = "wrapper_runtime_version"
            }
        }

        public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
            self.type = type
            self.timestamp = timestamp
            self.installID = installID
            self.device = device
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case timestamp
            case installID = "install_id"
            case device
        }
    }

    public init(isExceededMaxLimit: Bool? = nil, lastReceivedLogTimestamp: Date? = nil, logs: [Log]) {
        self.isExceededMaxLimit = isExceededMaxLimit
        self.lastReceivedLogTimestamp = lastReceivedLogTimestamp
        self.logs = logs
    }

    private enum CodingKeys: String, CodingKey {
        case isExceededMaxLimit = "exceeded_max_limit"
        case lastReceivedLogTimestamp = "last_received_log_timestamp"
        case logs
    }
}

public struct LogFlowGenericLogContainer: Codable {
    /// Indicates if the number of available logs are more than the max allowed return limit(100).
    public var isExceededMaxLimit: Bool?
    /// The timestamp of the last log received. This value can be used as the start time parameter in the consecutive API call.
    public var lastReceivedLogTimestamp: Date?
    /// The list of logs
    public var logs: [Log]

    /// Generic log.
    public struct Log: Codable {
        /// Log type.
        public var type: `Type`
        /// Log creation timestamp.
        public var timestamp: Date
        /// Install ID.
        public var installID: String
        /// Session ID.
        public var sessionID: String?
        /// Event ID.
        public var eventID: String?
        /// Event name.
        public var eventName: String?
        /// Message ID.
        public var messageID: String?
        /// Event specific properties.
        public var properties: [String: String]?
        /// Device characteristics.
        public var device: Device
        /// Auth service provider.
        public var authProvider: String?
        /// Account ID of the authenticated user.
        public var accountID: String?

        /// Log type.
        public enum `Type`: String, Codable, CaseIterable {
            case event
            case page
            case startSession = "start_session"
            case error
            case startService = "start_service"
            case customProperties = "custom_properties"
        }

        /// Device characteristics.
        public struct Device: Codable {
            /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
            public var sdkName: String
            /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
            public var sdkVersion: String
            /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
            public var wrapperSdkVersion: String?
            /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
            public var wrapperSdkName: String?
            /// Device model (example: iPad2,3).
            public var model: String?
            /// Device manufacturer (example: HTC).
            public var oemName: String?
            /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
            public var osName: String
            /// OS version (example: 9.3.0).
            public var osVersion: String
            /// OS build code (example: LMY47X).
            public var osBuild: String?
            /// API level when applicable like in Android (example: 15).
            public var osAPILevel: Int?
            /// Language code (example: en_US).
            public var locale: String
            /// The offset in minutes from UTC for the device time zone, including daylight savings time.
            public var timeZoneOffset: Int
            /// Screen size of the device in pixels (example: 640x480).
            public var screenSize: String?
            /// Application version name, e.g. 1.1.0
            public var appVersion: String
            /// Carrier name (for mobile devices).
            public var carrierName: String?
            /// Carrier country code (for mobile devices).
            public var carrierCode: String?
            /// Carrier country.
            public var carrierCountry: String?
            /// The app's build number, e.g. 42.
            public var appBuild: String
            /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
            public var appNamespace: String?
            /// Label that is used to identify application code 'version' released via Live Update beacon running on device
            public var liveUpdateReleaseLabel: String?
            /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
            public var liveUpdateDeploymentKey: String?
            /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
            public var liveUpdatePackageHash: String?
            /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
            public var wrapperRuntimeVersion: String?

            public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
                self.sdkName = sdkName
                self.sdkVersion = sdkVersion
                self.wrapperSdkVersion = wrapperSdkVersion
                self.wrapperSdkName = wrapperSdkName
                self.model = model
                self.oemName = oemName
                self.osName = osName
                self.osVersion = osVersion
                self.osBuild = osBuild
                self.osAPILevel = osAPILevel
                self.locale = locale
                self.timeZoneOffset = timeZoneOffset
                self.screenSize = screenSize
                self.appVersion = appVersion
                self.carrierName = carrierName
                self.carrierCode = carrierCode
                self.carrierCountry = carrierCountry
                self.appBuild = appBuild
                self.appNamespace = appNamespace
                self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
                self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
                self.liveUpdatePackageHash = liveUpdatePackageHash
                self.wrapperRuntimeVersion = wrapperRuntimeVersion
            }

            private enum CodingKeys: String, CodingKey {
                case sdkName = "sdk_name"
                case sdkVersion = "sdk_version"
                case wrapperSdkVersion = "wrapper_sdk_version"
                case wrapperSdkName = "wrapper_sdk_name"
                case model
                case oemName = "oem_name"
                case osName = "os_name"
                case osVersion = "os_version"
                case osBuild = "os_build"
                case osAPILevel = "os_api_level"
                case locale
                case timeZoneOffset = "time_zone_offset"
                case screenSize = "screen_size"
                case appVersion = "app_version"
                case carrierName = "carrier_name"
                case carrierCode = "carrier_code"
                case carrierCountry = "carrier_country"
                case appBuild = "app_build"
                case appNamespace = "app_namespace"
                case liveUpdateReleaseLabel = "live_update_release_label"
                case liveUpdateDeploymentKey = "live_update_deployment_key"
                case liveUpdatePackageHash = "live_update_package_hash"
                case wrapperRuntimeVersion = "wrapper_runtime_version"
            }
        }

        public init(type: `Type`, timestamp: Date, installID: String, sessionID: String? = nil, eventID: String? = nil, eventName: String? = nil, messageID: String? = nil, properties: [String: String]? = nil, device: Device, authProvider: String? = nil, accountID: String? = nil) {
            self.type = type
            self.timestamp = timestamp
            self.installID = installID
            self.sessionID = sessionID
            self.eventID = eventID
            self.eventName = eventName
            self.messageID = messageID
            self.properties = properties
            self.device = device
            self.authProvider = authProvider
            self.accountID = accountID
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case timestamp
            case installID = "install_id"
            case sessionID = "session_id"
            case eventID = "event_id"
            case eventName = "event_name"
            case messageID = "message_id"
            case properties
            case device
            case authProvider = "auth_provider"
            case accountID = "account_id"
        }
    }

    public init(isExceededMaxLimit: Bool? = nil, lastReceivedLogTimestamp: Date? = nil, logs: [Log]) {
        self.isExceededMaxLimit = isExceededMaxLimit
        self.lastReceivedLogTimestamp = lastReceivedLogTimestamp
        self.logs = logs
    }

    private enum CodingKeys: String, CodingKey {
        case isExceededMaxLimit = "exceeded_max_limit"
        case lastReceivedLogTimestamp = "last_received_log_timestamp"
        case logs
    }
}

/// Generic log.
public struct LogFlowGenericLog: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Session ID.
    public var sessionID: String?
    /// Event ID.
    public var eventID: String?
    /// Event name.
    public var eventName: String?
    /// Message ID.
    public var messageID: String?
    /// Event specific properties.
    public var properties: [String: String]?
    /// Device characteristics.
    public var device: Device
    /// Auth service provider.
    public var authProvider: String?
    /// Account ID of the authenticated user.
    public var accountID: String?

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, sessionID: String? = nil, eventID: String? = nil, eventName: String? = nil, messageID: String? = nil, properties: [String: String]? = nil, device: Device, authProvider: String? = nil, accountID: String? = nil) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.sessionID = sessionID
        self.eventID = eventID
        self.eventName = eventName
        self.messageID = messageID
        self.properties = properties
        self.device = device
        self.authProvider = authProvider
        self.accountID = accountID
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case timestamp
        case installID = "install_id"
        case sessionID = "session_id"
        case eventID = "event_id"
        case eventName = "event_name"
        case messageID = "message_id"
        case properties
        case device
        case authProvider = "auth_provider"
        case accountID = "account_id"
    }
}

public struct LogFlowLog: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case timestamp
        case installID = "install_id"
        case device
    }
}

public struct LogFlowLogWithProperties: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

/// Device characteristics.
public struct LogFlowDevice: Codable {
    /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
    public var sdkName: String
    /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
    public var sdkVersion: String
    /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
    public var wrapperSdkVersion: String?
    /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
    public var wrapperSdkName: String?
    /// Device model (example: iPad2,3).
    public var model: String?
    /// Device manufacturer (example: HTC).
    public var oemName: String?
    /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
    public var osName: String
    /// OS version (example: 9.3.0).
    public var osVersion: String
    /// OS build code (example: LMY47X).
    public var osBuild: String?
    /// API level when applicable like in Android (example: 15).
    public var osAPILevel: Int?
    /// Language code (example: en_US).
    public var locale: String
    /// The offset in minutes from UTC for the device time zone, including daylight savings time.
    public var timeZoneOffset: Int
    /// Screen size of the device in pixels (example: 640x480).
    public var screenSize: String?
    /// Application version name, e.g. 1.1.0
    public var appVersion: String
    /// Carrier name (for mobile devices).
    public var carrierName: String?
    /// Carrier country code (for mobile devices).
    public var carrierCode: String?
    /// Carrier country.
    public var carrierCountry: String?
    /// The app's build number, e.g. 42.
    public var appBuild: String
    /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
    public var appNamespace: String?
    /// Label that is used to identify application code 'version' released via Live Update beacon running on device
    public var liveUpdateReleaseLabel: String?
    /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
    public var liveUpdateDeploymentKey: String?
    /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
    public var liveUpdatePackageHash: String?
    /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
    public var wrapperRuntimeVersion: String?

    public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
        self.sdkName = sdkName
        self.sdkVersion = sdkVersion
        self.wrapperSdkVersion = wrapperSdkVersion
        self.wrapperSdkName = wrapperSdkName
        self.model = model
        self.oemName = oemName
        self.osName = osName
        self.osVersion = osVersion
        self.osBuild = osBuild
        self.osAPILevel = osAPILevel
        self.locale = locale
        self.timeZoneOffset = timeZoneOffset
        self.screenSize = screenSize
        self.appVersion = appVersion
        self.carrierName = carrierName
        self.carrierCode = carrierCode
        self.carrierCountry = carrierCountry
        self.appBuild = appBuild
        self.appNamespace = appNamespace
        self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
        self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
        self.liveUpdatePackageHash = liveUpdatePackageHash
        self.wrapperRuntimeVersion = wrapperRuntimeVersion
    }

    private enum CodingKeys: String, CodingKey {
        case sdkName = "sdk_name"
        case sdkVersion = "sdk_version"
        case wrapperSdkVersion = "wrapper_sdk_version"
        case wrapperSdkName = "wrapper_sdk_name"
        case model
        case oemName = "oem_name"
        case osName = "os_name"
        case osVersion = "os_version"
        case osBuild = "os_build"
        case osAPILevel = "os_api_level"
        case locale
        case timeZoneOffset = "time_zone_offset"
        case screenSize = "screen_size"
        case appVersion = "app_version"
        case carrierName = "carrier_name"
        case carrierCode = "carrier_code"
        case carrierCountry = "carrier_country"
        case appBuild = "app_build"
        case appNamespace = "app_namespace"
        case liveUpdateReleaseLabel = "live_update_release_label"
        case liveUpdateDeploymentKey = "live_update_deployment_key"
        case liveUpdatePackageHash = "live_update_package_hash"
        case wrapperRuntimeVersion = "wrapper_runtime_version"
    }
}

/// Required explicit begin session log (a marker event for analytics service).
public struct LogFlowStartSessionLog: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

/// Describe a AppCenter.Start API call from the SDK.
public struct LogFlowStartServiceLog: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

/// Set or remove custom properties.
public struct LogFlowCustomPropertyLog: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

public struct LogFlowCustomProperty: Codable {
    public var type: String
    public var name: String

    public init(type: String, name: String) {
        self.type = type
        self.name = name
    }
}

/// String property.
public struct LogFlowStringProperty: Codable {
    public var type: String
    public var name: String

    public init(type: String, name: String) {
        self.type = type
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.name = try values.decode(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(name, forKey: "name")
    }
}

/// Number property.
public struct LogFlowNumberProperty: Codable {
    public var type: String
    public var name: String

    public init(type: String, name: String) {
        self.type = type
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.name = try values.decode(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(name, forKey: "name")
    }
}

/// Boolean property.
public struct LogFlowBooleanProperty: Codable {
    public var type: String
    public var name: String

    public init(type: String, name: String) {
        self.type = type
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.name = try values.decode(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(name, forKey: "name")
    }
}

/// Date and time property.
public struct LogFlowDateTimeProperty: Codable {
    public var type: String
    public var name: String

    public init(type: String, name: String) {
        self.type = type
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.name = try values.decode(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(name, forKey: "name")
    }
}

/// Clear an existing property.
public struct LogFlowClearProperty: Codable {
    public var type: String
    public var name: String

    public init(type: String, name: String) {
        self.type = type
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.name = try values.decode(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(name, forKey: "name")
    }
}

public struct LogFlowPageLog: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

public struct LogFlowEventLog: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

/// Error log.
public struct LogFlowErrorLog: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

/// Aggregated Billing Information for a user or an organization
public struct AggregatedBillingInformation: Codable {
    /// Version of the Billing Information schema
    public var version: String?
    /// The ISO 8601 datetime of last modification
    public var timestamp: String?
    /// ID of the user or organization
    public var id: String?
    /// Billing Plans section in the Billing Information
    public var billingPlans: BillingPlans?
    /// Usage section in the Billing Information
    public var usage: Usage?
    /// Unique identifier for the Azure subscription used for billing
    public var azureSubscriptionID: String?
    /// State of the Azure subscription used for billing
    public var azureSubscriptionState: AzureSubscriptionState?

    /// Billing Plans section in the Billing Information
    public struct BillingPlans: Codable {
        /// Billing Plans for a single service
        public var buildService: BuildService?
        /// Billing Plans for a single service
        public var testService: TestService?

        /// Billing Plans for a single service
        public struct BuildService: Codable {
            /// Can customer select trial plan for that service (if it exists)?
            public var canSelectTrialPlan: Bool?
            /// Expiration time of the last selected trial plan. Will be null if trial plan was not used.
            public var lastTrialPlanExpirationTime: String?
            /// Billing plans for a given period
            public var currentBillingPeriod: CurrentBillingPeriod?

            /// Billing plans for a given period
            public struct CurrentBillingPeriod: Codable {
                /// Inclusive start of the period
                public var startTime: String?
                /// Exclusive end of the period.
                public var endTime: String?
                /// Selection of a billing plan
                public var byAccount: ByAccount?

                /// Selection of a billing plan
                public struct ByAccount: Codable {
                    /// Number of instances of the billing plan.
                    public var count: Int?
                    /// Billing Plan
                    public var plan: Plan?

                    /// Billing Plan
                    public struct Plan: Codable {
                        /// The Billing Plan ID
                        public var id: String?
                        /// Version of the Billing Plan schema
                        public var version: String?
                        /// Price of the Billing Plan
                        public var price: Double?
                        /// Service that receives payments for this billing plan.
                        public var paymentSource: PaymentSource?
                        /// Name of the service that the plan applies to.
                        public var service: Service?
                        /// A collection of named numeric values
                        public var limits: [String: Double]?
                        /// Collection of attribute values.
                        public var attributes: [String: [String: AnyJSON]]?
                        public var parentID: String?

                        /// Service that receives payments for this billing plan.
                        public enum PaymentSource: String, Codable, CaseIterable {
                            case `none` = "None"
                            case appCenter = "AppCenter"
                            case gitHub = "GitHub"
                            case xtc = "Xtc"
                        }

                        /// Name of the service that the plan applies to.
                        public enum Service: String, Codable, CaseIterable {
                            case build = "Build"
                            case test = "Test"
                        }

                        public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
                            self.id = id
                            self.version = version
                            self.price = price
                            self.paymentSource = paymentSource
                            self.service = service
                            self.limits = limits
                            self.attributes = attributes
                            self.parentID = parentID
                        }

                        private enum CodingKeys: String, CodingKey {
                            case id
                            case version
                            case price
                            case paymentSource
                            case service
                            case limits
                            case attributes
                            case parentID = "parentId"
                        }
                    }

                    public init(count: Int? = nil, plan: Plan? = nil) {
                        self.count = count
                        self.plan = plan
                    }
                }

                public init(startTime: String? = nil, endTime: String? = nil, byAccount: ByAccount? = nil) {
                    self.startTime = startTime
                    self.endTime = endTime
                    self.byAccount = byAccount
                }
            }

            public init(canSelectTrialPlan: Bool? = nil, lastTrialPlanExpirationTime: String? = nil, currentBillingPeriod: CurrentBillingPeriod? = nil) {
                self.canSelectTrialPlan = canSelectTrialPlan
                self.lastTrialPlanExpirationTime = lastTrialPlanExpirationTime
                self.currentBillingPeriod = currentBillingPeriod
            }
        }

        /// Billing Plans for a single service
        public struct TestService: Codable {
            /// Can customer select trial plan for that service (if it exists)?
            public var canSelectTrialPlan: Bool?
            /// Expiration time of the last selected trial plan. Will be null if trial plan was not used.
            public var lastTrialPlanExpirationTime: String?
            /// Billing plans for a given period
            public var currentBillingPeriod: CurrentBillingPeriod?

            /// Billing plans for a given period
            public struct CurrentBillingPeriod: Codable {
                /// Inclusive start of the period
                public var startTime: String?
                /// Exclusive end of the period.
                public var endTime: String?
                /// Selection of a billing plan
                public var byAccount: ByAccount?

                /// Selection of a billing plan
                public struct ByAccount: Codable {
                    /// Number of instances of the billing plan.
                    public var count: Int?
                    /// Billing Plan
                    public var plan: Plan?

                    /// Billing Plan
                    public struct Plan: Codable {
                        /// The Billing Plan ID
                        public var id: String?
                        /// Version of the Billing Plan schema
                        public var version: String?
                        /// Price of the Billing Plan
                        public var price: Double?
                        /// Service that receives payments for this billing plan.
                        public var paymentSource: PaymentSource?
                        /// Name of the service that the plan applies to.
                        public var service: Service?
                        /// A collection of named numeric values
                        public var limits: [String: Double]?
                        /// Collection of attribute values.
                        public var attributes: [String: [String: AnyJSON]]?
                        public var parentID: String?

                        /// Service that receives payments for this billing plan.
                        public enum PaymentSource: String, Codable, CaseIterable {
                            case `none` = "None"
                            case appCenter = "AppCenter"
                            case gitHub = "GitHub"
                            case xtc = "Xtc"
                        }

                        /// Name of the service that the plan applies to.
                        public enum Service: String, Codable, CaseIterable {
                            case build = "Build"
                            case test = "Test"
                        }

                        public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
                            self.id = id
                            self.version = version
                            self.price = price
                            self.paymentSource = paymentSource
                            self.service = service
                            self.limits = limits
                            self.attributes = attributes
                            self.parentID = parentID
                        }

                        private enum CodingKeys: String, CodingKey {
                            case id
                            case version
                            case price
                            case paymentSource
                            case service
                            case limits
                            case attributes
                            case parentID = "parentId"
                        }
                    }

                    public init(count: Int? = nil, plan: Plan? = nil) {
                        self.count = count
                        self.plan = plan
                    }
                }

                public init(startTime: String? = nil, endTime: String? = nil, byAccount: ByAccount? = nil) {
                    self.startTime = startTime
                    self.endTime = endTime
                    self.byAccount = byAccount
                }
            }

            public init(canSelectTrialPlan: Bool? = nil, lastTrialPlanExpirationTime: String? = nil, currentBillingPeriod: CurrentBillingPeriod? = nil) {
                self.canSelectTrialPlan = canSelectTrialPlan
                self.lastTrialPlanExpirationTime = lastTrialPlanExpirationTime
                self.currentBillingPeriod = currentBillingPeriod
            }
        }

        public init(buildService: BuildService? = nil, testService: TestService? = nil) {
            self.buildService = buildService
            self.testService = testService
        }
    }

    /// Usage section in the Billing Information
    public struct Usage: Codable {
        /// Resource usage for a single Mobile Center service
        public var buildService: BuildService?
        /// Resource usage for a single Mobile Center service
        public var testService: TestService?

        /// Resource usage for a single Mobile Center service
        public struct BuildService: Codable {
            /// Usage for a single period
            public var currentUsagePeriod: CurrentUsagePeriod?

            /// Usage for a single period
            public struct CurrentUsagePeriod: Codable {
                /// Inclusive start time of the usage period
                public var startTime: String?
                /// Exclusive end time of the usage period.
                public var endTime: String?
                /// A collection of named numeric values
                public var byAccount: [String: Double]?
                /// A collection of  named numeric values grouped by app
                public var byApp: [String: [String: Double]]?

                public init(startTime: String? = nil, endTime: String? = nil, byAccount: [String: Double]? = nil, byApp: [String: [String: Double]]? = nil) {
                    self.startTime = startTime
                    self.endTime = endTime
                    self.byAccount = byAccount
                    self.byApp = byApp
                }
            }

            public init(currentUsagePeriod: CurrentUsagePeriod? = nil) {
                self.currentUsagePeriod = currentUsagePeriod
            }
        }

        /// Resource usage for a single Mobile Center service
        public struct TestService: Codable {
            /// Usage for a single period
            public var currentUsagePeriod: CurrentUsagePeriod?

            /// Usage for a single period
            public struct CurrentUsagePeriod: Codable {
                /// Inclusive start time of the usage period
                public var startTime: String?
                /// Exclusive end time of the usage period.
                public var endTime: String?
                /// A collection of named numeric values
                public var byAccount: [String: Double]?
                /// A collection of  named numeric values grouped by app
                public var byApp: [String: [String: Double]]?

                public init(startTime: String? = nil, endTime: String? = nil, byAccount: [String: Double]? = nil, byApp: [String: [String: Double]]? = nil) {
                    self.startTime = startTime
                    self.endTime = endTime
                    self.byAccount = byAccount
                    self.byApp = byApp
                }
            }

            public init(currentUsagePeriod: CurrentUsagePeriod? = nil) {
                self.currentUsagePeriod = currentUsagePeriod
            }
        }

        public init(buildService: BuildService? = nil, testService: TestService? = nil) {
            self.buildService = buildService
            self.testService = testService
        }
    }

    /// State of the Azure subscription used for billing
    public enum AzureSubscriptionState: String, Codable, CaseIterable {
        case enabled = "Enabled"
        case disabled = "Disabled"
        case notSet = "NotSet"
    }

    public init(version: String? = nil, timestamp: String? = nil, id: String? = nil, billingPlans: BillingPlans? = nil, usage: Usage? = nil, azureSubscriptionID: String? = nil, azureSubscriptionState: AzureSubscriptionState? = nil) {
        self.version = version
        self.timestamp = timestamp
        self.id = id
        self.billingPlans = billingPlans
        self.usage = usage
        self.azureSubscriptionID = azureSubscriptionID
        self.azureSubscriptionState = azureSubscriptionState
    }

    private enum CodingKeys: String, CodingKey {
        case version
        case timestamp
        case id
        case billingPlans
        case usage
        case azureSubscriptionID = "azureSubscriptionId"
        case azureSubscriptionState
    }
}

/// Aggregated Billing Information for a user an the organizations in which the user is an admin.
public struct AllAccountsAggregatedBillingInformation: Codable {
    /// Aggregated Billing Information for a user or an organization
    public var aggregatedBillings: AggregatedBillings?

    /// Aggregated Billing Information for a user or an organization
    public struct AggregatedBillings: Codable {
        /// Version of the Billing Information schema
        public var version: String?
        /// The ISO 8601 datetime of last modification
        public var timestamp: String?
        /// ID of the user or organization
        public var id: String?
        /// Billing Plans section in the Billing Information
        public var billingPlans: BillingPlans?
        /// Usage section in the Billing Information
        public var usage: Usage?
        /// Unique identifier for the Azure subscription used for billing
        public var azureSubscriptionID: String?
        /// State of the Azure subscription used for billing
        public var azureSubscriptionState: AzureSubscriptionState?

        /// Billing Plans section in the Billing Information
        public struct BillingPlans: Codable {
            /// Billing Plans for a single service
            public var buildService: BuildService?
            /// Billing Plans for a single service
            public var testService: TestService?

            /// Billing Plans for a single service
            public struct BuildService: Codable {
                /// Can customer select trial plan for that service (if it exists)?
                public var canSelectTrialPlan: Bool?
                /// Expiration time of the last selected trial plan. Will be null if trial plan was not used.
                public var lastTrialPlanExpirationTime: String?
                /// Billing plans for a given period
                public var currentBillingPeriod: CurrentBillingPeriod?

                /// Billing plans for a given period
                public struct CurrentBillingPeriod: Codable {
                    /// Inclusive start of the period
                    public var startTime: String?
                    /// Exclusive end of the period.
                    public var endTime: String?
                    /// Selection of a billing plan
                    public var byAccount: ByAccount?

                    /// Selection of a billing plan
                    public struct ByAccount: Codable {
                        /// Number of instances of the billing plan.
                        public var count: Int?
                        /// Billing Plan
                        public var plan: Plan?

                        /// Billing Plan
                        public struct Plan: Codable {
                            /// The Billing Plan ID
                            public var id: String?
                            /// Version of the Billing Plan schema
                            public var version: String?
                            /// Price of the Billing Plan
                            public var price: Double?
                            /// Service that receives payments for this billing plan.
                            public var paymentSource: PaymentSource?
                            /// Name of the service that the plan applies to.
                            public var service: Service?
                            /// A collection of named numeric values
                            public var limits: [String: Double]?
                            /// Collection of attribute values.
                            public var attributes: [String: [String: AnyJSON]]?
                            public var parentID: String?

                            /// Service that receives payments for this billing plan.
                            public enum PaymentSource: String, Codable, CaseIterable {
                                case `none` = "None"
                                case appCenter = "AppCenter"
                                case gitHub = "GitHub"
                                case xtc = "Xtc"
                            }

                            /// Name of the service that the plan applies to.
                            public enum Service: String, Codable, CaseIterable {
                                case build = "Build"
                                case test = "Test"
                            }

                            public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
                                self.id = id
                                self.version = version
                                self.price = price
                                self.paymentSource = paymentSource
                                self.service = service
                                self.limits = limits
                                self.attributes = attributes
                                self.parentID = parentID
                            }

                            private enum CodingKeys: String, CodingKey {
                                case id
                                case version
                                case price
                                case paymentSource
                                case service
                                case limits
                                case attributes
                                case parentID = "parentId"
                            }
                        }

                        public init(count: Int? = nil, plan: Plan? = nil) {
                            self.count = count
                            self.plan = plan
                        }
                    }

                    public init(startTime: String? = nil, endTime: String? = nil, byAccount: ByAccount? = nil) {
                        self.startTime = startTime
                        self.endTime = endTime
                        self.byAccount = byAccount
                    }
                }

                public init(canSelectTrialPlan: Bool? = nil, lastTrialPlanExpirationTime: String? = nil, currentBillingPeriod: CurrentBillingPeriod? = nil) {
                    self.canSelectTrialPlan = canSelectTrialPlan
                    self.lastTrialPlanExpirationTime = lastTrialPlanExpirationTime
                    self.currentBillingPeriod = currentBillingPeriod
                }
            }

            /// Billing Plans for a single service
            public struct TestService: Codable {
                /// Can customer select trial plan for that service (if it exists)?
                public var canSelectTrialPlan: Bool?
                /// Expiration time of the last selected trial plan. Will be null if trial plan was not used.
                public var lastTrialPlanExpirationTime: String?
                /// Billing plans for a given period
                public var currentBillingPeriod: CurrentBillingPeriod?

                /// Billing plans for a given period
                public struct CurrentBillingPeriod: Codable {
                    /// Inclusive start of the period
                    public var startTime: String?
                    /// Exclusive end of the period.
                    public var endTime: String?
                    /// Selection of a billing plan
                    public var byAccount: ByAccount?

                    /// Selection of a billing plan
                    public struct ByAccount: Codable {
                        /// Number of instances of the billing plan.
                        public var count: Int?
                        /// Billing Plan
                        public var plan: Plan?

                        /// Billing Plan
                        public struct Plan: Codable {
                            /// The Billing Plan ID
                            public var id: String?
                            /// Version of the Billing Plan schema
                            public var version: String?
                            /// Price of the Billing Plan
                            public var price: Double?
                            /// Service that receives payments for this billing plan.
                            public var paymentSource: PaymentSource?
                            /// Name of the service that the plan applies to.
                            public var service: Service?
                            /// A collection of named numeric values
                            public var limits: [String: Double]?
                            /// Collection of attribute values.
                            public var attributes: [String: [String: AnyJSON]]?
                            public var parentID: String?

                            /// Service that receives payments for this billing plan.
                            public enum PaymentSource: String, Codable, CaseIterable {
                                case `none` = "None"
                                case appCenter = "AppCenter"
                                case gitHub = "GitHub"
                                case xtc = "Xtc"
                            }

                            /// Name of the service that the plan applies to.
                            public enum Service: String, Codable, CaseIterable {
                                case build = "Build"
                                case test = "Test"
                            }

                            public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
                                self.id = id
                                self.version = version
                                self.price = price
                                self.paymentSource = paymentSource
                                self.service = service
                                self.limits = limits
                                self.attributes = attributes
                                self.parentID = parentID
                            }

                            private enum CodingKeys: String, CodingKey {
                                case id
                                case version
                                case price
                                case paymentSource
                                case service
                                case limits
                                case attributes
                                case parentID = "parentId"
                            }
                        }

                        public init(count: Int? = nil, plan: Plan? = nil) {
                            self.count = count
                            self.plan = plan
                        }
                    }

                    public init(startTime: String? = nil, endTime: String? = nil, byAccount: ByAccount? = nil) {
                        self.startTime = startTime
                        self.endTime = endTime
                        self.byAccount = byAccount
                    }
                }

                public init(canSelectTrialPlan: Bool? = nil, lastTrialPlanExpirationTime: String? = nil, currentBillingPeriod: CurrentBillingPeriod? = nil) {
                    self.canSelectTrialPlan = canSelectTrialPlan
                    self.lastTrialPlanExpirationTime = lastTrialPlanExpirationTime
                    self.currentBillingPeriod = currentBillingPeriod
                }
            }

            public init(buildService: BuildService? = nil, testService: TestService? = nil) {
                self.buildService = buildService
                self.testService = testService
            }
        }

        /// Usage section in the Billing Information
        public struct Usage: Codable {
            /// Resource usage for a single Mobile Center service
            public var buildService: BuildService?
            /// Resource usage for a single Mobile Center service
            public var testService: TestService?

            /// Resource usage for a single Mobile Center service
            public struct BuildService: Codable {
                /// Usage for a single period
                public var currentUsagePeriod: CurrentUsagePeriod?

                /// Usage for a single period
                public struct CurrentUsagePeriod: Codable {
                    /// Inclusive start time of the usage period
                    public var startTime: String?
                    /// Exclusive end time of the usage period.
                    public var endTime: String?
                    /// A collection of named numeric values
                    public var byAccount: [String: Double]?
                    /// A collection of  named numeric values grouped by app
                    public var byApp: [String: [String: Double]]?

                    public init(startTime: String? = nil, endTime: String? = nil, byAccount: [String: Double]? = nil, byApp: [String: [String: Double]]? = nil) {
                        self.startTime = startTime
                        self.endTime = endTime
                        self.byAccount = byAccount
                        self.byApp = byApp
                    }
                }

                public init(currentUsagePeriod: CurrentUsagePeriod? = nil) {
                    self.currentUsagePeriod = currentUsagePeriod
                }
            }

            /// Resource usage for a single Mobile Center service
            public struct TestService: Codable {
                /// Usage for a single period
                public var currentUsagePeriod: CurrentUsagePeriod?

                /// Usage for a single period
                public struct CurrentUsagePeriod: Codable {
                    /// Inclusive start time of the usage period
                    public var startTime: String?
                    /// Exclusive end time of the usage period.
                    public var endTime: String?
                    /// A collection of named numeric values
                    public var byAccount: [String: Double]?
                    /// A collection of  named numeric values grouped by app
                    public var byApp: [String: [String: Double]]?

                    public init(startTime: String? = nil, endTime: String? = nil, byAccount: [String: Double]? = nil, byApp: [String: [String: Double]]? = nil) {
                        self.startTime = startTime
                        self.endTime = endTime
                        self.byAccount = byAccount
                        self.byApp = byApp
                    }
                }

                public init(currentUsagePeriod: CurrentUsagePeriod? = nil) {
                    self.currentUsagePeriod = currentUsagePeriod
                }
            }

            public init(buildService: BuildService? = nil, testService: TestService? = nil) {
                self.buildService = buildService
                self.testService = testService
            }
        }

        /// State of the Azure subscription used for billing
        public enum AzureSubscriptionState: String, Codable, CaseIterable {
            case enabled = "Enabled"
            case disabled = "Disabled"
            case notSet = "NotSet"
        }

        public init(version: String? = nil, timestamp: String? = nil, id: String? = nil, billingPlans: BillingPlans? = nil, usage: Usage? = nil, azureSubscriptionID: String? = nil, azureSubscriptionState: AzureSubscriptionState? = nil) {
            self.version = version
            self.timestamp = timestamp
            self.id = id
            self.billingPlans = billingPlans
            self.usage = usage
            self.azureSubscriptionID = azureSubscriptionID
            self.azureSubscriptionState = azureSubscriptionState
        }

        private enum CodingKeys: String, CodingKey {
            case version
            case timestamp
            case id
            case billingPlans
            case usage
            case azureSubscriptionID = "azureSubscriptionId"
            case azureSubscriptionState
        }
    }

    public init(aggregatedBillings: AggregatedBillings? = nil) {
        self.aggregatedBillings = aggregatedBillings
    }
}

/// Error
public struct BillingError: Codable {
    public var error: Error?

    public struct Error: Codable {
        /// The status code return by the API. It can be 400 or 403 or 500.
        public var code: Int?
        /// The reason for the request failed
        public var message: String?

        public init(code: Int? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }
    }

    public init(error: Error? = nil) {
        self.error = error
    }
}

/// Billing Plans section in the Billing Information
public struct BillingInformationPlans: Codable {
    /// Billing Plans for a single service
    public var buildService: BuildService?
    /// Billing Plans for a single service
    public var testService: TestService?

    /// Billing Plans for a single service
    public struct BuildService: Codable {
        /// Can customer select trial plan for that service (if it exists)?
        public var canSelectTrialPlan: Bool?
        /// Expiration time of the last selected trial plan. Will be null if trial plan was not used.
        public var lastTrialPlanExpirationTime: String?
        /// Billing plans for a given period
        public var currentBillingPeriod: CurrentBillingPeriod?

        /// Billing plans for a given period
        public struct CurrentBillingPeriod: Codable {
            /// Inclusive start of the period
            public var startTime: String?
            /// Exclusive end of the period.
            public var endTime: String?
            /// Selection of a billing plan
            public var byAccount: ByAccount?

            /// Selection of a billing plan
            public struct ByAccount: Codable {
                /// Number of instances of the billing plan.
                public var count: Int?
                /// Billing Plan
                public var plan: Plan?

                /// Billing Plan
                public struct Plan: Codable {
                    /// The Billing Plan ID
                    public var id: String?
                    /// Version of the Billing Plan schema
                    public var version: String?
                    /// Price of the Billing Plan
                    public var price: Double?
                    /// Service that receives payments for this billing plan.
                    public var paymentSource: PaymentSource?
                    /// Name of the service that the plan applies to.
                    public var service: Service?
                    /// A collection of named numeric values
                    public var limits: [String: Double]?
                    /// Collection of attribute values.
                    public var attributes: [String: [String: AnyJSON]]?
                    public var parentID: String?

                    /// Service that receives payments for this billing plan.
                    public enum PaymentSource: String, Codable, CaseIterable {
                        case `none` = "None"
                        case appCenter = "AppCenter"
                        case gitHub = "GitHub"
                        case xtc = "Xtc"
                    }

                    /// Name of the service that the plan applies to.
                    public enum Service: String, Codable, CaseIterable {
                        case build = "Build"
                        case test = "Test"
                    }

                    public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
                        self.id = id
                        self.version = version
                        self.price = price
                        self.paymentSource = paymentSource
                        self.service = service
                        self.limits = limits
                        self.attributes = attributes
                        self.parentID = parentID
                    }

                    private enum CodingKeys: String, CodingKey {
                        case id
                        case version
                        case price
                        case paymentSource
                        case service
                        case limits
                        case attributes
                        case parentID = "parentId"
                    }
                }

                public init(count: Int? = nil, plan: Plan? = nil) {
                    self.count = count
                    self.plan = plan
                }
            }

            public init(startTime: String? = nil, endTime: String? = nil, byAccount: ByAccount? = nil) {
                self.startTime = startTime
                self.endTime = endTime
                self.byAccount = byAccount
            }
        }

        public init(canSelectTrialPlan: Bool? = nil, lastTrialPlanExpirationTime: String? = nil, currentBillingPeriod: CurrentBillingPeriod? = nil) {
            self.canSelectTrialPlan = canSelectTrialPlan
            self.lastTrialPlanExpirationTime = lastTrialPlanExpirationTime
            self.currentBillingPeriod = currentBillingPeriod
        }
    }

    /// Billing Plans for a single service
    public struct TestService: Codable {
        /// Can customer select trial plan for that service (if it exists)?
        public var canSelectTrialPlan: Bool?
        /// Expiration time of the last selected trial plan. Will be null if trial plan was not used.
        public var lastTrialPlanExpirationTime: String?
        /// Billing plans for a given period
        public var currentBillingPeriod: CurrentBillingPeriod?

        /// Billing plans for a given period
        public struct CurrentBillingPeriod: Codable {
            /// Inclusive start of the period
            public var startTime: String?
            /// Exclusive end of the period.
            public var endTime: String?
            /// Selection of a billing plan
            public var byAccount: ByAccount?

            /// Selection of a billing plan
            public struct ByAccount: Codable {
                /// Number of instances of the billing plan.
                public var count: Int?
                /// Billing Plan
                public var plan: Plan?

                /// Billing Plan
                public struct Plan: Codable {
                    /// The Billing Plan ID
                    public var id: String?
                    /// Version of the Billing Plan schema
                    public var version: String?
                    /// Price of the Billing Plan
                    public var price: Double?
                    /// Service that receives payments for this billing plan.
                    public var paymentSource: PaymentSource?
                    /// Name of the service that the plan applies to.
                    public var service: Service?
                    /// A collection of named numeric values
                    public var limits: [String: Double]?
                    /// Collection of attribute values.
                    public var attributes: [String: [String: AnyJSON]]?
                    public var parentID: String?

                    /// Service that receives payments for this billing plan.
                    public enum PaymentSource: String, Codable, CaseIterable {
                        case `none` = "None"
                        case appCenter = "AppCenter"
                        case gitHub = "GitHub"
                        case xtc = "Xtc"
                    }

                    /// Name of the service that the plan applies to.
                    public enum Service: String, Codable, CaseIterable {
                        case build = "Build"
                        case test = "Test"
                    }

                    public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
                        self.id = id
                        self.version = version
                        self.price = price
                        self.paymentSource = paymentSource
                        self.service = service
                        self.limits = limits
                        self.attributes = attributes
                        self.parentID = parentID
                    }

                    private enum CodingKeys: String, CodingKey {
                        case id
                        case version
                        case price
                        case paymentSource
                        case service
                        case limits
                        case attributes
                        case parentID = "parentId"
                    }
                }

                public init(count: Int? = nil, plan: Plan? = nil) {
                    self.count = count
                    self.plan = plan
                }
            }

            public init(startTime: String? = nil, endTime: String? = nil, byAccount: ByAccount? = nil) {
                self.startTime = startTime
                self.endTime = endTime
                self.byAccount = byAccount
            }
        }

        public init(canSelectTrialPlan: Bool? = nil, lastTrialPlanExpirationTime: String? = nil, currentBillingPeriod: CurrentBillingPeriod? = nil) {
            self.canSelectTrialPlan = canSelectTrialPlan
            self.lastTrialPlanExpirationTime = lastTrialPlanExpirationTime
            self.currentBillingPeriod = currentBillingPeriod
        }
    }

    public init(buildService: BuildService? = nil, testService: TestService? = nil) {
        self.buildService = buildService
        self.testService = testService
    }
}

public struct BillingInformationSearchResult: Codable {
    /// The Account ID
    public var accountID: String?
    /// The Account Name
    public var accountName: String?
    /// The Billing Internal Account ID
    public var billingInternalAccountID: String?
    /// The ID of the Build Billing Plan
    public var buildPlan: String?
    /// The ID of the Test Billing Plan
    public var testPlan: String?

    public init(accountID: String? = nil, accountName: String? = nil, billingInternalAccountID: String? = nil, buildPlan: String? = nil, testPlan: String? = nil) {
        self.accountID = accountID
        self.accountName = accountName
        self.billingInternalAccountID = billingInternalAccountID
        self.buildPlan = buildPlan
        self.testPlan = testPlan
    }

    private enum CodingKeys: String, CodingKey {
        case accountID = "accountId"
        case accountName
        case billingInternalAccountID = "billingInternalAccountId"
        case buildPlan
        case testPlan
    }
}

/// Billing plans for a given period
public struct BillingPeriod: Codable {
    /// Inclusive start of the period
    public var startTime: String?
    /// Exclusive end of the period.
    public var endTime: String?
    /// Selection of a billing plan
    public var byAccount: ByAccount?

    /// Selection of a billing plan
    public struct ByAccount: Codable {
        /// Number of instances of the billing plan.
        public var count: Int?
        /// Billing Plan
        public var plan: Plan?

        /// Billing Plan
        public struct Plan: Codable {
            /// The Billing Plan ID
            public var id: String?
            /// Version of the Billing Plan schema
            public var version: String?
            /// Price of the Billing Plan
            public var price: Double?
            /// Service that receives payments for this billing plan.
            public var paymentSource: PaymentSource?
            /// Name of the service that the plan applies to.
            public var service: Service?
            /// A collection of named numeric values
            public var limits: [String: Double]?
            /// Collection of attribute values.
            public var attributes: [String: [String: AnyJSON]]?
            public var parentID: String?

            /// Service that receives payments for this billing plan.
            public enum PaymentSource: String, Codable, CaseIterable {
                case `none` = "None"
                case appCenter = "AppCenter"
                case gitHub = "GitHub"
                case xtc = "Xtc"
            }

            /// Name of the service that the plan applies to.
            public enum Service: String, Codable, CaseIterable {
                case build = "Build"
                case test = "Test"
            }

            public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
                self.id = id
                self.version = version
                self.price = price
                self.paymentSource = paymentSource
                self.service = service
                self.limits = limits
                self.attributes = attributes
                self.parentID = parentID
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case version
                case price
                case paymentSource
                case service
                case limits
                case attributes
                case parentID = "parentId"
            }
        }

        public init(count: Int? = nil, plan: Plan? = nil) {
            self.count = count
            self.plan = plan
        }
    }

    public init(startTime: String? = nil, endTime: String? = nil, byAccount: ByAccount? = nil) {
        self.startTime = startTime
        self.endTime = endTime
        self.byAccount = byAccount
    }
}

/// Billing Plan
public struct BillingPlan: Codable {
    /// The Billing Plan ID
    public var id: String?
    /// Version of the Billing Plan schema
    public var version: String?
    /// Price of the Billing Plan
    public var price: Double?
    /// Service that receives payments for this billing plan.
    public var paymentSource: PaymentSource?
    /// Name of the service that the plan applies to.
    public var service: Service?
    /// A collection of named numeric values
    public var limits: [String: Double]?
    /// Collection of attribute values.
    public var attributes: [String: [String: AnyJSON]]?
    public var parentID: String?

    /// Service that receives payments for this billing plan.
    public enum PaymentSource: String, Codable, CaseIterable {
        case `none` = "None"
        case appCenter = "AppCenter"
        case gitHub = "GitHub"
        case xtc = "Xtc"
    }

    /// Name of the service that the plan applies to.
    public enum Service: String, Codable, CaseIterable {
        case build = "Build"
        case test = "Test"
    }

    public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
        self.id = id
        self.version = version
        self.price = price
        self.paymentSource = paymentSource
        self.service = service
        self.limits = limits
        self.attributes = attributes
        self.parentID = parentID
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case version
        case price
        case paymentSource
        case service
        case limits
        case attributes
        case parentID = "parentId"
    }
}

/// Responses for requests that detect billing plans change type
public struct BillingPlansChangeTypeResponse: Codable {
    public var result: Result?

    public enum Result: String, Codable, CaseIterable {
        case noChange = "NoChange"
        case downgrade = "Downgrade"
        case upgrade = "Upgrade"
    }

    public init(result: Result? = nil) {
        self.result = result
    }
}

/// Selection of a billing plan
public struct BillingPlanSelection: Codable {
    /// Number of instances of the billing plan.
    public var count: Int?
    /// Billing Plan
    public var plan: Plan?

    /// Billing Plan
    public struct Plan: Codable {
        /// The Billing Plan ID
        public var id: String?
        /// Version of the Billing Plan schema
        public var version: String?
        /// Price of the Billing Plan
        public var price: Double?
        /// Service that receives payments for this billing plan.
        public var paymentSource: PaymentSource?
        /// Name of the service that the plan applies to.
        public var service: Service?
        /// A collection of named numeric values
        public var limits: [String: Double]?
        /// Collection of attribute values.
        public var attributes: [String: [String: AnyJSON]]?
        public var parentID: String?

        /// Service that receives payments for this billing plan.
        public enum PaymentSource: String, Codable, CaseIterable {
            case `none` = "None"
            case appCenter = "AppCenter"
            case gitHub = "GitHub"
            case xtc = "Xtc"
        }

        /// Name of the service that the plan applies to.
        public enum Service: String, Codable, CaseIterable {
            case build = "Build"
            case test = "Test"
        }

        public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
            self.id = id
            self.version = version
            self.price = price
            self.paymentSource = paymentSource
            self.service = service
            self.limits = limits
            self.attributes = attributes
            self.parentID = parentID
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case version
            case price
            case paymentSource
            case service
            case limits
            case attributes
            case parentID = "parentId"
        }
    }

    public init(count: Int? = nil, plan: Plan? = nil) {
        self.count = count
        self.plan = plan
    }
}

/// Selection of a billing plan for one or more services
public struct BillingPlansSelection: Codable {
    /// Selection of a billing plan
    public var buildService: BuildService?
    /// Selection of a billing plan
    public var testService: TestService?

    /// Selection of a billing plan
    public struct BuildService: Codable {
        /// Number of instances of the billing plan.
        public var count: Int?
        /// Billing Plan
        public var plan: Plan?

        /// Billing Plan
        public struct Plan: Codable {
            /// The Billing Plan ID
            public var id: String?
            /// Version of the Billing Plan schema
            public var version: String?
            /// Price of the Billing Plan
            public var price: Double?
            /// Service that receives payments for this billing plan.
            public var paymentSource: PaymentSource?
            /// Name of the service that the plan applies to.
            public var service: Service?
            /// A collection of named numeric values
            public var limits: [String: Double]?
            /// Collection of attribute values.
            public var attributes: [String: [String: AnyJSON]]?
            public var parentID: String?

            /// Service that receives payments for this billing plan.
            public enum PaymentSource: String, Codable, CaseIterable {
                case `none` = "None"
                case appCenter = "AppCenter"
                case gitHub = "GitHub"
                case xtc = "Xtc"
            }

            /// Name of the service that the plan applies to.
            public enum Service: String, Codable, CaseIterable {
                case build = "Build"
                case test = "Test"
            }

            public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
                self.id = id
                self.version = version
                self.price = price
                self.paymentSource = paymentSource
                self.service = service
                self.limits = limits
                self.attributes = attributes
                self.parentID = parentID
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case version
                case price
                case paymentSource
                case service
                case limits
                case attributes
                case parentID = "parentId"
            }
        }

        public init(count: Int? = nil, plan: Plan? = nil) {
            self.count = count
            self.plan = plan
        }
    }

    /// Selection of a billing plan
    public struct TestService: Codable {
        /// Number of instances of the billing plan.
        public var count: Int?
        /// Billing Plan
        public var plan: Plan?

        /// Billing Plan
        public struct Plan: Codable {
            /// The Billing Plan ID
            public var id: String?
            /// Version of the Billing Plan schema
            public var version: String?
            /// Price of the Billing Plan
            public var price: Double?
            /// Service that receives payments for this billing plan.
            public var paymentSource: PaymentSource?
            /// Name of the service that the plan applies to.
            public var service: Service?
            /// A collection of named numeric values
            public var limits: [String: Double]?
            /// Collection of attribute values.
            public var attributes: [String: [String: AnyJSON]]?
            public var parentID: String?

            /// Service that receives payments for this billing plan.
            public enum PaymentSource: String, Codable, CaseIterable {
                case `none` = "None"
                case appCenter = "AppCenter"
                case gitHub = "GitHub"
                case xtc = "Xtc"
            }

            /// Name of the service that the plan applies to.
            public enum Service: String, Codable, CaseIterable {
                case build = "Build"
                case test = "Test"
            }

            public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
                self.id = id
                self.version = version
                self.price = price
                self.paymentSource = paymentSource
                self.service = service
                self.limits = limits
                self.attributes = attributes
                self.parentID = parentID
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case version
                case price
                case paymentSource
                case service
                case limits
                case attributes
                case parentID = "parentId"
            }
        }

        public init(count: Int? = nil, plan: Plan? = nil) {
            self.count = count
            self.plan = plan
        }
    }

    public init(buildService: BuildService? = nil, testService: TestService? = nil) {
        self.buildService = buildService
        self.testService = testService
    }
}

/// Usage section in the Billing Information
public struct BillingResourceUsage: Codable {
    /// Resource usage for a single Mobile Center service
    public var buildService: BuildService?
    /// Resource usage for a single Mobile Center service
    public var testService: TestService?

    /// Resource usage for a single Mobile Center service
    public struct BuildService: Codable {
        /// Usage for a single period
        public var currentUsagePeriod: CurrentUsagePeriod?

        /// Usage for a single period
        public struct CurrentUsagePeriod: Codable {
            /// Inclusive start time of the usage period
            public var startTime: String?
            /// Exclusive end time of the usage period.
            public var endTime: String?
            /// A collection of named numeric values
            public var byAccount: [String: Double]?
            /// A collection of  named numeric values grouped by app
            public var byApp: [String: [String: Double]]?

            public init(startTime: String? = nil, endTime: String? = nil, byAccount: [String: Double]? = nil, byApp: [String: [String: Double]]? = nil) {
                self.startTime = startTime
                self.endTime = endTime
                self.byAccount = byAccount
                self.byApp = byApp
            }
        }

        public init(currentUsagePeriod: CurrentUsagePeriod? = nil) {
            self.currentUsagePeriod = currentUsagePeriod
        }
    }

    /// Resource usage for a single Mobile Center service
    public struct TestService: Codable {
        /// Usage for a single period
        public var currentUsagePeriod: CurrentUsagePeriod?

        /// Usage for a single period
        public struct CurrentUsagePeriod: Codable {
            /// Inclusive start time of the usage period
            public var startTime: String?
            /// Exclusive end time of the usage period.
            public var endTime: String?
            /// A collection of named numeric values
            public var byAccount: [String: Double]?
            /// A collection of  named numeric values grouped by app
            public var byApp: [String: [String: Double]]?

            public init(startTime: String? = nil, endTime: String? = nil, byAccount: [String: Double]? = nil, byApp: [String: [String: Double]]? = nil) {
                self.startTime = startTime
                self.endTime = endTime
                self.byAccount = byAccount
                self.byApp = byApp
            }
        }

        public init(currentUsagePeriod: CurrentUsagePeriod? = nil) {
            self.currentUsagePeriod = currentUsagePeriod
        }
    }

    public init(buildService: BuildService? = nil, testService: TestService? = nil) {
        self.buildService = buildService
        self.testService = testService
    }
}

/// GDPR tests verification result
public struct GdprVerificationResult: Codable {
    /// Verification status. True means that the verification was successfull.
    public var isStatus: Bool?
    /// Optional error message if the verification failed.
    public var message: String?

    public init(isStatus: Bool? = nil, message: String? = nil) {
        self.isStatus = isStatus
        self.message = message
    }

    private enum CodingKeys: String, CodingKey {
        case isStatus = "status"
        case message
    }
}

/// GitHub account information
public struct GitHubAccount: Codable {
    /// Id of GitHub account
    public var id: Int?
    /// Type of GitHub account
    public var accountType: AccountType?

    /// Type of GitHub account
    public enum AccountType: String, Codable, CaseIterable {
        case user = "User"
        case organization = "Organization"
    }

    public init(id: Int? = nil, accountType: AccountType? = nil) {
        self.id = id
        self.accountType = accountType
    }
}

/// GitHub Marketplace plan
public struct GitHubMarketplacePlan: Codable {
    /// Id of the GitHub plan
    public var id: Int?

    public init(id: Int? = nil) {
        self.id = id
    }
}

/// GitHub Marketplace purchase
public struct GitHubMarketplacePurchase: Codable {
    /// GitHub account information
    public var account: Account?
    /// GitHub Marketplace plan
    public var plan: Plan?

    /// GitHub account information
    public struct Account: Codable {
        /// Id of GitHub account
        public var id: Int?
        /// Type of GitHub account
        public var accountType: AccountType?

        /// Type of GitHub account
        public enum AccountType: String, Codable, CaseIterable {
            case user = "User"
            case organization = "Organization"
        }

        public init(id: Int? = nil, accountType: AccountType? = nil) {
            self.id = id
            self.accountType = accountType
        }
    }

    /// GitHub Marketplace plan
    public struct Plan: Codable {
        /// Id of the GitHub plan
        public var id: Int?

        public init(id: Int? = nil) {
            self.id = id
        }
    }

    public init(account: Account? = nil, plan: Plan? = nil) {
        self.account = account
        self.plan = plan
    }
}

/// Billing Plans for a single service
public struct ServiceBillingPlans: Codable {
    /// Can customer select trial plan for that service (if it exists)?
    public var canSelectTrialPlan: Bool?
    /// Expiration time of the last selected trial plan. Will be null if trial plan was not used.
    public var lastTrialPlanExpirationTime: String?
    /// Billing plans for a given period
    public var currentBillingPeriod: CurrentBillingPeriod?

    /// Billing plans for a given period
    public struct CurrentBillingPeriod: Codable {
        /// Inclusive start of the period
        public var startTime: String?
        /// Exclusive end of the period.
        public var endTime: String?
        /// Selection of a billing plan
        public var byAccount: ByAccount?

        /// Selection of a billing plan
        public struct ByAccount: Codable {
            /// Number of instances of the billing plan.
            public var count: Int?
            /// Billing Plan
            public var plan: Plan?

            /// Billing Plan
            public struct Plan: Codable {
                /// The Billing Plan ID
                public var id: String?
                /// Version of the Billing Plan schema
                public var version: String?
                /// Price of the Billing Plan
                public var price: Double?
                /// Service that receives payments for this billing plan.
                public var paymentSource: PaymentSource?
                /// Name of the service that the plan applies to.
                public var service: Service?
                /// A collection of named numeric values
                public var limits: [String: Double]?
                /// Collection of attribute values.
                public var attributes: [String: [String: AnyJSON]]?
                public var parentID: String?

                /// Service that receives payments for this billing plan.
                public enum PaymentSource: String, Codable, CaseIterable {
                    case `none` = "None"
                    case appCenter = "AppCenter"
                    case gitHub = "GitHub"
                    case xtc = "Xtc"
                }

                /// Name of the service that the plan applies to.
                public enum Service: String, Codable, CaseIterable {
                    case build = "Build"
                    case test = "Test"
                }

                public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
                    self.id = id
                    self.version = version
                    self.price = price
                    self.paymentSource = paymentSource
                    self.service = service
                    self.limits = limits
                    self.attributes = attributes
                    self.parentID = parentID
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case version
                    case price
                    case paymentSource
                    case service
                    case limits
                    case attributes
                    case parentID = "parentId"
                }
            }

            public init(count: Int? = nil, plan: Plan? = nil) {
                self.count = count
                self.plan = plan
            }
        }

        public init(startTime: String? = nil, endTime: String? = nil, byAccount: ByAccount? = nil) {
            self.startTime = startTime
            self.endTime = endTime
            self.byAccount = byAccount
        }
    }

    public init(canSelectTrialPlan: Bool? = nil, lastTrialPlanExpirationTime: String? = nil, currentBillingPeriod: CurrentBillingPeriod? = nil) {
        self.canSelectTrialPlan = canSelectTrialPlan
        self.lastTrialPlanExpirationTime = lastTrialPlanExpirationTime
        self.currentBillingPeriod = currentBillingPeriod
    }
}

/// Resource usage for a single Mobile Center service
public struct ServiceResourceUsage: Codable {
    /// Usage for a single period
    public var currentUsagePeriod: CurrentUsagePeriod?

    /// Usage for a single period
    public struct CurrentUsagePeriod: Codable {
        /// Inclusive start time of the usage period
        public var startTime: String?
        /// Exclusive end time of the usage period.
        public var endTime: String?
        /// A collection of named numeric values
        public var byAccount: [String: Double]?
        /// A collection of  named numeric values grouped by app
        public var byApp: [String: [String: Double]]?

        public init(startTime: String? = nil, endTime: String? = nil, byAccount: [String: Double]? = nil, byApp: [String: [String: Double]]? = nil) {
            self.startTime = startTime
            self.endTime = endTime
            self.byAccount = byAccount
            self.byApp = byApp
        }
    }

    public init(currentUsagePeriod: CurrentUsagePeriod? = nil) {
        self.currentUsagePeriod = currentUsagePeriod
    }
}

/// Usage for a single period
public struct UsagePeriod: Codable {
    /// Inclusive start time of the usage period
    public var startTime: String?
    /// Exclusive end time of the usage period.
    public var endTime: String?
    /// A collection of named numeric values
    public var byAccount: [String: Double]?
    /// A collection of  named numeric values grouped by app
    public var byApp: [String: [String: Double]]?

    public init(startTime: String? = nil, endTime: String? = nil, byAccount: [String: Double]? = nil, byApp: [String: [String: Double]]? = nil) {
        self.startTime = startTime
        self.endTime = endTime
        self.byAccount = byAccount
        self.byApp = byApp
    }
}

/// Status of the usage record creation
public struct UsageRecordStatus: Codable {
    /// Is the age of the most recent Build service usage record within expected limits
    public var isExpectedLatestBuildExists: Bool?
    /// Is the age of the most recent Test service usage record within expected limits
    public var isExpectedLatestTestExists: Bool?
    /// The time of the most recent Build service usage record
    public var latestBuildUsageRecordTime: String?
    /// The time of the most recent Test service usage record
    public var latestTestUsageRecordTime: String?

    public init(isExpectedLatestBuildExists: Bool? = nil, isExpectedLatestTestExists: Bool? = nil, latestBuildUsageRecordTime: String? = nil, latestTestUsageRecordTime: String? = nil) {
        self.isExpectedLatestBuildExists = isExpectedLatestBuildExists
        self.isExpectedLatestTestExists = isExpectedLatestTestExists
        self.latestBuildUsageRecordTime = latestBuildUsageRecordTime
        self.latestTestUsageRecordTime = latestTestUsageRecordTime
    }

    private enum CodingKeys: String, CodingKey {
        case isExpectedLatestBuildExists = "expectedLatestBuildExists"
        case isExpectedLatestTestExists = "expectedLatestTestExists"
        case latestBuildUsageRecordTime
        case latestTestUsageRecordTime
    }
}

/// Billing Plan with a version
public struct VersionedBillingPlan: Codable {
    /// Billing Plan
    public var document: Document?
    /// The version of the object
    public var etag: String?

    /// Billing Plan
    public struct Document: Codable {
        /// The Billing Plan ID
        public var id: String?
        /// Version of the Billing Plan schema
        public var version: String?
        /// Price of the Billing Plan
        public var price: Double?
        /// Service that receives payments for this billing plan.
        public var paymentSource: PaymentSource?
        /// Name of the service that the plan applies to.
        public var service: Service?
        /// A collection of named numeric values
        public var limits: [String: Double]?
        /// Collection of attribute values.
        public var attributes: [String: [String: AnyJSON]]?
        public var parentID: String?

        /// Service that receives payments for this billing plan.
        public enum PaymentSource: String, Codable, CaseIterable {
            case `none` = "None"
            case appCenter = "AppCenter"
            case gitHub = "GitHub"
            case xtc = "Xtc"
        }

        /// Name of the service that the plan applies to.
        public enum Service: String, Codable, CaseIterable {
            case build = "Build"
            case test = "Test"
        }

        public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
            self.id = id
            self.version = version
            self.price = price
            self.paymentSource = paymentSource
            self.service = service
            self.limits = limits
            self.attributes = attributes
            self.parentID = parentID
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case version
            case price
            case paymentSource
            case service
            case limits
            case attributes
            case parentID = "parentId"
        }
    }

    public init(document: Document? = nil, etag: String? = nil) {
        self.document = document
        self.etag = etag
    }
}

/// Envelope for messages sent to actors
public struct MessageEnvelope: Codable {
    /// Unique id of the message
    public var messageID: String?
    /// Type of the message
    public var messageType: String?
    /// Body of the message
    public var message: [String: AnyJSON]?

    public init(messageID: String? = nil, messageType: String? = nil, message: [String: AnyJSON]? = nil) {
        self.messageID = messageID
        self.messageType = messageType
        self.message = message
    }

    private enum CodingKeys: String, CodingKey {
        case messageID = "messageId"
        case messageType
        case message
    }
}

public struct FileAsset: Codable {
    public var id: String?
    public var location: String?
    public var token: String?
    public var uploadDomain: String?
    public var uploadWindowLocation: String?
    public var urlEncodedToken: String?

    public init(id: String? = nil, location: String? = nil, token: String? = nil, uploadDomain: String? = nil, uploadWindowLocation: String? = nil, urlEncodedToken: String? = nil) {
        self.id = id
        self.location = location
        self.token = token
        self.uploadDomain = uploadDomain
        self.uploadWindowLocation = uploadWindowLocation
        self.urlEncodedToken = urlEncodedToken
    }
}

/// The source repository
public struct SourceRepository: Codable {
    /// The repository name
    public var name: String?
    /// URL used to clone the repository
    public var cloneURL: String?

    public init(name: String? = nil, cloneURL: String? = nil) {
        self.name = name
        self.cloneURL = cloneURL
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case cloneURL = "clone_url"
    }
}

/// The source repository
public struct SourceRepositoriesItem: Codable {
    /// The repository name
    public var name: String?
    /// URL used to clone the repository
    public var cloneURL: String?

    public init(name: String? = nil, cloneURL: String? = nil) {
        self.name = name
        self.cloneURL = cloneURL
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case cloneURL = "clone_url"
    }
}

/// The GitHub Installation
public struct GitHubInstallationLite: Codable {
    /// GitHub Installation Id
    public var id: Double?
    /// The GitHub Installation
    public var account: Account?
    /// GitHub Installation App Id
    public var appID: Double?

    /// The GitHub Installation
    public struct Account: Codable {
        /// GitHub Account Id
        public var id: String?
        /// GitHub Account Login Name
        public var login: String?
        /// GitHub Account Type
        public var type: String?
        /// GitHub Account Url
        public var url: String?

        public init(id: String? = nil, login: String? = nil, type: String? = nil, url: String? = nil) {
            self.id = id
            self.login = login
            self.type = type
            self.url = url
        }
    }

    public init(id: Double? = nil, account: Account? = nil, appID: Double? = nil) {
        self.id = id
        self.account = account
        self.appID = appID
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case account
        case appID = "app_id"
    }
}

/// The GitHub Installation
public struct GitHubAccountLite: Codable {
    /// GitHub Account Id
    public var id: String?
    /// GitHub Account Login Name
    public var login: String?
    /// GitHub Account Type
    public var type: String?
    /// GitHub Account Url
    public var url: String?

    public init(id: String? = nil, login: String? = nil, type: String? = nil, url: String? = nil) {
        self.id = id
        self.login = login
        self.type = type
        self.url = url
    }
}

/// The repository which is accessiable by GitHub App Installation
public struct GitHubInstallationRepository: Codable {
    /// The repository name
    public var name: String?
    /// The discription of repository
    public var description: String?
    /// URL used to clone the repository
    public var cloneURL: String?
    /// The default branch for the repo
    public var defaultBranch: String?
    /// The language in the repository
    public var language: String?
    /// The repository updated time
    public var updatedAt: String?
    /// Whether the repository is a fork
    public var isFork: Bool?

    public init(name: String? = nil, description: String? = nil, cloneURL: String? = nil, defaultBranch: String? = nil, language: String? = nil, updatedAt: String? = nil, isFork: Bool? = nil) {
        self.name = name
        self.description = description
        self.cloneURL = cloneURL
        self.defaultBranch = defaultBranch
        self.language = language
        self.updatedAt = updatedAt
        self.isFork = isFork
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case description
        case cloneURL = "clone_url"
        case defaultBranch = "default_branch"
        case language
        case updatedAt = "updated_at"
        case isFork = "fork"
    }
}

/// The repository which is accessiable by GitHub App Installation
public struct GitHubInstallationRepositoriesItem: Codable {
    /// The repository name
    public var name: String?
    /// The discription of repository
    public var description: String?
    /// URL used to clone the repository
    public var cloneURL: String?
    /// The default branch for the repo
    public var defaultBranch: String?
    /// The language in the repository
    public var language: String?
    /// The repository updated time
    public var updatedAt: String?
    /// Whether the repository is a fork
    public var isFork: Bool?

    public init(name: String? = nil, description: String? = nil, cloneURL: String? = nil, defaultBranch: String? = nil, language: String? = nil, updatedAt: String? = nil, isFork: Bool? = nil) {
        self.name = name
        self.description = description
        self.cloneURL = cloneURL
        self.defaultBranch = defaultBranch
        self.language = language
        self.updatedAt = updatedAt
        self.isFork = isFork
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case description
        case cloneURL = "clone_url"
        case defaultBranch = "default_branch"
        case language
        case updatedAt = "updated_at"
        case isFork = "fork"
    }
}

/// App Center account details from GitHub billing
public struct GitHubBillingAccount: Codable {
    /// The unique id (UUID) of the account
    public var id: String
    /// The account's display name
    public var displayName: String
    /// The unique name that used to identify the owner
    public var name: String
    /// The owner type. Can either be 'org' or 'user'
    public var type: `Type`

    /// The owner type. Can either be 'org' or 'user'
    public enum `Type`: String, Codable, CaseIterable {
        case org
        case user
    }

    public init(id: String, displayName: String, name: String, type: `Type`) {
        self.id = id
        self.displayName = displayName
        self.name = name
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case displayName = "display_name"
        case name
        case type
    }
}

/// The lite version of GitHub pull request
public struct GitHubPullRequestLite: Codable {
    /// The lite version of GitHub branch
    public var head: Head?
    /// The lite version of GitHub branch
    public var base: Base?

    /// The lite version of GitHub branch
    public struct Head: Codable {
        /// The repository name
        public var ref: String?
        /// The discription of repository
        public var sha: String?
        /// The lite version of GitHub repository
        public var repo: Repo?

        /// The lite version of GitHub repository
        public struct Repo: Codable {
            /// The repository id
            public var id: Double?

            public init(id: Double? = nil) {
                self.id = id
            }
        }

        public init(ref: String? = nil, sha: String? = nil, repo: Repo? = nil) {
            self.ref = ref
            self.sha = sha
            self.repo = repo
        }
    }

    /// The lite version of GitHub branch
    public struct Base: Codable {
        /// The repository name
        public var ref: String?
        /// The discription of repository
        public var sha: String?
        /// The lite version of GitHub repository
        public var repo: Repo?

        /// The lite version of GitHub repository
        public struct Repo: Codable {
            /// The repository id
            public var id: Double?

            public init(id: Double? = nil) {
                self.id = id
            }
        }

        public init(ref: String? = nil, sha: String? = nil, repo: Repo? = nil) {
            self.ref = ref
            self.sha = sha
            self.repo = repo
        }
    }

    public init(head: Head? = nil, base: Base? = nil) {
        self.head = head
        self.base = base
    }
}

/// The lite version of GitHub branch
public struct GitHubBranchLite: Codable {
    /// The repository name
    public var ref: String?
    /// The discription of repository
    public var sha: String?
    /// The lite version of GitHub repository
    public var repo: Repo?

    /// The lite version of GitHub repository
    public struct Repo: Codable {
        /// The repository id
        public var id: Double?

        public init(id: Double? = nil) {
            self.id = id
        }
    }

    public init(ref: String? = nil, sha: String? = nil, repo: Repo? = nil) {
        self.ref = ref
        self.sha = sha
        self.repo = repo
    }
}

/// The lite version of GitHub repository
public struct GitHubRepositoryLite: Codable {
    /// The repository id
    public var id: Double?

    public init(id: Double? = nil) {
        self.id = id
    }
}

/// App extension information
public struct IosAppExtensionInfo: Codable {
    /// App extension name
    public var name: String
    /// App extension bundle identifier
    public var targetBundleIdentifier: String

    public init(name: String, targetBundleIdentifier: String) {
        self.name = name
        self.targetBundleIdentifier = targetBundleIdentifier
    }
}

/// Provisioning profile fetch and store information
public struct ProvisioningProfileFile: Codable {
    /// Name of uploaded provisioning profile
    public var fileName: String?
    /// File id from secure file storage
    public var fileID: String?
    /// Upload id to App Center File Upload Store
    public var uploadID: String?
    /// Target the provisioning profile is used to sign
    public var targetBundleIdentifier: String?

    public init(fileName: String? = nil, fileID: String? = nil, uploadID: String? = nil, targetBundleIdentifier: String? = nil) {
        self.fileName = fileName
        self.fileID = fileID
        self.uploadID = uploadID
        self.targetBundleIdentifier = targetBundleIdentifier
    }

    private enum CodingKeys: String, CodingKey {
        case fileName
        case fileID = "fileId"
        case uploadID = "uploadId"
        case targetBundleIdentifier
    }
}

/// VSTS user profile
public struct VSTSProfile: Codable {
    /// Profile id
    public var id: String?
    /// Profile display name
    public var displayName: String?
    /// Profile alias
    public var publicAlias: String?
    /// Profile email
    public var emailAddress: String?

    public init(id: String? = nil, displayName: String? = nil, publicAlias: String? = nil, emailAddress: String? = nil) {
        self.id = id
        self.displayName = displayName
        self.publicAlias = publicAlias
        self.emailAddress = emailAddress
    }
}

/// VSTS project
public struct VSTSProject: Codable {
    /// Project id
    public var id: String?
    /// Project name
    public var name: String?
    /// Project description
    public var description: String?
    /// Project URL
    public var url: String?
    /// Project state
    public var state: String?
    /// Project visibility
    public var visibility: String?

    public init(id: String? = nil, name: String? = nil, description: String? = nil, url: String? = nil, state: String? = nil, visibility: String? = nil) {
        self.id = id
        self.name = name
        self.description = description
        self.url = url
        self.state = state
        self.visibility = visibility
    }
}

/// VSTS account with projects list and user info
public struct VSTSAccount: Codable {
    /// Account id
    public var accountID: String?
    /// Account uri
    public var accountUri: String?
    /// Account name
    public var accountName: String?
    /// Account type
    public var accountType: String?
    /// Account status
    public var accountStatus: String?
    /// VSTS user profile
    public var user: User?
    /// Account projects
    public var projects: [Project]?

    /// VSTS user profile
    public struct User: Codable {
        /// Profile id
        public var id: String?
        /// Profile display name
        public var displayName: String?
        /// Profile alias
        public var publicAlias: String?
        /// Profile email
        public var emailAddress: String?

        public init(id: String? = nil, displayName: String? = nil, publicAlias: String? = nil, emailAddress: String? = nil) {
            self.id = id
            self.displayName = displayName
            self.publicAlias = publicAlias
            self.emailAddress = emailAddress
        }
    }

    /// VSTS project
    public struct Project: Codable {
        /// Project id
        public var id: String?
        /// Project name
        public var name: String?
        /// Project description
        public var description: String?
        /// Project URL
        public var url: String?
        /// Project state
        public var state: String?
        /// Project visibility
        public var visibility: String?

        public init(id: String? = nil, name: String? = nil, description: String? = nil, url: String? = nil, state: String? = nil, visibility: String? = nil) {
            self.id = id
            self.name = name
            self.description = description
            self.url = url
            self.state = state
            self.visibility = visibility
        }
    }

    public init(accountID: String? = nil, accountUri: String? = nil, accountName: String? = nil, accountType: String? = nil, accountStatus: String? = nil, user: User? = nil, projects: [Project]? = nil) {
        self.accountID = accountID
        self.accountUri = accountUri
        self.accountName = accountName
        self.accountType = accountType
        self.accountStatus = accountStatus
        self.user = user
        self.projects = projects
    }

    private enum CodingKeys: String, CodingKey {
        case accountID = "accountId"
        case accountUri
        case accountName
        case accountType
        case accountStatus
        case user
        case projects
    }
}

/// VSTS account with projects list and user info
public struct VSTSAccountsItem: Codable {
    /// Account id
    public var accountID: String?
    /// Account uri
    public var accountUri: String?
    /// Account name
    public var accountName: String?
    /// Account type
    public var accountType: String?
    /// Account status
    public var accountStatus: String?
    /// VSTS user profile
    public var user: User?
    /// Account projects
    public var projects: [Project]?

    /// VSTS user profile
    public struct User: Codable {
        /// Profile id
        public var id: String?
        /// Profile display name
        public var displayName: String?
        /// Profile alias
        public var publicAlias: String?
        /// Profile email
        public var emailAddress: String?

        public init(id: String? = nil, displayName: String? = nil, publicAlias: String? = nil, emailAddress: String? = nil) {
            self.id = id
            self.displayName = displayName
            self.publicAlias = publicAlias
            self.emailAddress = emailAddress
        }
    }

    /// VSTS project
    public struct Project: Codable {
        /// Project id
        public var id: String?
        /// Project name
        public var name: String?
        /// Project description
        public var description: String?
        /// Project URL
        public var url: String?
        /// Project state
        public var state: String?
        /// Project visibility
        public var visibility: String?

        public init(id: String? = nil, name: String? = nil, description: String? = nil, url: String? = nil, state: String? = nil, visibility: String? = nil) {
            self.id = id
            self.name = name
            self.description = description
            self.url = url
            self.state = state
            self.visibility = visibility
        }
    }

    public init(accountID: String? = nil, accountUri: String? = nil, accountName: String? = nil, accountType: String? = nil, accountStatus: String? = nil, user: User? = nil, projects: [Project]? = nil) {
        self.accountID = accountID
        self.accountUri = accountUri
        self.accountName = accountName
        self.accountType = accountType
        self.accountStatus = accountStatus
        self.user = user
        self.projects = projects
    }

    private enum CodingKeys: String, CodingKey {
        case accountID = "accountId"
        case accountUri
        case accountName
        case accountType
        case accountStatus
        case user
        case projects
    }
}

/// A download reference
public struct DownloadContainer: Codable {
    /// Download URI
    public var uri: String

    public init(uri: String) {
        self.uri = uri
    }
}

/// A websocket reference
public struct WebSocketContainer: Codable {
    /// WebSocket URL
    public var url: String

    public init(url: String) {
        self.url = url
    }
}

public struct XcodeArchiveProject: Codable {
    /// The Id of the target to archive
    public var archiveTargetID: String
    /// The project to archive container name
    public var projectName: String
    /// Full path of the target project
    public var projectPath: String?

    public init(archiveTargetID: String, projectName: String, projectPath: String? = nil) {
        self.archiveTargetID = archiveTargetID
        self.projectName = projectName
        self.projectPath = projectPath
    }

    private enum CodingKeys: String, CodingKey {
        case archiveTargetID = "archiveTargetId"
        case projectName
        case projectPath
    }
}

public struct XcodeScheme: Codable {
    /// Scheme name
    public var name: String
    /// Does scheme have a test action?
    public var hasTestAction: Bool
    /// Build configuration set in Archive action
    public var archiveConfiguration: String?
    public var archiveProject: ArchiveProject?

    public struct ArchiveProject: Codable {
        /// The Id of the target to archive
        public var archiveTargetID: String
        /// The project to archive container name
        public var projectName: String
        /// Full path of the target project
        public var projectPath: String?

        public init(archiveTargetID: String, projectName: String, projectPath: String? = nil) {
            self.archiveTargetID = archiveTargetID
            self.projectName = projectName
            self.projectPath = projectPath
        }

        private enum CodingKeys: String, CodingKey {
            case archiveTargetID = "archiveTargetId"
            case projectName
            case projectPath
        }
    }

    public init(name: String, hasTestAction: Bool, archiveConfiguration: String? = nil, archiveProject: ArchiveProject? = nil) {
        self.name = name
        self.hasTestAction = hasTestAction
        self.archiveConfiguration = archiveConfiguration
        self.archiveProject = archiveProject
    }
}

public struct XcodeToolset: Codable {
    /// The Xcode scheme containers
    public var xcodeSchemeContainers: [XcodeSchemeContainer]

    public struct XcodeSchemeContainer: Codable {
        /// Path to project
        public var path: String
        /// Project schemes
        public var sharedSchemes: [SharedScheme]
        /// Path to CocoaPods file, if present
        public var podfilePath: String?
        /// Path to Carthage file, if present
        public var cartfilePath: String?
        /// Repo object Id of the pbxproject
        public var xcodeProjectSha: String?
        /// Related projects paths for xcworkspace
        public var workspaceProjectPaths: String?
        /// Information regarding project app extensions, if present
        public var appExtensionTargets: [AppExtensionTarget]?

        public struct SharedScheme: Codable {
            /// Scheme name
            public var name: String
            /// Does scheme have a test action?
            public var hasTestAction: Bool
            /// Build configuration set in Archive action
            public var archiveConfiguration: String?
            public var archiveProject: ArchiveProject?

            public struct ArchiveProject: Codable {
                /// The Id of the target to archive
                public var archiveTargetID: String
                /// The project to archive container name
                public var projectName: String
                /// Full path of the target project
                public var projectPath: String?

                public init(archiveTargetID: String, projectName: String, projectPath: String? = nil) {
                    self.archiveTargetID = archiveTargetID
                    self.projectName = projectName
                    self.projectPath = projectPath
                }

                private enum CodingKeys: String, CodingKey {
                    case archiveTargetID = "archiveTargetId"
                    case projectName
                    case projectPath
                }
            }

            public init(name: String, hasTestAction: Bool, archiveConfiguration: String? = nil, archiveProject: ArchiveProject? = nil) {
                self.name = name
                self.hasTestAction = hasTestAction
                self.archiveConfiguration = archiveConfiguration
                self.archiveProject = archiveProject
            }
        }

        /// App extension information
        public struct AppExtensionTarget: Codable {
            /// App extension name
            public var name: String
            /// App extension bundle identifier
            public var targetBundleIdentifier: String

            public init(name: String, targetBundleIdentifier: String) {
                self.name = name
                self.targetBundleIdentifier = targetBundleIdentifier
            }
        }

        public init(path: String, sharedSchemes: [SharedScheme], podfilePath: String? = nil, cartfilePath: String? = nil, xcodeProjectSha: String? = nil, workspaceProjectPaths: String? = nil, appExtensionTargets: [AppExtensionTarget]? = nil) {
            self.path = path
            self.sharedSchemes = sharedSchemes
            self.podfilePath = podfilePath
            self.cartfilePath = cartfilePath
            self.xcodeProjectSha = xcodeProjectSha
            self.workspaceProjectPaths = workspaceProjectPaths
            self.appExtensionTargets = appExtensionTargets
        }
    }

    public init(xcodeSchemeContainers: [XcodeSchemeContainer]) {
        self.xcodeSchemeContainers = xcodeSchemeContainers
    }
}

public struct XcodeSchemeContainer: Codable {
    /// Path to project
    public var path: String
    /// Project schemes
    public var sharedSchemes: [SharedScheme]
    /// Path to CocoaPods file, if present
    public var podfilePath: String?
    /// Path to Carthage file, if present
    public var cartfilePath: String?
    /// Repo object Id of the pbxproject
    public var xcodeProjectSha: String?
    /// Related projects paths for xcworkspace
    public var workspaceProjectPaths: String?
    /// Information regarding project app extensions, if present
    public var appExtensionTargets: [AppExtensionTarget]?

    public struct SharedScheme: Codable {
        /// Scheme name
        public var name: String
        /// Does scheme have a test action?
        public var hasTestAction: Bool
        /// Build configuration set in Archive action
        public var archiveConfiguration: String?
        public var archiveProject: ArchiveProject?

        public struct ArchiveProject: Codable {
            /// The Id of the target to archive
            public var archiveTargetID: String
            /// The project to archive container name
            public var projectName: String
            /// Full path of the target project
            public var projectPath: String?

            public init(archiveTargetID: String, projectName: String, projectPath: String? = nil) {
                self.archiveTargetID = archiveTargetID
                self.projectName = projectName
                self.projectPath = projectPath
            }

            private enum CodingKeys: String, CodingKey {
                case archiveTargetID = "archiveTargetId"
                case projectName
                case projectPath
            }
        }

        public init(name: String, hasTestAction: Bool, archiveConfiguration: String? = nil, archiveProject: ArchiveProject? = nil) {
            self.name = name
            self.hasTestAction = hasTestAction
            self.archiveConfiguration = archiveConfiguration
            self.archiveProject = archiveProject
        }
    }

    /// App extension information
    public struct AppExtensionTarget: Codable {
        /// App extension name
        public var name: String
        /// App extension bundle identifier
        public var targetBundleIdentifier: String

        public init(name: String, targetBundleIdentifier: String) {
            self.name = name
            self.targetBundleIdentifier = targetBundleIdentifier
        }
    }

    public init(path: String, sharedSchemes: [SharedScheme], podfilePath: String? = nil, cartfilePath: String? = nil, xcodeProjectSha: String? = nil, workspaceProjectPaths: String? = nil, appExtensionTargets: [AppExtensionTarget]? = nil) {
        self.path = path
        self.sharedSchemes = sharedSchemes
        self.podfilePath = podfilePath
        self.cartfilePath = cartfilePath
        self.xcodeProjectSha = xcodeProjectSha
        self.workspaceProjectPaths = workspaceProjectPaths
        self.appExtensionTargets = appExtensionTargets
    }
}

public struct XamarinToolset: Codable {
    /// Xamarin solutions for the toolset
    public var xamarinSolutions: [XamarinSolution]

    public struct XamarinSolution: Codable {
        /// Path to solution
        public var path: String
        /// Solution configurations
        public var configurations: [String]
        /// Solution default configuration
        public var defaultConfiguration: String?

        public init(path: String, configurations: [String], defaultConfiguration: String? = nil) {
            self.path = path
            self.configurations = configurations
            self.defaultConfiguration = defaultConfiguration
        }
    }

    public init(xamarinSolutions: [XamarinSolution]) {
        self.xamarinSolutions = xamarinSolutions
    }
}

public struct XamarinSolution: Codable {
    /// Path to solution
    public var path: String
    /// Solution configurations
    public var configurations: [String]
    /// Solution default configuration
    public var defaultConfiguration: String?

    public init(path: String, configurations: [String], defaultConfiguration: String? = nil) {
        self.path = path
        self.configurations = configurations
        self.defaultConfiguration = defaultConfiguration
    }
}

public struct AndroidProject: Codable {
    /// Android Gradle modules
    public var androidModules: [AndroidModule]
    /// The path of the Gradle wrapper
    public var gradleWrapperPath: String?

    public struct AndroidModule: Codable {
        /// Name of the Android module
        public var name: String
        /// Module contains bundle settings
        public var hasBundle: Bool?
        /// The product flavors of the Android module
        public var productFlavors: [String]?
        /// The detected build variants of the Android module (matrix of product flavor + build type (debug|release))
        public var buildVariants: [String]?
        /// The detected build types of the Android module
        public var buildTypes: [String]?
        /// The detected build configurations of the Android module
        public var buildConfigurations: [BuildConfiguration]?
        /// Whether the module is at the root level of the project
        public var isRoot: Bool?

        public struct BuildConfiguration: Codable {
            /// Name of build configuration (the same as a build type name)
            public var name: String
            /// Android signing config. Null if not specified
            public var signingConfig: SigningConfig?

            /// Android signing config. Null if not specified
            public struct SigningConfig: Codable {
                /// Indicates if storeFile is specified in the signing configuration
                public var hasStoreFile: Bool?

                public init(hasStoreFile: Bool? = nil) {
                    self.hasStoreFile = hasStoreFile
                }
            }

            public init(name: String, signingConfig: SigningConfig? = nil) {
                self.name = name
                self.signingConfig = signingConfig
            }
        }

        public init(name: String, hasBundle: Bool? = nil, productFlavors: [String]? = nil, buildVariants: [String]? = nil, buildTypes: [String]? = nil, buildConfigurations: [BuildConfiguration]? = nil, isRoot: Bool? = nil) {
            self.name = name
            self.hasBundle = hasBundle
            self.productFlavors = productFlavors
            self.buildVariants = buildVariants
            self.buildTypes = buildTypes
            self.buildConfigurations = buildConfigurations
            self.isRoot = isRoot
        }
    }

    public init(androidModules: [AndroidModule], gradleWrapperPath: String? = nil) {
        self.androidModules = androidModules
        self.gradleWrapperPath = gradleWrapperPath
    }
}

public struct AndroidModule: Codable {
    /// Name of the Android module
    public var name: String
    /// Module contains bundle settings
    public var hasBundle: Bool?
    /// The product flavors of the Android module
    public var productFlavors: [String]?
    /// The detected build variants of the Android module (matrix of product flavor + build type (debug|release))
    public var buildVariants: [String]?
    /// The detected build types of the Android module
    public var buildTypes: [String]?
    /// The detected build configurations of the Android module
    public var buildConfigurations: [BuildConfiguration]?
    /// Whether the module is at the root level of the project
    public var isRoot: Bool?

    public struct BuildConfiguration: Codable {
        /// Name of build configuration (the same as a build type name)
        public var name: String
        /// Android signing config. Null if not specified
        public var signingConfig: SigningConfig?

        /// Android signing config. Null if not specified
        public struct SigningConfig: Codable {
            /// Indicates if storeFile is specified in the signing configuration
            public var hasStoreFile: Bool?

            public init(hasStoreFile: Bool? = nil) {
                self.hasStoreFile = hasStoreFile
            }
        }

        public init(name: String, signingConfig: SigningConfig? = nil) {
            self.name = name
            self.signingConfig = signingConfig
        }
    }

    public init(name: String, hasBundle: Bool? = nil, productFlavors: [String]? = nil, buildVariants: [String]? = nil, buildTypes: [String]? = nil, buildConfigurations: [BuildConfiguration]? = nil, isRoot: Bool? = nil) {
        self.name = name
        self.hasBundle = hasBundle
        self.productFlavors = productFlavors
        self.buildVariants = buildVariants
        self.buildTypes = buildTypes
        self.buildConfigurations = buildConfigurations
        self.isRoot = isRoot
    }
}

public struct BuildConfiguration: Codable {
    /// Name of build configuration (the same as a build type name)
    public var name: String
    /// Android signing config. Null if not specified
    public var signingConfig: SigningConfig?

    /// Android signing config. Null if not specified
    public struct SigningConfig: Codable {
        /// Indicates if storeFile is specified in the signing configuration
        public var hasStoreFile: Bool?

        public init(hasStoreFile: Bool? = nil) {
            self.hasStoreFile = hasStoreFile
        }
    }

    public init(name: String, signingConfig: SigningConfig? = nil) {
        self.name = name
        self.signingConfig = signingConfig
    }
}

public struct SigningConfig: Codable {
    /// Indicates if storeFile is specified in the signing configuration
    public var hasStoreFile: Bool?

    public init(hasStoreFile: Bool? = nil) {
        self.hasStoreFile = hasStoreFile
    }
}

public struct JavaScriptToolset: Codable {
    /// Paths for detected package.json files
    public var packageJSONPaths: [String]
    /// The React Native solutions detected
    public var javascriptSolutions: [JavascriptSolution]?

    public struct JavascriptSolution: Codable {
        /// The path to the detected package.json
        public var packageJSONPath: String
        /// Version of React Native from package.json files
        public var reactNativeVersion: String?

        public init(packageJSONPath: String, reactNativeVersion: String? = nil) {
            self.packageJSONPath = packageJSONPath
            self.reactNativeVersion = reactNativeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case packageJSONPath = "packageJsonPath"
            case reactNativeVersion
        }
    }

    public init(packageJSONPaths: [String], javascriptSolutions: [JavascriptSolution]? = nil) {
        self.packageJSONPaths = packageJSONPaths
        self.javascriptSolutions = javascriptSolutions
    }

    private enum CodingKeys: String, CodingKey {
        case packageJSONPaths = "packageJsonPaths"
        case javascriptSolutions
    }
}

public struct JavaScriptSolution: Codable {
    /// The path to the detected package.json
    public var packageJSONPath: String
    /// Version of React Native from package.json files
    public var reactNativeVersion: String?

    public init(packageJSONPath: String, reactNativeVersion: String? = nil) {
        self.packageJSONPath = packageJSONPath
        self.reactNativeVersion = reactNativeVersion
    }

    private enum CodingKeys: String, CodingKey {
        case packageJSONPath = "packageJsonPath"
        case reactNativeVersion
    }
}

public struct UWPToolset: Codable {
    /// The UWP solutions detected
    public var uwpSolutions: [UwpSolution]

    public struct UwpSolution: Codable {
        /// The path to the UWP solution
        public var path: String
        /// The possible configurations detected for the UWP solution
        public var configurations: [String]

        public init(path: String, configurations: [String]) {
            self.path = path
            self.configurations = configurations
        }
    }

    public init(uwpSolutions: [UwpSolution]) {
        self.uwpSolutions = uwpSolutions
    }
}

public struct UWPSolution: Codable {
    /// The path to the UWP solution
    public var path: String
    /// The possible configurations detected for the UWP solution
    public var configurations: [String]

    public init(path: String, configurations: [String]) {
        self.path = path
        self.configurations = configurations
    }
}

public struct TestCloudToolset: Codable {
    /// The TestCloud projects detected
    public var projects: [Project]

    public struct Project: Codable {
        /// The path to the TestCloud project
        public var path: String
        public var frameworkType: FrameworkType
        public var frameworkProperties: FrameworkProperties?

        public enum FrameworkType: String, Codable, CaseIterable {
            case appium = "Appium"
            case calabash = "Calabash"
            case espresso = "Espresso"
            case uITest = "UITest"
            case generated = "Generated"
        }

        public struct FrameworkProperties: Codable {
            public var configurations: [String]?

            public init(configurations: [String]? = nil) {
                self.configurations = configurations
            }
        }

        public init(path: String, frameworkType: FrameworkType, frameworkProperties: FrameworkProperties? = nil) {
            self.path = path
            self.frameworkType = frameworkType
            self.frameworkProperties = frameworkProperties
        }
    }

    public init(projects: [Project]) {
        self.projects = projects
    }
}

public struct TestCloudProject: Codable {
    /// The path to the TestCloud project
    public var path: String
    public var frameworkType: FrameworkType
    public var frameworkProperties: FrameworkProperties?

    public enum FrameworkType: String, Codable, CaseIterable {
        case appium = "Appium"
        case calabash = "Calabash"
        case espresso = "Espresso"
        case uITest = "UITest"
        case generated = "Generated"
    }

    public struct FrameworkProperties: Codable {
        public var configurations: [String]?

        public init(configurations: [String]? = nil) {
            self.configurations = configurations
        }
    }

    public init(path: String, frameworkType: FrameworkType, frameworkProperties: FrameworkProperties? = nil) {
        self.path = path
        self.frameworkType = frameworkType
        self.frameworkProperties = frameworkProperties
    }
}

public struct TestCloudProjectFrameworkProperties: Codable {
    public var configurations: [String]?

    public init(configurations: [String]? = nil) {
        self.configurations = configurations
    }
}

/// A collection of projects for each type of toolset
public struct ToolsetProjects: Codable {
    /// The commit hash of the analyzed commit
    public var commit: String?
    public var xcode: Xcode?
    public var javascript: Javascript?
    public var xamarin: Xamarin?
    public var android: Android?
    /// A collection of detected pre/post buildscripts for current platform toolset
    public var buildscripts: [String: AnyJSON]?
    public var uwp: Uwp?
    public var testcloud: Testcloud?

    public struct Xcode: Codable {
        /// The Xcode scheme containers
        public var xcodeSchemeContainers: [XcodeSchemeContainer]

        public struct XcodeSchemeContainer: Codable {
            /// Path to project
            public var path: String
            /// Project schemes
            public var sharedSchemes: [SharedScheme]
            /// Path to CocoaPods file, if present
            public var podfilePath: String?
            /// Path to Carthage file, if present
            public var cartfilePath: String?
            /// Repo object Id of the pbxproject
            public var xcodeProjectSha: String?
            /// Related projects paths for xcworkspace
            public var workspaceProjectPaths: String?
            /// Information regarding project app extensions, if present
            public var appExtensionTargets: [AppExtensionTarget]?

            public struct SharedScheme: Codable {
                /// Scheme name
                public var name: String
                /// Does scheme have a test action?
                public var hasTestAction: Bool
                /// Build configuration set in Archive action
                public var archiveConfiguration: String?
                public var archiveProject: ArchiveProject?

                public struct ArchiveProject: Codable {
                    /// The Id of the target to archive
                    public var archiveTargetID: String
                    /// The project to archive container name
                    public var projectName: String
                    /// Full path of the target project
                    public var projectPath: String?

                    public init(archiveTargetID: String, projectName: String, projectPath: String? = nil) {
                        self.archiveTargetID = archiveTargetID
                        self.projectName = projectName
                        self.projectPath = projectPath
                    }

                    private enum CodingKeys: String, CodingKey {
                        case archiveTargetID = "archiveTargetId"
                        case projectName
                        case projectPath
                    }
                }

                public init(name: String, hasTestAction: Bool, archiveConfiguration: String? = nil, archiveProject: ArchiveProject? = nil) {
                    self.name = name
                    self.hasTestAction = hasTestAction
                    self.archiveConfiguration = archiveConfiguration
                    self.archiveProject = archiveProject
                }
            }

            /// App extension information
            public struct AppExtensionTarget: Codable {
                /// App extension name
                public var name: String
                /// App extension bundle identifier
                public var targetBundleIdentifier: String

                public init(name: String, targetBundleIdentifier: String) {
                    self.name = name
                    self.targetBundleIdentifier = targetBundleIdentifier
                }
            }

            public init(path: String, sharedSchemes: [SharedScheme], podfilePath: String? = nil, cartfilePath: String? = nil, xcodeProjectSha: String? = nil, workspaceProjectPaths: String? = nil, appExtensionTargets: [AppExtensionTarget]? = nil) {
                self.path = path
                self.sharedSchemes = sharedSchemes
                self.podfilePath = podfilePath
                self.cartfilePath = cartfilePath
                self.xcodeProjectSha = xcodeProjectSha
                self.workspaceProjectPaths = workspaceProjectPaths
                self.appExtensionTargets = appExtensionTargets
            }
        }

        public init(xcodeSchemeContainers: [XcodeSchemeContainer]) {
            self.xcodeSchemeContainers = xcodeSchemeContainers
        }
    }

    public struct Javascript: Codable {
        /// Paths for detected package.json files
        public var packageJSONPaths: [String]
        /// The React Native solutions detected
        public var javascriptSolutions: [JavascriptSolution]?

        public struct JavascriptSolution: Codable {
            /// The path to the detected package.json
            public var packageJSONPath: String
            /// Version of React Native from package.json files
            public var reactNativeVersion: String?

            public init(packageJSONPath: String, reactNativeVersion: String? = nil) {
                self.packageJSONPath = packageJSONPath
                self.reactNativeVersion = reactNativeVersion
            }

            private enum CodingKeys: String, CodingKey {
                case packageJSONPath = "packageJsonPath"
                case reactNativeVersion
            }
        }

        public init(packageJSONPaths: [String], javascriptSolutions: [JavascriptSolution]? = nil) {
            self.packageJSONPaths = packageJSONPaths
            self.javascriptSolutions = javascriptSolutions
        }

        private enum CodingKeys: String, CodingKey {
            case packageJSONPaths = "packageJsonPaths"
            case javascriptSolutions
        }
    }

    public struct Xamarin: Codable {
        /// Xamarin solutions for the toolset
        public var xamarinSolutions: [XamarinSolution]

        public struct XamarinSolution: Codable {
            /// Path to solution
            public var path: String
            /// Solution configurations
            public var configurations: [String]
            /// Solution default configuration
            public var defaultConfiguration: String?

            public init(path: String, configurations: [String], defaultConfiguration: String? = nil) {
                self.path = path
                self.configurations = configurations
                self.defaultConfiguration = defaultConfiguration
            }
        }

        public init(xamarinSolutions: [XamarinSolution]) {
            self.xamarinSolutions = xamarinSolutions
        }
    }

    public struct Android: Codable {
        /// Android Gradle modules
        public var androidModules: [AndroidModule]
        /// The path of the Gradle wrapper
        public var gradleWrapperPath: String?

        public struct AndroidModule: Codable {
            /// Name of the Android module
            public var name: String
            /// Module contains bundle settings
            public var hasBundle: Bool?
            /// The product flavors of the Android module
            public var productFlavors: [String]?
            /// The detected build variants of the Android module (matrix of product flavor + build type (debug|release))
            public var buildVariants: [String]?
            /// The detected build types of the Android module
            public var buildTypes: [String]?
            /// The detected build configurations of the Android module
            public var buildConfigurations: [BuildConfiguration]?
            /// Whether the module is at the root level of the project
            public var isRoot: Bool?

            public struct BuildConfiguration: Codable {
                /// Name of build configuration (the same as a build type name)
                public var name: String
                /// Android signing config. Null if not specified
                public var signingConfig: SigningConfig?

                /// Android signing config. Null if not specified
                public struct SigningConfig: Codable {
                    /// Indicates if storeFile is specified in the signing configuration
                    public var hasStoreFile: Bool?

                    public init(hasStoreFile: Bool? = nil) {
                        self.hasStoreFile = hasStoreFile
                    }
                }

                public init(name: String, signingConfig: SigningConfig? = nil) {
                    self.name = name
                    self.signingConfig = signingConfig
                }
            }

            public init(name: String, hasBundle: Bool? = nil, productFlavors: [String]? = nil, buildVariants: [String]? = nil, buildTypes: [String]? = nil, buildConfigurations: [BuildConfiguration]? = nil, isRoot: Bool? = nil) {
                self.name = name
                self.hasBundle = hasBundle
                self.productFlavors = productFlavors
                self.buildVariants = buildVariants
                self.buildTypes = buildTypes
                self.buildConfigurations = buildConfigurations
                self.isRoot = isRoot
            }
        }

        public init(androidModules: [AndroidModule], gradleWrapperPath: String? = nil) {
            self.androidModules = androidModules
            self.gradleWrapperPath = gradleWrapperPath
        }
    }

    public struct Uwp: Codable {
        /// The UWP solutions detected
        public var uwpSolutions: [UwpSolution]

        public struct UwpSolution: Codable {
            /// The path to the UWP solution
            public var path: String
            /// The possible configurations detected for the UWP solution
            public var configurations: [String]

            public init(path: String, configurations: [String]) {
                self.path = path
                self.configurations = configurations
            }
        }

        public init(uwpSolutions: [UwpSolution]) {
            self.uwpSolutions = uwpSolutions
        }
    }

    public struct Testcloud: Codable {
        /// The TestCloud projects detected
        public var projects: [Project]

        public struct Project: Codable {
            /// The path to the TestCloud project
            public var path: String
            public var frameworkType: FrameworkType
            public var frameworkProperties: FrameworkProperties?

            public enum FrameworkType: String, Codable, CaseIterable {
                case appium = "Appium"
                case calabash = "Calabash"
                case espresso = "Espresso"
                case uITest = "UITest"
                case generated = "Generated"
            }

            public struct FrameworkProperties: Codable {
                public var configurations: [String]?

                public init(configurations: [String]? = nil) {
                    self.configurations = configurations
                }
            }

            public init(path: String, frameworkType: FrameworkType, frameworkProperties: FrameworkProperties? = nil) {
                self.path = path
                self.frameworkType = frameworkType
                self.frameworkProperties = frameworkProperties
            }
        }

        public init(projects: [Project]) {
            self.projects = projects
        }
    }

    public init(commit: String? = nil, xcode: Xcode? = nil, javascript: Javascript? = nil, xamarin: Xamarin? = nil, android: Android? = nil, buildscripts: [String: AnyJSON]? = nil, uwp: Uwp? = nil, testcloud: Testcloud? = nil) {
        self.commit = commit
        self.xcode = xcode
        self.javascript = javascript
        self.xamarin = xamarin
        self.android = android
        self.buildscripts = buildscripts
        self.uwp = uwp
        self.testcloud = testcloud
    }
}

/// Abstract platform project
public struct BuildScript: Codable {
    public var name: String?
    public var path: String?

    public init(name: String? = nil, path: String? = nil) {
        self.name = name
        self.path = path
    }
}

/// Abstract platform project
public struct ToolsetProject: Codable {
    public var name: String?
    public var path: String?

    public init(name: String? = nil, path: String? = nil) {
        self.name = name
        self.path = path
    }
}

/// The branch build core properties
public struct BranchStatusCollectionItemItem: Codable {
    public var branch: Branch?
    public var isEnabled: Bool?

    public struct Branch: Codable {
        /// The branch name
        public var name: String
        public var commit: Commit

        public struct Commit: Codable {
            /// The commit SHA
            public var sha: String?
            /// The URL to the commit
            public var url: String?

            public init(sha: String? = nil, url: String? = nil) {
                self.sha = sha
                self.url = url
            }
        }

        public init(name: String, commit: Commit) {
            self.name = name
            self.commit = commit
        }
    }

    public init(branch: Branch? = nil, isEnabled: Bool? = nil) {
        self.branch = branch
        self.isEnabled = isEnabled
    }

    private enum CodingKeys: String, CodingKey {
        case branch
        case isEnabled = "enabled"
    }
}

/// The branch build core properties
public struct BranchStatusItem: Codable {
    public var branch: Branch?
    public var isEnabled: Bool?

    public struct Branch: Codable {
        /// The branch name
        public var name: String
        public var commit: Commit

        public struct Commit: Codable {
            /// The commit SHA
            public var sha: String?
            /// The URL to the commit
            public var url: String?

            public init(sha: String? = nil, url: String? = nil) {
                self.sha = sha
                self.url = url
            }
        }

        public init(name: String, commit: Commit) {
            self.name = name
            self.commit = commit
        }
    }

    public init(branch: Branch? = nil, isEnabled: Bool? = nil) {
        self.branch = branch
        self.isEnabled = isEnabled
    }

    private enum CodingKeys: String, CodingKey {
        case branch
        case isEnabled = "enabled"
    }
}

/// The branch build core properties
public struct BranchProperties: Codable {
    public var branch: Branch?
    public var isEnabled: Bool?

    public struct Branch: Codable {
        /// The branch name
        public var name: String
        public var commit: Commit

        public struct Commit: Codable {
            /// The commit SHA
            public var sha: String?
            /// The URL to the commit
            public var url: String?

            public init(sha: String? = nil, url: String? = nil) {
                self.sha = sha
                self.url = url
            }
        }

        public init(name: String, commit: Commit) {
            self.name = name
            self.commit = commit
        }
    }

    public init(branch: Branch? = nil, isEnabled: Bool? = nil) {
        self.branch = branch
        self.isEnabled = isEnabled
    }

    private enum CodingKeys: String, CodingKey {
        case branch
        case isEnabled = "enabled"
    }
}

/// The branch build core properties
public struct BranchConfigurationItem: Codable {
    public var branch: Branch?
    public var isEnabled: Bool?

    public struct Branch: Codable {
        /// The branch name
        public var name: String
        public var commit: Commit

        public struct Commit: Codable {
            /// The commit SHA
            public var sha: String?
            /// The URL to the commit
            public var url: String?

            public init(sha: String? = nil, url: String? = nil) {
                self.sha = sha
                self.url = url
            }
        }

        public init(name: String, commit: Commit) {
            self.name = name
            self.commit = commit
        }
    }

    public init(branch: Branch? = nil, isEnabled: Bool? = nil) {
        self.branch = branch
        self.isEnabled = isEnabled
    }

    private enum CodingKeys: String, CodingKey {
        case branch
        case isEnabled = "enabled"
    }
}

/// Branch configuration revision
public struct BranchConfigurationRevisionsItem: Codable {
    public var id: String?
    public var revision: Double?
    public var changedDate: String?
    public var name: String?
    public var changeType: String?
    public var definitionURL: String?
    /// User who made a change in branch configuration
    public var changedBy: ChangedBy?

    /// User who made a change in branch configuration
    public struct ChangedBy: Codable {
        public var displayName: String?
        public var url: String?

        public init(displayName: String? = nil, url: String? = nil) {
            self.displayName = displayName
            self.url = url
        }
    }

    public init(id: String? = nil, revision: Double? = nil, changedDate: String? = nil, name: String? = nil, changeType: String? = nil, definitionURL: String? = nil, changedBy: ChangedBy? = nil) {
        self.id = id
        self.revision = revision
        self.changedDate = changedDate
        self.name = name
        self.changeType = changeType
        self.definitionURL = definitionURL
        self.changedBy = changedBy
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case revision
        case changedDate
        case name
        case changeType
        case definitionURL = "definitionUrl"
        case changedBy
    }
}

/// Branch configuration revision
public struct BranchConfigurationRevision: Codable {
    public var id: String?
    public var revision: Double?
    public var changedDate: String?
    public var name: String?
    public var changeType: String?
    public var definitionURL: String?
    /// User who made a change in branch configuration
    public var changedBy: ChangedBy?

    /// User who made a change in branch configuration
    public struct ChangedBy: Codable {
        public var displayName: String?
        public var url: String?

        public init(displayName: String? = nil, url: String? = nil) {
            self.displayName = displayName
            self.url = url
        }
    }

    public init(id: String? = nil, revision: Double? = nil, changedDate: String? = nil, name: String? = nil, changeType: String? = nil, definitionURL: String? = nil, changedBy: ChangedBy? = nil) {
        self.id = id
        self.revision = revision
        self.changedDate = changedDate
        self.name = name
        self.changeType = changeType
        self.definitionURL = definitionURL
        self.changedBy = changedBy
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case revision
        case changedDate
        case name
        case changeType
        case definitionURL = "definitionUrl"
        case changedBy
    }
}

/// User who made a change in branch configuration
public struct BranchConfigurationRevisionAuthor: Codable {
    public var displayName: String?
    public var url: String?

    public init(displayName: String? = nil, url: String? = nil) {
        self.displayName = displayName
        self.url = url
    }
}

public struct BranchConfigurationWithID: Codable {
    public var trigger: Trigger?
    public var isTestsEnabled: Bool?
    public var badgeIsEnabled: Bool?
    public var isSigned: Bool?
    /// A configured branch name to clone from. If provided, all other parameters will be ignored. Only supported in POST requests.
    public var cloneFromBranch: String?
    /// The branch build configuration for each toolset
    public var toolsets: Toolsets?
    /// The versioning configuration for artifacts built for this branch
    public var artifactVersioning: ArtifactVersioning?
    public var id: Int

    public enum Trigger: String, Codable, CaseIterable {
        case continous
        case continuous
        case manual
    }

    /// The branch build configuration for each toolset
    public struct Toolsets: Codable {
        /// Build configuration when Xcode is part of the build steps
        public var xcode: Xcode?
        /// Build configuration when React Native, or other JavaScript tech, is part of the build steps
        public var javascript: Javascript?
        /// Build configuration for Xamarin projects
        public var xamarin: Xamarin?
        /// Build configuration for Android projects
        public var android: Android?

        /// Build configuration when Xcode is part of the build steps
        public struct Xcode: Codable {
            /// Xcode project/workspace path
            public var projectOrWorkspacePath: String?
            /// Path to CococaPods file, if present
            public var podfilePath: String?
            /// Path to Carthage file, if present
            public var cartfilePath: String?
            public var provisioningProfileEncoded: String?
            public var certificateEncoded: String?
            public var provisioningProfileFileID: String?
            public var certificateFileID: String?
            public var provisioningProfileUploadID: String?
            public var appExtensionProvisioningProfileFiles: [AppExtensionProvisioningProfileFile]?
            public var certificateUploadID: String?
            public var certificatePassword: String?
            public var scheme: String?
            /// Xcode version used to build. Available versions can be found in "/xcode_versions" API. Default is latest stable version, at the time when the configuration is set.
            public var xcodeVersion: String?
            public var provisioningProfileFilename: String?
            public var certificateFilename: String?
            public var teamID: String?
            public var isAutomaticSigning: Bool?
            /// The selected pbxproject hash to the repositroy
            public var xcodeProjectSha: String?
            /// The build configuration of the target to archive
            public var archiveConfiguration: String?
            /// The target id of the selected scheme to archive
            public var targetToArchive: String?
            /// Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting from workspace settings is used.
            /// By default new build system is used if workspace setting is not committed to the repository. Only used for iOS React Native app, with Xcode 10.
            public var isForceLegacyBuildSystem: Bool?

            /// Provisioning profile fetch and store information
            public struct AppExtensionProvisioningProfileFile: Codable {
                /// Name of uploaded provisioning profile
                public var fileName: String?
                /// File id from secure file storage
                public var fileID: String?
                /// Upload id to App Center File Upload Store
                public var uploadID: String?
                /// Target the provisioning profile is used to sign
                public var targetBundleIdentifier: String?

                public init(fileName: String? = nil, fileID: String? = nil, uploadID: String? = nil, targetBundleIdentifier: String? = nil) {
                    self.fileName = fileName
                    self.fileID = fileID
                    self.uploadID = uploadID
                    self.targetBundleIdentifier = targetBundleIdentifier
                }

                private enum CodingKeys: String, CodingKey {
                    case fileName
                    case fileID = "fileId"
                    case uploadID = "uploadId"
                    case targetBundleIdentifier
                }
            }

            public init(projectOrWorkspacePath: String? = nil, podfilePath: String? = nil, cartfilePath: String? = nil, provisioningProfileEncoded: String? = nil, certificateEncoded: String? = nil, provisioningProfileFileID: String? = nil, certificateFileID: String? = nil, provisioningProfileUploadID: String? = nil, appExtensionProvisioningProfileFiles: [AppExtensionProvisioningProfileFile]? = nil, certificateUploadID: String? = nil, certificatePassword: String? = nil, scheme: String? = nil, xcodeVersion: String? = nil, provisioningProfileFilename: String? = nil, certificateFilename: String? = nil, teamID: String? = nil, isAutomaticSigning: Bool? = nil, xcodeProjectSha: String? = nil, archiveConfiguration: String? = nil, targetToArchive: String? = nil, isForceLegacyBuildSystem: Bool? = nil) {
                self.projectOrWorkspacePath = projectOrWorkspacePath
                self.podfilePath = podfilePath
                self.cartfilePath = cartfilePath
                self.provisioningProfileEncoded = provisioningProfileEncoded
                self.certificateEncoded = certificateEncoded
                self.provisioningProfileFileID = provisioningProfileFileID
                self.certificateFileID = certificateFileID
                self.provisioningProfileUploadID = provisioningProfileUploadID
                self.appExtensionProvisioningProfileFiles = appExtensionProvisioningProfileFiles
                self.certificateUploadID = certificateUploadID
                self.certificatePassword = certificatePassword
                self.scheme = scheme
                self.xcodeVersion = xcodeVersion
                self.provisioningProfileFilename = provisioningProfileFilename
                self.certificateFilename = certificateFilename
                self.teamID = teamID
                self.isAutomaticSigning = isAutomaticSigning
                self.xcodeProjectSha = xcodeProjectSha
                self.archiveConfiguration = archiveConfiguration
                self.targetToArchive = targetToArchive
                self.isForceLegacyBuildSystem = isForceLegacyBuildSystem
            }

            private enum CodingKeys: String, CodingKey {
                case projectOrWorkspacePath
                case podfilePath
                case cartfilePath
                case provisioningProfileEncoded
                case certificateEncoded
                case provisioningProfileFileID = "provisioningProfileFileId"
                case certificateFileID = "certificateFileId"
                case provisioningProfileUploadID = "provisioningProfileUploadId"
                case appExtensionProvisioningProfileFiles
                case certificateUploadID = "certificateUploadId"
                case certificatePassword
                case scheme
                case xcodeVersion
                case provisioningProfileFilename
                case certificateFilename
                case teamID = "teamId"
                case isAutomaticSigning = "automaticSigning"
                case xcodeProjectSha
                case archiveConfiguration
                case targetToArchive
                case isForceLegacyBuildSystem = "forceLegacyBuildSystem"
            }
        }

        /// Build configuration when React Native, or other JavaScript tech, is part of the build steps
        public struct Javascript: Codable {
            /// Path to package.json file for the main project, e.g. "package.json" or "myapp/package.json"
            public var packageJSONPath: String?
            /// Whether to run Jest unit tests, via npm test, during the build
            public var isRunTests: Bool?
            /// Version of React Native from package.json files
            public var reactNativeVersion: String?

            public init(packageJSONPath: String? = nil, isRunTests: Bool? = nil, reactNativeVersion: String? = nil) {
                self.packageJSONPath = packageJSONPath
                self.isRunTests = isRunTests
                self.reactNativeVersion = reactNativeVersion
            }

            private enum CodingKeys: String, CodingKey {
                case packageJSONPath = "packageJsonPath"
                case isRunTests = "runTests"
                case reactNativeVersion
            }
        }

        /// Build configuration for Xamarin projects
        public struct Xamarin: Codable {
            public var slnPath: String?
            public var isSimBuild: Bool?
            public var args: String?
            public var configuration: String?
            public var p12File: String?
            public var p12Pwd: String?
            public var provProfile: String?
            public var monoVersion: String?
            public var sdkBundle: String?
            /// Symlink of the SDK Bundle and Mono installation.
            /// The build will use the associated Mono bundled with related Xamarin SDK. If both symlink and monoVersion or sdkBundle are passed, the symlink is taking precedence. If non-existing symlink is passed, the current stable Mono version will be configured for building.
            public var symlink: String?

            public init(slnPath: String? = nil, isSimBuild: Bool? = nil, args: String? = nil, configuration: String? = nil, p12File: String? = nil, p12Pwd: String? = nil, provProfile: String? = nil, monoVersion: String? = nil, sdkBundle: String? = nil, symlink: String? = nil) {
                self.slnPath = slnPath
                self.isSimBuild = isSimBuild
                self.args = args
                self.configuration = configuration
                self.p12File = p12File
                self.p12Pwd = p12Pwd
                self.provProfile = provProfile
                self.monoVersion = monoVersion
                self.sdkBundle = sdkBundle
                self.symlink = symlink
            }
        }

        /// Build configuration for Android projects
        public struct Android: Codable {
            /// Path to the Gradle wrapper script
            ///
            /// Example: "android/gradlew"
            public var gradleWrapperPath: String?
            /// The Gradle module to build
            ///
            /// Example: "app"
            public var module: String?
            /// The Android build variant to build
            ///
            /// Example: "release"
            public var buildVariant: String?
            /// Whether to run unit tests during the build (default)
            public var isRunTests: Bool
            /// Whether to run lint checks during the build (default)
            public var isRunLint: Bool?
            /// Whether it is the root module or not
            public var isRoot: Bool?
            /// Whether to apply automatic signing or not
            public var isAutomaticSigning: Bool?
            /// The password of the keystore
            public var keystorePassword: String?
            /// The key alias
            public var keyAlias: String?
            /// The key password
            public var keyPassword: String?
            /// The name of the keystore file
            public var keystoreFilename: String?
            /// The keystore encoded value
            public var keystoreEncoded: String?

            public init(gradleWrapperPath: String? = nil, module: String? = nil, buildVariant: String? = nil, isRunTests: Bool? = nil, isRunLint: Bool? = nil, isRoot: Bool? = nil, isAutomaticSigning: Bool? = nil, keystorePassword: String? = nil, keyAlias: String? = nil, keyPassword: String? = nil, keystoreFilename: String? = nil, keystoreEncoded: String? = nil) {
                self.gradleWrapperPath = gradleWrapperPath
                self.module = module
                self.buildVariant = buildVariant
                self.isRunTests = isRunTests ?? true
                self.isRunLint = isRunLint
                self.isRoot = isRoot
                self.isAutomaticSigning = isAutomaticSigning
                self.keystorePassword = keystorePassword
                self.keyAlias = keyAlias
                self.keyPassword = keyPassword
                self.keystoreFilename = keystoreFilename
                self.keystoreEncoded = keystoreEncoded
            }

            private enum CodingKeys: String, CodingKey {
                case gradleWrapperPath
                case module
                case buildVariant
                case isRunTests = "runTests"
                case isRunLint = "runLint"
                case isRoot
                case isAutomaticSigning = "automaticSigning"
                case keystorePassword
                case keyAlias
                case keyPassword
                case keystoreFilename
                case keystoreEncoded
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: CodingKeys.self)
                self.gradleWrapperPath = try values.decodeIfPresent(String.self, forKey: .gradleWrapperPath)
                self.module = try values.decodeIfPresent(String.self, forKey: .module)
                self.buildVariant = try values.decodeIfPresent(String.self, forKey: .buildVariant)
                self.isRunTests = try values.decodeIfPresent(Bool.self, forKey: .isRunTests) ?? true
                self.isRunLint = try values.decodeIfPresent(Bool.self, forKey: .isRunLint)
                self.isRoot = try values.decodeIfPresent(Bool.self, forKey: .isRoot)
                self.isAutomaticSigning = try values.decodeIfPresent(Bool.self, forKey: .isAutomaticSigning)
                self.keystorePassword = try values.decodeIfPresent(String.self, forKey: .keystorePassword)
                self.keyAlias = try values.decodeIfPresent(String.self, forKey: .keyAlias)
                self.keyPassword = try values.decodeIfPresent(String.self, forKey: .keyPassword)
                self.keystoreFilename = try values.decodeIfPresent(String.self, forKey: .keystoreFilename)
                self.keystoreEncoded = try values.decodeIfPresent(String.self, forKey: .keystoreEncoded)
            }
        }

        public init(xcode: Xcode? = nil, javascript: Javascript? = nil, xamarin: Xamarin? = nil, android: Android? = nil) {
            self.xcode = xcode
            self.javascript = javascript
            self.xamarin = xamarin
            self.android = android
        }
    }

    /// The versioning configuration for artifacts built for this branch
    public struct ArtifactVersioning: Codable {
        public var buildNumberFormat: BuildNumberFormat?

        public enum BuildNumberFormat: String, Codable, CaseIterable {
            case buildID = "buildId"
            case timestamp
        }

        public init(buildNumberFormat: BuildNumberFormat? = nil) {
            self.buildNumberFormat = buildNumberFormat
        }
    }

    public init(trigger: Trigger? = nil, isTestsEnabled: Bool? = nil, badgeIsEnabled: Bool? = nil, isSigned: Bool? = nil, cloneFromBranch: String? = nil, toolsets: Toolsets? = nil, artifactVersioning: ArtifactVersioning? = nil, id: Int) {
        self.trigger = trigger
        self.isTestsEnabled = isTestsEnabled
        self.badgeIsEnabled = badgeIsEnabled
        self.isSigned = isSigned
        self.cloneFromBranch = cloneFromBranch
        self.toolsets = toolsets
        self.artifactVersioning = artifactVersioning
        self.id = id
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.trigger = try Trigger(from: decoder)
        self.isTestsEnabled = try values.decodeIfPresent(Bool.self, forKey: "testsEnabled")
        self.badgeIsEnabled = try values.decodeIfPresent(Bool.self, forKey: "badgeIsEnabled")
        self.isSigned = try values.decodeIfPresent(Bool.self, forKey: "signed")
        self.cloneFromBranch = try values.decodeIfPresent(String.self, forKey: "cloneFromBranch")
        self.toolsets = try Toolsets(from: decoder)
        self.artifactVersioning = try ArtifactVersioning(from: decoder)
        self.id = try values.decode(Int.self, forKey: "id")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(trigger, forKey: "trigger")
        try values.encodeIfPresent(isTestsEnabled, forKey: "testsEnabled")
        try values.encodeIfPresent(badgeIsEnabled, forKey: "badgeIsEnabled")
        try values.encodeIfPresent(isSigned, forKey: "signed")
        try values.encodeIfPresent(cloneFromBranch, forKey: "cloneFromBranch")
        try values.encodeIfPresent(toolsets, forKey: "toolsets")
        try values.encodeIfPresent(artifactVersioning, forKey: "artifactVersioning")
        try values.encode(id, forKey: "id")
    }
}

/// The branch build configuration for each toolset
public struct BranchConfigurationToolsets: Codable {
    /// Build configuration when Xcode is part of the build steps
    public var xcode: Xcode?
    /// Build configuration when React Native, or other JavaScript tech, is part of the build steps
    public var javascript: Javascript?
    /// Build configuration for Xamarin projects
    public var xamarin: Xamarin?
    /// Build configuration for Android projects
    public var android: Android?

    /// Build configuration when Xcode is part of the build steps
    public struct Xcode: Codable {
        /// Xcode project/workspace path
        public var projectOrWorkspacePath: String?
        /// Path to CococaPods file, if present
        public var podfilePath: String?
        /// Path to Carthage file, if present
        public var cartfilePath: String?
        public var provisioningProfileEncoded: String?
        public var certificateEncoded: String?
        public var provisioningProfileFileID: String?
        public var certificateFileID: String?
        public var provisioningProfileUploadID: String?
        public var appExtensionProvisioningProfileFiles: [AppExtensionProvisioningProfileFile]?
        public var certificateUploadID: String?
        public var certificatePassword: String?
        public var scheme: String?
        /// Xcode version used to build. Available versions can be found in "/xcode_versions" API. Default is latest stable version, at the time when the configuration is set.
        public var xcodeVersion: String?
        public var provisioningProfileFilename: String?
        public var certificateFilename: String?
        public var teamID: String?
        public var isAutomaticSigning: Bool?
        /// The selected pbxproject hash to the repositroy
        public var xcodeProjectSha: String?
        /// The build configuration of the target to archive
        public var archiveConfiguration: String?
        /// The target id of the selected scheme to archive
        public var targetToArchive: String?
        /// Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting from workspace settings is used.
        /// By default new build system is used if workspace setting is not committed to the repository. Only used for iOS React Native app, with Xcode 10.
        public var isForceLegacyBuildSystem: Bool?

        /// Provisioning profile fetch and store information
        public struct AppExtensionProvisioningProfileFile: Codable {
            /// Name of uploaded provisioning profile
            public var fileName: String?
            /// File id from secure file storage
            public var fileID: String?
            /// Upload id to App Center File Upload Store
            public var uploadID: String?
            /// Target the provisioning profile is used to sign
            public var targetBundleIdentifier: String?

            public init(fileName: String? = nil, fileID: String? = nil, uploadID: String? = nil, targetBundleIdentifier: String? = nil) {
                self.fileName = fileName
                self.fileID = fileID
                self.uploadID = uploadID
                self.targetBundleIdentifier = targetBundleIdentifier
            }

            private enum CodingKeys: String, CodingKey {
                case fileName
                case fileID = "fileId"
                case uploadID = "uploadId"
                case targetBundleIdentifier
            }
        }

        public init(projectOrWorkspacePath: String? = nil, podfilePath: String? = nil, cartfilePath: String? = nil, provisioningProfileEncoded: String? = nil, certificateEncoded: String? = nil, provisioningProfileFileID: String? = nil, certificateFileID: String? = nil, provisioningProfileUploadID: String? = nil, appExtensionProvisioningProfileFiles: [AppExtensionProvisioningProfileFile]? = nil, certificateUploadID: String? = nil, certificatePassword: String? = nil, scheme: String? = nil, xcodeVersion: String? = nil, provisioningProfileFilename: String? = nil, certificateFilename: String? = nil, teamID: String? = nil, isAutomaticSigning: Bool? = nil, xcodeProjectSha: String? = nil, archiveConfiguration: String? = nil, targetToArchive: String? = nil, isForceLegacyBuildSystem: Bool? = nil) {
            self.projectOrWorkspacePath = projectOrWorkspacePath
            self.podfilePath = podfilePath
            self.cartfilePath = cartfilePath
            self.provisioningProfileEncoded = provisioningProfileEncoded
            self.certificateEncoded = certificateEncoded
            self.provisioningProfileFileID = provisioningProfileFileID
            self.certificateFileID = certificateFileID
            self.provisioningProfileUploadID = provisioningProfileUploadID
            self.appExtensionProvisioningProfileFiles = appExtensionProvisioningProfileFiles
            self.certificateUploadID = certificateUploadID
            self.certificatePassword = certificatePassword
            self.scheme = scheme
            self.xcodeVersion = xcodeVersion
            self.provisioningProfileFilename = provisioningProfileFilename
            self.certificateFilename = certificateFilename
            self.teamID = teamID
            self.isAutomaticSigning = isAutomaticSigning
            self.xcodeProjectSha = xcodeProjectSha
            self.archiveConfiguration = archiveConfiguration
            self.targetToArchive = targetToArchive
            self.isForceLegacyBuildSystem = isForceLegacyBuildSystem
        }

        private enum CodingKeys: String, CodingKey {
            case projectOrWorkspacePath
            case podfilePath
            case cartfilePath
            case provisioningProfileEncoded
            case certificateEncoded
            case provisioningProfileFileID = "provisioningProfileFileId"
            case certificateFileID = "certificateFileId"
            case provisioningProfileUploadID = "provisioningProfileUploadId"
            case appExtensionProvisioningProfileFiles
            case certificateUploadID = "certificateUploadId"
            case certificatePassword
            case scheme
            case xcodeVersion
            case provisioningProfileFilename
            case certificateFilename
            case teamID = "teamId"
            case isAutomaticSigning = "automaticSigning"
            case xcodeProjectSha
            case archiveConfiguration
            case targetToArchive
            case isForceLegacyBuildSystem = "forceLegacyBuildSystem"
        }
    }

    /// Build configuration when React Native, or other JavaScript tech, is part of the build steps
    public struct Javascript: Codable {
        /// Path to package.json file for the main project, e.g. "package.json" or "myapp/package.json"
        public var packageJSONPath: String?
        /// Whether to run Jest unit tests, via npm test, during the build
        public var isRunTests: Bool?
        /// Version of React Native from package.json files
        public var reactNativeVersion: String?

        public init(packageJSONPath: String? = nil, isRunTests: Bool? = nil, reactNativeVersion: String? = nil) {
            self.packageJSONPath = packageJSONPath
            self.isRunTests = isRunTests
            self.reactNativeVersion = reactNativeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case packageJSONPath = "packageJsonPath"
            case isRunTests = "runTests"
            case reactNativeVersion
        }
    }

    /// Build configuration for Xamarin projects
    public struct Xamarin: Codable {
        public var slnPath: String?
        public var isSimBuild: Bool?
        public var args: String?
        public var configuration: String?
        public var p12File: String?
        public var p12Pwd: String?
        public var provProfile: String?
        public var monoVersion: String?
        public var sdkBundle: String?
        /// Symlink of the SDK Bundle and Mono installation.
        /// The build will use the associated Mono bundled with related Xamarin SDK. If both symlink and monoVersion or sdkBundle are passed, the symlink is taking precedence. If non-existing symlink is passed, the current stable Mono version will be configured for building.
        public var symlink: String?

        public init(slnPath: String? = nil, isSimBuild: Bool? = nil, args: String? = nil, configuration: String? = nil, p12File: String? = nil, p12Pwd: String? = nil, provProfile: String? = nil, monoVersion: String? = nil, sdkBundle: String? = nil, symlink: String? = nil) {
            self.slnPath = slnPath
            self.isSimBuild = isSimBuild
            self.args = args
            self.configuration = configuration
            self.p12File = p12File
            self.p12Pwd = p12Pwd
            self.provProfile = provProfile
            self.monoVersion = monoVersion
            self.sdkBundle = sdkBundle
            self.symlink = symlink
        }
    }

    /// Build configuration for Android projects
    public struct Android: Codable {
        /// Path to the Gradle wrapper script
        ///
        /// Example: "android/gradlew"
        public var gradleWrapperPath: String?
        /// The Gradle module to build
        ///
        /// Example: "app"
        public var module: String?
        /// The Android build variant to build
        ///
        /// Example: "release"
        public var buildVariant: String?
        /// Whether to run unit tests during the build (default)
        public var isRunTests: Bool
        /// Whether to run lint checks during the build (default)
        public var isRunLint: Bool?
        /// Whether it is the root module or not
        public var isRoot: Bool?
        /// Whether to apply automatic signing or not
        public var isAutomaticSigning: Bool?
        /// The password of the keystore
        public var keystorePassword: String?
        /// The key alias
        public var keyAlias: String?
        /// The key password
        public var keyPassword: String?
        /// The name of the keystore file
        public var keystoreFilename: String?
        /// The keystore encoded value
        public var keystoreEncoded: String?

        public init(gradleWrapperPath: String? = nil, module: String? = nil, buildVariant: String? = nil, isRunTests: Bool? = nil, isRunLint: Bool? = nil, isRoot: Bool? = nil, isAutomaticSigning: Bool? = nil, keystorePassword: String? = nil, keyAlias: String? = nil, keyPassword: String? = nil, keystoreFilename: String? = nil, keystoreEncoded: String? = nil) {
            self.gradleWrapperPath = gradleWrapperPath
            self.module = module
            self.buildVariant = buildVariant
            self.isRunTests = isRunTests ?? true
            self.isRunLint = isRunLint
            self.isRoot = isRoot
            self.isAutomaticSigning = isAutomaticSigning
            self.keystorePassword = keystorePassword
            self.keyAlias = keyAlias
            self.keyPassword = keyPassword
            self.keystoreFilename = keystoreFilename
            self.keystoreEncoded = keystoreEncoded
        }

        private enum CodingKeys: String, CodingKey {
            case gradleWrapperPath
            case module
            case buildVariant
            case isRunTests = "runTests"
            case isRunLint = "runLint"
            case isRoot
            case isAutomaticSigning = "automaticSigning"
            case keystorePassword
            case keyAlias
            case keyPassword
            case keystoreFilename
            case keystoreEncoded
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.gradleWrapperPath = try values.decodeIfPresent(String.self, forKey: .gradleWrapperPath)
            self.module = try values.decodeIfPresent(String.self, forKey: .module)
            self.buildVariant = try values.decodeIfPresent(String.self, forKey: .buildVariant)
            self.isRunTests = try values.decodeIfPresent(Bool.self, forKey: .isRunTests) ?? true
            self.isRunLint = try values.decodeIfPresent(Bool.self, forKey: .isRunLint)
            self.isRoot = try values.decodeIfPresent(Bool.self, forKey: .isRoot)
            self.isAutomaticSigning = try values.decodeIfPresent(Bool.self, forKey: .isAutomaticSigning)
            self.keystorePassword = try values.decodeIfPresent(String.self, forKey: .keystorePassword)
            self.keyAlias = try values.decodeIfPresent(String.self, forKey: .keyAlias)
            self.keyPassword = try values.decodeIfPresent(String.self, forKey: .keyPassword)
            self.keystoreFilename = try values.decodeIfPresent(String.self, forKey: .keystoreFilename)
            self.keystoreEncoded = try values.decodeIfPresent(String.self, forKey: .keystoreEncoded)
        }
    }

    public init(xcode: Xcode? = nil, javascript: Javascript? = nil, xamarin: Xamarin? = nil, android: Android? = nil) {
        self.xcode = xcode
        self.javascript = javascript
        self.xamarin = xamarin
        self.android = android
    }
}

/// The versioning configuration for artifacts built for this branch
public struct BranchConfigurationArtifactVersioning: Codable {
    public var buildNumberFormat: BuildNumberFormat?

    public enum BuildNumberFormat: String, Codable, CaseIterable {
        case buildID = "buildId"
        case timestamp
    }

    public init(buildNumberFormat: BuildNumberFormat? = nil) {
        self.buildNumberFormat = buildNumberFormat
    }
}

/// Build configuration when Xcode is part of the build steps
public struct XcodeBranchConfigurationProperties: Codable {
    /// Xcode project/workspace path
    public var projectOrWorkspacePath: String?
    /// Path to CococaPods file, if present
    public var podfilePath: String?
    /// Path to Carthage file, if present
    public var cartfilePath: String?
    public var provisioningProfileEncoded: String?
    public var certificateEncoded: String?
    public var provisioningProfileFileID: String?
    public var certificateFileID: String?
    public var provisioningProfileUploadID: String?
    public var appExtensionProvisioningProfileFiles: [AppExtensionProvisioningProfileFile]?
    public var certificateUploadID: String?
    public var certificatePassword: String?
    public var scheme: String?
    /// Xcode version used to build. Available versions can be found in "/xcode_versions" API. Default is latest stable version, at the time when the configuration is set.
    public var xcodeVersion: String?
    public var provisioningProfileFilename: String?
    public var certificateFilename: String?
    public var teamID: String?
    public var isAutomaticSigning: Bool?
    /// The selected pbxproject hash to the repositroy
    public var xcodeProjectSha: String?
    /// The build configuration of the target to archive
    public var archiveConfiguration: String?
    /// The target id of the selected scheme to archive
    public var targetToArchive: String?
    /// Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting from workspace settings is used.
    /// By default new build system is used if workspace setting is not committed to the repository. Only used for iOS React Native app, with Xcode 10.
    public var isForceLegacyBuildSystem: Bool?

    /// Provisioning profile fetch and store information
    public struct AppExtensionProvisioningProfileFile: Codable {
        /// Name of uploaded provisioning profile
        public var fileName: String?
        /// File id from secure file storage
        public var fileID: String?
        /// Upload id to App Center File Upload Store
        public var uploadID: String?
        /// Target the provisioning profile is used to sign
        public var targetBundleIdentifier: String?

        public init(fileName: String? = nil, fileID: String? = nil, uploadID: String? = nil, targetBundleIdentifier: String? = nil) {
            self.fileName = fileName
            self.fileID = fileID
            self.uploadID = uploadID
            self.targetBundleIdentifier = targetBundleIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case fileName
            case fileID = "fileId"
            case uploadID = "uploadId"
            case targetBundleIdentifier
        }
    }

    public init(projectOrWorkspacePath: String? = nil, podfilePath: String? = nil, cartfilePath: String? = nil, provisioningProfileEncoded: String? = nil, certificateEncoded: String? = nil, provisioningProfileFileID: String? = nil, certificateFileID: String? = nil, provisioningProfileUploadID: String? = nil, appExtensionProvisioningProfileFiles: [AppExtensionProvisioningProfileFile]? = nil, certificateUploadID: String? = nil, certificatePassword: String? = nil, scheme: String? = nil, xcodeVersion: String? = nil, provisioningProfileFilename: String? = nil, certificateFilename: String? = nil, teamID: String? = nil, isAutomaticSigning: Bool? = nil, xcodeProjectSha: String? = nil, archiveConfiguration: String? = nil, targetToArchive: String? = nil, isForceLegacyBuildSystem: Bool? = nil) {
        self.projectOrWorkspacePath = projectOrWorkspacePath
        self.podfilePath = podfilePath
        self.cartfilePath = cartfilePath
        self.provisioningProfileEncoded = provisioningProfileEncoded
        self.certificateEncoded = certificateEncoded
        self.provisioningProfileFileID = provisioningProfileFileID
        self.certificateFileID = certificateFileID
        self.provisioningProfileUploadID = provisioningProfileUploadID
        self.appExtensionProvisioningProfileFiles = appExtensionProvisioningProfileFiles
        self.certificateUploadID = certificateUploadID
        self.certificatePassword = certificatePassword
        self.scheme = scheme
        self.xcodeVersion = xcodeVersion
        self.provisioningProfileFilename = provisioningProfileFilename
        self.certificateFilename = certificateFilename
        self.teamID = teamID
        self.isAutomaticSigning = isAutomaticSigning
        self.xcodeProjectSha = xcodeProjectSha
        self.archiveConfiguration = archiveConfiguration
        self.targetToArchive = targetToArchive
        self.isForceLegacyBuildSystem = isForceLegacyBuildSystem
    }

    private enum CodingKeys: String, CodingKey {
        case projectOrWorkspacePath
        case podfilePath
        case cartfilePath
        case provisioningProfileEncoded
        case certificateEncoded
        case provisioningProfileFileID = "provisioningProfileFileId"
        case certificateFileID = "certificateFileId"
        case provisioningProfileUploadID = "provisioningProfileUploadId"
        case appExtensionProvisioningProfileFiles
        case certificateUploadID = "certificateUploadId"
        case certificatePassword
        case scheme
        case xcodeVersion
        case provisioningProfileFilename
        case certificateFilename
        case teamID = "teamId"
        case isAutomaticSigning = "automaticSigning"
        case xcodeProjectSha
        case archiveConfiguration
        case targetToArchive
        case isForceLegacyBuildSystem = "forceLegacyBuildSystem"
    }
}

/// Build configuration for Android projects
public struct AndroidBranchConfigurationProperties: Codable {
    /// Path to the Gradle wrapper script
    ///
    /// Example: "android/gradlew"
    public var gradleWrapperPath: String?
    /// The Gradle module to build
    ///
    /// Example: "app"
    public var module: String?
    /// The Android build variant to build
    ///
    /// Example: "release"
    public var buildVariant: String?
    /// Whether to run unit tests during the build (default)
    public var isRunTests: Bool
    /// Whether to run lint checks during the build (default)
    public var isRunLint: Bool?
    /// Whether it is the root module or not
    public var isRoot: Bool?
    /// Whether to apply automatic signing or not
    public var isAutomaticSigning: Bool?
    /// The password of the keystore
    public var keystorePassword: String?
    /// The key alias
    public var keyAlias: String?
    /// The key password
    public var keyPassword: String?
    /// The name of the keystore file
    public var keystoreFilename: String?
    /// The keystore encoded value
    public var keystoreEncoded: String?

    public init(gradleWrapperPath: String? = nil, module: String? = nil, buildVariant: String? = nil, isRunTests: Bool? = nil, isRunLint: Bool? = nil, isRoot: Bool? = nil, isAutomaticSigning: Bool? = nil, keystorePassword: String? = nil, keyAlias: String? = nil, keyPassword: String? = nil, keystoreFilename: String? = nil, keystoreEncoded: String? = nil) {
        self.gradleWrapperPath = gradleWrapperPath
        self.module = module
        self.buildVariant = buildVariant
        self.isRunTests = isRunTests ?? true
        self.isRunLint = isRunLint
        self.isRoot = isRoot
        self.isAutomaticSigning = isAutomaticSigning
        self.keystorePassword = keystorePassword
        self.keyAlias = keyAlias
        self.keyPassword = keyPassword
        self.keystoreFilename = keystoreFilename
        self.keystoreEncoded = keystoreEncoded
    }

    private enum CodingKeys: String, CodingKey {
        case gradleWrapperPath
        case module
        case buildVariant
        case isRunTests = "runTests"
        case isRunLint = "runLint"
        case isRoot
        case isAutomaticSigning = "automaticSigning"
        case keystorePassword
        case keyAlias
        case keyPassword
        case keystoreFilename
        case keystoreEncoded
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.gradleWrapperPath = try values.decodeIfPresent(String.self, forKey: .gradleWrapperPath)
        self.module = try values.decodeIfPresent(String.self, forKey: .module)
        self.buildVariant = try values.decodeIfPresent(String.self, forKey: .buildVariant)
        self.isRunTests = try values.decodeIfPresent(Bool.self, forKey: .isRunTests) ?? true
        self.isRunLint = try values.decodeIfPresent(Bool.self, forKey: .isRunLint)
        self.isRoot = try values.decodeIfPresent(Bool.self, forKey: .isRoot)
        self.isAutomaticSigning = try values.decodeIfPresent(Bool.self, forKey: .isAutomaticSigning)
        self.keystorePassword = try values.decodeIfPresent(String.self, forKey: .keystorePassword)
        self.keyAlias = try values.decodeIfPresent(String.self, forKey: .keyAlias)
        self.keyPassword = try values.decodeIfPresent(String.self, forKey: .keyPassword)
        self.keystoreFilename = try values.decodeIfPresent(String.self, forKey: .keystoreFilename)
        self.keystoreEncoded = try values.decodeIfPresent(String.self, forKey: .keystoreEncoded)
    }
}

/// Build configuration when React Native, or other JavaScript tech, is part of the build steps
public struct JavaScriptBranchConfigurationProperties: Codable {
    /// Path to package.json file for the main project, e.g. "package.json" or "myapp/package.json"
    public var packageJSONPath: String?
    /// Whether to run Jest unit tests, via npm test, during the build
    public var isRunTests: Bool?
    /// Version of React Native from package.json files
    public var reactNativeVersion: String?

    public init(packageJSONPath: String? = nil, isRunTests: Bool? = nil, reactNativeVersion: String? = nil) {
        self.packageJSONPath = packageJSONPath
        self.isRunTests = isRunTests
        self.reactNativeVersion = reactNativeVersion
    }

    private enum CodingKeys: String, CodingKey {
        case packageJSONPath = "packageJsonPath"
        case isRunTests = "runTests"
        case reactNativeVersion
    }
}

/// Build configuration for Xamarin projects
public struct XamarinBranchConfigurationProperties: Codable {
    public var slnPath: String?
    public var isSimBuild: Bool?
    public var args: String?
    public var configuration: String?
    public var p12File: String?
    public var p12Pwd: String?
    public var provProfile: String?
    public var monoVersion: String?
    public var sdkBundle: String?
    /// Symlink of the SDK Bundle and Mono installation.
    /// The build will use the associated Mono bundled with related Xamarin SDK. If both symlink and monoVersion or sdkBundle are passed, the symlink is taking precedence. If non-existing symlink is passed, the current stable Mono version will be configured for building.
    public var symlink: String?

    public init(slnPath: String? = nil, isSimBuild: Bool? = nil, args: String? = nil, configuration: String? = nil, p12File: String? = nil, p12Pwd: String? = nil, provProfile: String? = nil, monoVersion: String? = nil, sdkBundle: String? = nil, symlink: String? = nil) {
        self.slnPath = slnPath
        self.isSimBuild = isSimBuild
        self.args = args
        self.configuration = configuration
        self.p12File = p12File
        self.p12Pwd = p12Pwd
        self.provProfile = provProfile
        self.monoVersion = monoVersion
        self.sdkBundle = sdkBundle
        self.symlink = symlink
    }
}

public struct Branch: Codable {
    /// The branch name
    public var name: String
    public var commit: Commit

    public struct Commit: Codable {
        /// The commit SHA
        public var sha: String?
        /// The URL to the commit
        public var url: String?

        public init(sha: String? = nil, url: String? = nil) {
            self.sha = sha
            self.url = url
        }
    }

    public init(name: String, commit: Commit) {
        self.name = name
        self.commit = commit
    }
}

public struct Commit: Codable {
    /// The commit SHA
    public var sha: String?
    /// The URL to the commit
    public var url: String?

    public init(sha: String? = nil, url: String? = nil) {
        self.sha = sha
        self.url = url
    }
}

public struct CommitDetails: Codable {
    /// The commit SHA
    public var sha: String?
    /// The URL to the commit
    public var url: String?
    public var commit: Commit?

    public struct Commit: Codable {
        /// Commit message
        public var message: String?
        public var author: Author?

        public struct Author: Codable {
            /// Date and time of the commit
            public var date: String?
            /// Author name
            public var name: String?
            /// Author's email
            public var email: String?

            public init(date: String? = nil, name: String? = nil, email: String? = nil) {
                self.date = date
                self.name = name
                self.email = email
            }
        }

        public init(message: String? = nil, author: Author? = nil) {
            self.message = message
            self.author = author
        }
    }

    public init(sha: String? = nil, url: String? = nil, commit: Commit? = nil) {
        self.sha = sha
        self.url = url
        self.commit = commit
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.sha = try values.decodeIfPresent(String.self, forKey: "sha")
        self.url = try values.decodeIfPresent(String.self, forKey: "url")
        self.commit = try Commit(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(sha, forKey: "sha")
        try values.encodeIfPresent(url, forKey: "url")
        try values.encodeIfPresent(commit, forKey: "commit")
    }
}

public struct CommitDetailsListItem: Codable {
    /// The commit SHA
    public var sha: String?
    /// The URL to the commit
    public var url: String?
    public var commit: Commit?

    public struct Commit: Codable {
        /// Commit message
        public var message: String?
        public var author: Author?

        public struct Author: Codable {
            /// Date and time of the commit
            public var date: String?
            /// Author name
            public var name: String?
            /// Author's email
            public var email: String?

            public init(date: String? = nil, name: String? = nil, email: String? = nil) {
                self.date = date
                self.name = name
                self.email = email
            }
        }

        public init(message: String? = nil, author: Author? = nil) {
            self.message = message
            self.author = author
        }
    }

    public init(sha: String? = nil, url: String? = nil, commit: Commit? = nil) {
        self.sha = sha
        self.url = url
        self.commit = commit
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.sha = try values.decodeIfPresent(String.self, forKey: "sha")
        self.url = try values.decodeIfPresent(String.self, forKey: "url")
        self.commit = try Commit(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(sha, forKey: "sha")
        try values.encodeIfPresent(url, forKey: "url")
        try values.encodeIfPresent(commit, forKey: "commit")
    }
}

public struct RepoConfig: Codable {
    /// The repository's git url, must be a HTTPS URL
    ///
    /// Example: "https://github.com/foo/bar.git"
    public var repoURL: String?
    /// The repository id from the repository provider. Required for repositories connected from GitHub App and GitLab.com
    public var repoID: String?
    /// The external user id from the repository provider. Required for GitLab.com repositories
    public var externalUserID: String?
    /// The id of the service connection (private). Required for GitLab self-hosted repositories
    public var serviceConnectionID: String?

    public init(repoURL: String? = nil, repoID: String? = nil, externalUserID: String? = nil, serviceConnectionID: String? = nil) {
        self.repoURL = repoURL
        self.repoID = repoID
        self.externalUserID = externalUserID
        self.serviceConnectionID = serviceConnectionID
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.repoURL = try values.decodeIfPresent(String.self, forKey: "repo_url")
        self.repoID = try values.decodeIfPresent(String.self, forKey: "repo_id")
        self.externalUserID = try values.decodeIfPresent(String.self, forKey: "external_user_id")
        self.serviceConnectionID = try values.decodeIfPresent(String.self, forKey: "service_connection_id")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(repoURL, forKey: "repo_url")
        try values.encodeIfPresent(repoID, forKey: "repo_id")
        try values.encodeIfPresent(externalUserID, forKey: "external_user_id")
        try values.encodeIfPresent(serviceConnectionID, forKey: "service_connection_id")
    }
}

public struct RepoConfigPostRequest: Codable {
    /// The repository's git url, must be a HTTPS URL
    ///
    /// Example: "https://github.com/foo/bar.git"
    public var repoURL: String?
    /// The repository id from the repository provider. Required for repositories connected from GitHub App and GitLab.com
    public var repoID: String?
    /// The external user id from the repository provider. Required for GitLab.com repositories
    public var externalUserID: String?
    /// The id of the service connection (private). Required for GitLab self-hosted repositories
    public var serviceConnectionID: String?

    public init(repoURL: String? = nil, repoID: String? = nil, externalUserID: String? = nil, serviceConnectionID: String? = nil) {
        self.repoURL = repoURL
        self.repoID = repoID
        self.externalUserID = externalUserID
        self.serviceConnectionID = serviceConnectionID
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.repoURL = try values.decodeIfPresent(String.self, forKey: "repo_url")
        self.repoID = try values.decodeIfPresent(String.self, forKey: "repo_id")
        self.externalUserID = try values.decodeIfPresent(String.self, forKey: "external_user_id")
        self.serviceConnectionID = try values.decodeIfPresent(String.self, forKey: "service_connection_id")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(repoURL, forKey: "repo_url")
        try values.encodeIfPresent(repoID, forKey: "repo_id")
        try values.encodeIfPresent(externalUserID, forKey: "external_user_id")
        try values.encodeIfPresent(serviceConnectionID, forKey: "service_connection_id")
    }
}

public struct RepoConfigCommon: Codable {
    /// The repository's git url, must be a HTTPS URL
    ///
    /// Example: "https://github.com/foo/bar.git"
    public var repoURL: String?
    /// The repository id from the repository provider. Required for repositories connected from GitHub App and GitLab.com
    public var repoID: String?
    /// The external user id from the repository provider. Required for GitLab.com repositories
    public var externalUserID: String?
    /// The id of the service connection (private). Required for GitLab self-hosted repositories
    public var serviceConnectionID: String?

    public init(repoURL: String? = nil, repoID: String? = nil, externalUserID: String? = nil, serviceConnectionID: String? = nil) {
        self.repoURL = repoURL
        self.repoID = repoID
        self.externalUserID = externalUserID
        self.serviceConnectionID = serviceConnectionID
    }

    private enum CodingKeys: String, CodingKey {
        case repoURL = "repo_url"
        case repoID = "repo_id"
        case externalUserID = "external_user_id"
        case serviceConnectionID = "service_connection_id"
    }
}

public struct RepoConfigsItem: Codable {
    /// Repository configuration identifier
    public var id: String
    /// Type of repository
    public var type: String
    /// State of the configuration
    public var state: State
    /// Email of the user who linked the repository
    public var userEmail: String?

    /// State of the configuration
    public enum State: String, Codable, CaseIterable {
        case unauthorized
        case inactive
        case active
    }

    public init(id: String, type: String, state: State, userEmail: String? = nil) {
        self.id = id
        self.type = type
        self.state = state
        self.userEmail = userEmail
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case type
        case state
        case userEmail = "user_email"
    }
}

public struct RepoInfo: Codable {
    /// The repository url
    public var repoURL: String
    /// The external user ID
    public var externalUserID: String?

    public init(repoURL: String, externalUserID: String? = nil) {
        self.repoURL = repoURL
        self.externalUserID = externalUserID
    }

    private enum CodingKeys: String, CodingKey {
        case repoURL = "repo_url"
        case externalUserID = "external_user_id"
    }
}

public struct PatchRepoInfo: Codable {
    /// The external user ID
    public var externalUserID: String?

    public init(externalUserID: String? = nil) {
        self.externalUserID = externalUserID
    }

    private enum CodingKeys: String, CodingKey {
        case externalUserID = "external_user_id"
    }
}

/// Set of toolsets available for app
public struct Toolsets: Codable {
    /// A list of Xamarin SDK bundles
    public var xamarin: [XamarinItem]?
    /// A list of Xcode versions
    public var xcode: [XcodeItem]?
    /// A list of Node versions
    public var node: [NodeItem]?

    /// The Xamarin SDK bundle
    public struct XamarinItem: Codable {
        /// The Mono version
        public var monoVersion: String?
        /// The Xamarin SDK version
        public var sdkBundle: String?
        /// If the SDK is latest stable
        public var isCurrent: Bool?
        /// If the SDK is stable
        public var isStable: Bool?
        /// Specific for iOS SDK. A list of Xcode versions supported by current SDK version
        public var xcodeVersions: [String]?

        public init(monoVersion: String? = nil, sdkBundle: String? = nil, isCurrent: Bool? = nil, isStable: Bool? = nil, xcodeVersions: [String]? = nil) {
            self.monoVersion = monoVersion
            self.sdkBundle = sdkBundle
            self.isCurrent = isCurrent
            self.isStable = isStable
            self.xcodeVersions = xcodeVersions
        }

        private enum CodingKeys: String, CodingKey {
            case monoVersion
            case sdkBundle
            case isCurrent = "current"
            case isStable = "stable"
            case xcodeVersions
        }
    }

    /// The Xcode version
    public struct XcodeItem: Codable {
        /// The version name
        public var name: String?
        /// If the Xcode is latest stable
        public var isCurrent: Bool?

        public init(name: String? = nil, isCurrent: Bool? = nil) {
            self.name = name
            self.isCurrent = isCurrent
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case isCurrent = "current"
        }
    }

    /// The Node version
    public struct NodeItem: Codable {
        /// The version name
        public var name: String?
        /// If the Node version is default for AppCenter
        public var isCurrent: Bool?

        public init(name: String? = nil, isCurrent: Bool? = nil) {
            self.name = name
            self.isCurrent = isCurrent
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case isCurrent = "current"
        }
    }

    public init(xamarin: [XamarinItem]? = nil, xcode: [XcodeItem]? = nil, node: [NodeItem]? = nil) {
        self.xamarin = xamarin
        self.xcode = xcode
        self.node = node
    }
}

/// The Xcode version
public struct XcodeVersionsItem: Codable {
    /// The version name
    public var name: String?
    /// If the Xcode is latest stable
    public var isCurrent: Bool?

    public init(name: String? = nil, isCurrent: Bool? = nil) {
        self.name = name
        self.isCurrent = isCurrent
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case isCurrent = "current"
    }
}

/// The Xcode version
public struct XcodeVersion: Codable {
    /// The version name
    public var name: String?
    /// If the Xcode is latest stable
    public var isCurrent: Bool?

    public init(name: String? = nil, isCurrent: Bool? = nil) {
        self.name = name
        self.isCurrent = isCurrent
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case isCurrent = "current"
    }
}

/// The Xamarin SDK bundle
public struct XamarinSDKBundlesItem: Codable {
    /// The Mono version
    public var monoVersion: String?
    /// The Xamarin SDK version
    public var sdkBundle: String?
    /// If the SDK is latest stable
    public var isCurrent: Bool?
    /// If the SDK is stable
    public var isStable: Bool?
    /// Specific for iOS SDK. A list of Xcode versions supported by current SDK version
    public var xcodeVersions: [String]?

    public init(monoVersion: String? = nil, sdkBundle: String? = nil, isCurrent: Bool? = nil, isStable: Bool? = nil, xcodeVersions: [String]? = nil) {
        self.monoVersion = monoVersion
        self.sdkBundle = sdkBundle
        self.isCurrent = isCurrent
        self.isStable = isStable
        self.xcodeVersions = xcodeVersions
    }

    private enum CodingKeys: String, CodingKey {
        case monoVersion
        case sdkBundle
        case isCurrent = "current"
        case isStable = "stable"
        case xcodeVersions
    }
}

/// The Xamarin SDK bundle
public struct XamarinSDKBundle: Codable {
    /// The Mono version
    public var monoVersion: String?
    /// The Xamarin SDK version
    public var sdkBundle: String?
    /// If the SDK is latest stable
    public var isCurrent: Bool?
    /// If the SDK is stable
    public var isStable: Bool?
    /// Specific for iOS SDK. A list of Xcode versions supported by current SDK version
    public var xcodeVersions: [String]?

    public init(monoVersion: String? = nil, sdkBundle: String? = nil, isCurrent: Bool? = nil, isStable: Bool? = nil, xcodeVersions: [String]? = nil) {
        self.monoVersion = monoVersion
        self.sdkBundle = sdkBundle
        self.isCurrent = isCurrent
        self.isStable = isStable
        self.xcodeVersions = xcodeVersions
    }

    private enum CodingKeys: String, CodingKey {
        case monoVersion
        case sdkBundle
        case isCurrent = "current"
        case isStable = "stable"
        case xcodeVersions
    }
}

/// The Node version
public struct NodeVersionsItem: Codable {
    /// The version name
    public var name: String?
    /// If the Node version is default for AppCenter
    public var isCurrent: Bool?

    public init(name: String? = nil, isCurrent: Bool? = nil) {
        self.name = name
        self.isCurrent = isCurrent
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case isCurrent = "current"
    }
}

/// The Node version
public struct NodeVersion: Codable {
    /// The version name
    public var name: String?
    /// If the Node version is default for AppCenter
    public var isCurrent: Bool?

    public init(name: String? = nil, isCurrent: Bool? = nil) {
        self.name = name
        self.isCurrent = isCurrent
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case isCurrent = "current"
    }
}

public struct BuildsItem: Codable {
    /// The build ID
    public var id: Int
    /// The build number
    public var buildNumber: String
    /// The time the build was queued
    public var queueTime: String
    /// The time the build was started
    public var startTime: String?
    /// The time the build was finished
    public var finishTime: String?
    /// The time the build status was last changed
    public var lastChangedDate: String?
    /// The build status
    public var status: String
    /// The build result
    public var result: String
    /// The source branch name
    public var sourceBranch: String
    /// The source SHA
    public var sourceVersion: String

    public init(id: Int, buildNumber: String, queueTime: String, startTime: String? = nil, finishTime: String? = nil, lastChangedDate: String? = nil, status: String, result: String, sourceBranch: String, sourceVersion: String) {
        self.id = id
        self.buildNumber = buildNumber
        self.queueTime = queueTime
        self.startTime = startTime
        self.finishTime = finishTime
        self.lastChangedDate = lastChangedDate
        self.status = status
        self.result = result
        self.sourceBranch = sourceBranch
        self.sourceVersion = sourceVersion
    }
}

public struct BuildParams: Codable {
    /// Version to build which represents the full Git commit reference
    public var sourceVersion: String?
    /// Run build in debug mode
    public var isDebug: Bool?

    public init(sourceVersion: String? = nil, isDebug: Bool? = nil) {
        self.sourceVersion = sourceVersion
        self.isDebug = isDebug
    }

    private enum CodingKeys: String, CodingKey {
        case sourceVersion
        case isDebug = "debug"
    }
}

public struct Build: Codable {
    /// The build ID
    public var id: Int
    /// The build number
    public var buildNumber: String
    /// The time the build was queued
    public var queueTime: String
    /// The time the build was started
    public var startTime: String?
    /// The time the build was finished
    public var finishTime: String?
    /// The time the build status was last changed
    public var lastChangedDate: String?
    /// The build status
    public var status: String
    /// The build result
    public var result: String
    /// The source branch name
    public var sourceBranch: String
    /// The source SHA
    public var sourceVersion: String

    public init(id: Int, buildNumber: String, queueTime: String, startTime: String? = nil, finishTime: String? = nil, lastChangedDate: String? = nil, status: String, result: String, sourceBranch: String, sourceVersion: String) {
        self.id = id
        self.buildNumber = buildNumber
        self.queueTime = queueTime
        self.startTime = startTime
        self.finishTime = finishTime
        self.lastChangedDate = lastChangedDate
        self.status = status
        self.result = result
        self.sourceBranch = sourceBranch
        self.sourceVersion = sourceVersion
    }
}

public struct BuildPatch: Codable {
    /// The build status; used to cancel builds
    public var status: Status?

    /// The build status; used to cancel builds
    public enum Status: String, Codable, CaseIterable {
        case cancelling
    }

    public init(status: Status? = nil) {
        self.status = status
    }
}

public struct BuildLog: Codable {
    public var value: [String]?

    public init(value: [String]? = nil) {
        self.value = value
    }
}

public struct BuildTimeline: Codable {
    public var id: String?
    public var records: [Record]?

    public struct Record: Codable {
        public var id: String?
        public var name: String?
        public var order: Double?
        public var percentComplete: Double?
        public var currentOperation: String?
        public var state: String?
        public var result: String?
        public var errorCount: Double?
        public var warningCount: Double?
        public var issues: [Issue]?
        public var startTime: String?
        public var finishTime: String?
        public var type: String?

        public struct Issue: Codable {
            public var category: String?
            public var message: String?
            public var type: String?

            public init(category: String? = nil, message: String? = nil, type: String? = nil) {
                self.category = category
                self.message = message
                self.type = type
            }
        }

        public init(id: String? = nil, name: String? = nil, order: Double? = nil, percentComplete: Double? = nil, currentOperation: String? = nil, state: String? = nil, result: String? = nil, errorCount: Double? = nil, warningCount: Double? = nil, issues: [Issue]? = nil, startTime: String? = nil, finishTime: String? = nil, type: String? = nil) {
            self.id = id
            self.name = name
            self.order = order
            self.percentComplete = percentComplete
            self.currentOperation = currentOperation
            self.state = state
            self.result = result
            self.errorCount = errorCount
            self.warningCount = warningCount
            self.issues = issues
            self.startTime = startTime
            self.finishTime = finishTime
            self.type = type
        }
    }

    public init(id: String? = nil, records: [Record]? = nil) {
        self.id = id
        self.records = records
    }
}

public struct BuildTimelineRecord: Codable {
    public var id: String?
    public var name: String?
    public var order: Double?
    public var percentComplete: Double?
    public var currentOperation: String?
    public var state: String?
    public var result: String?
    public var errorCount: Double?
    public var warningCount: Double?
    public var issues: [Issue]?
    public var startTime: String?
    public var finishTime: String?
    public var type: String?

    public struct Issue: Codable {
        public var category: String?
        public var message: String?
        public var type: String?

        public init(category: String? = nil, message: String? = nil, type: String? = nil) {
            self.category = category
            self.message = message
            self.type = type
        }
    }

    public init(id: String? = nil, name: String? = nil, order: Double? = nil, percentComplete: Double? = nil, currentOperation: String? = nil, state: String? = nil, result: String? = nil, errorCount: Double? = nil, warningCount: Double? = nil, issues: [Issue]? = nil, startTime: String? = nil, finishTime: String? = nil, type: String? = nil) {
        self.id = id
        self.name = name
        self.order = order
        self.percentComplete = percentComplete
        self.currentOperation = currentOperation
        self.state = state
        self.result = result
        self.errorCount = errorCount
        self.warningCount = warningCount
        self.issues = issues
        self.startTime = startTime
        self.finishTime = finishTime
        self.type = type
    }
}

public struct BuildIssue: Codable {
    public var category: String?
    public var message: String?
    public var type: String?

    public init(category: String? = nil, message: String? = nil, type: String? = nil) {
        self.category = category
        self.message = message
        self.type = type
    }
}

public struct DistributionRequest: Codable {
    /// Array of objects {id:string, type:string} with "id" being the distribution group ID, store ID, or tester email, and "type" being "group", "store", or "tester"
    public var destinations: [Destination]?
    /// The release notes
    public var releaseNotes: String?
    public var isMandatoryUpdate: Bool?
    public var isNotifyTesters: Bool

    /// Destination details for distributing build releases
    public struct Destination: Codable {
        public var id: String
        public var type: `Type`

        public enum `Type`: String, Codable, CaseIterable {
            case store
            case group
            case tester
        }

        public init(id: String, type: `Type`) {
            self.id = id
            self.type = type
        }
    }

    public init(destinations: [Destination]? = nil, releaseNotes: String? = nil, isMandatoryUpdate: Bool? = nil, isNotifyTesters: Bool? = nil) {
        self.destinations = destinations
        self.releaseNotes = releaseNotes
        self.isMandatoryUpdate = isMandatoryUpdate
        self.isNotifyTesters = isNotifyTesters ?? true
    }

    private enum CodingKeys: String, CodingKey {
        case destinations
        case releaseNotes
        case isMandatoryUpdate = "mandatoryUpdate"
        case isNotifyTesters = "notifyTesters"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.destinations = try values.decodeIfPresent([Destination].self, forKey: .destinations)
        self.releaseNotes = try values.decodeIfPresent(String.self, forKey: .releaseNotes)
        self.isMandatoryUpdate = try values.decodeIfPresent(Bool.self, forKey: .isMandatoryUpdate)
        self.isNotifyTesters = try values.decodeIfPresent(Bool.self, forKey: .isNotifyTesters) ?? true
    }
}

public struct DistributionResponse: Codable {
    /// Status of the Request
    public var status: String?
    /// A unique ID of the upload
    public var uploadID: String?

    public init(status: String? = nil, uploadID: String? = nil) {
        self.status = status
        self.uploadID = uploadID
    }

    private enum CodingKeys: String, CodingKey {
        case status
        case uploadID = "upload_id"
    }
}

public struct BuildServiceStatus: Codable {
    public var status: String?
    public var service: String?
    public var message: String?
    public var url: String?
    public var validUntil: Int?
    public var os: String?

    public init(status: String? = nil, service: String? = nil, message: String? = nil, url: String? = nil, validUntil: Int? = nil, os: String? = nil) {
        self.status = status
        self.service = service
        self.message = message
        self.url = url
        self.validUntil = validUntil
        self.os = os
    }

    private enum CodingKeys: String, CodingKey {
        case status
        case service
        case message
        case url
        case validUntil = "valid_until"
        case os
    }
}

public struct BuildAgentQueue: Codable {
    public var queue: String

    public init(queue: String) {
        self.queue = queue
    }
}

public struct ValidationErrorResponse: Codable {
    public var id: String
    public var code: String
    public var message: String

    public init(id: String, code: String, message: String) {
        self.id = id
        self.code = code
        self.message = message
    }
}

/// Queue configured in build definition
public struct BuildAgentQueuesResponseItem: Codable {
    /// Name of the build definition
    public var buildDefinition: String?
    /// Name of the queue
    public var name: String?

    public init(buildDefinition: String? = nil, name: String? = nil) {
        self.buildDefinition = buildDefinition
        self.name = name
    }
}

/// Queue configured in build definition
public struct BuildAgentQueueResponse: Codable {
    /// Name of the build definition
    public var buildDefinition: String?
    /// Name of the queue
    public var name: String?

    public init(buildDefinition: String? = nil, name: String? = nil) {
        self.buildDefinition = buildDefinition
        self.name = name
    }
}

/// Agent queue
public struct AgentQueuesResponseItem: Codable {
    public var id: Int?
    public var name: String?

    public init(id: Int? = nil, name: String? = nil) {
        self.id = id
        self.name = name
    }
}

/// Agent queue
public struct AgentQueueResponse: Codable {
    public var id: Int?
    public var name: String?

    public init(id: Int? = nil, name: String? = nil) {
        self.id = id
        self.name = name
    }
}

/// Supported feature
public struct AppBuildFeaturesItem: Codable {
    public var name: String?
    public var isValue: Bool?

    public init(name: String? = nil, isValue: Bool? = nil) {
        self.name = name
        self.isValue = isValue
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case isValue = "value"
    }
}

/// Supported feature
public struct AppBuildFeature: Codable {
    public var name: String?
    public var isValue: Bool?

    public init(name: String? = nil, isValue: Bool? = nil) {
        self.name = name
        self.isValue = isValue
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case isValue = "value"
    }
}

/// Destination details for distributing build releases
public struct DestinationDetails: Codable {
    public var id: String
    public var type: `Type`

    public enum `Type`: String, Codable, CaseIterable {
        case store
        case group
        case tester
    }

    public init(id: String, type: `Type`) {
        self.id = id
        self.type = type
    }
}

/// Additional details required for file validation
public struct FileValidationDetails: Codable {
    public var p12password: String
    public var certificateUploadID: String?

    public init(p12password: String, certificateUploadID: String? = nil) {
        self.p12password = p12password
        self.certificateUploadID = certificateUploadID
    }

    private enum CodingKeys: String, CodingKey {
        case p12password
        case certificateUploadID = "certificateUploadId"
    }
}

/// Number of pipelines
public struct BuildConcurrencyResponse: Codable {
    /// The number of pipelines set by the billing plan
    public var quantity: Double?
    /// The number of pipelines committed, which can be equal or greater than the number from the billing plan
    public var committedQuantity: Double?

    public init(quantity: Double? = nil, committedQuantity: Double? = nil) {
        self.quantity = quantity
        self.committedQuantity = committedQuantity
    }

    private enum CodingKeys: String, CodingKey {
        case quantity
        case committedQuantity = "committed_quantity"
    }
}

public struct CodePushUploadedRelease: Codable {
    /// The upload metadata from the release initialization step.
    public var releaseUpload: ReleaseUpload
    /// The binary version of the application
    public var targetBinaryVersion: String
    /// This specifies which deployment you want to release the update to. Default is Staging.
    public var deploymentName: String?
    /// This provides an optional "change log" for the deployment.
    public var description: String?
    /// This specifies whether an update should be downloadable by end users or not.
    public var isDisabled: Bool?
    /// This specifies whether the update should be considered mandatory or not (e.g. it includes a critical security fix).
    public var isMandatory: Bool?
    /// This specifies that if the update is identical to the latest release on the deployment, the CLI should generate a warning instead of an error.
    public var isNoDuplicateReleaseError: Bool?
    /// This specifies the percentage of users (as an integer between 1 and 100) that should be eligible to receive this update.
    public var rollout: Int?

    /// The upload metadata from the release initialization step.
    public struct ReleaseUpload: Codable {
        /// The ID for the newly created upload. It is going to be required later in the process.
        public var id: String
        /// The URL domain used to upload the release.
        public var uploadDomain: String
        /// The URL encoded token used for upload permissions.
        public var token: String

        public init(id: String, uploadDomain: String, token: String) {
            self.id = id
            self.uploadDomain = uploadDomain
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case uploadDomain = "upload_domain"
            case token
        }
    }

    public init(releaseUpload: ReleaseUpload, targetBinaryVersion: String, deploymentName: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, isNoDuplicateReleaseError: Bool? = nil, rollout: Int? = nil) {
        self.releaseUpload = releaseUpload
        self.targetBinaryVersion = targetBinaryVersion
        self.deploymentName = deploymentName
        self.description = description
        self.isDisabled = isDisabled
        self.isMandatory = isMandatory
        self.isNoDuplicateReleaseError = isNoDuplicateReleaseError
        self.rollout = rollout
    }

    private enum CodingKeys: String, CodingKey {
        case releaseUpload = "release_upload"
        case targetBinaryVersion = "target_binary_version"
        case deploymentName = "deployment_name"
        case description
        case isDisabled = "disabled"
        case isMandatory = "mandatory"
        case isNoDuplicateReleaseError = "no_duplicate_release_error"
        case rollout
    }
}

public struct CodePushReleaseUpload: Codable {
    /// The ID for the newly created upload. It is going to be required later in the process.
    public var id: String
    /// The URL domain used to upload the release.
    public var uploadDomain: String
    /// The URL encoded token used for upload permissions.
    public var token: String

    public init(id: String, uploadDomain: String, token: String) {
        self.id = id
        self.uploadDomain = uploadDomain
        self.token = token
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case uploadDomain = "upload_domain"
        case token
    }
}

public struct Deployment: Codable {
    public var key: String?
    public var name: String
    public var latestRelease: LatestRelease?

    public struct LatestRelease: Codable {
        public var targetBinaryRange: String?
        public var description: String?
        public var isDisabled: Bool?
        public var isMandatory: Bool?
        public var rollout: Int?
        public var label: String?
        public var packageHash: String?
        public var blobURL: String?
        public var diffPackageMap: [String: DiffPackageMapItem]?
        /// Set on 'Promote'
        public var originalDeployment: String?
        /// Set on 'Promote' and 'Rollback'
        public var originalLabel: String?
        public var releasedBy: String?
        /// The release method is unknown if unspecified
        public var releaseMethod: ReleaseMethod?
        public var size: Double?
        public var uploadTime: Int?

        public struct DiffPackageMapItem: Codable {
            public var size: Double
            public var url: String

            public init(size: Double, url: String) {
                self.size = size
                self.url = url
            }
        }

        /// The release method is unknown if unspecified
        public enum ReleaseMethod: String, Codable, CaseIterable {
            case upload = "Upload"
            case promote = "Promote"
            case rollback = "Rollback"
        }

        public init(targetBinaryRange: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, label: String? = nil, packageHash: String? = nil, blobURL: String? = nil, diffPackageMap: [String: DiffPackageMapItem]? = nil, originalDeployment: String? = nil, originalLabel: String? = nil, releasedBy: String? = nil, releaseMethod: ReleaseMethod? = nil, size: Double? = nil, uploadTime: Int? = nil) {
            self.targetBinaryRange = targetBinaryRange
            self.description = description
            self.isDisabled = isDisabled
            self.isMandatory = isMandatory
            self.rollout = rollout
            self.label = label
            self.packageHash = packageHash
            self.blobURL = blobURL
            self.diffPackageMap = diffPackageMap
            self.originalDeployment = originalDeployment
            self.originalLabel = originalLabel
            self.releasedBy = releasedBy
            self.releaseMethod = releaseMethod
            self.size = size
            self.uploadTime = uploadTime
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.targetBinaryRange = try values.decodeIfPresent(String.self, forKey: "target_binary_range")
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
            self.isDisabled = try values.decodeIfPresent(Bool.self, forKey: "is_disabled")
            self.isMandatory = try values.decodeIfPresent(Bool.self, forKey: "is_mandatory")
            self.rollout = try values.decodeIfPresent(Int.self, forKey: "rollout")
            self.label = try values.decodeIfPresent(String.self, forKey: "label")
            self.packageHash = try values.decodeIfPresent(String.self, forKey: "package_hash")
            self.blobURL = try values.decodeIfPresent(String.self, forKey: "blob_url")
            self.diffPackageMap = try values.decodeIfPresent([String: DiffPackageMapItem].self, forKey: "diff_package_map")
            self.originalDeployment = try values.decodeIfPresent(String.self, forKey: "original_deployment")
            self.originalLabel = try values.decodeIfPresent(String.self, forKey: "original_label")
            self.releasedBy = try values.decodeIfPresent(String.self, forKey: "released_by")
            self.releaseMethod = try ReleaseMethod(from: decoder)
            self.size = try values.decodeIfPresent(Double.self, forKey: "size")
            self.uploadTime = try values.decodeIfPresent(Int.self, forKey: "upload_time")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(targetBinaryRange, forKey: "target_binary_range")
            try values.encodeIfPresent(description, forKey: "description")
            try values.encodeIfPresent(isDisabled, forKey: "is_disabled")
            try values.encodeIfPresent(isMandatory, forKey: "is_mandatory")
            try values.encodeIfPresent(rollout, forKey: "rollout")
            try values.encodeIfPresent(label, forKey: "label")
            try values.encodeIfPresent(packageHash, forKey: "package_hash")
            try values.encodeIfPresent(blobURL, forKey: "blob_url")
            try values.encodeIfPresent(diffPackageMap, forKey: "diff_package_map")
            try values.encodeIfPresent(originalDeployment, forKey: "original_deployment")
            try values.encodeIfPresent(originalLabel, forKey: "original_label")
            try values.encodeIfPresent(releasedBy, forKey: "released_by")
            try values.encodeIfPresent(releaseMethod, forKey: "release_method")
            try values.encodeIfPresent(size, forKey: "size")
            try values.encodeIfPresent(uploadTime, forKey: "upload_time")
        }
    }

    public init(key: String? = nil, name: String, latestRelease: LatestRelease? = nil) {
        self.key = key
        self.name = name
        self.latestRelease = latestRelease
    }

    private enum CodingKeys: String, CodingKey {
        case key
        case name
        case latestRelease = "latest_release"
    }
}

public struct DeploymentInternal: Codable {
    public var key: String?
    public var name: String
    public var latestRelease: LatestRelease?

    public struct LatestRelease: Codable {
        public var targetBinaryRange: String?
        public var description: String?
        public var isDisabled: Bool?
        public var isMandatory: Bool?
        public var rollout: Int?
        public var label: String?
        public var packageHash: String?
        public var blobURL: String?
        public var diffPackageMap: [String: DiffPackageMapItem]?
        /// Set on 'Promote'
        public var originalDeployment: String?
        /// Set on 'Promote' and 'Rollback'
        public var originalLabel: String?
        public var releasedBy: String?
        /// The release method is unknown if unspecified
        public var releaseMethod: ReleaseMethod?
        public var size: Double?
        public var uploadTime: Int?

        public struct DiffPackageMapItem: Codable {
            public var size: Double
            public var url: String

            public init(size: Double, url: String) {
                self.size = size
                self.url = url
            }
        }

        /// The release method is unknown if unspecified
        public enum ReleaseMethod: String, Codable, CaseIterable {
            case upload = "Upload"
            case promote = "Promote"
            case rollback = "Rollback"
        }

        public init(targetBinaryRange: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, label: String? = nil, packageHash: String? = nil, blobURL: String? = nil, diffPackageMap: [String: DiffPackageMapItem]? = nil, originalDeployment: String? = nil, originalLabel: String? = nil, releasedBy: String? = nil, releaseMethod: ReleaseMethod? = nil, size: Double? = nil, uploadTime: Int? = nil) {
            self.targetBinaryRange = targetBinaryRange
            self.description = description
            self.isDisabled = isDisabled
            self.isMandatory = isMandatory
            self.rollout = rollout
            self.label = label
            self.packageHash = packageHash
            self.blobURL = blobURL
            self.diffPackageMap = diffPackageMap
            self.originalDeployment = originalDeployment
            self.originalLabel = originalLabel
            self.releasedBy = releasedBy
            self.releaseMethod = releaseMethod
            self.size = size
            self.uploadTime = uploadTime
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.targetBinaryRange = try values.decodeIfPresent(String.self, forKey: "target_binary_range")
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
            self.isDisabled = try values.decodeIfPresent(Bool.self, forKey: "is_disabled")
            self.isMandatory = try values.decodeIfPresent(Bool.self, forKey: "is_mandatory")
            self.rollout = try values.decodeIfPresent(Int.self, forKey: "rollout")
            self.label = try values.decodeIfPresent(String.self, forKey: "label")
            self.packageHash = try values.decodeIfPresent(String.self, forKey: "package_hash")
            self.blobURL = try values.decodeIfPresent(String.self, forKey: "blob_url")
            self.diffPackageMap = try values.decodeIfPresent([String: DiffPackageMapItem].self, forKey: "diff_package_map")
            self.originalDeployment = try values.decodeIfPresent(String.self, forKey: "original_deployment")
            self.originalLabel = try values.decodeIfPresent(String.self, forKey: "original_label")
            self.releasedBy = try values.decodeIfPresent(String.self, forKey: "released_by")
            self.releaseMethod = try ReleaseMethod(from: decoder)
            self.size = try values.decodeIfPresent(Double.self, forKey: "size")
            self.uploadTime = try values.decodeIfPresent(Int.self, forKey: "upload_time")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(targetBinaryRange, forKey: "target_binary_range")
            try values.encodeIfPresent(description, forKey: "description")
            try values.encodeIfPresent(isDisabled, forKey: "is_disabled")
            try values.encodeIfPresent(isMandatory, forKey: "is_mandatory")
            try values.encodeIfPresent(rollout, forKey: "rollout")
            try values.encodeIfPresent(label, forKey: "label")
            try values.encodeIfPresent(packageHash, forKey: "package_hash")
            try values.encodeIfPresent(blobURL, forKey: "blob_url")
            try values.encodeIfPresent(diffPackageMap, forKey: "diff_package_map")
            try values.encodeIfPresent(originalDeployment, forKey: "original_deployment")
            try values.encodeIfPresent(originalLabel, forKey: "original_label")
            try values.encodeIfPresent(releasedBy, forKey: "released_by")
            try values.encodeIfPresent(releaseMethod, forKey: "release_method")
            try values.encodeIfPresent(size, forKey: "size")
            try values.encodeIfPresent(uploadTime, forKey: "upload_time")
        }
    }

    public init(key: String? = nil, name: String, latestRelease: LatestRelease? = nil) {
        self.key = key
        self.name = name
        self.latestRelease = latestRelease
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.key = try values.decodeIfPresent(String.self, forKey: "key")
        self.name = try values.decode(String.self, forKey: "name")
        self.latestRelease = try LatestRelease(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(key, forKey: "key")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(latestRelease, forKey: "latest_release")
    }
}

public struct DeploymentModification: Codable {
    public var name: String

    public init(name: String) {
        self.name = name
    }
}

public struct CodePushReleaseLabel: Codable {
    public var label: String?

    public init(label: String? = nil) {
        self.label = label
    }
}

public struct BlobInfo: Codable {
    public var size: Double
    public var url: String

    public init(size: Double, url: String) {
        self.size = size
        self.url = url
    }
}

public struct PackageHashToBlobInfoMapItem: Codable {
    public var size: Double
    public var url: String

    public init(size: Double, url: String) {
        self.size = size
        self.url = url
    }
}

public struct CodePushReleaseInfo: Codable {
    public var targetBinaryRange: String?
    public var description: String?
    public var isDisabled: Bool?
    public var isMandatory: Bool?
    public var rollout: Int?

    public init(targetBinaryRange: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil) {
        self.targetBinaryRange = targetBinaryRange
        self.description = description
        self.isDisabled = isDisabled
        self.isMandatory = isMandatory
        self.rollout = rollout
    }

    private enum CodingKeys: String, CodingKey {
        case targetBinaryRange = "target_binary_range"
        case description
        case isDisabled = "is_disabled"
        case isMandatory = "is_mandatory"
        case rollout
    }
}

public struct LegacyCodePushReleaseInfo: Codable {
    public var appVersion: String?
    public var description: String?
    public var isDisabled: Bool?
    public var isMandatory: Bool?
    public var rollout: Int?

    public init(appVersion: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil) {
        self.appVersion = appVersion
        self.description = description
        self.isDisabled = isDisabled
        self.isMandatory = isMandatory
        self.rollout = rollout
    }
}

public struct CodePushRelease: Codable {
    public var targetBinaryRange: String?
    public var description: String?
    public var isDisabled: Bool?
    public var isMandatory: Bool?
    public var rollout: Int?
    public var label: String?
    public var packageHash: String?
    public var blobURL: String?
    public var diffPackageMap: [String: DiffPackageMapItem]?
    /// Set on 'Promote'
    public var originalDeployment: String?
    /// Set on 'Promote' and 'Rollback'
    public var originalLabel: String?
    public var releasedBy: String?
    /// The release method is unknown if unspecified
    public var releaseMethod: ReleaseMethod?
    public var size: Double?
    public var uploadTime: Int?

    public struct DiffPackageMapItem: Codable {
        public var size: Double
        public var url: String

        public init(size: Double, url: String) {
            self.size = size
            self.url = url
        }
    }

    /// The release method is unknown if unspecified
    public enum ReleaseMethod: String, Codable, CaseIterable {
        case upload = "Upload"
        case promote = "Promote"
        case rollback = "Rollback"
    }

    public init(targetBinaryRange: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, label: String? = nil, packageHash: String? = nil, blobURL: String? = nil, diffPackageMap: [String: DiffPackageMapItem]? = nil, originalDeployment: String? = nil, originalLabel: String? = nil, releasedBy: String? = nil, releaseMethod: ReleaseMethod? = nil, size: Double? = nil, uploadTime: Int? = nil) {
        self.targetBinaryRange = targetBinaryRange
        self.description = description
        self.isDisabled = isDisabled
        self.isMandatory = isMandatory
        self.rollout = rollout
        self.label = label
        self.packageHash = packageHash
        self.blobURL = blobURL
        self.diffPackageMap = diffPackageMap
        self.originalDeployment = originalDeployment
        self.originalLabel = originalLabel
        self.releasedBy = releasedBy
        self.releaseMethod = releaseMethod
        self.size = size
        self.uploadTime = uploadTime
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.targetBinaryRange = try values.decodeIfPresent(String.self, forKey: "target_binary_range")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.isDisabled = try values.decodeIfPresent(Bool.self, forKey: "is_disabled")
        self.isMandatory = try values.decodeIfPresent(Bool.self, forKey: "is_mandatory")
        self.rollout = try values.decodeIfPresent(Int.self, forKey: "rollout")
        self.label = try values.decodeIfPresent(String.self, forKey: "label")
        self.packageHash = try values.decodeIfPresent(String.self, forKey: "package_hash")
        self.blobURL = try values.decodeIfPresent(String.self, forKey: "blob_url")
        self.diffPackageMap = try values.decodeIfPresent([String: DiffPackageMapItem].self, forKey: "diff_package_map")
        self.originalDeployment = try values.decodeIfPresent(String.self, forKey: "original_deployment")
        self.originalLabel = try values.decodeIfPresent(String.self, forKey: "original_label")
        self.releasedBy = try values.decodeIfPresent(String.self, forKey: "released_by")
        self.releaseMethod = try ReleaseMethod(from: decoder)
        self.size = try values.decodeIfPresent(Double.self, forKey: "size")
        self.uploadTime = try values.decodeIfPresent(Int.self, forKey: "upload_time")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(targetBinaryRange, forKey: "target_binary_range")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(isDisabled, forKey: "is_disabled")
        try values.encodeIfPresent(isMandatory, forKey: "is_mandatory")
        try values.encodeIfPresent(rollout, forKey: "rollout")
        try values.encodeIfPresent(label, forKey: "label")
        try values.encodeIfPresent(packageHash, forKey: "package_hash")
        try values.encodeIfPresent(blobURL, forKey: "blob_url")
        try values.encodeIfPresent(diffPackageMap, forKey: "diff_package_map")
        try values.encodeIfPresent(originalDeployment, forKey: "original_deployment")
        try values.encodeIfPresent(originalLabel, forKey: "original_label")
        try values.encodeIfPresent(releasedBy, forKey: "released_by")
        try values.encodeIfPresent(releaseMethod, forKey: "release_method")
        try values.encodeIfPresent(size, forKey: "size")
        try values.encodeIfPresent(uploadTime, forKey: "upload_time")
    }
}

public struct CodePushReleaseModification: Codable {
    public var targetBinaryRange: String?
    public var description: String?
    public var isDisabled: Bool?
    public var isMandatory: Bool?
    public var rollout: Int?

    public init(targetBinaryRange: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil) {
        self.targetBinaryRange = targetBinaryRange
        self.description = description
        self.isDisabled = isDisabled
        self.isMandatory = isMandatory
        self.rollout = rollout
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.targetBinaryRange = try values.decodeIfPresent(String.self, forKey: "target_binary_range")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.isDisabled = try values.decodeIfPresent(Bool.self, forKey: "is_disabled")
        self.isMandatory = try values.decodeIfPresent(Bool.self, forKey: "is_mandatory")
        self.rollout = try values.decodeIfPresent(Int.self, forKey: "rollout")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(targetBinaryRange, forKey: "target_binary_range")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(isDisabled, forKey: "is_disabled")
        try values.encodeIfPresent(isMandatory, forKey: "is_mandatory")
        try values.encodeIfPresent(rollout, forKey: "rollout")
    }
}

public struct CodePushReleasePromote: Codable {
    public var targetBinaryRange: String?
    public var description: String?
    public var isDisabled: Bool?
    public var isMandatory: Bool?
    public var rollout: Int?
    public var label: String?

    public init(targetBinaryRange: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, label: String? = nil) {
        self.targetBinaryRange = targetBinaryRange
        self.description = description
        self.isDisabled = isDisabled
        self.isMandatory = isMandatory
        self.rollout = rollout
        self.label = label
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.targetBinaryRange = try values.decodeIfPresent(String.self, forKey: "target_binary_range")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.isDisabled = try values.decodeIfPresent(Bool.self, forKey: "is_disabled")
        self.isMandatory = try values.decodeIfPresent(Bool.self, forKey: "is_mandatory")
        self.rollout = try values.decodeIfPresent(Int.self, forKey: "rollout")
        self.label = try values.decodeIfPresent(String.self, forKey: "label")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(targetBinaryRange, forKey: "target_binary_range")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(isDisabled, forKey: "is_disabled")
        try values.encodeIfPresent(isMandatory, forKey: "is_mandatory")
        try values.encodeIfPresent(rollout, forKey: "rollout")
        try values.encodeIfPresent(label, forKey: "label")
    }
}

public struct CodePushReleaseMetric: Codable {
    public var label: String
    public var active: Int
    public var downloaded: Int?
    public var failed: Int?
    public var installed: Int?

    public init(label: String, active: Int, downloaded: Int? = nil, failed: Int? = nil, installed: Int? = nil) {
        self.label = label
        self.active = active
        self.downloaded = downloaded
        self.failed = failed
        self.installed = installed
    }
}

public struct CodePushStatusMetricMetadata: Codable {
    public var deploymentKey: String
    public var label: String?
    public var appVersion: String?
    public var previousDeploymentKey: String?
    public var previousLabelOrAppVersion: String?
    public var status: String?
    public var clientUniqueID: String?

    public init(deploymentKey: String, label: String? = nil, appVersion: String? = nil, previousDeploymentKey: String? = nil, previousLabelOrAppVersion: String? = nil, status: String? = nil, clientUniqueID: String? = nil) {
        self.deploymentKey = deploymentKey
        self.label = label
        self.appVersion = appVersion
        self.previousDeploymentKey = previousDeploymentKey
        self.previousLabelOrAppVersion = previousLabelOrAppVersion
        self.status = status
        self.clientUniqueID = clientUniqueID
    }

    private enum CodingKeys: String, CodingKey {
        case deploymentKey = "deployment_key"
        case label
        case appVersion = "app_version"
        case previousDeploymentKey = "previous_deployment_key"
        case previousLabelOrAppVersion = "previous_label_or_app_version"
        case status
        case clientUniqueID = "client_unique_id"
    }
}

public struct LegacyCodePushStatusMetricMetadata: Codable {
    public var deploymentKey: String?
    public var label: String?
    public var appVersion: String?
    public var previousDeploymentKey: String?
    public var previousLabelOrAppVersion: String?
    public var status: String?
    public var clientUniqueID: String?

    public init(deploymentKey: String? = nil, label: String? = nil, appVersion: String? = nil, previousDeploymentKey: String? = nil, previousLabelOrAppVersion: String? = nil, status: String? = nil, clientUniqueID: String? = nil) {
        self.deploymentKey = deploymentKey
        self.label = label
        self.appVersion = appVersion
        self.previousDeploymentKey = previousDeploymentKey
        self.previousLabelOrAppVersion = previousLabelOrAppVersion
        self.status = status
        self.clientUniqueID = clientUniqueID
    }

    private enum CodingKeys: String, CodingKey {
        case deploymentKey
        case label
        case appVersion
        case previousDeploymentKey
        case previousLabelOrAppVersion
        case status
        case clientUniqueID = "clientUniqueId"
    }
}

public struct UpdateCheckResponse: Codable {
    public var updateInfo: UpdateInfo

    public struct UpdateInfo: Codable {
        public var targetBinaryRange: String?
        public var description: String?
        public var isDisabled: Bool?
        public var isMandatory: Bool?
        public var rollout: Int?
        public var downloadURL: String?
        public var isAvailable: Bool?
        public var packageSize: Double?
        public var shouldRunBinaryVersion: Bool?
        public var isUpdateAppVersion: Bool?
        public var packageHash: String?
        public var label: String?

        public init(targetBinaryRange: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, downloadURL: String? = nil, isAvailable: Bool? = nil, packageSize: Double? = nil, shouldRunBinaryVersion: Bool? = nil, isUpdateAppVersion: Bool? = nil, packageHash: String? = nil, label: String? = nil) {
            self.targetBinaryRange = targetBinaryRange
            self.description = description
            self.isDisabled = isDisabled
            self.isMandatory = isMandatory
            self.rollout = rollout
            self.downloadURL = downloadURL
            self.isAvailable = isAvailable
            self.packageSize = packageSize
            self.shouldRunBinaryVersion = shouldRunBinaryVersion
            self.isUpdateAppVersion = isUpdateAppVersion
            self.packageHash = packageHash
            self.label = label
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.targetBinaryRange = try values.decodeIfPresent(String.self, forKey: "target_binary_range")
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
            self.isDisabled = try values.decodeIfPresent(Bool.self, forKey: "is_disabled")
            self.isMandatory = try values.decodeIfPresent(Bool.self, forKey: "is_mandatory")
            self.rollout = try values.decodeIfPresent(Int.self, forKey: "rollout")
            self.downloadURL = try values.decodeIfPresent(String.self, forKey: "download_url")
            self.isAvailable = try values.decodeIfPresent(Bool.self, forKey: "is_available")
            self.packageSize = try values.decodeIfPresent(Double.self, forKey: "package_size")
            self.shouldRunBinaryVersion = try values.decodeIfPresent(Bool.self, forKey: "should_run_binary_version")
            self.isUpdateAppVersion = try values.decodeIfPresent(Bool.self, forKey: "update_app_version")
            self.packageHash = try values.decodeIfPresent(String.self, forKey: "package_hash")
            self.label = try values.decodeIfPresent(String.self, forKey: "label")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(targetBinaryRange, forKey: "target_binary_range")
            try values.encodeIfPresent(description, forKey: "description")
            try values.encodeIfPresent(isDisabled, forKey: "is_disabled")
            try values.encodeIfPresent(isMandatory, forKey: "is_mandatory")
            try values.encodeIfPresent(rollout, forKey: "rollout")
            try values.encodeIfPresent(downloadURL, forKey: "download_url")
            try values.encodeIfPresent(isAvailable, forKey: "is_available")
            try values.encodeIfPresent(packageSize, forKey: "package_size")
            try values.encodeIfPresent(shouldRunBinaryVersion, forKey: "should_run_binary_version")
            try values.encodeIfPresent(isUpdateAppVersion, forKey: "update_app_version")
            try values.encodeIfPresent(packageHash, forKey: "package_hash")
            try values.encodeIfPresent(label, forKey: "label")
        }
    }

    public init(updateInfo: UpdateInfo) {
        self.updateInfo = updateInfo
    }

    private enum CodingKeys: String, CodingKey {
        case updateInfo = "update_info"
    }
}

public struct LegacyUpdateCheckResponse: Codable {
    public var updateInfo: UpdateInfo

    public struct UpdateInfo: Codable {
        public var appVersion: String?
        public var description: String?
        public var isDisabled: Bool?
        public var isMandatory: Bool?
        public var rollout: Int?
        public var downloadURL: String?
        public var isAvailable: Bool?
        public var packageSize: Double?
        public var shouldRunBinaryVersion: Bool?
        public var isUpdateAppVersion: Bool?
        public var packageHash: String?
        public var label: String?

        public init(appVersion: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, downloadURL: String? = nil, isAvailable: Bool? = nil, packageSize: Double? = nil, shouldRunBinaryVersion: Bool? = nil, isUpdateAppVersion: Bool? = nil, packageHash: String? = nil, label: String? = nil) {
            self.appVersion = appVersion
            self.description = description
            self.isDisabled = isDisabled
            self.isMandatory = isMandatory
            self.rollout = rollout
            self.downloadURL = downloadURL
            self.isAvailable = isAvailable
            self.packageSize = packageSize
            self.shouldRunBinaryVersion = shouldRunBinaryVersion
            self.isUpdateAppVersion = isUpdateAppVersion
            self.packageHash = packageHash
            self.label = label
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.appVersion = try values.decodeIfPresent(String.self, forKey: "appVersion")
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
            self.isDisabled = try values.decodeIfPresent(Bool.self, forKey: "isDisabled")
            self.isMandatory = try values.decodeIfPresent(Bool.self, forKey: "isMandatory")
            self.rollout = try values.decodeIfPresent(Int.self, forKey: "rollout")
            self.downloadURL = try values.decodeIfPresent(String.self, forKey: "downloadURL")
            self.isAvailable = try values.decodeIfPresent(Bool.self, forKey: "isAvailable")
            self.packageSize = try values.decodeIfPresent(Double.self, forKey: "packageSize")
            self.shouldRunBinaryVersion = try values.decodeIfPresent(Bool.self, forKey: "shouldRunBinaryVersion")
            self.isUpdateAppVersion = try values.decodeIfPresent(Bool.self, forKey: "updateAppVersion")
            self.packageHash = try values.decodeIfPresent(String.self, forKey: "packageHash")
            self.label = try values.decodeIfPresent(String.self, forKey: "label")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(appVersion, forKey: "appVersion")
            try values.encodeIfPresent(description, forKey: "description")
            try values.encodeIfPresent(isDisabled, forKey: "isDisabled")
            try values.encodeIfPresent(isMandatory, forKey: "isMandatory")
            try values.encodeIfPresent(rollout, forKey: "rollout")
            try values.encodeIfPresent(downloadURL, forKey: "downloadURL")
            try values.encodeIfPresent(isAvailable, forKey: "isAvailable")
            try values.encodeIfPresent(packageSize, forKey: "packageSize")
            try values.encodeIfPresent(shouldRunBinaryVersion, forKey: "shouldRunBinaryVersion")
            try values.encodeIfPresent(isUpdateAppVersion, forKey: "updateAppVersion")
            try values.encodeIfPresent(packageHash, forKey: "packageHash")
            try values.encodeIfPresent(label, forKey: "label")
        }
    }

    public init(updateInfo: UpdateInfo) {
        self.updateInfo = updateInfo
    }
}

public struct UpdateInfoData: Codable {
    public var targetBinaryRange: String?
    public var description: String?
    public var isDisabled: Bool?
    public var isMandatory: Bool?
    public var rollout: Int?
    public var downloadURL: String?
    public var isAvailable: Bool?
    public var packageSize: Double?
    public var shouldRunBinaryVersion: Bool?
    public var isUpdateAppVersion: Bool?
    public var packageHash: String?
    public var label: String?

    public init(targetBinaryRange: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, downloadURL: String? = nil, isAvailable: Bool? = nil, packageSize: Double? = nil, shouldRunBinaryVersion: Bool? = nil, isUpdateAppVersion: Bool? = nil, packageHash: String? = nil, label: String? = nil) {
        self.targetBinaryRange = targetBinaryRange
        self.description = description
        self.isDisabled = isDisabled
        self.isMandatory = isMandatory
        self.rollout = rollout
        self.downloadURL = downloadURL
        self.isAvailable = isAvailable
        self.packageSize = packageSize
        self.shouldRunBinaryVersion = shouldRunBinaryVersion
        self.isUpdateAppVersion = isUpdateAppVersion
        self.packageHash = packageHash
        self.label = label
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.targetBinaryRange = try values.decodeIfPresent(String.self, forKey: "target_binary_range")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.isDisabled = try values.decodeIfPresent(Bool.self, forKey: "is_disabled")
        self.isMandatory = try values.decodeIfPresent(Bool.self, forKey: "is_mandatory")
        self.rollout = try values.decodeIfPresent(Int.self, forKey: "rollout")
        self.downloadURL = try values.decodeIfPresent(String.self, forKey: "download_url")
        self.isAvailable = try values.decodeIfPresent(Bool.self, forKey: "is_available")
        self.packageSize = try values.decodeIfPresent(Double.self, forKey: "package_size")
        self.shouldRunBinaryVersion = try values.decodeIfPresent(Bool.self, forKey: "should_run_binary_version")
        self.isUpdateAppVersion = try values.decodeIfPresent(Bool.self, forKey: "update_app_version")
        self.packageHash = try values.decodeIfPresent(String.self, forKey: "package_hash")
        self.label = try values.decodeIfPresent(String.self, forKey: "label")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(targetBinaryRange, forKey: "target_binary_range")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(isDisabled, forKey: "is_disabled")
        try values.encodeIfPresent(isMandatory, forKey: "is_mandatory")
        try values.encodeIfPresent(rollout, forKey: "rollout")
        try values.encodeIfPresent(downloadURL, forKey: "download_url")
        try values.encodeIfPresent(isAvailable, forKey: "is_available")
        try values.encodeIfPresent(packageSize, forKey: "package_size")
        try values.encodeIfPresent(shouldRunBinaryVersion, forKey: "should_run_binary_version")
        try values.encodeIfPresent(isUpdateAppVersion, forKey: "update_app_version")
        try values.encodeIfPresent(packageHash, forKey: "package_hash")
        try values.encodeIfPresent(label, forKey: "label")
    }
}

public struct LegacyUpdateInfoData: Codable {
    public var appVersion: String?
    public var description: String?
    public var isDisabled: Bool?
    public var isMandatory: Bool?
    public var rollout: Int?
    public var downloadURL: String?
    public var isAvailable: Bool?
    public var packageSize: Double?
    public var shouldRunBinaryVersion: Bool?
    public var isUpdateAppVersion: Bool?
    public var packageHash: String?
    public var label: String?

    public init(appVersion: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, downloadURL: String? = nil, isAvailable: Bool? = nil, packageSize: Double? = nil, shouldRunBinaryVersion: Bool? = nil, isUpdateAppVersion: Bool? = nil, packageHash: String? = nil, label: String? = nil) {
        self.appVersion = appVersion
        self.description = description
        self.isDisabled = isDisabled
        self.isMandatory = isMandatory
        self.rollout = rollout
        self.downloadURL = downloadURL
        self.isAvailable = isAvailable
        self.packageSize = packageSize
        self.shouldRunBinaryVersion = shouldRunBinaryVersion
        self.isUpdateAppVersion = isUpdateAppVersion
        self.packageHash = packageHash
        self.label = label
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.appVersion = try values.decodeIfPresent(String.self, forKey: "appVersion")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.isDisabled = try values.decodeIfPresent(Bool.self, forKey: "isDisabled")
        self.isMandatory = try values.decodeIfPresent(Bool.self, forKey: "isMandatory")
        self.rollout = try values.decodeIfPresent(Int.self, forKey: "rollout")
        self.downloadURL = try values.decodeIfPresent(String.self, forKey: "downloadURL")
        self.isAvailable = try values.decodeIfPresent(Bool.self, forKey: "isAvailable")
        self.packageSize = try values.decodeIfPresent(Double.self, forKey: "packageSize")
        self.shouldRunBinaryVersion = try values.decodeIfPresent(Bool.self, forKey: "shouldRunBinaryVersion")
        self.isUpdateAppVersion = try values.decodeIfPresent(Bool.self, forKey: "updateAppVersion")
        self.packageHash = try values.decodeIfPresent(String.self, forKey: "packageHash")
        self.label = try values.decodeIfPresent(String.self, forKey: "label")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(appVersion, forKey: "appVersion")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(isDisabled, forKey: "isDisabled")
        try values.encodeIfPresent(isMandatory, forKey: "isMandatory")
        try values.encodeIfPresent(rollout, forKey: "rollout")
        try values.encodeIfPresent(downloadURL, forKey: "downloadURL")
        try values.encodeIfPresent(isAvailable, forKey: "isAvailable")
        try values.encodeIfPresent(packageSize, forKey: "packageSize")
        try values.encodeIfPresent(shouldRunBinaryVersion, forKey: "shouldRunBinaryVersion")
        try values.encodeIfPresent(isUpdateAppVersion, forKey: "updateAppVersion")
        try values.encodeIfPresent(packageHash, forKey: "packageHash")
        try values.encodeIfPresent(label, forKey: "label")
    }
}

public struct AppName: Codable {
    public var name: String

    public init(name: String) {
        self.name = name
    }
}

public struct AcquisitionStatusSuccessResponse: Codable {
    /// The code indicating the status
    public var code: String
    /// The message indicating the status
    public var message: String

    public init(code: String, message: String) {
        self.code = code
        self.message = message
    }
}

public struct GDPRPurgeVerifyRequest: Codable {
    /// Deployment id
    public var id: String
    /// Deployment key
    public var key: String

    public init(id: String, key: String) {
        self.id = id
        self.key = key
    }
}

public struct GDPRPurgeVerifyResponse: Codable {
    /// Indicate whether GDPR purge operation succeeds or not
    public var isSuccess: Bool

    public init(isSuccess: Bool) {
        self.isSuccess = isSuccess
    }

    private enum CodingKeys: String, CodingKey {
        case isSuccess = "success"
    }
}

public struct LegacyDeploymentsResponse: Codable {
    public var deployments: [Deploymants]?

    public struct Deploymants: Codable {
        /// Time at which the deployment was created as a Unix timestamp.
        public var createdTime: Int?
        /// The ID of the deployment (internal use only).
        public var id: String?
        /// Deployment key (aka Deployment Id)
        public var key: String?
        /// Updated deployment name
        public var name: String
        public var package: Package?

        public struct Package: Codable {
            /// The version of the release
            public var appVersion: String?
            /// Flag used to determine if release is disabled
            public var isDisabled: Bool?
            /// Flag used to determine if release is mandatory
            public var isMandatory: Bool?
            /// Percentage (out of 100) that release is deployed to
            public var rollout: Int?
            /// Location (URL) of release package
            public var blobURL: String?
            /// Size of release package
            public var size: Int?
            /// Method used to deploy release
            public var releaseMethod: String?
            /// Release upload time as epoch Unix timestamp
            public var uploadTime: Int?
            /// Release label (aka release name)
            public var label: String?
            /// User ID that triggered most recent release
            public var releasedByUserID: String?
            /// The URL location of the package's manifest file.
            public var manifestBlobURL: String?
            /// Object containing URL and size of changed package hashes contained in the release
            public var diffPackageMap: [String: AnyJSON]?

            public init(appVersion: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, blobURL: String? = nil, size: Int? = nil, releaseMethod: String? = nil, uploadTime: Int? = nil, label: String? = nil, releasedByUserID: String? = nil, manifestBlobURL: String? = nil, diffPackageMap: [String: AnyJSON]? = nil) {
                self.appVersion = appVersion
                self.isDisabled = isDisabled
                self.isMandatory = isMandatory
                self.rollout = rollout
                self.blobURL = blobURL
                self.size = size
                self.releaseMethod = releaseMethod
                self.uploadTime = uploadTime
                self.label = label
                self.releasedByUserID = releasedByUserID
                self.manifestBlobURL = manifestBlobURL
                self.diffPackageMap = diffPackageMap
            }

            private enum CodingKeys: String, CodingKey {
                case appVersion
                case isDisabled
                case isMandatory
                case rollout
                case blobURL = "blobUrl"
                case size
                case releaseMethod
                case uploadTime
                case label
                case releasedByUserID = "releasedByUserId"
                case manifestBlobURL = "manifestBlobUrl"
                case diffPackageMap
            }
        }

        public init(createdTime: Int? = nil, id: String? = nil, key: String? = nil, name: String, package: Package? = nil) {
            self.createdTime = createdTime
            self.id = id
            self.key = key
            self.name = name
            self.package = package
        }
    }

    public init(deployments: [Deploymants]? = nil) {
        self.deployments = deployments
    }
}

public struct LegacyDeploymentResponse: Codable {
    public var deployment: [String: Deploymant]?

    public struct Deploymant: Codable {
        /// Time at which the deployment was created as a Unix timestamp.
        public var createdTime: Int?
        /// The ID of the deployment (internal use only).
        public var id: String?
        /// Deployment key (aka Deployment Id)
        public var key: String?
        /// Updated deployment name
        public var name: String
        public var package: Package?

        public struct Package: Codable {
            /// The version of the release
            public var appVersion: String?
            /// Flag used to determine if release is disabled
            public var isDisabled: Bool?
            /// Flag used to determine if release is mandatory
            public var isMandatory: Bool?
            /// Percentage (out of 100) that release is deployed to
            public var rollout: Int?
            /// Location (URL) of release package
            public var blobURL: String?
            /// Size of release package
            public var size: Int?
            /// Method used to deploy release
            public var releaseMethod: String?
            /// Release upload time as epoch Unix timestamp
            public var uploadTime: Int?
            /// Release label (aka release name)
            public var label: String?
            /// User ID that triggered most recent release
            public var releasedByUserID: String?
            /// The URL location of the package's manifest file.
            public var manifestBlobURL: String?
            /// Object containing URL and size of changed package hashes contained in the release
            public var diffPackageMap: [String: AnyJSON]?

            public init(appVersion: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, blobURL: String? = nil, size: Int? = nil, releaseMethod: String? = nil, uploadTime: Int? = nil, label: String? = nil, releasedByUserID: String? = nil, manifestBlobURL: String? = nil, diffPackageMap: [String: AnyJSON]? = nil) {
                self.appVersion = appVersion
                self.isDisabled = isDisabled
                self.isMandatory = isMandatory
                self.rollout = rollout
                self.blobURL = blobURL
                self.size = size
                self.releaseMethod = releaseMethod
                self.uploadTime = uploadTime
                self.label = label
                self.releasedByUserID = releasedByUserID
                self.manifestBlobURL = manifestBlobURL
                self.diffPackageMap = diffPackageMap
            }

            private enum CodingKeys: String, CodingKey {
                case appVersion
                case isDisabled
                case isMandatory
                case rollout
                case blobURL = "blobUrl"
                case size
                case releaseMethod
                case uploadTime
                case label
                case releasedByUserID = "releasedByUserId"
                case manifestBlobURL = "manifestBlobUrl"
                case diffPackageMap
            }
        }

        public init(createdTime: Int? = nil, id: String? = nil, key: String? = nil, name: String, package: Package? = nil) {
            self.createdTime = createdTime
            self.id = id
            self.key = key
            self.name = name
            self.package = package
        }
    }

    public init(deployment: [String: Deploymant]? = nil) {
        self.deployment = deployment
    }
}

public struct LegacyDeployment: Codable {
    /// Time at which the deployment was created as a Unix timestamp.
    public var createdTime: Int?
    /// The ID of the deployment (internal use only).
    public var id: String?
    /// Deployment key (aka Deployment Id)
    public var key: String?
    /// Updated deployment name
    public var name: String
    public var package: Package?

    public struct Package: Codable {
        /// The version of the release
        public var appVersion: String?
        /// Flag used to determine if release is disabled
        public var isDisabled: Bool?
        /// Flag used to determine if release is mandatory
        public var isMandatory: Bool?
        /// Percentage (out of 100) that release is deployed to
        public var rollout: Int?
        /// Location (URL) of release package
        public var blobURL: String?
        /// Size of release package
        public var size: Int?
        /// Method used to deploy release
        public var releaseMethod: String?
        /// Release upload time as epoch Unix timestamp
        public var uploadTime: Int?
        /// Release label (aka release name)
        public var label: String?
        /// User ID that triggered most recent release
        public var releasedByUserID: String?
        /// The URL location of the package's manifest file.
        public var manifestBlobURL: String?
        /// Object containing URL and size of changed package hashes contained in the release
        public var diffPackageMap: [String: AnyJSON]?

        public init(appVersion: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, blobURL: String? = nil, size: Int? = nil, releaseMethod: String? = nil, uploadTime: Int? = nil, label: String? = nil, releasedByUserID: String? = nil, manifestBlobURL: String? = nil, diffPackageMap: [String: AnyJSON]? = nil) {
            self.appVersion = appVersion
            self.isDisabled = isDisabled
            self.isMandatory = isMandatory
            self.rollout = rollout
            self.blobURL = blobURL
            self.size = size
            self.releaseMethod = releaseMethod
            self.uploadTime = uploadTime
            self.label = label
            self.releasedByUserID = releasedByUserID
            self.manifestBlobURL = manifestBlobURL
            self.diffPackageMap = diffPackageMap
        }

        private enum CodingKeys: String, CodingKey {
            case appVersion
            case isDisabled
            case isMandatory
            case rollout
            case blobURL = "blobUrl"
            case size
            case releaseMethod
            case uploadTime
            case label
            case releasedByUserID = "releasedByUserId"
            case manifestBlobURL = "manifestBlobUrl"
            case diffPackageMap
        }
    }

    public init(createdTime: Int? = nil, id: String? = nil, key: String? = nil, name: String, package: Package? = nil) {
        self.createdTime = createdTime
        self.id = id
        self.key = key
        self.name = name
        self.package = package
    }
}

public struct LegacyDeploymentHistoryResponse: Codable {
    /// Array containing the deployment's package history.
    public var history: [HistoryItem]?

    /// Information about a specific release.
    public struct HistoryItem: Codable {
        public var allOf: AllOf?
        /// The description of the release.
        public var description: String?
        /// The original deployment of the release, if it's ever been promoted.
        public var originalDeployment: String?
        /// The original label of the release, if it's ever been updated.
        public var originalLabel: String?
        /// The package's hash value (internal use).
        public var packageHash: String?

        public struct AllOf: Codable {
            /// The version of the release
            public var appVersion: String?
            /// Flag used to determine if release is disabled
            public var isDisabled: Bool?
            /// Flag used to determine if release is mandatory
            public var isMandatory: Bool?
            /// Percentage (out of 100) that release is deployed to
            public var rollout: Int?
            /// Location (URL) of release package
            public var blobURL: String?
            /// Size of release package
            public var size: Int?
            /// Method used to deploy release
            public var releaseMethod: String?
            /// Release upload time as epoch Unix timestamp
            public var uploadTime: Int?
            /// Release label (aka release name)
            public var label: String?
            /// User ID that triggered most recent release
            public var releasedByUserID: String?
            /// The URL location of the package's manifest file.
            public var manifestBlobURL: String?
            /// Object containing URL and size of changed package hashes contained in the release
            public var diffPackageMap: [String: AnyJSON]?

            public init(appVersion: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, blobURL: String? = nil, size: Int? = nil, releaseMethod: String? = nil, uploadTime: Int? = nil, label: String? = nil, releasedByUserID: String? = nil, manifestBlobURL: String? = nil, diffPackageMap: [String: AnyJSON]? = nil) {
                self.appVersion = appVersion
                self.isDisabled = isDisabled
                self.isMandatory = isMandatory
                self.rollout = rollout
                self.blobURL = blobURL
                self.size = size
                self.releaseMethod = releaseMethod
                self.uploadTime = uploadTime
                self.label = label
                self.releasedByUserID = releasedByUserID
                self.manifestBlobURL = manifestBlobURL
                self.diffPackageMap = diffPackageMap
            }

            private enum CodingKeys: String, CodingKey {
                case appVersion
                case isDisabled
                case isMandatory
                case rollout
                case blobURL = "blobUrl"
                case size
                case releaseMethod
                case uploadTime
                case label
                case releasedByUserID = "releasedByUserId"
                case manifestBlobURL = "manifestBlobUrl"
                case diffPackageMap
            }
        }

        public init(allOf: AllOf? = nil, description: String? = nil, originalDeployment: String? = nil, originalLabel: String? = nil, packageHash: String? = nil) {
            self.allOf = allOf
            self.description = description
            self.originalDeployment = originalDeployment
            self.originalLabel = originalLabel
            self.packageHash = packageHash
        }
    }

    public init(history: [HistoryItem]? = nil) {
        self.history = history
    }
}

/// Information about a specific release.
public struct LegacyDeploymentHistory: Codable {
    public var allOf: AllOf?
    /// The description of the release.
    public var description: String?
    /// The original deployment of the release, if it's ever been promoted.
    public var originalDeployment: String?
    /// The original label of the release, if it's ever been updated.
    public var originalLabel: String?
    /// The package's hash value (internal use).
    public var packageHash: String?

    public struct AllOf: Codable {
        /// The version of the release
        public var appVersion: String?
        /// Flag used to determine if release is disabled
        public var isDisabled: Bool?
        /// Flag used to determine if release is mandatory
        public var isMandatory: Bool?
        /// Percentage (out of 100) that release is deployed to
        public var rollout: Int?
        /// Location (URL) of release package
        public var blobURL: String?
        /// Size of release package
        public var size: Int?
        /// Method used to deploy release
        public var releaseMethod: String?
        /// Release upload time as epoch Unix timestamp
        public var uploadTime: Int?
        /// Release label (aka release name)
        public var label: String?
        /// User ID that triggered most recent release
        public var releasedByUserID: String?
        /// The URL location of the package's manifest file.
        public var manifestBlobURL: String?
        /// Object containing URL and size of changed package hashes contained in the release
        public var diffPackageMap: [String: AnyJSON]?

        public init(appVersion: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, blobURL: String? = nil, size: Int? = nil, releaseMethod: String? = nil, uploadTime: Int? = nil, label: String? = nil, releasedByUserID: String? = nil, manifestBlobURL: String? = nil, diffPackageMap: [String: AnyJSON]? = nil) {
            self.appVersion = appVersion
            self.isDisabled = isDisabled
            self.isMandatory = isMandatory
            self.rollout = rollout
            self.blobURL = blobURL
            self.size = size
            self.releaseMethod = releaseMethod
            self.uploadTime = uploadTime
            self.label = label
            self.releasedByUserID = releasedByUserID
            self.manifestBlobURL = manifestBlobURL
            self.diffPackageMap = diffPackageMap
        }

        private enum CodingKeys: String, CodingKey {
            case appVersion
            case isDisabled
            case isMandatory
            case rollout
            case blobURL = "blobUrl"
            case size
            case releaseMethod
            case uploadTime
            case label
            case releasedByUserID = "releasedByUserId"
            case manifestBlobURL = "manifestBlobUrl"
            case diffPackageMap
        }
    }

    public init(allOf: AllOf? = nil, description: String? = nil, originalDeployment: String? = nil, originalLabel: String? = nil, packageHash: String? = nil) {
        self.allOf = allOf
        self.description = description
        self.originalDeployment = originalDeployment
        self.originalLabel = originalLabel
        self.packageHash = packageHash
    }
}

public struct LegacyDeploymentMetricsResponse: Codable {
    /// Object containing a property named after each release label, which contains an object that contains that release's metrics.
    public var metrics: [String: Metric]?

    public struct Metric: Codable {
        /// The number of devices that have this release installed currently
        public var active: Int
        /// The number of times this release has been installed on a device
        public var installed: Int?
        /// The number of times this release has been downloaded
        public var downloaded: Int?
        /// The number of times this release has failed to be installed on a device
        public var failed: Int?

        public init(active: Int, installed: Int? = nil, downloaded: Int? = nil, failed: Int? = nil) {
            self.active = active
            self.installed = installed
            self.downloaded = downloaded
            self.failed = failed
        }
    }

    public init(metrics: [String: Metric]? = nil) {
        self.metrics = metrics
    }
}

public struct LegacyDeploymentMetric: Codable {
    /// The number of devices that have this release installed currently
    public var active: Int
    /// The number of times this release has been installed on a device
    public var installed: Int?
    /// The number of times this release has been downloaded
    public var downloaded: Int?
    /// The number of times this release has failed to be installed on a device
    public var failed: Int?

    public init(active: Int, installed: Int? = nil, downloaded: Int? = nil, failed: Int? = nil) {
        self.active = active
        self.installed = installed
        self.downloaded = downloaded
        self.failed = failed
    }
}

public struct LegacyCodePushRelease: Codable {
    /// The version of the release
    public var appVersion: String?
    /// Flag used to determine if release is disabled
    public var isDisabled: Bool?
    /// Flag used to determine if release is mandatory
    public var isMandatory: Bool?
    /// Percentage (out of 100) that release is deployed to
    public var rollout: Int?
    /// Location (URL) of release package
    public var blobURL: String?
    /// Size of release package
    public var size: Int?
    /// Method used to deploy release
    public var releaseMethod: String?
    /// Release upload time as epoch Unix timestamp
    public var uploadTime: Int?
    /// Release label (aka release name)
    public var label: String?
    /// User ID that triggered most recent release
    public var releasedByUserID: String?
    /// The URL location of the package's manifest file.
    public var manifestBlobURL: String?
    /// Object containing URL and size of changed package hashes contained in the release
    public var diffPackageMap: [String: AnyJSON]?

    public init(appVersion: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, blobURL: String? = nil, size: Int? = nil, releaseMethod: String? = nil, uploadTime: Int? = nil, label: String? = nil, releasedByUserID: String? = nil, manifestBlobURL: String? = nil, diffPackageMap: [String: AnyJSON]? = nil) {
        self.appVersion = appVersion
        self.isDisabled = isDisabled
        self.isMandatory = isMandatory
        self.rollout = rollout
        self.blobURL = blobURL
        self.size = size
        self.releaseMethod = releaseMethod
        self.uploadTime = uploadTime
        self.label = label
        self.releasedByUserID = releasedByUserID
        self.manifestBlobURL = manifestBlobURL
        self.diffPackageMap = diffPackageMap
    }

    private enum CodingKeys: String, CodingKey {
        case appVersion
        case isDisabled
        case isMandatory
        case rollout
        case blobURL = "blobUrl"
        case size
        case releaseMethod
        case uploadTime
        case label
        case releasedByUserID = "releasedByUserId"
        case manifestBlobURL = "manifestBlobUrl"
        case diffPackageMap
    }
}

public struct LegacyCodePushReleaseModification: Codable {
    /// The release package information
    public var packageInfo: [String: AnyJSON]

    public init(packageInfo: [String: AnyJSON]) {
        self.packageInfo = packageInfo
    }
}

public struct LegacyCodePushReleaseResponse: Codable {
    public var package: Package

    public struct Package: Codable {
        /// The version of the release
        public var appVersion: String?
        /// Flag used to determine if release is disabled
        public var isDisabled: Bool?
        /// Flag used to determine if release is mandatory
        public var isMandatory: Bool?
        /// Percentage (out of 100) that release is deployed to
        public var rollout: Int?
        /// Location (URL) of release package
        public var blobURL: String?
        /// Size of release package
        public var size: Int?
        /// Method used to deploy release
        public var releaseMethod: String?
        /// Release upload time as epoch Unix timestamp
        public var uploadTime: Int?
        /// Release label (aka release name)
        public var label: String?
        /// User ID that triggered most recent release
        public var releasedByUserID: String?
        /// The URL location of the package's manifest file.
        public var manifestBlobURL: String?
        /// Object containing URL and size of changed package hashes contained in the release
        public var diffPackageMap: [String: AnyJSON]?

        public init(appVersion: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, blobURL: String? = nil, size: Int? = nil, releaseMethod: String? = nil, uploadTime: Int? = nil, label: String? = nil, releasedByUserID: String? = nil, manifestBlobURL: String? = nil, diffPackageMap: [String: AnyJSON]? = nil) {
            self.appVersion = appVersion
            self.isDisabled = isDisabled
            self.isMandatory = isMandatory
            self.rollout = rollout
            self.blobURL = blobURL
            self.size = size
            self.releaseMethod = releaseMethod
            self.uploadTime = uploadTime
            self.label = label
            self.releasedByUserID = releasedByUserID
            self.manifestBlobURL = manifestBlobURL
            self.diffPackageMap = diffPackageMap
        }

        private enum CodingKeys: String, CodingKey {
            case appVersion
            case isDisabled
            case isMandatory
            case rollout
            case blobURL = "blobUrl"
            case size
            case releaseMethod
            case uploadTime
            case label
            case releasedByUserID = "releasedByUserId"
            case manifestBlobURL = "manifestBlobUrl"
            case diffPackageMap
        }
    }

    public init(package: Package) {
        self.package = package
    }
}

public struct LegacyAuthenticationResponse: Codable {
    /// The authentication status of the user.
    public var isAuthenticated: Bool?

    public init(isAuthenticated: Bool? = nil) {
        self.isAuthenticated = isAuthenticated
    }

    private enum CodingKeys: String, CodingKey {
        case isAuthenticated = "authenticated"
    }
}

public struct LegacyAccountResponse: Codable {
    /// Object containing the account information.
    public var account: [String: AccountItem]?

    public struct AccountItem: Codable {
        /// The account name of the calling user.
        public var name: String?
        /// The calling user's email.
        public var email: String?
        /// Array of linked authentication providers associated with the account.
        public var linkedProviders: [String]?

        public init(name: String? = nil, email: String? = nil, linkedProviders: [String]? = nil) {
            self.name = name
            self.email = email
            self.linkedProviders = linkedProviders
        }
    }

    public init(account: [String: AccountItem]? = nil) {
        self.account = account
    }
}

public struct LegacyAccount: Codable {
    /// The account name of the calling user.
    public var name: String?
    /// The calling user's email.
    public var email: String?
    /// Array of linked authentication providers associated with the account.
    public var linkedProviders: [String]?

    public init(name: String? = nil, email: String? = nil, linkedProviders: [String]? = nil) {
        self.name = name
        self.email = email
        self.linkedProviders = linkedProviders
    }
}

public struct LegacyAppListResponse: Codable {
    public var apps: [App]?

    public struct App: Codable {
        /// The app name.
        public var name: String?
        public var collaborators: [String: Collaborator]?
        public var deployments: [String]?

        public struct Collaborator: Codable {
            /// Is current collaborator the same as current account.
            public var isCurrentAccount: Bool?
            /// Which permission does current account has.
            public var permission: String?

            public init(isCurrentAccount: Bool? = nil, permission: String? = nil) {
                self.isCurrentAccount = isCurrentAccount
                self.permission = permission
            }
        }

        public init(name: String? = nil, collaborators: [String: Collaborator]? = nil, deployments: [String]? = nil) {
            self.name = name
            self.collaborators = collaborators
            self.deployments = deployments
        }
    }

    public init(apps: [App]? = nil) {
        self.apps = apps
    }
}

public struct LegacyAppResponse: Codable {
    public var app: App?

    public struct App: Codable {
        /// The app name.
        public var name: String?
        public var collaborators: [String: Collaborator]?
        public var deployments: [String]?

        public struct Collaborator: Codable {
            /// Is current collaborator the same as current account.
            public var isCurrentAccount: Bool?
            /// Which permission does current account has.
            public var permission: String?

            public init(isCurrentAccount: Bool? = nil, permission: String? = nil) {
                self.isCurrentAccount = isCurrentAccount
                self.permission = permission
            }
        }

        public init(name: String? = nil, collaborators: [String: Collaborator]? = nil, deployments: [String]? = nil) {
            self.name = name
            self.collaborators = collaborators
            self.deployments = deployments
        }
    }

    public init(app: App? = nil) {
        self.app = app
    }
}

public struct LegacyApp: Codable {
    /// The app name.
    public var name: String?
    public var collaborators: [String: Collaborator]?
    public var deployments: [String]?

    public struct Collaborator: Codable {
        /// Is current collaborator the same as current account.
        public var isCurrentAccount: Bool?
        /// Which permission does current account has.
        public var permission: String?

        public init(isCurrentAccount: Bool? = nil, permission: String? = nil) {
            self.isCurrentAccount = isCurrentAccount
            self.permission = permission
        }
    }

    public init(name: String? = nil, collaborators: [String: Collaborator]? = nil, deployments: [String]? = nil) {
        self.name = name
        self.collaborators = collaborators
        self.deployments = deployments
    }
}

public struct LegacyCollaborator: Codable {
    /// Is current collaborator the same as current account.
    public var isCurrentAccount: Bool?
    /// Which permission does current account has.
    public var permission: String?

    public init(isCurrentAccount: Bool? = nil, permission: String? = nil) {
        self.isCurrentAccount = isCurrentAccount
        self.permission = permission
    }
}

public struct LegacyCollaborators: Codable {
    public var collaborators: [String: Collaborator]?

    public struct Collaborator: Codable {
        /// Is current collaborator the same as current account.
        public var isCurrentAccount: Bool?
        /// Which permission does current account has.
        public var permission: String?

        public init(isCurrentAccount: Bool? = nil, permission: String? = nil) {
            self.isCurrentAccount = isCurrentAccount
            self.permission = permission
        }
    }

    public init(collaborators: [String: Collaborator]? = nil) {
        self.collaborators = collaborators
    }
}

public struct LegacyCodePushApp: Codable {
    /// The app name.
    public var name: String
    /// The app os.
    public var os: String?
    /// The app platform.
    public var platform: String?
    /// Whether the user provided their own deployments. Not currently in use.
    public var isManuallyProvisionDeployments: Bool?

    public init(name: String, os: String? = nil, platform: String? = nil, isManuallyProvisionDeployments: Bool? = nil) {
        self.name = name
        self.os = os
        self.platform = platform
        self.isManuallyProvisionDeployments = isManuallyProvisionDeployments
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case os
        case platform
        case isManuallyProvisionDeployments = "manuallyProvisionDeployments"
    }
}

public struct CreateAccessKeyRequest: Codable {
    /// Name of creator current access key
    public var createdBy: String?
    /// Friendly name of the access key
    public var friendlyName: String?
    /// Time to live of the access key
    public var ttl: Double?

    public init(createdBy: String? = nil, friendlyName: String? = nil, ttl: Double? = nil) {
        self.createdBy = createdBy
        self.friendlyName = friendlyName
        self.ttl = ttl
    }
}

public struct CreateAccessKeyResponse: Codable {
    public var accessKey: AccessKey?

    public struct AccessKey: Codable {
        /// Key of access key
        public var name: String?
        /// Account name of creator.
        public var createdBy: String?
        /// Description of access key
        public var description: String?
        /// Friendly name of access key
        public var friendlyName: String?
        /// Created time of access key
        public var createdTime: Double?
        /// Time of expiry of access key
        public var expires: Double?
        /// Id of accessKey
        public var id: String?
        /// Legacy property which indicate if accessKey was created from session
        public var isSession: Bool?

        public init(name: String? = nil, createdBy: String? = nil, description: String? = nil, friendlyName: String? = nil, createdTime: Double? = nil, expires: Double? = nil, id: String? = nil, isSession: Bool? = nil) {
            self.name = name
            self.createdBy = createdBy
            self.description = description
            self.friendlyName = friendlyName
            self.createdTime = createdTime
            self.expires = expires
            self.id = id
            self.isSession = isSession
        }
    }

    public init(accessKey: AccessKey? = nil) {
        self.accessKey = accessKey
    }
}

public struct AccessKey: Codable {
    /// Key of access key
    public var name: String?
    /// Account name of creator.
    public var createdBy: String?
    /// Description of access key
    public var description: String?
    /// Friendly name of access key
    public var friendlyName: String?
    /// Created time of access key
    public var createdTime: Double?
    /// Time of expiry of access key
    public var expires: Double?
    /// Id of accessKey
    public var id: String?
    /// Legacy property which indicate if accessKey was created from session
    public var isSession: Bool?

    public init(name: String? = nil, createdBy: String? = nil, description: String? = nil, friendlyName: String? = nil, createdTime: Double? = nil, expires: Double? = nil, id: String? = nil, isSession: Bool? = nil) {
        self.name = name
        self.createdBy = createdBy
        self.description = description
        self.friendlyName = friendlyName
        self.createdTime = createdTime
        self.expires = expires
        self.id = id
        self.isSession = isSession
    }
}

public struct AccessKeyListResponse: Codable {
    /// Array containing the list of existing AccessKeys
    public var accessKeys: [AccessKey]?

    public struct AccessKey: Codable {
        /// Key of access key
        public var name: String?
        /// Account name of creator.
        public var createdBy: String?
        /// Description of access key
        public var description: String?
        /// Friendly name of access key
        public var friendlyName: String?
        /// Created time of access key
        public var createdTime: Double?
        /// Time of expiry of access key
        public var expires: Double?
        /// Id of accessKey
        public var id: String?
        /// Legacy property which indicate if accessKey was created from session
        public var isSession: Bool?

        public init(name: String? = nil, createdBy: String? = nil, description: String? = nil, friendlyName: String? = nil, createdTime: Double? = nil, expires: Double? = nil, id: String? = nil, isSession: Bool? = nil) {
            self.name = name
            self.createdBy = createdBy
            self.description = description
            self.friendlyName = friendlyName
            self.createdTime = createdTime
            self.expires = expires
            self.id = id
            self.isSession = isSession
        }
    }

    public init(accessKeys: [AccessKey]? = nil) {
        self.accessKeys = accessKeys
    }
}

public struct Symbol: Codable {
    /// The unique id for this symbol (uuid)
    public var symbolID: String
    /// The type of the symbol for the current symbol upload
    public var type: `Type`
    /// The application that this symbol belongs to
    public var appID: String
    /// The platform that this symbol is associated with
    public var platform: String
    /// The path name of the symbol file in blob storage
    public var url: String
    /// The origin of the symbol file
    public var origin: Origin
    /// The other symbols in the same file
    public var alternateSymbolIDs: [String]
    /// Whether the symbol is ignored.
    public var status: Status
    /// The version number. Optional for Apple. Required for Android.
    public var version: String?
    /// The build number. Optional for Apple. Required for Android.
    public var build: String?
    /// The id of the symbol upload this symbol belongs to.
    public var symbolUploadID: String

    /// The type of the symbol for the current symbol upload
    public enum `Type`: String, Codable, CaseIterable {
        case apple = "Apple"
        case javaScript = "JavaScript"
        case breakpad = "Breakpad"
        case androidProguard = "AndroidProguard"
        case uwp = "UWP"
    }

    /// The origin of the symbol file
    public enum Origin: String, Codable, CaseIterable {
        case system = "System"
        case user = "User"
    }

    /// Whether the symbol is ignored.
    public enum Status: String, Codable, CaseIterable {
        case available
        case ignored
    }

    public init(symbolID: String, type: `Type`, appID: String, platform: String, url: String, origin: Origin, alternateSymbolIDs: [String], status: Status, version: String? = nil, build: String? = nil, symbolUploadID: String) {
        self.symbolID = symbolID
        self.type = type
        self.appID = appID
        self.platform = platform
        self.url = url
        self.origin = origin
        self.alternateSymbolIDs = alternateSymbolIDs
        self.status = status
        self.version = version
        self.build = build
        self.symbolUploadID = symbolUploadID
    }

    private enum CodingKeys: String, CodingKey {
        case symbolID = "symbol_id"
        case type
        case appID = "app_id"
        case platform
        case url
        case origin
        case alternateSymbolIDs = "alternate_symbol_ids"
        case status
        case version
        case build
        case symbolUploadID = "symbol_upload_id"
    }
}

public struct SymbolsItem: Codable {
    /// The unique id for this symbol (uuid)
    public var symbolID: String
    /// The type of the symbol for the current symbol upload
    public var type: `Type`
    /// The application that this symbol belongs to
    public var appID: String
    /// The platform that this symbol is associated with
    public var platform: String
    /// The path name of the symbol file in blob storage
    public var url: String
    /// The origin of the symbol file
    public var origin: Origin
    /// The other symbols in the same file
    public var alternateSymbolIDs: [String]
    /// Whether the symbol is ignored.
    public var status: Status
    /// The version number. Optional for Apple. Required for Android.
    public var version: String?
    /// The build number. Optional for Apple. Required for Android.
    public var build: String?
    /// The id of the symbol upload this symbol belongs to.
    public var symbolUploadID: String

    /// The type of the symbol for the current symbol upload
    public enum `Type`: String, Codable, CaseIterable {
        case apple = "Apple"
        case javaScript = "JavaScript"
        case breakpad = "Breakpad"
        case androidProguard = "AndroidProguard"
        case uwp = "UWP"
    }

    /// The origin of the symbol file
    public enum Origin: String, Codable, CaseIterable {
        case system = "System"
        case user = "User"
    }

    /// Whether the symbol is ignored.
    public enum Status: String, Codable, CaseIterable {
        case available
        case ignored
    }

    public init(symbolID: String, type: `Type`, appID: String, platform: String, url: String, origin: Origin, alternateSymbolIDs: [String], status: Status, version: String? = nil, build: String? = nil, symbolUploadID: String) {
        self.symbolID = symbolID
        self.type = type
        self.appID = appID
        self.platform = platform
        self.url = url
        self.origin = origin
        self.alternateSymbolIDs = alternateSymbolIDs
        self.status = status
        self.version = version
        self.build = build
        self.symbolUploadID = symbolUploadID
    }

    private enum CodingKeys: String, CodingKey {
        case symbolID = "symbol_id"
        case type
        case appID = "app_id"
        case platform
        case url
        case origin
        case alternateSymbolIDs = "alternate_symbol_ids"
        case status
        case version
        case build
        case symbolUploadID = "symbol_upload_id"
    }
}

/// A response containing information pertaining to a symbol status
public struct SymbolStatusResponse: Codable {
    /// The unique id for this symbol (uuid)
    public var symbolID: String
    /// The application that this symbol belongs to
    public var appID: String
    /// Whether the symbol is ignored.
    public var status: Status

    /// Whether the symbol is ignored.
    public enum Status: String, Codable, CaseIterable {
        case available
        case ignored
        case missing
    }

    public init(symbolID: String, appID: String, status: Status) {
        self.symbolID = symbolID
        self.appID = appID
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case symbolID = "symbol_id"
        case appID = "app_id"
        case status
    }
}

/// A single symbol upload entity
public struct SymbolUpload: Codable {
    /// The id for the current symbol upload
    public var symbolUploadID: String
    /// The application that this symbol upload belongs to
    public var appID: String
    /// User information of the one who intitiated the symbol upload
    public var user: User?
    /// The current status for the symbol upload
    public var status: Status
    /// The type of the symbol for the current symbol upload
    public var symbolType: SymbolType
    /// The symbols found in the upload. This may be empty until the status is indexed
    public var symbolsUploaded: [SymbolsUploadedItem]?
    /// The origin of the symbol upload
    public var origin: Origin?
    /// The file name for the symbol upload
    public var fileName: String?
    /// The size of the file in Mebibytes. This may be 0 until the status is indexed
    public var fileSize: Double?
    /// When the symbol upload was committed, or last transaction time if not committed
    public var timestamp: Date?

    /// User information of the one who intitiated the symbol upload
    public struct User: Codable {
        /// The email of the user
        public var email: String?
        /// The full name of the user. Might for example be first and last name
        public var displayName: String?

        public init(email: String? = nil, displayName: String? = nil) {
            self.email = email
            self.displayName = displayName
        }

        private enum CodingKeys: String, CodingKey {
            case email
            case displayName = "display_name"
        }
    }

    /// The current status for the symbol upload
    public enum Status: String, Codable, CaseIterable {
        case created
        case committed
        case aborted
        case processing
        case indexed
        case failed
    }

    /// The type of the symbol for the current symbol upload
    public enum SymbolType: String, Codable, CaseIterable {
        case apple = "Apple"
        case javaScript = "JavaScript"
        case breakpad = "Breakpad"
        case androidProguard = "AndroidProguard"
        case uwp = "UWP"
    }

    public struct SymbolsUploadedItem: Codable {
        /// The symbol id of the symbol binary
        public var symbolID: String
        /// The platform the symbol is associated with
        public var platform: String

        public init(symbolID: String, platform: String) {
            self.symbolID = symbolID
            self.platform = platform
        }

        private enum CodingKeys: String, CodingKey {
            case symbolID = "symbol_id"
            case platform
        }
    }

    /// The origin of the symbol upload
    public enum Origin: String, Codable, CaseIterable {
        case user = "User"
        case system = "System"
    }

    public init(symbolUploadID: String, appID: String, user: User? = nil, status: Status, symbolType: SymbolType, symbolsUploaded: [SymbolsUploadedItem]? = nil, origin: Origin? = nil, fileName: String? = nil, fileSize: Double? = nil, timestamp: Date? = nil) {
        self.symbolUploadID = symbolUploadID
        self.appID = appID
        self.user = user
        self.status = status
        self.symbolType = symbolType
        self.symbolsUploaded = symbolsUploaded
        self.origin = origin
        self.fileName = fileName
        self.fileSize = fileSize
        self.timestamp = timestamp
    }

    private enum CodingKeys: String, CodingKey {
        case symbolUploadID = "symbol_upload_id"
        case appID = "app_id"
        case user
        case status
        case symbolType = "symbol_type"
        case symbolsUploaded = "symbols_uploaded"
        case origin
        case fileName = "file_name"
        case fileSize = "file_size"
        case timestamp
    }
}

/// A single symbol upload entity
public struct SymbolUploadsItem: Codable {
    /// The id for the current symbol upload
    public var symbolUploadID: String
    /// The application that this symbol upload belongs to
    public var appID: String
    /// User information of the one who intitiated the symbol upload
    public var user: User?
    /// The current status for the symbol upload
    public var status: Status
    /// The type of the symbol for the current symbol upload
    public var symbolType: SymbolType
    /// The symbols found in the upload. This may be empty until the status is indexed
    public var symbolsUploaded: [SymbolsUploadedItem]?
    /// The origin of the symbol upload
    public var origin: Origin?
    /// The file name for the symbol upload
    public var fileName: String?
    /// The size of the file in Mebibytes. This may be 0 until the status is indexed
    public var fileSize: Double?
    /// When the symbol upload was committed, or last transaction time if not committed
    public var timestamp: Date?

    /// User information of the one who intitiated the symbol upload
    public struct User: Codable {
        /// The email of the user
        public var email: String?
        /// The full name of the user. Might for example be first and last name
        public var displayName: String?

        public init(email: String? = nil, displayName: String? = nil) {
            self.email = email
            self.displayName = displayName
        }

        private enum CodingKeys: String, CodingKey {
            case email
            case displayName = "display_name"
        }
    }

    /// The current status for the symbol upload
    public enum Status: String, Codable, CaseIterable {
        case created
        case committed
        case aborted
        case processing
        case indexed
        case failed
    }

    /// The type of the symbol for the current symbol upload
    public enum SymbolType: String, Codable, CaseIterable {
        case apple = "Apple"
        case javaScript = "JavaScript"
        case breakpad = "Breakpad"
        case androidProguard = "AndroidProguard"
        case uwp = "UWP"
    }

    public struct SymbolsUploadedItem: Codable {
        /// The symbol id of the symbol binary
        public var symbolID: String
        /// The platform the symbol is associated with
        public var platform: String

        public init(symbolID: String, platform: String) {
            self.symbolID = symbolID
            self.platform = platform
        }

        private enum CodingKeys: String, CodingKey {
            case symbolID = "symbol_id"
            case platform
        }
    }

    /// The origin of the symbol upload
    public enum Origin: String, Codable, CaseIterable {
        case user = "User"
        case system = "System"
    }

    public init(symbolUploadID: String, appID: String, user: User? = nil, status: Status, symbolType: SymbolType, symbolsUploaded: [SymbolsUploadedItem]? = nil, origin: Origin? = nil, fileName: String? = nil, fileSize: Double? = nil, timestamp: Date? = nil) {
        self.symbolUploadID = symbolUploadID
        self.appID = appID
        self.user = user
        self.status = status
        self.symbolType = symbolType
        self.symbolsUploaded = symbolsUploaded
        self.origin = origin
        self.fileName = fileName
        self.fileSize = fileSize
        self.timestamp = timestamp
    }

    private enum CodingKeys: String, CodingKey {
        case symbolUploadID = "symbol_upload_id"
        case appID = "app_id"
        case user
        case status
        case symbolType = "symbol_type"
        case symbolsUploaded = "symbols_uploaded"
        case origin
        case fileName = "file_name"
        case fileSize = "file_size"
        case timestamp
    }
}

/// Location for downloading symbol
public struct SymbolLocation: Codable {
    public var uri: String

    public init(uri: String) {
        self.uri = uri
    }
}

/// Location for downloading symbol upload
public struct SymbolUploadLocation: Codable {
    public var uri: String

    public init(uri: String) {
        self.uri = uri
    }
}

/// A request containing information pertaining to starting a symbol upload process
public struct SymbolUploadBeginRequest: Codable {
    /// The type of the symbol for the current symbol upload
    public var symbolType: SymbolType
    /// The callback URL that the client can optionally provide to get status updates for the current symbol upload
    public var clientCallback: String?
    /// The file name for the symbol upload
    public var fileName: String?
    /// The build number. Optional for Apple. Required for Android.
    public var build: String?
    /// The version number. Optional for Apple. Required for Android.
    public var version: String?

    /// The type of the symbol for the current symbol upload
    public enum SymbolType: String, Codable, CaseIterable {
        case apple = "Apple"
        case javaScript = "JavaScript"
        case breakpad = "Breakpad"
        case androidProguard = "AndroidProguard"
        case uwp = "UWP"
    }

    public init(symbolType: SymbolType, clientCallback: String? = nil, fileName: String? = nil, build: String? = nil, version: String? = nil) {
        self.symbolType = symbolType
        self.clientCallback = clientCallback
        self.fileName = fileName
        self.build = build
        self.version = version
    }

    private enum CodingKeys: String, CodingKey {
        case symbolType = "symbol_type"
        case clientCallback = "client_callback"
        case fileName = "file_name"
        case build
        case version
    }
}

/// A response containing information pertaining to starting a symbol upload process
public struct SymbolUploadBeginResponse: Codable {
    /// The id for the current upload
    public var symbolUploadID: String
    /// The URL where the client needs to upload the symbol blob to
    public var uploadURL: String
    /// Describes how long the upload_url is valid
    public var expirationDate: Date

    public init(symbolUploadID: String, uploadURL: String, expirationDate: Date) {
        self.symbolUploadID = symbolUploadID
        self.uploadURL = uploadURL
        self.expirationDate = expirationDate
    }

    private enum CodingKeys: String, CodingKey {
        case symbolUploadID = "symbol_upload_id"
        case uploadURL = "upload_url"
        case expirationDate = "expiration_date"
    }
}

/// A request containing information pertaining to completing a symbol upload process
public struct SymbolUploadEndRequest: Codable {
    /// The desired operation for the symbol upload
    public var status: Status

    /// The desired operation for the symbol upload
    public enum Status: String, Codable, CaseIterable {
        case committed
        case aborted
    }

    public init(status: Status) {
        self.status = status
    }
}

public struct SymbolUploadUserInfo: Codable {
    /// The email of the user
    public var email: String?
    /// The full name of the user. Might for example be first and last name
    public var displayName: String?

    public init(email: String? = nil, displayName: String? = nil) {
        self.email = email
        self.displayName = displayName
    }

    private enum CodingKeys: String, CodingKey {
        case email
        case displayName = "display_name"
    }
}

public struct UploadedSymbolInfo: Codable {
    /// The symbol id of the symbol binary
    public var symbolID: String
    /// The platform the symbol is associated with
    public var platform: String

    public init(symbolID: String, platform: String) {
        self.symbolID = symbolID
        self.platform = platform
    }

    private enum CodingKeys: String, CodingKey {
        case symbolID = "symbol_id"
        case platform
    }
}

/// A response represents information about symbol name group
public struct SystemVersionNameGroup: Codable {
    /// Name of version group
    public var name: String?
    public var versions: [String]?

    public init(name: String? = nil, versions: [String]? = nil) {
        self.name = name
        self.versions = versions
    }
}

/// A response represents information about symbol name group
public struct SystemVersionNameGroupsItem: Codable {
    /// Name of version group
    public var name: String?
    public var versions: [String]?

    public init(name: String? = nil, versions: [String]? = nil) {
        self.name = name
        self.versions = versions
    }
}

public struct AppCrashesInfo: Codable {
    public var hasCrashes: Bool
    public var features: Features

    public struct Features: Codable {
        /// App supports modification of crashgroup status
        public var isCrashgroupModifyStatus: Bool?
        /// App supports modification of crashgroup annotation
        public var isCrashgroupModifyAnnotation: Bool?
        /// App supports search API
        public var isSearch: Bool?
        /// App supports the 'crash free user' metric
        public var isCrashgroupAnalyticsCrashfreeusers: Bool?
        /// App supports the 'impacted users' metric
        public var isCrashgroupAnalyticsImpactedusers: Bool?
        /// App supports download of raw crashes
        public var isCrashDownloadRaw: Bool?

        public init(isCrashgroupModifyStatus: Bool? = nil, isCrashgroupModifyAnnotation: Bool? = nil, isSearch: Bool? = nil, isCrashgroupAnalyticsCrashfreeusers: Bool? = nil, isCrashgroupAnalyticsImpactedusers: Bool? = nil, isCrashDownloadRaw: Bool? = nil) {
            self.isCrashgroupModifyStatus = isCrashgroupModifyStatus
            self.isCrashgroupModifyAnnotation = isCrashgroupModifyAnnotation
            self.isSearch = isSearch
            self.isCrashgroupAnalyticsCrashfreeusers = isCrashgroupAnalyticsCrashfreeusers
            self.isCrashgroupAnalyticsImpactedusers = isCrashgroupAnalyticsImpactedusers
            self.isCrashDownloadRaw = isCrashDownloadRaw
        }

        private enum CodingKeys: String, CodingKey {
            case isCrashgroupModifyStatus = "crashgroup_modify_status"
            case isCrashgroupModifyAnnotation = "crashgroup_modify_annotation"
            case isSearch = "search"
            case isCrashgroupAnalyticsCrashfreeusers = "crashgroup_analytics_crashfreeusers"
            case isCrashgroupAnalyticsImpactedusers = "crashgroup_analytics_impactedusers"
            case isCrashDownloadRaw = "crash_download_raw"
        }
    }

    public init(hasCrashes: Bool, features: Features) {
        self.hasCrashes = hasCrashes
        self.features = features
    }

    private enum CodingKeys: String, CodingKey {
        case hasCrashes = "has_crashes"
        case features
    }
}

public struct AppFeatures: Codable {
    /// App supports modification of crashgroup status
    public var isCrashgroupModifyStatus: Bool?
    /// App supports modification of crashgroup annotation
    public var isCrashgroupModifyAnnotation: Bool?
    /// App supports search API
    public var isSearch: Bool?
    /// App supports the 'crash free user' metric
    public var isCrashgroupAnalyticsCrashfreeusers: Bool?
    /// App supports the 'impacted users' metric
    public var isCrashgroupAnalyticsImpactedusers: Bool?
    /// App supports download of raw crashes
    public var isCrashDownloadRaw: Bool?

    public init(isCrashgroupModifyStatus: Bool? = nil, isCrashgroupModifyAnnotation: Bool? = nil, isSearch: Bool? = nil, isCrashgroupAnalyticsCrashfreeusers: Bool? = nil, isCrashgroupAnalyticsImpactedusers: Bool? = nil, isCrashDownloadRaw: Bool? = nil) {
        self.isCrashgroupModifyStatus = isCrashgroupModifyStatus
        self.isCrashgroupModifyAnnotation = isCrashgroupModifyAnnotation
        self.isSearch = isSearch
        self.isCrashgroupAnalyticsCrashfreeusers = isCrashgroupAnalyticsCrashfreeusers
        self.isCrashgroupAnalyticsImpactedusers = isCrashgroupAnalyticsImpactedusers
        self.isCrashDownloadRaw = isCrashDownloadRaw
    }

    private enum CodingKeys: String, CodingKey {
        case isCrashgroupModifyStatus = "crashgroup_modify_status"
        case isCrashgroupModifyAnnotation = "crashgroup_modify_annotation"
        case isSearch = "search"
        case isCrashgroupAnalyticsCrashfreeusers = "crashgroup_analytics_crashfreeusers"
        case isCrashgroupAnalyticsImpactedusers = "crashgroup_analytics_impactedusers"
        case isCrashDownloadRaw = "crash_download_raw"
    }
}

public struct AppVersion: Codable {
    public var appVersionID: String
    public var appID: String
    public var displayName: String
    public var appVersion: String
    public var buildNumber: String?

    public init(appVersionID: String, appID: String, displayName: String, appVersion: String, buildNumber: String? = nil) {
        self.appVersionID = appVersionID
        self.appID = appID
        self.displayName = displayName
        self.appVersion = appVersion
        self.buildNumber = buildNumber
    }

    private enum CodingKeys: String, CodingKey {
        case appVersionID = "app_version_id"
        case appID = "app_id"
        case displayName = "display_name"
        case appVersion = "app_version"
        case buildNumber = "build_number"
    }
}

/// A exception
public struct Exception: Codable {
    /// Reason of the exception
    public var reason: String?
    /// Type of the exception (NSSomethingException, NullPointerException)
    public var type: String?
    /// Frames of the excetpion
    public var frames: [Frame]
    /// Relevant exception (crashed)
    public var isRelevant: Bool?
    public var innerExceptions: [Exception]?
    /// SDK/Platform this thread is beeing generated from
    public var platform: Platform?

    /// A single frame of a stack trace
    public struct Frame: Codable {
        /// Address of the frame
        public var address: String?
        /// Name of the class
        public var className: String?
        /// Name of the method
        public var method: String?
        /// Is a class method
        public var isClassMethod: Bool?
        /// Name of the file
        public var file: String?
        /// Line number
        public var line: Int?
        /// This line isn't from any framework
        public var isAppCode: Bool
        /// Name of the framework
        public var frameworkName: String?
        /// Raw frame string
        public var codeRaw: String
        /// Formatted frame string
        public var codeFormatted: String
        /// Programming language of the frame
        public var language: Language?
        /// Frame should be shown always
        public var isRelevant: Bool?
        /// Parameters of the frames method
        public var methodParams: String?

        /// Programming language of the frame
        public enum Language: String, Codable, CaseIterable {
            case javaScript = "JavaScript"
            case cSharp = "CSharp"
            case objectiveC = "Objective-C"
            case objectiveCpp = "Objective-Cpp"
            case cpp = "Cpp"
            case c = "C"
            case swift = "Swift"
            case java = "Java"
            case unknown = "Unknown"
        }

        public init(address: String? = nil, className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool, frameworkName: String? = nil, codeRaw: String, codeFormatted: String, language: Language? = nil, isRelevant: Bool? = nil, methodParams: String? = nil) {
            self.address = address
            self.className = className
            self.method = method
            self.isClassMethod = isClassMethod
            self.file = file
            self.line = line
            self.isAppCode = isAppCode
            self.frameworkName = frameworkName
            self.codeRaw = codeRaw
            self.codeFormatted = codeFormatted
            self.language = language
            self.isRelevant = isRelevant
            self.methodParams = methodParams
        }

        private enum CodingKeys: String, CodingKey {
            case address
            case className = "class_name"
            case method
            case isClassMethod = "class_method"
            case file
            case line
            case isAppCode = "app_code"
            case frameworkName = "framework_name"
            case codeRaw = "code_raw"
            case codeFormatted = "code_formatted"
            case language
            case isRelevant = "relevant"
            case methodParams = "method_params"
        }
    }

    /// SDK/Platform this thread is beeing generated from
    public enum Platform: String, Codable, CaseIterable {
        case ios
        case android
        case xamarin
        case reactNative = "react-native"
        case ndk
        case unity
        case other
    }

    public init(reason: String? = nil, type: String? = nil, frames: [Frame], isRelevant: Bool? = nil, innerExceptions: [Exception]? = nil, platform: Platform? = nil) {
        self.reason = reason
        self.type = type
        self.frames = frames
        self.isRelevant = isRelevant
        self.innerExceptions = innerExceptions
        self.platform = platform
    }

    private enum CodingKeys: String, CodingKey {
        case reason
        case type
        case frames
        case isRelevant = "relevant"
        case innerExceptions = "inner_exceptions"
        case platform
    }
}

/// A stacktrace in a processed and prettyfied way
public struct Stacktrace: Codable {
    public var title: String?
    public var reason: String?
    public var threads: [Thread]?
    public var exception: Exception?

    public init(title: String? = nil, reason: String? = nil, threads: [Thread]? = nil, exception: Exception? = nil) {
        self.title = title
        self.reason = reason
        self.threads = threads
        self.exception = exception
    }
}

/// A thread representation
public struct Thread: Codable {
    /// Name of the thread
    public var title: String
    /// Frames of that thread
    public var frames: [Frame]
    public var exception: Exception?
    /// Shows if a thread is relevant or not. Is false if all frames are non relevant, otherwise true
    public var isRelevant: Bool?
    /// SDK/Platform this thread is beeing generated from
    public var platform: Platform?
    /// True if this thread crashed
    public var isCrashed: Bool?

    /// A single frame of a stack trace
    public struct Frame: Codable {
        /// Address of the frame
        public var address: String?
        /// Name of the class
        public var className: String?
        /// Name of the method
        public var method: String?
        /// Is a class method
        public var isClassMethod: Bool?
        /// Name of the file
        public var file: String?
        /// Line number
        public var line: Int?
        /// This line isn't from any framework
        public var isAppCode: Bool
        /// Name of the framework
        public var frameworkName: String?
        /// Raw frame string
        public var codeRaw: String
        /// Formatted frame string
        public var codeFormatted: String
        /// Programming language of the frame
        public var language: Language?
        /// Frame should be shown always
        public var isRelevant: Bool?
        /// Parameters of the frames method
        public var methodParams: String?

        /// Programming language of the frame
        public enum Language: String, Codable, CaseIterable {
            case javaScript = "JavaScript"
            case cSharp = "CSharp"
            case objectiveC = "Objective-C"
            case objectiveCpp = "Objective-Cpp"
            case cpp = "Cpp"
            case c = "C"
            case swift = "Swift"
            case java = "Java"
            case unknown = "Unknown"
        }

        public init(address: String? = nil, className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool, frameworkName: String? = nil, codeRaw: String, codeFormatted: String, language: Language? = nil, isRelevant: Bool? = nil, methodParams: String? = nil) {
            self.address = address
            self.className = className
            self.method = method
            self.isClassMethod = isClassMethod
            self.file = file
            self.line = line
            self.isAppCode = isAppCode
            self.frameworkName = frameworkName
            self.codeRaw = codeRaw
            self.codeFormatted = codeFormatted
            self.language = language
            self.isRelevant = isRelevant
            self.methodParams = methodParams
        }

        private enum CodingKeys: String, CodingKey {
            case address
            case className = "class_name"
            case method
            case isClassMethod = "class_method"
            case file
            case line
            case isAppCode = "app_code"
            case frameworkName = "framework_name"
            case codeRaw = "code_raw"
            case codeFormatted = "code_formatted"
            case language
            case isRelevant = "relevant"
            case methodParams = "method_params"
        }
    }

    /// SDK/Platform this thread is beeing generated from
    public enum Platform: String, Codable, CaseIterable {
        case ios
        case android
        case xamarin
        case reactNative = "react-native"
        case ndk
        case unity
        case other
    }

    public init(title: String, frames: [Frame], exception: Exception? = nil, isRelevant: Bool? = nil, platform: Platform? = nil, isCrashed: Bool? = nil) {
        self.title = title
        self.frames = frames
        self.exception = exception
        self.isRelevant = isRelevant
        self.platform = platform
        self.isCrashed = isCrashed
    }

    private enum CodingKeys: String, CodingKey {
        case title
        case frames
        case exception
        case isRelevant = "relevant"
        case platform
        case isCrashed = "crashed"
    }
}

/// A single frame of a stack trace
public struct StackFrame: Codable {
    /// Address of the frame
    public var address: String?
    /// Name of the class
    public var className: String?
    /// Name of the method
    public var method: String?
    /// Is a class method
    public var isClassMethod: Bool?
    /// Name of the file
    public var file: String?
    /// Line number
    public var line: Int?
    /// This line isn't from any framework
    public var isAppCode: Bool
    /// Name of the framework
    public var frameworkName: String?
    /// Raw frame string
    public var codeRaw: String
    /// Formatted frame string
    public var codeFormatted: String
    /// Programming language of the frame
    public var language: Language?
    /// Frame should be shown always
    public var isRelevant: Bool?
    /// Parameters of the frames method
    public var methodParams: String?

    /// Programming language of the frame
    public enum Language: String, Codable, CaseIterable {
        case javaScript = "JavaScript"
        case cSharp = "CSharp"
        case objectiveC = "Objective-C"
        case objectiveCpp = "Objective-Cpp"
        case cpp = "Cpp"
        case c = "C"
        case swift = "Swift"
        case java = "Java"
        case unknown = "Unknown"
    }

    public init(address: String? = nil, className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool, frameworkName: String? = nil, codeRaw: String, codeFormatted: String, language: Language? = nil, isRelevant: Bool? = nil, methodParams: String? = nil) {
        self.address = address
        self.className = className
        self.method = method
        self.isClassMethod = isClassMethod
        self.file = file
        self.line = line
        self.isAppCode = isAppCode
        self.frameworkName = frameworkName
        self.codeRaw = codeRaw
        self.codeFormatted = codeFormatted
        self.language = language
        self.isRelevant = isRelevant
        self.methodParams = methodParams
    }

    private enum CodingKeys: String, CodingKey {
        case address
        case className = "class_name"
        case method
        case isClassMethod = "class_method"
        case file
        case line
        case isAppCode = "app_code"
        case frameworkName = "framework_name"
        case codeRaw = "code_raw"
        case codeFormatted = "code_formatted"
        case language
        case isRelevant = "relevant"
        case methodParams = "method_params"
    }
}

/// Frame belonging to the reason of the crash
public struct ReasonStackFrame: Codable {
    /// Name of the class
    public var className: String?
    /// Name of the method
    public var method: String?
    /// Is a class method
    public var isClassMethod: Bool?
    /// Name of the file
    public var file: String?
    /// Line number
    public var line: Int?
    /// This line isn't from any framework
    public var isAppCode: Bool?
    /// Name of the framework
    public var frameworkName: String?
    /// Formatted frame string
    public var codeFormatted: String?
    /// Unformatted Frame string
    public var codeRaw: String?
    /// Programming language of the frame
    public var language: Language?
    /// Parameters of the frames method
    public var methodParams: String?
    /// Exception type.
    public var exceptionType: String?
    /// OS exception type. (aka. SIGNAL)
    public var osExceptionType: String?

    /// Programming language of the frame
    public enum Language: String, Codable, CaseIterable {
        case javaScript = "JavaScript"
        case cSharp = "CSharp"
        case objectiveC = "Objective-C"
        case objectiveCpp = "Objective-Cpp"
        case cpp = "Cpp"
        case c = "C"
        case swift = "Swift"
        case java = "Java"
        case unknown = "Unknown"
    }

    public init(className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool? = nil, frameworkName: String? = nil, codeFormatted: String? = nil, codeRaw: String? = nil, language: Language? = nil, methodParams: String? = nil, exceptionType: String? = nil, osExceptionType: String? = nil) {
        self.className = className
        self.method = method
        self.isClassMethod = isClassMethod
        self.file = file
        self.line = line
        self.isAppCode = isAppCode
        self.frameworkName = frameworkName
        self.codeFormatted = codeFormatted
        self.codeRaw = codeRaw
        self.language = language
        self.methodParams = methodParams
        self.exceptionType = exceptionType
        self.osExceptionType = osExceptionType
    }

    private enum CodingKeys: String, CodingKey {
        case className = "class_name"
        case method
        case isClassMethod = "class_method"
        case file
        case line
        case isAppCode = "app_code"
        case frameworkName = "framework_name"
        case codeFormatted = "code_formatted"
        case codeRaw = "code_raw"
        case language
        case methodParams = "method_params"
        case exceptionType = "exception_type"
        case osExceptionType = "os_exception_type"
    }
}

public struct RetentionSettings: Codable {
    public var retentionInDays: Int

    public init(retentionInDays: Int) {
        self.retentionInDays = retentionInDays
    }

    private enum CodingKeys: String, CodingKey {
        case retentionInDays = "retention_in_days"
    }
}

public struct CrashAttachment: Codable {
    public var appID: String
    public var attachmentID: String
    public var crashID: String
    public var blobLocation: String
    public var contentType: String
    public var fileName: String
    public var createdTime: Date
    public var size: Double

    public init(appID: String, attachmentID: String, crashID: String, blobLocation: String, contentType: String, fileName: String, createdTime: Date, size: Double) {
        self.appID = appID
        self.attachmentID = attachmentID
        self.crashID = crashID
        self.blobLocation = blobLocation
        self.contentType = contentType
        self.fileName = fileName
        self.createdTime = createdTime
        self.size = size
    }

    private enum CodingKeys: String, CodingKey {
        case appID = "app_id"
        case attachmentID = "attachment_id"
        case crashID = "crash_id"
        case blobLocation = "blob_location"
        case contentType = "content_type"
        case fileName = "file_name"
        case createdTime = "created_time"
        case size
    }
}

/// Location for downloading crash raw
public struct CrashRawLocation: Codable {
    public var uri: String

    public init(uri: String) {
        self.uri = uri
    }
}

/// Location for downloading crash attachment
public struct CrashAttachmentLocation: Codable {
    public var uri: String

    public init(uri: String) {
        self.uri = uri
    }
}

public struct CrashGroupsContainer: Codable {
    public var isLimitedResultSet: Bool
    /// Cassandra request continuation token. The token is used for pagination.
    public var continuationToken: String?
    public var crashGroups: [CrashGroup]

    public struct CrashGroup: Codable {
        public var crashGroupID: String
        public var newCrashGroupID: String
        public var displayID: String
        public var appVersion: String
        public var build: String
        public var status: Status
        public var count: Int
        public var impactedUsers: Int?
        public var firstOccurrence: Date
        public var lastOccurrence: Date
        public var exception: String?
        public var crashReason: String
        /// Frame belonging to the reason of the crash
        public var reasonFrame: ReasonFrame?
        /// Crash or handled exception
        public var isFatal: Bool
        public var annotation: String

        public enum Status: String, Codable, CaseIterable {
            case `open`
            case closed
            case ignored
        }

        /// Frame belonging to the reason of the crash
        public struct ReasonFrame: Codable {
            /// Name of the class
            public var className: String?
            /// Name of the method
            public var method: String?
            /// Is a class method
            public var isClassMethod: Bool?
            /// Name of the file
            public var file: String?
            /// Line number
            public var line: Int?
            /// This line isn't from any framework
            public var isAppCode: Bool?
            /// Name of the framework
            public var frameworkName: String?
            /// Formatted frame string
            public var codeFormatted: String?
            /// Unformatted Frame string
            public var codeRaw: String?
            /// Programming language of the frame
            public var language: Language?
            /// Parameters of the frames method
            public var methodParams: String?
            /// Exception type.
            public var exceptionType: String?
            /// OS exception type. (aka. SIGNAL)
            public var osExceptionType: String?

            /// Programming language of the frame
            public enum Language: String, Codable, CaseIterable {
                case javaScript = "JavaScript"
                case cSharp = "CSharp"
                case objectiveC = "Objective-C"
                case objectiveCpp = "Objective-Cpp"
                case cpp = "Cpp"
                case c = "C"
                case swift = "Swift"
                case java = "Java"
                case unknown = "Unknown"
            }

            public init(className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool? = nil, frameworkName: String? = nil, codeFormatted: String? = nil, codeRaw: String? = nil, language: Language? = nil, methodParams: String? = nil, exceptionType: String? = nil, osExceptionType: String? = nil) {
                self.className = className
                self.method = method
                self.isClassMethod = isClassMethod
                self.file = file
                self.line = line
                self.isAppCode = isAppCode
                self.frameworkName = frameworkName
                self.codeFormatted = codeFormatted
                self.codeRaw = codeRaw
                self.language = language
                self.methodParams = methodParams
                self.exceptionType = exceptionType
                self.osExceptionType = osExceptionType
            }

            private enum CodingKeys: String, CodingKey {
                case className = "class_name"
                case method
                case isClassMethod = "class_method"
                case file
                case line
                case isAppCode = "app_code"
                case frameworkName = "framework_name"
                case codeFormatted = "code_formatted"
                case codeRaw = "code_raw"
                case language
                case methodParams = "method_params"
                case exceptionType = "exception_type"
                case osExceptionType = "os_exception_type"
            }
        }

        public init(crashGroupID: String, newCrashGroupID: String, displayID: String, appVersion: String, build: String, status: Status, count: Int, impactedUsers: Int? = nil, firstOccurrence: Date, lastOccurrence: Date, exception: String? = nil, crashReason: String, reasonFrame: ReasonFrame? = nil, isFatal: Bool, annotation: String) {
            self.crashGroupID = crashGroupID
            self.newCrashGroupID = newCrashGroupID
            self.displayID = displayID
            self.appVersion = appVersion
            self.build = build
            self.status = status
            self.count = count
            self.impactedUsers = impactedUsers
            self.firstOccurrence = firstOccurrence
            self.lastOccurrence = lastOccurrence
            self.exception = exception
            self.crashReason = crashReason
            self.reasonFrame = reasonFrame
            self.isFatal = isFatal
            self.annotation = annotation
        }

        private enum CodingKeys: String, CodingKey {
            case crashGroupID = "crash_group_id"
            case newCrashGroupID = "new_crash_group_id"
            case displayID = "display_id"
            case appVersion = "app_version"
            case build
            case status
            case count
            case impactedUsers = "impacted_users"
            case firstOccurrence = "first_occurrence"
            case lastOccurrence = "last_occurrence"
            case exception
            case crashReason = "crash_reason"
            case reasonFrame = "reason_frame"
            case isFatal = "fatal"
            case annotation
        }
    }

    public init(isLimitedResultSet: Bool, continuationToken: String? = nil, crashGroups: [CrashGroup]) {
        self.isLimitedResultSet = isLimitedResultSet
        self.continuationToken = continuationToken
        self.crashGroups = crashGroups
    }

    private enum CodingKeys: String, CodingKey {
        case isLimitedResultSet = "limited_result_set"
        case continuationToken = "continuation_token"
        case crashGroups = "crash_groups"
    }
}

public struct CrashGroup: Codable {
    public var crashGroupID: String
    public var newCrashGroupID: String
    public var displayID: String
    public var appVersion: String
    public var build: String
    public var status: Status
    public var count: Int
    public var impactedUsers: Int?
    public var firstOccurrence: Date
    public var lastOccurrence: Date
    public var exception: String?
    public var crashReason: String
    /// Frame belonging to the reason of the crash
    public var reasonFrame: ReasonFrame?
    /// Crash or handled exception
    public var isFatal: Bool
    public var annotation: String

    public enum Status: String, Codable, CaseIterable {
        case `open`
        case closed
        case ignored
    }

    /// Frame belonging to the reason of the crash
    public struct ReasonFrame: Codable {
        /// Name of the class
        public var className: String?
        /// Name of the method
        public var method: String?
        /// Is a class method
        public var isClassMethod: Bool?
        /// Name of the file
        public var file: String?
        /// Line number
        public var line: Int?
        /// This line isn't from any framework
        public var isAppCode: Bool?
        /// Name of the framework
        public var frameworkName: String?
        /// Formatted frame string
        public var codeFormatted: String?
        /// Unformatted Frame string
        public var codeRaw: String?
        /// Programming language of the frame
        public var language: Language?
        /// Parameters of the frames method
        public var methodParams: String?
        /// Exception type.
        public var exceptionType: String?
        /// OS exception type. (aka. SIGNAL)
        public var osExceptionType: String?

        /// Programming language of the frame
        public enum Language: String, Codable, CaseIterable {
            case javaScript = "JavaScript"
            case cSharp = "CSharp"
            case objectiveC = "Objective-C"
            case objectiveCpp = "Objective-Cpp"
            case cpp = "Cpp"
            case c = "C"
            case swift = "Swift"
            case java = "Java"
            case unknown = "Unknown"
        }

        public init(className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool? = nil, frameworkName: String? = nil, codeFormatted: String? = nil, codeRaw: String? = nil, language: Language? = nil, methodParams: String? = nil, exceptionType: String? = nil, osExceptionType: String? = nil) {
            self.className = className
            self.method = method
            self.isClassMethod = isClassMethod
            self.file = file
            self.line = line
            self.isAppCode = isAppCode
            self.frameworkName = frameworkName
            self.codeFormatted = codeFormatted
            self.codeRaw = codeRaw
            self.language = language
            self.methodParams = methodParams
            self.exceptionType = exceptionType
            self.osExceptionType = osExceptionType
        }

        private enum CodingKeys: String, CodingKey {
            case className = "class_name"
            case method
            case isClassMethod = "class_method"
            case file
            case line
            case isAppCode = "app_code"
            case frameworkName = "framework_name"
            case codeFormatted = "code_formatted"
            case codeRaw = "code_raw"
            case language
            case methodParams = "method_params"
            case exceptionType = "exception_type"
            case osExceptionType = "os_exception_type"
        }
    }

    public init(crashGroupID: String, newCrashGroupID: String, displayID: String, appVersion: String, build: String, status: Status, count: Int, impactedUsers: Int? = nil, firstOccurrence: Date, lastOccurrence: Date, exception: String? = nil, crashReason: String, reasonFrame: ReasonFrame? = nil, isFatal: Bool, annotation: String) {
        self.crashGroupID = crashGroupID
        self.newCrashGroupID = newCrashGroupID
        self.displayID = displayID
        self.appVersion = appVersion
        self.build = build
        self.status = status
        self.count = count
        self.impactedUsers = impactedUsers
        self.firstOccurrence = firstOccurrence
        self.lastOccurrence = lastOccurrence
        self.exception = exception
        self.crashReason = crashReason
        self.reasonFrame = reasonFrame
        self.isFatal = isFatal
        self.annotation = annotation
    }

    private enum CodingKeys: String, CodingKey {
        case crashGroupID = "crash_group_id"
        case newCrashGroupID = "new_crash_group_id"
        case displayID = "display_id"
        case appVersion = "app_version"
        case build
        case status
        case count
        case impactedUsers = "impacted_users"
        case firstOccurrence = "first_occurrence"
        case lastOccurrence = "last_occurrence"
        case exception
        case crashReason = "crash_reason"
        case reasonFrame = "reason_frame"
        case isFatal = "fatal"
        case annotation
    }
}

public struct CrashGroupChange: Codable {
    public var status: Status?
    public var annotation: String?

    public enum Status: String, Codable, CaseIterable {
        case `open`
        case closed
        case ignored
    }

    public init(status: Status? = nil, annotation: String? = nil) {
        self.status = status
        self.annotation = annotation
    }
}

public struct Crash: Codable {
    public var details: Details?
    public var newCrashGroupID: String
    public var crashID: String
    public var newCrashID: String
    public var displayID: String?
    public var timestamp: Date
    public var version: String
    public var build: String
    public var device: String
    public var deviceName: String?
    public var osVersion: String
    public var osType: String?
    public var stacktrace: Stacktrace?
    public var userName: String
    public var userEmail: String?

    public struct Details: Codable {
        /// Carrier country code (for mobile devices).
        public var carrierCountry: String?
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Language code (example: en_US).
        public var locale: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// Whether the device where the crash occurred is rooted or jailbroken
        public var isRooted: Bool
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String
        /// Application launch timestamp (example: 1985-04-12T23:20:50.52Z).
        public var appStartTimestamp: Date?

        public init(carrierCountry: String? = nil, carrierName: String? = nil, locale: String, osBuild: String? = nil, isRooted: Bool, screenSize: String, appStartTimestamp: Date? = nil) {
            self.carrierCountry = carrierCountry
            self.carrierName = carrierName
            self.locale = locale
            self.osBuild = osBuild
            self.isRooted = isRooted
            self.screenSize = screenSize
            self.appStartTimestamp = appStartTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case carrierCountry = "carrier_country"
            case carrierName = "carrier_name"
            case locale
            case osBuild = "os_build"
            case isRooted = "rooted"
            case screenSize = "screen_size"
            case appStartTimestamp = "app_start_timestamp"
        }
    }

    public init(details: Details? = nil, newCrashGroupID: String, crashID: String, newCrashID: String, displayID: String? = nil, timestamp: Date, version: String, build: String, device: String, deviceName: String? = nil, osVersion: String, osType: String? = nil, stacktrace: Stacktrace? = nil, userName: String, userEmail: String? = nil) {
        self.details = details
        self.newCrashGroupID = newCrashGroupID
        self.crashID = crashID
        self.newCrashID = newCrashID
        self.displayID = displayID
        self.timestamp = timestamp
        self.version = version
        self.build = build
        self.device = device
        self.deviceName = deviceName
        self.osVersion = osVersion
        self.osType = osType
        self.stacktrace = stacktrace
        self.userName = userName
        self.userEmail = userEmail
    }

    private enum CodingKeys: String, CodingKey {
        case details
        case newCrashGroupID = "new_crash_group_id"
        case crashID = "crash_id"
        case newCrashID = "new_crash_id"
        case displayID = "display_id"
        case timestamp
        case version
        case build
        case device
        case deviceName = "device_name"
        case osVersion = "os_version"
        case osType = "os_type"
        case stacktrace
        case userName = "user_name"
        case userEmail = "user_email"
    }
}

public struct CrashDetails: Codable {
    /// Carrier country code (for mobile devices).
    public var carrierCountry: String?
    /// Carrier name (for mobile devices).
    public var carrierName: String?
    /// Language code (example: en_US).
    public var locale: String
    /// OS build code (example: LMY47X).
    public var osBuild: String?
    /// Whether the device where the crash occurred is rooted or jailbroken
    public var isRooted: Bool
    /// Screen size of the device in pixels (example: 640x480).
    public var screenSize: String
    /// Application launch timestamp (example: 1985-04-12T23:20:50.52Z).
    public var appStartTimestamp: Date?

    public init(carrierCountry: String? = nil, carrierName: String? = nil, locale: String, osBuild: String? = nil, isRooted: Bool, screenSize: String, appStartTimestamp: Date? = nil) {
        self.carrierCountry = carrierCountry
        self.carrierName = carrierName
        self.locale = locale
        self.osBuild = osBuild
        self.isRooted = isRooted
        self.screenSize = screenSize
        self.appStartTimestamp = appStartTimestamp
    }

    private enum CodingKeys: String, CodingKey {
        case carrierCountry = "carrier_country"
        case carrierName = "carrier_name"
        case locale
        case osBuild = "os_build"
        case isRooted = "rooted"
        case screenSize = "screen_size"
        case appStartTimestamp = "app_start_timestamp"
    }
}

public struct AlertingCrashGroup: Codable {
    public var url: String?
    public var appDisplayName: String?
    /// SDK/Platform this thread is beeing generated from
    public var appPlatform: AppPlatform?
    public var appVersion: String?
    public var id: String?
    public var name: String?
    public var reason: String?
    public var stackTrace: [String]?

    /// SDK/Platform this thread is beeing generated from
    public enum AppPlatform: String, Codable, CaseIterable {
        case ios
        case android
        case xamarin
        case reactNative = "react-native"
        case ndk
        case unity
        case other
    }

    public init(url: String? = nil, appDisplayName: String? = nil, appPlatform: AppPlatform? = nil, appVersion: String? = nil, id: String? = nil, name: String? = nil, reason: String? = nil, stackTrace: [String]? = nil) {
        self.url = url
        self.appDisplayName = appDisplayName
        self.appPlatform = appPlatform
        self.appVersion = appVersion
        self.id = id
        self.name = name
        self.reason = reason
        self.stackTrace = stackTrace
    }

    private enum CodingKeys: String, CodingKey {
        case url
        case appDisplayName = "app_display_name"
        case appPlatform = "app_platform"
        case appVersion = "app_version"
        case id
        case name
        case reason
        case stackTrace = "stack_trace"
    }
}

public struct CrashDeleteCounter: Codable {
    public var appID: String?
    public var crashGroupID: String?
    public var crashID: String?
    public var crashesDeleted: Int?
    public var attachmentsDeleted: Int?
    public var blobsSucceeded: Int?
    public var blobsFailed: Int?

    public init(appID: String? = nil, crashGroupID: String? = nil, crashID: String? = nil, crashesDeleted: Int? = nil, attachmentsDeleted: Int? = nil, blobsSucceeded: Int? = nil, blobsFailed: Int? = nil) {
        self.appID = appID
        self.crashGroupID = crashGroupID
        self.crashID = crashID
        self.crashesDeleted = crashesDeleted
        self.attachmentsDeleted = attachmentsDeleted
        self.blobsSucceeded = blobsSucceeded
        self.blobsFailed = blobsFailed
    }

    private enum CodingKeys: String, CodingKey {
        case appID = "app_id"
        case crashGroupID = "crash_group_id"
        case crashID = "crash_id"
        case crashesDeleted = "crashes_deleted"
        case attachmentsDeleted = "attachments_deleted"
        case blobsSucceeded = "blobs_succeeded"
        case blobsFailed = "blobs_failed"
    }
}

/// Missing symbol
public struct V2MissingSymbol: Codable {
    /// Symbol id
    public var symbolID: String
    /// Symbol name
    public var name: String
    /// Symbol plarform
    public var platform: String?
    /// Symbol status
    public var status: Status

    /// Symbol status
    public enum Status: String, Codable, CaseIterable {
        case missing
        case ignored
        case available
    }

    public init(symbolID: String, name: String, platform: String? = nil, status: Status) {
        self.symbolID = symbolID
        self.name = name
        self.platform = platform
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case symbolID = "symbol_id"
        case name
        case platform
        case status
    }
}

/// Missing symbol
public struct V2MissingSymbolsItem: Codable {
    /// Symbol id
    public var symbolID: String
    /// Symbol name
    public var name: String
    /// Symbol plarform
    public var platform: String?
    /// Symbol status
    public var status: Status

    /// Symbol status
    public enum Status: String, Codable, CaseIterable {
        case missing
        case ignored
        case available
    }

    public init(symbolID: String, name: String, platform: String? = nil, status: Status) {
        self.symbolID = symbolID
        self.name = name
        self.platform = platform
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case symbolID = "symbol_id"
        case name
        case platform
        case status
    }
}

/// Symbol update message
public struct V2SymbolUpdateInfo: Codable {
    /// UUID of the symbol
    public var symbolID: String
    /// Application id
    public var appID: String
    /// Symbol upload status
    public var status: Status

    /// Symbol upload status
    public enum Status: String, Codable, CaseIterable {
        case missing
        case ignored
        case available
    }

    public init(symbolID: String, appID: String, status: Status) {
        self.symbolID = symbolID
        self.appID = appID
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case symbolID = "symbol_id"
        case appID = "app_id"
        case status
    }
}

/// Symbol update message
public struct V2SymbolUpdateInfoArrayItem: Codable {
    /// UUID of the symbol
    public var symbolID: String
    /// Application id
    public var appID: String
    /// Symbol upload status
    public var status: Status

    /// Symbol upload status
    public enum Status: String, Codable, CaseIterable {
        case missing
        case ignored
        case available
    }

    public init(symbolID: String, appID: String, status: Status) {
        self.symbolID = symbolID
        self.appID = appID
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case symbolID = "symbol_id"
        case appID = "app_id"
        case status
    }
}

/// Missing symbol crash group object
public struct V2MissingSymbolCrashGroup: Codable {
    /// Id of the symbol group
    public var symbolGroupID: String
    /// Number of crashes that belong to this group
    public var crashCount: Int?
    /// Number of errors that belong to this group
    public var errorCount: Int?
    /// Application id
    public var appID: String
    /// Application version
    public var appVer: String
    /// Application build
    public var appBuild: String
    /// Last update date for the group
    public var lastModified: Date
    /// List of missing symbols
    public var missingSymbols: [MissingSymbol]
    /// Group status
    public var status: Status

    /// Missing symbol
    public struct MissingSymbol: Codable {
        /// Symbol id
        public var symbolID: String
        /// Symbol name
        public var name: String
        /// Symbol plarform
        public var platform: String?
        /// Symbol status
        public var status: Status

        /// Symbol status
        public enum Status: String, Codable, CaseIterable {
            case missing
            case ignored
            case available
        }

        public init(symbolID: String, name: String, platform: String? = nil, status: Status) {
            self.symbolID = symbolID
            self.name = name
            self.platform = platform
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case symbolID = "symbol_id"
            case name
            case platform
            case status
        }
    }

    /// Group status
    public enum Status: String, Codable, CaseIterable {
        case active
        case pending
        case closed
    }

    public init(symbolGroupID: String, crashCount: Int? = nil, errorCount: Int? = nil, appID: String, appVer: String, appBuild: String, lastModified: Date, missingSymbols: [MissingSymbol], status: Status) {
        self.symbolGroupID = symbolGroupID
        self.crashCount = crashCount
        self.errorCount = errorCount
        self.appID = appID
        self.appVer = appVer
        self.appBuild = appBuild
        self.lastModified = lastModified
        self.missingSymbols = missingSymbols
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case symbolGroupID = "symbol_group_id"
        case crashCount = "crash_count"
        case errorCount = "error_count"
        case appID = "app_id"
        case appVer = "app_ver"
        case appBuild = "app_build"
        case lastModified = "last_modified"
        case missingSymbols = "missing_symbols"
        case status
    }
}

/// Missing symbol crash group object
public struct V2MissingSymbolCrashGroupsItem: Codable {
    /// Id of the symbol group
    public var symbolGroupID: String
    /// Number of crashes that belong to this group
    public var crashCount: Int?
    /// Number of errors that belong to this group
    public var errorCount: Int?
    /// Application id
    public var appID: String
    /// Application version
    public var appVer: String
    /// Application build
    public var appBuild: String
    /// Last update date for the group
    public var lastModified: Date
    /// List of missing symbols
    public var missingSymbols: [MissingSymbol]
    /// Group status
    public var status: Status

    /// Missing symbol
    public struct MissingSymbol: Codable {
        /// Symbol id
        public var symbolID: String
        /// Symbol name
        public var name: String
        /// Symbol plarform
        public var platform: String?
        /// Symbol status
        public var status: Status

        /// Symbol status
        public enum Status: String, Codable, CaseIterable {
            case missing
            case ignored
            case available
        }

        public init(symbolID: String, name: String, platform: String? = nil, status: Status) {
            self.symbolID = symbolID
            self.name = name
            self.platform = platform
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case symbolID = "symbol_id"
            case name
            case platform
            case status
        }
    }

    /// Group status
    public enum Status: String, Codable, CaseIterable {
        case active
        case pending
        case closed
    }

    public init(symbolGroupID: String, crashCount: Int? = nil, errorCount: Int? = nil, appID: String, appVer: String, appBuild: String, lastModified: Date, missingSymbols: [MissingSymbol], status: Status) {
        self.symbolGroupID = symbolGroupID
        self.crashCount = crashCount
        self.errorCount = errorCount
        self.appID = appID
        self.appVer = appVer
        self.appBuild = appBuild
        self.lastModified = lastModified
        self.missingSymbols = missingSymbols
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case symbolGroupID = "symbol_group_id"
        case crashCount = "crash_count"
        case errorCount = "error_count"
        case appID = "app_id"
        case appVer = "app_ver"
        case appBuild = "app_build"
        case lastModified = "last_modified"
        case missingSymbols = "missing_symbols"
        case status
    }
}

/// Grouped by missing symbols crashes response object
public struct V2MissingSymbolCrashGroupsResponse: Codable {
    /// Total number of crashes for all the groups
    public var totalCrashCount: Int
    /// List of crash groups formed by missing symbols combination
    public var groups: [Group]

    /// Missing symbol crash group object
    public struct Group: Codable {
        /// Id of the symbol group
        public var symbolGroupID: String
        /// Number of crashes that belong to this group
        public var crashCount: Int?
        /// Number of errors that belong to this group
        public var errorCount: Int?
        /// Application id
        public var appID: String
        /// Application version
        public var appVer: String
        /// Application build
        public var appBuild: String
        /// Last update date for the group
        public var lastModified: Date
        /// List of missing symbols
        public var missingSymbols: [MissingSymbol]
        /// Group status
        public var status: Status

        /// Missing symbol
        public struct MissingSymbol: Codable {
            /// Symbol id
            public var symbolID: String
            /// Symbol name
            public var name: String
            /// Symbol plarform
            public var platform: String?
            /// Symbol status
            public var status: Status

            /// Symbol status
            public enum Status: String, Codable, CaseIterable {
                case missing
                case ignored
                case available
            }

            public init(symbolID: String, name: String, platform: String? = nil, status: Status) {
                self.symbolID = symbolID
                self.name = name
                self.platform = platform
                self.status = status
            }

            private enum CodingKeys: String, CodingKey {
                case symbolID = "symbol_id"
                case name
                case platform
                case status
            }
        }

        /// Group status
        public enum Status: String, Codable, CaseIterable {
            case active
            case pending
            case closed
        }

        public init(symbolGroupID: String, crashCount: Int? = nil, errorCount: Int? = nil, appID: String, appVer: String, appBuild: String, lastModified: Date, missingSymbols: [MissingSymbol], status: Status) {
            self.symbolGroupID = symbolGroupID
            self.crashCount = crashCount
            self.errorCount = errorCount
            self.appID = appID
            self.appVer = appVer
            self.appBuild = appBuild
            self.lastModified = lastModified
            self.missingSymbols = missingSymbols
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case symbolGroupID = "symbol_group_id"
            case crashCount = "crash_count"
            case errorCount = "error_count"
            case appID = "app_id"
            case appVer = "app_ver"
            case appBuild = "app_build"
            case lastModified = "last_modified"
            case missingSymbols = "missing_symbols"
            case status
        }
    }

    public init(totalCrashCount: Int, groups: [Group]) {
        self.totalCrashCount = totalCrashCount
        self.groups = groups
    }

    private enum CodingKeys: String, CodingKey {
        case totalCrashCount = "total_crash_count"
        case groups
    }
}

/// Missing symbol groups
public struct V2MissingSymbolCrashGroupsInfoResponse: Codable {
    /// Total number of crashes for all missing symbol groups
    public var totalCrashCount: Int

    public init(totalCrashCount: Int) {
        self.totalCrashCount = totalCrashCount
    }

    private enum CodingKeys: String, CodingKey {
        case totalCrashCount = "total_crash_count"
    }
}

/// Status response object
public struct V2StatusResponse: Codable {
    public var status: String

    public init(status: String) {
        self.status = status
    }
}

/// Failure response object
public struct V2FailureResponse: Codable {
    public var code: String
    public var message: String

    public init(code: String, message: String) {
        self.code = code
        self.message = message
    }
}

public struct CreateReleaseUploadResponse: Codable {
    /// The ID for the newly created upload. It is going to be required later in the process.
    public var id: String
    /// The URL domain used to upload the release.
    public var uploadDomain: String
    /// The access token used for upload permissions.
    public var token: String
    /// The access token used for upload permissions (URL encoded to use as a single query parameter).
    public var urlEncodedToken: String
    /// The associated asset ID in the file management service associated with this uploaded.
    public var packageAssetID: String

    public init(id: String, uploadDomain: String, token: String, urlEncodedToken: String, packageAssetID: String) {
        self.id = id
        self.uploadDomain = uploadDomain
        self.token = token
        self.urlEncodedToken = urlEncodedToken
        self.packageAssetID = packageAssetID
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case uploadDomain = "upload_domain"
        case token
        case urlEncodedToken = "url_encoded_token"
        case packageAssetID = "package_asset_id"
    }
}

public struct GetReleaseStatusResponse: Codable {
    /// The ID for the upload.
    public var id: String
    /// The current upload status.
    public var uploadStatus: UploadStatus
    /// Details describing what went wrong processing the upload. Will only be set if status = 'error'.
    public var errorDetails: String?
    /// The distinct ID of the release. Will only be set when the status = 'readyToBePublished'.
    public var releaseDistinctID: Double?
    /// The URL of the release. Will only be set when the status = 'readyToBePublished'.
    public var releaseURL: [String: AnyJSON]?

    /// The current upload status.
    public enum UploadStatus: String, Codable, CaseIterable {
        case uploadStarted
        case uploadFinished
        case readyToBePublished
        case malwareDetected
        case error
    }

    public init(id: String, uploadStatus: UploadStatus, errorDetails: String? = nil, releaseDistinctID: Double? = nil, releaseURL: [String: AnyJSON]? = nil) {
        self.id = id
        self.uploadStatus = uploadStatus
        self.errorDetails = errorDetails
        self.releaseDistinctID = releaseDistinctID
        self.releaseURL = releaseURL
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case uploadStatus = "upload_status"
        case errorDetails = "error_details"
        case releaseDistinctID = "release_distinct_id"
        case releaseURL = "release_url"
    }
}

public struct PatchReleaseUploadStatusRequest: Codable {
    /// The new status of the release upload
    public var uploadStatus: UploadStatus

    /// The new status of the release upload
    public enum UploadStatus: String, Codable, CaseIterable {
        case uploadFinished
        case uploadCanceled
    }

    public init(uploadStatus: UploadStatus) {
        self.uploadStatus = uploadStatus
    }

    private enum CodingKeys: String, CodingKey {
        case uploadStatus = "upload_status"
    }
}

public struct PostCreateReleaseUploadRequest: Codable {
    /// User defined build version
    public var buildVersion: String?
    /// User defined build number
    public var buildNumber: String?

    public init(buildVersion: String? = nil, buildNumber: String? = nil) {
        self.buildVersion = buildVersion
        self.buildNumber = buildNumber
    }

    private enum CodingKeys: String, CodingKey {
        case buildVersion = "build_version"
        case buildNumber = "build_number"
    }
}

/// Set additional details for the placeholder ReleaseUpload that will be scheduled for delete.
public struct PostPlaceholderReleaseUploadForDeleteRequest: Codable {
    /// Additional details to identify why the placeholder ReleaseUpload is being created.
    public var errorDetails: String?

    public init(errorDetails: String? = nil) {
        self.errorDetails = errorDetails
    }

    private enum CodingKeys: String, CodingKey {
        case errorDetails = "error_details"
    }
}

public struct PatchReleaseUploadStatusResponse: Codable {
    /// The ID for the upload.
    public var id: String
    /// The current upload status.
    public var uploadStatus: UploadStatus

    /// The current upload status.
    public enum UploadStatus: String, Codable, CaseIterable {
        case uploadStarted
        case uploadFinished
        case uploadCanceled
        case readyToBePublished
        case malwareDetected
        case error
    }

    public init(id: String, uploadStatus: UploadStatus) {
        self.id = id
        self.uploadStatus = uploadStatus
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case uploadStatus = "upload_status"
    }
}

public struct TesterAppWithReleaseResponse: Codable {
    /// The unique ID (UUID) of the app
    public var id: String?
    public var release: Release?
    /// The app's name.
    public var name: String?
    /// The app's display name.
    public var displayName: String?
    /// The description of the app
    public var description: String?
    /// A URL to the app's icon.
    public var iconURL: String?
    /// The app's os.
    public var os: String?
    /// The information about the app's owner
    public var owner: Owner?

    public struct Release: Codable {
        /// ID identifying this unique release.
        public var id: Int
        /// The release's version.<br>
        /// For iOS: CFBundleVersion from info.plist.<br>
        /// For Android: android:versionCode from AppManifest.xml.
        public var version: String
        /// The release's origin
        public var origin: Origin?
        /// The release's short version.<br>
        /// For iOS: CFBundleShortVersionString from info.plist.<br>
        /// For Android: android:versionName from AppManifest.xml.
        public var shortVersion: String
        /// A boolean which determines whether the release is a mandatory update or not.
        public var isMandatoryUpdate: Bool
        /// UTC time in ISO 8601 format of the uploaded time.
        public var uploadedAt: String
        /// This value determines the whether a release currently is enabled or disabled.
        public var isEnabled: Bool
        /// This value determines if a release is external or not.
        public var isExternalBuild: Bool?
        /// The release's size in bytes.
        public var size: Int
        /// The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`
        public var installURL: String?
        /// The release's release notes.
        public var releaseNotes: String?

        /// The release's origin
        public enum Origin: String, Codable, CaseIterable {
            case hockeyapp
            case appcenter
        }

        public init(id: Int, version: String, origin: Origin? = nil, shortVersion: String, isMandatoryUpdate: Bool, uploadedAt: String, isEnabled: Bool, isExternalBuild: Bool? = nil, size: Int, installURL: String? = nil, releaseNotes: String? = nil) {
            self.id = id
            self.version = version
            self.origin = origin
            self.shortVersion = shortVersion
            self.isMandatoryUpdate = isMandatoryUpdate
            self.uploadedAt = uploadedAt
            self.isEnabled = isEnabled
            self.isExternalBuild = isExternalBuild
            self.size = size
            self.installURL = installURL
            self.releaseNotes = releaseNotes
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(Int.self, forKey: "id")
            self.version = try values.decode(String.self, forKey: "version")
            self.origin = try Origin(from: decoder)
            self.shortVersion = try values.decode(String.self, forKey: "short_version")
            self.isMandatoryUpdate = try values.decode(Bool.self, forKey: "mandatory_update")
            self.uploadedAt = try values.decode(String.self, forKey: "uploaded_at")
            self.isEnabled = try values.decode(Bool.self, forKey: "enabled")
            self.isExternalBuild = try values.decodeIfPresent(Bool.self, forKey: "is_external_build")
            self.size = try values.decode(Int.self, forKey: "size")
            self.installURL = try values.decodeIfPresent(String.self, forKey: "install_url")
            self.releaseNotes = try values.decodeIfPresent(String.self, forKey: "release_notes")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encode(version, forKey: "version")
            try values.encodeIfPresent(origin, forKey: "origin")
            try values.encode(shortVersion, forKey: "short_version")
            try values.encode(isMandatoryUpdate, forKey: "mandatory_update")
            try values.encode(uploadedAt, forKey: "uploaded_at")
            try values.encode(isEnabled, forKey: "enabled")
            try values.encodeIfPresent(isExternalBuild, forKey: "is_external_build")
            try values.encode(size, forKey: "size")
            try values.encodeIfPresent(installURL, forKey: "install_url")
            try values.encodeIfPresent(releaseNotes, forKey: "release_notes")
        }
    }

    /// The information about the app's owner
    public struct Owner: Codable {
        /// The unique id (UUID) of the owner
        public var id: String?
        /// The avatar URL of the owner
        public var avatarURL: String?
        /// The owner's display name
        public var displayName: String?
        /// The owner's email address
        public var email: String?
        /// The unique name that used to identify the owner
        public var name: String?
        /// The owner type. Can either be 'org' or 'user'
        public var type: `Type`?

        /// The owner type. Can either be 'org' or 'user'
        public enum `Type`: String, Codable, CaseIterable {
            case org
            case user
        }

        public init(id: String? = nil, avatarURL: String? = nil, displayName: String? = nil, email: String? = nil, name: String? = nil, type: `Type`? = nil) {
            self.id = id
            self.avatarURL = avatarURL
            self.displayName = displayName
            self.email = email
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case avatarURL = "avatar_url"
            case displayName = "display_name"
            case email
            case name
            case type
        }
    }

    public init(id: String? = nil, release: Release? = nil, name: String? = nil, displayName: String? = nil, description: String? = nil, iconURL: String? = nil, os: String? = nil, owner: Owner? = nil) {
        self.id = id
        self.release = release
        self.name = name
        self.displayName = displayName
        self.description = description
        self.iconURL = iconURL
        self.os = os
        self.owner = owner
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case release
        case name
        case displayName = "display_name"
        case description
        case iconURL = "icon_url"
        case os
        case owner
    }
}

public struct TesterAppRelease: Codable {
    /// ID identifying this unique release.
    public var id: Int
    /// The release's version.<br>
    /// For iOS: CFBundleVersion from info.plist.<br>
    /// For Android: android:versionCode from AppManifest.xml.
    public var version: String
    /// The release's origin
    public var origin: Origin?
    /// The release's short version.<br>
    /// For iOS: CFBundleShortVersionString from info.plist.<br>
    /// For Android: android:versionName from AppManifest.xml.
    public var shortVersion: String
    /// A boolean which determines whether the release is a mandatory update or not.
    public var isMandatoryUpdate: Bool
    /// UTC time in ISO 8601 format of the uploaded time.
    public var uploadedAt: String
    /// This value determines the whether a release currently is enabled or disabled.
    public var isEnabled: Bool
    /// This value determines if a release is external or not.
    public var isExternalBuild: Bool?
    /// The release's size in bytes.
    public var size: Int
    /// The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`
    public var installURL: String?
    /// The release's release notes.
    public var releaseNotes: String?

    /// The release's origin
    public enum Origin: String, Codable, CaseIterable {
        case hockeyapp
        case appcenter
    }

    public init(id: Int, version: String, origin: Origin? = nil, shortVersion: String, isMandatoryUpdate: Bool, uploadedAt: String, isEnabled: Bool, isExternalBuild: Bool? = nil, size: Int, installURL: String? = nil, releaseNotes: String? = nil) {
        self.id = id
        self.version = version
        self.origin = origin
        self.shortVersion = shortVersion
        self.isMandatoryUpdate = isMandatoryUpdate
        self.uploadedAt = uploadedAt
        self.isEnabled = isEnabled
        self.isExternalBuild = isExternalBuild
        self.size = size
        self.installURL = installURL
        self.releaseNotes = releaseNotes
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.version = try values.decode(String.self, forKey: "version")
        self.origin = try Origin(from: decoder)
        self.shortVersion = try values.decode(String.self, forKey: "short_version")
        self.isMandatoryUpdate = try values.decode(Bool.self, forKey: "mandatory_update")
        self.uploadedAt = try values.decode(String.self, forKey: "uploaded_at")
        self.isEnabled = try values.decode(Bool.self, forKey: "enabled")
        self.isExternalBuild = try values.decodeIfPresent(Bool.self, forKey: "is_external_build")
        self.size = try values.decode(Int.self, forKey: "size")
        self.installURL = try values.decodeIfPresent(String.self, forKey: "install_url")
        self.releaseNotes = try values.decodeIfPresent(String.self, forKey: "release_notes")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(version, forKey: "version")
        try values.encodeIfPresent(origin, forKey: "origin")
        try values.encode(shortVersion, forKey: "short_version")
        try values.encode(isMandatoryUpdate, forKey: "mandatory_update")
        try values.encode(uploadedAt, forKey: "uploaded_at")
        try values.encode(isEnabled, forKey: "enabled")
        try values.encodeIfPresent(isExternalBuild, forKey: "is_external_build")
        try values.encode(size, forKey: "size")
        try values.encodeIfPresent(installURL, forKey: "install_url")
        try values.encodeIfPresent(releaseNotes, forKey: "release_notes")
    }
}

public struct SendNotificationRequest: Codable {
    /// User list to send email notification
    public var userIDs: [String]

    public init(userIDs: [String]) {
        self.userIDs = userIDs
    }

    private enum CodingKeys: String, CodingKey {
        case userIDs = "userIds"
    }
}

/// Response for retrieving user interaction metrics.
public struct UserInteractionMetricsResponse: Codable {
    /// Check if the user has less than 100 apps.
    public var isLessThan100Apps: Bool?
    /// Check if the user's whole apps has more than 1 releases.
    public var hasMoreThan1Release: Bool?

    public init(isLessThan100Apps: Bool? = nil, hasMoreThan1Release: Bool? = nil) {
        self.isLessThan100Apps = isLessThan100Apps
        self.hasMoreThan1Release = hasMoreThan1Release
    }

    private enum CodingKeys: String, CodingKey {
        case isLessThan100Apps = "less_than_100_apps"
        case hasMoreThan1Release = "has_more_than_1_release"
    }
}

/// Response for updating a release
public struct ReleaseUpdateResponse: Codable {
    public var isEnabled: Bool?
    public var isMandatoryUpdate: Bool?
    public var releaseNotes: String?
    public var provisioningStatusURL: String?
    public var destinations: [Destination]?

    public struct Destination: Codable {
        public var id: String?
        public var name: String?

        public init(id: String? = nil, name: String? = nil) {
            self.id = id
            self.name = name
        }
    }

    public init(isEnabled: Bool? = nil, isMandatoryUpdate: Bool? = nil, releaseNotes: String? = nil, provisioningStatusURL: String? = nil, destinations: [Destination]? = nil) {
        self.isEnabled = isEnabled
        self.isMandatoryUpdate = isMandatoryUpdate
        self.releaseNotes = releaseNotes
        self.provisioningStatusURL = provisioningStatusURL
        self.destinations = destinations
    }

    private enum CodingKeys: String, CodingKey {
        case isEnabled = "enabled"
        case isMandatoryUpdate = "mandatory_update"
        case releaseNotes = "release_notes"
        case provisioningStatusURL = "provisioning_status_url"
        case destinations
    }
}

/// Response for updating release details
public struct ReleaseDetailsUpdateResponse: Codable {
    public var releaseNotes: String?

    public init(releaseNotes: String? = nil) {
        self.releaseNotes = releaseNotes
    }

    private enum CodingKeys: String, CodingKey {
        case releaseNotes = "release_notes"
    }
}

/// Response for updating release external url
public struct ReleaseExternalURLUpdateResponse: Codable {
    public var externalDownloadURL: String?

    public init(externalDownloadURL: String? = nil) {
        self.externalDownloadURL = externalDownloadURL
    }

    private enum CodingKeys: String, CodingKey {
        case externalDownloadURL = "external_download_url"
    }
}

/// Response for provisioning a release
public struct ReleaseProvisionResponse: Codable {
    /// The url to check provisioning status.
    public var statusURL: String?

    public init(statusURL: String? = nil) {
        self.statusURL = statusURL
    }

    private enum CodingKeys: String, CodingKey {
        case statusURL = "status_url"
    }
}

/// Details of an uploaded release
public struct PrivateReleaseDetailsResponse: Codable {
    /// ID identifying this unique release.
    public var id: Int?
    /// OBSOLETE. Will be removed in next version. The availability concept is now replaced with distributed. Any 'available' release will be associated with the default distribution group of an app.</br>
    /// The release state.<br>
    /// <b>available</b>: The uploaded release has been distributed.<br>
    /// <b>unavailable</b>: The uploaded release is not visible to the user. <br>
    public var status: Status?
    /// The app's name (extracted from the uploaded release).
    public var appName: String?
    /// The app's display name.
    public var appDisplayName: String?
    /// The release's version.<br>
    /// For iOS: CFBundleVersion from info.plist.
    /// For Android: android:versionCode from AppManifest.xml.
    public var version: String?
    /// The release's origin
    public var origin: Origin?
    /// The release's short version.<br>
    /// For iOS: CFBundleShortVersionString from info.plist.
    /// For Android: android:versionName from AppManifest.xml.
    public var shortVersion: String?
    /// The release's release notes.
    public var releaseNotes: String?
    /// The release's provisioning profile name.
    public var provisioningProfileName: String?
    /// The type of the provisioning profile for the requested app version.
    public var provisioningProfileType: ProvisioningProfileType?
    /// A flag that determines whether the release's provisioning profile is still extracted or not.
    public var isProvisioningProfileSyncing: Bool?
    /// The release's size in bytes.
    public var size: Int?
    /// The release's minimum required operating system.
    public var minOs: String?
    /// The release's device family.
    public var deviceFamily: String?
    /// The release's minimum required Android API level.
    public var androidMinAPILevel: String?
    /// The identifier of the apps bundle.
    public var bundleIdentifier: String?
    /// MD5 checksum of the release binary.
    public var fingerprint: String?
    /// UTC time in ISO 8601 format of the uploaded time.
    public var uploadedAt: String?
    /// The URL that hosts the binary for this release.
    public var downloadURL: String?
    /// A URL to the app's icon.
    public var appIconURL: String?
    /// The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`
    public var installURL: String?
    /// The destination where release is distributed
    public var distributionGroupID: String?
    /// The publishing status of the distributed release
    public var publishingStatus: String?
    /// The destination type.<br>
    /// <b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>
    /// <b>store</b>: The release distributed to external stores and distribution_stores details will be returned. <br>
    public var destinationType: DestinationType?
    /// This value determines if a release is external or not.
    public var isExternalBuild: Bool?

    /// OBSOLETE. Will be removed in next version. The availability concept is now replaced with distributed. Any 'available' release will be associated with the default distribution group of an app.</br>
    /// The release state.<br>
    /// <b>available</b>: The uploaded release has been distributed.<br>
    /// <b>unavailable</b>: The uploaded release is not visible to the user. <br>
    public enum Status: String, Codable, CaseIterable {
        case available
        case unavailable
    }

    /// The release's origin
    public enum Origin: String, Codable, CaseIterable {
        case hockeyapp
        case appcenter
    }

    /// The type of the provisioning profile for the requested app version.
    public enum ProvisioningProfileType: String, Codable, CaseIterable {
        case adhoc
        case enterprise
        case other
    }

    /// The destination type.<br>
    /// <b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>
    /// <b>store</b>: The release distributed to external stores and distribution_stores details will be returned. <br>
    public enum DestinationType: String, Codable, CaseIterable {
        case group
        case store
        case tester
    }

    public init(id: Int? = nil, status: Status? = nil, appName: String? = nil, appDisplayName: String? = nil, version: String? = nil, origin: Origin? = nil, shortVersion: String? = nil, releaseNotes: String? = nil, provisioningProfileName: String? = nil, provisioningProfileType: ProvisioningProfileType? = nil, isProvisioningProfileSyncing: Bool? = nil, size: Int? = nil, minOs: String? = nil, deviceFamily: String? = nil, androidMinAPILevel: String? = nil, bundleIdentifier: String? = nil, fingerprint: String? = nil, uploadedAt: String? = nil, downloadURL: String? = nil, appIconURL: String? = nil, installURL: String? = nil, distributionGroupID: String? = nil, publishingStatus: String? = nil, destinationType: DestinationType? = nil, isExternalBuild: Bool? = nil) {
        self.id = id
        self.status = status
        self.appName = appName
        self.appDisplayName = appDisplayName
        self.version = version
        self.origin = origin
        self.shortVersion = shortVersion
        self.releaseNotes = releaseNotes
        self.provisioningProfileName = provisioningProfileName
        self.provisioningProfileType = provisioningProfileType
        self.isProvisioningProfileSyncing = isProvisioningProfileSyncing
        self.size = size
        self.minOs = minOs
        self.deviceFamily = deviceFamily
        self.androidMinAPILevel = androidMinAPILevel
        self.bundleIdentifier = bundleIdentifier
        self.fingerprint = fingerprint
        self.uploadedAt = uploadedAt
        self.downloadURL = downloadURL
        self.appIconURL = appIconURL
        self.installURL = installURL
        self.distributionGroupID = distributionGroupID
        self.publishingStatus = publishingStatus
        self.destinationType = destinationType
        self.isExternalBuild = isExternalBuild
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case status
        case appName = "app_name"
        case appDisplayName = "app_display_name"
        case version
        case origin
        case shortVersion = "short_version"
        case releaseNotes = "release_notes"
        case provisioningProfileName = "provisioning_profile_name"
        case provisioningProfileType = "provisioning_profile_type"
        case isProvisioningProfileSyncing = "is_provisioning_profile_syncing"
        case size
        case minOs = "min_os"
        case deviceFamily = "device_family"
        case androidMinAPILevel = "android_min_api_level"
        case bundleIdentifier = "bundle_identifier"
        case fingerprint
        case uploadedAt = "uploaded_at"
        case downloadURL = "download_url"
        case appIconURL = "app_icon_url"
        case installURL = "install_url"
        case distributionGroupID = "distribution_group_id"
        case publishingStatus = "publishing_status"
        case destinationType = "destination_type"
        case isExternalBuild = "is_external_build"
    }
}

/// Basic information on a release for private apis
public struct PrivateBasicReleaseDetailsResponse: Codable {
    /// ID identifying this unique release.
    public var id: Int?
    /// The release's version.<br>
    /// For iOS: CFBundleVersion from info.plist.<br>
    /// For Android: android:versionCode from AppManifest.xml.
    public var version: String?
    /// The release's origin
    public var origin: Origin?
    /// The release's short version.<br>
    /// For iOS: CFBundleShortVersionString from info.plist.<br>
    /// For Android: android:versionName from AppManifest.xml.
    public var shortVersion: String?
    /// UTC time in ISO 8601 format of the uploaded time.
    public var uploadedAt: String?
    /// The destination id of release where it is distributed.
    public var distributionGroupID: String?
    /// The destination type.<br>
    /// <b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>
    /// <b>store</b>: The release distributed to external stores and distribution_stores details will be returned. <br>
    public var destinationType: DestinationType?
    /// Indicates if this is the latest release in the group.
    public var isLatest: Bool?
    /// A boolean which determines whether the release is a mandatory update or not.
    public var isMandatoryUpdate: Bool?
    /// The publishing status of the distributed release
    public var publishingStatus: String?
    /// This value determines if a release is external or not.
    public var isExternalBuild: Bool?

    /// The release's origin
    public enum Origin: String, Codable, CaseIterable {
        case hockeyapp
        case appcenter
    }

    /// The destination type.<br>
    /// <b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>
    /// <b>store</b>: The release distributed to external stores and distribution_stores details will be returned. <br>
    public enum DestinationType: String, Codable, CaseIterable {
        case group
        case store
        case tester
    }

    public init(id: Int? = nil, version: String? = nil, origin: Origin? = nil, shortVersion: String? = nil, uploadedAt: String? = nil, distributionGroupID: String? = nil, destinationType: DestinationType? = nil, isLatest: Bool? = nil, isMandatoryUpdate: Bool? = nil, publishingStatus: String? = nil, isExternalBuild: Bool? = nil) {
        self.id = id
        self.version = version
        self.origin = origin
        self.shortVersion = shortVersion
        self.uploadedAt = uploadedAt
        self.distributionGroupID = distributionGroupID
        self.destinationType = destinationType
        self.isLatest = isLatest
        self.isMandatoryUpdate = isMandatoryUpdate
        self.publishingStatus = publishingStatus
        self.isExternalBuild = isExternalBuild
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case version
        case origin
        case shortVersion = "short_version"
        case uploadedAt = "uploaded_at"
        case distributionGroupID = "distribution_group_id"
        case destinationType = "destination_type"
        case isLatest = "is_latest"
        case isMandatoryUpdate = "mandatory_update"
        case publishingStatus = "publishing_status"
        case isExternalBuild = "is_external_build"
    }
}

/// Response for getting a list of releases in a distribution group
public struct DistributionGroupReleasesResponseItem: Codable {
    /// ID identifying this unique release.
    public var id: Int
    /// The release's version.<br>
    /// For iOS: CFBundleVersion from info.plist.<br>
    /// For Android: android:versionCode from AppManifest.xml.
    public var version: String
    /// The release's origin
    public var origin: Origin?
    /// The release's short version.<br>
    /// For iOS: CFBundleShortVersionString from info.plist.<br>
    /// For Android: android:versionName from AppManifest.xml.
    public var shortVersion: String
    /// A boolean which determines whether the release is a mandatory update or not.
    public var isMandatoryUpdate: Bool
    /// UTC time in ISO 8601 format of the uploaded time.
    public var uploadedAt: String
    /// This value determines the whether a release currently is enabled or disabled.
    public var isEnabled: Bool
    /// This value determines if a release is external or not.
    public var isExternalBuild: Bool?

    /// The release's origin
    public enum Origin: String, Codable, CaseIterable {
        case hockeyapp
        case appcenter
    }

    public init(id: Int, version: String, origin: Origin? = nil, shortVersion: String, isMandatoryUpdate: Bool, uploadedAt: String, isEnabled: Bool, isExternalBuild: Bool? = nil) {
        self.id = id
        self.version = version
        self.origin = origin
        self.shortVersion = shortVersion
        self.isMandatoryUpdate = isMandatoryUpdate
        self.uploadedAt = uploadedAt
        self.isEnabled = isEnabled
        self.isExternalBuild = isExternalBuild
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case version
        case origin
        case shortVersion = "short_version"
        case isMandatoryUpdate = "mandatory_update"
        case uploadedAt = "uploaded_at"
        case isEnabled = "enabled"
        case isExternalBuild = "is_external_build"
    }
}

/// Response for getting a list of releases in a distribution group
public struct DistributionGroupRelease: Codable {
    /// ID identifying this unique release.
    public var id: Int
    /// The release's version.<br>
    /// For iOS: CFBundleVersion from info.plist.<br>
    /// For Android: android:versionCode from AppManifest.xml.
    public var version: String
    /// The release's origin
    public var origin: Origin?
    /// The release's short version.<br>
    /// For iOS: CFBundleShortVersionString from info.plist.<br>
    /// For Android: android:versionName from AppManifest.xml.
    public var shortVersion: String
    /// A boolean which determines whether the release is a mandatory update or not.
    public var isMandatoryUpdate: Bool
    /// UTC time in ISO 8601 format of the uploaded time.
    public var uploadedAt: String
    /// This value determines the whether a release currently is enabled or disabled.
    public var isEnabled: Bool
    /// This value determines if a release is external or not.
    public var isExternalBuild: Bool?

    /// The release's origin
    public enum Origin: String, Codable, CaseIterable {
        case hockeyapp
        case appcenter
    }

    public init(id: Int, version: String, origin: Origin? = nil, shortVersion: String, isMandatoryUpdate: Bool, uploadedAt: String, isEnabled: Bool, isExternalBuild: Bool? = nil) {
        self.id = id
        self.version = version
        self.origin = origin
        self.shortVersion = shortVersion
        self.isMandatoryUpdate = isMandatoryUpdate
        self.uploadedAt = uploadedAt
        self.isEnabled = isEnabled
        self.isExternalBuild = isExternalBuild
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case version
        case origin
        case shortVersion = "short_version"
        case isMandatoryUpdate = "mandatory_update"
        case uploadedAt = "uploaded_at"
        case isEnabled = "enabled"
        case isExternalBuild = "is_external_build"
    }
}

/// Basic information on a release
public struct BasicReleaseDetailsResponse: Codable {
    /// ID identifying this unique release.
    public var id: Int
    /// The release's version.<br>
    /// For iOS: CFBundleVersion from info.plist.<br>
    /// For Android: android:versionCode from AppManifest.xml.
    public var version: String
    /// The release's origin
    public var origin: Origin?
    /// The release's short version.<br>
    /// For iOS: CFBundleShortVersionString from info.plist.<br>
    /// For Android: android:versionName from AppManifest.xml.
    public var shortVersion: String
    /// This value determines the whether a release currently is enabled or disabled.
    public var isEnabled: Bool
    /// UTC time in ISO 8601 format of the uploaded time.
    public var uploadedAt: String
    /// OBSOLETE. Will be removed in next version. The destination type.<br>
    /// <b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>
    /// <b>store</b>: The release distributed to external stores and distribution_stores details will be returned. <br>
    public var destinationType: DestinationType?
    /// OBSOLETE. Will be removed in next version. A list of distribution groups that are associated with this release.
    public var distributionGroups: [DistributionGroup]?
    /// OBSOLETE. Will be removed in next version. A list of distribution stores that are associated with this release.
    public var distributionStores: [DistributionStore]?
    /// A list of distribution groups or stores.
    public var destinations: [Destination]?
    /// Build information for the release
    public var build: Build?
    /// This value determines if a release is external or not.
    public var isExternalBuild: Bool?
    /// The file extension of the main (user-uploaded) package file.
    public var fileExtension: String?

    /// The release's origin
    public enum Origin: String, Codable, CaseIterable {
        case hockeyapp
        case appcenter
    }

    /// OBSOLETE. Will be removed in next version. The destination type.<br>
    /// <b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>
    /// <b>store</b>: The release distributed to external stores and distribution_stores details will be returned. <br>
    public enum DestinationType: String, Codable, CaseIterable {
        case group
        case store
        case tester
    }

    public struct DistributionGroup: Codable {
        /// ID identifying a unique distribution group.
        public var id: String
        /// A name identifying a unique distribution group.
        public var name: String?
        /// Is the containing release the latest one in this distribution group.
        public var isLatest: Bool?

        public init(id: String, name: String? = nil, isLatest: Bool? = nil) {
            self.id = id
            self.name = name
            self.isLatest = isLatest
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(String.self, forKey: "id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(isLatest, forKey: "is_latest")
        }
    }

    public struct DistributionStore: Codable {
        /// ID identifying a unique distribution store.
        public var id: String
        /// A name identifying a unique distribution store.
        public var name: String?
        /// Type of the distribution store currently stores type can be intune, googleplay or windows.
        public var type: `Type`?
        /// Publishing status of the release in the store.
        public var publishingStatus: String?
        /// Is the containing release the latest one in this distribution store.
        public var isLatest: Bool?

        /// Type of the distribution store currently stores type can be intune, googleplay or windows.
        public enum `Type`: String, Codable, CaseIterable {
            case intune
            case googleplay
            case apple
            case `none`
        }

        public init(id: String, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil, isLatest: Bool? = nil) {
            self.id = id
            self.name = name
            self.type = type
            self.publishingStatus = publishingStatus
            self.isLatest = isLatest
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(String.self, forKey: "id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.type = try `Type`(from: decoder)
            self.publishingStatus = try values.decodeIfPresent(String.self, forKey: "publishing_status")
            self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encodeIfPresent(publishingStatus, forKey: "publishing_status")
            try values.encodeIfPresent(isLatest, forKey: "is_latest")
        }
    }

    public struct Destination: Codable {
        public var a: A
        public var b: B
        /// Name of a distribution group / distribution store. The release will be associated with this distribution group or store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
        public var name: String?
        /// Id of a distribution group / store. The release will be associated with this distribution group / store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
        public var id: String?
        /// Destination can be either store or group.
        public var destinationType: DestinationType?
        /// Display name for the group or tester
        public var displayName: String?

        public struct A: Codable {
            /// ID identifying a unique distribution group.
            public var id: String
            /// A name identifying a unique distribution group.
            public var name: String?
            /// Is the containing release the latest one in this distribution group.
            public var isLatest: Bool?

            public init(id: String, name: String? = nil, isLatest: Bool? = nil) {
                self.id = id
                self.name = name
                self.isLatest = isLatest
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decode(String.self, forKey: "id")
                self.name = try values.decodeIfPresent(String.self, forKey: "name")
                self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(id, forKey: "id")
                try values.encodeIfPresent(name, forKey: "name")
                try values.encodeIfPresent(isLatest, forKey: "is_latest")
            }
        }

        public struct B: Codable {
            /// ID identifying a unique distribution store.
            public var id: String
            /// A name identifying a unique distribution store.
            public var name: String?
            /// Type of the distribution store currently stores type can be intune, googleplay or windows.
            public var type: `Type`?
            /// Publishing status of the release in the store.
            public var publishingStatus: String?
            /// Is the containing release the latest one in this distribution store.
            public var isLatest: Bool?

            /// Type of the distribution store currently stores type can be intune, googleplay or windows.
            public enum `Type`: String, Codable, CaseIterable {
                case intune
                case googleplay
                case apple
                case `none`
            }

            public init(id: String, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil, isLatest: Bool? = nil) {
                self.id = id
                self.name = name
                self.type = type
                self.publishingStatus = publishingStatus
                self.isLatest = isLatest
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decode(String.self, forKey: "id")
                self.name = try values.decodeIfPresent(String.self, forKey: "name")
                self.type = try `Type`(from: decoder)
                self.publishingStatus = try values.decodeIfPresent(String.self, forKey: "publishing_status")
                self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(id, forKey: "id")
                try values.encodeIfPresent(name, forKey: "name")
                try values.encodeIfPresent(type, forKey: "type")
                try values.encodeIfPresent(publishingStatus, forKey: "publishing_status")
                try values.encodeIfPresent(isLatest, forKey: "is_latest")
            }
        }

        /// Destination can be either store or group.
        public enum DestinationType: String, Codable, CaseIterable {
            case group
            case store
            case tester
        }

        public init(a: A, b: B, name: String? = nil, id: String? = nil, destinationType: DestinationType? = nil, displayName: String? = nil) {
            self.a = a
            self.b = b
            self.name = name
            self.id = id
            self.destinationType = destinationType
            self.displayName = displayName
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.a = try A(from: decoder)
            self.b = try B(from: decoder)
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.destinationType = try DestinationType(from: decoder)
            self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(a, forKey: "a")
            try values.encode(b, forKey: "b")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(destinationType, forKey: "destination_type")
            try values.encodeIfPresent(displayName, forKey: "display_name")
        }
    }

    /// Build information for the release
    public struct Build: Codable {
        /// The branch name of the build producing the release
        public var branchName: String?
        /// The commit hash of the build producing the release
        public var commitHash: String?
        /// The commit message of the build producing the release
        public var commitMessage: String?

        public init(branchName: String? = nil, commitHash: String? = nil, commitMessage: String? = nil) {
            self.branchName = branchName
            self.commitHash = commitHash
            self.commitMessage = commitMessage
        }

        private enum CodingKeys: String, CodingKey {
            case branchName = "branch_name"
            case commitHash = "commit_hash"
            case commitMessage = "commit_message"
        }
    }

    public init(id: Int, version: String, origin: Origin? = nil, shortVersion: String, isEnabled: Bool, uploadedAt: String, destinationType: DestinationType? = nil, distributionGroups: [DistributionGroup]? = nil, distributionStores: [DistributionStore]? = nil, destinations: [Destination]? = nil, build: Build? = nil, isExternalBuild: Bool? = nil, fileExtension: String? = nil) {
        self.id = id
        self.version = version
        self.origin = origin
        self.shortVersion = shortVersion
        self.isEnabled = isEnabled
        self.uploadedAt = uploadedAt
        self.destinationType = destinationType
        self.distributionGroups = distributionGroups
        self.distributionStores = distributionStores
        self.destinations = destinations
        self.build = build
        self.isExternalBuild = isExternalBuild
        self.fileExtension = fileExtension
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case version
        case origin
        case shortVersion = "short_version"
        case isEnabled = "enabled"
        case uploadedAt = "uploaded_at"
        case destinationType = "destination_type"
        case distributionGroups = "distribution_groups"
        case distributionStores = "distribution_stores"
        case destinations
        case build
        case isExternalBuild = "is_external_build"
        case fileExtension = "file_extension"
    }
}

/// Details of an uploaded release
public struct ReleaseDetailsResponse: Codable {
    /// ID identifying this unique release.
    public var id: Int
    /// The app's name (extracted from the uploaded release).
    public var appName: String
    /// The app's display name.
    public var appDisplayName: String
    /// The app's OS.
    public var appOs: String?
    /// The release's version.<br>
    /// For iOS: CFBundleVersion from info.plist.
    /// For Android: android:versionCode from AppManifest.xml.
    public var version: String
    /// The release's origin
    public var origin: Origin?
    /// The release's short version.<br>
    /// For iOS: CFBundleShortVersionString from info.plist.
    /// For Android: android:versionName from AppManifest.xml.
    public var shortVersion: String
    /// The release's release notes.
    public var releaseNotes: String?
    /// The release's provisioning profile name.
    public var provisioningProfileName: String?
    /// The type of the provisioning profile for the requested app version.
    public var provisioningProfileType: ProvisioningProfileType?
    /// Expiration date of provisioning profile in UTC format.
    public var provisioningProfileExpiryDate: String?
    /// A flag that determines whether the release's provisioning profile is still extracted or not.
    public var isProvisioningProfileSyncing: Bool?
    /// The release's size in bytes.
    public var size: Int?
    /// The release's minimum required operating system.
    public var minOs: String?
    /// The release's device family.
    public var deviceFamily: String?
    /// The release's minimum required Android API level.
    public var androidMinAPILevel: String?
    /// The identifier of the apps bundle.
    public var bundleIdentifier: String?
    /// Hashes for the packages.
    public var packageHashes: [String]?
    /// MD5 checksum of the release binary.
    public var fingerprint: String?
    /// UTC time in ISO 8601 format of the uploaded time.
    public var uploadedAt: String
    /// The URL that hosts the binary for this release.
    public var downloadURL: String?
    /// A URL to the app's icon.
    public var appIconURL: String
    /// The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`
    public var installURL: String?
    /// OBSOLETE. Will be removed in next version. The destination type.<br>
    /// <b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>
    /// <b>store</b>: The release distributed to external stores and distribution_stores details will be returned.<br>
    /// <b>tester</b>: The release distributed testers details will be returned.<br>
    public var destinationType: DestinationType?
    /// OBSOLETE. Will be removed in next version. A list of distribution groups that are associated with this release.
    public var distributionGroups: [DistributionGroup]?
    /// OBSOLETE. Will be removed in next version. A list of distribution stores that are associated with this release.
    public var distributionStores: [DistributionStore]?
    /// A list of distribution groups or stores.
    public var destinations: [Destination]?
    /// In calls that allow passing `udid` in the query string, this value will hold the provisioning status of that UDID in this release. Will be ignored for non-iOS platforms.
    public var isUdidProvisioned: Bool?
    /// In calls that allow passing `udid` in the query string, this value determines if a release can be re-signed. When true, after a re-sign, the tester will be able to install the release from his registered devices. Will not be returned for non-iOS platforms.
    public var canResign: Bool?
    /// Contains metadata about the build that produced the release being uploaded
    public var build: Build?
    /// This value determines the whether a release currently is enabled or disabled.
    public var isEnabled: Bool
    /// Status of the release.
    public var status: String?
    /// This value determines if a release is external or not.
    public var isExternalBuild: Bool?

    /// The release's origin
    public enum Origin: String, Codable, CaseIterable {
        case hockeyapp
        case appcenter
    }

    /// The type of the provisioning profile for the requested app version.
    public enum ProvisioningProfileType: String, Codable, CaseIterable {
        case adhoc
        case enterprise
        case other
    }

    /// OBSOLETE. Will be removed in next version. The destination type.<br>
    /// <b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>
    /// <b>store</b>: The release distributed to external stores and distribution_stores details will be returned.<br>
    /// <b>tester</b>: The release distributed testers details will be returned.<br>
    public enum DestinationType: String, Codable, CaseIterable {
        case group
        case store
        case tester
    }

    public struct DistributionGroup: Codable {
        /// ID identifying a unique distribution group.
        public var id: String
        /// A name identifying a unique distribution group.
        public var name: String?

        public init(id: String, name: String? = nil) {
            self.id = id
            self.name = name
        }
    }

    public struct DistributionStore: Codable {
        /// ID identifying a unique distribution store.
        public var id: String
        /// A name identifying a unique distribution store.
        public var name: String?
        /// Type of the distribution store currently stores type can be intune, googleplay or windows.
        public var type: `Type`?
        /// Publishing status of the release in the store.
        public var publishingStatus: String?

        /// Type of the distribution store currently stores type can be intune, googleplay or windows.
        public enum `Type`: String, Codable, CaseIterable {
            case intune
            case googleplay
            case apple
            case `none`
        }

        public init(id: String, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil) {
            self.id = id
            self.name = name
            self.type = type
            self.publishingStatus = publishingStatus
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case name
            case type
            case publishingStatus = "publishing_status"
        }
    }

    public struct Destination: Codable {
        public var a: A
        public var b: B
        /// Name of a distribution group / distribution store. The release will be associated with this distribution group or store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
        public var name: String?
        /// Id of a distribution group / store. The release will be associated with this distribution group / store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
        public var id: String?
        /// Destination can be either store or group.
        public var destinationType: DestinationType?
        /// Display name for the group or tester
        public var displayName: String?

        public struct A: Codable {
            /// ID identifying a unique distribution group.
            public var id: String
            /// A name identifying a unique distribution group.
            public var name: String?
            /// Is the containing release the latest one in this distribution group.
            public var isLatest: Bool?

            public init(id: String, name: String? = nil, isLatest: Bool? = nil) {
                self.id = id
                self.name = name
                self.isLatest = isLatest
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decode(String.self, forKey: "id")
                self.name = try values.decodeIfPresent(String.self, forKey: "name")
                self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(id, forKey: "id")
                try values.encodeIfPresent(name, forKey: "name")
                try values.encodeIfPresent(isLatest, forKey: "is_latest")
            }
        }

        public struct B: Codable {
            /// ID identifying a unique distribution store.
            public var id: String
            /// A name identifying a unique distribution store.
            public var name: String?
            /// Type of the distribution store currently stores type can be intune, googleplay or windows.
            public var type: `Type`?
            /// Publishing status of the release in the store.
            public var publishingStatus: String?
            /// Is the containing release the latest one in this distribution store.
            public var isLatest: Bool?

            /// Type of the distribution store currently stores type can be intune, googleplay or windows.
            public enum `Type`: String, Codable, CaseIterable {
                case intune
                case googleplay
                case apple
                case `none`
            }

            public init(id: String, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil, isLatest: Bool? = nil) {
                self.id = id
                self.name = name
                self.type = type
                self.publishingStatus = publishingStatus
                self.isLatest = isLatest
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decode(String.self, forKey: "id")
                self.name = try values.decodeIfPresent(String.self, forKey: "name")
                self.type = try `Type`(from: decoder)
                self.publishingStatus = try values.decodeIfPresent(String.self, forKey: "publishing_status")
                self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(id, forKey: "id")
                try values.encodeIfPresent(name, forKey: "name")
                try values.encodeIfPresent(type, forKey: "type")
                try values.encodeIfPresent(publishingStatus, forKey: "publishing_status")
                try values.encodeIfPresent(isLatest, forKey: "is_latest")
            }
        }

        /// Destination can be either store or group.
        public enum DestinationType: String, Codable, CaseIterable {
            case group
            case store
            case tester
        }

        public init(a: A, b: B, name: String? = nil, id: String? = nil, destinationType: DestinationType? = nil, displayName: String? = nil) {
            self.a = a
            self.b = b
            self.name = name
            self.id = id
            self.destinationType = destinationType
            self.displayName = displayName
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.a = try A(from: decoder)
            self.b = try B(from: decoder)
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.destinationType = try DestinationType(from: decoder)
            self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(a, forKey: "a")
            try values.encode(b, forKey: "b")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(destinationType, forKey: "destination_type")
            try values.encodeIfPresent(displayName, forKey: "display_name")
        }
    }

    /// Contains metadata about the build that produced the release being uploaded
    public struct Build: Codable {
        /// The branch name of the build producing the release
        public var branchName: String?
        /// The commit hash of the build producing the release
        public var commitHash: String?
        /// The commit message of the build producing the release
        public var commitMessage: String?

        public init(branchName: String? = nil, commitHash: String? = nil, commitMessage: String? = nil) {
            self.branchName = branchName
            self.commitHash = commitHash
            self.commitMessage = commitMessage
        }

        private enum CodingKeys: String, CodingKey {
            case branchName = "branch_name"
            case commitHash = "commit_hash"
            case commitMessage = "commit_message"
        }
    }

    public init(id: Int, appName: String, appDisplayName: String, appOs: String? = nil, version: String, origin: Origin? = nil, shortVersion: String, releaseNotes: String? = nil, provisioningProfileName: String? = nil, provisioningProfileType: ProvisioningProfileType? = nil, provisioningProfileExpiryDate: String? = nil, isProvisioningProfileSyncing: Bool? = nil, size: Int? = nil, minOs: String? = nil, deviceFamily: String? = nil, androidMinAPILevel: String? = nil, bundleIdentifier: String? = nil, packageHashes: [String]? = nil, fingerprint: String? = nil, uploadedAt: String, downloadURL: String? = nil, appIconURL: String, installURL: String? = nil, destinationType: DestinationType? = nil, distributionGroups: [DistributionGroup]? = nil, distributionStores: [DistributionStore]? = nil, destinations: [Destination]? = nil, isUdidProvisioned: Bool? = nil, canResign: Bool? = nil, build: Build? = nil, isEnabled: Bool, status: String? = nil, isExternalBuild: Bool? = nil) {
        self.id = id
        self.appName = appName
        self.appDisplayName = appDisplayName
        self.appOs = appOs
        self.version = version
        self.origin = origin
        self.shortVersion = shortVersion
        self.releaseNotes = releaseNotes
        self.provisioningProfileName = provisioningProfileName
        self.provisioningProfileType = provisioningProfileType
        self.provisioningProfileExpiryDate = provisioningProfileExpiryDate
        self.isProvisioningProfileSyncing = isProvisioningProfileSyncing
        self.size = size
        self.minOs = minOs
        self.deviceFamily = deviceFamily
        self.androidMinAPILevel = androidMinAPILevel
        self.bundleIdentifier = bundleIdentifier
        self.packageHashes = packageHashes
        self.fingerprint = fingerprint
        self.uploadedAt = uploadedAt
        self.downloadURL = downloadURL
        self.appIconURL = appIconURL
        self.installURL = installURL
        self.destinationType = destinationType
        self.distributionGroups = distributionGroups
        self.distributionStores = distributionStores
        self.destinations = destinations
        self.isUdidProvisioned = isUdidProvisioned
        self.canResign = canResign
        self.build = build
        self.isEnabled = isEnabled
        self.status = status
        self.isExternalBuild = isExternalBuild
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case appName = "app_name"
        case appDisplayName = "app_display_name"
        case appOs = "app_os"
        case version
        case origin
        case shortVersion = "short_version"
        case releaseNotes = "release_notes"
        case provisioningProfileName = "provisioning_profile_name"
        case provisioningProfileType = "provisioning_profile_type"
        case provisioningProfileExpiryDate = "provisioning_profile_expiry_date"
        case isProvisioningProfileSyncing = "is_provisioning_profile_syncing"
        case size
        case minOs = "min_os"
        case deviceFamily = "device_family"
        case androidMinAPILevel = "android_min_api_level"
        case bundleIdentifier = "bundle_identifier"
        case packageHashes = "package_hashes"
        case fingerprint
        case uploadedAt = "uploaded_at"
        case downloadURL = "download_url"
        case appIconURL = "app_icon_url"
        case installURL = "install_url"
        case destinationType = "destination_type"
        case distributionGroups = "distribution_groups"
        case distributionStores = "distribution_stores"
        case destinations
        case isUdidProvisioned = "is_udid_provisioned"
        case canResign = "can_resign"
        case build
        case isEnabled = "enabled"
        case status
        case isExternalBuild = "is_external_build"
    }
}

/// Details of an uploaded release
public struct ManagementReleaseDetailsResponse: Codable {
    /// ID identifying this unique release.
    public var distinctID: Int?
    /// The release's origin
    public var origin: Origin?
    /// The release's short version.<br>
    /// For iOS: CFBundleShortVersionString from info.plist.<br>
    /// For Android: android:versionName from AppManifest.xml.
    public var version: String?
    /// The release's buildVersion.<br>
    /// For iOS: CFBundleVersion from info.plist.<br>
    /// For Android: android:versionCode from AppManifest.xml.
    public var buildVersion: String?
    /// The release's sortVersion.
    public var sortVersion: String?
    /// UTC time the release was created in ISO 8601 format.
    public var createdAt: String?
    /// This value determines the whether a release currently is enabled or disabled.
    public var isEnabled: Bool?
    /// UTC time the release was created in ISO 8601 format.
    public var deletedAt: String?

    /// The release's origin
    public enum Origin: String, Codable, CaseIterable {
        case hockeyapp
        case appcenter
    }

    public init(distinctID: Int? = nil, origin: Origin? = nil, version: String? = nil, buildVersion: String? = nil, sortVersion: String? = nil, createdAt: String? = nil, isEnabled: Bool? = nil, deletedAt: String? = nil) {
        self.distinctID = distinctID
        self.origin = origin
        self.version = version
        self.buildVersion = buildVersion
        self.sortVersion = sortVersion
        self.createdAt = createdAt
        self.isEnabled = isEnabled
        self.deletedAt = deletedAt
    }

    private enum CodingKeys: String, CodingKey {
        case distinctID = "distinctId"
        case origin
        case version
        case buildVersion
        case sortVersion
        case createdAt
        case isEnabled = "enabled"
        case deletedAt
    }
}

/// A request containing a set of release ids to validate
public struct GDPRValidationRequest: Codable {
    /// A list of release ids to validate (AC flow)
    public var releaseIDs: [Int]
    /// A list of release ids to validate (HA flow)
    public var hockeyappReleaseIDs: [Int]?
    /// A list of release uploads ids to validate
    public var releaseUploadIDs: [String]?

    public init(releaseIDs: [Int], hockeyappReleaseIDs: [Int]? = nil, releaseUploadIDs: [String]? = nil) {
        self.releaseIDs = releaseIDs
        self.hockeyappReleaseIDs = hockeyappReleaseIDs
        self.releaseUploadIDs = releaseUploadIDs
    }

    private enum CodingKeys: String, CodingKey {
        case releaseIDs = "release_ids"
        case hockeyappReleaseIDs = "hockeyapp_release_ids"
        case releaseUploadIDs = "release_upload_ids"
    }
}

/// A request containing information for creating a release.
public struct ReleaseCreateRequest: Codable {
    /// The release's version.<br>
    /// For iOS: CFBundleVersion from info.plist.<br>
    /// For Android: android:versionCode from AppManifest.xml.
    public var version: String?
    /// The release's short version.<br>
    /// For iOS: CFBundleShortVersionString from info.plist.<br>
    /// For Android: android:versionName from AppManifest.xml.
    public var buildVersion: String?
    /// The identifier of the app's bundle.
    public var uniqueIdentifier: String?
    /// The release's minimum required operating system.
    public var minimumOsVersion: String?
    /// The release's device family.
    public var deviceFamily: String?
    /// The languages supported by the release. Limited to 510 characters in a serialized array.
    public var languages: [String]?
    /// MD5 checksum of the release binary.
    public var fingerprint: String
    /// The release's size in bytes.
    public var size: Int
    /// The URL to the release's binary.
    public var packageURL: String?
    /// The file extension of the asset. Does not include the initial period.
    public var fileExtension: String?
    /// The upload id associated with the release, to map to the releases upload table.
    public var uploadID: String
    /// The assetId associated with the icon uploaded to app center file upload service.
    public var iconAssetID: String?
    /// A list of UUIDs for architectures for an iOS app.
    public var ipaUUIDs: [IpaUUID]?
    /// An object containing information about an iOS provisioning profile.
    public var provision: Provision?
    /// IOS app extension provisioning profiles included in the release.
    public var appexProvisioningProfiles: [AppexProvisioningProfile]?
    /// If true this release was uploaded to the AKS upload proxy
    public var isProxyFlow: Bool?

    /// An object containing a UUID for an architecture for an iOS app.
    public struct IpaUUID: Codable {
        /// The architecture that the UUID belongs to, i.e. armv7 or arm64.
        public var architecture: String
        /// The unique identifier.
        public var uuid: String

        public init(architecture: String, uuid: String) {
            self.architecture = architecture
            self.uuid = uuid
        }
    }

    /// An object containing information about an iOS provisioning profile.
    public struct Provision: Codable {
        /// The name of the provisioning profile.
        public var name: String
        /// The application identifier.
        public var applicationIdentifier: String
        /// The team identifier.
        public var teamIdentifier: String
        public var profileType: ProfileType
        /// The profile's expiration date in RFC 3339 format, i.e. 2017-07-21T17:32:28Z
        public var expiredAt: String
        public var udids: [String]?

        public enum ProfileType: String, Codable, CaseIterable {
            case adhoc
            case enterprise
            case other
        }

        public init(name: String, applicationIdentifier: String, teamIdentifier: String, profileType: ProfileType, expiredAt: String, udids: [String]? = nil) {
            self.name = name
            self.applicationIdentifier = applicationIdentifier
            self.teamIdentifier = teamIdentifier
            self.profileType = profileType
            self.expiredAt = expiredAt
            self.udids = udids
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case applicationIdentifier = "application_identifier"
            case teamIdentifier = "team_identifier"
            case profileType = "profile_type"
            case expiredAt = "expired_at"
            case udids
        }
    }

    /// An object containing information about an iOS provisioning profile.
    public struct AppexProvisioningProfile: Codable {
        /// The name of the provisioning profile.
        public var name: String
        /// The application identifier.
        public var applicationIdentifier: String
        /// The team identifier.
        public var teamIdentifier: String
        public var profileType: ProfileType
        /// The profile's expiration date in RFC 3339 format, i.e. 2017-07-21T17:32:28Z
        public var expiredAt: String
        public var udids: [String]?

        public enum ProfileType: String, Codable, CaseIterable {
            case adhoc
            case enterprise
            case other
        }

        public init(name: String, applicationIdentifier: String, teamIdentifier: String, profileType: ProfileType, expiredAt: String, udids: [String]? = nil) {
            self.name = name
            self.applicationIdentifier = applicationIdentifier
            self.teamIdentifier = teamIdentifier
            self.profileType = profileType
            self.expiredAt = expiredAt
            self.udids = udids
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case applicationIdentifier = "application_identifier"
            case teamIdentifier = "team_identifier"
            case profileType = "profile_type"
            case expiredAt = "expired_at"
            case udids
        }
    }

    public init(version: String? = nil, buildVersion: String? = nil, uniqueIdentifier: String? = nil, minimumOsVersion: String? = nil, deviceFamily: String? = nil, languages: [String]? = nil, fingerprint: String, size: Int, packageURL: String? = nil, fileExtension: String? = nil, uploadID: String, iconAssetID: String? = nil, ipaUUIDs: [IpaUUID]? = nil, provision: Provision? = nil, appexProvisioningProfiles: [AppexProvisioningProfile]? = nil, isProxyFlow: Bool? = nil) {
        self.version = version
        self.buildVersion = buildVersion
        self.uniqueIdentifier = uniqueIdentifier
        self.minimumOsVersion = minimumOsVersion
        self.deviceFamily = deviceFamily
        self.languages = languages
        self.fingerprint = fingerprint
        self.size = size
        self.packageURL = packageURL
        self.fileExtension = fileExtension
        self.uploadID = uploadID
        self.iconAssetID = iconAssetID
        self.ipaUUIDs = ipaUUIDs
        self.provision = provision
        self.appexProvisioningProfiles = appexProvisioningProfiles
        self.isProxyFlow = isProxyFlow
    }

    private enum CodingKeys: String, CodingKey {
        case version
        case buildVersion = "build_version"
        case uniqueIdentifier = "unique_identifier"
        case minimumOsVersion = "minimum_os_version"
        case deviceFamily = "device_family"
        case languages
        case fingerprint
        case size
        case packageURL = "package_url"
        case fileExtension = "file_extension"
        case uploadID = "upload_id"
        case iconAssetID = "icon_asset_id"
        case ipaUUIDs = "ipa_uuids"
        case provision
        case appexProvisioningProfiles = "appex_provisioning_profiles"
        case isProxyFlow = "proxy_flow"
    }
}

/// A request containing information for creating an externally hosted release.
public struct ExternallyHostedReleaseCreateRequest: Codable {
    /// The build version of the uploaded binary
    public var buildVersion: String
    /// The build number of the uploaded binary
    public var buildNumber: String?
    /// The external URL to the release's binary.
    public var externalDownloadURL: String

    public init(buildVersion: String, buildNumber: String? = nil, externalDownloadURL: String) {
        self.buildVersion = buildVersion
        self.buildNumber = buildNumber
        self.externalDownloadURL = externalDownloadURL
    }

    private enum CodingKeys: String, CodingKey {
        case buildVersion = "build_version"
        case buildNumber = "build_number"
        case externalDownloadURL = "external_download_url"
    }
}

/// A request containing information for creating an externally hosted release.
public struct UpdateExternalURLRequest: Codable {
    /// The external URL to the release's binary.
    public var externalDownloadURL: String

    public init(externalDownloadURL: String) {
        self.externalDownloadURL = externalDownloadURL
    }

    private enum CodingKeys: String, CodingKey {
        case externalDownloadURL = "external_download_url"
    }
}

/// A request containing information for updating a release.
public struct ReleaseUpdateRequest: Codable {
    /// OBSOLETE. Will be removed in future releases - use destinations instead. Name of a distribution group. The release will be associated with this distribution group. If the distribution group doesn't exist a 400 is returned. If both distribution group name and id are passed, the id is taking precedence.
    public var distributionGroupName: String?
    /// OBSOLETE. Will be removed in future releases - use destinations instead. Id of a distribution group. The release will be associated with this distribution group. If the distribution group doesn't exist a 400 is returned. If both distribution group name and id are passed, the id is taking precedence.
    public var distributionGroupID: String?
    /// OBSOLETE. Will be removed in future releases - use destinations instead. Name of a destination. The release will be associated with this destination. If the destination doesn't exist a 400 is returned. If both distribution group name and id are passed, the id is taking precedence.
    public var destinationName: String?
    /// OBSOLETE. Will be removed in future releases - use destinations instead. Id of a destination. The release will be associated with this destination. If the destination doesn't exist a 400 is returned. If both destination name and id are passed, the id is taking precedence.
    public var destinationID: String?
    /// Not used anymore.
    public var destinationType: String?
    /// Release notes for this release.
    public var releaseNotes: String?
    /// A boolean which determines whether this version should be a mandatory update or not.
    public var isMandatoryUpdate: Bool?
    /// Distribute this release under the following list of destinations (store groups or distribution groups).
    public var destinations: [Destination]?
    /// Contains metadata about the build that produced the release being uploaded
    public var build: Build?
    /// A boolean which determines whether to notify testers of a new release, default to true.
    public var isNotifyTesters: Bool
    /// An object containing all the release metadata.
    public var metadata: Metadata?

    /// A unique identifier for a destination. A destination can be identified by an ID (guid) or by a name. DestinationId encapsulates both options. A destination can be either a distribution group or a store.
    public struct Destination: Codable {
        /// Name of a distribution group / distribution store. The release will be associated with this distribution group or store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
        public var name: String?
        /// Id of a distribution group / store. The release will be associated with this distribution group / store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
        public var id: String?

        public init(name: String? = nil, id: String? = nil) {
            self.name = name
            self.id = id
        }
    }

    /// Contains metadata about the build that produced the release being uploaded
    public struct Build: Codable {
        /// The branch name of the build producing the release
        public var branchName: String?
        /// The commit hash of the build producing the release
        public var commitHash: String?
        /// The commit message of the build producing the release
        public var commitMessage: String?

        public init(branchName: String? = nil, commitHash: String? = nil, commitMessage: String? = nil) {
            self.branchName = branchName
            self.commitHash = commitHash
            self.commitMessage = commitMessage
        }

        private enum CodingKeys: String, CodingKey {
            case branchName = "branch_name"
            case commitHash = "commit_hash"
            case commitMessage = "commit_message"
        }
    }

    /// An object containing all the release metadata.
    public struct Metadata: Codable {
        /// Dsa signature of the release for the sparkle feed.
        public var dsaSignature: String?
        /// EdDSA signature of the release for the sparkle feed.
        public var edSignature: String?

        public init(dsaSignature: String? = nil, edSignature: String? = nil) {
            self.dsaSignature = dsaSignature
            self.edSignature = edSignature
        }

        private enum CodingKeys: String, CodingKey {
            case dsaSignature = "dsa_signature"
            case edSignature = "ed_signature"
        }
    }

    public init(distributionGroupName: String? = nil, distributionGroupID: String? = nil, destinationName: String? = nil, destinationID: String? = nil, destinationType: String? = nil, releaseNotes: String? = nil, isMandatoryUpdate: Bool? = nil, destinations: [Destination]? = nil, build: Build? = nil, isNotifyTesters: Bool? = nil, metadata: Metadata? = nil) {
        self.distributionGroupName = distributionGroupName
        self.distributionGroupID = distributionGroupID
        self.destinationName = destinationName
        self.destinationID = destinationID
        self.destinationType = destinationType
        self.releaseNotes = releaseNotes
        self.isMandatoryUpdate = isMandatoryUpdate
        self.destinations = destinations
        self.build = build
        self.isNotifyTesters = isNotifyTesters ?? true
        self.metadata = metadata
    }

    private enum CodingKeys: String, CodingKey {
        case distributionGroupName = "distribution_group_name"
        case distributionGroupID = "distribution_group_id"
        case destinationName = "destination_name"
        case destinationID = "destination_id"
        case destinationType = "destination_type"
        case releaseNotes = "release_notes"
        case isMandatoryUpdate = "mandatory_update"
        case destinations
        case build
        case isNotifyTesters = "notify_testers"
        case metadata
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.distributionGroupName = try values.decodeIfPresent(String.self, forKey: .distributionGroupName)
        self.distributionGroupID = try values.decodeIfPresent(String.self, forKey: .distributionGroupID)
        self.destinationName = try values.decodeIfPresent(String.self, forKey: .destinationName)
        self.destinationID = try values.decodeIfPresent(String.self, forKey: .destinationID)
        self.destinationType = try values.decodeIfPresent(String.self, forKey: .destinationType)
        self.releaseNotes = try values.decodeIfPresent(String.self, forKey: .releaseNotes)
        self.isMandatoryUpdate = try values.decodeIfPresent(Bool.self, forKey: .isMandatoryUpdate)
        self.destinations = try values.decodeIfPresent([Destination].self, forKey: .destinations)
        self.build = try values.decodeIfPresent(Build.self, forKey: .build)
        self.isNotifyTesters = try values.decodeIfPresent(Bool.self, forKey: .isNotifyTesters) ?? true
        self.metadata = try values.decodeIfPresent(Metadata.self, forKey: .metadata)
    }
}

/// A request containing information for updating details of a release
public struct ReleaseDetailsUpdateRequest: Codable {
    /// Toggle this release to be enable distribute/download or not.
    public var isEnabled: Bool?
    /// Release notes for this release.
    public var releaseNotes: String?
    /// Contains metadata about the build that produced the release being uploaded
    public var build: Build?

    /// Contains metadata about the build that produced the release being uploaded
    public struct Build: Codable {
        /// The branch name of the build producing the release
        public var branchName: String?
        /// The commit hash of the build producing the release
        public var commitHash: String?
        /// The commit message of the build producing the release
        public var commitMessage: String?

        public init(branchName: String? = nil, commitHash: String? = nil, commitMessage: String? = nil) {
            self.branchName = branchName
            self.commitHash = commitHash
            self.commitMessage = commitMessage
        }

        private enum CodingKeys: String, CodingKey {
            case branchName = "branch_name"
            case commitHash = "commit_hash"
            case commitMessage = "commit_message"
        }
    }

    public init(isEnabled: Bool? = nil, releaseNotes: String? = nil, build: Build? = nil) {
        self.isEnabled = isEnabled
        self.releaseNotes = releaseNotes
        self.build = build
    }

    private enum CodingKeys: String, CodingKey {
        case isEnabled = "enabled"
        case releaseNotes = "release_notes"
        case build
    }
}

/// Contains metadata about the build that produced the release being uploaded
public struct BuildInfo: Codable {
    /// The branch name of the build producing the release
    public var branchName: String?
    /// The commit hash of the build producing the release
    public var commitHash: String?
    /// The commit message of the build producing the release
    public var commitMessage: String?

    public init(branchName: String? = nil, commitHash: String? = nil, commitMessage: String? = nil) {
        self.branchName = branchName
        self.commitHash = commitHash
        self.commitMessage = commitMessage
    }

    private enum CodingKeys: String, CodingKey {
        case branchName = "branch_name"
        case commitHash = "commit_hash"
        case commitMessage = "commit_message"
    }
}

/// An object containing all the release metadata.
public struct ReleaseMetadata: Codable {
    /// Dsa signature of the release for the sparkle feed.
    public var dsaSignature: String?
    /// EdDSA signature of the release for the sparkle feed.
    public var edSignature: String?

    public init(dsaSignature: String? = nil, edSignature: String? = nil) {
        self.dsaSignature = dsaSignature
        self.edSignature = edSignature
    }

    private enum CodingKeys: String, CodingKey {
        case dsaSignature = "dsa_signature"
        case edSignature = "ed_signature"
    }
}

/// A unique identifier for a destination. A destination can be identified by an ID (guid) or by a name. DestinationId encapsulates both options. A destination can be either a distribution group or a store.
public struct DestinationID: Codable {
    /// Name of a distribution group / distribution store. The release will be associated with this distribution group or store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
    public var name: String?
    /// Id of a distribution group / store. The release will be associated with this distribution group / store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
    public var id: String?

    public init(name: String? = nil, id: String? = nil) {
        self.name = name
        self.id = id
    }
}

public struct ReleaseDestinationRequest: Codable {
    /// Unique id of the release destination
    public var id: String
    /// Flag to mark the release for the provided destinations as mandatory
    public var isMandatoryUpdate: Bool?
    /// Flag to enable or disable notifications to testers
    public var isNotifyTesters: Bool

    public init(id: String, isMandatoryUpdate: Bool? = nil, isNotifyTesters: Bool? = nil) {
        self.id = id
        self.isMandatoryUpdate = isMandatoryUpdate
        self.isNotifyTesters = isNotifyTesters ?? true
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.isMandatoryUpdate = try values.decodeIfPresent(Bool.self, forKey: "mandatory_update")
        self.isNotifyTesters = try values.decodeIfPresent(Bool.self, forKey: "notify_testers") ?? true
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(isMandatoryUpdate, forKey: "mandatory_update")
        try values.encodeIfPresent(isNotifyTesters, forKey: "notify_testers")
    }
}

public struct ReleaseStoreDestinationRequest: Codable {
    /// Unique id of the release destination
    public var id: String

    public init(id: String) {
        self.id = id
    }
}

public struct ReleaseTesterDestinationRequest: Codable {
    /// Flag to mark the release for the provided destinations as mandatory
    public var isMandatoryUpdate: Bool?
    /// Tester's email address
    public var email: String
    /// Flag to enable or disable notifications to testers
    public var isNotifyTesters: Bool

    public init(isMandatoryUpdate: Bool? = nil, email: String, isNotifyTesters: Bool? = nil) {
        self.isMandatoryUpdate = isMandatoryUpdate
        self.email = email
        self.isNotifyTesters = isNotifyTesters ?? true
    }

    private enum CodingKeys: String, CodingKey {
        case isMandatoryUpdate = "mandatory_update"
        case email
        case isNotifyTesters = "notify_testers"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isMandatoryUpdate = try values.decodeIfPresent(Bool.self, forKey: .isMandatoryUpdate)
        self.email = try values.decode(String.self, forKey: .email)
        self.isNotifyTesters = try values.decodeIfPresent(Bool.self, forKey: .isNotifyTesters) ?? true
    }
}

public struct ReleaseDestinationResponse: Codable {
    /// Unique id for the release destination
    public var id: String
    /// Flag to mark the release for the provided destinations as mandatory
    public var isMandatoryUpdate: Bool
    /// The url to check provisioning status.
    public var provisioningStatusURL: String?

    public init(id: String, isMandatoryUpdate: Bool, provisioningStatusURL: String? = nil) {
        self.id = id
        self.isMandatoryUpdate = isMandatoryUpdate
        self.provisioningStatusURL = provisioningStatusURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.isMandatoryUpdate = try values.decode(Bool.self, forKey: "mandatory_update")
        self.provisioningStatusURL = try values.decodeIfPresent(String.self, forKey: "provisioning_status_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(isMandatoryUpdate, forKey: "mandatory_update")
        try values.encodeIfPresent(provisioningStatusURL, forKey: "provisioning_status_url")
    }
}

public struct ReleaseStoreDestinationResponse: Codable {
    /// Unique id for the release destination
    public var id: String

    public init(id: String) {
        self.id = id
    }
}

public struct Destination: Codable {
    public var a: A
    public var b: B
    /// Name of a distribution group / distribution store. The release will be associated with this distribution group or store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
    public var name: String?
    /// Id of a distribution group / store. The release will be associated with this distribution group / store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
    public var id: String?
    /// Destination can be either store or group.
    public var destinationType: DestinationType?
    /// Display name for the group or tester
    public var displayName: String?

    public struct A: Codable {
        /// ID identifying a unique distribution group.
        public var id: String
        /// A name identifying a unique distribution group.
        public var name: String?
        /// Is the containing release the latest one in this distribution group.
        public var isLatest: Bool?

        public init(id: String, name: String? = nil, isLatest: Bool? = nil) {
            self.id = id
            self.name = name
            self.isLatest = isLatest
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(String.self, forKey: "id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(isLatest, forKey: "is_latest")
        }
    }

    public struct B: Codable {
        /// ID identifying a unique distribution store.
        public var id: String
        /// A name identifying a unique distribution store.
        public var name: String?
        /// Type of the distribution store currently stores type can be intune, googleplay or windows.
        public var type: `Type`?
        /// Publishing status of the release in the store.
        public var publishingStatus: String?
        /// Is the containing release the latest one in this distribution store.
        public var isLatest: Bool?

        /// Type of the distribution store currently stores type can be intune, googleplay or windows.
        public enum `Type`: String, Codable, CaseIterable {
            case intune
            case googleplay
            case apple
            case `none`
        }

        public init(id: String, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil, isLatest: Bool? = nil) {
            self.id = id
            self.name = name
            self.type = type
            self.publishingStatus = publishingStatus
            self.isLatest = isLatest
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(String.self, forKey: "id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.type = try `Type`(from: decoder)
            self.publishingStatus = try values.decodeIfPresent(String.self, forKey: "publishing_status")
            self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encodeIfPresent(publishingStatus, forKey: "publishing_status")
            try values.encodeIfPresent(isLatest, forKey: "is_latest")
        }
    }

    /// Destination can be either store or group.
    public enum DestinationType: String, Codable, CaseIterable {
        case group
        case store
        case tester
    }

    public init(a: A, b: B, name: String? = nil, id: String? = nil, destinationType: DestinationType? = nil, displayName: String? = nil) {
        self.a = a
        self.b = b
        self.name = name
        self.id = id
        self.destinationType = destinationType
        self.displayName = displayName
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.a = try A(from: decoder)
        self.b = try B(from: decoder)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.destinationType = try DestinationType(from: decoder)
        self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(a, forKey: "a")
        try values.encode(b, forKey: "b")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(destinationType, forKey: "destination_type")
        try values.encodeIfPresent(displayName, forKey: "display_name")
    }
}

/// A request containing information for updating a release.
public struct PrivateReleaseUpdateRequest: Codable {
    /// The store publishing status.
    public var publishingStatus: PublishingStatus?

    /// The store publishing status.
    public enum PublishingStatus: String, Codable, CaseIterable {
        case failed
        case processing
        case submitted
        case timeout
    }

    public init(publishingStatus: PublishingStatus? = nil) {
        self.publishingStatus = publishingStatus
    }

    private enum CodingKeys: String, CodingKey {
        case publishingStatus = "publishing_status"
    }
}

public struct DistributionGroup: Codable {
    /// ID identifying a unique distribution group.
    public var id: String
    /// A name identifying a unique distribution group.
    public var name: String?
    /// Is the containing release the latest one in this distribution group.
    public var isLatest: Bool?

    public init(id: String, name: String? = nil, isLatest: Bool? = nil) {
        self.id = id
        self.name = name
        self.isLatest = isLatest
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(isLatest, forKey: "is_latest")
    }
}

public struct DistributionGroupWithoutIsLatest: Codable {
    /// ID identifying a unique distribution group.
    public var id: String
    /// A name identifying a unique distribution group.
    public var name: String?

    public init(id: String, name: String? = nil) {
        self.id = id
        self.name = name
    }
}

public struct DistributionStore: Codable {
    /// ID identifying a unique distribution store.
    public var id: String
    /// A name identifying a unique distribution store.
    public var name: String?
    /// Type of the distribution store currently stores type can be intune, googleplay or windows.
    public var type: `Type`?
    /// Publishing status of the release in the store.
    public var publishingStatus: String?
    /// Is the containing release the latest one in this distribution store.
    public var isLatest: Bool?

    /// Type of the distribution store currently stores type can be intune, googleplay or windows.
    public enum `Type`: String, Codable, CaseIterable {
        case intune
        case googleplay
        case apple
        case `none`
    }

    public init(id: String, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil, isLatest: Bool? = nil) {
        self.id = id
        self.name = name
        self.type = type
        self.publishingStatus = publishingStatus
        self.isLatest = isLatest
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.type = try `Type`(from: decoder)
        self.publishingStatus = try values.decodeIfPresent(String.self, forKey: "publishing_status")
        self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encodeIfPresent(publishingStatus, forKey: "publishing_status")
        try values.encodeIfPresent(isLatest, forKey: "is_latest")
    }
}

public struct DistributionStoreWithoutIsLatest: Codable {
    /// ID identifying a unique distribution store.
    public var id: String
    /// A name identifying a unique distribution store.
    public var name: String?
    /// Type of the distribution store currently stores type can be intune, googleplay or windows.
    public var type: `Type`?
    /// Publishing status of the release in the store.
    public var publishingStatus: String?

    /// Type of the distribution store currently stores type can be intune, googleplay or windows.
    public enum `Type`: String, Codable, CaseIterable {
        case intune
        case googleplay
        case apple
        case `none`
    }

    public init(id: String, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil) {
        self.id = id
        self.name = name
        self.type = type
        self.publishingStatus = publishingStatus
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case type
        case publishingStatus = "publishing_status"
    }
}

/// An object containing a UUID for an architecture for an iOS app.
public struct ArchIdentifier: Codable {
    /// The architecture that the UUID belongs to, i.e. armv7 or arm64.
    public var architecture: String
    /// The unique identifier.
    public var uuid: String

    public init(architecture: String, uuid: String) {
        self.architecture = architecture
        self.uuid = uuid
    }
}

/// An object containing information about an iOS provisioning profile.
public struct ProvisioningProfile: Codable {
    /// The name of the provisioning profile.
    public var name: String
    /// The application identifier.
    public var applicationIdentifier: String
    /// The team identifier.
    public var teamIdentifier: String
    public var profileType: ProfileType
    /// The profile's expiration date in RFC 3339 format, i.e. 2017-07-21T17:32:28Z
    public var expiredAt: String
    public var udids: [String]?

    public enum ProfileType: String, Codable, CaseIterable {
        case adhoc
        case enterprise
        case other
    }

    public init(name: String, applicationIdentifier: String, teamIdentifier: String, profileType: ProfileType, expiredAt: String, udids: [String]? = nil) {
        self.name = name
        self.applicationIdentifier = applicationIdentifier
        self.teamIdentifier = teamIdentifier
        self.profileType = profileType
        self.expiredAt = expiredAt
        self.udids = udids
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case applicationIdentifier = "application_identifier"
        case teamIdentifier = "team_identifier"
        case profileType = "profile_type"
        case expiredAt = "expired_at"
        case udids
    }
}

/// A response containing information about an iOS provisioning profile.
public struct ProvisioningProfileResponse: Codable {
    public var provisioningProfileType: ProvisioningProfileType
    public var udids: [String]?
    /// The name of the provisioning profile.
    public var provisioningProfileName: String?
    /// The team identifier.
    public var teamIdentifier: String?
    /// The bundle identifier associated with the profile.
    public var provisioningBundleID: String?
    /// Array of provisioning profiles for any app extensions
    public var appexProfiles: [ProvisioningProfileResponse]?

    public enum ProvisioningProfileType: String, Codable, CaseIterable {
        case adhoc
        case enterprise
        case other
    }

    public init(provisioningProfileType: ProvisioningProfileType, udids: [String]? = nil, provisioningProfileName: String? = nil, teamIdentifier: String? = nil, provisioningBundleID: String? = nil, appexProfiles: [ProvisioningProfileResponse]? = nil) {
        self.provisioningProfileType = provisioningProfileType
        self.udids = udids
        self.provisioningProfileName = provisioningProfileName
        self.teamIdentifier = teamIdentifier
        self.provisioningBundleID = provisioningBundleID
        self.appexProfiles = appexProfiles
    }

    private enum CodingKeys: String, CodingKey {
        case provisioningProfileType = "provisioning_profile_type"
        case udids
        case provisioningProfileName = "provisioning_profile_name"
        case teamIdentifier = "team_identifier"
        case provisioningBundleID = "provisioning_bundle_id"
        case appexProfiles = "appex_profiles"
    }
}

public struct ReleaseUpdateError: Codable {
    public var code: Code
    public var message: String
    public var releaseNotes: String?
    public var isMandatoryUpdate: Bool?
    public var destinations: [Destination]?

    public enum Code: String, Codable, CaseIterable {
        case badRequest = "BadRequest"
        case conflict = "Conflict"
        case notAcceptable = "NotAcceptable"
        case notFound = "NotFound"
        case internalServerError = "InternalServerError"
        case unauthorized = "Unauthorized"
        case tooManyRequests = "TooManyRequests"
    }

    public struct Destination: Codable {
        /// Error Codes:<br>
        /// <b>invalid_store_secrets</b>: While distributing to store, secrets provided for store are not valid.<br>
        /// <b>store_release_bad_request</b>: Proper package release details for the store is not provided.<br>
        /// <b>store_release_unauthorized</b>: User is not authorized to publish to store due to invalid developer credentials.<br>
        /// <b>store_release_forbidden</b>: Publish to store is forbidden due to conflicts/errors in the release version and already existing version in the store.<br>
        /// <b>store_release_promotion</b>: Release already distributed, promoting a release is not supported.<br>
        /// <b>store_track_deactivated</b>: One or more tracks would be deactivated with this release. This is not supported yet.<br>
        /// <b>store_release_not_found</b>: App with the given package name is not found in the store.<br>
        /// <b>store_release_not_available</b>: The release is not available.<br>
        /// <b>internal_server_error</b>: Failed to distribute to a destination due to an internal server error.
        public var code: String?
        public var message: String?
        public var id: String?
        public var name: String?

        public init(code: String? = nil, message: String? = nil, id: String? = nil, name: String? = nil) {
            self.code = code
            self.message = message
            self.id = id
            self.name = name
        }
    }

    public init(code: Code, message: String, releaseNotes: String? = nil, isMandatoryUpdate: Bool? = nil, destinations: [Destination]? = nil) {
        self.code = code
        self.message = message
        self.releaseNotes = releaseNotes
        self.isMandatoryUpdate = isMandatoryUpdate
        self.destinations = destinations
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.code = try Code(from: decoder)
        self.message = try values.decode(String.self, forKey: "message")
        self.releaseNotes = try values.decodeIfPresent(String.self, forKey: "release_notes")
        self.isMandatoryUpdate = try values.decodeIfPresent(Bool.self, forKey: "mandatory_update")
        self.destinations = try values.decodeIfPresent([Destination].self, forKey: "destinations")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(code, forKey: "code")
        try values.encode(message, forKey: "message")
        try values.encodeIfPresent(releaseNotes, forKey: "release_notes")
        try values.encodeIfPresent(isMandatoryUpdate, forKey: "mandatory_update")
        try values.encodeIfPresent(destinations, forKey: "destinations")
    }
}

public struct DestinationError: Codable {
    /// Error Codes:<br>
    /// <b>invalid_store_secrets</b>: While distributing to store, secrets provided for store are not valid.<br>
    /// <b>store_release_bad_request</b>: Proper package release details for the store is not provided.<br>
    /// <b>store_release_unauthorized</b>: User is not authorized to publish to store due to invalid developer credentials.<br>
    /// <b>store_release_forbidden</b>: Publish to store is forbidden due to conflicts/errors in the release version and already existing version in the store.<br>
    /// <b>store_release_promotion</b>: Release already distributed, promoting a release is not supported.<br>
    /// <b>store_track_deactivated</b>: One or more tracks would be deactivated with this release. This is not supported yet.<br>
    /// <b>store_release_not_found</b>: App with the given package name is not found in the store.<br>
    /// <b>store_release_not_available</b>: The release is not available.<br>
    /// <b>internal_server_error</b>: Failed to distribute to a destination due to an internal server error.
    public var code: String?
    public var message: String?
    public var id: String?
    public var name: String?

    public init(code: String? = nil, message: String? = nil, id: String? = nil, name: String? = nil) {
        self.code = code
        self.message = message
        self.id = id
        self.name = name
    }
}

/// A request containing information for creating a Auto Provisioning Config.
public struct AutoProvisioningConfigRequest: Codable {
    /// A key to a secret in customer-credential-store. apple_developer_account refers to the user's developer account that is used to log into https://developer.apple.com. Normally the user's email.
    public var appleDeveloperAccountKey: String?
    /// A key to a secret in customer-credential-store. distribution_certificate refers to the customer's certificate (that holds the private key) that will be used to sign the app.
    public var appleDistributionCertificateKey: String?
    /// When *true* enables auto provisioning
    public var allowAutoProvisioning: Bool?

    public init(appleDeveloperAccountKey: String? = nil, appleDistributionCertificateKey: String? = nil, allowAutoProvisioning: Bool? = nil) {
        self.appleDeveloperAccountKey = appleDeveloperAccountKey
        self.appleDistributionCertificateKey = appleDistributionCertificateKey
        self.allowAutoProvisioning = allowAutoProvisioning
    }

    private enum CodingKeys: String, CodingKey {
        case appleDeveloperAccountKey = "apple_developer_account_key"
        case appleDistributionCertificateKey = "apple_distribution_certificate_key"
        case allowAutoProvisioning = "allow_auto_provisioning"
    }
}

/// A response from API containing information for a Auto Provisioning Config.
public struct AutoProvisioningConfigResponse: Codable {
    /// The identifier of the config.
    public var id: Double?
    /// The identifier of the App.
    public var appID: String?
    /// The identifier of the destination.
    public var destinationID: String?
    /// A key to a secret in customer-credential-store. apple_developer_account refers to the user's developer account that is used to log into https://developer.apple.com. Normally the user's email.
    public var appleDeveloperAccountKey: String?
    /// A key to a secret in customer-credential-store. distribution_certificate refers to the cusomer's certificate (that holds the private key) that will be used to sign the app.
    public var appleDistributionCertificateKey: String?
    /// When *true* enables auto provisioning
    public var allowAutoProvisioning: Bool?

    public init(id: Double? = nil, appID: String? = nil, destinationID: String? = nil, appleDeveloperAccountKey: String? = nil, appleDistributionCertificateKey: String? = nil, allowAutoProvisioning: Bool? = nil) {
        self.id = id
        self.appID = appID
        self.destinationID = destinationID
        self.appleDeveloperAccountKey = appleDeveloperAccountKey
        self.appleDistributionCertificateKey = appleDistributionCertificateKey
        self.allowAutoProvisioning = allowAutoProvisioning
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case appID = "app_id"
        case destinationID = "destination_id"
        case appleDeveloperAccountKey = "apple_developer_account_key"
        case appleDistributionCertificateKey = "apple_distribution_certificate_key"
        case allowAutoProvisioning = "allow_auto_provisioning"
    }
}

public struct AnalyticsReleasesResponse: Codable {
    public var releases: [Release]?

    public struct Release: Codable {
        /// Release id
        public var releaseID: Int
        /// Distribution group id
        public var distributionGroupID: String
        /// User id
        public var userID: String

        public init(releaseID: Int, distributionGroupID: String, userID: String) {
            self.releaseID = releaseID
            self.distributionGroupID = distributionGroupID
            self.userID = userID
        }

        private enum CodingKeys: String, CodingKey {
            case releaseID = "release_id"
            case distributionGroupID = "distribution_group_id"
            case userID = "user_id"
        }
    }

    public init(releases: [Release]? = nil) {
        self.releases = releases
    }
}

public struct AnalyticsReleasesParameter: Codable {
    /// Release id
    public var releaseID: Int
    /// Distribution group id
    public var distributionGroupID: String
    /// User id
    public var userID: String

    public init(releaseID: Int, distributionGroupID: String, userID: String) {
        self.releaseID = releaseID
        self.distributionGroupID = distributionGroupID
        self.userID = userID
    }

    private enum CodingKeys: String, CodingKey {
        case releaseID = "release_id"
        case distributionGroupID = "distribution_group_id"
        case userID = "user_id"
    }
}

public struct HockeyAppCompatibilityReleaseResponse: Codable {
    public var id: Int?
    public var shortversion: String?
    public var version: String?
    public var uploadedAt: String?
    public var appsize: Int?
    public var notes: String?
    public var isMandatory: Bool?
    public var isExternal: Bool?
    public var deviceFamily: String?
    public var minimumOsVersion: String?
    public var installURL: String?
    public var bundleIdentifier: String?

    public init(id: Int? = nil, shortversion: String? = nil, version: String? = nil, uploadedAt: String? = nil, appsize: Int? = nil, notes: String? = nil, isMandatory: Bool? = nil, isExternal: Bool? = nil, deviceFamily: String? = nil, minimumOsVersion: String? = nil, installURL: String? = nil, bundleIdentifier: String? = nil) {
        self.id = id
        self.shortversion = shortversion
        self.version = version
        self.uploadedAt = uploadedAt
        self.appsize = appsize
        self.notes = notes
        self.isMandatory = isMandatory
        self.isExternal = isExternal
        self.deviceFamily = deviceFamily
        self.minimumOsVersion = minimumOsVersion
        self.installURL = installURL
        self.bundleIdentifier = bundleIdentifier
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case shortversion
        case version
        case uploadedAt = "uploaded_at"
        case appsize
        case notes
        case isMandatory = "mandatory"
        case isExternal = "external"
        case deviceFamily = "device_family"
        case minimumOsVersion = "minimum_os_version"
        case installURL = "install_url"
        case bundleIdentifier = "bundle_identifier"
    }
}

/// Describes the migration schema for a provisioning profile defined in HockeyApp.
public struct ProvisioningProfileMigration: Codable {
    /// The name of the provisioning profile.
    public var name: String
    /// The bundle/application identifier.
    public var bundleID: String
    /// The team identifier.
    public var teamIdentifier: String
    /// The type of provisoning profile.
    public var type: Int
    /// A boolean value that indicates whether the provisioning profile represents an app extension.
    public var isAppex: Bool
    /// The provisioning profile's expiration date in RFC 3339 format, i.e. 2017-07-21T17:32:28Z.
    public var expiredAt: String?
    /// A list of UDIDs of provisioned devices.
    public var udids: [String]?
    /// A provisioning profile URL that indicates where to download it from.
    public var url: String?

    public init(name: String, bundleID: String, teamIdentifier: String, type: Int, isAppex: Bool, expiredAt: String? = nil, udids: [String]? = nil, url: String? = nil) {
        self.name = name
        self.bundleID = bundleID
        self.teamIdentifier = teamIdentifier
        self.type = type
        self.isAppex = isAppex
        self.expiredAt = expiredAt
        self.udids = udids
        self.url = url
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case bundleID = "bundle_id"
        case teamIdentifier = "team_identifier"
        case type
        case isAppex = "is_appex"
        case expiredAt = "expired_at"
        case udids
        case url
    }
}

/// Details of the upload to patch
public struct PrivateUpdateUploadDetails: Codable {
    public var status: Status
    /// Message of the error
    public var errorMessage: String

    public enum Status: String, Codable, CaseIterable {
        case uploadStarted
        case uploadFinished
        case readyToBePublished
        case malwareDetected
        case error
    }

    public init(status: Status, errorMessage: String) {
        self.status = status
        self.errorMessage = errorMessage
    }

    private enum CodingKeys: String, CodingKey {
        case status
        case errorMessage = "error_message"
    }
}

/// Set the download URL of an external build
public struct PostExternalDownloadURL: Codable {
    /// The new download URL
    public var downloadURL: String?

    public init(downloadURL: String? = nil) {
        self.downloadURL = downloadURL
    }

    private enum CodingKeys: String, CodingKey {
        case downloadURL = "download_url"
    }
}

/// Patch the asset id of a release request body
public struct PatchReleaseAssetIDRequest: Codable {
    /// The release new package id in ACFUS
    public var packageAssetID: String
    /// The release upload id used to upload the release
    public var uploadID: String
    /// The ipa UUIDs for this release, as a serialized JSON array
    public var ipaUUIDs: String?

    public init(packageAssetID: String, uploadID: String, ipaUUIDs: String? = nil) {
        self.packageAssetID = packageAssetID
        self.uploadID = uploadID
        self.ipaUUIDs = ipaUUIDs
    }

    private enum CodingKeys: String, CodingKey {
        case packageAssetID = "package_asset_id"
        case uploadID = "upload_id"
        case ipaUUIDs = "ipa_uuids"
    }
}

/// Malware scan result from Malware Scan service
public struct MalwareScanResultPayload: Codable {
    /// Scan request identifier
    public var requestID: String
    /// Scan result
    public var result: Result

    /// Scan result
    public enum Result: String, Codable, CaseIterable {
        case clean
        case infected
        case error
    }

    public init(requestID: String, result: Result) {
        self.requestID = requestID
        self.result = result
    }

    private enum CodingKeys: String, CodingKey {
        case requestID = "requestId"
        case result
    }
}

public struct DistributionSettingsResponse: Codable {
    /// Is this app using the "Default to Public Distribution Groups" logic
    public var isDefaultPublic: Bool

    public init(isDefaultPublic: Bool) {
        self.isDefaultPublic = isDefaultPublic
    }

    private enum CodingKeys: String, CodingKey {
        case isDefaultPublic = "default_public"
    }
}

public struct PublicDistributionGroupsResponse: Codable {
    /// The id of the distribution group
    public var id: String

    public init(id: String) {
        self.id = id
    }
}

/// A response containing the fully encoded binary blob for a mobileconfig
public struct DeviceConfigurationResponse: Codable {
    /// A data URL containing a signed mobileconfig profile
    public var dataURL: String

    public init(dataURL: String) {
        self.dataURL = dataURL
    }

    private enum CodingKeys: String, CodingKey {
        case dataURL = "data_url"
    }
}

/// The information for a single iOS device
public struct DeviceInfoRequest: Codable {
    /// The Unique Device IDentifier of the device
    public var udid: String
    /// The model identifier of the device, in the format iDeviceM,N
    public var model: String
    /// The build number of the last known OS version running on the device
    public var osBuild: String?
    /// The last known OS version running on the device
    public var osVersion: String?
    /// The device's serial number. Always empty or undefined at present.
    public var serial: String?
    /// The device's International Mobile Equipment Identity number. Always empty or undefined at present.
    public var imei: String?
    /// The user ID of the device owner.
    public var ownerID: String?

    public init(udid: String, model: String, osBuild: String? = nil, osVersion: String? = nil, serial: String? = nil, imei: String? = nil, ownerID: String? = nil) {
        self.udid = udid
        self.model = model
        self.osBuild = osBuild
        self.osVersion = osVersion
        self.serial = serial
        self.imei = imei
        self.ownerID = ownerID
    }

    private enum CodingKeys: String, CodingKey {
        case udid
        case model
        case osBuild = "os_build"
        case osVersion = "os_version"
        case serial
        case imei
        case ownerID = "owner_id"
    }
}

/// The information for a single iOS device
public struct DeviceInfoResponse: Codable {
    /// The Unique Device IDentifier of the device
    public var udid: String
    /// The model identifier of the device, in the format iDeviceM,N
    public var model: String
    /// The device description, in the format "iPhone 7 Plus (A1784)"
    public var deviceName: String
    /// A combination of the device model name and the owner name.
    public var fullDeviceName: String?
    /// The last known OS version running on the device
    public var osBuild: String
    /// The last known OS version running on the device
    public var osVersion: String
    /// The device's serial number. Always empty or undefined at present.
    public var serial: String?
    /// The device's International Mobile Equipment Identity number. Always empty or undefined at present.
    public var imei: String?
    /// The user ID of the device owner.
    public var ownerID: String?
    /// The provisioning status of the device.
    public var status: String
    /// Timestamp of when the device was registered in ISO format.
    public var registeredAt: String?

    public init(udid: String, model: String, deviceName: String, fullDeviceName: String? = nil, osBuild: String, osVersion: String, serial: String? = nil, imei: String? = nil, ownerID: String? = nil, status: String, registeredAt: String? = nil) {
        self.udid = udid
        self.model = model
        self.deviceName = deviceName
        self.fullDeviceName = fullDeviceName
        self.osBuild = osBuild
        self.osVersion = osVersion
        self.serial = serial
        self.imei = imei
        self.ownerID = ownerID
        self.status = status
        self.registeredAt = registeredAt
    }

    private enum CodingKeys: String, CodingKey {
        case udid
        case model
        case deviceName = "device_name"
        case fullDeviceName = "full_device_name"
        case osBuild = "os_build"
        case osVersion = "os_version"
        case serial
        case imei
        case ownerID = "owner_id"
        case status
        case registeredAt = "registered_at"
    }
}

/// The status of the resign operation.
public struct ResignStatus: Codable {
    /// The status of the resign
    public var status: String
    /// Error code for any error that occured during the resigning operation.
    public var errorCode: String?
    /// Error message for any error that occured during the resigning operation.
    public var errorMessage: String?

    public init(status: String, errorCode: String? = nil, errorMessage: String? = nil) {
        self.status = status
        self.errorCode = errorCode
        self.errorMessage = errorMessage
    }

    private enum CodingKeys: String, CodingKey {
        case status
        case errorCode = "error_code"
        case errorMessage = "error_message"
    }
}

/// The information for a resign attempt.
public struct ResignInfo: Codable {
    /// The group name of the resign attempt
    public var groupName: String?
    /// The provisioning profile name of group for the given resign attempt
    public var profileName: String?
    /// The provisioning profile type of group for the given resign attempt
    public var profileType: String?
    /// The name of the certificate used for the resign attempt
    public var certificateName: String?
    /// The expiration date of the certificate used for the resign attempt
    public var certificateExpiration: String?

    public init(groupName: String? = nil, profileName: String? = nil, profileType: String? = nil, certificateName: String? = nil, certificateExpiration: String? = nil) {
        self.groupName = groupName
        self.profileName = profileName
        self.profileType = profileType
        self.certificateName = certificateName
        self.certificateExpiration = certificateExpiration
    }

    private enum CodingKeys: String, CodingKey {
        case groupName = "group_name"
        case profileName = "profile_name"
        case profileType = "profile_type"
        case certificateName = "certificate_name"
        case certificateExpiration = "certificate_expiration"
    }
}

/// The information for a single distribution group member and their ios device
public struct MemberDevicesInfoResponse: Codable {
    /// The unique id (UUID) of the user
    public var id: String
    /// The avatar URL of the user
    public var avatarURL: String?
    /// User is required to send an old password in order to change the password.
    public var canChangePassword: Bool?
    /// The full name of the user. Might for example be first and last name
    public var displayName: String?
    /// The email address of the user
    public var email: String
    /// Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".
    public var isInvitePending: Bool?
    /// The unique name that is used to identify the user.
    public var name: String?
    /// The Unique Device IDentifier of the device
    public var udid: String
    /// The model identifier of the device, in the format iDeviceM,N
    public var model: String
    /// The device description, in the format "iPhone 7 Plus (A1784)"
    public var deviceName: String
    /// A combination of the device model name and the owner name.
    public var fullDeviceName: String?
    /// The last known OS version running on the device
    public var osBuild: String
    /// The last known OS version running on the device
    public var osVersion: String
    /// The device's serial number. Always empty or undefined at present.
    public var serial: String?
    /// The device's International Mobile Equipment Identity number. Always empty or undefined at present.
    public var imei: String?
    /// The user ID of the device owner.
    public var ownerID: String?
    /// The provisioning status of the device.
    public var status: String
    /// Timestamp of when the device was registered in ISO format.
    public var registeredAt: String?

    public init(id: String, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String? = nil, email: String, isInvitePending: Bool? = nil, name: String? = nil, udid: String, model: String, deviceName: String, fullDeviceName: String? = nil, osBuild: String, osVersion: String, serial: String? = nil, imei: String? = nil, ownerID: String? = nil, status: String, registeredAt: String? = nil) {
        self.id = id
        self.avatarURL = avatarURL
        self.canChangePassword = canChangePassword
        self.displayName = displayName
        self.email = email
        self.isInvitePending = isInvitePending
        self.name = name
        self.udid = udid
        self.model = model
        self.deviceName = deviceName
        self.fullDeviceName = fullDeviceName
        self.osBuild = osBuild
        self.osVersion = osVersion
        self.serial = serial
        self.imei = imei
        self.ownerID = ownerID
        self.status = status
        self.registeredAt = registeredAt
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case avatarURL = "avatar_url"
        case canChangePassword = "can_change_password"
        case displayName = "display_name"
        case email
        case isInvitePending = "invite_pending"
        case name
        case udid
        case model
        case deviceName = "device_name"
        case fullDeviceName = "full_device_name"
        case osBuild = "os_build"
        case osVersion = "os_version"
        case serial
        case imei
        case ownerID = "owner_id"
        case status
        case registeredAt = "registered_at"
    }
}

/// The publising information.
public struct PublishDevicesRequest: Codable {
    /// The username for the Apple Developer account to publish the devices to.
    public var username: String?
    /// The password for the Apple Developer account to publish the devices to.
    public var password: String?
    /// The service_connection_id of the stored Apple credentials instead of username, password.
    public var accountServiceConnectionID: String?
    /// When set to true, all unprovisioned devices will be published to the Apple Developer account.  When false, only the provided devices will be published to the Apple Developer account.
    public var isPublishAllDevices: Bool?
    /// Array of device UDID's to be published to the Apple Developer account.
    public var devices: [String]?

    public init(username: String? = nil, password: String? = nil, accountServiceConnectionID: String? = nil, isPublishAllDevices: Bool? = nil, devices: [String]? = nil) {
        self.username = username
        self.password = password
        self.accountServiceConnectionID = accountServiceConnectionID
        self.isPublishAllDevices = isPublishAllDevices
        self.devices = devices
    }

    private enum CodingKeys: String, CodingKey {
        case username
        case password
        case accountServiceConnectionID = "account_service_connection_id"
        case isPublishAllDevices = "publish_all_devices"
        case devices
    }
}

/// The information for a single iOS device
public struct PublishDevicesResponse: Codable {
    /// The file name for the provisioning profile.
    public var profileFileName: String?
    /// The updated provisioning profiles zip base64 encoded.
    public var profilesZipBase64: String

    public init(profileFileName: String? = nil, profilesZipBase64: String) {
        self.profileFileName = profileFileName
        self.profilesZipBase64 = profilesZipBase64
    }

    private enum CodingKeys: String, CodingKey {
        case profileFileName = "profile_file_name"
        case profilesZipBase64 = "profiles_zip_base64"
    }
}

/// Apple credentials needed to log into the Apple Developer Portal
public struct AppleLoginRequest: Codable {
    /// The username for the Apple Developer account.
    public var username: String
    /// The password for the Apple Developer account.
    public var password: String
    /// Identifier of the team to use when logged in.
    public var teamIdentifier: String?
    /// The 30-day session cookie for multi-factor authentication backed accounts.
    public var cookie: String?

    public init(username: String, password: String, teamIdentifier: String? = nil, cookie: String? = nil) {
        self.username = username
        self.password = password
        self.teamIdentifier = teamIdentifier
        self.cookie = cookie
    }

    private enum CodingKeys: String, CodingKey {
        case username
        case password
        case teamIdentifier = "team_identifier"
        case cookie
    }
}

/// Indicates if login was successful.
public struct AppleLoginResponse: Codable {
    /// True when login was successful.
    public var isSuccessful: Bool?

    public init(isSuccessful: Bool? = nil) {
        self.isSuccessful = isSuccessful
    }

    private enum CodingKeys: String, CodingKey {
        case isSuccessful = "successful"
    }
}

/// Apple credentials needed to log into the Apple Developer Portal
public struct AppleMutifactorLoginRequest: Codable {
    /// The username for the Apple Developer account.
    public var username: String
    /// This is the six digit OTP used for completing the multi-factor authentication
    public var authcode: String

    public init(username: String, authcode: String) {
        self.username = username
        self.authcode = authcode
    }
}

/// The response of Multifactor login. This is a 30 day session token generated by apple.
public struct AppleMultifactorLoginResponse: Codable {
    /// The apple developer account.
    public var username: String?
    /// The 30-day session Token generated by apple after successfully logging in with Multifactor authentication.
    public var cookie: String?
    /// The expiry date of the cookie generated by apple
    public var expires: String?

    public init(username: String? = nil, cookie: String? = nil, expires: String? = nil) {
        self.username = username
        self.cookie = cookie
        self.expires = expires
    }
}

/// The information needed to fetch the status of an application
public struct ApplicationStatusRequest: Codable {
    /// The username for the Apple Developer account.
    public var username: String
    /// The password for the Apple Developer account.
    public var password: String
    /// Bundle Identifier of application in Apple Itunes portal.
    public var bundleIdentifier: String
    /// Track Identifier for which the status is to be fetched.
    public var trackIdentifier: String
    /// The version of build for which real time status is to be fetched.
    public var buildVersion: String?
    /// Identifier of the team to use when logged in.
    public var teamIdentifier: String?
    /// The Train version for which the status is to be fetched.
    public var trainVersion: String?

    public init(username: String, password: String, bundleIdentifier: String, trackIdentifier: String, buildVersion: String? = nil, teamIdentifier: String? = nil, trainVersion: String? = nil) {
        self.username = username
        self.password = password
        self.bundleIdentifier = bundleIdentifier
        self.trackIdentifier = trackIdentifier
        self.buildVersion = buildVersion
        self.teamIdentifier = teamIdentifier
        self.trainVersion = trainVersion
    }

    private enum CodingKeys: String, CodingKey {
        case username
        case password
        case bundleIdentifier = "bundle_identifier"
        case trackIdentifier = "track_identifier"
        case buildVersion = "build_version"
        case teamIdentifier = "team_identifier"
        case trainVersion = "train_version"
    }
}

/// The status information from Itunes portal
public struct ApplicationStatusResponse: Codable {
    /// The type of version being returned (production/edit/test flight).
    public var versionType: String
    /// The version of the application
    public var version: String?

    public init(versionType: String, version: String? = nil) {
        self.versionType = versionType
        self.version = version
    }

    private enum CodingKeys: String, CodingKey {
        case versionType = "version_type"
        case version
    }
}

/// Apple credentials with username, password or service_connection_id of the stored credentials is needed along with team_identifier.
public struct ItunesAppsRequest: Codable {
    /// The username for the Apple Developer account.
    public var username: String?
    /// The password for the Apple Developer account.
    public var password: String?
    /// The service_connection_id of the stored Apple credentials instead of username, password.
    public var serviceConnectionID: String?
    /// Identifier of the team to use when logged in.
    public var teamIdentifier: String?
    /// The 30-day session cookie for multi-factor authentication backed accounts.
    public var cookie: String?

    public init(username: String? = nil, password: String? = nil, serviceConnectionID: String? = nil, teamIdentifier: String? = nil, cookie: String? = nil) {
        self.username = username
        self.password = password
        self.serviceConnectionID = serviceConnectionID
        self.teamIdentifier = teamIdentifier
        self.cookie = cookie
    }

    private enum CodingKeys: String, CodingKey {
        case username
        case password
        case serviceConnectionID = "service_connection_id"
        case teamIdentifier = "team_identifier"
        case cookie
    }
}

/// Apple credentials with username, password or service_connection_id of the stored credentials is needed.
public struct ItunesTeamsRequest: Codable {
    /// The username for the Apple Developer account.
    public var username: String?
    /// The password for the Apple Developer account.
    public var password: String?
    /// The service_connection_id of the stored Apple credentials instead of username, password.
    public var serviceConnectionID: String?
    /// The 30-day session cookie for multi-factor authentication backed accounts.
    public var cookie: String?

    public init(username: String? = nil, password: String? = nil, serviceConnectionID: String? = nil, cookie: String? = nil) {
        self.username = username
        self.password = password
        self.serviceConnectionID = serviceConnectionID
        self.cookie = cookie
    }

    private enum CodingKeys: String, CodingKey {
        case username
        case password
        case serviceConnectionID = "service_connection_id"
        case cookie
    }
}

/// Itunes teams details .
public struct ItunesTeamsResponse: Codable {
    /// Itunes team id.
    public var teamID: String?
    /// Itunes Team Name
    public var teamName: String?

    public init(teamID: String? = nil, teamName: String? = nil) {
        self.teamID = teamID
        self.teamName = teamName
    }

    private enum CodingKeys: String, CodingKey {
        case teamID = "teamId"
        case teamName
    }
}

/// Itunes teams details .
public struct AllItunesAppsResponse: Codable {
    /// Apple id for app team id.
    public var appleID: String?
    /// Bundle identifier of app
    public var bundleID: String?
    /// App Name
    public var name: String?
    /// Url for the app icon from app store
    public var iconURL: String?

    public init(appleID: String? = nil, bundleID: String? = nil, name: String? = nil, iconURL: String? = nil) {
        self.appleID = appleID
        self.bundleID = bundleID
        self.name = name
        self.iconURL = iconURL
    }

    private enum CodingKeys: String, CodingKey {
        case appleID = "apple_id"
        case bundleID = "bundle_id"
        case name
        case iconURL = "iconUrl"
    }
}

/// Apple details for fetching test flight groups from Apple Developer Portal. pass either apple_id or bundle_identifier to get the test flight groups. if both are passed than apple_id will take preference
public struct AppleTestFlightGroupRequest: Codable {
    /// The username for the Apple Developer account.
    public var username: String?
    /// The password for the Apple Developer account.
    public var password: String?
    /// Apple_id of the app for which test flight groups need to be fetched.
    public var appleID: String?
    /// Apple_id of the app for which test flight groups need to be fetched.
    public var bundleIdentifier: String?
    /// Identifier of the team to use when logged in.
    public var teamIdentifier: String?
    /// The 30-day session cookie for multi-factor authentication backed accounts.
    public var cookie: String?
    /// The service_connection_id of the stored Apple credentials instead of username, password.
    public var serviceConnectionID: String?

    public init(username: String? = nil, password: String? = nil, appleID: String? = nil, bundleIdentifier: String? = nil, teamIdentifier: String? = nil, cookie: String? = nil, serviceConnectionID: String? = nil) {
        self.username = username
        self.password = password
        self.appleID = appleID
        self.bundleIdentifier = bundleIdentifier
        self.teamIdentifier = teamIdentifier
        self.cookie = cookie
        self.serviceConnectionID = serviceConnectionID
    }

    private enum CodingKeys: String, CodingKey {
        case username
        case password
        case appleID = "apple_id"
        case bundleIdentifier = "bundle_identifier"
        case teamIdentifier = "team_identifier"
        case cookie
        case serviceConnectionID = "service_connection_id"
    }
}

/// Test flight group details for the app.
public struct AppleTestFlightGroupResponse: Codable {
    /// Id of the group.
    public var id: String?
    /// Provider id of the group.
    public var providerID: Double?
    /// Apple id of the group.
    public var appAdamID: Double?
    /// Name of the group.
    public var name: String?
    /// True if group is in active state.
    public var isActive: Bool?
    /// True if the group is an internal group.
    public var isInternalGroup: Bool?

    public init(id: String? = nil, providerID: Double? = nil, appAdamID: Double? = nil, name: String? = nil, isActive: Bool? = nil, isInternalGroup: Bool? = nil) {
        self.id = id
        self.providerID = providerID
        self.appAdamID = appAdamID
        self.name = name
        self.isActive = isActive
        self.isInternalGroup = isInternalGroup
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case providerID = "providerId"
        case appAdamID = "appAdamId"
        case name
        case isActive = "active"
        case isInternalGroup
    }
}

/// Apple credentials needed to log into the Apple Developer Portal and access provisioning profiles
public struct AvailabilityOfDevicesRequest: Codable {
    /// The username for the Apple Developer account.
    public var username: String?
    /// The password for the Apple Developer account.
    public var password: String?
    /// The service_connection_id of the stored Apple credentials instad of username, password.
    public var serviceConnectionID: String?

    public init(username: String? = nil, password: String? = nil, serviceConnectionID: String? = nil) {
        self.username = username
        self.password = password
        self.serviceConnectionID = serviceConnectionID
    }

    private enum CodingKeys: String, CodingKey {
        case username
        case password
        case serviceConnectionID = "service_connection_id"
    }
}

/// ...
public struct DeviceAvailability: Codable {
    public var registered: Double
    public var available: Double
    public var maximum: Double

    public init(registered: Double, available: Double, maximum: Double) {
        self.registered = registered
        self.available = available
        self.maximum = maximum
    }
}

/// The current device availability (registered, available and maxmimum) for iPhones, iPads, iPods and Watches from Apple Developer Portal
public struct AvailabilityOfDevicesResponse: Codable {
    /// ...
    public var iphones: Iphones
    /// ...
    public var ipads: Ipads
    /// ...
    public var ipods: Ipods
    /// ...
    public var watches: Watches

    /// ...
    public struct Iphones: Codable {
        public var registered: Double
        public var available: Double
        public var maximum: Double

        public init(registered: Double, available: Double, maximum: Double) {
            self.registered = registered
            self.available = available
            self.maximum = maximum
        }
    }

    /// ...
    public struct Ipads: Codable {
        public var registered: Double
        public var available: Double
        public var maximum: Double

        public init(registered: Double, available: Double, maximum: Double) {
            self.registered = registered
            self.available = available
            self.maximum = maximum
        }
    }

    /// ...
    public struct Ipods: Codable {
        public var registered: Double
        public var available: Double
        public var maximum: Double

        public init(registered: Double, available: Double, maximum: Double) {
            self.registered = registered
            self.available = available
            self.maximum = maximum
        }
    }

    /// ...
    public struct Watches: Codable {
        public var registered: Double
        public var available: Double
        public var maximum: Double

        public init(registered: Double, available: Double, maximum: Double) {
            self.registered = registered
            self.available = available
            self.maximum = maximum
        }
    }

    public init(iphones: Iphones, ipads: Ipads, ipods: Ipods, watches: Watches) {
        self.iphones = iphones
        self.ipads = ipads
        self.ipods = ipods
        self.watches = watches
    }
}

/// Information required to publish devices to the Apple Developer account and resign the application.
public struct UpdateDevicesRequest: Codable {
    /// When provided, will update the provided release with the new set of devices. By default the latest release of the distribution group is used when this property is omitted. If `release_id` is passed in the path, there is no need to pass in the body as well.
    public var releaseID: Double?
    /// The username for the Apple Developer account to publish the devices to.
    public var username: String?
    /// The password for the Apple Developer account to publish the devices to.
    public var password: String?
    /// The service_connection_id of the stored Apple credentials instead of username, password.
    public var accountServiceConnectionID: String?
    /// The certificate to use for resigning the application with the updated provisioning profiles.
    public var p12Base64: String?
    /// The service_connection_id of the stored Apple certificate instead of p12_base64 value.
    public var p12ServiceConnectionID: String?
    /// The password certificate if one is needed.
    public var p12Password: String?
    /// When set to true, all unprovisioned devices will be published to the Apple Developer account.  When false, only the provided devices will be published to the Apple Developer account.
    public var isPublishAllDevices: Bool?
    /// Array of device UDID's to be published to the Apple Developer account.
    public var devices: [String]?
    /// Array of distribution groups that the devices should be provisioned from.
    public var destinations: [Destination]?

    public struct Destination: Codable {
        public var name: String?

        public init(name: String? = nil) {
            self.name = name
        }
    }

    public init(releaseID: Double? = nil, username: String? = nil, password: String? = nil, accountServiceConnectionID: String? = nil, p12Base64: String? = nil, p12ServiceConnectionID: String? = nil, p12Password: String? = nil, isPublishAllDevices: Bool? = nil, devices: [String]? = nil, destinations: [Destination]? = nil) {
        self.releaseID = releaseID
        self.username = username
        self.password = password
        self.accountServiceConnectionID = accountServiceConnectionID
        self.p12Base64 = p12Base64
        self.p12ServiceConnectionID = p12ServiceConnectionID
        self.p12Password = p12Password
        self.isPublishAllDevices = isPublishAllDevices
        self.devices = devices
        self.destinations = destinations
    }

    private enum CodingKeys: String, CodingKey {
        case releaseID = "release_id"
        case username
        case password
        case accountServiceConnectionID = "account_service_connection_id"
        case p12Base64 = "p12_base64"
        case p12ServiceConnectionID = "p12_service_connection_id"
        case p12Password = "p12_password"
        case isPublishAllDevices = "publish_all_devices"
        case devices
        case destinations
    }
}

/// URL that can be used to check the status of the update devices operation and the updated profiles.
public struct UpdateDevicesResponse: Codable {
    /// URL that can be used to check the status of the update devices operation.
    public var statusURL: String

    public init(statusURL: String) {
        self.statusURL = statusURL
    }

    private enum CodingKeys: String, CodingKey {
        case statusURL = "status_url"
    }
}

/// Updates the status of the resign request
public struct UpdateResignStatusRequest: Codable {
    /// The updated status for the resigning request.
    public var status: String
    /// Error code if an error occured in the resigning operation.
    public var errorCode: String?
    /// Error message if an error occured in the resigning operation.
    public var errorMessage: String?
    /// ReleaseMetadata from ios resigner extractor
    public var releaseMetadata: [String: AnyJSON]?

    public init(status: String, errorCode: String? = nil, errorMessage: String? = nil, releaseMetadata: [String: AnyJSON]? = nil) {
        self.status = status
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.releaseMetadata = releaseMetadata
    }

    private enum CodingKeys: String, CodingKey {
        case status
        case errorCode = "error_code"
        case errorMessage = "error_message"
        case releaseMetadata
    }
}

/// URL that can be used to check the status of the update devices operation and the updated profiles.
public struct UpdateResignStatusResponse: Codable {
    /// The status.
    public var status: String
    /// A zip of the updated provisioning profiles. Base64 encoded.
    public var profilesZipBase64: String?

    public init(status: String, profilesZipBase64: String? = nil) {
        self.status = status
        self.profilesZipBase64 = profilesZipBase64
    }

    private enum CodingKeys: String, CodingKey {
        case status
        case profilesZipBase64 = "profiles_zip_base64"
    }
}

/// The url that can be navigated to in order to start the device registration process.
public struct DeviceRegistrationURL: Codable {
    /// The url that can be navigated to in order to start the device registration process.
    public var registrationURL: String

    public init(registrationURL: String) {
        self.registrationURL = registrationURL
    }

    private enum CodingKeys: String, CodingKey {
        case registrationURL = "registration_url"
    }
}

/// URL that can be used to check the status of the update devices operation and the updated profiles.
public struct ResignAttemptResponse: Codable {
    /// The status of the resigning operation.
    public var status: String
    /// ID of the user performing the resign operaiton.
    public var userID: String
    /// App ID that the resign operation is being performed against.
    public var appID: String
    /// ID of the release which is being resigned.
    public var originalReleaseID: Double
    /// ID of the resign operation.
    public var resignID: String
    /// Context ID for the resigning operation.
    public var contextID: String
    /// The time that the resign operation was started.
    public var startTime: Double
    /// List of destinations that the resign operation is being performed against.
    public var destinations: [[String: AnyJSON]]?
    /// Error code associated with the exception.
    public var errorCode: String?
    /// Error message associated with the exception.
    public var errorMessage: String?

    public init(status: String, userID: String, appID: String, originalReleaseID: Double, resignID: String, contextID: String, startTime: Double, destinations: [[String: AnyJSON]]? = nil, errorCode: String? = nil, errorMessage: String? = nil) {
        self.status = status
        self.userID = userID
        self.appID = appID
        self.originalReleaseID = originalReleaseID
        self.resignID = resignID
        self.contextID = contextID
        self.startTime = startTime
        self.destinations = destinations
        self.errorCode = errorCode
        self.errorMessage = errorMessage
    }

    private enum CodingKeys: String, CodingKey {
        case status
        case userID = "userId"
        case appID = "appId"
        case originalReleaseID = "originalReleaseId"
        case resignID = "resignId"
        case contextID = "contextId"
        case startTime
        case destinations
        case errorCode
        case errorMessage
    }
}

/// Details of an uploaded release
public struct StoresReleaseDetails: Codable {
    /// ID identifying this unique release.
    public var id: Double?
    /// OBSOLETE. Will be removed in next version. The availability concept is now replaced with distributed. Any 'available' release will be associated with the default distribution group of an app.</br>
    /// The release state.<br>
    /// <b>available</b>: The uploaded release has been distributed.<br>
    /// <b>unavailable</b>: The uploaded release is not visible to the user. <br>
    public var status: Status?
    /// The app's name (extracted from the uploaded release).
    public var appName: String?
    /// The app's display name.
    public var appDisplayName: String?
    /// The release's version.<br>
    /// For iOS: CFBundleVersion from info.plist.
    /// For Android: android:versionCode from AppManifest.xml.
    public var version: String?
    /// The release's short version.<br>
    /// For iOS: CFBundleShortVersionString from info.plist.
    /// For Android: android:versionName from AppManifest.xml.
    public var shortVersion: String?
    /// The release's release notes.
    public var releaseNotes: String?
    /// The release's size in bytes.
    public var size: Double?
    /// The release's minimum required operating system.
    public var minOs: String?
    /// The release's minimum required Android API level.
    public var androidMinAPILevel: String?
    /// The identifier of the apps bundle.
    public var bundleIdentifier: String?
    /// MD5 checksum of the release binary.
    public var fingerprint: String?
    /// UTC time in ISO 8601 format of the uploaded time.
    public var uploadedAt: String?
    /// The URL that hosts the binary for this release.
    public var downloadURL: String?
    /// The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`
    public var installURL: InstallURL?
    /// A list of distribution stores that are associated with this release.
    public var distributionStores: [DistributionStore]?

    /// OBSOLETE. Will be removed in next version. The availability concept is now replaced with distributed. Any 'available' release will be associated with the default distribution group of an app.</br>
    /// The release state.<br>
    /// <b>available</b>: The uploaded release has been distributed.<br>
    /// <b>unavailable</b>: The uploaded release is not visible to the user. <br>
    public enum Status: String, Codable, CaseIterable {
        case available
        case unavailable
    }

    /// The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`
    public enum InstallURL: String, Codable, CaseIterable {
        case group
        case store
    }

    public struct DistributionStore: Codable {
        /// ID identifying a unique distribution store.
        public var id: String?
        /// A name identifying a unique distribution store.
        public var name: String?
        /// Type of the distribution store currently stores type can be intune or googleplay.
        public var type: `Type`?
        /// Publishing status of the release in the store.
        public var publishingStatus: String?

        /// Type of the distribution store currently stores type can be intune or googleplay.
        public enum `Type`: String, Codable, CaseIterable {
            case intune
            case googleplay
        }

        public init(id: String? = nil, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil) {
            self.id = id
            self.name = name
            self.type = type
            self.publishingStatus = publishingStatus
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case name
            case type
            case publishingStatus = "publishing_status"
        }
    }

    public init(id: Double? = nil, status: Status? = nil, appName: String? = nil, appDisplayName: String? = nil, version: String? = nil, shortVersion: String? = nil, releaseNotes: String? = nil, size: Double? = nil, minOs: String? = nil, androidMinAPILevel: String? = nil, bundleIdentifier: String? = nil, fingerprint: String? = nil, uploadedAt: String? = nil, downloadURL: String? = nil, installURL: InstallURL? = nil, distributionStores: [DistributionStore]? = nil) {
        self.id = id
        self.status = status
        self.appName = appName
        self.appDisplayName = appDisplayName
        self.version = version
        self.shortVersion = shortVersion
        self.releaseNotes = releaseNotes
        self.size = size
        self.minOs = minOs
        self.androidMinAPILevel = androidMinAPILevel
        self.bundleIdentifier = bundleIdentifier
        self.fingerprint = fingerprint
        self.uploadedAt = uploadedAt
        self.downloadURL = downloadURL
        self.installURL = installURL
        self.distributionStores = distributionStores
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case status
        case appName = "app_name"
        case appDisplayName = "app_display_name"
        case version
        case shortVersion = "short_version"
        case releaseNotes = "release_notes"
        case size
        case minOs = "min_os"
        case androidMinAPILevel = "android_min_api_level"
        case bundleIdentifier = "bundle_identifier"
        case fingerprint
        case uploadedAt = "uploaded_at"
        case downloadURL = "download_url"
        case installURL = "install_url"
        case distributionStores = "distribution_stores"
    }
}

public struct StorePatchRequest: Codable {
    /// Service connection id to updated.
    public var serviceConnectionID: String

    public init(serviceConnectionID: String) {
        self.serviceConnectionID = serviceConnectionID
    }

    private enum CodingKeys: String, CodingKey {
        case serviceConnectionID = "service_connection_id"
    }
}

/// ExternalStoreRequest
public struct ExternalStoreRequest: Codable {
    /// Store Type
    public var type: `Type`?
    /// Name of the store. In case of googleplay, and Apple store this is fixed to Production.
    public var name: String?
    /// Track of the store. Can be production, alpha & beta for googleplay. Can be production, testflight-internal & testflight-external for Apple Store.
    public var track: Track?
    public var intuneDetails: IntuneDetails?
    /// Id for the shared service connection. In case of Apple AppStore, this connection will be used to create and connect to the Apple AppStore in Mobile Center.
    public var serviceConnectionID: String?

    /// Store Type
    public enum `Type`: String, Codable, CaseIterable {
        case googleplay
        case apple
        case intune
    }

    /// Track of the store. Can be production, alpha & beta for googleplay. Can be production, testflight-internal & testflight-external for Apple Store.
    public enum Track: String, Codable, CaseIterable {
        case production
        case alpha
        case beta
        case testflightInternal = "testflight-internal"
        case testflightExternal = "testflight-external"
    }

    public struct IntuneDetails: Codable {
        public var secretJSON: SecretJSON?
        public var targetAudience: TargetAudience?
        public var appCategory: AppCategory?
        /// Tenant id of the intune store
        public var tenantID: String?

        public struct SecretJSON: Codable {
            /// The id token of user
            public var idToken: String?
            /// The refresh token for user
            public var refreshToken: String?
            /// The expiry of refresh token
            public var refreshTokenExpiry: String?

            public init(idToken: String? = nil, refreshToken: String? = nil, refreshTokenExpiry: String? = nil) {
                self.idToken = idToken
                self.refreshToken = refreshToken
                self.refreshTokenExpiry = refreshTokenExpiry
            }

            private enum CodingKeys: String, CodingKey {
                case idToken = "id_token"
                case refreshToken = "refresh_token"
                case refreshTokenExpiry = "refresh_token_expiry"
            }
        }

        public struct TargetAudience: Codable {
            /// Display name for the target audience/group
            public var name: String?

            public init(name: String? = nil) {
                self.name = name
            }
        }

        public struct AppCategory: Codable {
            /// Display name for the app category
            public var name: String?

            public init(name: String? = nil) {
                self.name = name
            }
        }

        public init(secretJSON: SecretJSON? = nil, targetAudience: TargetAudience? = nil, appCategory: AppCategory? = nil, tenantID: String? = nil) {
            self.secretJSON = secretJSON
            self.targetAudience = targetAudience
            self.appCategory = appCategory
            self.tenantID = tenantID
        }

        private enum CodingKeys: String, CodingKey {
            case secretJSON = "secret_json"
            case targetAudience = "target_audience"
            case appCategory = "app_category"
            case tenantID = "tenant_id"
        }
    }

    public init(type: `Type`? = nil, name: String? = nil, track: Track? = nil, intuneDetails: IntuneDetails? = nil, serviceConnectionID: String? = nil) {
        self.type = type
        self.name = name
        self.track = track
        self.intuneDetails = intuneDetails
        self.serviceConnectionID = serviceConnectionID
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case name
        case track
        case intuneDetails = "intune_details"
        case serviceConnectionID = "service_connection_id"
    }
}

/// Apple Mapping Request Type
public struct AppleMappingRequest: Codable {
    /// Id for the shared service connection. In case of Apple AppStore, this connection will be used to create and connect to the Apple AppStore in Mobile Center.
    public var serviceConnectionID: String
    /// ID of the apple application in apple store, takes precedence over bundle_identifier when both are provided
    public var appleID: String?
    /// Bundle Identifier of the apple package
    public var bundleIdentifier: String?
    /// ID of the Team associated with the app in apple store
    public var teamIdentifier: String

    public init(serviceConnectionID: String, appleID: String? = nil, bundleIdentifier: String? = nil, teamIdentifier: String) {
        self.serviceConnectionID = serviceConnectionID
        self.appleID = appleID
        self.bundleIdentifier = bundleIdentifier
        self.teamIdentifier = teamIdentifier
    }

    private enum CodingKeys: String, CodingKey {
        case serviceConnectionID = "service_connection_id"
        case appleID = "apple_id"
        case bundleIdentifier = "bundle_identifier"
        case teamIdentifier = "team_identifier"
    }
}

/// Apple Mapping Request Type
public struct AppleMappingResponse: Codable {
    /// ID of the apple application in Mobile Center
    public var appID: String?
    /// Id for the shared service connection. In case of Apple AppStore, this connection will be used to create and connect to the Apple AppStore in Mobile Center.
    public var serviceConnectionID: String?
    /// ID of the apple application in apple store
    public var appleID: String?
    /// ID of the Team associated with the app in apple store
    public var teamIdentifier: String?

    public init(appID: String? = nil, serviceConnectionID: String? = nil, appleID: String? = nil, teamIdentifier: String? = nil) {
        self.appID = appID
        self.serviceConnectionID = serviceConnectionID
        self.appleID = appleID
        self.teamIdentifier = teamIdentifier
    }

    private enum CodingKeys: String, CodingKey {
        case appID = "app_id"
        case serviceConnectionID = "service_connection_id"
        case appleID = "apple_id"
        case teamIdentifier = "team_identifier"
    }
}

/// Apple Test Flight Groups Response Type
public struct AppleTestFlightGroupsResponse: Codable {
    /// Id of the group.
    public var id: String?
    /// Provider id of the group.
    public var providerID: Double?
    /// Apple id of the group.
    public var appleID: Double?
    /// Name of the group.
    public var name: String?

    public init(id: String? = nil, providerID: Double? = nil, appleID: Double? = nil, name: String? = nil) {
        self.id = id
        self.providerID = providerID
        self.appleID = appleID
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case providerID = "providerId"
        case appleID = "appleId"
        case name
    }
}

/// Create the store through private API. Used by UI.
public struct PrivateCreateStoreRequest: Codable {
    /// Store Type
    public var type: `Type`?
    /// Name of the store.
    public var name: String?
    public var intuneDetails: IntuneDetails?

    /// Store Type
    public enum `Type`: String, Codable, CaseIterable {
        case intune
    }

    public struct IntuneDetails: Codable {
        public var targetAudience: TargetAudience?
        public var appCategory: AppCategory?
        /// Tenant id of the intune store
        public var tenantID: String?

        public struct TargetAudience: Codable {
            /// Display name for the target audience/group
            public var name: String?

            public init(name: String? = nil) {
                self.name = name
            }
        }

        public struct AppCategory: Codable {
            /// Display name for the app category
            public var name: String?

            public init(name: String? = nil) {
                self.name = name
            }
        }

        public init(targetAudience: TargetAudience? = nil, appCategory: AppCategory? = nil, tenantID: String? = nil) {
            self.targetAudience = targetAudience
            self.appCategory = appCategory
            self.tenantID = tenantID
        }

        private enum CodingKeys: String, CodingKey {
            case targetAudience = "target_audience"
            case appCategory = "app_category"
            case tenantID = "tenant_id"
        }
    }

    public init(type: `Type`? = nil, name: String? = nil, intuneDetails: IntuneDetails? = nil) {
        self.type = type
        self.name = name
        self.intuneDetails = intuneDetails
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case name
        case intuneDetails = "intune_details"
    }
}

public struct IntuneSecretDetails: Codable {
    /// The id token of user
    public var idToken: String?
    /// The refresh token for user
    public var refreshToken: String?
    /// The expiry of refresh token
    public var refreshTokenExpiry: String?

    public init(idToken: String? = nil, refreshToken: String? = nil, refreshTokenExpiry: String? = nil) {
        self.idToken = idToken
        self.refreshToken = refreshToken
        self.refreshTokenExpiry = refreshTokenExpiry
    }

    private enum CodingKeys: String, CodingKey {
        case idToken = "id_token"
        case refreshToken = "refresh_token"
        case refreshTokenExpiry = "refresh_token_expiry"
    }
}

public struct IntuneCategories: Codable {
    /// Context
    public var odataContext: String?
    /// Categories for intune app
    public var value: [ValueItem]?

    public struct ValueItem: Codable {
        /// The id of the category
        public var id: String?
        /// The display name for the category
        public var displayName: String?
        /// Modified date for category
        public var lastModifiedDateTime: String?

        public init(id: String? = nil, displayName: String? = nil, lastModifiedDateTime: String? = nil) {
            self.id = id
            self.displayName = displayName
            self.lastModifiedDateTime = lastModifiedDateTime
        }
    }

    public init(odataContext: String? = nil, value: [ValueItem]? = nil) {
        self.odataContext = odataContext
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case odataContext = "odata.context"
        case value
    }
}

public struct IntuneCategoryValue: Codable {
    /// The id of the category
    public var id: String?
    /// The display name for the category
    public var displayName: String?
    /// Modified date for category
    public var lastModifiedDateTime: String?

    public init(id: String? = nil, displayName: String? = nil, lastModifiedDateTime: String? = nil) {
        self.id = id
        self.displayName = displayName
        self.lastModifiedDateTime = lastModifiedDateTime
    }
}

public struct IntuneGroups: Codable {
    /// Context
    public var odataContext: String?
    /// Categories for intune app
    public var value: [ValueItem]?

    public struct ValueItem: Codable {
        /// The id of the Group
        public var id: String?
        /// The display name of the group
        public var displayName: String?

        public init(id: String? = nil, displayName: String? = nil) {
            self.id = id
            self.displayName = displayName
        }
    }

    public init(odataContext: String? = nil, value: [ValueItem]? = nil) {
        self.odataContext = odataContext
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case odataContext = "odata.context"
        case value
    }
}

public struct IntuneGroupValue: Codable {
    /// The id of the Group
    public var id: String?
    /// The display name of the group
    public var displayName: String?

    public init(id: String? = nil, displayName: String? = nil) {
        self.id = id
        self.displayName = displayName
    }
}

public struct IntuneGroup: Codable {
    /// The id of the Group
    public var id: String?
    /// The display name of the group
    public var displayName: String?
    /// Species if it is a security group
    public var isSecurityEnabled: Bool?

    public init(id: String? = nil, displayName: String? = nil, isSecurityEnabled: Bool? = nil) {
        self.id = id
        self.displayName = displayName
        self.isSecurityEnabled = isSecurityEnabled
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case displayName
        case isSecurityEnabled = "securityEnabled"
    }
}

public struct CreateStoreSecretRequest: Codable {
    public var secretJSON: SecretJSON?
    /// The tenant id for user
    public var tenantID: String?

    public struct SecretJSON: Codable {
        /// The id token of user
        public var idToken: String?
        /// The refresh token for user
        public var refreshToken: String?
        /// The expiry of refresh token
        public var refreshTokenExpiry: String?

        public init(idToken: String? = nil, refreshToken: String? = nil, refreshTokenExpiry: String? = nil) {
            self.idToken = idToken
            self.refreshToken = refreshToken
            self.refreshTokenExpiry = refreshTokenExpiry
        }

        private enum CodingKeys: String, CodingKey {
            case idToken = "id_token"
            case refreshToken = "refresh_token"
            case refreshTokenExpiry = "refresh_token_expiry"
        }
    }

    public init(secretJSON: SecretJSON? = nil, tenantID: String? = nil) {
        self.secretJSON = secretJSON
        self.tenantID = tenantID
    }

    private enum CodingKeys: String, CodingKey {
        case secretJSON = "secret_json"
        case tenantID = "tenant_id"
    }
}

public struct CreateStoreSecretResponse: Codable {
    /// The secret id for store secret
    public var secretID: String?

    public init(secretID: String? = nil) {
        self.secretID = secretID
    }

    private enum CodingKeys: String, CodingKey {
        case secretID = "secret_id"
    }
}

public struct SecretDetails: Codable {
    /// The id token of user
    public var idToken: String?
    /// The refresh token for user
    public var refreshToken: String?
    /// The expiry of refresh token
    public var refreshTokenExpiry: String?

    public init(idToken: String? = nil, refreshToken: String? = nil, refreshTokenExpiry: String? = nil) {
        self.idToken = idToken
        self.refreshToken = refreshToken
        self.refreshTokenExpiry = refreshTokenExpiry
    }

    private enum CodingKeys: String, CodingKey {
        case idToken = "id_token"
        case refreshToken = "refresh_token"
        case refreshTokenExpiry = "refresh_token_expiry"
    }
}

/// ReleasePublishErrorResponse
public struct ReleasePublishErrorResponse: Codable {
    /// Error Details
    public var message: String?
    /// Boolean property to tell if logs are available for download
    public var isLogAvailable: Bool?

    public init(message: String? = nil, isLogAvailable: Bool? = nil) {
        self.message = message
        self.isLogAvailable = isLogAvailable
    }

    private enum CodingKeys: String, CodingKey {
        case message
        case isLogAvailable = "is_log_available"
    }
}

/// Status of the app from store
public struct ReleaseRealTimeStatusResponse: Codable {
    /// Release id
    public var releaseID: String?
    /// App id
    public var appID: String?
    /// Status Data from store
    public var status: Status?

    /// Status Data from store
    public struct Status: Codable {
        /// Status from store
        public var status: String?
        /// Store type
        public var storetype: String?
        /// Track information from store
        public var track: String?
        /// Version of the app from store
        public var version: String?

        public init(status: String? = nil, storetype: String? = nil, track: String? = nil, version: String? = nil) {
            self.status = status
            self.storetype = storetype
            self.track = track
            self.version = version
        }
    }

    public init(releaseID: String? = nil, appID: String? = nil, status: Status? = nil) {
        self.releaseID = releaseID
        self.appID = appID
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case releaseID = "release_id"
        case appID = "app_id"
        case status
    }
}

/// The response which contains the validation data that the connection is valid.
public struct ValidationResponse: Codable {
    /// App id
    public var appID: String?
    /// Status Data from store
    public var status: Status?

    /// Status Data from store
    public struct Status: Codable {
        /// Status from store
        public var status: String?
        /// Store type
        public var storetype: String?
        /// Track information from store
        public var track: String?
        /// Version of the app from store
        public var version: String?

        public init(status: String? = nil, storetype: String? = nil, track: String? = nil, version: String? = nil) {
            self.status = status
            self.storetype = storetype
            self.track = track
            self.version = version
        }
    }

    public init(appID: String? = nil, status: Status? = nil) {
        self.appID = appID
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case appID = "app_id"
        case status
    }
}

/// The response for the build uploaded check.
public struct HasBuildUploadedResponse: Codable {
    /// True if a build has been uploaded, false otherwise
    public var hasBuildUploaded: Bool?

    public init(hasBuildUploaded: Bool? = nil) {
        self.hasBuildUploaded = hasBuildUploaded
    }

    private enum CodingKeys: String, CodingKey {
        case hasBuildUploaded = "has_build_uploaded"
    }
}

/// The response for the testflight metadata check.
public struct HasTestflightMetadataResponse: Codable {
    /// True if the app has the testflight metadata, false otherwise
    public var hasTestflightMetadata: Bool?

    public init(hasTestflightMetadata: Bool? = nil) {
        self.hasTestflightMetadata = hasTestflightMetadata
    }

    private enum CodingKeys: String, CodingKey {
        case hasTestflightMetadata = "has_testflight_metadata"
    }
}

/// Wheither or not to skip the validation for this release
public struct SkipValidationRequest: Codable {
    /// True if we want to skip the validation, false otherwise
    public var isSkipValidation: Bool?

    public init(isSkipValidation: Bool? = nil) {
        self.isSkipValidation = isSkipValidation
    }

    private enum CodingKeys: String, CodingKey {
        case isSkipValidation = "skip_validation"
    }
}

/// Status Data from store
public struct StatusData: Codable {
    /// Status from store
    public var status: String?
    /// Store type
    public var storetype: String?
    /// Track information from store
    public var track: String?
    /// Version of the app from store
    public var version: String?

    public init(status: String? = nil, storetype: String? = nil, track: String? = nil, version: String? = nil) {
        self.status = status
        self.storetype = storetype
        self.track = track
        self.version = version
    }
}

/// ExternalStoreResponse
public struct ExternalStoreResponse: Codable {
    /// Store id
    public var id: String?
    /// Store Name
    public var name: String?
    /// Store Type
    public var type: String?
    /// Store track
    public var track: Track?
    /// Store details for intune
    public var intuneDetails: IntuneDetails?
    /// Id for the shared service connection. In case of Apple / GooglePlay stores, this connection will be used to connect to the Apple / Google stores in App Center.
    public var serviceConnectionID: String?
    /// The ID of the principal that created the store.
    public var createdBy: String?
    /// The type of the principal that created the store.
    public var createdByPrincipalType: String?

    /// Store track
    public enum Track: String, Codable, CaseIterable {
        case production
        case alpha
        case beta
        case testflightInternal = "testflight-internal"
        case testflightExternal = "testflight-external"
    }

    /// Store details for intune
    public struct IntuneDetails: Codable {
        public var targetAudience: TargetAudience?
        public var appCategory: AppCategory?

        public struct TargetAudience: Codable {
            /// Display name for the target audience/group
            public var name: String?
            /// ID for the target audience/group.
            public var id: String?

            public init(name: String? = nil, id: String? = nil) {
                self.name = name
                self.id = id
            }
        }

        public struct AppCategory: Codable {
            /// Display name for the app category
            public var name: String?
            /// ID for the category.
            public var id: String?

            public init(name: String? = nil, id: String? = nil) {
                self.name = name
                self.id = id
            }
        }

        public init(targetAudience: TargetAudience? = nil, appCategory: AppCategory? = nil) {
            self.targetAudience = targetAudience
            self.appCategory = appCategory
        }

        private enum CodingKeys: String, CodingKey {
            case targetAudience = "target_audience"
            case appCategory = "app_category"
        }
    }

    public init(id: String? = nil, name: String? = nil, type: String? = nil, track: Track? = nil, intuneDetails: IntuneDetails? = nil, serviceConnectionID: String? = nil, createdBy: String? = nil, createdByPrincipalType: String? = nil) {
        self.id = id
        self.name = name
        self.type = type
        self.track = track
        self.intuneDetails = intuneDetails
        self.serviceConnectionID = serviceConnectionID
        self.createdBy = createdBy
        self.createdByPrincipalType = createdByPrincipalType
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case type
        case track
        case intuneDetails = "intune_details"
        case serviceConnectionID = "service_connection_id"
        case createdBy = "created_by"
        case createdByPrincipalType = "created_by_principal_type"
    }
}

/// StoreSecretResponse
public struct StoreSecretResponse: Codable {
    /// Store id
    public var id: String?
    /// Store Name
    public var name: String?
    /// Store Type
    public var type: String?
    /// Secret Json
    public var secret: String?
    /// Tenant Id for Intune
    public var tenantID: String?

    public init(id: String? = nil, name: String? = nil, type: String? = nil, secret: String? = nil, tenantID: String? = nil) {
        self.id = id
        self.name = name
        self.type = type
        self.secret = secret
        self.tenantID = tenantID
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case type
        case secret
        case tenantID = "tenant_id"
    }
}

public struct IntuneStoreResponse: Codable {
    public var targetAudience: TargetAudience?
    public var appCategory: AppCategory?

    public struct TargetAudience: Codable {
        /// Display name for the target audience/group
        public var name: String?
        /// ID for the target audience/group.
        public var id: String?

        public init(name: String? = nil, id: String? = nil) {
            self.name = name
            self.id = id
        }
    }

    public struct AppCategory: Codable {
        /// Display name for the app category
        public var name: String?
        /// ID for the category.
        public var id: String?

        public init(name: String? = nil, id: String? = nil) {
            self.name = name
            self.id = id
        }
    }

    public init(targetAudience: TargetAudience? = nil, appCategory: AppCategory? = nil) {
        self.targetAudience = targetAudience
        self.appCategory = appCategory
    }

    private enum CodingKeys: String, CodingKey {
        case targetAudience = "target_audience"
        case appCategory = "app_category"
    }
}

public struct IntuneStoreRequest: Codable {
    public var secretJSON: SecretJSON?
    public var targetAudience: TargetAudience?
    public var appCategory: AppCategory?
    /// Tenant id of the intune store
    public var tenantID: String?

    public struct SecretJSON: Codable {
        /// The id token of user
        public var idToken: String?
        /// The refresh token for user
        public var refreshToken: String?
        /// The expiry of refresh token
        public var refreshTokenExpiry: String?

        public init(idToken: String? = nil, refreshToken: String? = nil, refreshTokenExpiry: String? = nil) {
            self.idToken = idToken
            self.refreshToken = refreshToken
            self.refreshTokenExpiry = refreshTokenExpiry
        }

        private enum CodingKeys: String, CodingKey {
            case idToken = "id_token"
            case refreshToken = "refresh_token"
            case refreshTokenExpiry = "refresh_token_expiry"
        }
    }

    public struct TargetAudience: Codable {
        /// Display name for the target audience/group
        public var name: String?

        public init(name: String? = nil) {
            self.name = name
        }
    }

    public struct AppCategory: Codable {
        /// Display name for the app category
        public var name: String?

        public init(name: String? = nil) {
            self.name = name
        }
    }

    public init(secretJSON: SecretJSON? = nil, targetAudience: TargetAudience? = nil, appCategory: AppCategory? = nil, tenantID: String? = nil) {
        self.secretJSON = secretJSON
        self.targetAudience = targetAudience
        self.appCategory = appCategory
        self.tenantID = tenantID
    }

    private enum CodingKeys: String, CodingKey {
        case secretJSON = "secret_json"
        case targetAudience = "target_audience"
        case appCategory = "app_category"
        case tenantID = "tenant_id"
    }
}

public struct PrivateIntuneStoreRequest: Codable {
    public var targetAudience: TargetAudience?
    public var appCategory: AppCategory?
    /// Tenant id of the intune store
    public var tenantID: String?

    public struct TargetAudience: Codable {
        /// Display name for the target audience/group
        public var name: String?

        public init(name: String? = nil) {
            self.name = name
        }
    }

    public struct AppCategory: Codable {
        /// Display name for the app category
        public var name: String?

        public init(name: String? = nil) {
            self.name = name
        }
    }

    public init(targetAudience: TargetAudience? = nil, appCategory: AppCategory? = nil, tenantID: String? = nil) {
        self.targetAudience = targetAudience
        self.appCategory = appCategory
        self.tenantID = tenantID
    }

    private enum CodingKeys: String, CodingKey {
        case targetAudience = "target_audience"
        case appCategory = "app_category"
        case tenantID = "tenant_id"
    }
}

public struct IntuneTargetAudience: Codable {
    /// Display name for the target audience/group
    public var name: String?

    public init(name: String? = nil) {
        self.name = name
    }
}

public struct IntuneAppCategory: Codable {
    /// Display name for the app category
    public var name: String?

    public init(name: String? = nil) {
        self.name = name
    }
}

public struct IntuneTargetAudienceResponse: Codable {
    /// Display name for the target audience/group
    public var name: String?
    /// ID for the target audience/group.
    public var id: String?

    public init(name: String? = nil, id: String? = nil) {
        self.name = name
        self.id = id
    }
}

public struct IntuneAppCategoryResponse: Codable {
    /// Display name for the app category
    public var name: String?
    /// ID for the category.
    public var id: String?

    public init(name: String? = nil, id: String? = nil) {
        self.name = name
        self.id = id
    }
}

public struct PatchReleaseRequest: Codable {
    /// Updated status of release
    public var status: String?
    /// Destination Publish Id
    public var destPublishID: String?
    /// Failure error details from store
    public var errorDetails: String?
    /// ContextId for failed error message
    public var errorContextID: String?
    /// Package url for wrapping request
    public var wrapPackageURL: String?
    /// Request is for wrapping or not
    public var isWrapperRequest: Bool?

    public init(status: String? = nil, destPublishID: String? = nil, errorDetails: String? = nil, errorContextID: String? = nil, wrapPackageURL: String? = nil, isWrapperRequest: Bool? = nil) {
        self.status = status
        self.destPublishID = destPublishID
        self.errorDetails = errorDetails
        self.errorContextID = errorContextID
        self.wrapPackageURL = wrapPackageURL
        self.isWrapperRequest = isWrapperRequest
    }

    private enum CodingKeys: String, CodingKey {
        case status
        case destPublishID = "dest_publish_id"
        case errorDetails = "error_details"
        case errorContextID = "error_contextId"
        case wrapPackageURL = "wrap_package_url"
        case isWrapperRequest = "is_wrapper_request"
    }
}

/// Basic information on a release
public struct StoresBasicReleaseDetails: Codable {
    /// ID identifying this unique release.
    public var id: Double?
    /// The release's version.
    /// For iOS: CFBundleVersion from info.plist.
    /// For Android: android:versionCode from AppManifest.xml.
    public var version: String?
    /// The release's short version.
    /// For iOS: CFBundleShortVersionString from info.plist.
    /// For Android: android:versionName from AppManifest.xml.
    public var shortVersion: String?
    /// UTC time in ISO 8601 format of the uploaded time.
    public var uploadedAt: String?
    /// Destination for this release.
    public var destinationType: DestinationType?
    /// A list of distribution stores that are associated with this release.
    public var distributionStores: [DistributionStore]?

    /// Destination for this release.
    public enum DestinationType: String, Codable, CaseIterable {
        case group
        case store
        case tester
    }

    public struct DistributionStore: Codable {
        /// ID identifying a unique distribution store.
        public var id: String?
        /// A name identifying a unique distribution store.
        public var name: String?
        /// A type identifying the type of distribution store.
        public var type: `Type`?
        /// A status identifying the status of release in the distribution store.
        public var publishingStatus: String?
        /// Is the containing release the latest one in this distribution store.
        public var isLatest: Bool?

        /// A type identifying the type of distribution store.
        public enum `Type`: String, Codable, CaseIterable {
            case googleplay
            case intune
            case apple
        }

        public init(id: String? = nil, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil, isLatest: Bool? = nil) {
            self.id = id
            self.name = name
            self.type = type
            self.publishingStatus = publishingStatus
            self.isLatest = isLatest
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case name
            case type
            case publishingStatus = "publishing_status"
            case isLatest = "is_latest"
        }
    }

    public init(id: Double? = nil, version: String? = nil, shortVersion: String? = nil, uploadedAt: String? = nil, destinationType: DestinationType? = nil, distributionStores: [DistributionStore]? = nil) {
        self.id = id
        self.version = version
        self.shortVersion = shortVersion
        self.uploadedAt = uploadedAt
        self.destinationType = destinationType
        self.distributionStores = distributionStores
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case version
        case shortVersion = "short_version"
        case uploadedAt = "uploaded_at"
        case destinationType = "destination_type"
        case distributionStores = "distribution_stores"
    }
}

public struct StoresDetails: Codable {
    /// ID identifying a unique distribution store.
    public var id: String?
    /// A name identifying a unique distribution store.
    public var name: String?
    /// A type identifying the type of distribution store.
    public var type: `Type`?
    /// A status identifying the status of release in the distribution store.
    public var publishingStatus: String?
    /// Is the containing release the latest one in this distribution store.
    public var isLatest: Bool?

    /// A type identifying the type of distribution store.
    public enum `Type`: String, Codable, CaseIterable {
        case googleplay
        case intune
        case apple
    }

    public init(id: String? = nil, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil, isLatest: Bool? = nil) {
        self.id = id
        self.name = name
        self.type = type
        self.publishingStatus = publishingStatus
        self.isLatest = isLatest
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case type
        case publishingStatus = "publishing_status"
        case isLatest = "is_latest"
    }
}

public struct StoreDestinationDetails: Codable {
    /// Destination ID identifying a unique id in distribution store.
    public var destPublishID: String?
    /// Type of store.
    public var storeType: StoreType?
    /// App id of application.
    public var appID: String?

    /// Type of store.
    public enum StoreType: String, Codable, CaseIterable {
        case intune
    }

    public init(destPublishID: String? = nil, storeType: StoreType? = nil, appID: String? = nil) {
        self.destPublishID = destPublishID
        self.storeType = storeType
        self.appID = appID
    }

    private enum CodingKeys: String, CodingKey {
        case destPublishID = "dest_publish_id"
        case storeType = "store_type"
        case appID = "appId"
    }
}

public struct StoresBasicDetails: Codable {
    /// ID identifying a unique distribution store.
    public var id: String?
    /// A name identifying a unique distribution store.
    public var name: String?
    /// Type of the distribution store currently stores type can be intune or googleplay.
    public var type: `Type`?
    /// Publishing status of the release in the store.
    public var publishingStatus: String?

    /// Type of the distribution store currently stores type can be intune or googleplay.
    public enum `Type`: String, Codable, CaseIterable {
        case intune
        case googleplay
    }

    public init(id: String? = nil, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil) {
        self.id = id
        self.name = name
        self.type = type
        self.publishingStatus = publishingStatus
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case type
        case publishingStatus = "publishing_status"
    }
}

/// IntuneAppsRequest
public struct IntuneAppsRequest: Codable {
    /// PartitionKey year-month
    public var createdMonth: String?

    public init(createdMonth: String? = nil) {
        self.createdMonth = createdMonth
    }

    private enum CodingKeys: String, CodingKey {
        case createdMonth = "created_month"
    }
}

/// IntuneAppsResponse
public struct IntuneAppsResponse: Codable {
    /// PartitionKey year-month
    public var createdMonth: String?
    /// App id
    public var appID: String?
    /// Refresh Status
    public var refreshStatus: String?

    public init(createdMonth: String? = nil, appID: String? = nil, refreshStatus: String? = nil) {
        self.createdMonth = createdMonth
        self.appID = appID
        self.refreshStatus = refreshStatus
    }

    private enum CodingKeys: String, CodingKey {
        case createdMonth = "created_month"
        case appID = "app_id"
        case refreshStatus
    }
}

/// Org settings Request
public struct OrgComplianceSettingsRequest: Codable {
    /// Certificate connection id to wrap and resign the app after wrapping
    public var certificateConnectionID: String

    public init(certificateConnectionID: String) {
        self.certificateConnectionID = certificateConnectionID
    }

    private enum CodingKeys: String, CodingKey {
        case certificateConnectionID = "certificate_connection_id"
    }
}

/// Org settings response
public struct OrgComplianceSettingsResponse: Codable {
    /// The internal unique id (UUID) of the organization compliance setting
    public var id: String
    /// The internal unique id (UUID) of the organization.
    public var orgID: String
    /// Certificate connection id to wrap and resign the app after wrapping
    public var certificateConnectionID: String
    /// Flag to tell if mam warpping is enabled on the Org
    public var isMamEnabled: Bool?

    public init(id: String, orgID: String, certificateConnectionID: String, isMamEnabled: Bool? = nil) {
        self.id = id
        self.orgID = orgID
        self.certificateConnectionID = certificateConnectionID
        self.isMamEnabled = isMamEnabled
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case orgID = "org_id"
        case certificateConnectionID = "certificate_connection_id"
        case isMamEnabled = "is_mam_enabled"
    }
}

public struct StoreNotification: Codable {
    public var service: String?
    public var status: String?
    public var validUntil: Int?

    public init(service: String? = nil, status: String? = nil, validUntil: Int? = nil) {
        self.service = service
        self.status = status
        self.validUntil = validUntil
    }

    private enum CodingKeys: String, CodingKey {
        case service
        case status
        case validUntil = "valid_until"
    }
}

/// The diagnostic id for the given publish action
public struct DiagnosticIDResponse: Codable {
    /// Diagnostic id
    public var diagnosticID: String?

    public init(diagnosticID: String? = nil) {
        self.diagnosticID = diagnosticID
    }

    private enum CodingKeys: String, CodingKey {
        case diagnosticID = "diagnostic_id"
    }
}

public struct ErrorGroups: Codable {
    public var nextLink: String?
    public var errorGroups: [ErrorGroup]?

    public struct ErrorGroup: Codable {
        public var errorGroupID: String
        public var appVersion: String
        public var appBuild: String?
        public var count: Int
        public var deviceCount: Int
        public var firstOccurrence: Date
        public var lastOccurrence: Date
        public var exceptionType: String?
        public var exceptionMessage: String?
        public var exceptionClassName: String?
        public var isExceptionClassMethod: Bool?
        public var exceptionMethod: String?
        public var isExceptionAppCode: Bool?
        public var exceptionFile: String?
        public var exceptionLine: String?
        public var codeRaw: String?
        public var reasonFrames: [ReasonFrame]?
        public var isHidden: Bool?

        public struct ReasonFrame: Codable {
            /// Name of the class
            public var className: String?
            /// Name of the method
            public var method: String?
            /// Is a class method
            public var isClassMethod: Bool?
            /// Name of the file
            public var file: String?
            /// Line number
            public var line: Int?
            /// This line isn't from any framework
            public var isAppCode: Bool?
            /// Name of the framework
            public var frameworkName: String?
            /// Formatted frame string
            public var codeFormatted: String?
            /// Unformatted Frame string
            public var codeRaw: String?
            /// Programming language of the frame
            public var language: Language?
            /// Parameters of the frames method
            public var methodParams: String?
            /// Exception type.
            public var exceptionType: String?
            /// OS exception type. (aka. SIGNAL)
            public var osExceptionType: String?

            /// Programming language of the frame
            public enum Language: String, Codable, CaseIterable {
                case javaScript = "JavaScript"
                case cSharp = "CSharp"
                case objectiveC = "Objective-C"
                case objectiveCpp = "Objective-Cpp"
                case cpp = "Cpp"
                case c = "C"
                case swift = "Swift"
                case java = "Java"
                case unknown = "Unknown"
            }

            public init(className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool? = nil, frameworkName: String? = nil, codeFormatted: String? = nil, codeRaw: String? = nil, language: Language? = nil, methodParams: String? = nil, exceptionType: String? = nil, osExceptionType: String? = nil) {
                self.className = className
                self.method = method
                self.isClassMethod = isClassMethod
                self.file = file
                self.line = line
                self.isAppCode = isAppCode
                self.frameworkName = frameworkName
                self.codeFormatted = codeFormatted
                self.codeRaw = codeRaw
                self.language = language
                self.methodParams = methodParams
                self.exceptionType = exceptionType
                self.osExceptionType = osExceptionType
            }

            private enum CodingKeys: String, CodingKey {
                case className
                case method
                case isClassMethod = "classMethod"
                case file
                case line
                case isAppCode = "appCode"
                case frameworkName
                case codeFormatted
                case codeRaw
                case language
                case methodParams
                case exceptionType
                case osExceptionType
            }
        }

        public init(errorGroupID: String, appVersion: String, appBuild: String? = nil, count: Int, deviceCount: Int, firstOccurrence: Date, lastOccurrence: Date, exceptionType: String? = nil, exceptionMessage: String? = nil, exceptionClassName: String? = nil, isExceptionClassMethod: Bool? = nil, exceptionMethod: String? = nil, isExceptionAppCode: Bool? = nil, exceptionFile: String? = nil, exceptionLine: String? = nil, codeRaw: String? = nil, reasonFrames: [ReasonFrame]? = nil, isHidden: Bool? = nil) {
            self.errorGroupID = errorGroupID
            self.appVersion = appVersion
            self.appBuild = appBuild
            self.count = count
            self.deviceCount = deviceCount
            self.firstOccurrence = firstOccurrence
            self.lastOccurrence = lastOccurrence
            self.exceptionType = exceptionType
            self.exceptionMessage = exceptionMessage
            self.exceptionClassName = exceptionClassName
            self.isExceptionClassMethod = isExceptionClassMethod
            self.exceptionMethod = exceptionMethod
            self.isExceptionAppCode = isExceptionAppCode
            self.exceptionFile = exceptionFile
            self.exceptionLine = exceptionLine
            self.codeRaw = codeRaw
            self.reasonFrames = reasonFrames
            self.isHidden = isHidden
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.errorGroupID = try values.decode(String.self, forKey: "errorGroupId")
            self.appVersion = try values.decode(String.self, forKey: "appVersion")
            self.appBuild = try values.decodeIfPresent(String.self, forKey: "appBuild")
            self.count = try values.decode(Int.self, forKey: "count")
            self.deviceCount = try values.decode(Int.self, forKey: "deviceCount")
            self.firstOccurrence = try values.decode(Date.self, forKey: "firstOccurrence")
            self.lastOccurrence = try values.decode(Date.self, forKey: "lastOccurrence")
            self.exceptionType = try values.decodeIfPresent(String.self, forKey: "exceptionType")
            self.exceptionMessage = try values.decodeIfPresent(String.self, forKey: "exceptionMessage")
            self.exceptionClassName = try values.decodeIfPresent(String.self, forKey: "exceptionClassName")
            self.isExceptionClassMethod = try values.decodeIfPresent(Bool.self, forKey: "exceptionClassMethod")
            self.exceptionMethod = try values.decodeIfPresent(String.self, forKey: "exceptionMethod")
            self.isExceptionAppCode = try values.decodeIfPresent(Bool.self, forKey: "exceptionAppCode")
            self.exceptionFile = try values.decodeIfPresent(String.self, forKey: "exceptionFile")
            self.exceptionLine = try values.decodeIfPresent(String.self, forKey: "exceptionLine")
            self.codeRaw = try values.decodeIfPresent(String.self, forKey: "codeRaw")
            self.reasonFrames = try values.decodeIfPresent([ReasonFrame].self, forKey: "reasonFrames")
            self.isHidden = try values.decodeIfPresent(Bool.self, forKey: "hidden")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(errorGroupID, forKey: "errorGroupId")
            try values.encode(appVersion, forKey: "appVersion")
            try values.encodeIfPresent(appBuild, forKey: "appBuild")
            try values.encode(count, forKey: "count")
            try values.encode(deviceCount, forKey: "deviceCount")
            try values.encode(firstOccurrence, forKey: "firstOccurrence")
            try values.encode(lastOccurrence, forKey: "lastOccurrence")
            try values.encodeIfPresent(exceptionType, forKey: "exceptionType")
            try values.encodeIfPresent(exceptionMessage, forKey: "exceptionMessage")
            try values.encodeIfPresent(exceptionClassName, forKey: "exceptionClassName")
            try values.encodeIfPresent(isExceptionClassMethod, forKey: "exceptionClassMethod")
            try values.encodeIfPresent(exceptionMethod, forKey: "exceptionMethod")
            try values.encodeIfPresent(isExceptionAppCode, forKey: "exceptionAppCode")
            try values.encodeIfPresent(exceptionFile, forKey: "exceptionFile")
            try values.encodeIfPresent(exceptionLine, forKey: "exceptionLine")
            try values.encodeIfPresent(codeRaw, forKey: "codeRaw")
            try values.encodeIfPresent(reasonFrames, forKey: "reasonFrames")
            try values.encodeIfPresent(isHidden, forKey: "hidden")
        }
    }

    public init(nextLink: String? = nil, errorGroups: [ErrorGroup]? = nil) {
        self.nextLink = nextLink
        self.errorGroups = errorGroups
    }
}

public struct ErrorGroupsSearchResult: Codable {
    public var hasMoreResults: Bool?
    public var errorGroups: [ErrorGroup]?

    public struct ErrorGroup: Codable {
        public var errorGroupID: String
        public var appVersion: String
        public var appBuild: String?
        public var count: Int
        public var deviceCount: Int
        public var firstOccurrence: Date
        public var lastOccurrence: Date
        public var exceptionType: String?
        public var exceptionMessage: String?
        public var exceptionClassName: String?
        public var isExceptionClassMethod: Bool?
        public var exceptionMethod: String?
        public var isExceptionAppCode: Bool?
        public var exceptionFile: String?
        public var exceptionLine: String?
        public var codeRaw: String?
        public var reasonFrames: [ReasonFrame]?
        public var isHidden: Bool?

        public struct ReasonFrame: Codable {
            /// Name of the class
            public var className: String?
            /// Name of the method
            public var method: String?
            /// Is a class method
            public var isClassMethod: Bool?
            /// Name of the file
            public var file: String?
            /// Line number
            public var line: Int?
            /// This line isn't from any framework
            public var isAppCode: Bool?
            /// Name of the framework
            public var frameworkName: String?
            /// Formatted frame string
            public var codeFormatted: String?
            /// Unformatted Frame string
            public var codeRaw: String?
            /// Programming language of the frame
            public var language: Language?
            /// Parameters of the frames method
            public var methodParams: String?
            /// Exception type.
            public var exceptionType: String?
            /// OS exception type. (aka. SIGNAL)
            public var osExceptionType: String?

            /// Programming language of the frame
            public enum Language: String, Codable, CaseIterable {
                case javaScript = "JavaScript"
                case cSharp = "CSharp"
                case objectiveC = "Objective-C"
                case objectiveCpp = "Objective-Cpp"
                case cpp = "Cpp"
                case c = "C"
                case swift = "Swift"
                case java = "Java"
                case unknown = "Unknown"
            }

            public init(className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool? = nil, frameworkName: String? = nil, codeFormatted: String? = nil, codeRaw: String? = nil, language: Language? = nil, methodParams: String? = nil, exceptionType: String? = nil, osExceptionType: String? = nil) {
                self.className = className
                self.method = method
                self.isClassMethod = isClassMethod
                self.file = file
                self.line = line
                self.isAppCode = isAppCode
                self.frameworkName = frameworkName
                self.codeFormatted = codeFormatted
                self.codeRaw = codeRaw
                self.language = language
                self.methodParams = methodParams
                self.exceptionType = exceptionType
                self.osExceptionType = osExceptionType
            }

            private enum CodingKeys: String, CodingKey {
                case className
                case method
                case isClassMethod = "classMethod"
                case file
                case line
                case isAppCode = "appCode"
                case frameworkName
                case codeFormatted
                case codeRaw
                case language
                case methodParams
                case exceptionType
                case osExceptionType
            }
        }

        public init(errorGroupID: String, appVersion: String, appBuild: String? = nil, count: Int, deviceCount: Int, firstOccurrence: Date, lastOccurrence: Date, exceptionType: String? = nil, exceptionMessage: String? = nil, exceptionClassName: String? = nil, isExceptionClassMethod: Bool? = nil, exceptionMethod: String? = nil, isExceptionAppCode: Bool? = nil, exceptionFile: String? = nil, exceptionLine: String? = nil, codeRaw: String? = nil, reasonFrames: [ReasonFrame]? = nil, isHidden: Bool? = nil) {
            self.errorGroupID = errorGroupID
            self.appVersion = appVersion
            self.appBuild = appBuild
            self.count = count
            self.deviceCount = deviceCount
            self.firstOccurrence = firstOccurrence
            self.lastOccurrence = lastOccurrence
            self.exceptionType = exceptionType
            self.exceptionMessage = exceptionMessage
            self.exceptionClassName = exceptionClassName
            self.isExceptionClassMethod = isExceptionClassMethod
            self.exceptionMethod = exceptionMethod
            self.isExceptionAppCode = isExceptionAppCode
            self.exceptionFile = exceptionFile
            self.exceptionLine = exceptionLine
            self.codeRaw = codeRaw
            self.reasonFrames = reasonFrames
            self.isHidden = isHidden
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.errorGroupID = try values.decode(String.self, forKey: "errorGroupId")
            self.appVersion = try values.decode(String.self, forKey: "appVersion")
            self.appBuild = try values.decodeIfPresent(String.self, forKey: "appBuild")
            self.count = try values.decode(Int.self, forKey: "count")
            self.deviceCount = try values.decode(Int.self, forKey: "deviceCount")
            self.firstOccurrence = try values.decode(Date.self, forKey: "firstOccurrence")
            self.lastOccurrence = try values.decode(Date.self, forKey: "lastOccurrence")
            self.exceptionType = try values.decodeIfPresent(String.self, forKey: "exceptionType")
            self.exceptionMessage = try values.decodeIfPresent(String.self, forKey: "exceptionMessage")
            self.exceptionClassName = try values.decodeIfPresent(String.self, forKey: "exceptionClassName")
            self.isExceptionClassMethod = try values.decodeIfPresent(Bool.self, forKey: "exceptionClassMethod")
            self.exceptionMethod = try values.decodeIfPresent(String.self, forKey: "exceptionMethod")
            self.isExceptionAppCode = try values.decodeIfPresent(Bool.self, forKey: "exceptionAppCode")
            self.exceptionFile = try values.decodeIfPresent(String.self, forKey: "exceptionFile")
            self.exceptionLine = try values.decodeIfPresent(String.self, forKey: "exceptionLine")
            self.codeRaw = try values.decodeIfPresent(String.self, forKey: "codeRaw")
            self.reasonFrames = try values.decodeIfPresent([ReasonFrame].self, forKey: "reasonFrames")
            self.isHidden = try values.decodeIfPresent(Bool.self, forKey: "hidden")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(errorGroupID, forKey: "errorGroupId")
            try values.encode(appVersion, forKey: "appVersion")
            try values.encodeIfPresent(appBuild, forKey: "appBuild")
            try values.encode(count, forKey: "count")
            try values.encode(deviceCount, forKey: "deviceCount")
            try values.encode(firstOccurrence, forKey: "firstOccurrence")
            try values.encode(lastOccurrence, forKey: "lastOccurrence")
            try values.encodeIfPresent(exceptionType, forKey: "exceptionType")
            try values.encodeIfPresent(exceptionMessage, forKey: "exceptionMessage")
            try values.encodeIfPresent(exceptionClassName, forKey: "exceptionClassName")
            try values.encodeIfPresent(isExceptionClassMethod, forKey: "exceptionClassMethod")
            try values.encodeIfPresent(exceptionMethod, forKey: "exceptionMethod")
            try values.encodeIfPresent(isExceptionAppCode, forKey: "exceptionAppCode")
            try values.encodeIfPresent(exceptionFile, forKey: "exceptionFile")
            try values.encodeIfPresent(exceptionLine, forKey: "exceptionLine")
            try values.encodeIfPresent(codeRaw, forKey: "codeRaw")
            try values.encodeIfPresent(reasonFrames, forKey: "reasonFrames")
            try values.encodeIfPresent(isHidden, forKey: "hidden")
        }
    }

    public init(hasMoreResults: Bool? = nil, errorGroups: [ErrorGroup]? = nil) {
        self.hasMoreResults = hasMoreResults
        self.errorGroups = errorGroups
    }
}

public struct ErrorCounts: Codable {
    /// Total error count
    public var count: Int?
    /// The total error count for day
    public var errors: [Error]?

    public struct Error: Codable {
        /// The ISO 8601 datetime
        public var datetime: String?
        /// Count of the object
        public var count: Int?

        public init(datetime: String? = nil, count: Int? = nil) {
            self.datetime = datetime
            self.count = count
        }
    }

    public init(count: Int? = nil, errors: [Error]? = nil) {
        self.count = count
        self.errors = errors
    }
}

public struct ErrorGroupListItem: Codable {
    public var state: State
    public var annotation: String?

    public enum State: String, Codable, CaseIterable {
        case `open`
        case closed
        case ignored
    }

    public init(state: State, annotation: String? = nil) {
        self.state = state
        self.annotation = annotation
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.state = try State(from: decoder)
        self.annotation = try values.decodeIfPresent(String.self, forKey: "annotation")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(state, forKey: "state")
        try values.encodeIfPresent(annotation, forKey: "annotation")
    }
}

public struct ErrorGroup: Codable {
    public var state: State
    public var annotation: String?

    public enum State: String, Codable, CaseIterable {
        case `open`
        case closed
        case ignored
    }

    public init(state: State, annotation: String? = nil) {
        self.state = state
        self.annotation = annotation
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.state = try State(from: decoder)
        self.annotation = try values.decodeIfPresent(String.self, forKey: "annotation")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(state, forKey: "state")
        try values.encodeIfPresent(annotation, forKey: "annotation")
    }
}

public struct ErrorDateTimePercentages: Codable {
    /// The ISO 8601 datetime
    public var datetime: String?
    /// Percentage of the object
    public var percentage: Double?

    public init(datetime: String? = nil, percentage: Double? = nil) {
        self.datetime = datetime
        self.percentage = percentage
    }
}

public struct ErrorDateTimeCounts: Codable {
    /// The ISO 8601 datetime
    public var datetime: String?
    /// Count of the object
    public var count: Int?

    public init(datetime: String? = nil, count: Int? = nil) {
        self.datetime = datetime
        self.count = count
    }
}

public struct ErrorGroupState: Codable {
    public var state: State
    public var annotation: String?

    public enum State: String, Codable, CaseIterable {
        case `open`
        case closed
        case ignored
    }

    public init(state: State, annotation: String? = nil) {
        self.state = state
        self.annotation = annotation
    }
}

public struct ErrorDownloadLink: Codable {
    public var link: String

    public init(link: String) {
        self.link = link
    }
}

/// A exception
public struct DiagnosticsException: Codable {
    /// Reason of the exception
    public var reason: String?
    /// Type of the exception (NSSomethingException, NullPointerException)
    public var type: String?
    /// Frames of the excetpion
    public var frames: [Frame]
    /// Relevant exception (crashed)
    public var isRelevant: Bool?
    public var innerExceptions: [DiagnosticsException]?
    /// SDK/Platform this thread is beeing generated from
    public var platform: Platform?

    /// A single frame of a stack trace
    public struct Frame: Codable {
        /// Address of the frame
        public var address: String?
        /// Name of the class
        public var className: String?
        /// Name of the method
        public var method: String?
        /// Is a class method
        public var isClassMethod: Bool?
        /// Name of the file
        public var file: String?
        /// Line number
        public var line: Int?
        /// This line isn't from any framework
        public var isAppCode: Bool
        /// Name of the framework
        public var frameworkName: String?
        /// Raw frame string
        public var codeRaw: String
        /// Formatted frame string
        public var codeFormatted: String
        /// Programming language of the frame
        public var language: Language?
        /// Frame should be shown always
        public var isRelevant: Bool?
        /// Parameters of the frames method
        public var methodParams: String?

        /// Programming language of the frame
        public enum Language: String, Codable, CaseIterable {
            case javaScript = "JavaScript"
            case cSharp = "CSharp"
            case objectiveC = "Objective-C"
            case objectiveCpp = "Objective-Cpp"
            case cpp = "Cpp"
            case c = "C"
            case swift = "Swift"
            case java = "Java"
            case unknown = "Unknown"
        }

        public init(address: String? = nil, className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool, frameworkName: String? = nil, codeRaw: String, codeFormatted: String, language: Language? = nil, isRelevant: Bool? = nil, methodParams: String? = nil) {
            self.address = address
            self.className = className
            self.method = method
            self.isClassMethod = isClassMethod
            self.file = file
            self.line = line
            self.isAppCode = isAppCode
            self.frameworkName = frameworkName
            self.codeRaw = codeRaw
            self.codeFormatted = codeFormatted
            self.language = language
            self.isRelevant = isRelevant
            self.methodParams = methodParams
        }

        private enum CodingKeys: String, CodingKey {
            case address
            case className = "class_name"
            case method
            case isClassMethod = "class_method"
            case file
            case line
            case isAppCode = "app_code"
            case frameworkName = "framework_name"
            case codeRaw = "code_raw"
            case codeFormatted = "code_formatted"
            case language
            case isRelevant = "relevant"
            case methodParams = "method_params"
        }
    }

    /// SDK/Platform this thread is beeing generated from
    public enum Platform: String, Codable, CaseIterable {
        case ios
        case android
        case xamarin
        case reactNative = "react-native"
        case ndk
        case unity
        case other
    }

    public init(reason: String? = nil, type: String? = nil, frames: [Frame], isRelevant: Bool? = nil, innerExceptions: [DiagnosticsException]? = nil, platform: Platform? = nil) {
        self.reason = reason
        self.type = type
        self.frames = frames
        self.isRelevant = isRelevant
        self.innerExceptions = innerExceptions
        self.platform = platform
    }

    private enum CodingKeys: String, CodingKey {
        case reason
        case type
        case frames
        case isRelevant = "relevant"
        case innerExceptions = "inner_exceptions"
        case platform
    }
}

/// A stacktrace in a processed and prettyfied way
public struct DiagnosticsStackTrace: Codable {
    public var title: String?
    public var reason: String?
    public var threads: [DiagnosticsThread]?
    public var exception: DiagnosticsException?

    public init(title: String? = nil, reason: String? = nil, threads: [DiagnosticsThread]? = nil, exception: DiagnosticsException? = nil) {
        self.title = title
        self.reason = reason
        self.threads = threads
        self.exception = exception
    }
}

/// A thread representation
public struct DiagnosticsThread: Codable {
    /// Name of the thread
    public var title: String
    /// Frames of that thread
    public var frames: [Frame]
    public var exception: DiagnosticsException?
    /// Shows if a thread is relevant or not. Is false if all frames are non relevant, otherwise true
    public var isRelevant: Bool?
    /// SDK/Platform this thread is beeing generated from
    public var platform: Platform?
    /// True if this thread crashed
    public var isCrashed: Bool?

    /// A single frame of a stack trace
    public struct Frame: Codable {
        /// Address of the frame
        public var address: String?
        /// Name of the class
        public var className: String?
        /// Name of the method
        public var method: String?
        /// Is a class method
        public var isClassMethod: Bool?
        /// Name of the file
        public var file: String?
        /// Line number
        public var line: Int?
        /// This line isn't from any framework
        public var isAppCode: Bool
        /// Name of the framework
        public var frameworkName: String?
        /// Raw frame string
        public var codeRaw: String
        /// Formatted frame string
        public var codeFormatted: String
        /// Programming language of the frame
        public var language: Language?
        /// Frame should be shown always
        public var isRelevant: Bool?
        /// Parameters of the frames method
        public var methodParams: String?

        /// Programming language of the frame
        public enum Language: String, Codable, CaseIterable {
            case javaScript = "JavaScript"
            case cSharp = "CSharp"
            case objectiveC = "Objective-C"
            case objectiveCpp = "Objective-Cpp"
            case cpp = "Cpp"
            case c = "C"
            case swift = "Swift"
            case java = "Java"
            case unknown = "Unknown"
        }

        public init(address: String? = nil, className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool, frameworkName: String? = nil, codeRaw: String, codeFormatted: String, language: Language? = nil, isRelevant: Bool? = nil, methodParams: String? = nil) {
            self.address = address
            self.className = className
            self.method = method
            self.isClassMethod = isClassMethod
            self.file = file
            self.line = line
            self.isAppCode = isAppCode
            self.frameworkName = frameworkName
            self.codeRaw = codeRaw
            self.codeFormatted = codeFormatted
            self.language = language
            self.isRelevant = isRelevant
            self.methodParams = methodParams
        }

        private enum CodingKeys: String, CodingKey {
            case address
            case className = "class_name"
            case method
            case isClassMethod = "class_method"
            case file
            case line
            case isAppCode = "app_code"
            case frameworkName = "framework_name"
            case codeRaw = "code_raw"
            case codeFormatted = "code_formatted"
            case language
            case isRelevant = "relevant"
            case methodParams = "method_params"
        }
    }

    /// SDK/Platform this thread is beeing generated from
    public enum Platform: String, Codable, CaseIterable {
        case ios
        case android
        case xamarin
        case reactNative = "react-native"
        case ndk
        case unity
        case other
    }

    public init(title: String, frames: [Frame], exception: DiagnosticsException? = nil, isRelevant: Bool? = nil, platform: Platform? = nil, isCrashed: Bool? = nil) {
        self.title = title
        self.frames = frames
        self.exception = exception
        self.isRelevant = isRelevant
        self.platform = platform
        self.isCrashed = isCrashed
    }

    private enum CodingKeys: String, CodingKey {
        case title
        case frames
        case exception
        case isRelevant = "relevant"
        case platform
        case isCrashed = "crashed"
    }
}

/// A single frame of a stack trace
public struct DiagnosticsStackFrame: Codable {
    /// Address of the frame
    public var address: String?
    /// Name of the class
    public var className: String?
    /// Name of the method
    public var method: String?
    /// Is a class method
    public var isClassMethod: Bool?
    /// Name of the file
    public var file: String?
    /// Line number
    public var line: Int?
    /// This line isn't from any framework
    public var isAppCode: Bool
    /// Name of the framework
    public var frameworkName: String?
    /// Raw frame string
    public var codeRaw: String
    /// Formatted frame string
    public var codeFormatted: String
    /// Programming language of the frame
    public var language: Language?
    /// Frame should be shown always
    public var isRelevant: Bool?
    /// Parameters of the frames method
    public var methodParams: String?

    /// Programming language of the frame
    public enum Language: String, Codable, CaseIterable {
        case javaScript = "JavaScript"
        case cSharp = "CSharp"
        case objectiveC = "Objective-C"
        case objectiveCpp = "Objective-Cpp"
        case cpp = "Cpp"
        case c = "C"
        case swift = "Swift"
        case java = "Java"
        case unknown = "Unknown"
    }

    public init(address: String? = nil, className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool, frameworkName: String? = nil, codeRaw: String, codeFormatted: String, language: Language? = nil, isRelevant: Bool? = nil, methodParams: String? = nil) {
        self.address = address
        self.className = className
        self.method = method
        self.isClassMethod = isClassMethod
        self.file = file
        self.line = line
        self.isAppCode = isAppCode
        self.frameworkName = frameworkName
        self.codeRaw = codeRaw
        self.codeFormatted = codeFormatted
        self.language = language
        self.isRelevant = isRelevant
        self.methodParams = methodParams
    }

    private enum CodingKeys: String, CodingKey {
        case address
        case className = "class_name"
        case method
        case isClassMethod = "class_method"
        case file
        case line
        case isAppCode = "app_code"
        case frameworkName = "framework_name"
        case codeRaw = "code_raw"
        case codeFormatted = "code_formatted"
        case language
        case isRelevant = "relevant"
        case methodParams = "method_params"
    }
}

public struct HandledErrorReasonFrame: Codable {
    /// Name of the class
    public var className: String?
    /// Name of the method
    public var method: String?
    /// Is a class method
    public var isClassMethod: Bool?
    /// Name of the file
    public var file: String?
    /// Line number
    public var line: Int?
    /// This line isn't from any framework
    public var isAppCode: Bool?
    /// Name of the framework
    public var frameworkName: String?
    /// Formatted frame string
    public var codeFormatted: String?
    /// Unformatted Frame string
    public var codeRaw: String?
    /// Programming language of the frame
    public var language: Language?
    /// Parameters of the frames method
    public var methodParams: String?
    /// Exception type.
    public var exceptionType: String?
    /// OS exception type. (aka. SIGNAL)
    public var osExceptionType: String?

    /// Programming language of the frame
    public enum Language: String, Codable, CaseIterable {
        case javaScript = "JavaScript"
        case cSharp = "CSharp"
        case objectiveC = "Objective-C"
        case objectiveCpp = "Objective-Cpp"
        case cpp = "Cpp"
        case c = "C"
        case swift = "Swift"
        case java = "Java"
        case unknown = "Unknown"
    }

    public init(className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool? = nil, frameworkName: String? = nil, codeFormatted: String? = nil, codeRaw: String? = nil, language: Language? = nil, methodParams: String? = nil, exceptionType: String? = nil, osExceptionType: String? = nil) {
        self.className = className
        self.method = method
        self.isClassMethod = isClassMethod
        self.file = file
        self.line = line
        self.isAppCode = isAppCode
        self.frameworkName = frameworkName
        self.codeFormatted = codeFormatted
        self.codeRaw = codeRaw
        self.language = language
        self.methodParams = methodParams
        self.exceptionType = exceptionType
        self.osExceptionType = osExceptionType
    }

    private enum CodingKeys: String, CodingKey {
        case className
        case method
        case isClassMethod = "classMethod"
        case file
        case line
        case isAppCode = "appCode"
        case frameworkName
        case codeFormatted
        case codeRaw
        case language
        case methodParams
        case exceptionType
        case osExceptionType
    }
}

public struct ErrorFreeDevicePercentages: Codable {
    /// Average percentage
    public var averagePercentage: Double?
    /// The error-free percentage per day.
    public var dailyPercentages: [DailyPercentage]?

    public struct DailyPercentage: Codable {
        /// The ISO 8601 datetime
        public var datetime: String?
        /// Percentage of the object
        public var percentage: Double?

        public init(datetime: String? = nil, percentage: Double? = nil) {
            self.datetime = datetime
            self.percentage = percentage
        }
    }

    public init(averagePercentage: Double? = nil, dailyPercentages: [DailyPercentage]? = nil) {
        self.averagePercentage = averagePercentage
        self.dailyPercentages = dailyPercentages
    }
}

public struct HandledErrors: Codable {
    public var nextLink: String?
    /// Errors list.
    public var errors: [Error]?

    public struct Error: Codable {
        public var errorID: String?
        public var timestamp: Date?
        public var deviceName: String?
        public var osVersion: String?
        public var osType: String?
        public var country: String?
        public var language: String?
        public var userID: String?
        public var hasBreadcrumbs: Bool?
        public var hasAttachments: Bool?

        public init(errorID: String? = nil, timestamp: Date? = nil, deviceName: String? = nil, osVersion: String? = nil, osType: String? = nil, country: String? = nil, language: String? = nil, userID: String? = nil, hasBreadcrumbs: Bool? = nil, hasAttachments: Bool? = nil) {
            self.errorID = errorID
            self.timestamp = timestamp
            self.deviceName = deviceName
            self.osVersion = osVersion
            self.osType = osType
            self.country = country
            self.language = language
            self.userID = userID
            self.hasBreadcrumbs = hasBreadcrumbs
            self.hasAttachments = hasAttachments
        }

        private enum CodingKeys: String, CodingKey {
            case errorID = "errorId"
            case timestamp
            case deviceName
            case osVersion
            case osType
            case country
            case language
            case userID = "userId"
            case hasBreadcrumbs
            case hasAttachments
        }
    }

    public init(nextLink: String? = nil, errors: [Error]? = nil) {
        self.nextLink = nextLink
        self.errors = errors
    }
}

public struct ErrorsSearchResult: Codable {
    public var hasMoreResults: Bool?
    public var errors: [Error]?

    public struct Error: Codable {
        public var errorID: String?
        public var timestamp: Date?
        public var deviceName: String?
        public var osVersion: String?
        public var osType: String?
        public var country: String?
        public var language: String?
        public var userID: String?
        public var hasBreadcrumbs: Bool?
        public var hasAttachments: Bool?

        public init(errorID: String? = nil, timestamp: Date? = nil, deviceName: String? = nil, osVersion: String? = nil, osType: String? = nil, country: String? = nil, language: String? = nil, userID: String? = nil, hasBreadcrumbs: Bool? = nil, hasAttachments: Bool? = nil) {
            self.errorID = errorID
            self.timestamp = timestamp
            self.deviceName = deviceName
            self.osVersion = osVersion
            self.osType = osType
            self.country = country
            self.language = language
            self.userID = userID
            self.hasBreadcrumbs = hasBreadcrumbs
            self.hasAttachments = hasAttachments
        }

        private enum CodingKeys: String, CodingKey {
            case errorID = "errorId"
            case timestamp
            case deviceName
            case osVersion
            case osType
            case country
            case language
            case userID = "userId"
            case hasBreadcrumbs
            case hasAttachments
        }
    }

    public init(hasMoreResults: Bool? = nil, errors: [Error]? = nil) {
        self.hasMoreResults = hasMoreResults
        self.errors = errors
    }
}

public struct HandledError: Codable {
    public var errorID: String?
    public var timestamp: Date?
    public var deviceName: String?
    public var osVersion: String?
    public var osType: String?
    public var country: String?
    public var language: String?
    public var userID: String?
    public var hasBreadcrumbs: Bool?
    public var hasAttachments: Bool?

    public init(errorID: String? = nil, timestamp: Date? = nil, deviceName: String? = nil, osVersion: String? = nil, osType: String? = nil, country: String? = nil, language: String? = nil, userID: String? = nil, hasBreadcrumbs: Bool? = nil, hasAttachments: Bool? = nil) {
        self.errorID = errorID
        self.timestamp = timestamp
        self.deviceName = deviceName
        self.osVersion = osVersion
        self.osType = osType
        self.country = country
        self.language = language
        self.userID = userID
        self.hasBreadcrumbs = hasBreadcrumbs
        self.hasAttachments = hasAttachments
    }

    private enum CodingKeys: String, CodingKey {
        case errorID = "errorId"
        case timestamp
        case deviceName
        case osVersion
        case osType
        case country
        case language
        case userID = "userId"
        case hasBreadcrumbs
        case hasAttachments
    }
}

public struct HandledErrorDetails: Codable {
    public var errorID: String?
    public var timestamp: Date?
    public var deviceName: String?
    public var osVersion: String?
    public var osType: String?
    public var country: String?
    public var language: String?
    public var userID: String?
    public var hasBreadcrumbs: Bool?
    public var hasAttachments: Bool?

    public init(errorID: String? = nil, timestamp: Date? = nil, deviceName: String? = nil, osVersion: String? = nil, osType: String? = nil, country: String? = nil, language: String? = nil, userID: String? = nil, hasBreadcrumbs: Bool? = nil, hasAttachments: Bool? = nil) {
        self.errorID = errorID
        self.timestamp = timestamp
        self.deviceName = deviceName
        self.osVersion = osVersion
        self.osType = osType
        self.country = country
        self.language = language
        self.userID = userID
        self.hasBreadcrumbs = hasBreadcrumbs
        self.hasAttachments = hasAttachments
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.errorID = try values.decodeIfPresent(String.self, forKey: "errorId")
        self.timestamp = try values.decodeIfPresent(Date.self, forKey: "timestamp")
        self.deviceName = try values.decodeIfPresent(String.self, forKey: "deviceName")
        self.osVersion = try values.decodeIfPresent(String.self, forKey: "osVersion")
        self.osType = try values.decodeIfPresent(String.self, forKey: "osType")
        self.country = try values.decodeIfPresent(String.self, forKey: "country")
        self.language = try values.decodeIfPresent(String.self, forKey: "language")
        self.userID = try values.decodeIfPresent(String.self, forKey: "userId")
        self.hasBreadcrumbs = try values.decodeIfPresent(Bool.self, forKey: "hasBreadcrumbs")
        self.hasAttachments = try values.decodeIfPresent(Bool.self, forKey: "hasAttachments")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(errorID, forKey: "errorId")
        try values.encodeIfPresent(timestamp, forKey: "timestamp")
        try values.encodeIfPresent(deviceName, forKey: "deviceName")
        try values.encodeIfPresent(osVersion, forKey: "osVersion")
        try values.encodeIfPresent(osType, forKey: "osType")
        try values.encodeIfPresent(country, forKey: "country")
        try values.encodeIfPresent(language, forKey: "language")
        try values.encodeIfPresent(userID, forKey: "userId")
        try values.encodeIfPresent(hasBreadcrumbs, forKey: "hasBreadcrumbs")
        try values.encodeIfPresent(hasAttachments, forKey: "hasAttachments")
    }
}

public struct ErrorDeleteCounter: Codable {
    public var appID: String?
    public var errorGroupID: String?
    public var errorID: String?
    public var errorsDeleted: Int?
    public var attachmentsDeleted: Int?
    public var blobsSucceeded: Int?
    public var blobsFailed: Int?

    public init(appID: String? = nil, errorGroupID: String? = nil, errorID: String? = nil, errorsDeleted: Int? = nil, attachmentsDeleted: Int? = nil, blobsSucceeded: Int? = nil, blobsFailed: Int? = nil) {
        self.appID = appID
        self.errorGroupID = errorGroupID
        self.errorID = errorID
        self.errorsDeleted = errorsDeleted
        self.attachmentsDeleted = attachmentsDeleted
        self.blobsSucceeded = blobsSucceeded
        self.blobsFailed = blobsFailed
    }

    private enum CodingKeys: String, CodingKey {
        case appID = "appId"
        case errorGroupID = "errorGroupId"
        case errorID = "errorId"
        case errorsDeleted
        case attachmentsDeleted
        case blobsSucceeded
        case blobsFailed
    }
}

public struct ErrorLocation: Codable {
    public var uri: String?

    public init(uri: String? = nil) {
        self.uri = uri
    }
}

public struct ErrorAttachmants: Codable {
    public var appID: String?
    public var attachmentID: String?
    public var crashID: String?
    public var blobLocation: String?
    public var contentType: String?
    public var fileName: String?
    public var createdTime: Date?
    public var size: Int?

    public init(appID: String? = nil, attachmentID: String? = nil, crashID: String? = nil, blobLocation: String? = nil, contentType: String? = nil, fileName: String? = nil, createdTime: Date? = nil, size: Int? = nil) {
        self.appID = appID
        self.attachmentID = attachmentID
        self.crashID = crashID
        self.blobLocation = blobLocation
        self.contentType = contentType
        self.fileName = fileName
        self.createdTime = createdTime
        self.size = size
    }

    private enum CodingKeys: String, CodingKey {
        case appID = "appId"
        case attachmentID = "attachmentId"
        case crashID = "crashId"
        case blobLocation
        case contentType
        case fileName
        case createdTime
        case size
    }
}

public struct ErrorAttachment: Codable {
    public var appID: String?
    public var attachmentID: String?
    public var crashID: String?
    public var blobLocation: String?
    public var contentType: String?
    public var fileName: String?
    public var createdTime: Date?
    public var size: Int?

    public init(appID: String? = nil, attachmentID: String? = nil, crashID: String? = nil, blobLocation: String? = nil, contentType: String? = nil, fileName: String? = nil, createdTime: Date? = nil, size: Int? = nil) {
        self.appID = appID
        self.attachmentID = attachmentID
        self.crashID = crashID
        self.blobLocation = blobLocation
        self.contentType = contentType
        self.fileName = fileName
        self.createdTime = createdTime
        self.size = size
    }

    private enum CodingKeys: String, CodingKey {
        case appID = "appId"
        case attachmentID = "attachmentId"
        case crashID = "crashId"
        case blobLocation
        case contentType
        case fileName
        case createdTime
        case size
    }
}

public struct ErrorAppBuilds: Codable {
    public var appBuilds: [String]?

    public init(appBuilds: [String]? = nil) {
        self.appBuilds = appBuilds
    }
}

public struct ErrorAttachmentText: Codable {
    public var content: String?

    public init(content: String? = nil) {
        self.content = content
    }
}

public struct ErrorAttachmentLocation: Codable {
    public var uri: String?

    public init(uri: String? = nil) {
        self.uri = uri
    }
}

public struct ErrorGroupModels: Codable {
    public var errorCount: Int?
    public var models: [Model]?

    public struct Model: Codable {
        /// Model name
        public var modelName: String?
        /// Model code
        public var modelCode: String?
        /// Count of errors in a model
        public var errorCount: Int?

        public init(modelName: String? = nil, modelCode: String? = nil, errorCount: Int? = nil) {
            self.modelName = modelName
            self.modelCode = modelCode
            self.errorCount = errorCount
        }
    }

    public init(errorCount: Int? = nil, models: [Model]? = nil) {
        self.errorCount = errorCount
        self.models = models
    }
}

public struct ErrorGroupModel: Codable {
    /// Model name
    public var modelName: String?
    /// Model code
    public var modelCode: String?
    /// Count of errors in a model
    public var errorCount: Int?

    public init(modelName: String? = nil, modelCode: String? = nil, errorCount: Int? = nil) {
        self.modelName = modelName
        self.modelCode = modelCode
        self.errorCount = errorCount
    }
}

public struct ErrorGroupOperatingSystems: Codable {
    public var errorCount: Int?
    public var operatingSystems: [OperatingSystem]?

    public struct OperatingSystem: Codable {
        /// OS name
        public var operatingSystemName: String?
        /// Count of OS
        public var errorCount: Int?

        public init(operatingSystemName: String? = nil, errorCount: Int? = nil) {
            self.operatingSystemName = operatingSystemName
            self.errorCount = errorCount
        }
    }

    public init(errorCount: Int? = nil, operatingSystems: [OperatingSystem]? = nil) {
        self.errorCount = errorCount
        self.operatingSystems = operatingSystems
    }
}

public struct ErrorGroupOperatingSystem: Codable {
    /// OS name
    public var operatingSystemName: String?
    /// Count of OS
    public var errorCount: Int?

    public init(operatingSystemName: String? = nil, errorCount: Int? = nil) {
        self.operatingSystemName = operatingSystemName
        self.errorCount = errorCount
    }
}

public struct GenericLogContainerDiagnostics: Codable {
    /// Indicates if the number of available logs are more than the max allowed return limit(100).
    public var isExceededMaxLimit: Bool?
    /// The timestamp of the last log received. This value can be used as the start time parameter in the consecutive API call.
    public var lastReceivedLogTimestamp: Date?
    /// The list of logs
    public var logs: [Log]

    /// Generic log.
    public struct Log: Codable {
        /// Log type.
        public var type: `Type`
        /// Log creation timestamp.
        public var timestamp: Date
        /// Install ID.
        public var installID: String
        /// Session ID.
        public var sessionID: String?
        /// Event ID.
        public var eventID: String?
        /// Event name.
        public var eventName: String?
        /// Message ID.
        public var messageID: String?
        /// Event specific properties.
        public var properties: [String: String]?
        /// Device characteristics.
        public var device: Device

        /// Log type.
        public enum `Type`: String, Codable, CaseIterable {
            case event
            case page
            case startSession = "start_session"
            case error
            case pushInstallation = "push_installation"
            case startService = "start_service"
            case customProperties = "custom_properties"
        }

        /// Device characteristics.
        public struct Device: Codable {
            /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
            public var sdkName: String
            /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
            public var sdkVersion: String
            /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
            public var wrapperSdkVersion: String?
            /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
            public var wrapperSdkName: String?
            /// Device model (example: iPad2,3).
            public var model: String?
            /// Device manufacturer (example: HTC).
            public var oemName: String?
            /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
            public var osName: String
            /// OS version (example: 9.3.0).
            public var osVersion: String
            /// OS build code (example: LMY47X).
            public var osBuild: String?
            /// API level when applicable like in Android (example: 15).
            public var osAPILevel: Int?
            /// Language code (example: en_US).
            public var locale: String
            /// The offset in minutes from UTC for the device time zone, including daylight savings time.
            public var timeZoneOffset: Int
            /// Screen size of the device in pixels (example: 640x480).
            public var screenSize: String?
            /// Application version name, e.g. 1.1.0
            public var appVersion: String
            /// Carrier name (for mobile devices).
            public var carrierName: String?
            /// Carrier country code (for mobile devices).
            public var carrierCode: String?
            /// Carrier country.
            public var carrierCountry: String?
            /// The app's build number, e.g. 42.
            public var appBuild: String
            /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
            public var appNamespace: String?
            /// Label that is used to identify application code 'version' released via Live Update beacon running on device
            public var liveUpdateReleaseLabel: String?
            /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
            public var liveUpdateDeploymentKey: String?
            /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
            public var liveUpdatePackageHash: String?
            /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
            public var wrapperRuntimeVersion: String?

            public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
                self.sdkName = sdkName
                self.sdkVersion = sdkVersion
                self.wrapperSdkVersion = wrapperSdkVersion
                self.wrapperSdkName = wrapperSdkName
                self.model = model
                self.oemName = oemName
                self.osName = osName
                self.osVersion = osVersion
                self.osBuild = osBuild
                self.osAPILevel = osAPILevel
                self.locale = locale
                self.timeZoneOffset = timeZoneOffset
                self.screenSize = screenSize
                self.appVersion = appVersion
                self.carrierName = carrierName
                self.carrierCode = carrierCode
                self.carrierCountry = carrierCountry
                self.appBuild = appBuild
                self.appNamespace = appNamespace
                self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
                self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
                self.liveUpdatePackageHash = liveUpdatePackageHash
                self.wrapperRuntimeVersion = wrapperRuntimeVersion
            }

            private enum CodingKeys: String, CodingKey {
                case sdkName = "sdk_name"
                case sdkVersion = "sdk_version"
                case wrapperSdkVersion = "wrapper_sdk_version"
                case wrapperSdkName = "wrapper_sdk_name"
                case model
                case oemName = "oem_name"
                case osName = "os_name"
                case osVersion = "os_version"
                case osBuild = "os_build"
                case osAPILevel = "os_api_level"
                case locale
                case timeZoneOffset = "time_zone_offset"
                case screenSize = "screen_size"
                case appVersion = "app_version"
                case carrierName = "carrier_name"
                case carrierCode = "carrier_code"
                case carrierCountry = "carrier_country"
                case appBuild = "app_build"
                case appNamespace = "app_namespace"
                case liveUpdateReleaseLabel = "live_update_release_label"
                case liveUpdateDeploymentKey = "live_update_deployment_key"
                case liveUpdatePackageHash = "live_update_package_hash"
                case wrapperRuntimeVersion = "wrapper_runtime_version"
            }
        }

        public init(type: `Type`, timestamp: Date, installID: String, sessionID: String? = nil, eventID: String? = nil, eventName: String? = nil, messageID: String? = nil, properties: [String: String]? = nil, device: Device) {
            self.type = type
            self.timestamp = timestamp
            self.installID = installID
            self.sessionID = sessionID
            self.eventID = eventID
            self.eventName = eventName
            self.messageID = messageID
            self.properties = properties
            self.device = device
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case timestamp
            case installID = "install_id"
            case sessionID = "session_id"
            case eventID = "event_id"
            case eventName = "event_name"
            case messageID = "message_id"
            case properties
            case device
        }
    }

    public init(isExceededMaxLimit: Bool? = nil, lastReceivedLogTimestamp: Date? = nil, logs: [Log]) {
        self.isExceededMaxLimit = isExceededMaxLimit
        self.lastReceivedLogTimestamp = lastReceivedLogTimestamp
        self.logs = logs
    }

    private enum CodingKeys: String, CodingKey {
        case isExceededMaxLimit = "exceeded_max_limit"
        case lastReceivedLogTimestamp = "last_received_log_timestamp"
        case logs
    }
}

/// Generic log.
public struct GenericLogDiagnostics: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Session ID.
    public var sessionID: String?
    /// Event ID.
    public var eventID: String?
    /// Event name.
    public var eventName: String?
    /// Message ID.
    public var messageID: String?
    /// Event specific properties.
    public var properties: [String: String]?
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, sessionID: String? = nil, eventID: String? = nil, eventName: String? = nil, messageID: String? = nil, properties: [String: String]? = nil, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.sessionID = sessionID
        self.eventID = eventID
        self.eventName = eventName
        self.messageID = messageID
        self.properties = properties
        self.device = device
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case timestamp
        case installID = "install_id"
        case sessionID = "session_id"
        case eventID = "event_id"
        case eventName = "event_name"
        case messageID = "message_id"
        case properties
        case device
    }
}

public struct LogDiagnostics: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case timestamp
        case installID = "install_id"
        case device
    }
}

public struct LogWithPropertiesDiagnostics: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

/// Device characteristics.
public struct DeviceDiagnostics: Codable {
    /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
    public var sdkName: String
    /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
    public var sdkVersion: String
    /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
    public var wrapperSdkVersion: String?
    /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
    public var wrapperSdkName: String?
    /// Device model (example: iPad2,3).
    public var model: String?
    /// Device manufacturer (example: HTC).
    public var oemName: String?
    /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
    public var osName: String
    /// OS version (example: 9.3.0).
    public var osVersion: String
    /// OS build code (example: LMY47X).
    public var osBuild: String?
    /// API level when applicable like in Android (example: 15).
    public var osAPILevel: Int?
    /// Language code (example: en_US).
    public var locale: String
    /// The offset in minutes from UTC for the device time zone, including daylight savings time.
    public var timeZoneOffset: Int
    /// Screen size of the device in pixels (example: 640x480).
    public var screenSize: String?
    /// Application version name, e.g. 1.1.0
    public var appVersion: String
    /// Carrier name (for mobile devices).
    public var carrierName: String?
    /// Carrier country code (for mobile devices).
    public var carrierCode: String?
    /// Carrier country.
    public var carrierCountry: String?
    /// The app's build number, e.g. 42.
    public var appBuild: String
    /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
    public var appNamespace: String?
    /// Label that is used to identify application code 'version' released via Live Update beacon running on device
    public var liveUpdateReleaseLabel: String?
    /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
    public var liveUpdateDeploymentKey: String?
    /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
    public var liveUpdatePackageHash: String?
    /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
    public var wrapperRuntimeVersion: String?

    public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
        self.sdkName = sdkName
        self.sdkVersion = sdkVersion
        self.wrapperSdkVersion = wrapperSdkVersion
        self.wrapperSdkName = wrapperSdkName
        self.model = model
        self.oemName = oemName
        self.osName = osName
        self.osVersion = osVersion
        self.osBuild = osBuild
        self.osAPILevel = osAPILevel
        self.locale = locale
        self.timeZoneOffset = timeZoneOffset
        self.screenSize = screenSize
        self.appVersion = appVersion
        self.carrierName = carrierName
        self.carrierCode = carrierCode
        self.carrierCountry = carrierCountry
        self.appBuild = appBuild
        self.appNamespace = appNamespace
        self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
        self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
        self.liveUpdatePackageHash = liveUpdatePackageHash
        self.wrapperRuntimeVersion = wrapperRuntimeVersion
    }

    private enum CodingKeys: String, CodingKey {
        case sdkName = "sdk_name"
        case sdkVersion = "sdk_version"
        case wrapperSdkVersion = "wrapper_sdk_version"
        case wrapperSdkName = "wrapper_sdk_name"
        case model
        case oemName = "oem_name"
        case osName = "os_name"
        case osVersion = "os_version"
        case osBuild = "os_build"
        case osAPILevel = "os_api_level"
        case locale
        case timeZoneOffset = "time_zone_offset"
        case screenSize = "screen_size"
        case appVersion = "app_version"
        case carrierName = "carrier_name"
        case carrierCode = "carrier_code"
        case carrierCountry = "carrier_country"
        case appBuild = "app_build"
        case appNamespace = "app_namespace"
        case liveUpdateReleaseLabel = "live_update_release_label"
        case liveUpdateDeploymentKey = "live_update_deployment_key"
        case liveUpdatePackageHash = "live_update_package_hash"
        case wrapperRuntimeVersion = "wrapper_runtime_version"
    }
}

/// Required explicit begin session log (a marker event for analytics service).
public struct StartSessionLogDiagnostics: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

/// Required explicit begin session log (a marker event for analytics service).
public struct HanledErrorLogDiagnostics: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

/// Describe a AppCenter.Start API call from the SDK.
public struct StartServiceLogDiagnostics: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

/// Set or remove custom properties.
public struct CustomPropertyLogDiagnostics: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

public struct CustomPropertyDiagnostics: Codable {
    public var type: String
    public var name: String

    public init(type: String, name: String) {
        self.type = type
        self.name = name
    }
}

/// String property.
public struct StringPropertyDiagnostics: Codable {
    public var type: String
    public var name: String

    public init(type: String, name: String) {
        self.type = type
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.name = try values.decode(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(name, forKey: "name")
    }
}

/// Number property.
public struct NumberPropertyDiagnostics: Codable {
    public var type: String
    public var name: String

    public init(type: String, name: String) {
        self.type = type
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.name = try values.decode(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(name, forKey: "name")
    }
}

/// Boolean property.
public struct BooleanPropertyDiagnostics: Codable {
    public var type: String
    public var name: String

    public init(type: String, name: String) {
        self.type = type
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.name = try values.decode(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(name, forKey: "name")
    }
}

/// Date and time property.
public struct DateTimePropertyDiagnostics: Codable {
    public var type: String
    public var name: String

    public init(type: String, name: String) {
        self.type = type
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.name = try values.decode(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(name, forKey: "name")
    }
}

/// Clear an existing property.
public struct ClearPropertyDiagnostics: Codable {
    public var type: String
    public var name: String

    public init(type: String, name: String) {
        self.type = type
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try values.decode(String.self, forKey: "type")
        self.name = try values.decode(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(name, forKey: "name")
    }
}

public struct PageLogDiagnostics: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

public struct EventLogDiagnostics: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

/// Error log.
public struct ErrorLogDiagnostics: Codable {
    /// Log type.
    public var type: `Type`
    /// Log creation timestamp.
    public var timestamp: Date
    /// Install ID.
    public var installID: String
    /// Device characteristics.
    public var device: Device

    /// Log type.
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case page
        case startSession = "start_session"
        case error
        case pushInstallation = "push_installation"
        case startService = "start_service"
        case customProperties = "custom_properties"
    }

    /// Device characteristics.
    public struct Device: Codable {
        /// Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".
        public var sdkName: String
        /// Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".
        public var sdkVersion: String
        /// Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.
        public var wrapperSdkVersion: String?
        /// Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".
        public var wrapperSdkName: String?
        /// Device model (example: iPad2,3).
        public var model: String?
        /// Device manufacturer (example: HTC).
        public var oemName: String?
        /// OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.
        public var osName: String
        /// OS version (example: 9.3.0).
        public var osVersion: String
        /// OS build code (example: LMY47X).
        public var osBuild: String?
        /// API level when applicable like in Android (example: 15).
        public var osAPILevel: Int?
        /// Language code (example: en_US).
        public var locale: String
        /// The offset in minutes from UTC for the device time zone, including daylight savings time.
        public var timeZoneOffset: Int
        /// Screen size of the device in pixels (example: 640x480).
        public var screenSize: String?
        /// Application version name, e.g. 1.1.0
        public var appVersion: String
        /// Carrier name (for mobile devices).
        public var carrierName: String?
        /// Carrier country code (for mobile devices).
        public var carrierCode: String?
        /// Carrier country.
        public var carrierCountry: String?
        /// The app's build number, e.g. 42.
        public var appBuild: String
        /// The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.
        public var appNamespace: String?
        /// Label that is used to identify application code 'version' released via Live Update beacon running on device
        public var liveUpdateReleaseLabel: String?
        /// Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.
        public var liveUpdateDeploymentKey: String?
        /// Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.
        public var liveUpdatePackageHash: String?
        /// Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.
        public var wrapperRuntimeVersion: String?

        public init(sdkName: String, sdkVersion: String, wrapperSdkVersion: String? = nil, wrapperSdkName: String? = nil, model: String? = nil, oemName: String? = nil, osName: String, osVersion: String, osBuild: String? = nil, osAPILevel: Int? = nil, locale: String, timeZoneOffset: Int, screenSize: String? = nil, appVersion: String, carrierName: String? = nil, carrierCode: String? = nil, carrierCountry: String? = nil, appBuild: String, appNamespace: String? = nil, liveUpdateReleaseLabel: String? = nil, liveUpdateDeploymentKey: String? = nil, liveUpdatePackageHash: String? = nil, wrapperRuntimeVersion: String? = nil) {
            self.sdkName = sdkName
            self.sdkVersion = sdkVersion
            self.wrapperSdkVersion = wrapperSdkVersion
            self.wrapperSdkName = wrapperSdkName
            self.model = model
            self.oemName = oemName
            self.osName = osName
            self.osVersion = osVersion
            self.osBuild = osBuild
            self.osAPILevel = osAPILevel
            self.locale = locale
            self.timeZoneOffset = timeZoneOffset
            self.screenSize = screenSize
            self.appVersion = appVersion
            self.carrierName = carrierName
            self.carrierCode = carrierCode
            self.carrierCountry = carrierCountry
            self.appBuild = appBuild
            self.appNamespace = appNamespace
            self.liveUpdateReleaseLabel = liveUpdateReleaseLabel
            self.liveUpdateDeploymentKey = liveUpdateDeploymentKey
            self.liveUpdatePackageHash = liveUpdatePackageHash
            self.wrapperRuntimeVersion = wrapperRuntimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sdkName = "sdk_name"
            case sdkVersion = "sdk_version"
            case wrapperSdkVersion = "wrapper_sdk_version"
            case wrapperSdkName = "wrapper_sdk_name"
            case model
            case oemName = "oem_name"
            case osName = "os_name"
            case osVersion = "os_version"
            case osBuild = "os_build"
            case osAPILevel = "os_api_level"
            case locale
            case timeZoneOffset = "time_zone_offset"
            case screenSize = "screen_size"
            case appVersion = "app_version"
            case carrierName = "carrier_name"
            case carrierCode = "carrier_code"
            case carrierCountry = "carrier_country"
            case appBuild = "app_build"
            case appNamespace = "app_namespace"
            case liveUpdateReleaseLabel = "live_update_release_label"
            case liveUpdateDeploymentKey = "live_update_deployment_key"
            case liveUpdatePackageHash = "live_update_package_hash"
            case wrapperRuntimeVersion = "wrapper_runtime_version"
        }
    }

    public init(type: `Type`, timestamp: Date, installID: String, device: Device) {
        self.type = type
        self.timestamp = timestamp
        self.installID = installID
        self.device = device
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.timestamp = try values.decode(Date.self, forKey: "timestamp")
        self.installID = try values.decode(String.self, forKey: "install_id")
        self.device = try Device(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encode(timestamp, forKey: "timestamp")
        try values.encode(installID, forKey: "install_id")
        try values.encode(device, forKey: "device")
    }
}

public struct VersionsDiagnostics: Codable {
    /// List of version count
    public var versions: [Version]?
    /// The total count of versions
    public var total: Int?

    public struct Version: Codable {
        /// Version
        public var version: String?
        /// Version count
        public var count: Int?
        /// The count of previous time range of the version
        public var previousCount: Int?

        public init(version: String? = nil, count: Int? = nil, previousCount: Int? = nil) {
            self.version = version
            self.count = count
            self.previousCount = previousCount
        }

        private enum CodingKeys: String, CodingKey {
            case version
            case count
            case previousCount = "previous_count"
        }
    }

    public init(versions: [Version]? = nil, total: Int? = nil) {
        self.versions = versions
        self.total = total
    }
}

public struct VersionDiagnostics: Codable {
    /// Version
    public var version: String?
    /// Version count
    public var count: Int?
    /// The count of previous time range of the version
    public var previousCount: Int?

    public init(version: String? = nil, count: Int? = nil, previousCount: Int? = nil) {
        self.version = version
        self.count = count
        self.previousCount = previousCount
    }

    private enum CodingKeys: String, CodingKey {
        case version
        case count
        case previousCount = "previous_count"
    }
}

public struct AvailableVersionsDiagnostics: Codable {
    /// List of available versions.
    public var versions: [String]?
    /// The full number of versions across all pages.
    public var totalCount: Int?

    public init(versions: [String]? = nil, totalCount: Int? = nil) {
        self.versions = versions
        self.totalCount = totalCount
    }

    private enum CodingKeys: String, CodingKey {
        case versions
        case totalCount = "total_count"
    }
}

public struct ErrorRetentionSettings: Codable {
    public var retentionInDays: Int

    public init(retentionInDays: Int) {
        self.retentionInDays = retentionInDays
    }

    private enum CodingKeys: String, CodingKey {
        case retentionInDays = "retention_in_days"
    }
}

public enum ExportEntity: String, Codable, CaseIterable {
    case crashes
    case errors
    case attachments
    case noLogs = "no_logs"
}

/// Export configuration
public struct ExportConfiguration: Codable {
    /// Type of export configuration
    public var type: `Type`
    public var exportEntities: [ExportEntity]?
    /// The resource name on azure
    public var resourceName: String?
    /// The resource group name on azure
    public var resourceGroup: String?
    /// Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.
    public var isBackfill: Bool?

    /// Type of export configuration
    public enum `Type`: String, Codable, CaseIterable {
        case blobStorageConnectionString = "blob_storage_connection_string"
        case applicationInsightsInstrumentationKey = "application_insights_instrumentation_key"
        case blobStorageLinkedSubscription = "blob_storage_linked_subscription"
        case applicationInsightsLinkedSubscription = "application_insights_linked_subscription"
    }

    public enum ExportEntity: String, Codable, CaseIterable {
        case crashes
        case errors
        case attachments
        case noLogs = "no_logs"
    }

    public init(type: `Type`, exportEntities: [ExportEntity]? = nil, resourceName: String? = nil, resourceGroup: String? = nil, isBackfill: Bool? = nil) {
        self.type = type
        self.exportEntities = exportEntities
        self.resourceName = resourceName
        self.resourceGroup = resourceGroup
        self.isBackfill = isBackfill
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case exportEntities = "export_entities"
        case resourceName = "resource_name"
        case resourceGroup = "resource_group"
        case isBackfill = "backfill"
    }
}

/// Configuration for export to Blob Storage with blob format
public struct ExportBlobConfiguration: Codable {
    /// Type of export configuration
    public var type: `Type`
    public var exportEntities: [ExportEntity]?
    /// The resource name on azure
    public var resourceName: String?
    /// The resource group name on azure
    public var resourceGroup: String?
    /// Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.
    public var isBackfill: Bool?

    /// Type of export configuration
    public enum `Type`: String, Codable, CaseIterable {
        case blobStorageConnectionString = "blob_storage_connection_string"
        case applicationInsightsInstrumentationKey = "application_insights_instrumentation_key"
        case blobStorageLinkedSubscription = "blob_storage_linked_subscription"
        case applicationInsightsLinkedSubscription = "application_insights_linked_subscription"
    }

    public enum ExportEntity: String, Codable, CaseIterable {
        case crashes
        case errors
        case attachments
        case noLogs = "no_logs"
    }

    public init(type: `Type`, exportEntities: [ExportEntity]? = nil, resourceName: String? = nil, resourceGroup: String? = nil, isBackfill: Bool? = nil) {
        self.type = type
        self.exportEntities = exportEntities
        self.resourceName = resourceName
        self.resourceGroup = resourceGroup
        self.isBackfill = isBackfill
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.exportEntities = try values.decodeIfPresent([ExportEntity].self, forKey: "export_entities")
        self.resourceName = try values.decodeIfPresent(String.self, forKey: "resource_name")
        self.resourceGroup = try values.decodeIfPresent(String.self, forKey: "resource_group")
        self.isBackfill = try values.decodeIfPresent(Bool.self, forKey: "backfill")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encodeIfPresent(exportEntities, forKey: "export_entities")
        try values.encodeIfPresent(resourceName, forKey: "resource_name")
        try values.encodeIfPresent(resourceGroup, forKey: "resource_group")
        try values.encodeIfPresent(isBackfill, forKey: "backfill")
    }
}

/// Configuration for export to Blob Storage with blob format
public struct ExportConfigurationBlobStorageConnectionString: Codable {
    /// Type of export configuration
    public var type: `Type`
    public var exportEntities: [ExportEntity]?
    /// The resource name on azure
    public var resourceName: String?
    /// The resource group name on azure
    public var resourceGroup: String?
    /// Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.
    public var isBackfill: Bool?

    /// Type of export configuration
    public enum `Type`: String, Codable, CaseIterable {
        case blobStorageConnectionString = "blob_storage_connection_string"
        case applicationInsightsInstrumentationKey = "application_insights_instrumentation_key"
        case blobStorageLinkedSubscription = "blob_storage_linked_subscription"
        case applicationInsightsLinkedSubscription = "application_insights_linked_subscription"
    }

    public enum ExportEntity: String, Codable, CaseIterable {
        case crashes
        case errors
        case attachments
        case noLogs = "no_logs"
    }

    public init(type: `Type`, exportEntities: [ExportEntity]? = nil, resourceName: String? = nil, resourceGroup: String? = nil, isBackfill: Bool? = nil) {
        self.type = type
        self.exportEntities = exportEntities
        self.resourceName = resourceName
        self.resourceGroup = resourceGroup
        self.isBackfill = isBackfill
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.exportEntities = try values.decodeIfPresent([ExportEntity].self, forKey: "export_entities")
        self.resourceName = try values.decodeIfPresent(String.self, forKey: "resource_name")
        self.resourceGroup = try values.decodeIfPresent(String.self, forKey: "resource_group")
        self.isBackfill = try values.decodeIfPresent(Bool.self, forKey: "backfill")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encodeIfPresent(exportEntities, forKey: "export_entities")
        try values.encodeIfPresent(resourceName, forKey: "resource_name")
        try values.encodeIfPresent(resourceGroup, forKey: "resource_group")
        try values.encodeIfPresent(isBackfill, forKey: "backfill")
    }
}

/// Configuration for export to Application Insights resource with customer provided intrumentation key
public struct ExportConfigurationAppInsightsKey: Codable {
    /// Type of export configuration
    public var type: `Type`
    public var exportEntities: [ExportEntity]?
    /// The resource name on azure
    public var resourceName: String?
    /// The resource group name on azure
    public var resourceGroup: String?
    /// Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.
    public var isBackfill: Bool?

    /// Type of export configuration
    public enum `Type`: String, Codable, CaseIterable {
        case blobStorageConnectionString = "blob_storage_connection_string"
        case applicationInsightsInstrumentationKey = "application_insights_instrumentation_key"
        case blobStorageLinkedSubscription = "blob_storage_linked_subscription"
        case applicationInsightsLinkedSubscription = "application_insights_linked_subscription"
    }

    public enum ExportEntity: String, Codable, CaseIterable {
        case crashes
        case errors
        case attachments
        case noLogs = "no_logs"
    }

    public init(type: `Type`, exportEntities: [ExportEntity]? = nil, resourceName: String? = nil, resourceGroup: String? = nil, isBackfill: Bool? = nil) {
        self.type = type
        self.exportEntities = exportEntities
        self.resourceName = resourceName
        self.resourceGroup = resourceGroup
        self.isBackfill = isBackfill
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.exportEntities = try values.decodeIfPresent([ExportEntity].self, forKey: "export_entities")
        self.resourceName = try values.decodeIfPresent(String.self, forKey: "resource_name")
        self.resourceGroup = try values.decodeIfPresent(String.self, forKey: "resource_group")
        self.isBackfill = try values.decodeIfPresent(Bool.self, forKey: "backfill")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encodeIfPresent(exportEntities, forKey: "export_entities")
        try values.encodeIfPresent(resourceName, forKey: "resource_name")
        try values.encodeIfPresent(resourceGroup, forKey: "resource_group")
        try values.encodeIfPresent(isBackfill, forKey: "backfill")
    }
}

/// Configuration for export to Blob Storage with blob format
public struct ExportConfigurationBlobStorageLinkedSubscription: Codable {
    /// Type of export configuration
    public var type: `Type`
    public var exportEntities: [ExportEntity]?
    /// The resource name on azure
    public var resourceName: String?
    /// The resource group name on azure
    public var resourceGroup: String?
    /// Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.
    public var isBackfill: Bool?

    /// Type of export configuration
    public enum `Type`: String, Codable, CaseIterable {
        case blobStorageConnectionString = "blob_storage_connection_string"
        case applicationInsightsInstrumentationKey = "application_insights_instrumentation_key"
        case blobStorageLinkedSubscription = "blob_storage_linked_subscription"
        case applicationInsightsLinkedSubscription = "application_insights_linked_subscription"
    }

    public enum ExportEntity: String, Codable, CaseIterable {
        case crashes
        case errors
        case attachments
        case noLogs = "no_logs"
    }

    public init(type: `Type`, exportEntities: [ExportEntity]? = nil, resourceName: String? = nil, resourceGroup: String? = nil, isBackfill: Bool? = nil) {
        self.type = type
        self.exportEntities = exportEntities
        self.resourceName = resourceName
        self.resourceGroup = resourceGroup
        self.isBackfill = isBackfill
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.exportEntities = try values.decodeIfPresent([ExportEntity].self, forKey: "export_entities")
        self.resourceName = try values.decodeIfPresent(String.self, forKey: "resource_name")
        self.resourceGroup = try values.decodeIfPresent(String.self, forKey: "resource_group")
        self.isBackfill = try values.decodeIfPresent(Bool.self, forKey: "backfill")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encodeIfPresent(exportEntities, forKey: "export_entities")
        try values.encodeIfPresent(resourceName, forKey: "resource_name")
        try values.encodeIfPresent(resourceGroup, forKey: "resource_group")
        try values.encodeIfPresent(isBackfill, forKey: "backfill")
    }
}

/// Configuration for export to Application Insights resource with customer linked subscription.
public struct ExportConfigurationAppInsightsLinkedSubscription: Codable {
    /// Type of export configuration
    public var type: `Type`
    public var exportEntities: [ExportEntity]?
    /// The resource name on azure
    public var resourceName: String?
    /// The resource group name on azure
    public var resourceGroup: String?
    /// Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.
    public var isBackfill: Bool?

    /// Type of export configuration
    public enum `Type`: String, Codable, CaseIterable {
        case blobStorageConnectionString = "blob_storage_connection_string"
        case applicationInsightsInstrumentationKey = "application_insights_instrumentation_key"
        case blobStorageLinkedSubscription = "blob_storage_linked_subscription"
        case applicationInsightsLinkedSubscription = "application_insights_linked_subscription"
    }

    public enum ExportEntity: String, Codable, CaseIterable {
        case crashes
        case errors
        case attachments
        case noLogs = "no_logs"
    }

    public init(type: `Type`, exportEntities: [ExportEntity]? = nil, resourceName: String? = nil, resourceGroup: String? = nil, isBackfill: Bool? = nil) {
        self.type = type
        self.exportEntities = exportEntities
        self.resourceName = resourceName
        self.resourceGroup = resourceGroup
        self.isBackfill = isBackfill
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.type = try `Type`(from: decoder)
        self.exportEntities = try values.decodeIfPresent([ExportEntity].self, forKey: "export_entities")
        self.resourceName = try values.decodeIfPresent(String.self, forKey: "resource_name")
        self.resourceGroup = try values.decodeIfPresent(String.self, forKey: "resource_group")
        self.isBackfill = try values.decodeIfPresent(Bool.self, forKey: "backfill")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(type, forKey: "type")
        try values.encodeIfPresent(exportEntities, forKey: "export_entities")
        try values.encodeIfPresent(resourceName, forKey: "resource_name")
        try values.encodeIfPresent(resourceGroup, forKey: "resource_group")
        try values.encodeIfPresent(isBackfill, forKey: "backfill")
    }
}

/// Export configuration result
public struct ExportConfigurationResult: Codable {
    /// Export configuration id
    public var id: String
    /// Target resource type of export configuration
    public var exportType: ExportType
    /// Creation time in ISO 8601 format
    public var creationTime: String
    /// Latest time in ISO 8601 format when export completed successfully
    public var lastRunTime: String?
    public var exportEntities: [ExportEntity]?
    /// State of the export job
    public var state: State
    /// Additional information about export configuration state
    public var stateInfo: String?
    /// Resource group for the storage account/App Insights resource
    public var resourceGroup: String?
    /// Storage accout or Appinsights resource name
    public var resourceName: String?
    /// Export configuration
    public var exportConfiguration: ExportConfiguration?

    /// Target resource type of export configuration
    public enum ExportType: String, Codable, CaseIterable {
        case blobStorage = "BlobStorage"
        case appInsights = "AppInsights"
    }

    public enum ExportEntity: String, Codable, CaseIterable {
        case crashes
        case errors
        case attachments
        case noLogs = "no_logs"
    }

    /// State of the export job
    public enum State: String, Codable, CaseIterable {
        case enabled = "Enabled"
        case disabled = "Disabled"
        case pending = "Pending"
        case deleted = "Deleted"
        case invalid = "Invalid"
    }

    /// Export configuration
    public struct ExportConfiguration: Codable {
        /// Type of export configuration
        public var type: `Type`
        public var exportEntities: [ExportEntity]?
        /// The resource name on azure
        public var resourceName: String?
        /// The resource group name on azure
        public var resourceGroup: String?
        /// Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.
        public var isBackfill: Bool?

        /// Type of export configuration
        public enum `Type`: String, Codable, CaseIterable {
            case blobStorageConnectionString = "blob_storage_connection_string"
            case applicationInsightsInstrumentationKey = "application_insights_instrumentation_key"
            case blobStorageLinkedSubscription = "blob_storage_linked_subscription"
            case applicationInsightsLinkedSubscription = "application_insights_linked_subscription"
        }

        public enum ExportEntity: String, Codable, CaseIterable {
            case crashes
            case errors
            case attachments
            case noLogs = "no_logs"
        }

        public init(type: `Type`, exportEntities: [ExportEntity]? = nil, resourceName: String? = nil, resourceGroup: String? = nil, isBackfill: Bool? = nil) {
            self.type = type
            self.exportEntities = exportEntities
            self.resourceName = resourceName
            self.resourceGroup = resourceGroup
            self.isBackfill = isBackfill
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case exportEntities = "export_entities"
            case resourceName = "resource_name"
            case resourceGroup = "resource_group"
            case isBackfill = "backfill"
        }
    }

    public init(id: String, exportType: ExportType, creationTime: String, lastRunTime: String? = nil, exportEntities: [ExportEntity]? = nil, state: State, stateInfo: String? = nil, resourceGroup: String? = nil, resourceName: String? = nil, exportConfiguration: ExportConfiguration? = nil) {
        self.id = id
        self.exportType = exportType
        self.creationTime = creationTime
        self.lastRunTime = lastRunTime
        self.exportEntities = exportEntities
        self.state = state
        self.stateInfo = stateInfo
        self.resourceGroup = resourceGroup
        self.resourceName = resourceName
        self.exportConfiguration = exportConfiguration
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case exportType = "export_type"
        case creationTime = "creation_time"
        case lastRunTime = "last_run_time"
        case exportEntities = "export_entities"
        case state
        case stateInfo = "state_info"
        case resourceGroup = "resource_group"
        case resourceName = "resource_name"
        case exportConfiguration = "export_configuration"
    }
}

/// List of export configurations
public struct ExportConfigurationListResult: Codable {
    public var values: [Value]
    /// The total count of exports
    public var total: Int?
    public var nextLink: String?

    /// Export configuration result
    public struct Value: Codable {
        /// Export configuration id
        public var id: String
        /// Target resource type of export configuration
        public var exportType: ExportType
        /// Creation time in ISO 8601 format
        public var creationTime: String
        /// Latest time in ISO 8601 format when export completed successfully
        public var lastRunTime: String?
        public var exportEntities: [ExportEntity]?
        /// State of the export job
        public var state: State
        /// Additional information about export configuration state
        public var stateInfo: String?
        /// Resource group for the storage account/App Insights resource
        public var resourceGroup: String?
        /// Storage accout or Appinsights resource name
        public var resourceName: String?
        /// Export configuration
        public var exportConfiguration: ExportConfiguration?

        /// Target resource type of export configuration
        public enum ExportType: String, Codable, CaseIterable {
            case blobStorage = "BlobStorage"
            case appInsights = "AppInsights"
        }

        public enum ExportEntity: String, Codable, CaseIterable {
            case crashes
            case errors
            case attachments
            case noLogs = "no_logs"
        }

        /// State of the export job
        public enum State: String, Codable, CaseIterable {
            case enabled = "Enabled"
            case disabled = "Disabled"
            case pending = "Pending"
            case deleted = "Deleted"
            case invalid = "Invalid"
        }

        /// Export configuration
        public struct ExportConfiguration: Codable {
            /// Type of export configuration
            public var type: `Type`
            public var exportEntities: [ExportEntity]?
            /// The resource name on azure
            public var resourceName: String?
            /// The resource group name on azure
            public var resourceGroup: String?
            /// Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.
            public var isBackfill: Bool?

            /// Type of export configuration
            public enum `Type`: String, Codable, CaseIterable {
                case blobStorageConnectionString = "blob_storage_connection_string"
                case applicationInsightsInstrumentationKey = "application_insights_instrumentation_key"
                case blobStorageLinkedSubscription = "blob_storage_linked_subscription"
                case applicationInsightsLinkedSubscription = "application_insights_linked_subscription"
            }

            public enum ExportEntity: String, Codable, CaseIterable {
                case crashes
                case errors
                case attachments
                case noLogs = "no_logs"
            }

            public init(type: `Type`, exportEntities: [ExportEntity]? = nil, resourceName: String? = nil, resourceGroup: String? = nil, isBackfill: Bool? = nil) {
                self.type = type
                self.exportEntities = exportEntities
                self.resourceName = resourceName
                self.resourceGroup = resourceGroup
                self.isBackfill = isBackfill
            }

            private enum CodingKeys: String, CodingKey {
                case type
                case exportEntities = "export_entities"
                case resourceName = "resource_name"
                case resourceGroup = "resource_group"
                case isBackfill = "backfill"
            }
        }

        public init(id: String, exportType: ExportType, creationTime: String, lastRunTime: String? = nil, exportEntities: [ExportEntity]? = nil, state: State, stateInfo: String? = nil, resourceGroup: String? = nil, resourceName: String? = nil, exportConfiguration: ExportConfiguration? = nil) {
            self.id = id
            self.exportType = exportType
            self.creationTime = creationTime
            self.lastRunTime = lastRunTime
            self.exportEntities = exportEntities
            self.state = state
            self.stateInfo = stateInfo
            self.resourceGroup = resourceGroup
            self.resourceName = resourceName
            self.exportConfiguration = exportConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case exportType = "export_type"
            case creationTime = "creation_time"
            case lastRunTime = "last_run_time"
            case exportEntities = "export_entities"
            case state
            case stateInfo = "state_info"
            case resourceGroup = "resource_group"
            case resourceName = "resource_name"
            case exportConfiguration = "export_configuration"
        }
    }

    public init(values: [Value], total: Int? = nil, nextLink: String? = nil) {
        self.values = values
        self.total = total
        self.nextLink = nextLink
    }
}

public struct DataSubjectRightCustomerIDRequest: Codable {
    /// Customer account id (b2c identifier) / customer user id (free form text) depending on the value of the fied `type`
    public var dataSubjectIdentifier: String?
    /// Type of the customer dataSubjectIdentifier
    public var type: `Type`?

    /// Type of the customer dataSubjectIdentifier
    public enum `Type`: String, Codable, CaseIterable {
        case customerAccountID = "CustomerAccountId"
        case customerUserID = "CustomerUserId"
    }

    public init(dataSubjectIdentifier: String? = nil, type: `Type`? = nil) {
        self.dataSubjectIdentifier = dataSubjectIdentifier
        self.type = type
    }
}

public struct DataSubjectRightEmailRequest: Codable {
    /// Email used for cancel delete with x-authz-bypass headers
    public var email: String

    public init(email: String) {
        self.email = email
    }
}

public struct DataSubjectRightResponse: Codable {
    /// Unique request identifier
    public var token: String
    /// ISO 8601 format timestamp of when request was created.
    public var createdAt: Date

    public init(token: String, createdAt: Date) {
        self.token = token
        self.createdAt = createdAt
    }
}

public struct DataSubjectRightStatusResponse: Codable {
    /// Azure Storage shared access signature (SAS) URL for exported user data.
    public var sasURL: String?
    /// Whether Azure Storage shared access signature (SAS) URL has expired or not.
    public var isSasURLExpired: Bool?
    /// Status of data subject right request
    public var status: Status
    /// Explanation message of the status
    public var message: String

    /// Status of data subject right request
    public enum Status: String, Codable, CaseIterable {
        case `none` = "None"
        case created = "Created"
        case queued = "Queued"
        case inProgress = "InProgress"
        case completed = "Completed"
        case failed = "Failed"
    }

    public init(sasURL: String? = nil, isSasURLExpired: Bool? = nil, status: Status, message: String) {
        self.sasURL = sasURL
        self.isSasURLExpired = isSasURLExpired
        self.status = status
        self.message = message
    }

    private enum CodingKeys: String, CodingKey {
        case sasURL = "sasUrl"
        case isSasURLExpired = "sasUrlExpired"
        case status
        case message
    }
}

public struct DataSubjectRightUpdateStatusOperation: Codable {
    /// Request identifier of the operation
    public var requestID: String
    /// Operation status
    public var status: Status
    /// String field to be used by participant for any intermediate statuses or data they need to save
    public var participantData: String?

    /// Operation status
    public enum Status: String, Codable, CaseIterable {
        case `none` = "None"
        case created = "Created"
        case queued = "Queued"
        case inProgress = "InProgress"
        case completed = "Completed"
        case failed = "Failed"
    }

    public init(requestID: String, status: Status, participantData: String? = nil) {
        self.requestID = requestID
        self.status = status
        self.participantData = participantData
    }

    private enum CodingKeys: String, CodingKey {
        case requestID = "requestId"
        case status
        case participantData
    }
}

public struct DataSubjectRightOperation: Codable {
    /// Unique request identifier
    public var requestID: String
    /// Unique operation identifier
    public var operationID: String
    /// Request type
    public var requestType: RequestType
    /// Operation status
    public var status: Status
    /// Participant to execute the response
    public var participant: String
    /// JSON object decribing what to delete (TODO - make separate definition?)
    public var context: String
    /// Application identifier if applicable
    public var appID: String?
    /// String field to be used by participant for any intermediate statuses or data they need to save
    public var participantData: String?

    /// Request type
    public enum RequestType: String, Codable, CaseIterable {
        case unsupported = "Unsupported"
        case delete = "Delete"
        case purge = "Purge"
        case undoDelete = "UndoDelete"
        case scheduled = "Scheduled"
        case appDelete = "AppDelete"
        case appPurge = "AppPurge"
        case appUndoDelete = "AppUndoDelete"
        case export = "Export"
        case customerAccountDelete = "CustomerAccountDelete"
        case customerAccountExport = "CustomerAccountExport"
        case customerUserDelete = "CustomerUserDelete"
        case customerUserExport = "CustomerUserExport"
    }

    /// Operation status
    public enum Status: String, Codable, CaseIterable {
        case `none` = "None"
        case created = "Created"
        case queued = "Queued"
        case inProgress = "InProgress"
        case completed = "Completed"
        case failed = "Failed"
    }

    public init(requestID: String, operationID: String, requestType: RequestType, status: Status, participant: String, context: String, appID: String? = nil, participantData: String? = nil) {
        self.requestID = requestID
        self.operationID = operationID
        self.requestType = requestType
        self.status = status
        self.participant = participant
        self.context = context
        self.appID = appID
        self.participantData = participantData
    }

    private enum CodingKeys: String, CodingKey {
        case requestID = "requestId"
        case operationID = "operationId"
        case requestType
        case status
        case participant
        case context
        case appID = "appId"
        case participantData
    }
}

/// Request type
public enum RequestType: String, Codable, CaseIterable {
    case unsupported = "Unsupported"
    case delete = "Delete"
    case purge = "Purge"
    case undoDelete = "UndoDelete"
    case scheduled = "Scheduled"
    case appDelete = "AppDelete"
    case appPurge = "AppPurge"
    case appUndoDelete = "AppUndoDelete"
    case export = "Export"
    case customerAccountDelete = "CustomerAccountDelete"
    case customerAccountExport = "CustomerAccountExport"
    case customerUserDelete = "CustomerUserDelete"
    case customerUserExport = "CustomerUserExport"
}

/// Operation status
public enum OperationStatus: String, Codable, CaseIterable {
    case `none` = "None"
    case created = "Created"
    case queued = "Queued"
    case inProgress = "InProgress"
    case completed = "Completed"
    case failed = "Failed"
}

public struct DataSubjectRightQueueInfo: Codable {
    public var sasUri: URL
    public var queueName: String
    public var expiresAt: Date

    public init(sasUri: URL, queueName: String, expiresAt: Date) {
        self.sasUri = sasUri
        self.queueName = queueName
        self.expiresAt = expiresAt
    }
}

public struct DataSubjectRighBlobContainerInfo: Codable {
    public var sasUri: String
    public var blobPath: String

    public init(sasUri: String, blobPath: String) {
        self.sasUri = sasUri
        self.blobPath = blobPath
    }
}

public struct AppID: Codable {
    /// The id of the app
    public var id: String?

    public init(id: String? = nil) {
        self.id = id
    }
}

public struct DeviceConfiguration: Codable {
    /// The name of the device model and OS version
    public var name: String?
    /// The unique id of the device configuration
    public var id: String?
    /// The tier
    public var tier: Double?
    public var image: Image?
    public var model: Model?
    public var os: String?
    public var osName: String?
    public var marketShare: Double?

    public struct Image: Codable {
        public var full: String?
        public var thumb: String?

        public init(full: String? = nil, thumb: String? = nil) {
            self.full = full
            self.thumb = thumb
        }
    }

    public struct Model: Codable {
        public var name: String?
        public var manufacturer: String?
        public var model: String?
        public var platform: String?
        /// Physical device dimensions
        public var dimensions: Dimensions?
        /// Device screen resolution
        public var resolution: Resolution?
        public var releaseDate: String?
        public var formFactor: String?
        /// Physical device screen dimensions
        public var screenSize: ScreenSize?
        /// CPU data for device
        public var cpu: Cpu?
        /// Memory data for device
        public var memory: Memory?
        public var screenRotation: Double?
        public var deviceFrame: DeviceFrame?
        public var availabilityCount: Double?

        /// Physical device dimensions
        public struct Dimensions: Codable {
            public var depth: [String: AnyJSON]?
            public var height: [String: AnyJSON]?
            public var width: [String: AnyJSON]?

            public init(depth: [String: AnyJSON]? = nil, height: [String: AnyJSON]? = nil, width: [String: AnyJSON]? = nil) {
                self.depth = depth
                self.height = height
                self.width = width
            }
        }

        /// Device screen resolution
        public struct Resolution: Codable {
            public var height: String?
            public var width: String?
            public var ppi: String?

            public init(height: String? = nil, width: String? = nil, ppi: String? = nil) {
                self.height = height
                self.width = width
                self.ppi = ppi
            }
        }

        /// Physical device screen dimensions
        public struct ScreenSize: Codable {
            public var cm: String?
            public var `in`: String?

            public init(cm: String? = nil, `in`: String? = nil) {
                self.cm = cm
                self.in = `in`
            }

            private enum CodingKeys: String, CodingKey {
                case cm
                case `in` = "in"
            }
        }

        /// CPU data for device
        public struct Cpu: Codable {
            public var frequency: String?
            public var core: String?
            public var text: String?

            public init(frequency: String? = nil, core: String? = nil, text: String? = nil) {
                self.frequency = frequency
                self.core = core
                self.text = text
            }
        }

        /// Memory data for device
        public struct Memory: Codable {
            public var formattedSize: String?

            public init(formattedSize: String? = nil) {
                self.formattedSize = formattedSize
            }
        }

        public struct DeviceFrame: Codable {
            public var grid: Grid?
            public var full: Full?

            public struct Grid: Codable {
                public var width: Double?
                public var height: Double?
                public var frameURL: String?
                public var screen: [Double]?

                public init(width: Double? = nil, height: Double? = nil, frameURL: String? = nil, screen: [Double]? = nil) {
                    self.width = width
                    self.height = height
                    self.frameURL = frameURL
                    self.screen = screen
                }

                private enum CodingKeys: String, CodingKey {
                    case width
                    case height
                    case frameURL = "frameUrl"
                    case screen
                }
            }

            public struct Full: Codable {
                public var width: Double?
                public var height: Double?
                public var frameURL: String?
                public var screen: [Double]?

                public init(width: Double? = nil, height: Double? = nil, frameURL: String? = nil, screen: [Double]? = nil) {
                    self.width = width
                    self.height = height
                    self.frameURL = frameURL
                    self.screen = screen
                }

                private enum CodingKeys: String, CodingKey {
                    case width
                    case height
                    case frameURL = "frameUrl"
                    case screen
                }
            }

            public init(grid: Grid? = nil, full: Full? = nil) {
                self.grid = grid
                self.full = full
            }
        }

        public init(name: String? = nil, manufacturer: String? = nil, model: String? = nil, platform: String? = nil, dimensions: Dimensions? = nil, resolution: Resolution? = nil, releaseDate: String? = nil, formFactor: String? = nil, screenSize: ScreenSize? = nil, cpu: Cpu? = nil, memory: Memory? = nil, screenRotation: Double? = nil, deviceFrame: DeviceFrame? = nil, availabilityCount: Double? = nil) {
            self.name = name
            self.manufacturer = manufacturer
            self.model = model
            self.platform = platform
            self.dimensions = dimensions
            self.resolution = resolution
            self.releaseDate = releaseDate
            self.formFactor = formFactor
            self.screenSize = screenSize
            self.cpu = cpu
            self.memory = memory
            self.screenRotation = screenRotation
            self.deviceFrame = deviceFrame
            self.availabilityCount = availabilityCount
        }
    }

    public init(name: String? = nil, id: String? = nil, tier: Double? = nil, image: Image? = nil, model: Model? = nil, os: String? = nil, osName: String? = nil, marketShare: Double? = nil) {
        self.name = name
        self.id = id
        self.tier = tier
        self.image = image
        self.model = model
        self.os = os
        self.osName = osName
        self.marketShare = marketShare
    }
}

public struct DeviceSetConfiguration: Codable {
    /// The unique id of the device configuration
    public var id: String?
    public var image: Image?
    public var model: Model?
    public var os: String?
    public var osName: String?

    public struct Image: Codable {
        public var thumb: String?

        public init(thumb: String? = nil) {
            self.thumb = thumb
        }
    }

    public struct Model: Codable {
        public var name: String?
        public var manufacturer: String?
        public var releaseDate: String?
        public var formFactor: String?

        public init(name: String? = nil, manufacturer: String? = nil, releaseDate: String? = nil, formFactor: String? = nil) {
            self.name = name
            self.manufacturer = manufacturer
            self.releaseDate = releaseDate
            self.formFactor = formFactor
        }
    }

    public init(id: String? = nil, image: Image? = nil, model: Model? = nil, os: String? = nil, osName: String? = nil) {
        self.id = id
        self.image = image
        self.model = model
        self.os = os
        self.osName = osName
    }
}

public struct DeviceModel: Codable {
    public var name: String?
    public var manufacturer: String?
    public var model: String?
    public var platform: String?
    /// Physical device dimensions
    public var dimensions: Dimensions?
    /// Device screen resolution
    public var resolution: Resolution?
    public var releaseDate: String?
    public var formFactor: String?
    /// Physical device screen dimensions
    public var screenSize: ScreenSize?
    /// CPU data for device
    public var cpu: Cpu?
    /// Memory data for device
    public var memory: Memory?
    public var screenRotation: Double?
    public var deviceFrame: DeviceFrame?
    public var availabilityCount: Double?

    /// Physical device dimensions
    public struct Dimensions: Codable {
        public var depth: [String: AnyJSON]?
        public var height: [String: AnyJSON]?
        public var width: [String: AnyJSON]?

        public init(depth: [String: AnyJSON]? = nil, height: [String: AnyJSON]? = nil, width: [String: AnyJSON]? = nil) {
            self.depth = depth
            self.height = height
            self.width = width
        }
    }

    /// Device screen resolution
    public struct Resolution: Codable {
        public var height: String?
        public var width: String?
        public var ppi: String?

        public init(height: String? = nil, width: String? = nil, ppi: String? = nil) {
            self.height = height
            self.width = width
            self.ppi = ppi
        }
    }

    /// Physical device screen dimensions
    public struct ScreenSize: Codable {
        public var cm: String?
        public var `in`: String?

        public init(cm: String? = nil, `in`: String? = nil) {
            self.cm = cm
            self.in = `in`
        }

        private enum CodingKeys: String, CodingKey {
            case cm
            case `in` = "in"
        }
    }

    /// CPU data for device
    public struct Cpu: Codable {
        public var frequency: String?
        public var core: String?
        public var text: String?

        public init(frequency: String? = nil, core: String? = nil, text: String? = nil) {
            self.frequency = frequency
            self.core = core
            self.text = text
        }
    }

    /// Memory data for device
    public struct Memory: Codable {
        public var formattedSize: String?

        public init(formattedSize: String? = nil) {
            self.formattedSize = formattedSize
        }
    }

    public struct DeviceFrame: Codable {
        public var grid: Grid?
        public var full: Full?

        public struct Grid: Codable {
            public var width: Double?
            public var height: Double?
            public var frameURL: String?
            public var screen: [Double]?

            public init(width: Double? = nil, height: Double? = nil, frameURL: String? = nil, screen: [Double]? = nil) {
                self.width = width
                self.height = height
                self.frameURL = frameURL
                self.screen = screen
            }

            private enum CodingKeys: String, CodingKey {
                case width
                case height
                case frameURL = "frameUrl"
                case screen
            }
        }

        public struct Full: Codable {
            public var width: Double?
            public var height: Double?
            public var frameURL: String?
            public var screen: [Double]?

            public init(width: Double? = nil, height: Double? = nil, frameURL: String? = nil, screen: [Double]? = nil) {
                self.width = width
                self.height = height
                self.frameURL = frameURL
                self.screen = screen
            }

            private enum CodingKeys: String, CodingKey {
                case width
                case height
                case frameURL = "frameUrl"
                case screen
            }
        }

        public init(grid: Grid? = nil, full: Full? = nil) {
            self.grid = grid
            self.full = full
        }
    }

    public init(name: String? = nil, manufacturer: String? = nil, model: String? = nil, platform: String? = nil, dimensions: Dimensions? = nil, resolution: Resolution? = nil, releaseDate: String? = nil, formFactor: String? = nil, screenSize: ScreenSize? = nil, cpu: Cpu? = nil, memory: Memory? = nil, screenRotation: Double? = nil, deviceFrame: DeviceFrame? = nil, availabilityCount: Double? = nil) {
        self.name = name
        self.manufacturer = manufacturer
        self.model = model
        self.platform = platform
        self.dimensions = dimensions
        self.resolution = resolution
        self.releaseDate = releaseDate
        self.formFactor = formFactor
        self.screenSize = screenSize
        self.cpu = cpu
        self.memory = memory
        self.screenRotation = screenRotation
        self.deviceFrame = deviceFrame
        self.availabilityCount = availabilityCount
    }
}

public struct DeviceSetModel: Codable {
    public var name: String?
    public var manufacturer: String?
    public var releaseDate: String?
    public var formFactor: String?

    public init(name: String? = nil, manufacturer: String? = nil, releaseDate: String? = nil, formFactor: String? = nil) {
        self.name = name
        self.manufacturer = manufacturer
        self.releaseDate = releaseDate
        self.formFactor = formFactor
    }
}

/// Physical device screen dimensions
public struct DeviceScreenSize: Codable {
    public var cm: String?
    public var `in`: String?

    public init(cm: String? = nil, `in`: String? = nil) {
        self.cm = cm
        self.in = `in`
    }

    private enum CodingKeys: String, CodingKey {
        case cm
        case `in` = "in"
    }
}

/// Device screen resolution
public struct DeviceResolution: Codable {
    public var height: String?
    public var width: String?
    public var ppi: String?

    public init(height: String? = nil, width: String? = nil, ppi: String? = nil) {
        self.height = height
        self.width = width
        self.ppi = ppi
    }
}

/// Physical device dimensions
public struct DeviceDimensions: Codable {
    public var depth: [String: AnyJSON]?
    public var height: [String: AnyJSON]?
    public var width: [String: AnyJSON]?

    public init(depth: [String: AnyJSON]? = nil, height: [String: AnyJSON]? = nil, width: [String: AnyJSON]? = nil) {
        self.depth = depth
        self.height = height
        self.width = width
    }
}

/// CPU data for device
public struct DeviceCpu: Codable {
    public var frequency: String?
    public var core: String?
    public var text: String?

    public init(frequency: String? = nil, core: String? = nil, text: String? = nil) {
        self.frequency = frequency
        self.core = core
        self.text = text
    }
}

/// Memory data for device
public struct DeviceMemory: Codable {
    public var formattedSize: String?

    public init(formattedSize: String? = nil) {
        self.formattedSize = formattedSize
    }
}

public struct DeviceFrame: Codable {
    public var grid: Grid?
    public var full: Full?

    public struct Grid: Codable {
        public var width: Double?
        public var height: Double?
        public var frameURL: String?
        public var screen: [Double]?

        public init(width: Double? = nil, height: Double? = nil, frameURL: String? = nil, screen: [Double]? = nil) {
            self.width = width
            self.height = height
            self.frameURL = frameURL
            self.screen = screen
        }

        private enum CodingKeys: String, CodingKey {
            case width
            case height
            case frameURL = "frameUrl"
            case screen
        }
    }

    public struct Full: Codable {
        public var width: Double?
        public var height: Double?
        public var frameURL: String?
        public var screen: [Double]?

        public init(width: Double? = nil, height: Double? = nil, frameURL: String? = nil, screen: [Double]? = nil) {
            self.width = width
            self.height = height
            self.frameURL = frameURL
            self.screen = screen
        }

        private enum CodingKeys: String, CodingKey {
            case width
            case height
            case frameURL = "frameUrl"
            case screen
        }
    }

    public init(grid: Grid? = nil, full: Full? = nil) {
        self.grid = grid
        self.full = full
    }
}

public struct DeviceFrameDefinition: Codable {
    public var width: Double?
    public var height: Double?
    public var frameURL: String?
    public var screen: [Double]?

    public init(width: Double? = nil, height: Double? = nil, frameURL: String? = nil, screen: [Double]? = nil) {
        self.width = width
        self.height = height
        self.frameURL = frameURL
        self.screen = screen
    }

    private enum CodingKeys: String, CodingKey {
        case width
        case height
        case frameURL = "frameUrl"
        case screen
    }
}

/// Summary single test run on Xamarin Test Cloud
public struct TestRun: Codable {
    /// The unique id of the test upload
    public var id: String?
    /// The date and time the test was uploaded
    public var date: String?
    /// The compiled version of the app binary
    public var appVersion: String?
    /// The name of the test series with which this test upload is associated
    public var testSeries: String?
    /// The device platform targeted by the test. Possible values are 'ios' or 'android'
    public var platform: String?
    /// The current status of the test run, in relation to the various phases
    public var runStatus: String?
    /// The passed/failed state
    public var resultStatus: String?
    /// Deprecated. Use runStatus instead.
    public var state: String?
    /// Deprecated. Use resultStatus instead.
    public var status: String?
    /// Human readable explanation of the current test status
    public var description: String?
    /// Test Run Statistics
    ///
    /// Summary single test run on Xamarin Test Cloud
    public var stats: Stats?
    /// The name of the test framework used to run this test
    public var testType: String?

    /// Test Run Statistics
    ///
    /// Summary single test run on Xamarin Test Cloud
    public struct Stats: Codable {
        /// Number of devices running the test
        public var devices: Double?
        /// Number of finished devices
        public var devicesFinished: Double?
        /// Number of failed devices
        public var devicesFailed: Double?
        /// Number of tests in total
        public var total: Double?
        /// Number of passed tests
        public var passed: Double?
        /// Number of failed tests
        public var failed: Double?
        /// Number of skipped tests
        public var skipped: Double?
        /// The max amount of MB used during the test run
        public var peakMemory: Double?
        /// The number of minutes of device time the test has been runnign
        public var totalDeviceMinutes: Double?

        public init(devices: Double? = nil, devicesFinished: Double? = nil, devicesFailed: Double? = nil, total: Double? = nil, passed: Double? = nil, failed: Double? = nil, skipped: Double? = nil, peakMemory: Double? = nil, totalDeviceMinutes: Double? = nil) {
            self.devices = devices
            self.devicesFinished = devicesFinished
            self.devicesFailed = devicesFailed
            self.total = total
            self.passed = passed
            self.failed = failed
            self.skipped = skipped
            self.peakMemory = peakMemory
            self.totalDeviceMinutes = totalDeviceMinutes
        }
    }

    public init(id: String? = nil, date: String? = nil, appVersion: String? = nil, testSeries: String? = nil, platform: String? = nil, runStatus: String? = nil, resultStatus: String? = nil, state: String? = nil, status: String? = nil, description: String? = nil, stats: Stats? = nil, testType: String? = nil) {
        self.id = id
        self.date = date
        self.appVersion = appVersion
        self.testSeries = testSeries
        self.platform = platform
        self.runStatus = runStatus
        self.resultStatus = resultStatus
        self.state = state
        self.status = status
        self.description = description
        self.stats = stats
        self.testType = testType
    }
}

/// Summary single test run on Xamarin Test Cloud
public struct TestRunStatistics: Codable {
    /// Number of devices running the test
    public var devices: Double?
    /// Number of finished devices
    public var devicesFinished: Double?
    /// Number of failed devices
    public var devicesFailed: Double?
    /// Number of tests in total
    public var total: Double?
    /// Number of passed tests
    public var passed: Double?
    /// Number of failed tests
    public var failed: Double?
    /// Number of skipped tests
    public var skipped: Double?
    /// The max amount of MB used during the test run
    public var peakMemory: Double?
    /// The number of minutes of device time the test has been runnign
    public var totalDeviceMinutes: Double?

    public init(devices: Double? = nil, devicesFinished: Double? = nil, devicesFailed: Double? = nil, total: Double? = nil, passed: Double? = nil, failed: Double? = nil, skipped: Double? = nil, peakMemory: Double? = nil, totalDeviceMinutes: Double? = nil) {
        self.devices = devices
        self.devicesFinished = devicesFinished
        self.devicesFailed = devicesFailed
        self.total = total
        self.passed = passed
        self.failed = failed
        self.skipped = skipped
        self.peakMemory = peakMemory
        self.totalDeviceMinutes = totalDeviceMinutes
    }
}

/// Summary of a single test series
public struct TestSeries: Codable {
    /// Unique, human-readable identifier of the test series
    public var slug: String
    /// Name of the test series
    public var name: String
    /// Date of the latest test run that used this test series
    public var mostRecentActivity: String?
    /// Most recent test runs
    public var testRuns: [TestRun]?

    /// Test Run Summary
    ///
    /// Most important information about a test run.
    public struct TestRun: Codable {
        /// Date of the test run.
        public var date: String?
        /// Human-readable status of the test run.
        public var statusDescription: String?
        /// Number of failed tests
        public var failed: Double?
        /// Number of passed tests
        public var passed: Double?
        /// Tells whether the test run has completed
        public var isCompleted: Bool?

        public init(date: String? = nil, statusDescription: String? = nil, failed: Double? = nil, passed: Double? = nil, isCompleted: Bool? = nil) {
            self.date = date
            self.statusDescription = statusDescription
            self.failed = failed
            self.passed = passed
            self.isCompleted = isCompleted
        }

        private enum CodingKeys: String, CodingKey {
            case date
            case statusDescription
            case failed
            case passed
            case isCompleted = "completed"
        }
    }

    public init(slug: String, name: String, mostRecentActivity: String? = nil, testRuns: [TestRun]? = nil) {
        self.slug = slug
        self.name = name
        self.mostRecentActivity = mostRecentActivity
        self.testRuns = testRuns
    }
}

/// Name of the test series
public struct TestSeriesName: Codable {
    /// Name of the new test series
    public var name: String

    public init(name: String) {
        self.name = name
    }
}

/// Most important information about a test run.
public struct TestRunSummary: Codable {
    /// Date of the test run.
    public var date: String?
    /// Human-readable status of the test run.
    public var statusDescription: String?
    /// Number of failed tests
    public var failed: Double?
    /// Number of passed tests
    public var passed: Double?
    /// Tells whether the test run has completed
    public var isCompleted: Bool?

    public init(date: String? = nil, statusDescription: String? = nil, failed: Double? = nil, passed: Double? = nil, isCompleted: Bool? = nil) {
        self.date = date
        self.statusDescription = statusDescription
        self.failed = failed
        self.passed = passed
        self.isCompleted = isCompleted
    }

    private enum CodingKeys: String, CodingKey {
        case date
        case statusDescription
        case failed
        case passed
        case isCompleted = "completed"
    }
}

/// A list of device IDs
public struct DeviceList: Codable {
    public var devices: [String]

    public init(devices: [String]) {
        self.devices = devices
    }
}

/// Short ID for a list of device IDs
public struct DeviceSelection: Codable {
    /// Identifier of the device selection
    public var shortID: String

    public init(shortID: String) {
        self.shortID = shortID
    }

    private enum CodingKeys: String, CodingKey {
        case shortID = "shortId"
    }
}

/// Device Set update information
///
/// The name of the device set and the list of device IDs
public struct DeviceSetUpdate: Codable {
    /// List of device IDs
    public var devices: [String]
    /// The name of the device set
    public var name: String

    public init(devices: [String], name: String) {
        self.devices = devices
        self.name = name
    }
}

/// The name and devices of the device set
public struct DeviceSet: Codable {
    /// Identifier of the device set
    public var id: String
    /// The number of manufacturers in the device set's device selection
    public var manufacturerCount: Double?
    /// Name of the device set
    public var name: String
    /// Slug of the device set
    public var slug: String?
    /// Device Set Owner
    ///
    /// The owner of a device set
    public var owner: Owner
    /// The number of os versions in the device set's device selection
    public var osVersionCount: Double?
    public var deviceConfigurations: [DeviceConfiguration]

    /// Device Set Owner
    ///
    /// The owner of a device set
    public struct Owner: Codable {
        /// Type of account
        public var type: String
        /// Account ID
        public var id: String
        /// Display name of the account
        public var displayName: String?
        /// Name of the account
        public var name: String

        public init(type: String, id: String, displayName: String? = nil, name: String) {
            self.type = type
            self.id = id
            self.displayName = displayName
            self.name = name
        }
    }

    public struct DeviceConfiguration: Codable {
        /// The unique id of the device configuration
        public var id: String?
        public var image: Image?
        public var model: Model?
        public var os: String?
        public var osName: String?

        public struct Image: Codable {
            public var thumb: String?

            public init(thumb: String? = nil) {
                self.thumb = thumb
            }
        }

        public struct Model: Codable {
            public var name: String?
            public var manufacturer: String?
            public var releaseDate: String?
            public var formFactor: String?

            public init(name: String? = nil, manufacturer: String? = nil, releaseDate: String? = nil, formFactor: String? = nil) {
                self.name = name
                self.manufacturer = manufacturer
                self.releaseDate = releaseDate
                self.formFactor = formFactor
            }
        }

        public init(id: String? = nil, image: Image? = nil, model: Model? = nil, os: String? = nil, osName: String? = nil) {
            self.id = id
            self.image = image
            self.model = model
            self.os = os
            self.osName = osName
        }
    }

    public init(id: String, manufacturerCount: Double? = nil, name: String, slug: String? = nil, owner: Owner, osVersionCount: Double? = nil, deviceConfigurations: [DeviceConfiguration]) {
        self.id = id
        self.manufacturerCount = manufacturerCount
        self.name = name
        self.slug = slug
        self.owner = owner
        self.osVersionCount = osVersionCount
        self.deviceConfigurations = deviceConfigurations
    }
}

/// The owner of a device set
public struct DeviceSetOwner: Codable {
    /// Type of account
    public var type: String
    /// Account ID
    public var id: String
    /// Display name of the account
    public var displayName: String?
    /// Name of the account
    public var name: String

    public init(type: String, id: String, displayName: String? = nil, name: String) {
        self.type = type
        self.id = id
        self.displayName = displayName
        self.name = name
    }
}

/// Subscription information
public struct Subscription: Codable {
    /// The date the subscription began
    public var startsAt: String?
    /// The date the subscription will end or ended
    public var endsAt: String?
    /// The number of days left in the subscription
    public var daysLeft: Double?
    /// Subscription Tier
    public var tier: Tier?
    /// Is the subscription currently active?
    public var isActive: Bool?
    /// Id of the subscription
    public var id: String?
    /// Customer limits on concurrent devices
    public var concurrentDevicesLimit: Int?
    /// Current device concurrency utilization
    public var runningDevices: Int?

    /// Subscription Tier
    public struct Tier: Codable {
        /// The name of the tier
        public var name: String?

        public init(name: String? = nil) {
            self.name = name
        }
    }

    public init(startsAt: String? = nil, endsAt: String? = nil, daysLeft: Double? = nil, tier: Tier? = nil, isActive: Bool? = nil, id: String? = nil, concurrentDevicesLimit: Int? = nil, runningDevices: Int? = nil) {
        self.startsAt = startsAt
        self.endsAt = endsAt
        self.daysLeft = daysLeft
        self.tier = tier
        self.isActive = isActive
        self.id = id
        self.concurrentDevicesLimit = concurrentDevicesLimit
        self.runningDevices = runningDevices
    }

    private enum CodingKeys: String, CodingKey {
        case startsAt
        case endsAt
        case daysLeft
        case tier
        case isActive = "active"
        case id
        case concurrentDevicesLimit
        case runningDevices
    }
}

/// Subscription Tier
public struct Tier: Codable {
    /// The name of the tier
    public var name: String?

    public init(name: String? = nil) {
        self.name = name
    }
}

public struct TestReport: Codable {
    public var appUploadID: String
    public var date: String
    public var testType: String
    public var platform: String
    public var stats: Stats
    public var id: String
    public var schemaVersion: Double
    public var revision: Double
    public var features: [Feature]
    public var finishedDeviceSnapshots: [String]
    public var deviceLogs: [DeviceLog]
    public var dateFinished: String
    public var errorMessage: String?
    public var snapshotFatalErrors: [SnapshotFatalError]?

    public struct Stats: Codable {
        public var os: Double
        public var devices: Double
        public var filesize: Double
        public var totalDeviceMinutes: Double
        public var devicesNotRunned: Double
        public var failed: Double
        public var skipped: Double
        public var passed: Double
        public var total: Double
        public var devicesFinished: Double
        public var devicesFailed: Double
        public var devicesSkipped: Double
        public var stepCount: Double
        public var artifacts: [String: String]?

        public init(os: Double, devices: Double, filesize: Double, totalDeviceMinutes: Double, devicesNotRunned: Double, failed: Double, skipped: Double, passed: Double, total: Double, devicesFinished: Double, devicesFailed: Double, devicesSkipped: Double, stepCount: Double, artifacts: [String: String]? = nil) {
            self.os = os
            self.devices = devices
            self.filesize = filesize
            self.totalDeviceMinutes = totalDeviceMinutes
            self.devicesNotRunned = devicesNotRunned
            self.failed = failed
            self.skipped = skipped
            self.passed = passed
            self.total = total
            self.devicesFinished = devicesFinished
            self.devicesFailed = devicesFailed
            self.devicesSkipped = devicesSkipped
            self.stepCount = stepCount
            self.artifacts = artifacts
        }

        private enum CodingKeys: String, CodingKey {
            case os
            case devices
            case filesize
            case totalDeviceMinutes
            case devicesNotRunned = "devices_not_runned"
            case failed
            case skipped
            case passed
            case total
            case devicesFinished = "devices_finished"
            case devicesFailed = "devices_failed"
            case devicesSkipped = "devices_skipped"
            case stepCount = "step_count"
            case artifacts
        }
    }

    public struct Feature: Codable {
        public var name: String?
        public var tests: [Test]?
        public var failed: Double?
        public var skipped: Double?
        public var peakMemory: Double?
        public var peakDuration: Double?

        public struct Test: Codable {
            public var testName: String?
            public var runs: [Run]?
            public var peakMemory: Double?
            public var peakDuration: Double?

            public struct Run: Codable {
                public var number: Double?
                public var steps: [Step]?
                public var failed: Double?
                public var skipped: Double?
                public var reportURL: String?
                public var id: String?

                public struct Step: Codable {
                    public var stepName: String?
                    public var id: String?
                    public var stepExecutions: [StepExecution]?
                    public var failed: Double?
                    public var skipped: Double?
                    public var stepReportURL: String?

                    public struct StepExecution: Codable {
                        public var deviceSnapshotID: String?
                        public var status: String?
                        public var timestamp: Double?

                        public init(deviceSnapshotID: String? = nil, status: String? = nil, timestamp: Double? = nil) {
                            self.deviceSnapshotID = deviceSnapshotID
                            self.status = status
                            self.timestamp = timestamp
                        }

                        private enum CodingKeys: String, CodingKey {
                            case deviceSnapshotID = "device_snapshot_id"
                            case status
                            case timestamp
                        }
                    }

                    public init(stepName: String? = nil, id: String? = nil, stepExecutions: [StepExecution]? = nil, failed: Double? = nil, skipped: Double? = nil, stepReportURL: String? = nil) {
                        self.stepName = stepName
                        self.id = id
                        self.stepExecutions = stepExecutions
                        self.failed = failed
                        self.skipped = skipped
                        self.stepReportURL = stepReportURL
                    }

                    private enum CodingKeys: String, CodingKey {
                        case stepName
                        case id
                        case stepExecutions
                        case failed
                        case skipped
                        case stepReportURL = "step_report_url"
                    }
                }

                public init(number: Double? = nil, steps: [Step]? = nil, failed: Double? = nil, skipped: Double? = nil, reportURL: String? = nil, id: String? = nil) {
                    self.number = number
                    self.steps = steps
                    self.failed = failed
                    self.skipped = skipped
                    self.reportURL = reportURL
                    self.id = id
                }

                private enum CodingKeys: String, CodingKey {
                    case number
                    case steps
                    case failed
                    case skipped
                    case reportURL = "report_url"
                    case id
                }
            }

            public init(testName: String? = nil, runs: [Run]? = nil, peakMemory: Double? = nil, peakDuration: Double? = nil) {
                self.testName = testName
                self.runs = runs
                self.peakMemory = peakMemory
                self.peakDuration = peakDuration
            }
        }

        public init(name: String? = nil, tests: [Test]? = nil, failed: Double? = nil, skipped: Double? = nil, peakMemory: Double? = nil, peakDuration: Double? = nil) {
            self.name = name
            self.tests = tests
            self.failed = failed
            self.skipped = skipped
            self.peakMemory = peakMemory
            self.peakDuration = peakDuration
        }
    }

    public struct DeviceLog: Codable {
        public var deviceSnapshotID: String?
        public var deviceLog: String?
        public var testLog: String?
        public var appiumLog: String?

        public init(deviceSnapshotID: String? = nil, deviceLog: String? = nil, testLog: String? = nil, appiumLog: String? = nil) {
            self.deviceSnapshotID = deviceSnapshotID
            self.deviceLog = deviceLog
            self.testLog = testLog
            self.appiumLog = appiumLog
        }

        private enum CodingKeys: String, CodingKey {
            case deviceSnapshotID = "device_snapshot_id"
            case deviceLog = "device_log"
            case testLog = "test_log"
            case appiumLog = "appium_log"
        }
    }

    public struct SnapshotFatalError: Codable {
        public var deviceSnapshotID: String?
        public var errorMessage: String?
        public var errorTitle: String?

        public init(deviceSnapshotID: String? = nil, errorMessage: String? = nil, errorTitle: String? = nil) {
            self.deviceSnapshotID = deviceSnapshotID
            self.errorMessage = errorMessage
            self.errorTitle = errorTitle
        }

        private enum CodingKeys: String, CodingKey {
            case deviceSnapshotID = "device_snapshot_id"
            case errorMessage = "error_message"
            case errorTitle = "error_title"
        }
    }

    public init(appUploadID: String, date: String, testType: String, platform: String, stats: Stats, id: String, schemaVersion: Double, revision: Double, features: [Feature], finishedDeviceSnapshots: [String], deviceLogs: [DeviceLog], dateFinished: String, errorMessage: String? = nil, snapshotFatalErrors: [SnapshotFatalError]? = nil) {
        self.appUploadID = appUploadID
        self.date = date
        self.testType = testType
        self.platform = platform
        self.stats = stats
        self.id = id
        self.schemaVersion = schemaVersion
        self.revision = revision
        self.features = features
        self.finishedDeviceSnapshots = finishedDeviceSnapshots
        self.deviceLogs = deviceLogs
        self.dateFinished = dateFinished
        self.errorMessage = errorMessage
        self.snapshotFatalErrors = snapshotFatalErrors
    }

    private enum CodingKeys: String, CodingKey {
        case appUploadID = "app_upload_id"
        case date
        case testType
        case platform
        case stats
        case id
        case schemaVersion = "schema_version"
        case revision
        case features
        case finishedDeviceSnapshots = "finished_device_snapshots"
        case deviceLogs = "device_logs"
        case dateFinished = "date_finished"
        case errorMessage
        case snapshotFatalErrors = "snapshot_fatal_errors"
    }
}

public struct StepReport: Codable {
    public var finishedSnapshots: [String]
    public var deviceScreenshots: [DeviceScreenshot]

    public struct DeviceScreenshot: Codable {
        public var id: String?
        public var deviceSnapshotID: String?
        public var stacktrace: [String]?
        public var crashData: [String]?
        public var status: String?
        public var title: String?
        public var screenshot: Screenshot?
        public var logFile: String?
        public var appiumLogFile: String?
        public var rawCrashData: [String]?

        public struct Screenshot: Codable {
            public var urls: URLs
            public var rotation: Double
            public var isLandscape: Bool

            public struct URLs: Codable {
                public var original: String
                public var small: String
                public var medium: String
                public var large: String

                public init(original: String, small: String, medium: String, large: String) {
                    self.original = original
                    self.small = small
                    self.medium = medium
                    self.large = large
                }
            }

            public init(urls: URLs, rotation: Double, isLandscape: Bool) {
                self.urls = urls
                self.rotation = rotation
                self.isLandscape = isLandscape
            }

            private enum CodingKeys: String, CodingKey {
                case urls
                case rotation
                case isLandscape = "landscape"
            }
        }

        public init(id: String? = nil, deviceSnapshotID: String? = nil, stacktrace: [String]? = nil, crashData: [String]? = nil, status: String? = nil, title: String? = nil, screenshot: Screenshot? = nil, logFile: String? = nil, appiumLogFile: String? = nil, rawCrashData: [String]? = nil) {
            self.id = id
            self.deviceSnapshotID = deviceSnapshotID
            self.stacktrace = stacktrace
            self.crashData = crashData
            self.status = status
            self.title = title
            self.screenshot = screenshot
            self.logFile = logFile
            self.appiumLogFile = appiumLogFile
            self.rawCrashData = rawCrashData
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case deviceSnapshotID = "device_snapshot_id"
            case stacktrace
            case crashData = "crash_data"
            case status
            case title
            case screenshot
            case logFile = "log_file"
            case appiumLogFile = "appium_log_file"
            case rawCrashData = "raw_crash_data"
        }
    }

    public init(finishedSnapshots: [String], deviceScreenshots: [DeviceScreenshot]) {
        self.finishedSnapshots = finishedSnapshots
        self.deviceScreenshots = deviceScreenshots
    }
}

/// Details of a failed operation
public struct TestCloudErrorDetails: Codable {
    /// Status of the operation
    public var status: String
    /// Human-readable message that describes the error
    public var message: String

    public init(status: String, message: String) {
        self.status = status
        self.message = message
    }
}

/// Test Cloud File Hash
///
/// Hash, type, path and byte range of a file that is required in test run
public struct TestCloudFileHashDeprecated: Codable {
    /// Type of the file
    public var fileType: FileType
    /// SHA256 hash of the file
    public var checksum: String
    /// Relative path of the file
    public var relativePath: String
    /// Range of bytes required to verify ownership of the file
    public var byteRange: String?

    /// Type of the file
    public enum FileType: String, Codable, CaseIterable {
        case dsymFile = "dsym-file"
        case appFile = "app-file"
        case testFile = "test-file"
    }

    public init(fileType: FileType, checksum: String, relativePath: String, byteRange: String? = nil) {
        self.fileType = fileType
        self.checksum = checksum
        self.relativePath = relativePath
        self.byteRange = byteRange
    }

    private enum CodingKeys: String, CodingKey {
        case fileType = "file_type"
        case checksum
        case relativePath = "relative_path"
        case byteRange = "byte_range"
    }
}

/// Hash, type, path and byte range of a file that is required in test run
public struct TestCloudFileHash: Codable {
    /// Type of the file
    public var fileType: FileType
    /// SHA256 hash of the file
    public var checksum: String
    /// Relative path of the file
    public var relativePath: String

    /// Type of the file
    public enum FileType: String, Codable, CaseIterable {
        case dsymFile = "dsym-file"
        case appFile = "app-file"
        case testFile = "test-file"
    }

    public init(fileType: FileType, checksum: String, relativePath: String) {
        self.fileType = fileType
        self.checksum = checksum
        self.relativePath = relativePath
    }
}

/// Response message for single uploaded file hash
public struct TestCloudFileHashResponse: Codable {
    /// Type of the file
    public var fileType: FileType
    /// SHA256 hash of the file
    public var checksum: String
    /// Relative path of the file
    public var relativePath: String?
    /// Test Cloud Hash Upload Status
    ///
    /// Status of the upload
    public var uploadStatus: UploadStatus

    /// Type of the file
    public enum FileType: String, Codable, CaseIterable {
        case dsymFile = "dsym-file"
        case appFile = "app-file"
        case testFile = "test-file"
    }

    /// Test Cloud Hash Upload Status
    ///
    /// Status of the upload
    public struct UploadStatus: Codable {
        /// HTTP status code that represent result of upload
        public var statusCode: Double
        /// URI that should be used to make POST request if file with given hash doesn't exist. This is set when status_code is equal to 412
        public var location: String?

        public init(statusCode: Double, location: String? = nil) {
            self.statusCode = statusCode
            self.location = location
        }
    }

    public init(fileType: FileType, checksum: String, relativePath: String? = nil, uploadStatus: UploadStatus) {
        self.fileType = fileType
        self.checksum = checksum
        self.relativePath = relativePath
        self.uploadStatus = uploadStatus
    }
}

/// Result of uploading a single file hash
public struct TestCloudHashUploadStatus: Codable {
    /// HTTP status code that represent result of upload
    public var statusCode: Double
    /// URI that should be used to make POST request if file with given hash doesn't exist. This is set when status_code is equal to 412
    public var location: String?

    public init(statusCode: Double, location: String? = nil) {
        self.statusCode = statusCode
        self.location = location
    }
}

/// Options required to start the test run
public struct TestCloudStartTestRunOptions: Codable {
    /// Test framework used by tests.
    public var testFramework: String
    /// Device selection string.
    public var deviceSelection: String
    /// Language that should be used to run tests.
    public var language: String?
    /// Locale that should be used to run tests.
    public var locale: String?
    /// Name of the test series.
    public var testSeries: String?
    /// A JSON dictionary with additional test parameters
    public var testParameters: [String: AnyJSON]?

    public init(testFramework: String, deviceSelection: String, language: String? = nil, locale: String? = nil, testSeries: String? = nil, testParameters: [String: AnyJSON]? = nil) {
        self.testFramework = testFramework
        self.deviceSelection = deviceSelection
        self.language = language
        self.locale = locale
        self.testSeries = testSeries
        self.testParameters = testParameters
    }

    private enum CodingKeys: String, CodingKey {
        case testFramework = "test_framework"
        case deviceSelection = "device_selection"
        case language
        case locale
        case testSeries = "test_series"
        case testParameters = "test_parameters"
    }
}

/// Test Cloud Test Run Start Result
///
/// Result of starting a test run
public struct TestCloudStartTestRunResult: Codable {
    /// List with names of accepted devices
    public var acceptedDevices: [String]?
    /// List with names and descriptions of rejected devices
    public var rejectedDevices: [String]?

    public init(acceptedDevices: [String]? = nil, rejectedDevices: [String]? = nil) {
        self.acceptedDevices = acceptedDevices
        self.rejectedDevices = rejectedDevices
    }

    private enum CodingKeys: String, CodingKey {
        case acceptedDevices = "accepted_devices"
        case rejectedDevices = "rejected_devices"
    }
}

/// Current status of a test run
public struct TestRunState: Codable {
    /// Multi-line message that describes the status
    public var message: [String]?
    /// Time (in seconds) that the client should wait for before checking the status again
    public var waitTime: Int?
    /// The exit code that the client should use when exiting. Used for indicating status to the caller of the client.
    /// 0: test run completes with no failing tests
    /// 1: test run completes with at least one failing test
    /// 2: test run failed to complete. Status for test run is unknown
    public var exitCode: Int?

    public init(message: [String]? = nil, waitTime: Int? = nil, exitCode: Int? = nil) {
        self.message = message
        self.waitTime = waitTime
        self.exitCode = exitCode
    }

    private enum CodingKeys: String, CodingKey {
        case message
        case waitTime = "wait_time"
        case exitCode = "exit_code"
    }
}

/// Report data for a single test (a.k.a. scenario)
public struct PerformanceReport: Codable {
    public var deviceSnapshotID: String?
    public var performanceData: PerformanceData?
    public var video: Video?

    public struct PerformanceData: Codable {
        public var steps: [Step]
        public var elapsedSecsEnd: Double
        public var elapsedSecsStart: Double
        public var elapsedSecs: Double
        public var id: String

        public struct Step: Codable {
            public var avgCpu: Double?
            public var avgMem: Double?
            public var samples: [Sample]?
            public var elapsedSecsEnd: Double?
            public var elapsedSecsStart: Double?
            public var elapsedSecs: Double?
            public var name: String?
            public var id: String?

            public struct Sample: Codable {
                public var cpu: Double?
                public var mem: Double?
                public var elapsedSecs: Double?

                public init(cpu: Double? = nil, mem: Double? = nil, elapsedSecs: Double? = nil) {
                    self.cpu = cpu
                    self.mem = mem
                    self.elapsedSecs = elapsedSecs
                }

                private enum CodingKeys: String, CodingKey {
                    case cpu
                    case mem
                    case elapsedSecs = "elapsed-secs"
                }
            }

            public init(avgCpu: Double? = nil, avgMem: Double? = nil, samples: [Sample]? = nil, elapsedSecsEnd: Double? = nil, elapsedSecsStart: Double? = nil, elapsedSecs: Double? = nil, name: String? = nil, id: String? = nil) {
                self.avgCpu = avgCpu
                self.avgMem = avgMem
                self.samples = samples
                self.elapsedSecsEnd = elapsedSecsEnd
                self.elapsedSecsStart = elapsedSecsStart
                self.elapsedSecs = elapsedSecs
                self.name = name
                self.id = id
            }

            private enum CodingKeys: String, CodingKey {
                case avgCpu = "avg-cpu"
                case avgMem = "avg-mem"
                case samples
                case elapsedSecsEnd = "elapsed-secs-end"
                case elapsedSecsStart = "elapsed-secs-start"
                case elapsedSecs = "elapsed-secs"
                case name
                case id
            }
        }

        public init(steps: [Step], elapsedSecsEnd: Double, elapsedSecsStart: Double, elapsedSecs: Double, id: String) {
            self.steps = steps
            self.elapsedSecsEnd = elapsedSecsEnd
            self.elapsedSecsStart = elapsedSecsStart
            self.elapsedSecs = elapsedSecs
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case steps
            case elapsedSecsEnd = "elapsed-secs-end"
            case elapsedSecsStart = "elapsed-secs-start"
            case elapsedSecs = "elapsed-secs"
            case id
        }
    }

    public struct Video: Codable {
        public var videoMetadata: VideoMetadata
        public var videoURL: String

        public struct VideoMetadata: Codable {
            public var events: [Event]?

            public struct Event: Codable {
                public var id: String?
                public var millis: Double?
                public var name: String?
                public var type: String?

                public init(id: String? = nil, millis: Double? = nil, name: String? = nil, type: String? = nil) {
                    self.id = id
                    self.millis = millis
                    self.name = name
                    self.type = type
                }
            }

            public init(events: [Event]? = nil) {
                self.events = events
            }
        }

        public init(videoMetadata: VideoMetadata, videoURL: String) {
            self.videoMetadata = videoMetadata
            self.videoURL = videoURL
        }

        private enum CodingKeys: String, CodingKey {
            case videoMetadata = "video_metadata"
            case videoURL = "video_url"
        }
    }

    public init(deviceSnapshotID: String? = nil, performanceData: PerformanceData? = nil, video: Video? = nil) {
        self.deviceSnapshotID = deviceSnapshotID
        self.performanceData = performanceData
        self.video = video
    }

    private enum CodingKeys: String, CodingKey {
        case deviceSnapshotID = "device_snapshot_id"
        case performanceData = "performance_data"
        case video
    }
}

public struct SubmitDsrOperationRequest: Codable {
    public var request: Request?
    public var accountID: String?
    public var appID: String?
    /// The DSR operation ID provided by the GDPR coordinator. Used for tracking only.
    public var operationID: String?
    /// Request ID provided by the GDPR coordinator. Used for tracking.
    public var requestID: String?

    public enum Request: String, Codable, CaseIterable {
        case delete = "Delete"
        case purge = "Purge"
        case undoDelete = "UndoDelete"
        case export = "Export"
    }

    public init(request: Request? = nil, accountID: String? = nil, appID: String? = nil, operationID: String? = nil, requestID: String? = nil) {
        self.request = request
        self.accountID = accountID
        self.appID = appID
        self.operationID = operationID
        self.requestID = requestID
    }

    private enum CodingKeys: String, CodingKey {
        case request
        case accountID = "accountId"
        case appID = "appId"
        case operationID = "operationId"
        case requestID = "requestId"
    }
}

public struct SubmitDsrOperationResponse: Codable {
    /// The status of the DSR operation
    public var status: Status?

    /// The status of the DSR operation
    public enum Status: String, Codable, CaseIterable {
        case notStarted = "NotStarted"
        case inProgress = "InProgress"
        case completed = "Completed"
        case failure = "Failure"
    }

    public init(status: Status? = nil) {
        self.status = status
    }
}

public struct CreateGdprTestData: Codable {
    public var appID: String?
    public var accountID: String?
    public var userName: String?
    public var userEmail: String?
    public var appName: String?

    public init(appID: String? = nil, accountID: String? = nil, userName: String? = nil, userEmail: String? = nil, appName: String? = nil) {
        self.appID = appID
        self.accountID = accountID
        self.userName = userName
        self.userEmail = userEmail
        self.appName = appName
    }

    private enum CodingKeys: String, CodingKey {
        case appID = "appId"
        case accountID = "accountId"
        case userName
        case userEmail
        case appName
    }
}

public struct TestGDPRAccount: Codable {
    public var id: String?

    public init(id: String? = nil) {
        self.id = id
    }
}

public struct TestGDPRFeatureFlag: Codable {
    public var name: String?
    public var targetID: String?

    public init(name: String? = nil, targetID: String? = nil) {
        self.name = name
        self.targetID = targetID
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case targetID = "target_id"
    }
}

public struct TestGDPRResourceList: Codable {
    public var resources: [Resource]?

    public struct Resource: Codable {
        public var rel: String?
        public var path: String?

        public init(rel: String? = nil, path: String? = nil) {
            self.rel = rel
            self.path = path
        }
    }

    public init(resources: [Resource]? = nil) {
        self.resources = resources
    }
}

public struct TestGDPRApp: Codable {
    public var hashFilesURL: String?

    public init(hashFilesURL: String? = nil) {
        self.hashFilesURL = hashFilesURL
    }

    private enum CodingKeys: String, CodingKey {
        case hashFilesURL = "hash_files_url"
    }
}

public struct TestGDPRHashFile: Codable {
    public var id: String?
    public var filename: String?

    public init(id: String? = nil, filename: String? = nil) {
        self.id = id
        self.filename = filename
    }
}

public struct TestGDPRTestRun: Codable {
    public var id: String?
    public var appHashFileID: String?
    public var locale: String?
    public var dsymHashFileID: String?
    public var appHashFileURL: String?
    public var dsymHashFileURL: String?
    public var appIconURL: String?

    public init(id: String? = nil, appHashFileID: String? = nil, locale: String? = nil, dsymHashFileID: String? = nil, appHashFileURL: String? = nil, dsymHashFileURL: String? = nil, appIconURL: String? = nil) {
        self.id = id
        self.appHashFileID = appHashFileID
        self.locale = locale
        self.dsymHashFileID = dsymHashFileID
        self.appHashFileURL = appHashFileURL
        self.dsymHashFileURL = dsymHashFileURL
        self.appIconURL = appIconURL
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case appHashFileID = "app_hash_file_id"
        case locale
        case dsymHashFileID = "dsym_hash_file_id"
        case appHashFileURL = "app_hash_file_url"
        case dsymHashFileURL = "dsym_hash_file_url"
        case appIconURL = "app_icon_url"
    }
}

public struct TestGDPRPipelineTest: Codable {
    public var appUploadID: String?
    public var testParameters: [String: AnyJSON]?

    public init(appUploadID: String? = nil, testParameters: [String: AnyJSON]? = nil) {
        self.appUploadID = appUploadID
        self.testParameters = testParameters
    }

    private enum CodingKeys: String, CodingKey {
        case appUploadID = "app_upload_id"
        case testParameters = "test_parameters"
    }
}

public struct TestGDPRFileSetFile: Codable {
    public var path: String?
    public var hashFileID: String?
    public var appUploadID: String?
    public var hashFileURL: String?

    public init(path: String? = nil, hashFileID: String? = nil, appUploadID: String? = nil, hashFileURL: String? = nil) {
        self.path = path
        self.hashFileID = hashFileID
        self.appUploadID = appUploadID
        self.hashFileURL = hashFileURL
    }

    private enum CodingKeys: String, CodingKey {
        case path
        case hashFileID = "hash_file_id"
        case appUploadID = "app_upload_id"
        case hashFileURL = "hash_file_url"
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
