// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import NaiveDate
import Get

extension Paths {
    public static var v1: V1 {
        V1(path: "/v1")
    }

    public struct V1 {
        /// Path: `/v1`
        public let path: String
    }
}

extension Paths.V1 {
    public func paymentService(_ paymentService: String) -> WithPaymentService {
        WithPaymentService(path: "\(path)/\(paymentService)")
    }

    public struct WithPaymentService {
        /// Path: `/v1/{payment-service}`
        public let path: String
    }
}

extension Paths.V1.WithPaymentService {
    public func paymentProduct(_ paymentProduct: String) -> WithPaymentProduct {
        WithPaymentProduct(path: "\(path)/\(paymentProduct)")
    }

    public struct WithPaymentProduct {
        /// Path: `/v1/{payment-service}/{payment-product}`
        public let path: String

        /// Payment initiation request
        ///
        /// This method is used to initiate a payment at the ASPSP.
        /// 
        /// ## Variants of payment initiation requests
        /// 
        /// This method to initiate a payment initiation at the ASPSP can be sent with either a JSON body or an pain.001 body depending on the payment product in the path.
        /// 
        /// There are the following **payment products**:
        /// 
        ///   - Payment products with payment information in *JSON* format:
        ///     - ***domestic-swiss-credit-transfers-isr***
        ///     - ***domestic-swiss-credit-transfers***
        ///     - ***domestic-swiss-credit-transfers-qr***
        ///     - ***domestic-swiss-foreign-credit-transfers***
        ///     - ***swiss-sepa-credit-transfers***
        ///     - ***swiss-cross-border-credit-transfers***
        ///   - Payment products with payment information in *SIX pain.001* XML format:
        ///     - ***pain.001-sepa-credit-transfers***
        ///     - ***pain.001-cross-border-credit-transfers***
        ///     - ***pain.001-swiss-six-credit-transfers***
        /// 
        /// Furthermore the request body depends on the **payment-service**:
        ///   * ***payments***: A single payment initiation request.
        ///   * ***bulk-payments***: A collection of several payment initiation requests.
        ///   
        ///     In case of a *pain.001* message there are more than one payments contained in the *pain.001 message.
        /// 
        ///     In case of a *JSON* there are several JSON payment blocks contained in a joining list.
        ///   * ***periodic-payments***:
        ///     Create a standing order initiation resource for recurrent i.e. periodic payments addressable under {paymentId}
        ///      with all data relevant for the corresponding payment product and the execution of the standing order contained in a JSON body.
        /// 
        /// This is the first step in the API to initiate the related recurring/periodic payment.
        /// 
        /// ## Single and mulitilevel SCA Processes
        /// 
        /// The payment initiation requests are independent from the need of one or multilevel
        /// SCA processing, i.e. independent from the number of authorisations needed for the execution of payments.
        /// 
        /// But the response messages are specific to either one SCA processing or multilevel SCA processing.
        /// 
        /// For payment initiation with multilevel SCA, this specification requires an explicit start of the authorisation,
        /// i.e. links directly associated with SCA processing like 'scaRedirect' or 'scaOAuth' cannot be contained in the
        /// response message of a Payment Initation Request for a payment, where multiple authorisations are needed.
        /// Also if any data is needed for the next action, like selecting an SCA method is not supported in the response,
        /// since all starts of the multiple authorisations are fully equal.
        /// In these cases, first an authorisation sub-resource has to be generated following the 'startAuthorisation' link.
        public func post(_ body: PostRequest) -> Request<OpenBankingAPI.PaymentInitationRequestResponse201> {
            .post(path, body: body)
        }

        public enum PostRequest: Encodable {
            case paymentInitiationJSON(OpenBankingAPI.PaymentInitiationJSON)
            case periodicPaymentInitiationJSON(OpenBankingAPI.PeriodicPaymentInitiationJSON)
            case bulkPaymentInitiationJSON(OpenBankingAPI.BulkPaymentInitiationJSON)

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .paymentInitiationJSON(let value): try container.encode(value)
                case .periodicPaymentInitiationJSON(let value): try container.encode(value)
                case .bulkPaymentInitiationJSON(let value): try container.encode(value)
                }
            }
        }
    }
}

extension Paths.V1.WithPaymentService.WithPaymentProduct {
    public func paymentID(_ paymentID: String) -> WithPaymentID {
        WithPaymentID(path: "\(path)/\(paymentID)")
    }

    public struct WithPaymentID {
        /// Path: `/v1/{payment-service}/{payment-product}/{paymentId}`
        public let path: String

        /// Get payment information
        ///
        /// Returns the content of a payment object
        public var get: Request<GetResponse> {
            .get(path)
        }

        public enum GetResponse: Decodable {
            case paymentInitiationWithStatusResponse(OpenBankingAPI.PaymentInitiationWithStatusResponse)
            case periodicPaymentInitiationWithStatusResponse(OpenBankingAPI.PeriodicPaymentInitiationWithStatusResponse)
            case bulkPaymentInitiationWithStatusResponse(OpenBankingAPI.BulkPaymentInitiationWithStatusResponse)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(OpenBankingAPI.PaymentInitiationWithStatusResponse.self) {
                    self = .paymentInitiationWithStatusResponse(value)
                } else if let value = try? container.decode(OpenBankingAPI.PeriodicPaymentInitiationWithStatusResponse.self) {
                    self = .periodicPaymentInitiationWithStatusResponse(value)
                } else if let value = try? container.decode(OpenBankingAPI.BulkPaymentInitiationWithStatusResponse.self) {
                    self = .bulkPaymentInitiationWithStatusResponse(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        /// Payment cancellation request
        ///
        /// This method initiates the cancellation of a payment.
        /// Depending on the payment-service, the payment-product and the ASPSP's implementation,
        /// this TPP call might be sufficient to cancel a payment.
        /// If an authorisation of the payment cancellation is mandated by the ASPSP,
        /// a corresponding hyperlink will be contained in the response message.
        /// 
        /// Cancels the addressed payment with resource identification paymentId if applicable to the payment-service, payment-product and received in product related timelines (e.g. before end of business day for scheduled payments of the last business day before the scheduled execution day).
        /// 
        /// The response to this DELETE command will tell the TPP whether the
        ///   * access method was rejected,
        ///   * access method was successful, or
        ///   * access method is generally applicable, but further authorisation processes are needed.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.V1.WithPaymentService.WithPaymentProduct.WithPaymentID {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/v1/{payment-service}/{payment-product}/{paymentId}/status`
        public let path: String

        /// Payment initiation status request
        ///
        /// Check the transaction status of a payment initiation.
        public var get: Request<OpenBankingAPI.PaymentInitiationStatusResponse200JSON> {
            .get(path)
        }
    }
}

extension Paths.V1.WithPaymentService.WithPaymentProduct.WithPaymentID {
    public var authorisations: Authorisations {
        Authorisations(path: path + "/authorisations")
    }

    public struct Authorisations {
        /// Path: `/v1/{payment-service}/{payment-product}/{paymentId}/authorisations`
        public let path: String

        /// Get payment initiation authorisation sub-resources request
        ///
        /// Read a list of all authorisation subresources IDs which have been created.
        /// 
        /// This function returns an array of hyperlinks to all generated authorisation sub-resources.
        public var get: Request<OpenBankingAPI.Authorisations> {
            .get(path)
        }

        /// Start the authorisation process for a payment initiation
        ///
        /// Create an authorisation sub-resource and start the authorisation process.
        /// The message might in addition transmit authentication and authorisation related data.
        /// 
        /// This method is iterated n times for a n times SCA authorisation in a
        /// corporate context, each creating an own authorisation sub-endpoint for
        /// the corresponding PSU authorising the transaction.
        /// 
        /// The ASPSP might make the usage of this access method unnecessary in case
        /// of only one SCA process needed, since the related authorisation resource
        /// might be automatically created by the ASPSP after the submission of the
        /// payment data with the first POST payments/{payment-product} call.
        /// 
        /// The start authorisation process is a process which is needed for creating a new authorisation
        /// or cancellation sub-resource.
        /// 
        /// This applies in the following scenarios:
        /// 
        ///   * The ASPSP has indicated with a 'startAuthorisation' hyperlink in the preceding Payment
        ///     initiation response that an explicit start of the authorisation process is needed by the TPP.
        ///     The 'startAuthorisation' hyperlink can transport more information about data which needs to be
        ///     uploaded by using the extended forms:
        ///     * 'startAuthorisationWithPsuIdentfication'
        ///     * 'startAuthorisationWithPsuAuthentication'
        ///     * 'startAuthorisationWithEncryptedPsuAuthentication'
        ///     * 'startAuthorisationWithAuthentciationMethodSelection'
        ///   * The related payment initiation cannot yet be executed since a multilevel SCA is mandated.
        ///   * The ASPSP has indicated with a 'startAuthorisation' hyperlink in the preceding
        ///     Payment cancellation response that an explicit start of the authorisation process is needed by the TPP.
        ///     The 'startAuthorisation' hyperlink can transport more information about data which needs to be uploaded
        ///     by using the extended forms as indicated above.
        ///   * The related payment cancellation request cannot be applied yet since a multilevel SCA is mandate for
        ///     executing the cancellation.
        ///   * The signing basket needs to be authorised yet.
        public func post(_ body: PostRequest? = nil) -> Request<OpenBankingAPI.StartScaprocessResponse> {
            .post(path, body: body)
        }

        public enum PostRequest: Encodable {
            case anyJSON(AnyJSON)
            case updatePsuAuthentication(OpenBankingAPI.UpdatePsuAuthentication)
            case selectPsuAuthenticationMethod(OpenBankingAPI.SelectPsuAuthenticationMethod)
            case transactionAuthorisation(OpenBankingAPI.TransactionAuthorisation)

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .anyJSON(let value): try container.encode(value)
                case .updatePsuAuthentication(let value): try container.encode(value)
                case .selectPsuAuthenticationMethod(let value): try container.encode(value)
                case .transactionAuthorisation(let value): try container.encode(value)
                }
            }
        }
    }
}

extension Paths.V1.WithPaymentService.WithPaymentProduct.WithPaymentID.Authorisations {
    public func authorisationID(_ authorisationID: String) -> WithAuthorisationID {
        WithAuthorisationID(path: "\(path)/\(authorisationID)")
    }

    public struct WithAuthorisationID {
        /// Path: `/v1/{payment-service}/{payment-product}/{paymentId}/authorisations/{authorisationId}`
        public let path: String

        /// Read the SCA status of the payment authorisation
        ///
        /// This method returns the SCA status of a payment initiation's authorisation sub-resource.
        public var get: Request<OpenBankingAPI.ScaStatusResponse> {
            .get(path)
        }

        /// Update PSU data for payment initiation
        ///
        /// This methods updates PSU data on the authorisation resource if needed.
        /// It may authorise a payment within the Embedded SCA Approach where needed.
        /// 
        /// Independently from the SCA Approach it supports e.g. the selection of
        /// the authentication method and a non-SCA PSU authentication.
        /// 
        /// There are several possible update PSU data requests in the context of payment initiation services needed,
        /// which depends on the SCA approach:
        /// 
        /// * Redirect SCA Approach:
        ///   A specific update PSU data request is applicable for
        ///     * the selection of authentication methods, before choosing the actual SCA approach.
        /// * Decoupled SCA Approach:
        ///   A specific update PSU data request is only applicable for
        ///   * adding the PSU identification, if not provided yet in the payment initiation request or the account information consent request, or if no OAuth2 access token is used, or
        ///   * the selection of authentication methods.
        /// * Embedded SCA Approach:
        ///   The Update PSU Data request might be used
        ///   * to add credentials as a first factor authentication data of the PSU and
        ///   * to select the authentication method and
        ///   * transaction authorisation.
        /// 
        /// The SCA Approach might depend on the chosen SCA method.
        /// For that reason, the following possible Update PSU data request can apply to all SCA approaches:
        /// 
        /// * Select an SCA method in case of several SCA methods are available for the customer.
        /// 
        /// There are the following request types on this access path:
        ///   * Update PSU identification
        ///   * Update PSU authentication
        ///   * Select PSU autorization method
        ///     WARNING: This method needs a reduced header,
        ///     therefore many optional elements are not present.
        ///     Maybe in a later version the access path will change.
        ///   * Transaction authorisation
        ///     WARNING: This method needs a reduced header,
        ///     therefore many optional elements are not present.
        ///     Maybe in a later version the access path will change.
        public func put(_ body: PutRequest? = nil) -> Request<PutResponse> {
            .put(path, body: body)
        }

        public enum PutResponse: Decodable {
            case updatePsuIdenticationResponse(OpenBankingAPI.UpdatePsuIdenticationResponse)
            case updatePsuAuthenticationResponse(OpenBankingAPI.UpdatePsuAuthenticationResponse)
            case selectPsuAuthenticationMethodResponse(OpenBankingAPI.SelectPsuAuthenticationMethodResponse)
            case scaStatusResponse(OpenBankingAPI.ScaStatusResponse)
            case authorisationConfirmationResponse(OpenBankingAPI.AuthorisationConfirmationResponse)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(OpenBankingAPI.UpdatePsuIdenticationResponse.self) {
                    self = .updatePsuIdenticationResponse(value)
                } else if let value = try? container.decode(OpenBankingAPI.UpdatePsuAuthenticationResponse.self) {
                    self = .updatePsuAuthenticationResponse(value)
                } else if let value = try? container.decode(OpenBankingAPI.SelectPsuAuthenticationMethodResponse.self) {
                    self = .selectPsuAuthenticationMethodResponse(value)
                } else if let value = try? container.decode(OpenBankingAPI.ScaStatusResponse.self) {
                    self = .scaStatusResponse(value)
                } else if let value = try? container.decode(OpenBankingAPI.AuthorisationConfirmationResponse.self) {
                    self = .authorisationConfirmationResponse(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        public enum PutRequest: Encodable {
            case anyJSON(AnyJSON)
            case updatePsuAuthentication(OpenBankingAPI.UpdatePsuAuthentication)
            case selectPsuAuthenticationMethod(OpenBankingAPI.SelectPsuAuthenticationMethod)
            case transactionAuthorisation(OpenBankingAPI.TransactionAuthorisation)
            case authorisationConfirmation(OpenBankingAPI.AuthorisationConfirmation)

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .anyJSON(let value): try container.encode(value)
                case .updatePsuAuthentication(let value): try container.encode(value)
                case .selectPsuAuthenticationMethod(let value): try container.encode(value)
                case .transactionAuthorisation(let value): try container.encode(value)
                case .authorisationConfirmation(let value): try container.encode(value)
                }
            }
        }
    }
}

extension Paths.V1.WithPaymentService.WithPaymentProduct.WithPaymentID {
    public var cancellationAuthorisations: CancellationAuthorisations {
        CancellationAuthorisations(path: path + "/cancellation-authorisations")
    }

    public struct CancellationAuthorisations {
        /// Path: `/v1/{payment-service}/{payment-product}/{paymentId}/cancellation-authorisations`
        public let path: String

        /// Will deliver an array of resource identifications to all generated cancellation authorisation sub-resources
        ///
        /// Retrieve a list of all created cancellation authorisation sub-resources.
        public var get: Request<OpenBankingAPI.Authorisations> {
            .get(path)
        }

        /// Start the authorisation process for the cancellation of the addressed payment
        ///
        /// Creates an authorisation sub-resource and start the authorisation process of the cancellation of the addressed payment.
        /// The message might in addition transmit authentication and authorisation related data.
        /// 
        /// This method is iterated n times for a n times SCA authorisation in a
        /// corporate context, each creating an own authorisation sub-endpoint for
        /// the corresponding PSU authorising the cancellation-authorisation.
        /// 
        /// The ASPSP might make the usage of this access method unnecessary in case
        /// of only one SCA process needed, since the related authorisation resource
        /// might be automatically created by the ASPSP after the submission of the
        /// payment data with the first POST payments/{payment-product} call.
        /// 
        /// The start authorisation process is a process which is needed for creating a new authorisation
        /// or cancellation sub-resource.
        /// 
        /// This applies in the following scenarios:
        /// 
        ///   * The ASPSP has indicated with a 'startAuthorisation' hyperlink in the preceding payment
        ///     initiation response that an explicit start of the authorisation process is needed by the TPP.
        ///     The 'startAuthorisation' hyperlink can transport more information about data which needs to be
        ///     uploaded by using the extended forms:
        ///     * 'startAuthorisationWithPsuIdentfication'
        ///     * 'startAuthorisationWithPsuAuthentication'
        ///     * 'startAuthorisationWithAuthentciationMethodSelection'
        ///   * The related payment initiation cannot yet be executed since a multilevel SCA is mandated.
        ///   * The ASPSP has indicated with a 'startAuthorisation' hyperlink in the preceding
        ///     payment cancellation response that an explicit start of the authorisation process is needed by the TPP.
        ///     The 'startAuthorisation' hyperlink can transport more information about data which needs to be uploaded
        ///     by using the extended forms as indicated above.
        ///   * The related payment cancellation request cannot be applied yet since a multilevel SCA is mandate for
        ///     executing the cancellation.
        ///   * The signing basket needs to be authorised yet.
        public func post(_ body: PostRequest? = nil) -> Request<OpenBankingAPI.StartScaprocessResponse> {
            .post(path, body: body)
        }

        public enum PostRequest: Encodable {
            case anyJSON(AnyJSON)
            case updatePsuAuthentication(OpenBankingAPI.UpdatePsuAuthentication)
            case selectPsuAuthenticationMethod(OpenBankingAPI.SelectPsuAuthenticationMethod)
            case transactionAuthorisation(OpenBankingAPI.TransactionAuthorisation)

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .anyJSON(let value): try container.encode(value)
                case .updatePsuAuthentication(let value): try container.encode(value)
                case .selectPsuAuthenticationMethod(let value): try container.encode(value)
                case .transactionAuthorisation(let value): try container.encode(value)
                }
            }
        }
    }
}

extension Paths.V1.WithPaymentService.WithPaymentProduct.WithPaymentID.CancellationAuthorisations {
    public func authorisationID(_ authorisationID: String) -> WithAuthorisationID {
        WithAuthorisationID(path: "\(path)/\(authorisationID)")
    }

    public struct WithAuthorisationID {
        /// Path: `/v1/{payment-service}/{payment-product}/{paymentId}/cancellation-authorisations/{authorisationId}`
        public let path: String

        /// Read the SCA status of the payment cancellation's authorisation
        ///
        /// This method returns the SCA status of a payment initiation's authorisation sub-resource.
        public var get: Request<OpenBankingAPI.ScaStatusResponse> {
            .get(path)
        }

        /// Update PSU data for payment initiation cancellation
        ///
        /// This method updates PSU data on the cancellation authorisation resource if needed.
        /// It may authorise a cancellation of the payment within the Embedded SCA Approach where needed.
        /// 
        /// Independently from the SCA Approach it supports e.g. the selection of
        /// the authentication method and a non-SCA PSU authentication.
        /// 
        /// There are several possible update PSU data requests in the context of a cancellation authorisation within the payment initiation services needed,
        /// which depends on the SCA approach:
        /// 
        /// * Redirect SCA Approach:
        ///   A specific Update PSU data request is applicable for
        ///     * the selection of authentication methods, before choosing the actual SCA approach.
        /// * Decoupled SCA Approach:
        ///   A specific Update PSU data request is only applicable for
        ///   * adding the PSU Identification, if not provided yet in the payment initiation request or the Account Information Consent Request, or if no OAuth2 access token is used, or
        ///   * the selection of authentication methods.
        /// * Embedded SCA Approach:
        ///   The Update PSU data request might be used
        ///   * to add credentials as a first factor authentication data of the PSU and
        ///   * to select the authentication method and
        ///   * transaction authorisation.
        /// 
        /// The SCA approach might depend on the chosen SCA method.
        /// For that reason, the following possible update PSU data request can apply to all SCA approaches:
        /// 
        /// * Select an SCA method in case of several SCA methods are available for the customer.
        /// 
        /// There are the following request types on this access path:
        ///   * Update PSU identification
        ///   * Update PSU authentication
        ///   * Select PSU autorization method
        ///     WARNING: This method needs a reduced header,
        ///     therefore many optional elements are not present.
        ///     Maybe in a later version the access path will change.
        ///   * Transaction Authorisation
        ///     WARNING: This method needs a reduced header,
        ///     therefore many optional elements are not present.
        ///     Maybe in a later version the access path will change.
        public func put(_ body: PutRequest? = nil) -> Request<PutResponse> {
            .put(path, body: body)
        }

        public enum PutResponse: Decodable {
            case updatePsuIdenticationResponse(OpenBankingAPI.UpdatePsuIdenticationResponse)
            case updatePsuAuthenticationResponse(OpenBankingAPI.UpdatePsuAuthenticationResponse)
            case selectPsuAuthenticationMethodResponse(OpenBankingAPI.SelectPsuAuthenticationMethodResponse)
            case scaStatusResponse(OpenBankingAPI.ScaStatusResponse)
            case authorisationConfirmationResponse(OpenBankingAPI.AuthorisationConfirmationResponse)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(OpenBankingAPI.UpdatePsuIdenticationResponse.self) {
                    self = .updatePsuIdenticationResponse(value)
                } else if let value = try? container.decode(OpenBankingAPI.UpdatePsuAuthenticationResponse.self) {
                    self = .updatePsuAuthenticationResponse(value)
                } else if let value = try? container.decode(OpenBankingAPI.SelectPsuAuthenticationMethodResponse.self) {
                    self = .selectPsuAuthenticationMethodResponse(value)
                } else if let value = try? container.decode(OpenBankingAPI.ScaStatusResponse.self) {
                    self = .scaStatusResponse(value)
                } else if let value = try? container.decode(OpenBankingAPI.AuthorisationConfirmationResponse.self) {
                    self = .authorisationConfirmationResponse(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        public enum PutRequest: Encodable {
            case anyJSON(AnyJSON)
            case updatePsuAuthentication(OpenBankingAPI.UpdatePsuAuthentication)
            case selectPsuAuthenticationMethod(OpenBankingAPI.SelectPsuAuthenticationMethod)
            case transactionAuthorisation(OpenBankingAPI.TransactionAuthorisation)
            case authorisationConfirmation(OpenBankingAPI.AuthorisationConfirmation)

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .anyJSON(let value): try container.encode(value)
                case .updatePsuAuthentication(let value): try container.encode(value)
                case .selectPsuAuthenticationMethod(let value): try container.encode(value)
                case .transactionAuthorisation(let value): try container.encode(value)
                case .authorisationConfirmation(let value): try container.encode(value)
                }
            }
        }
    }
}

extension Paths.V1 {
    public var accounts: Accounts {
        Accounts(path: path + "/accounts")
    }

    public struct Accounts {
        /// Path: `/v1/accounts`
        public let path: String

        /// Read account list
        ///
        /// Read the identifiers of the available payment account together with
        /// booking balance information, depending on the consent granted.
        /// 
        /// It is assumed that a consent of the PSU to this access is already given and stored on the ASPSP system.
        /// The addressed list of accounts depends then on the PSU ID and the stored consent addressed by consentId,
        /// respectively the OAuth2 access token.
        /// 
        /// Returns all identifiers of the accounts, to which an account access has been granted to through
        /// the /consents endpoint by the PSU.
        /// In addition, relevant information about the accounts and hyperlinks to corresponding account
        /// information resources are provided if a related consent has been already granted.
        /// 
        /// Remark: Note that the /consents endpoint optionally offers to grant an access on all available
        /// payment accounts of a PSU.
        /// In this case, this endpoint will deliver the information about all available payment accounts
        /// of the PSU at this ASPSP.
        public func get(isWithBalance: Bool? = nil) -> Request<OpenBankingAPI.AccountList> {
            .get(path, query: makeGetQuery(isWithBalance))
        }

        private func makeGetQuery(_ isWithBalance: Bool?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("withBalance", isWithBalance)
            return query
        }
    }
}

extension Paths.V1.Accounts {
    public func accountID(_ accountID: String) -> WithAccountID {
        WithAccountID(path: "\(path)/\(accountID)")
    }

    public struct WithAccountID {
        /// Path: `/v1/accounts/{account-id}`
        public let path: String

        /// Read account details
        ///
        /// Reads details about an account, with balances where required.
        /// It is assumed that a consent of the PSU to
        /// this access is already given and stored on the ASPSP system.
        /// The addressed details of this account depends then on the stored consent addressed by consentId,
        /// respectively the OAuth2 access token.
        /// 
        /// **NOTE:** The account-id can represent a multicurrency account.
        /// In this case the currency code is set to "XXX".
        /// 
        /// Give detailed information about the addressed account.
        /// 
        /// Give detailed information about the addressed account together with balance information
        public func get(isWithBalance: Bool? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(isWithBalance))
        }

        public struct GetResponse: Decodable {
            /// The ASPSP shall give at least one of the account reference identifiers:
            ///   - iban
            ///   - bban
            ///   - pan
            ///   - maskedPan
            ///   - msisdn
            /// If the account is a multicurrency account currency code in "currency" is set to "XXX".
            public var account: OpenBankingAPI.AccountDetails

            public init(account: OpenBankingAPI.AccountDetails) {
                self.account = account
            }
        }

        private func makeGetQuery(_ isWithBalance: Bool?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("withBalance", isWithBalance)
            return query
        }
    }
}

extension Paths.V1.Accounts.WithAccountID {
    public var balances: Balances {
        Balances(path: path + "/balances")
    }

    public struct Balances {
        /// Path: `/v1/accounts/{account-id}/balances`
        public let path: String

        /// Read balance
        ///
        /// Reads account data from a given account addressed by "account-id".
        /// 
        /// **Remark:** This account-id can be a tokenised identification due to data protection reason since the path
        /// information might be logged on intermediary servers within the ASPSP sphere.
        /// This account-id then can be retrieved by the "Get account list" call.
        /// 
        /// The account-id is constant at least throughout the lifecycle of a given consent.
        public var get: Request<OpenBankingAPI.ReadAccountBalanceResponse200> {
            .get(path)
        }
    }
}

extension Paths.V1.Accounts.WithAccountID {
    public var transactions: Transactions {
        Transactions(path: path + "/transactions")
    }

    public struct Transactions {
        /// Path: `/v1/accounts/{account-id}/transactions`
        public let path: String

        /// Read transaction list of an account
        ///
        /// Read transaction reports or transaction lists of a given account ddressed by "account-id", depending on the steering parameter
        /// "bookingStatus" together with balances.
        /// 
        /// For a given account, additional parameters are e.g. the attributes "dateFrom" and "dateTo".
        /// The ASPSP might add balance information, if transaction lists without balances are not supported.
        public func get(parameters: GetParameters) -> Request<OpenBankingAPI.TransactionsResponse200JSON> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var dateFrom: NaiveDate?
            public var dateTo: NaiveDate?
            public var entryReferenceFrom: String?
            public var bookingStatus: BookingStatus
            public var isDeltaList: Bool?
            public var isWithBalance: Bool?

            public enum BookingStatus: String, Codable, CaseIterable {
                case information
                case booked
                case pending
                case both
            }

            public init(dateFrom: NaiveDate? = nil, dateTo: NaiveDate? = nil, entryReferenceFrom: String? = nil, bookingStatus: BookingStatus, isDeltaList: Bool? = nil, isWithBalance: Bool? = nil) {
                self.dateFrom = dateFrom
                self.dateTo = dateTo
                self.entryReferenceFrom = entryReferenceFrom
                self.bookingStatus = bookingStatus
                self.isDeltaList = isDeltaList
                self.isWithBalance = isWithBalance
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("dateFrom", dateFrom)
                query.addQueryItem("dateTo", dateTo)
                query.addQueryItem("entryReferenceFrom", entryReferenceFrom)
                query.addQueryItem("bookingStatus", bookingStatus)
                query.addQueryItem("deltaList", isDeltaList)
                query.addQueryItem("withBalance", isWithBalance)
                return query
            }
        }
    }
}

extension Paths.V1.Accounts.WithAccountID.Transactions {
    public func transactionID(_ transactionID: String) -> WithTransactionID {
        WithTransactionID(path: "\(path)/\(transactionID)")
    }

    public struct WithTransactionID {
        /// Path: `/v1/accounts/{account-id}/transactions/{transactionId}`
        public let path: String

        /// Read transaction details
        ///
        /// Reads transaction details from a given transaction addressed by "transactionId" on a given account addressed by "account-id".
        /// This call is only available on transactions as reported in a JSON format.
        /// 
        /// **Remark:** Please note that the PATH might be already given in detail by the corresponding entry of the response of the
        /// "Read Transaction List" call within the _links subfield.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Transaction details.
            public var transactionsDetails: OpenBankingAPI.TransactionDetailsBody

            public init(transactionsDetails: OpenBankingAPI.TransactionDetailsBody) {
                self.transactionsDetails = transactionsDetails
            }
        }
    }
}

extension Paths.V1 {
    public var consents: Consents {
        Consents(path: path + "/consents")
    }

    public struct Consents {
        /// Path: `/v1/consents`
        public let path: String

        /// Create consent
        ///
        /// This method create a consent resource, defining access rights to dedicated accounts of
        /// a given PSU-ID. These accounts are addressed explicitly in the method as
        /// parameters as a core function.
        /// 
        /// **Side Effects**
        /// When this consent request is a request where the "recurringIndicator" equals "true",
        /// and if it exists already a former consent for recurring access on account information
        /// for the addressed PSU, then the former consent automatically expires as soon as the new
        /// consent request is authorised by the PSU.
        /// 
        /// Optional Extension:
        /// As an option, an ASPSP might optionally accept a specific access right on the access on all PSD2 related services for all available accounts.
        /// 
        /// As another option an ASPSP might optionally also accept a command, where only access rights are inserted without mentioning the addressed account.
        /// The relation to accounts is then handled afterwards between PSU and ASPSP.
        /// This option is not supported for the Embedded SCA Approach.
        /// As a last option, an ASPSP might in addition accept a command with access rights
        ///   * to see the list of available payment accounts or
        ///   * to see the list of available payment accounts with balances.
        public func post(_ body: OpenBankingAPI.Consents) -> Request<OpenBankingAPI.ConsentsResponse201> {
            .post(path, body: body)
        }
    }
}

extension Paths.V1.Consents {
    public func consentID(_ consentID: String) -> WithConsentID {
        WithConsentID(path: "\(path)/\(consentID)")
    }

    public struct WithConsentID {
        /// Path: `/v1/consents/{consentId}`
        public let path: String

        /// Get consent request
        ///
        /// Returns the content of an account information consent object.
        /// This is returning the data for the TPP especially in cases,
        /// where the consent was directly managed between ASPSP and PSU e.g. in a redirect SCA Approach.
        public var get: Request<OpenBankingAPI.ConsentInformationResponse200JSON> {
            .get(path)
        }

        /// Delete Consent
        ///
        /// The TPP can delete an account information consent object if needed.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.V1.Consents.WithConsentID {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/v1/consents/{consentId}/status`
        public let path: String

        /// Consent status request
        ///
        /// Read the status of an account information consent resource.
        public var get: Request<OpenBankingAPI.ConsentStatusResponse200> {
            .get(path)
        }
    }
}

extension Paths.V1.Consents.WithConsentID {
    public var authorisations: Authorisations {
        Authorisations(path: path + "/authorisations")
    }

    public struct Authorisations {
        /// Path: `/v1/consents/{consentId}/authorisations`
        public let path: String

        /// Get consent authorisation sub-resources request
        ///
        /// Return a list of all authorisation subresources IDs which have been created.
        /// 
        /// This function returns an array of hyperlinks to all generated authorisation sub-resources.
        public var get: Request<OpenBankingAPI.Authorisations> {
            .get(path)
        }

        /// Start the authorisation process for a consent
        ///
        /// Create an authorisation sub-resource and start the authorisation process of a consent.
        /// The message might in addition transmit authentication and authorisation related data.
        /// 
        /// his method is iterated n times for a n times SCA authorisation in a
        /// corporate context, each creating an own authorisation sub-endpoint for
        /// the corresponding PSU authorising the consent.
        /// 
        /// The ASPSP might make the usage of this access method unnecessary,
        /// since the related authorisation resource will be automatically created by
        /// the ASPSP after the submission of the consent data with the first POST consents call.
        /// 
        /// The start authorisation process is a process which is needed for creating a new authorisation
        /// or cancellation sub-resource.
        /// 
        /// This applies in the following scenarios:
        /// 
        ///   * The ASPSP has indicated with an 'startAuthorisation' hyperlink in the preceding Payment
        ///     initiation response that an explicit start of the authorisation process is needed by the TPP.
        ///     The 'startAuthorisation' hyperlink can transport more information about data which needs to be
        ///     uploaded by using the extended forms:
        ///     * 'startAuthorisationWithPsuIdentfication',
        ///     * 'startAuthorisationWithPsuAuthentication'
        ///     * 'startAuthorisationWithEncryptedPsuAuthentication'
        ///     * 'startAuthorisationWithAuthentciationMethodSelection'
        ///   * The related payment initiation cannot yet be executed since a multilevel SCA is mandated.
        ///   * The ASPSP has indicated with an 'startAuthorisation' hyperlink in the preceding
        ///     payment cancellation response that an explicit start of the authorisation process is needed by the TPP.
        ///     The 'startAuthorisation' hyperlink can transport more information about data which needs to be uploaded
        ///     by using the extended forms as indicated above.
        ///   * The related payment cancellation request cannot be applied yet since a multilevel SCA is mandate for
        ///     executing the cancellation.
        ///   * The signing basket needs to be authorised yet.
        public func post(_ body: PostRequest? = nil) -> Request<OpenBankingAPI.StartScaprocessResponse> {
            .post(path, body: body)
        }

        public enum PostRequest: Encodable {
            case anyJSON(AnyJSON)
            case updatePsuAuthentication(OpenBankingAPI.UpdatePsuAuthentication)
            case selectPsuAuthenticationMethod(OpenBankingAPI.SelectPsuAuthenticationMethod)
            case transactionAuthorisation(OpenBankingAPI.TransactionAuthorisation)

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .anyJSON(let value): try container.encode(value)
                case .updatePsuAuthentication(let value): try container.encode(value)
                case .selectPsuAuthenticationMethod(let value): try container.encode(value)
                case .transactionAuthorisation(let value): try container.encode(value)
                }
            }
        }
    }
}

extension Paths.V1.Consents.WithConsentID.Authorisations {
    public func authorisationID(_ authorisationID: String) -> WithAuthorisationID {
        WithAuthorisationID(path: "\(path)/\(authorisationID)")
    }

    public struct WithAuthorisationID {
        /// Path: `/v1/consents/{consentId}/authorisations/{authorisationId}`
        public let path: String

        /// Read the SCA status of the consent authorisation
        ///
        /// This method returns the SCA status of a consent initiation's authorisation sub-resource.
        public var get: Request<OpenBankingAPI.ScaStatusResponse> {
            .get(path)
        }

        /// Update PSU Data for consents
        ///
        /// This method update PSU data on the consents  resource if needed.
        /// It may authorise a consent within the Embedded SCA Approach where needed.
        /// 
        /// Independently from the SCA Approach it supports e.g. the selection of
        /// the authentication method and a non-SCA PSU authentication.
        /// 
        /// There are several possible update PSU data requests in the context of a consent request if needed,
        /// which depends on the SCA approach:
        /// 
        /// * Redirect SCA Approach:
        ///   A specific Update PSU data request is applicable for
        ///     * the selection of authentication methods, before choosing the actual SCA approach.
        /// * Decoupled SCA Approach:
        ///   A specific update PSU data request is only applicable for
        ///   * adding the PSU Identification, if not provided yet in the payment initiation request or the Account Information Consent Request, or if no OAuth2 access token is used, or
        ///   * the selection of authentication methods.
        /// * Embedded SCA Approach:
        ///   The Update PSU data request might be used
        ///   * to add credentials as a first factor authentication data of the PSU and
        ///   * to select the authentication method and
        ///   * transaction authorisation.
        /// 
        /// The SCA Approach might depend on the chosen SCA method.
        /// For that reason, the following possible update PSU data request can apply to all SCA approaches:
        /// 
        /// * Select an SCA method in case of several SCA methods are available for the customer.
        /// 
        /// There are the following request types on this access path:
        ///   * Update PSU identification
        ///   * Update PSU authentication
        ///   * Select PSU autorization method
        ///     WARNING: This method needs a reduced header,
        ///     therefore many optional elements are not present.
        ///     Maybe in a later version the access path will change.
        ///   * Transaction Authorisation
        ///     WARNING: This method needs a reduced header,
        ///     therefore many optional elements are not present.
        ///     Maybe in a later version the access path will change.
        public func put(_ body: PutRequest? = nil) -> Request<PutResponse> {
            .put(path, body: body)
        }

        public enum PutResponse: Decodable {
            case updatePsuIdenticationResponse(OpenBankingAPI.UpdatePsuIdenticationResponse)
            case updatePsuAuthenticationResponse(OpenBankingAPI.UpdatePsuAuthenticationResponse)
            case selectPsuAuthenticationMethodResponse(OpenBankingAPI.SelectPsuAuthenticationMethodResponse)
            case scaStatusResponse(OpenBankingAPI.ScaStatusResponse)
            case authorisationConfirmationResponse(OpenBankingAPI.AuthorisationConfirmationResponse)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(OpenBankingAPI.UpdatePsuIdenticationResponse.self) {
                    self = .updatePsuIdenticationResponse(value)
                } else if let value = try? container.decode(OpenBankingAPI.UpdatePsuAuthenticationResponse.self) {
                    self = .updatePsuAuthenticationResponse(value)
                } else if let value = try? container.decode(OpenBankingAPI.SelectPsuAuthenticationMethodResponse.self) {
                    self = .selectPsuAuthenticationMethodResponse(value)
                } else if let value = try? container.decode(OpenBankingAPI.ScaStatusResponse.self) {
                    self = .scaStatusResponse(value)
                } else if let value = try? container.decode(OpenBankingAPI.AuthorisationConfirmationResponse.self) {
                    self = .authorisationConfirmationResponse(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        public enum PutRequest: Encodable {
            case anyJSON(AnyJSON)
            case updatePsuAuthentication(OpenBankingAPI.UpdatePsuAuthentication)
            case selectPsuAuthenticationMethod(OpenBankingAPI.SelectPsuAuthenticationMethod)
            case transactionAuthorisation(OpenBankingAPI.TransactionAuthorisation)
            case authorisationConfirmation(OpenBankingAPI.AuthorisationConfirmation)

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .anyJSON(let value): try container.encode(value)
                case .updatePsuAuthentication(let value): try container.encode(value)
                case .selectPsuAuthenticationMethod(let value): try container.encode(value)
                case .transactionAuthorisation(let value): try container.encode(value)
                case .authorisationConfirmation(let value): try container.encode(value)
                }
            }
        }
    }
}

extension Paths.V1 {
    public var fundsConfirmations: FundsConfirmations {
        FundsConfirmations(path: path + "/funds-confirmations")
    }

    public struct FundsConfirmations {
        /// Path: `/v1/funds-confirmations`
        public let path: String

        /// Confirmation of funds request
        ///
        /// Creates a confirmation of funds request at the ASPSP. Checks whether a specific amount is available at point of time of the request on an account linked to a given tuple card issuer(TPP)/card number, or addressed by IBAN and TPP respectively.
        /// If the related extended services are used a conditional Consent-ID is contained in the header. This field is contained but commented out in this specification.
        public func post(_ body: OpenBankingAPI.ConfirmationOfFunds) -> Request<PostResponse> {
            .post(path, body: body)
        }

        /// Equals "true" if sufficient funds are available at the time of the request,
        /// "false" otherwise.
        public struct PostResponse: Decodable {
            /// Equals true if sufficient funds are available at the time of the request, false otherwise.
            /// 
            /// This datalemenet is allways contained in a confirmation of funds response.
            /// 
            /// This data element is contained in a payment status response,
            /// if supported by the ASPSP, if a funds check has been performed and
            /// if the transactionStatus is "ACTC", "ACWC" or "ACCP".
            public var isFundsAvailable: Bool

            public init(isFundsAvailable: Bool) {
                self.isFundsAvailable = isFundsAvailable
            }

            private enum CodingKeys: String, CodingKey {
                case isFundsAvailable = "fundsAvailable"
            }
        }
    }
}

extension Paths.V1 {
    public var signingBaskets: SigningBaskets {
        SigningBaskets(path: path + "/signing-baskets")
    }

    public struct SigningBaskets {
        /// Path: `/v1/signing-baskets`
        public let path: String

        /// Create a signing basket resource
        ///
        /// Create a signing basket resource for authorising several transactions with one SCA method.
        /// The resource identifications of these transactions are contained in the payload of this access method
        public func post(_ body: OpenBankingAPI.SigningBasket) -> Request<OpenBankingAPI.SigningBasketResponse201> {
            .post(path, body: body)
        }
    }
}

extension Paths.V1.SigningBaskets {
    public func basketID(_ basketID: String) -> WithBasketID {
        WithBasketID(path: "\(path)/\(basketID)")
    }

    public struct WithBasketID {
        /// Path: `/v1/signing-baskets/{basketId}`
        public let path: String

        /// Returns the content of an signing basket object
        ///
        /// Returns the content of a signing basket object.
        public var get: Request<OpenBankingAPI.SigningBasketResponse200> {
            .get(path)
        }

        /// Delete the signing basket
        ///
        /// Delete the signing basket structure as long as no (partial) authorisation has yet been applied.
        /// The undlerying transactions are not affected by this deletion.
        /// 
        /// Remark: The signing basket as such is not deletable after a first (partial) authorisation has been applied.
        /// Nevertheless, single transactions might be cancelled on an individual basis on the XS2A interface.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.V1.SigningBaskets.WithBasketID {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/v1/signing-baskets/{basketId}/status`
        public let path: String

        /// Read the status of the signing basket
        ///
        /// Returns the status of a signing basket object.
        public var get: Request<OpenBankingAPI.SigningBasketStatusResponse200> {
            .get(path)
        }
    }
}

extension Paths.V1.SigningBaskets.WithBasketID {
    public var authorisations: Authorisations {
        Authorisations(path: path + "/authorisations")
    }

    public struct Authorisations {
        /// Path: `/v1/signing-baskets/{basketId}/authorisations`
        public let path: String

        /// Get signing basket authorisation sub-resources request
        ///
        /// Read a list of all authorisation subresources IDs which have been created.
        /// 
        /// This function returns an array of hyperlinks to all generated authorisation sub-resources.
        public var get: Request<OpenBankingAPI.Authorisations> {
            .get(path)
        }

        /// Start the authorisation process for a signing basket
        ///
        /// Create an authorisation sub-resource and start the authorisation process of a signing basket.
        /// The message might in addition transmit authentication and authorisation related data.
        /// 
        /// This method is iterated n times for a n times SCA authorisation in a
        /// corporate context, each creating an own authorisation sub-endpoint for
        /// the corresponding PSU authorising the signing-baskets.
        /// 
        /// The ASPSP might make the usage of this access method unnecessary in case
        /// of only one SCA process needed, since the related authorisation resource
        /// might be automatically created by the ASPSP after the submission of the
        /// payment data with the first POST signing basket call.
        /// 
        /// The start authorisation process is a process which is needed for creating a new authorisation
        /// or cancellation sub-resource.
        /// 
        /// This applies in the following scenarios:
        /// 
        ///   * The ASPSP has indicated with a 'startAuthorisation' hyperlink in the preceding payment
        ///     initiation response that an explicit start of the authorisation process is needed by the TPP.
        ///     The 'startAuthorisation' hyperlink can transport more information about data which needs to be
        ///     uploaded by using the extended forms:
        ///     * 'startAuthorisationWithPsuIdentfication',
        ///     * 'startAuthorisationWithPsuAuthentication'
        ///     * 'startAuthorisationWithEncryptedPsuAuthentication'
        ///     * 'startAuthorisationWithAuthentciationMethodSelection'
        ///   * The related payment initiation cannot yet be executed since a multilevel SCA is mandated.
        ///   * The ASPSP has indicated with a 'startAuthorisation' hyperlink in the preceding
        ///     payment cancellation response that an explicit start of the authorisation process is needed by the TPP.
        ///     The 'startAuthorisation' hyperlink can transport more information about data which needs to be uploaded
        ///     by using the extended forms as indicated above.
        ///   * The related payment cancellation request cannot be applied yet since a multilevel SCA is mandate for
        ///     executing the cancellation.
        ///   * The signing basket needs to be authorised yet.
        public func post(_ body: PostRequest? = nil) -> Request<OpenBankingAPI.StartScaprocessResponse> {
            .post(path, body: body)
        }

        public enum PostRequest: Encodable {
            case anyJSON(AnyJSON)
            case updatePsuAuthentication(OpenBankingAPI.UpdatePsuAuthentication)
            case selectPsuAuthenticationMethod(OpenBankingAPI.SelectPsuAuthenticationMethod)
            case transactionAuthorisation(OpenBankingAPI.TransactionAuthorisation)

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .anyJSON(let value): try container.encode(value)
                case .updatePsuAuthentication(let value): try container.encode(value)
                case .selectPsuAuthenticationMethod(let value): try container.encode(value)
                case .transactionAuthorisation(let value): try container.encode(value)
                }
            }
        }
    }
}

extension Paths.V1.SigningBaskets.WithBasketID.Authorisations {
    public func authorisationID(_ authorisationID: String) -> WithAuthorisationID {
        WithAuthorisationID(path: "\(path)/\(authorisationID)")
    }

    public struct WithAuthorisationID {
        /// Path: `/v1/signing-baskets/{basketId}/authorisations/{authorisationId}`
        public let path: String

        /// Read the SCA status of the signing basket authorisation
        ///
        /// This method returns the SCA status of a signing basket's authorisation sub-resource.
        public var get: Request<OpenBankingAPI.ScaStatusResponse> {
            .get(path)
        }

        /// Update PSU data for signing basket
        ///
        /// This method update PSU data on the signing basket resource if needed.
        /// It may authorise a igning basket within the embedded SCA approach where needed.
        /// 
        /// Independently from the SCA Approach it supports e.g. the selection of
        /// the authentication method and a non-SCA PSU authentication.
        /// 
        /// There are several possible update PSU data requests in the context of a consent request if needed,
        /// which depends on the SCA approach:
        /// 
        /// * Redirect SCA Approach:
        ///   A specific Update PSU data request is applicable for
        ///     * the selection of authentication methods, before choosing the actual SCA approach.
        /// * Decoupled SCA Approach:
        ///   A specific Update PSU data request is only applicable for
        ///   * adding the PSU Identification, if not provided yet in the payment initiation request or the account information consent request, or if no OAuth2 access token is used, or
        ///   * the selection of authentication methods.
        /// * Embedded SCA Approach:
        ///   The update PSU data request might be used
        ///   * to add credentials as a first factor authentication data of the PSU and
        ///   * to select the authentication method and
        ///   * transaction authorisation.
        /// 
        /// The SCA approach might depend on the chosen SCA method.
        /// For that reason, the following possible update PSU data request can apply to all SCA approaches:
        /// 
        /// * Select an SCA method in case of several SCA methods are available for the customer.
        /// 
        /// There are the following request types on this access path:
        ///   * Update PSU identification
        ///   * Update PSU authentication
        ///   * Select PSU autorization Method
        ///     WARNING: This method needs a reduced header,
        ///     therefore many optional elements are not present.
        ///     Maybe in a later version the access path will change.
        ///   * Transaction Authorisation
        ///     WARNING: This method needs a reduced header,
        ///     therefore many optional elements are not present.
        ///     Maybe in a later version the access path will change.
        public func put(_ body: PutRequest? = nil) -> Request<PutResponse> {
            .put(path, body: body)
        }

        public enum PutResponse: Decodable {
            case updatePsuIdenticationResponse(OpenBankingAPI.UpdatePsuIdenticationResponse)
            case updatePsuAuthenticationResponse(OpenBankingAPI.UpdatePsuAuthenticationResponse)
            case selectPsuAuthenticationMethodResponse(OpenBankingAPI.SelectPsuAuthenticationMethodResponse)
            case scaStatusResponse(OpenBankingAPI.ScaStatusResponse)
            case authorisationConfirmationResponse(OpenBankingAPI.AuthorisationConfirmationResponse)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(OpenBankingAPI.UpdatePsuIdenticationResponse.self) {
                    self = .updatePsuIdenticationResponse(value)
                } else if let value = try? container.decode(OpenBankingAPI.UpdatePsuAuthenticationResponse.self) {
                    self = .updatePsuAuthenticationResponse(value)
                } else if let value = try? container.decode(OpenBankingAPI.SelectPsuAuthenticationMethodResponse.self) {
                    self = .selectPsuAuthenticationMethodResponse(value)
                } else if let value = try? container.decode(OpenBankingAPI.ScaStatusResponse.self) {
                    self = .scaStatusResponse(value)
                } else if let value = try? container.decode(OpenBankingAPI.AuthorisationConfirmationResponse.self) {
                    self = .authorisationConfirmationResponse(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        public enum PutRequest: Encodable {
            case anyJSON(AnyJSON)
            case updatePsuAuthentication(OpenBankingAPI.UpdatePsuAuthentication)
            case selectPsuAuthenticationMethod(OpenBankingAPI.SelectPsuAuthenticationMethod)
            case transactionAuthorisation(OpenBankingAPI.TransactionAuthorisation)
            case authorisationConfirmation(OpenBankingAPI.AuthorisationConfirmation)

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .anyJSON(let value): try container.encode(value)
                case .updatePsuAuthentication(let value): try container.encode(value)
                case .selectPsuAuthenticationMethod(let value): try container.encode(value)
                case .transactionAuthorisation(let value): try container.encode(value)
                case .authorisationConfirmation(let value): try container.encode(value)
                }
            }
        }
    }
}

public enum Paths {}

protocol QueryEncodable {
    var asQueryValue: String { get }
}

extension Bool: QueryEncodable {
    var asQueryValue: String {
        self ? "true" : "false"
    }
}

extension Date: QueryEncodable {
    var asQueryValue: String {
        ISO8601DateFormatter().string(from: self)
    }
}

extension Double: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int32: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int64: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension NaiveDate: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension String: QueryEncodable {
    var asQueryValue: String {
        self
    }
}

extension URL: QueryEncodable {
    var asQueryValue: String {
        absoluteString
    }
}

extension RawRepresentable where RawValue == String {
    var asQueryValue: String {
        rawValue
    }
}

extension Array where Element == (String, String?) {
    mutating func addQueryItem<T: RawRepresentable>(_ name: String, _ value: T?) where T.RawValue == String {
        addQueryItem(name, value?.rawValue)
    }
    
    mutating func addQueryItem(_ name: String, _ value: QueryEncodable?) {
        guard let value = value?.asQueryValue, !value.isEmpty else { return }
        append((name, value))
    }
    
    mutating func addDeepObject(_ name: String, _ query: [(String, String?)]?) {
        for (key, value) in query ?? [] {
            addQueryItem("\(name)[\(key)]", value)
        }
    }

    var asPercentEncodedQuery: String {
        var components = URLComponents()
        components.queryItems = self.map(URLQueryItem.init)
        return components.percentEncodedQuery ?? ""
    }
    
    // [("role", "admin"), ("name": "kean)] -> "role,admin,name,kean"
    var asCompactQuery: String {
        flatMap { [$0, $1] }.compactMap { $0 }.joined(separator: ",")
    }
}
