// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import NaiveDate
import APIClient

extension Paths {
    public static var accountsJSON: AccountsJSON {
        AccountsJSON(path: "/2010-04-01/Accounts.json")
    }

    public struct AccountsJSON {
        /// Path: `/2010-04-01/Accounts.json`
        public let path: String

        /// Retrieves a collection of Accounts belonging to the account used to make the request
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListAccountResponse
        public struct GetResponse: Decodable {
            public var accounts: [TwilioAPI.APIV2010Account]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(accounts: [TwilioAPI.APIV2010Account]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.accounts = accounts
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case accounts
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var friendlyName: String?
            public var status: Status?
            public var pageSize: Int?

            public enum Status: String, Codable, CaseIterable {
                case active
                case suspended
                case closed
            }

            public init(friendlyName: String? = nil, status: Status? = nil, pageSize: Int? = nil) {
                self.friendlyName = friendlyName
                self.status = status
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("Status", status?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }

        /// Create a new Twilio Subaccount from the account making the request
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010Account> {
            .post(path, body: body?.asQuery())
        }

        /// CreateAccountRequest
        public struct PostRequest: Encodable {
            /// A human readable description of the account to create, defaults to `SubAccount Created at {YYYY-MM-DD HH:MM meridian}`
            public var friendlyName: String?

            public init(friendlyName: String? = nil) {
                self.friendlyName = friendlyName
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths {
    public static var accounts: Accounts {
        Accounts(path: "/2010-04-01/Accounts")
    }

    public struct Accounts {
        /// Path: `/2010-04-01/Accounts`
        public let path: String
    }
}

extension Paths.Accounts {
    public func accountSid(_ accountSid: String) -> WithAccountSid {
        WithAccountSid(path: "\(path)/\(accountSid)")
    }

    public struct WithAccountSid {
        /// Path: `/2010-04-01/Accounts/{AccountSid}`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid {
    public var addressesJSON: AddressesJSON {
        AddressesJSON(path: path + "/Addresses.json")
    }

    public struct AddressesJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Addresses.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListAddressResponse
        public struct GetResponse: Decodable {
            public var addresses: [TwilioAPI.APIV2010AccountAddress]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(addresses: [TwilioAPI.APIV2010AccountAddress]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.addresses = addresses
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case addresses
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var customerName: String?
            public var friendlyName: String?
            public var isoCountry: String?
            public var pageSize: Int?

            public init(customerName: String? = nil, friendlyName: String? = nil, isoCountry: String? = nil, pageSize: Int? = nil) {
                self.customerName = customerName
                self.friendlyName = friendlyName
                self.isoCountry = isoCountry
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("CustomerName", customerName?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("IsoCountry", isoCountry?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }

        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountAddress> {
            .post(path, body: body?.asQuery())
        }

        /// CreateAddressRequest
        public struct PostRequest: Encodable {
            /// Whether we should automatically correct the address. Can be: `true` or `false` and the default is `true`. If empty or `true`, we will correct the address you provide if necessary. If `false`, we won't alter the address you provide.
            public var isAutoCorrectAddress: Bool?
            /// The city of the new address.
            public var city: String
            /// The name to associate with the new address.
            public var customerName: String
            /// Whether to enable emergency calling on the new address. Can be: `true` or `false`.
            public var isEmergencyEnabled: Bool?
            /// A descriptive string that you create to describe the new address. It can be up to 64 characters long.
            public var friendlyName: String?
            /// The ISO country code of the new address.
            public var isoCountry: String
            /// The postal code of the new address.
            public var postalCode: String
            /// The state or region of the new address.
            public var region: String
            /// The number and street address of the new address.
            public var street: String

            public init(isAutoCorrectAddress: Bool? = nil, city: String, customerName: String, isEmergencyEnabled: Bool? = nil, friendlyName: String? = nil, isoCountry: String, postalCode: String, region: String, street: String) {
                self.isAutoCorrectAddress = isAutoCorrectAddress
                self.city = city
                self.customerName = customerName
                self.isEmergencyEnabled = isEmergencyEnabled
                self.friendlyName = friendlyName
                self.isoCountry = isoCountry
                self.postalCode = postalCode
                self.region = region
                self.street = street
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("AutoCorrectAddress", isAutoCorrectAddress?.asQueryValue)
                query.addQueryItem("City", city.asQueryValue)
                query.addQueryItem("CustomerName", customerName.asQueryValue)
                query.addQueryItem("EmergencyEnabled", isEmergencyEnabled?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("IsoCountry", isoCountry.asQueryValue)
                query.addQueryItem("PostalCode", postalCode.asQueryValue)
                query.addQueryItem("Region", region.asQueryValue)
                query.addQueryItem("Street", street.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var addresses: Addresses {
        Addresses(path: path + "/Addresses")
    }

    public struct Addresses {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Addresses`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Addresses {
    public func addressSid(_ addressSid: String) -> WithAddressSid {
        WithAddressSid(path: "\(path)/\(addressSid)")
    }

    public struct WithAddressSid {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Addresses/{AddressSid}`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Addresses.WithAddressSid {
    public var dependentPhoneNumbersJSON: DependentPhoneNumbersJSON {
        DependentPhoneNumbersJSON(path: path + "/DependentPhoneNumbers.json")
    }

    public struct DependentPhoneNumbersJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Addresses/{AddressSid}/DependentPhoneNumbers.json`
        public let path: String

        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListDependentPhoneNumberResponse
        public struct GetResponse: Decodable {
            public var dependentPhoneNumbers: [TwilioAPI.APIV2010AccountAddressDependentPhoneNumber]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(dependentPhoneNumbers: [TwilioAPI.APIV2010AccountAddressDependentPhoneNumber]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.dependentPhoneNumbers = dependentPhoneNumbers
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case dependentPhoneNumbers = "dependent_phone_numbers"
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }
    }
}

extension Paths.Accounts.WithAccountSid.Addresses {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json`
        public let path: String

        public var get: Request<TwilioAPI.APIV2010AccountAddress> {
            .get(path)
        }

        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountAddress> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateAddressRequest
        public struct PostRequest: Encodable {
            /// Whether we should automatically correct the address. Can be: `true` or `false` and the default is `true`. If empty or `true`, we will correct the address you provide if necessary. If `false`, we won't alter the address you provide.
            public var isAutoCorrectAddress: Bool?
            /// The city of the address.
            public var city: String?
            /// The name to associate with the address.
            public var customerName: String?
            /// Whether to enable emergency calling on the address. Can be: `true` or `false`.
            public var isEmergencyEnabled: Bool?
            /// A descriptive string that you create to describe the address. It can be up to 64 characters long.
            public var friendlyName: String?
            /// The postal code of the address.
            public var postalCode: String?
            /// The state or region of the address.
            public var region: String?
            /// The number and street address of the address.
            public var street: String?

            public init(isAutoCorrectAddress: Bool? = nil, city: String? = nil, customerName: String? = nil, isEmergencyEnabled: Bool? = nil, friendlyName: String? = nil, postalCode: String? = nil, region: String? = nil, street: String? = nil) {
                self.isAutoCorrectAddress = isAutoCorrectAddress
                self.city = city
                self.customerName = customerName
                self.isEmergencyEnabled = isEmergencyEnabled
                self.friendlyName = friendlyName
                self.postalCode = postalCode
                self.region = region
                self.street = street
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("AutoCorrectAddress", isAutoCorrectAddress?.asQueryValue)
                query.addQueryItem("City", city?.asQueryValue)
                query.addQueryItem("CustomerName", customerName?.asQueryValue)
                query.addQueryItem("EmergencyEnabled", isEmergencyEnabled?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("PostalCode", postalCode?.asQueryValue)
                query.addQueryItem("Region", region?.asQueryValue)
                query.addQueryItem("Street", street?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var applicationsJSON: ApplicationsJSON {
        ApplicationsJSON(path: path + "/Applications.json")
    }

    public struct ApplicationsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Applications.json`
        public let path: String

        /// Retrieve a list of applications representing an application within the requesting account
        public func get(friendlyName: String? = nil, pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(friendlyName, pageSize))
        }

        /// ListApplicationResponse
        public struct GetResponse: Decodable {
            public var applications: [TwilioAPI.APIV2010AccountApplication]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(applications: [TwilioAPI.APIV2010AccountApplication]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.applications = applications
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case applications
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ friendlyName: String?, _ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }

        /// Create a new application within your account
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountApplication> {
            .post(path, body: body?.asQuery())
        }

        /// CreateApplicationRequest
        public struct PostRequest: Encodable {
            /// The API version to use to start a new TwiML session. Can be: `2010-04-01` or `2008-08-01`. The default value is the account's default API version.
            public var apiVersion: String?
            /// A descriptive string that you create to describe the new application. It can be up to 64 characters long.
            public var friendlyName: String?
            /// The URL we should call using a POST method to send message status information to your application.
            public var messageStatusCallback: URL?
            /// The HTTP method we should use to call `sms_fallback_url`. Can be: `GET` or `POST`.
            public var smsFallbackMethod: SmsFallbackMethod?
            /// The URL that we should call when an error occurs while retrieving or executing the TwiML from `sms_url`.
            public var smsFallbackURL: URL?
            /// The HTTP method we should use to call `sms_url`. Can be: `GET` or `POST`.
            public var smsMethod: SmsMethod?
            /// The URL we should call using a POST method to send status information about SMS messages sent by the application.
            public var smsStatusCallback: URL?
            /// The URL we should call when the phone number receives an incoming SMS message.
            public var smsURL: URL?
            /// The URL we should call using the `status_callback_method` to send status information to your application.
            public var statusCallback: URL?
            /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST`.
            public var statusCallbackMethod: StatusCallbackMethod?
            /// Whether we should look up the caller's caller-ID name from the CNAM database (additional charges apply). Can be: `true` or `false`.
            public var isVoiceCallerIDLookup: Bool?
            /// The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`.
            public var voiceFallbackMethod: VoiceFallbackMethod?
            /// The URL that we should call when an error occurs retrieving or executing the TwiML requested by `url`.
            public var voiceFallbackURL: URL?
            /// The HTTP method we should use to call `voice_url`. Can be: `GET` or `POST`.
            public var voiceMethod: VoiceMethod?
            /// The URL we should call when the phone number assigned to this application receives a call.
            public var voiceURL: URL?

            /// The HTTP method we should use to call `sms_fallback_url`. Can be: `GET` or `POST`.
            public enum SmsFallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `sms_url`. Can be: `GET` or `POST`.
            public enum SmsMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST`.
            public enum StatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`.
            public enum VoiceFallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `voice_url`. Can be: `GET` or `POST`.
            public enum VoiceMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            public init(apiVersion: String? = nil, friendlyName: String? = nil, messageStatusCallback: URL? = nil, smsFallbackMethod: SmsFallbackMethod? = nil, smsFallbackURL: URL? = nil, smsMethod: SmsMethod? = nil, smsStatusCallback: URL? = nil, smsURL: URL? = nil, statusCallback: URL? = nil, statusCallbackMethod: StatusCallbackMethod? = nil, isVoiceCallerIDLookup: Bool? = nil, voiceFallbackMethod: VoiceFallbackMethod? = nil, voiceFallbackURL: URL? = nil, voiceMethod: VoiceMethod? = nil, voiceURL: URL? = nil) {
                self.apiVersion = apiVersion
                self.friendlyName = friendlyName
                self.messageStatusCallback = messageStatusCallback
                self.smsFallbackMethod = smsFallbackMethod
                self.smsFallbackURL = smsFallbackURL
                self.smsMethod = smsMethod
                self.smsStatusCallback = smsStatusCallback
                self.smsURL = smsURL
                self.statusCallback = statusCallback
                self.statusCallbackMethod = statusCallbackMethod
                self.isVoiceCallerIDLookup = isVoiceCallerIDLookup
                self.voiceFallbackMethod = voiceFallbackMethod
                self.voiceFallbackURL = voiceFallbackURL
                self.voiceMethod = voiceMethod
                self.voiceURL = voiceURL
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("ApiVersion", apiVersion?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("MessageStatusCallback", messageStatusCallback?.asQueryValue)
                query.addQueryItem("SmsFallbackMethod", smsFallbackMethod?.asQueryValue)
                query.addQueryItem("SmsFallbackUrl", smsFallbackURL?.asQueryValue)
                query.addQueryItem("SmsMethod", smsMethod?.asQueryValue)
                query.addQueryItem("SmsStatusCallback", smsStatusCallback?.asQueryValue)
                query.addQueryItem("SmsUrl", smsURL?.asQueryValue)
                query.addQueryItem("StatusCallback", statusCallback?.asQueryValue)
                query.addQueryItem("StatusCallbackMethod", statusCallbackMethod?.asQueryValue)
                query.addQueryItem("VoiceCallerIdLookup", isVoiceCallerIDLookup?.asQueryValue)
                query.addQueryItem("VoiceFallbackMethod", voiceFallbackMethod?.asQueryValue)
                query.addQueryItem("VoiceFallbackUrl", voiceFallbackURL?.asQueryValue)
                query.addQueryItem("VoiceMethod", voiceMethod?.asQueryValue)
                query.addQueryItem("VoiceUrl", voiceURL?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var applications: Applications {
        Applications(path: path + "/Applications")
    }

    public struct Applications {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Applications`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Applications {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json`
        public let path: String

        /// Fetch the application specified by the provided sid
        public var get: Request<TwilioAPI.APIV2010AccountApplication> {
            .get(path)
        }

        /// Updates the application's properties
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountApplication> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateApplicationRequest
        public struct PostRequest: Encodable {
            /// The API version to use to start a new TwiML session. Can be: `2010-04-01` or `2008-08-01`. The default value is your account's default API version.
            public var apiVersion: String?
            /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
            public var friendlyName: String?
            /// The URL we should call using a POST method to send message status information to your application.
            public var messageStatusCallback: URL?
            /// The HTTP method we should use to call `sms_fallback_url`. Can be: `GET` or `POST`.
            public var smsFallbackMethod: SmsFallbackMethod?
            /// The URL that we should call when an error occurs while retrieving or executing the TwiML from `sms_url`.
            public var smsFallbackURL: URL?
            /// The HTTP method we should use to call `sms_url`. Can be: `GET` or `POST`.
            public var smsMethod: SmsMethod?
            /// Same as message_status_callback: The URL we should call using a POST method to send status information about SMS messages sent by the application. Deprecated, included for backwards compatibility.
            public var smsStatusCallback: URL?
            /// The URL we should call when the phone number receives an incoming SMS message.
            public var smsURL: URL?
            /// The URL we should call using the `status_callback_method` to send status information to your application.
            public var statusCallback: URL?
            /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST`.
            public var statusCallbackMethod: StatusCallbackMethod?
            /// Whether we should look up the caller's caller-ID name from the CNAM database (additional charges apply). Can be: `true` or `false`.
            public var isVoiceCallerIDLookup: Bool?
            /// The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`.
            public var voiceFallbackMethod: VoiceFallbackMethod?
            /// The URL that we should call when an error occurs retrieving or executing the TwiML requested by `url`.
            public var voiceFallbackURL: URL?
            /// The HTTP method we should use to call `voice_url`. Can be: `GET` or `POST`.
            public var voiceMethod: VoiceMethod?
            /// The URL we should call when the phone number assigned to this application receives a call.
            public var voiceURL: URL?

            /// The HTTP method we should use to call `sms_fallback_url`. Can be: `GET` or `POST`.
            public enum SmsFallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `sms_url`. Can be: `GET` or `POST`.
            public enum SmsMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST`.
            public enum StatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`.
            public enum VoiceFallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `voice_url`. Can be: `GET` or `POST`.
            public enum VoiceMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            public init(apiVersion: String? = nil, friendlyName: String? = nil, messageStatusCallback: URL? = nil, smsFallbackMethod: SmsFallbackMethod? = nil, smsFallbackURL: URL? = nil, smsMethod: SmsMethod? = nil, smsStatusCallback: URL? = nil, smsURL: URL? = nil, statusCallback: URL? = nil, statusCallbackMethod: StatusCallbackMethod? = nil, isVoiceCallerIDLookup: Bool? = nil, voiceFallbackMethod: VoiceFallbackMethod? = nil, voiceFallbackURL: URL? = nil, voiceMethod: VoiceMethod? = nil, voiceURL: URL? = nil) {
                self.apiVersion = apiVersion
                self.friendlyName = friendlyName
                self.messageStatusCallback = messageStatusCallback
                self.smsFallbackMethod = smsFallbackMethod
                self.smsFallbackURL = smsFallbackURL
                self.smsMethod = smsMethod
                self.smsStatusCallback = smsStatusCallback
                self.smsURL = smsURL
                self.statusCallback = statusCallback
                self.statusCallbackMethod = statusCallbackMethod
                self.isVoiceCallerIDLookup = isVoiceCallerIDLookup
                self.voiceFallbackMethod = voiceFallbackMethod
                self.voiceFallbackURL = voiceFallbackURL
                self.voiceMethod = voiceMethod
                self.voiceURL = voiceURL
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("ApiVersion", apiVersion?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("MessageStatusCallback", messageStatusCallback?.asQueryValue)
                query.addQueryItem("SmsFallbackMethod", smsFallbackMethod?.asQueryValue)
                query.addQueryItem("SmsFallbackUrl", smsFallbackURL?.asQueryValue)
                query.addQueryItem("SmsMethod", smsMethod?.asQueryValue)
                query.addQueryItem("SmsStatusCallback", smsStatusCallback?.asQueryValue)
                query.addQueryItem("SmsUrl", smsURL?.asQueryValue)
                query.addQueryItem("StatusCallback", statusCallback?.asQueryValue)
                query.addQueryItem("StatusCallbackMethod", statusCallbackMethod?.asQueryValue)
                query.addQueryItem("VoiceCallerIdLookup", isVoiceCallerIDLookup?.asQueryValue)
                query.addQueryItem("VoiceFallbackMethod", voiceFallbackMethod?.asQueryValue)
                query.addQueryItem("VoiceFallbackUrl", voiceFallbackURL?.asQueryValue)
                query.addQueryItem("VoiceMethod", voiceMethod?.asQueryValue)
                query.addQueryItem("VoiceUrl", voiceURL?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }

        /// Delete the application by the specified application sid
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var authorizedConnectAppsJSON: AuthorizedConnectAppsJSON {
        AuthorizedConnectAppsJSON(path: path + "/AuthorizedConnectApps.json")
    }

    public struct AuthorizedConnectAppsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/AuthorizedConnectApps.json`
        public let path: String

        /// Retrieve a list of authorized-connect-apps belonging to the account used to make the request
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListAuthorizedConnectAppResponse
        public struct GetResponse: Decodable {
            public var authorizedConnectApps: [TwilioAPI.APIV2010AccountAuthorizedConnectApp]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(authorizedConnectApps: [TwilioAPI.APIV2010AccountAuthorizedConnectApp]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.authorizedConnectApps = authorizedConnectApps
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case authorizedConnectApps = "authorized_connect_apps"
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var authorizedConnectApps: AuthorizedConnectApps {
        AuthorizedConnectApps(path: path + "/AuthorizedConnectApps")
    }

    public struct AuthorizedConnectApps {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/AuthorizedConnectApps`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.AuthorizedConnectApps {
    public func connectAppSid(_ connectAppSid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(connectAppSid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/AuthorizedConnectApps/{ConnectAppSid}.json`
        public let path: String

        /// Fetch an instance of an authorized-connect-app
        public var get: Request<TwilioAPI.APIV2010AccountAuthorizedConnectApp> {
            .get(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var availablePhoneNumbersJSON: AvailablePhoneNumbersJSON {
        AvailablePhoneNumbersJSON(path: path + "/AvailablePhoneNumbers.json")
    }

    public struct AvailablePhoneNumbersJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers.json`
        public let path: String

        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListAvailablePhoneNumberCountryResponse
        public struct GetResponse: Decodable {
            public var countries: [TwilioAPI.APIV2010AccountAvailablePhoneNumberCountry]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(countries: [TwilioAPI.APIV2010AccountAvailablePhoneNumberCountry]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.countries = countries
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case countries
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var availablePhoneNumbers: AvailablePhoneNumbers {
        AvailablePhoneNumbers(path: path + "/AvailablePhoneNumbers")
    }

    public struct AvailablePhoneNumbers {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.AvailablePhoneNumbers {
    public func countryCode(_ countryCode: String) -> WithJSON {
        WithJSON(path: "\(path)/\(countryCode).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}.json`
        public let path: String

        public var get: Request<TwilioAPI.APIV2010AccountAvailablePhoneNumberCountry> {
            .get(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.AvailablePhoneNumbers {
    public func countryCode(_ countryCode: String) -> WithCountryCode {
        WithCountryCode(path: "\(path)/\(countryCode)")
    }

    public struct WithCountryCode {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.AvailablePhoneNumbers.WithCountryCode {
    public var localJSON: LocalJSON {
        LocalJSON(path: path + "/Local.json")
    }

    public struct LocalJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Local.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListAvailablePhoneNumberLocalResponse
        public struct GetResponse: Decodable {
            public var availablePhoneNumbers: [TwilioAPI.APIV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberLocal]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(availablePhoneNumbers: [TwilioAPI.APIV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberLocal]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.availablePhoneNumbers = availablePhoneNumbers
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case availablePhoneNumbers = "available_phone_numbers"
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var areaCode: Int?
            public var contains: String?
            public var isSmsEnabled: Bool?
            public var isMmsEnabled: Bool?
            public var isVoiceEnabled: Bool?
            public var excludeAllAddressRequired: Bool?
            public var excludeLocalAddressRequired: Bool?
            public var excludeForeignAddressRequired: Bool?
            public var isBeta: Bool?
            public var nearNumber: String?
            public var nearLatLong: String?
            public var distance: Int?
            public var inPostalCode: String?
            public var inRegion: String?
            public var inRateCenter: String?
            public var inLata: String?
            public var inLocality: String?
            public var isFaxEnabled: Bool?
            public var pageSize: Int?

            public init(areaCode: Int? = nil, contains: String? = nil, isSmsEnabled: Bool? = nil, isMmsEnabled: Bool? = nil, isVoiceEnabled: Bool? = nil, excludeAllAddressRequired: Bool? = nil, excludeLocalAddressRequired: Bool? = nil, excludeForeignAddressRequired: Bool? = nil, isBeta: Bool? = nil, nearNumber: String? = nil, nearLatLong: String? = nil, distance: Int? = nil, inPostalCode: String? = nil, inRegion: String? = nil, inRateCenter: String? = nil, inLata: String? = nil, inLocality: String? = nil, isFaxEnabled: Bool? = nil, pageSize: Int? = nil) {
                self.areaCode = areaCode
                self.contains = contains
                self.isSmsEnabled = isSmsEnabled
                self.isMmsEnabled = isMmsEnabled
                self.isVoiceEnabled = isVoiceEnabled
                self.excludeAllAddressRequired = excludeAllAddressRequired
                self.excludeLocalAddressRequired = excludeLocalAddressRequired
                self.excludeForeignAddressRequired = excludeForeignAddressRequired
                self.isBeta = isBeta
                self.nearNumber = nearNumber
                self.nearLatLong = nearLatLong
                self.distance = distance
                self.inPostalCode = inPostalCode
                self.inRegion = inRegion
                self.inRateCenter = inRateCenter
                self.inLata = inLata
                self.inLocality = inLocality
                self.isFaxEnabled = isFaxEnabled
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("AreaCode", areaCode?.asQueryValue)
                query.addQueryItem("Contains", contains?.asQueryValue)
                query.addQueryItem("SmsEnabled", isSmsEnabled?.asQueryValue)
                query.addQueryItem("MmsEnabled", isMmsEnabled?.asQueryValue)
                query.addQueryItem("VoiceEnabled", isVoiceEnabled?.asQueryValue)
                query.addQueryItem("ExcludeAllAddressRequired", excludeAllAddressRequired?.asQueryValue)
                query.addQueryItem("ExcludeLocalAddressRequired", excludeLocalAddressRequired?.asQueryValue)
                query.addQueryItem("ExcludeForeignAddressRequired", excludeForeignAddressRequired?.asQueryValue)
                query.addQueryItem("Beta", isBeta?.asQueryValue)
                query.addQueryItem("NearNumber", nearNumber?.asQueryValue)
                query.addQueryItem("NearLatLong", nearLatLong?.asQueryValue)
                query.addQueryItem("Distance", distance?.asQueryValue)
                query.addQueryItem("InPostalCode", inPostalCode?.asQueryValue)
                query.addQueryItem("InRegion", inRegion?.asQueryValue)
                query.addQueryItem("InRateCenter", inRateCenter?.asQueryValue)
                query.addQueryItem("InLata", inLata?.asQueryValue)
                query.addQueryItem("InLocality", inLocality?.asQueryValue)
                query.addQueryItem("FaxEnabled", isFaxEnabled?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.AvailablePhoneNumbers.WithCountryCode {
    public var machineToMachineJSON: MachineToMachineJSON {
        MachineToMachineJSON(path: path + "/MachineToMachine.json")
    }

    public struct MachineToMachineJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/MachineToMachine.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListAvailablePhoneNumberMachineToMachineResponse
        public struct GetResponse: Decodable {
            public var availablePhoneNumbers: [TwilioAPI.APIV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberMachineToMachine]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(availablePhoneNumbers: [TwilioAPI.APIV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberMachineToMachine]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.availablePhoneNumbers = availablePhoneNumbers
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case availablePhoneNumbers = "available_phone_numbers"
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var areaCode: Int?
            public var contains: String?
            public var isSmsEnabled: Bool?
            public var isMmsEnabled: Bool?
            public var isVoiceEnabled: Bool?
            public var excludeAllAddressRequired: Bool?
            public var excludeLocalAddressRequired: Bool?
            public var excludeForeignAddressRequired: Bool?
            public var isBeta: Bool?
            public var nearNumber: String?
            public var nearLatLong: String?
            public var distance: Int?
            public var inPostalCode: String?
            public var inRegion: String?
            public var inRateCenter: String?
            public var inLata: String?
            public var inLocality: String?
            public var isFaxEnabled: Bool?
            public var pageSize: Int?

            public init(areaCode: Int? = nil, contains: String? = nil, isSmsEnabled: Bool? = nil, isMmsEnabled: Bool? = nil, isVoiceEnabled: Bool? = nil, excludeAllAddressRequired: Bool? = nil, excludeLocalAddressRequired: Bool? = nil, excludeForeignAddressRequired: Bool? = nil, isBeta: Bool? = nil, nearNumber: String? = nil, nearLatLong: String? = nil, distance: Int? = nil, inPostalCode: String? = nil, inRegion: String? = nil, inRateCenter: String? = nil, inLata: String? = nil, inLocality: String? = nil, isFaxEnabled: Bool? = nil, pageSize: Int? = nil) {
                self.areaCode = areaCode
                self.contains = contains
                self.isSmsEnabled = isSmsEnabled
                self.isMmsEnabled = isMmsEnabled
                self.isVoiceEnabled = isVoiceEnabled
                self.excludeAllAddressRequired = excludeAllAddressRequired
                self.excludeLocalAddressRequired = excludeLocalAddressRequired
                self.excludeForeignAddressRequired = excludeForeignAddressRequired
                self.isBeta = isBeta
                self.nearNumber = nearNumber
                self.nearLatLong = nearLatLong
                self.distance = distance
                self.inPostalCode = inPostalCode
                self.inRegion = inRegion
                self.inRateCenter = inRateCenter
                self.inLata = inLata
                self.inLocality = inLocality
                self.isFaxEnabled = isFaxEnabled
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("AreaCode", areaCode?.asQueryValue)
                query.addQueryItem("Contains", contains?.asQueryValue)
                query.addQueryItem("SmsEnabled", isSmsEnabled?.asQueryValue)
                query.addQueryItem("MmsEnabled", isMmsEnabled?.asQueryValue)
                query.addQueryItem("VoiceEnabled", isVoiceEnabled?.asQueryValue)
                query.addQueryItem("ExcludeAllAddressRequired", excludeAllAddressRequired?.asQueryValue)
                query.addQueryItem("ExcludeLocalAddressRequired", excludeLocalAddressRequired?.asQueryValue)
                query.addQueryItem("ExcludeForeignAddressRequired", excludeForeignAddressRequired?.asQueryValue)
                query.addQueryItem("Beta", isBeta?.asQueryValue)
                query.addQueryItem("NearNumber", nearNumber?.asQueryValue)
                query.addQueryItem("NearLatLong", nearLatLong?.asQueryValue)
                query.addQueryItem("Distance", distance?.asQueryValue)
                query.addQueryItem("InPostalCode", inPostalCode?.asQueryValue)
                query.addQueryItem("InRegion", inRegion?.asQueryValue)
                query.addQueryItem("InRateCenter", inRateCenter?.asQueryValue)
                query.addQueryItem("InLata", inLata?.asQueryValue)
                query.addQueryItem("InLocality", inLocality?.asQueryValue)
                query.addQueryItem("FaxEnabled", isFaxEnabled?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.AvailablePhoneNumbers.WithCountryCode {
    public var mobileJSON: MobileJSON {
        MobileJSON(path: path + "/Mobile.json")
    }

    public struct MobileJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Mobile.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListAvailablePhoneNumberMobileResponse
        public struct GetResponse: Decodable {
            public var availablePhoneNumbers: [TwilioAPI.APIV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberMobile]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(availablePhoneNumbers: [TwilioAPI.APIV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberMobile]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.availablePhoneNumbers = availablePhoneNumbers
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case availablePhoneNumbers = "available_phone_numbers"
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var areaCode: Int?
            public var contains: String?
            public var isSmsEnabled: Bool?
            public var isMmsEnabled: Bool?
            public var isVoiceEnabled: Bool?
            public var excludeAllAddressRequired: Bool?
            public var excludeLocalAddressRequired: Bool?
            public var excludeForeignAddressRequired: Bool?
            public var isBeta: Bool?
            public var nearNumber: String?
            public var nearLatLong: String?
            public var distance: Int?
            public var inPostalCode: String?
            public var inRegion: String?
            public var inRateCenter: String?
            public var inLata: String?
            public var inLocality: String?
            public var isFaxEnabled: Bool?
            public var pageSize: Int?

            public init(areaCode: Int? = nil, contains: String? = nil, isSmsEnabled: Bool? = nil, isMmsEnabled: Bool? = nil, isVoiceEnabled: Bool? = nil, excludeAllAddressRequired: Bool? = nil, excludeLocalAddressRequired: Bool? = nil, excludeForeignAddressRequired: Bool? = nil, isBeta: Bool? = nil, nearNumber: String? = nil, nearLatLong: String? = nil, distance: Int? = nil, inPostalCode: String? = nil, inRegion: String? = nil, inRateCenter: String? = nil, inLata: String? = nil, inLocality: String? = nil, isFaxEnabled: Bool? = nil, pageSize: Int? = nil) {
                self.areaCode = areaCode
                self.contains = contains
                self.isSmsEnabled = isSmsEnabled
                self.isMmsEnabled = isMmsEnabled
                self.isVoiceEnabled = isVoiceEnabled
                self.excludeAllAddressRequired = excludeAllAddressRequired
                self.excludeLocalAddressRequired = excludeLocalAddressRequired
                self.excludeForeignAddressRequired = excludeForeignAddressRequired
                self.isBeta = isBeta
                self.nearNumber = nearNumber
                self.nearLatLong = nearLatLong
                self.distance = distance
                self.inPostalCode = inPostalCode
                self.inRegion = inRegion
                self.inRateCenter = inRateCenter
                self.inLata = inLata
                self.inLocality = inLocality
                self.isFaxEnabled = isFaxEnabled
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("AreaCode", areaCode?.asQueryValue)
                query.addQueryItem("Contains", contains?.asQueryValue)
                query.addQueryItem("SmsEnabled", isSmsEnabled?.asQueryValue)
                query.addQueryItem("MmsEnabled", isMmsEnabled?.asQueryValue)
                query.addQueryItem("VoiceEnabled", isVoiceEnabled?.asQueryValue)
                query.addQueryItem("ExcludeAllAddressRequired", excludeAllAddressRequired?.asQueryValue)
                query.addQueryItem("ExcludeLocalAddressRequired", excludeLocalAddressRequired?.asQueryValue)
                query.addQueryItem("ExcludeForeignAddressRequired", excludeForeignAddressRequired?.asQueryValue)
                query.addQueryItem("Beta", isBeta?.asQueryValue)
                query.addQueryItem("NearNumber", nearNumber?.asQueryValue)
                query.addQueryItem("NearLatLong", nearLatLong?.asQueryValue)
                query.addQueryItem("Distance", distance?.asQueryValue)
                query.addQueryItem("InPostalCode", inPostalCode?.asQueryValue)
                query.addQueryItem("InRegion", inRegion?.asQueryValue)
                query.addQueryItem("InRateCenter", inRateCenter?.asQueryValue)
                query.addQueryItem("InLata", inLata?.asQueryValue)
                query.addQueryItem("InLocality", inLocality?.asQueryValue)
                query.addQueryItem("FaxEnabled", isFaxEnabled?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.AvailablePhoneNumbers.WithCountryCode {
    public var nationalJSON: NationalJSON {
        NationalJSON(path: path + "/National.json")
    }

    public struct NationalJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/National.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListAvailablePhoneNumberNationalResponse
        public struct GetResponse: Decodable {
            public var availablePhoneNumbers: [TwilioAPI.APIV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberNational]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(availablePhoneNumbers: [TwilioAPI.APIV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberNational]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.availablePhoneNumbers = availablePhoneNumbers
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case availablePhoneNumbers = "available_phone_numbers"
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var areaCode: Int?
            public var contains: String?
            public var isSmsEnabled: Bool?
            public var isMmsEnabled: Bool?
            public var isVoiceEnabled: Bool?
            public var excludeAllAddressRequired: Bool?
            public var excludeLocalAddressRequired: Bool?
            public var excludeForeignAddressRequired: Bool?
            public var isBeta: Bool?
            public var nearNumber: String?
            public var nearLatLong: String?
            public var distance: Int?
            public var inPostalCode: String?
            public var inRegion: String?
            public var inRateCenter: String?
            public var inLata: String?
            public var inLocality: String?
            public var isFaxEnabled: Bool?
            public var pageSize: Int?

            public init(areaCode: Int? = nil, contains: String? = nil, isSmsEnabled: Bool? = nil, isMmsEnabled: Bool? = nil, isVoiceEnabled: Bool? = nil, excludeAllAddressRequired: Bool? = nil, excludeLocalAddressRequired: Bool? = nil, excludeForeignAddressRequired: Bool? = nil, isBeta: Bool? = nil, nearNumber: String? = nil, nearLatLong: String? = nil, distance: Int? = nil, inPostalCode: String? = nil, inRegion: String? = nil, inRateCenter: String? = nil, inLata: String? = nil, inLocality: String? = nil, isFaxEnabled: Bool? = nil, pageSize: Int? = nil) {
                self.areaCode = areaCode
                self.contains = contains
                self.isSmsEnabled = isSmsEnabled
                self.isMmsEnabled = isMmsEnabled
                self.isVoiceEnabled = isVoiceEnabled
                self.excludeAllAddressRequired = excludeAllAddressRequired
                self.excludeLocalAddressRequired = excludeLocalAddressRequired
                self.excludeForeignAddressRequired = excludeForeignAddressRequired
                self.isBeta = isBeta
                self.nearNumber = nearNumber
                self.nearLatLong = nearLatLong
                self.distance = distance
                self.inPostalCode = inPostalCode
                self.inRegion = inRegion
                self.inRateCenter = inRateCenter
                self.inLata = inLata
                self.inLocality = inLocality
                self.isFaxEnabled = isFaxEnabled
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("AreaCode", areaCode?.asQueryValue)
                query.addQueryItem("Contains", contains?.asQueryValue)
                query.addQueryItem("SmsEnabled", isSmsEnabled?.asQueryValue)
                query.addQueryItem("MmsEnabled", isMmsEnabled?.asQueryValue)
                query.addQueryItem("VoiceEnabled", isVoiceEnabled?.asQueryValue)
                query.addQueryItem("ExcludeAllAddressRequired", excludeAllAddressRequired?.asQueryValue)
                query.addQueryItem("ExcludeLocalAddressRequired", excludeLocalAddressRequired?.asQueryValue)
                query.addQueryItem("ExcludeForeignAddressRequired", excludeForeignAddressRequired?.asQueryValue)
                query.addQueryItem("Beta", isBeta?.asQueryValue)
                query.addQueryItem("NearNumber", nearNumber?.asQueryValue)
                query.addQueryItem("NearLatLong", nearLatLong?.asQueryValue)
                query.addQueryItem("Distance", distance?.asQueryValue)
                query.addQueryItem("InPostalCode", inPostalCode?.asQueryValue)
                query.addQueryItem("InRegion", inRegion?.asQueryValue)
                query.addQueryItem("InRateCenter", inRateCenter?.asQueryValue)
                query.addQueryItem("InLata", inLata?.asQueryValue)
                query.addQueryItem("InLocality", inLocality?.asQueryValue)
                query.addQueryItem("FaxEnabled", isFaxEnabled?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.AvailablePhoneNumbers.WithCountryCode {
    public var sharedCostJSON: SharedCostJSON {
        SharedCostJSON(path: path + "/SharedCost.json")
    }

    public struct SharedCostJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/SharedCost.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListAvailablePhoneNumberSharedCostResponse
        public struct GetResponse: Decodable {
            public var availablePhoneNumbers: [TwilioAPI.APIV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberSharedCost]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(availablePhoneNumbers: [TwilioAPI.APIV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberSharedCost]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.availablePhoneNumbers = availablePhoneNumbers
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case availablePhoneNumbers = "available_phone_numbers"
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var areaCode: Int?
            public var contains: String?
            public var isSmsEnabled: Bool?
            public var isMmsEnabled: Bool?
            public var isVoiceEnabled: Bool?
            public var excludeAllAddressRequired: Bool?
            public var excludeLocalAddressRequired: Bool?
            public var excludeForeignAddressRequired: Bool?
            public var isBeta: Bool?
            public var nearNumber: String?
            public var nearLatLong: String?
            public var distance: Int?
            public var inPostalCode: String?
            public var inRegion: String?
            public var inRateCenter: String?
            public var inLata: String?
            public var inLocality: String?
            public var isFaxEnabled: Bool?
            public var pageSize: Int?

            public init(areaCode: Int? = nil, contains: String? = nil, isSmsEnabled: Bool? = nil, isMmsEnabled: Bool? = nil, isVoiceEnabled: Bool? = nil, excludeAllAddressRequired: Bool? = nil, excludeLocalAddressRequired: Bool? = nil, excludeForeignAddressRequired: Bool? = nil, isBeta: Bool? = nil, nearNumber: String? = nil, nearLatLong: String? = nil, distance: Int? = nil, inPostalCode: String? = nil, inRegion: String? = nil, inRateCenter: String? = nil, inLata: String? = nil, inLocality: String? = nil, isFaxEnabled: Bool? = nil, pageSize: Int? = nil) {
                self.areaCode = areaCode
                self.contains = contains
                self.isSmsEnabled = isSmsEnabled
                self.isMmsEnabled = isMmsEnabled
                self.isVoiceEnabled = isVoiceEnabled
                self.excludeAllAddressRequired = excludeAllAddressRequired
                self.excludeLocalAddressRequired = excludeLocalAddressRequired
                self.excludeForeignAddressRequired = excludeForeignAddressRequired
                self.isBeta = isBeta
                self.nearNumber = nearNumber
                self.nearLatLong = nearLatLong
                self.distance = distance
                self.inPostalCode = inPostalCode
                self.inRegion = inRegion
                self.inRateCenter = inRateCenter
                self.inLata = inLata
                self.inLocality = inLocality
                self.isFaxEnabled = isFaxEnabled
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("AreaCode", areaCode?.asQueryValue)
                query.addQueryItem("Contains", contains?.asQueryValue)
                query.addQueryItem("SmsEnabled", isSmsEnabled?.asQueryValue)
                query.addQueryItem("MmsEnabled", isMmsEnabled?.asQueryValue)
                query.addQueryItem("VoiceEnabled", isVoiceEnabled?.asQueryValue)
                query.addQueryItem("ExcludeAllAddressRequired", excludeAllAddressRequired?.asQueryValue)
                query.addQueryItem("ExcludeLocalAddressRequired", excludeLocalAddressRequired?.asQueryValue)
                query.addQueryItem("ExcludeForeignAddressRequired", excludeForeignAddressRequired?.asQueryValue)
                query.addQueryItem("Beta", isBeta?.asQueryValue)
                query.addQueryItem("NearNumber", nearNumber?.asQueryValue)
                query.addQueryItem("NearLatLong", nearLatLong?.asQueryValue)
                query.addQueryItem("Distance", distance?.asQueryValue)
                query.addQueryItem("InPostalCode", inPostalCode?.asQueryValue)
                query.addQueryItem("InRegion", inRegion?.asQueryValue)
                query.addQueryItem("InRateCenter", inRateCenter?.asQueryValue)
                query.addQueryItem("InLata", inLata?.asQueryValue)
                query.addQueryItem("InLocality", inLocality?.asQueryValue)
                query.addQueryItem("FaxEnabled", isFaxEnabled?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.AvailablePhoneNumbers.WithCountryCode {
    public var tollFreeJSON: TollFreeJSON {
        TollFreeJSON(path: path + "/TollFree.json")
    }

    public struct TollFreeJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/TollFree.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListAvailablePhoneNumberTollFreeResponse
        public struct GetResponse: Decodable {
            public var availablePhoneNumbers: [TwilioAPI.APIV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberTollFree]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(availablePhoneNumbers: [TwilioAPI.APIV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberTollFree]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.availablePhoneNumbers = availablePhoneNumbers
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case availablePhoneNumbers = "available_phone_numbers"
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var areaCode: Int?
            public var contains: String?
            public var isSmsEnabled: Bool?
            public var isMmsEnabled: Bool?
            public var isVoiceEnabled: Bool?
            public var excludeAllAddressRequired: Bool?
            public var excludeLocalAddressRequired: Bool?
            public var excludeForeignAddressRequired: Bool?
            public var isBeta: Bool?
            public var nearNumber: String?
            public var nearLatLong: String?
            public var distance: Int?
            public var inPostalCode: String?
            public var inRegion: String?
            public var inRateCenter: String?
            public var inLata: String?
            public var inLocality: String?
            public var isFaxEnabled: Bool?
            public var pageSize: Int?

            public init(areaCode: Int? = nil, contains: String? = nil, isSmsEnabled: Bool? = nil, isMmsEnabled: Bool? = nil, isVoiceEnabled: Bool? = nil, excludeAllAddressRequired: Bool? = nil, excludeLocalAddressRequired: Bool? = nil, excludeForeignAddressRequired: Bool? = nil, isBeta: Bool? = nil, nearNumber: String? = nil, nearLatLong: String? = nil, distance: Int? = nil, inPostalCode: String? = nil, inRegion: String? = nil, inRateCenter: String? = nil, inLata: String? = nil, inLocality: String? = nil, isFaxEnabled: Bool? = nil, pageSize: Int? = nil) {
                self.areaCode = areaCode
                self.contains = contains
                self.isSmsEnabled = isSmsEnabled
                self.isMmsEnabled = isMmsEnabled
                self.isVoiceEnabled = isVoiceEnabled
                self.excludeAllAddressRequired = excludeAllAddressRequired
                self.excludeLocalAddressRequired = excludeLocalAddressRequired
                self.excludeForeignAddressRequired = excludeForeignAddressRequired
                self.isBeta = isBeta
                self.nearNumber = nearNumber
                self.nearLatLong = nearLatLong
                self.distance = distance
                self.inPostalCode = inPostalCode
                self.inRegion = inRegion
                self.inRateCenter = inRateCenter
                self.inLata = inLata
                self.inLocality = inLocality
                self.isFaxEnabled = isFaxEnabled
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("AreaCode", areaCode?.asQueryValue)
                query.addQueryItem("Contains", contains?.asQueryValue)
                query.addQueryItem("SmsEnabled", isSmsEnabled?.asQueryValue)
                query.addQueryItem("MmsEnabled", isMmsEnabled?.asQueryValue)
                query.addQueryItem("VoiceEnabled", isVoiceEnabled?.asQueryValue)
                query.addQueryItem("ExcludeAllAddressRequired", excludeAllAddressRequired?.asQueryValue)
                query.addQueryItem("ExcludeLocalAddressRequired", excludeLocalAddressRequired?.asQueryValue)
                query.addQueryItem("ExcludeForeignAddressRequired", excludeForeignAddressRequired?.asQueryValue)
                query.addQueryItem("Beta", isBeta?.asQueryValue)
                query.addQueryItem("NearNumber", nearNumber?.asQueryValue)
                query.addQueryItem("NearLatLong", nearLatLong?.asQueryValue)
                query.addQueryItem("Distance", distance?.asQueryValue)
                query.addQueryItem("InPostalCode", inPostalCode?.asQueryValue)
                query.addQueryItem("InRegion", inRegion?.asQueryValue)
                query.addQueryItem("InRateCenter", inRateCenter?.asQueryValue)
                query.addQueryItem("InLata", inLata?.asQueryValue)
                query.addQueryItem("InLocality", inLocality?.asQueryValue)
                query.addQueryItem("FaxEnabled", isFaxEnabled?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.AvailablePhoneNumbers.WithCountryCode {
    public var voipJSON: VoipJSON {
        VoipJSON(path: path + "/Voip.json")
    }

    public struct VoipJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Voip.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListAvailablePhoneNumberVoipResponse
        public struct GetResponse: Decodable {
            public var availablePhoneNumbers: [TwilioAPI.APIV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberVoip]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(availablePhoneNumbers: [TwilioAPI.APIV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberVoip]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.availablePhoneNumbers = availablePhoneNumbers
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case availablePhoneNumbers = "available_phone_numbers"
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var areaCode: Int?
            public var contains: String?
            public var isSmsEnabled: Bool?
            public var isMmsEnabled: Bool?
            public var isVoiceEnabled: Bool?
            public var excludeAllAddressRequired: Bool?
            public var excludeLocalAddressRequired: Bool?
            public var excludeForeignAddressRequired: Bool?
            public var isBeta: Bool?
            public var nearNumber: String?
            public var nearLatLong: String?
            public var distance: Int?
            public var inPostalCode: String?
            public var inRegion: String?
            public var inRateCenter: String?
            public var inLata: String?
            public var inLocality: String?
            public var isFaxEnabled: Bool?
            public var pageSize: Int?

            public init(areaCode: Int? = nil, contains: String? = nil, isSmsEnabled: Bool? = nil, isMmsEnabled: Bool? = nil, isVoiceEnabled: Bool? = nil, excludeAllAddressRequired: Bool? = nil, excludeLocalAddressRequired: Bool? = nil, excludeForeignAddressRequired: Bool? = nil, isBeta: Bool? = nil, nearNumber: String? = nil, nearLatLong: String? = nil, distance: Int? = nil, inPostalCode: String? = nil, inRegion: String? = nil, inRateCenter: String? = nil, inLata: String? = nil, inLocality: String? = nil, isFaxEnabled: Bool? = nil, pageSize: Int? = nil) {
                self.areaCode = areaCode
                self.contains = contains
                self.isSmsEnabled = isSmsEnabled
                self.isMmsEnabled = isMmsEnabled
                self.isVoiceEnabled = isVoiceEnabled
                self.excludeAllAddressRequired = excludeAllAddressRequired
                self.excludeLocalAddressRequired = excludeLocalAddressRequired
                self.excludeForeignAddressRequired = excludeForeignAddressRequired
                self.isBeta = isBeta
                self.nearNumber = nearNumber
                self.nearLatLong = nearLatLong
                self.distance = distance
                self.inPostalCode = inPostalCode
                self.inRegion = inRegion
                self.inRateCenter = inRateCenter
                self.inLata = inLata
                self.inLocality = inLocality
                self.isFaxEnabled = isFaxEnabled
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("AreaCode", areaCode?.asQueryValue)
                query.addQueryItem("Contains", contains?.asQueryValue)
                query.addQueryItem("SmsEnabled", isSmsEnabled?.asQueryValue)
                query.addQueryItem("MmsEnabled", isMmsEnabled?.asQueryValue)
                query.addQueryItem("VoiceEnabled", isVoiceEnabled?.asQueryValue)
                query.addQueryItem("ExcludeAllAddressRequired", excludeAllAddressRequired?.asQueryValue)
                query.addQueryItem("ExcludeLocalAddressRequired", excludeLocalAddressRequired?.asQueryValue)
                query.addQueryItem("ExcludeForeignAddressRequired", excludeForeignAddressRequired?.asQueryValue)
                query.addQueryItem("Beta", isBeta?.asQueryValue)
                query.addQueryItem("NearNumber", nearNumber?.asQueryValue)
                query.addQueryItem("NearLatLong", nearLatLong?.asQueryValue)
                query.addQueryItem("Distance", distance?.asQueryValue)
                query.addQueryItem("InPostalCode", inPostalCode?.asQueryValue)
                query.addQueryItem("InRegion", inRegion?.asQueryValue)
                query.addQueryItem("InRateCenter", inRateCenter?.asQueryValue)
                query.addQueryItem("InLata", inLata?.asQueryValue)
                query.addQueryItem("InLocality", inLocality?.asQueryValue)
                query.addQueryItem("FaxEnabled", isFaxEnabled?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var balanceJSON: BalanceJSON {
        BalanceJSON(path: path + "/Balance.json")
    }

    public struct BalanceJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Balance.json`
        public let path: String

        /// Fetch the balance for an Account based on Account Sid. Balance changes may not be reflected immediately. Child accounts do not contain balance information
        public var get: Request<TwilioAPI.APIV2010AccountBalance> {
            .get(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var callsJSON: CallsJSON {
        CallsJSON(path: path + "/Calls.json")
    }

    public struct CallsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls.json`
        public let path: String

        /// Retrieves a collection of calls made to and from your account
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListCallResponse
        public struct GetResponse: Decodable {
            public var calls: [TwilioAPI.APIV2010AccountCall]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(calls: [TwilioAPI.APIV2010AccountCall]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.calls = calls
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case calls
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var to: String?
            public var from: String?
            public var parentCallSid: String?
            public var status: Status?
            public var startTime: Date?
            public var startTimeLessThan: Date?
            public var startTimeGreaterThan: Date?
            public var endTime: Date?
            public var endTimeLessThan: Date?
            public var endTimeGreaterThan: Date?
            public var pageSize: Int?

            public enum Status: String, Codable, CaseIterable {
                case queued
                case ringing
                case inProgress = "in-progress"
                case completed
                case busy
                case failed
                case noAnswer = "no-answer"
                case canceled
            }

            public init(to: String? = nil, from: String? = nil, parentCallSid: String? = nil, status: Status? = nil, startTime: Date? = nil, startTimeLessThan: Date? = nil, startTimeGreaterThan: Date? = nil, endTime: Date? = nil, endTimeLessThan: Date? = nil, endTimeGreaterThan: Date? = nil, pageSize: Int? = nil) {
                self.to = to
                self.from = from
                self.parentCallSid = parentCallSid
                self.status = status
                self.startTime = startTime
                self.startTimeLessThan = startTimeLessThan
                self.startTimeGreaterThan = startTimeGreaterThan
                self.endTime = endTime
                self.endTimeLessThan = endTimeLessThan
                self.endTimeGreaterThan = endTimeGreaterThan
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("To", to?.asQueryValue)
                query.addQueryItem("From", from?.asQueryValue)
                query.addQueryItem("ParentCallSid", parentCallSid?.asQueryValue)
                query.addQueryItem("Status", status?.asQueryValue)
                query.addQueryItem("StartTime", startTime?.asQueryValue)
                query.addQueryItem("StartTime<", startTimeLessThan?.asQueryValue)
                query.addQueryItem("StartTime>", startTimeGreaterThan?.asQueryValue)
                query.addQueryItem("EndTime", endTime?.asQueryValue)
                query.addQueryItem("EndTime<", endTimeLessThan?.asQueryValue)
                query.addQueryItem("EndTime>", endTimeGreaterThan?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }

        /// Create a new outgoing call to phones, SIP-enabled endpoints or Twilio Client connections
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountCall> {
            .post(path, body: body?.asQuery())
        }

        /// CreateCallRequest
        public struct PostRequest: Encodable {
            /// The SID of the Application resource that will handle the call, if the call will be handled by an application.
            public var applicationSid: String?
            /// Select whether to perform answering machine detection in the background. Default, blocks the execution of the call until Answering Machine Detection is completed. Can be: `true` or `false`.
            public var asyncAmd: String?
            /// The URL that we should call using the `async_amd_status_callback_method` to notify customer application whether the call was answered by human, machine or fax.
            public var asyncAmdStatusCallback: URL?
            /// The HTTP method we should use when calling the `async_amd_status_callback` URL. Can be: `GET` or `POST` and the default is `POST`.
            public var asyncAmdStatusCallbackMethod: AsyncAmdStatusCallbackMethod?
            /// The SID of a BYOC (Bring Your Own Carrier) trunk to route this call with. Note that `byoc` is only meaningful when `to` is a phone number; it will otherwise be ignored. (Beta)
            public var byoc: String?
            /// The Reason for the outgoing call. Use it to specify the purpose of the call that is presented on the called party's phone. (Branded Calls Beta)
            public var callReason: String?
            /// A token string needed to invoke a forwarded call. A call_token is generated when an incoming call is received on a Twilio number. Pass an incoming call's call_token value to a forwarded call via the call_token parameter when creating a new call. A forwarded call should bear the same CallerID of the original incoming call.
            public var callToken: String?
            /// The phone number, SIP address, or Client identifier that made this call. Phone numbers are in [E.164 format](https://wwnw.twilio.com/docs/glossary/what-e164) (e.g., +16175551212). SIP addresses are formatted as `name@company.com`.
            public var callerID: String?
            /// The HTTP method that we should use to request the `fallback_url`. Can be: `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is present, this parameter is ignored.
            public var fallbackMethod: FallbackMethod?
            /// The URL that we call using the `fallback_method` if an error occurs when requesting or executing the TwiML at `url`. If an `application_sid` parameter is present, this parameter is ignored.
            public var fallbackURL: URL?
            /// The phone number or client identifier to use as the caller id. If using a phone number, it must be a Twilio number or a Verified [outgoing caller id](https://www.twilio.com/docs/voice/api/outgoing-caller-ids) for your account. If the `to` parameter is a phone number, `From` must also be a phone number.
            public var from: String
            /// Whether to detect if a human, answering machine, or fax has picked up the call. Can be: `Enable` or `DetectMessageEnd`. Use `Enable` if you would like us to return `AnsweredBy` as soon as the called party is identified. Use `DetectMessageEnd`, if you would like to leave a message on an answering machine. If `send_digits` is provided, this parameter is ignored. For more information, see [Answering Machine Detection](https://www.twilio.com/docs/voice/answering-machine-detection).
            public var machineDetection: String?
            /// The number of milliseconds of initial silence after which an `unknown` AnsweredBy result will be returned. Possible Values: 2000-10000. Default: 5000.
            public var machineDetectionSilenceTimeout: Int?
            /// The number of milliseconds of silence after speech activity at which point the speech activity is considered complete. Possible Values: 500-5000. Default: 1200.
            public var machineDetectionSpeechEndThreshold: Int?
            /// The number of milliseconds that is used as the measuring stick for the length of the speech activity, where durations lower than this value will be interpreted as a human and longer than this value as a machine. Possible Values: 1000-6000. Default: 2400.
            public var machineDetectionSpeechThreshold: Int?
            /// The number of seconds that we should attempt to detect an answering machine before timing out and sending a voice request with `AnsweredBy` of `unknown`. The default timeout is 30 seconds.
            public var machineDetectionTimeout: Int?
            /// The HTTP method we should use when calling the `url` parameter's value. Can be: `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is present, this parameter is ignored.
            public var method: Method?
            /// Whether to record the call. Can be `true` to record the phone call, or `false` to not. The default is `false`. The `recording_url` is sent to the `status_callback` URL.
            public var isRecord: Bool?
            /// The number of channels in the final recording. Can be: `mono` or `dual`. The default is `mono`. `mono` records both legs of the call in a single channel of the recording file. `dual` records each leg to a separate channel of the recording file. The first channel of a dual-channel recording contains the parent call and the second channel contains the child call.
            public var recordingChannels: String?
            /// The URL that we call when the recording is available to be accessed.
            public var recordingStatusCallback: String?
            /// The recording status events that will trigger calls to the URL specified in `recording_status_callback`. Can be: `in-progress`, `completed` and `absent`. Defaults to `completed`. Separate  multiple values with a space.
            public var recordingStatusCallbackEvent: [String]?
            /// The HTTP method we should use when calling the `recording_status_callback` URL. Can be: `GET` or `POST` and the default is `POST`.
            public var recordingStatusCallbackMethod: RecordingStatusCallbackMethod?
            /// The audio track to record for the call. Can be: `inbound`, `outbound` or `both`. The default is `both`. `inbound` records the audio that is received by Twilio. `outbound` records the audio that is generated from Twilio. `both` records the audio that is received and generated by Twilio.
            public var recordingTrack: String?
            /// A string of keys to dial after connecting to the number, maximum of 32 digits. Valid digits in the string include: any digit (`0`-`9`), '`#`', '`*`' and '`w`', to insert a half second pause. For example, if you connected to a company phone number and wanted to pause for one second, and then dial extension 1234 followed by the pound key, the value of this parameter would be `ww1234#`. Remember to URL-encode this string, since the '`#`' character has special meaning in a URL. If both `SendDigits` and `MachineDetection` parameters are provided, then `MachineDetection` will be ignored.
            public var sendDigits: String?
            /// The password required to authenticate the user account specified in `sip_auth_username`.
            public var sipAuthPassword: String?
            /// The username used to authenticate the caller making a SIP call.
            public var sipAuthUsername: String?
            /// The URL we should call using the `status_callback_method` to send status information to your application. If no `status_callback_event` is specified, we will send the `completed` status. If an `application_sid` parameter is present, this parameter is ignored. URLs must contain a valid hostname (underscores are not permitted).
            public var statusCallback: URL?
            /// The call progress events that we will send to the `status_callback` URL. Can be: `initiated`, `ringing`, `answered`, and `completed`. If no event is specified, we send the `completed` status. If you want to receive multiple events, specify each one in a separate `status_callback_event` parameter. See the code sample for [monitoring call progress](https://www.twilio.com/docs/voice/api/call-resource?code-sample=code-create-a-call-resource-and-specify-a-statuscallbackevent&code-sdk-version=json). If an `application_sid` is present, this parameter is ignored.
            public var statusCallbackEvent: [String]?
            /// The HTTP method we should use when calling the `status_callback` URL. Can be: `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is present, this parameter is ignored.
            public var statusCallbackMethod: StatusCallbackMethod?
            /// The maximum duration of the call in seconds. Constraints depend on account and configuration.
            public var timeLimit: Int?
            /// The integer number of seconds that we should allow the phone to ring before assuming there is no answer. The default is `60` seconds and the maximum is `600` seconds. For some call flows, we will add a 5-second buffer to the timeout value you provide. For this reason, a timeout value of 10 seconds could result in an actual timeout closer to 15 seconds. You can set this to a short time, such as `15` seconds, to hang up before reaching an answering machine or voicemail.
            public var timeout: Int?
            /// The phone number, SIP address, or client identifier to call.
            public var to: String
            /// Whether to trim any leading and trailing silence from the recording. Can be: `trim-silence` or `do-not-trim` and the default is `trim-silence`.
            public var trim: String?
            /// TwiML instructions for the call Twilio will use without fetching Twiml from url parameter. If both `twiml` and `url` are provided then `twiml` parameter will be ignored. Max 4000 characters.
            public var twiml: String?
            /// The absolute URL that returns the TwiML instructions for the call. We will call this URL using the `method` when the call connects. For more information, see the [Url Parameter](https://www.twilio.com/docs/voice/make-calls#specify-a-url-parameter) section in [Making Calls](https://www.twilio.com/docs/voice/make-calls).
            public var url: URL?

            /// The HTTP method we should use when calling the `async_amd_status_callback` URL. Can be: `GET` or `POST` and the default is `POST`.
            public enum AsyncAmdStatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method that we should use to request the `fallback_url`. Can be: `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is present, this parameter is ignored.
            public enum FallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use when calling the `url` parameter's value. Can be: `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is present, this parameter is ignored.
            public enum Method: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use when calling the `recording_status_callback` URL. Can be: `GET` or `POST` and the default is `POST`.
            public enum RecordingStatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use when calling the `status_callback` URL. Can be: `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is present, this parameter is ignored.
            public enum StatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            public init(applicationSid: String? = nil, asyncAmd: String? = nil, asyncAmdStatusCallback: URL? = nil, asyncAmdStatusCallbackMethod: AsyncAmdStatusCallbackMethod? = nil, byoc: String? = nil, callReason: String? = nil, callToken: String? = nil, callerID: String? = nil, fallbackMethod: FallbackMethod? = nil, fallbackURL: URL? = nil, from: String, machineDetection: String? = nil, machineDetectionSilenceTimeout: Int? = nil, machineDetectionSpeechEndThreshold: Int? = nil, machineDetectionSpeechThreshold: Int? = nil, machineDetectionTimeout: Int? = nil, method: Method? = nil, isRecord: Bool? = nil, recordingChannels: String? = nil, recordingStatusCallback: String? = nil, recordingStatusCallbackEvent: [String]? = nil, recordingStatusCallbackMethod: RecordingStatusCallbackMethod? = nil, recordingTrack: String? = nil, sendDigits: String? = nil, sipAuthPassword: String? = nil, sipAuthUsername: String? = nil, statusCallback: URL? = nil, statusCallbackEvent: [String]? = nil, statusCallbackMethod: StatusCallbackMethod? = nil, timeLimit: Int? = nil, timeout: Int? = nil, to: String, trim: String? = nil, twiml: String? = nil, url: URL? = nil) {
                self.applicationSid = applicationSid
                self.asyncAmd = asyncAmd
                self.asyncAmdStatusCallback = asyncAmdStatusCallback
                self.asyncAmdStatusCallbackMethod = asyncAmdStatusCallbackMethod
                self.byoc = byoc
                self.callReason = callReason
                self.callToken = callToken
                self.callerID = callerID
                self.fallbackMethod = fallbackMethod
                self.fallbackURL = fallbackURL
                self.from = from
                self.machineDetection = machineDetection
                self.machineDetectionSilenceTimeout = machineDetectionSilenceTimeout
                self.machineDetectionSpeechEndThreshold = machineDetectionSpeechEndThreshold
                self.machineDetectionSpeechThreshold = machineDetectionSpeechThreshold
                self.machineDetectionTimeout = machineDetectionTimeout
                self.method = method
                self.isRecord = isRecord
                self.recordingChannels = recordingChannels
                self.recordingStatusCallback = recordingStatusCallback
                self.recordingStatusCallbackEvent = recordingStatusCallbackEvent
                self.recordingStatusCallbackMethod = recordingStatusCallbackMethod
                self.recordingTrack = recordingTrack
                self.sendDigits = sendDigits
                self.sipAuthPassword = sipAuthPassword
                self.sipAuthUsername = sipAuthUsername
                self.statusCallback = statusCallback
                self.statusCallbackEvent = statusCallbackEvent
                self.statusCallbackMethod = statusCallbackMethod
                self.timeLimit = timeLimit
                self.timeout = timeout
                self.to = to
                self.trim = trim
                self.twiml = twiml
                self.url = url
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("ApplicationSid", applicationSid?.asQueryValue)
                query.addQueryItem("AsyncAmd", asyncAmd?.asQueryValue)
                query.addQueryItem("AsyncAmdStatusCallback", asyncAmdStatusCallback?.asQueryValue)
                query.addQueryItem("AsyncAmdStatusCallbackMethod", asyncAmdStatusCallbackMethod?.asQueryValue)
                query.addQueryItem("Byoc", byoc?.asQueryValue)
                query.addQueryItem("CallReason", callReason?.asQueryValue)
                query.addQueryItem("CallToken", callToken?.asQueryValue)
                query.addQueryItem("CallerId", callerID?.asQueryValue)
                query.addQueryItem("FallbackMethod", fallbackMethod?.asQueryValue)
                query.addQueryItem("FallbackUrl", fallbackURL?.asQueryValue)
                query.addQueryItem("From", from.asQueryValue)
                query.addQueryItem("MachineDetection", machineDetection?.asQueryValue)
                query.addQueryItem("MachineDetectionSilenceTimeout", machineDetectionSilenceTimeout?.asQueryValue)
                query.addQueryItem("MachineDetectionSpeechEndThreshold", machineDetectionSpeechEndThreshold?.asQueryValue)
                query.addQueryItem("MachineDetectionSpeechThreshold", machineDetectionSpeechThreshold?.asQueryValue)
                query.addQueryItem("MachineDetectionTimeout", machineDetectionTimeout?.asQueryValue)
                query.addQueryItem("Method", method?.asQueryValue)
                query.addQueryItem("Record", isRecord?.asQueryValue)
                query.addQueryItem("RecordingChannels", recordingChannels?.asQueryValue)
                query.addQueryItem("RecordingStatusCallback", recordingStatusCallback?.asQueryValue)
                for value in recordingStatusCallbackEvent ?? [] {
                    query.addQueryItem("RecordingStatusCallbackEvent", value.asQueryValue)
                }
                query.addQueryItem("RecordingStatusCallbackMethod", recordingStatusCallbackMethod?.asQueryValue)
                query.addQueryItem("RecordingTrack", recordingTrack?.asQueryValue)
                query.addQueryItem("SendDigits", sendDigits?.asQueryValue)
                query.addQueryItem("SipAuthPassword", sipAuthPassword?.asQueryValue)
                query.addQueryItem("SipAuthUsername", sipAuthUsername?.asQueryValue)
                query.addQueryItem("StatusCallback", statusCallback?.asQueryValue)
                for value in statusCallbackEvent ?? [] {
                    query.addQueryItem("StatusCallbackEvent", value.asQueryValue)
                }
                query.addQueryItem("StatusCallbackMethod", statusCallbackMethod?.asQueryValue)
                query.addQueryItem("TimeLimit", timeLimit?.asQueryValue)
                query.addQueryItem("Timeout", timeout?.asQueryValue)
                query.addQueryItem("To", to.asQueryValue)
                query.addQueryItem("Trim", trim?.asQueryValue)
                query.addQueryItem("Twiml", twiml?.asQueryValue)
                query.addQueryItem("Url", url?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var calls: Calls {
        Calls(path: path + "/Calls")
    }

    public struct Calls {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Calls {
    public var feedbackSummaryJSON: FeedbackSummaryJSON {
        FeedbackSummaryJSON(path: path + "/FeedbackSummary.json")
    }

    public struct FeedbackSummaryJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary.json`
        public let path: String

        /// Create a FeedbackSummary resource for a call
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountCallCallFeedbackSummary> {
            .post(path, body: body?.asQuery())
        }

        /// CreateCallFeedbackSummaryRequest
        public struct PostRequest: Encodable {
            /// Only include feedback given on or before this date. Format is `YYYY-MM-DD` and specified in UTC.
            public var endDate: NaiveDate
            /// Whether to also include Feedback resources from all subaccounts. `true` includes feedback from all subaccounts and `false`, the default, includes feedback from only the specified account.
            public var isIncludeSubaccounts: Bool?
            /// Only include feedback given on or after this date. Format is `YYYY-MM-DD` and specified in UTC.
            public var startDate: NaiveDate
            /// The URL that we will request when the feedback summary is complete.
            public var statusCallback: URL?
            /// The HTTP method (`GET` or `POST`) we use to make the request to the `StatusCallback` URL.
            public var statusCallbackMethod: StatusCallbackMethod?

            /// The HTTP method (`GET` or `POST`) we use to make the request to the `StatusCallback` URL.
            public enum StatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            public init(endDate: NaiveDate, isIncludeSubaccounts: Bool? = nil, startDate: NaiveDate, statusCallback: URL? = nil, statusCallbackMethod: StatusCallbackMethod? = nil) {
                self.endDate = endDate
                self.isIncludeSubaccounts = isIncludeSubaccounts
                self.startDate = startDate
                self.statusCallback = statusCallback
                self.statusCallbackMethod = statusCallbackMethod
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("EndDate", endDate.asQueryValue)
                query.addQueryItem("IncludeSubaccounts", isIncludeSubaccounts?.asQueryValue)
                query.addQueryItem("StartDate", startDate.asQueryValue)
                query.addQueryItem("StatusCallback", statusCallback?.asQueryValue)
                query.addQueryItem("StatusCallbackMethod", statusCallbackMethod?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Calls {
    public var feedbackSummary: FeedbackSummary {
        FeedbackSummary(path: path + "/FeedbackSummary")
    }

    public struct FeedbackSummary {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Calls.FeedbackSummary {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary/{Sid}.json`
        public let path: String

        /// Fetch a FeedbackSummary resource from a call
        public var get: Request<TwilioAPI.APIV2010AccountCallCallFeedbackSummary> {
            .get(path)
        }

        /// Delete a FeedbackSummary resource from a call
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.Calls {
    public func callSid(_ callSid: String) -> WithCallSid {
        WithCallSid(path: "\(path)/\(callSid)")
    }

    public struct WithCallSid {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Calls.WithCallSid {
    public var eventsJSON: EventsJSON {
        EventsJSON(path: path + "/Events.json")
    }

    public struct EventsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Events.json`
        public let path: String

        /// Retrieve a list of all events for a call.
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListCallEventResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var events: [TwilioAPI.APIV2010AccountCallCallEvent]?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, events: [TwilioAPI.APIV2010AccountCallCallEvent]? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.events = events
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case events
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }
    }
}

extension Paths.Accounts.WithAccountSid.Calls.WithCallSid {
    public var feedbackJSON: FeedbackJSON {
        FeedbackJSON(path: path + "/Feedback.json")
    }

    public struct FeedbackJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Feedback.json`
        public let path: String

        /// Fetch a Feedback resource from a call
        public var get: Request<TwilioAPI.APIV2010AccountCallCallFeedback> {
            .get(path)
        }

        /// Update a Feedback resource for a call
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountCallCallFeedback> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateCallFeedbackRequest
        public struct PostRequest: Encodable {
            /// One or more issues experienced during the call. The issues can be: `imperfect-audio`, `dropped-call`, `incorrect-caller-id`, `post-dial-delay`, `digits-not-captured`, `audio-latency`, `unsolicited-call`, or `one-way-audio`.
            public var issue: [IssueItem]?
            /// The call quality expressed as an integer from `1` to `5` where `1` represents very poor call quality and `5` represents a perfect call.
            public var qualityScore: Int?

            public enum IssueItem: String, Codable, CaseIterable {
                case audioLatency = "audio-latency"
                case digitsNotCaptured = "digits-not-captured"
                case droppedCall = "dropped-call"
                case imperfectAudio = "imperfect-audio"
                case incorrectCallerID = "incorrect-caller-id"
                case oneWayAudio = "one-way-audio"
                case postDialDelay = "post-dial-delay"
                case unsolicitedCall = "unsolicited-call"
            }

            public init(issue: [IssueItem]? = nil, qualityScore: Int? = nil) {
                self.issue = issue
                self.qualityScore = qualityScore
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                for value in issue ?? [] {
                    query.addQueryItem("Issue", value.asQueryValue)
                }
                query.addQueryItem("QualityScore", qualityScore?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Calls.WithCallSid {
    public var notificationsJSON: NotificationsJSON {
        NotificationsJSON(path: path + "/Notifications.json")
    }

    public struct NotificationsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Notifications.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListCallNotificationResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var notifications: [TwilioAPI.APIV2010AccountCallCallNotification]?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, notifications: [TwilioAPI.APIV2010AccountCallCallNotification]? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.notifications = notifications
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case notifications
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var log: Int?
            public var messageDate: NaiveDate?
            public var messageDateLessThan: NaiveDate?
            public var messageDateGreaterThan: NaiveDate?
            public var pageSize: Int?

            public init(log: Int? = nil, messageDate: NaiveDate? = nil, messageDateLessThan: NaiveDate? = nil, messageDateGreaterThan: NaiveDate? = nil, pageSize: Int? = nil) {
                self.log = log
                self.messageDate = messageDate
                self.messageDateLessThan = messageDateLessThan
                self.messageDateGreaterThan = messageDateGreaterThan
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("Log", log?.asQueryValue)
                query.addQueryItem("MessageDate", messageDate?.asQueryValue)
                query.addQueryItem("MessageDate<", messageDateLessThan?.asQueryValue)
                query.addQueryItem("MessageDate>", messageDateGreaterThan?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Calls.WithCallSid {
    public var notifications: Notifications {
        Notifications(path: path + "/Notifications")
    }

    public struct Notifications {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Notifications`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Calls.WithCallSid.Notifications {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Notifications/{Sid}.json`
        public let path: String

        public var get: Request<TwilioAPI.APIV2010AccountCallCallNotificationInstance> {
            .get(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.Calls.WithCallSid {
    public var paymentsJSON: PaymentsJSON {
        PaymentsJSON(path: path + "/Payments.json")
    }

    public struct PaymentsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Payments.json`
        public let path: String

        /// Create an instance of payments. This will start a new payments session
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountCallPayments> {
            .post(path, body: body?.asQuery())
        }

        /// CreatePaymentsRequest
        public struct PostRequest: Encodable {
            /// Type of bank account if payment source is ACH. One of `consumer-checking`, `consumer-savings`, or `commercial-checking`. The default value is `consumer-checking`.
            public var bankAccountType: BankAccountType?
            /// A positive decimal value less than 1,000,000 to charge against the credit card or bank account. Default currency can be overwritten with `currency` field. Leave blank or set to 0 to tokenize.
            public var chargeAmount: Double?
            /// The currency of the `charge_amount`, formatted as [ISO 4127](http://www.iso.org/iso/home/standards/currency_codes.htm) format. The default value is `USD` and all values allowed from the <Pay> Connector are accepted.
            public var currency: String?
            /// The description can be used to provide more details regarding the transaction. This information is submitted along with the payment details to the Payment Connector which are then posted on the transactions.
            public var description: String?
            /// A unique token that will be used to ensure that multiple API calls with the same information do not result in multiple transactions. This should be a unique string value per API call and can be a randomly generated.
            public var idempotencyKey: String
            /// A list of inputs that should be accepted. Currently only `dtmf` is supported. All digits captured during a pay session are redacted from the logs.
            public var input: String?
            /// A positive integer that is used to validate the length of the `PostalCode` inputted by the user. User must enter this many digits.
            public var minPostalCodeLength: Int?
            /// A single level JSON string that is required when accepting certain information specific only to ACH payments. The information that has to be included here depends on the <Pay> Connector. [Read more](https://www.twilio.com/console/voice/pay-connectors).
            public var parameter: String?
            /// This is the unique name corresponding to the Payment Gateway Connector installed in the Twilio Add-ons. Learn more about [<Pay> Connectors](https://www.twilio.com/console/voice/pay-connectors). The default value is `Default`.
            public var paymentConnector: String?
            /// Type of payment being captured. One of `credit-card` or `ach-debit`. The default value is `credit-card`.
            public var paymentMethod: PaymentMethod?
            /// Indicates whether the credit card postal code (zip code) is a required piece of payment information that must be provided by the caller. The default is `true`.
            public var isPostalCode: Bool?
            /// Indicates whether the credit card security code is a required piece of payment information that must be provided by the caller. The default is `true`.
            public var isSecurityCode: Bool?
            /// Provide an absolute or relative URL to receive status updates regarding your Pay session. Read more about the [expected StatusCallback values](https://www.twilio.com/docs/voice/api/payment-resource#statuscallback)
            public var statusCallback: URL
            /// The number of seconds that <Pay> should wait for the caller to press a digit between each subsequent digit, after the first one, before moving on to validate the digits captured. The default is `5`, maximum is `600`.
            public var timeout: Int?
            /// Indicates whether the payment method should be tokenized as a `one-time` or `reusable` token. The default value is `reusable`. Do not enter a charge amount when tokenizing. If a charge amount is entered, the payment method will be charged and not tokenized.
            public var tokenType: TokenType?
            /// Credit card types separated by space that Pay should accept. The default value is `visa mastercard amex`
            public var validCardTypes: String?

            /// Type of bank account if payment source is ACH. One of `consumer-checking`, `consumer-savings`, or `commercial-checking`. The default value is `consumer-checking`.
            public enum BankAccountType: String, Codable, CaseIterable {
                case consumerChecking = "consumer-checking"
                case consumerSavings = "consumer-savings"
                case commercialChecking = "commercial-checking"
            }

            /// Type of payment being captured. One of `credit-card` or `ach-debit`. The default value is `credit-card`.
            public enum PaymentMethod: String, Codable, CaseIterable {
                case creditCard = "credit-card"
                case achDebit = "ach-debit"
            }

            /// Indicates whether the payment method should be tokenized as a `one-time` or `reusable` token. The default value is `reusable`. Do not enter a charge amount when tokenizing. If a charge amount is entered, the payment method will be charged and not tokenized.
            public enum TokenType: String, Codable, CaseIterable {
                case oneTime = "one-time"
                case reusable
            }

            public init(bankAccountType: BankAccountType? = nil, chargeAmount: Double? = nil, currency: String? = nil, description: String? = nil, idempotencyKey: String, input: String? = nil, minPostalCodeLength: Int? = nil, parameter: String? = nil, paymentConnector: String? = nil, paymentMethod: PaymentMethod? = nil, isPostalCode: Bool? = nil, isSecurityCode: Bool? = nil, statusCallback: URL, timeout: Int? = nil, tokenType: TokenType? = nil, validCardTypes: String? = nil) {
                self.bankAccountType = bankAccountType
                self.chargeAmount = chargeAmount
                self.currency = currency
                self.description = description
                self.idempotencyKey = idempotencyKey
                self.input = input
                self.minPostalCodeLength = minPostalCodeLength
                self.parameter = parameter
                self.paymentConnector = paymentConnector
                self.paymentMethod = paymentMethod
                self.isPostalCode = isPostalCode
                self.isSecurityCode = isSecurityCode
                self.statusCallback = statusCallback
                self.timeout = timeout
                self.tokenType = tokenType
                self.validCardTypes = validCardTypes
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("BankAccountType", bankAccountType?.asQueryValue)
                query.addQueryItem("ChargeAmount", chargeAmount?.asQueryValue)
                query.addQueryItem("Currency", currency?.asQueryValue)
                query.addQueryItem("Description", description?.asQueryValue)
                query.addQueryItem("IdempotencyKey", idempotencyKey.asQueryValue)
                query.addQueryItem("Input", input?.asQueryValue)
                query.addQueryItem("MinPostalCodeLength", minPostalCodeLength?.asQueryValue)
                query.addQueryItem("Parameter", parameter?.asQueryValue)
                query.addQueryItem("PaymentConnector", paymentConnector?.asQueryValue)
                query.addQueryItem("PaymentMethod", paymentMethod?.asQueryValue)
                query.addQueryItem("PostalCode", isPostalCode?.asQueryValue)
                query.addQueryItem("SecurityCode", isSecurityCode?.asQueryValue)
                query.addQueryItem("StatusCallback", statusCallback.asQueryValue)
                query.addQueryItem("Timeout", timeout?.asQueryValue)
                query.addQueryItem("TokenType", tokenType?.asQueryValue)
                query.addQueryItem("ValidCardTypes", validCardTypes?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Calls.WithCallSid {
    public var payments: Payments {
        Payments(path: path + "/Payments")
    }

    public struct Payments {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Payments`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Calls.WithCallSid.Payments {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Payments/{Sid}.json`
        public let path: String

        /// Update an instance of payments with different phases of payment flows.
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountCallPayments> {
            .post(path, body: body?.asQuery())
        }

        /// UpdatePaymentsRequest
        public struct PostRequest: Encodable {
            /// The piece of payment information that you wish the caller to enter. Must be one of `payment-card-number`, `expiration-date`, `security-code`, `postal-code`, `bank-routing-number`, or `bank-account-number`.
            public var capture: Capture?
            /// A unique token that will be used to ensure that multiple API calls with the same information do not result in multiple transactions. This should be a unique string value per API call and can be a randomly generated.
            public var idempotencyKey: String
            /// Indicates whether the current payment session should be cancelled or completed. When `cancel` the payment session is cancelled. When `complete`, Twilio sends the payment information to the selected <Pay> connector for processing.
            public var status: Status?
            /// Provide an absolute or relative URL to receive status updates regarding your Pay session. Read more about the [Update](https://www.twilio.com/docs/voice/api/payment-resource#statuscallback-update) and [Complete/Cancel](https://www.twilio.com/docs/voice/api/payment-resource#statuscallback-cancelcomplete) POST requests.
            public var statusCallback: URL

            /// The piece of payment information that you wish the caller to enter. Must be one of `payment-card-number`, `expiration-date`, `security-code`, `postal-code`, `bank-routing-number`, or `bank-account-number`.
            public enum Capture: String, Codable, CaseIterable {
                case paymentCardNumber = "payment-card-number"
                case expirationDate = "expiration-date"
                case securityCode = "security-code"
                case postalCode = "postal-code"
                case bankRoutingNumber = "bank-routing-number"
                case bankAccountNumber = "bank-account-number"
            }

            /// Indicates whether the current payment session should be cancelled or completed. When `cancel` the payment session is cancelled. When `complete`, Twilio sends the payment information to the selected <Pay> connector for processing.
            public enum Status: String, Codable, CaseIterable {
                case complete
                case cancel
            }

            public init(capture: Capture? = nil, idempotencyKey: String, status: Status? = nil, statusCallback: URL) {
                self.capture = capture
                self.idempotencyKey = idempotencyKey
                self.status = status
                self.statusCallback = statusCallback
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("Capture", capture?.asQueryValue)
                query.addQueryItem("IdempotencyKey", idempotencyKey.asQueryValue)
                query.addQueryItem("Status", status?.asQueryValue)
                query.addQueryItem("StatusCallback", statusCallback.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Calls.WithCallSid {
    public var recordingsJSON: RecordingsJSON {
        RecordingsJSON(path: path + "/Recordings.json")
    }

    public struct RecordingsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings.json`
        public let path: String

        /// Retrieve a list of recordings belonging to the call used to make the request
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListCallRecordingResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var recordings: [TwilioAPI.APIV2010AccountCallCallRecording]?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, recordings: [TwilioAPI.APIV2010AccountCallCallRecording]? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.recordings = recordings
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case recordings
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var dateCreated: NaiveDate?
            public var dateCreatedLessThan: NaiveDate?
            public var dateCreatedGreaterThan: NaiveDate?
            public var pageSize: Int?

            public init(dateCreated: NaiveDate? = nil, dateCreatedLessThan: NaiveDate? = nil, dateCreatedGreaterThan: NaiveDate? = nil, pageSize: Int? = nil) {
                self.dateCreated = dateCreated
                self.dateCreatedLessThan = dateCreatedLessThan
                self.dateCreatedGreaterThan = dateCreatedGreaterThan
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("DateCreated", dateCreated?.asQueryValue)
                query.addQueryItem("DateCreated<", dateCreatedLessThan?.asQueryValue)
                query.addQueryItem("DateCreated>", dateCreatedGreaterThan?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }

        /// Create a recording for the call
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountCallCallRecording> {
            .post(path, body: body?.asQuery())
        }

        /// CreateCallRecordingRequest
        public struct PostRequest: Encodable {
            /// The number of channels used in the recording. Can be: `mono` or `dual` and the default is `mono`. `mono` records all parties of the call into one channel. `dual` records each party of a 2-party call into separate channels.
            public var recordingChannels: String?
            /// The URL we should call using the `recording_status_callback_method` on each recording event specified in  `recording_status_callback_event`. For more information, see [RecordingStatusCallback parameters](https://www.twilio.com/docs/voice/api/recording#recordingstatuscallback).
            public var recordingStatusCallback: URL?
            /// The recording status events on which we should call the `recording_status_callback` URL. Can be: `in-progress`, `completed` and `absent` and the default is `completed`. Separate multiple event values with a space.
            public var recordingStatusCallbackEvent: [String]?
            /// The HTTP method we should use to call `recording_status_callback`. Can be: `GET` or `POST` and the default is `POST`.
            public var recordingStatusCallbackMethod: RecordingStatusCallbackMethod?
            /// The audio track to record for the call. Can be: `inbound`, `outbound` or `both`. The default is `both`. `inbound` records the audio that is received by Twilio. `outbound` records the audio that is generated from Twilio. `both` records the audio that is received and generated by Twilio.
            public var recordingTrack: String?
            /// Whether to trim any leading and trailing silence in the recording. Can be: `trim-silence` or `do-not-trim` and the default is `do-not-trim`. `trim-silence` trims the silence from the beginning and end of the recording and `do-not-trim` does not.
            public var trim: String?

            /// The HTTP method we should use to call `recording_status_callback`. Can be: `GET` or `POST` and the default is `POST`.
            public enum RecordingStatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            public init(recordingChannels: String? = nil, recordingStatusCallback: URL? = nil, recordingStatusCallbackEvent: [String]? = nil, recordingStatusCallbackMethod: RecordingStatusCallbackMethod? = nil, recordingTrack: String? = nil, trim: String? = nil) {
                self.recordingChannels = recordingChannels
                self.recordingStatusCallback = recordingStatusCallback
                self.recordingStatusCallbackEvent = recordingStatusCallbackEvent
                self.recordingStatusCallbackMethod = recordingStatusCallbackMethod
                self.recordingTrack = recordingTrack
                self.trim = trim
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("RecordingChannels", recordingChannels?.asQueryValue)
                query.addQueryItem("RecordingStatusCallback", recordingStatusCallback?.asQueryValue)
                for value in recordingStatusCallbackEvent ?? [] {
                    query.addQueryItem("RecordingStatusCallbackEvent", value.asQueryValue)
                }
                query.addQueryItem("RecordingStatusCallbackMethod", recordingStatusCallbackMethod?.asQueryValue)
                query.addQueryItem("RecordingTrack", recordingTrack?.asQueryValue)
                query.addQueryItem("Trim", trim?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Calls.WithCallSid {
    public var recordings: Recordings {
        Recordings(path: path + "/Recordings")
    }

    public struct Recordings {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Calls.WithCallSid.Recordings {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json`
        public let path: String

        /// Fetch an instance of a recording for a call
        public var get: Request<TwilioAPI.APIV2010AccountCallCallRecording> {
            .get(path)
        }

        /// Changes the status of the recording to paused, stopped, or in-progress. Note: Pass `Twilio.CURRENT` instead of recording sid to reference current active recording.
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountCallCallRecording> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateCallRecordingRequest
        public struct PostRequest: Encodable {
            /// Whether to record during a pause. Can be: `skip` or `silence` and the default is `silence`. `skip` does not record during the pause period, while `silence` will replace the actual audio of the call with silence during the pause period. This parameter only applies when setting `status` is set to `paused`.
            public var pauseBehavior: String?
            /// The new status of the recording. Can be: `stopped`, `paused`, `in-progress`.
            public var status: Status

            /// The new status of the recording. Can be: `stopped`, `paused`, `in-progress`.
            public enum Status: String, Codable, CaseIterable {
                case inProgress = "in-progress"
                case paused
                case stopped
                case processing
                case completed
                case absent
            }

            public init(pauseBehavior: String? = nil, status: Status) {
                self.pauseBehavior = pauseBehavior
                self.status = status
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("PauseBehavior", pauseBehavior?.asQueryValue)
                query.addQueryItem("Status", status.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }

        /// Delete a recording from your account
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.Calls.WithCallSid {
    public var siprecJSON: SiprecJSON {
        SiprecJSON(path: path + "/Siprec.json")
    }

    public struct SiprecJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Siprec.json`
        public let path: String

        /// Create a Siprec
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountCallSiprec> {
            .post(path, body: body?.asQuery())
        }

        /// CreateSiprecRequest
        public struct PostRequest: Encodable {
            /// Unique name used when configuring the connector via Marketplace Add-on.
            public var connectorName: String?
            /// The user-specified name of this Siprec, if one was given when the Siprec was created. This may be used to stop the Siprec.
            public var name: String?
            /// Parameter name
            public var parameter1Name: String?
            /// Parameter value
            public var parameter1Value: String?
            /// Parameter name
            public var parameter10Name: String?
            /// Parameter value
            public var parameter10Value: String?
            /// Parameter name
            public var parameter11Name: String?
            /// Parameter value
            public var parameter11Value: String?
            /// Parameter name
            public var parameter12Name: String?
            /// Parameter value
            public var parameter12Value: String?
            /// Parameter name
            public var parameter13Name: String?
            /// Parameter value
            public var parameter13Value: String?
            /// Parameter name
            public var parameter14Name: String?
            /// Parameter value
            public var parameter14Value: String?
            /// Parameter name
            public var parameter15Name: String?
            /// Parameter value
            public var parameter15Value: String?
            /// Parameter name
            public var parameter16Name: String?
            /// Parameter value
            public var parameter16Value: String?
            /// Parameter name
            public var parameter17Name: String?
            /// Parameter value
            public var parameter17Value: String?
            /// Parameter name
            public var parameter18Name: String?
            /// Parameter value
            public var parameter18Value: String?
            /// Parameter name
            public var parameter19Name: String?
            /// Parameter value
            public var parameter19Value: String?
            /// Parameter name
            public var parameter2Name: String?
            /// Parameter value
            public var parameter2Value: String?
            /// Parameter name
            public var parameter20Name: String?
            /// Parameter value
            public var parameter20Value: String?
            /// Parameter name
            public var parameter21Name: String?
            /// Parameter value
            public var parameter21Value: String?
            /// Parameter name
            public var parameter22Name: String?
            /// Parameter value
            public var parameter22Value: String?
            /// Parameter name
            public var parameter23Name: String?
            /// Parameter value
            public var parameter23Value: String?
            /// Parameter name
            public var parameter24Name: String?
            /// Parameter value
            public var parameter24Value: String?
            /// Parameter name
            public var parameter25Name: String?
            /// Parameter value
            public var parameter25Value: String?
            /// Parameter name
            public var parameter26Name: String?
            /// Parameter value
            public var parameter26Value: String?
            /// Parameter name
            public var parameter27Name: String?
            /// Parameter value
            public var parameter27Value: String?
            /// Parameter name
            public var parameter28Name: String?
            /// Parameter value
            public var parameter28Value: String?
            /// Parameter name
            public var parameter29Name: String?
            /// Parameter value
            public var parameter29Value: String?
            /// Parameter name
            public var parameter3Name: String?
            /// Parameter value
            public var parameter3Value: String?
            /// Parameter name
            public var parameter30Name: String?
            /// Parameter value
            public var parameter30Value: String?
            /// Parameter name
            public var parameter31Name: String?
            /// Parameter value
            public var parameter31Value: String?
            /// Parameter name
            public var parameter32Name: String?
            /// Parameter value
            public var parameter32Value: String?
            /// Parameter name
            public var parameter33Name: String?
            /// Parameter value
            public var parameter33Value: String?
            /// Parameter name
            public var parameter34Name: String?
            /// Parameter value
            public var parameter34Value: String?
            /// Parameter name
            public var parameter35Name: String?
            /// Parameter value
            public var parameter35Value: String?
            /// Parameter name
            public var parameter36Name: String?
            /// Parameter value
            public var parameter36Value: String?
            /// Parameter name
            public var parameter37Name: String?
            /// Parameter value
            public var parameter37Value: String?
            /// Parameter name
            public var parameter38Name: String?
            /// Parameter value
            public var parameter38Value: String?
            /// Parameter name
            public var parameter39Name: String?
            /// Parameter value
            public var parameter39Value: String?
            /// Parameter name
            public var parameter4Name: String?
            /// Parameter value
            public var parameter4Value: String?
            /// Parameter name
            public var parameter40Name: String?
            /// Parameter value
            public var parameter40Value: String?
            /// Parameter name
            public var parameter41Name: String?
            /// Parameter value
            public var parameter41Value: String?
            /// Parameter name
            public var parameter42Name: String?
            /// Parameter value
            public var parameter42Value: String?
            /// Parameter name
            public var parameter43Name: String?
            /// Parameter value
            public var parameter43Value: String?
            /// Parameter name
            public var parameter44Name: String?
            /// Parameter value
            public var parameter44Value: String?
            /// Parameter name
            public var parameter45Name: String?
            /// Parameter value
            public var parameter45Value: String?
            /// Parameter name
            public var parameter46Name: String?
            /// Parameter value
            public var parameter46Value: String?
            /// Parameter name
            public var parameter47Name: String?
            /// Parameter value
            public var parameter47Value: String?
            /// Parameter name
            public var parameter48Name: String?
            /// Parameter value
            public var parameter48Value: String?
            /// Parameter name
            public var parameter49Name: String?
            /// Parameter value
            public var parameter49Value: String?
            /// Parameter name
            public var parameter5Name: String?
            /// Parameter value
            public var parameter5Value: String?
            /// Parameter name
            public var parameter50Name: String?
            /// Parameter value
            public var parameter50Value: String?
            /// Parameter name
            public var parameter51Name: String?
            /// Parameter value
            public var parameter51Value: String?
            /// Parameter name
            public var parameter52Name: String?
            /// Parameter value
            public var parameter52Value: String?
            /// Parameter name
            public var parameter53Name: String?
            /// Parameter value
            public var parameter53Value: String?
            /// Parameter name
            public var parameter54Name: String?
            /// Parameter value
            public var parameter54Value: String?
            /// Parameter name
            public var parameter55Name: String?
            /// Parameter value
            public var parameter55Value: String?
            /// Parameter name
            public var parameter56Name: String?
            /// Parameter value
            public var parameter56Value: String?
            /// Parameter name
            public var parameter57Name: String?
            /// Parameter value
            public var parameter57Value: String?
            /// Parameter name
            public var parameter58Name: String?
            /// Parameter value
            public var parameter58Value: String?
            /// Parameter name
            public var parameter59Name: String?
            /// Parameter value
            public var parameter59Value: String?
            /// Parameter name
            public var parameter6Name: String?
            /// Parameter value
            public var parameter6Value: String?
            /// Parameter name
            public var parameter60Name: String?
            /// Parameter value
            public var parameter60Value: String?
            /// Parameter name
            public var parameter61Name: String?
            /// Parameter value
            public var parameter61Value: String?
            /// Parameter name
            public var parameter62Name: String?
            /// Parameter value
            public var parameter62Value: String?
            /// Parameter name
            public var parameter63Name: String?
            /// Parameter value
            public var parameter63Value: String?
            /// Parameter name
            public var parameter64Name: String?
            /// Parameter value
            public var parameter64Value: String?
            /// Parameter name
            public var parameter65Name: String?
            /// Parameter value
            public var parameter65Value: String?
            /// Parameter name
            public var parameter66Name: String?
            /// Parameter value
            public var parameter66Value: String?
            /// Parameter name
            public var parameter67Name: String?
            /// Parameter value
            public var parameter67Value: String?
            /// Parameter name
            public var parameter68Name: String?
            /// Parameter value
            public var parameter68Value: String?
            /// Parameter name
            public var parameter69Name: String?
            /// Parameter value
            public var parameter69Value: String?
            /// Parameter name
            public var parameter7Name: String?
            /// Parameter value
            public var parameter7Value: String?
            /// Parameter name
            public var parameter70Name: String?
            /// Parameter value
            public var parameter70Value: String?
            /// Parameter name
            public var parameter71Name: String?
            /// Parameter value
            public var parameter71Value: String?
            /// Parameter name
            public var parameter72Name: String?
            /// Parameter value
            public var parameter72Value: String?
            /// Parameter name
            public var parameter73Name: String?
            /// Parameter value
            public var parameter73Value: String?
            /// Parameter name
            public var parameter74Name: String?
            /// Parameter value
            public var parameter74Value: String?
            /// Parameter name
            public var parameter75Name: String?
            /// Parameter value
            public var parameter75Value: String?
            /// Parameter name
            public var parameter76Name: String?
            /// Parameter value
            public var parameter76Value: String?
            /// Parameter name
            public var parameter77Name: String?
            /// Parameter value
            public var parameter77Value: String?
            /// Parameter name
            public var parameter78Name: String?
            /// Parameter value
            public var parameter78Value: String?
            /// Parameter name
            public var parameter79Name: String?
            /// Parameter value
            public var parameter79Value: String?
            /// Parameter name
            public var parameter8Name: String?
            /// Parameter value
            public var parameter8Value: String?
            /// Parameter name
            public var parameter80Name: String?
            /// Parameter value
            public var parameter80Value: String?
            /// Parameter name
            public var parameter81Name: String?
            /// Parameter value
            public var parameter81Value: String?
            /// Parameter name
            public var parameter82Name: String?
            /// Parameter value
            public var parameter82Value: String?
            /// Parameter name
            public var parameter83Name: String?
            /// Parameter value
            public var parameter83Value: String?
            /// Parameter name
            public var parameter84Name: String?
            /// Parameter value
            public var parameter84Value: String?
            /// Parameter name
            public var parameter85Name: String?
            /// Parameter value
            public var parameter85Value: String?
            /// Parameter name
            public var parameter86Name: String?
            /// Parameter value
            public var parameter86Value: String?
            /// Parameter name
            public var parameter87Name: String?
            /// Parameter value
            public var parameter87Value: String?
            /// Parameter name
            public var parameter88Name: String?
            /// Parameter value
            public var parameter88Value: String?
            /// Parameter name
            public var parameter89Name: String?
            /// Parameter value
            public var parameter89Value: String?
            /// Parameter name
            public var parameter9Name: String?
            /// Parameter value
            public var parameter9Value: String?
            /// Parameter name
            public var parameter90Name: String?
            /// Parameter value
            public var parameter90Value: String?
            /// Parameter name
            public var parameter91Name: String?
            /// Parameter value
            public var parameter91Value: String?
            /// Parameter name
            public var parameter92Name: String?
            /// Parameter value
            public var parameter92Value: String?
            /// Parameter name
            public var parameter93Name: String?
            /// Parameter value
            public var parameter93Value: String?
            /// Parameter name
            public var parameter94Name: String?
            /// Parameter value
            public var parameter94Value: String?
            /// Parameter name
            public var parameter95Name: String?
            /// Parameter value
            public var parameter95Value: String?
            /// Parameter name
            public var parameter96Name: String?
            /// Parameter value
            public var parameter96Value: String?
            /// Parameter name
            public var parameter97Name: String?
            /// Parameter value
            public var parameter97Value: String?
            /// Parameter name
            public var parameter98Name: String?
            /// Parameter value
            public var parameter98Value: String?
            /// Parameter name
            public var parameter99Name: String?
            /// Parameter value
            public var parameter99Value: String?
            /// Absolute URL of the status callback.
            public var statusCallback: URL?
            /// The http method for the status_callback (one of GET, POST).
            public var statusCallbackMethod: StatusCallbackMethod?
            /// One of `inbound_track`, `outbound_track`, `both_tracks`.
            public var track: Track?

            /// The http method for the status_callback (one of GET, POST).
            public enum StatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// One of `inbound_track`, `outbound_track`, `both_tracks`.
            public enum Track: String, Codable, CaseIterable {
                case inboundTrack = "inbound_track"
                case outboundTrack = "outbound_track"
                case bothTracks = "both_tracks"
            }

            public init(connectorName: String? = nil, name: String? = nil, parameter1Name: String? = nil, parameter1Value: String? = nil, parameter10Name: String? = nil, parameter10Value: String? = nil, parameter11Name: String? = nil, parameter11Value: String? = nil, parameter12Name: String? = nil, parameter12Value: String? = nil, parameter13Name: String? = nil, parameter13Value: String? = nil, parameter14Name: String? = nil, parameter14Value: String? = nil, parameter15Name: String? = nil, parameter15Value: String? = nil, parameter16Name: String? = nil, parameter16Value: String? = nil, parameter17Name: String? = nil, parameter17Value: String? = nil, parameter18Name: String? = nil, parameter18Value: String? = nil, parameter19Name: String? = nil, parameter19Value: String? = nil, parameter2Name: String? = nil, parameter2Value: String? = nil, parameter20Name: String? = nil, parameter20Value: String? = nil, parameter21Name: String? = nil, parameter21Value: String? = nil, parameter22Name: String? = nil, parameter22Value: String? = nil, parameter23Name: String? = nil, parameter23Value: String? = nil, parameter24Name: String? = nil, parameter24Value: String? = nil, parameter25Name: String? = nil, parameter25Value: String? = nil, parameter26Name: String? = nil, parameter26Value: String? = nil, parameter27Name: String? = nil, parameter27Value: String? = nil, parameter28Name: String? = nil, parameter28Value: String? = nil, parameter29Name: String? = nil, parameter29Value: String? = nil, parameter3Name: String? = nil, parameter3Value: String? = nil, parameter30Name: String? = nil, parameter30Value: String? = nil, parameter31Name: String? = nil, parameter31Value: String? = nil, parameter32Name: String? = nil, parameter32Value: String? = nil, parameter33Name: String? = nil, parameter33Value: String? = nil, parameter34Name: String? = nil, parameter34Value: String? = nil, parameter35Name: String? = nil, parameter35Value: String? = nil, parameter36Name: String? = nil, parameter36Value: String? = nil, parameter37Name: String? = nil, parameter37Value: String? = nil, parameter38Name: String? = nil, parameter38Value: String? = nil, parameter39Name: String? = nil, parameter39Value: String? = nil, parameter4Name: String? = nil, parameter4Value: String? = nil, parameter40Name: String? = nil, parameter40Value: String? = nil, parameter41Name: String? = nil, parameter41Value: String? = nil, parameter42Name: String? = nil, parameter42Value: String? = nil, parameter43Name: String? = nil, parameter43Value: String? = nil, parameter44Name: String? = nil, parameter44Value: String? = nil, parameter45Name: String? = nil, parameter45Value: String? = nil, parameter46Name: String? = nil, parameter46Value: String? = nil, parameter47Name: String? = nil, parameter47Value: String? = nil, parameter48Name: String? = nil, parameter48Value: String? = nil, parameter49Name: String? = nil, parameter49Value: String? = nil, parameter5Name: String? = nil, parameter5Value: String? = nil, parameter50Name: String? = nil, parameter50Value: String? = nil, parameter51Name: String? = nil, parameter51Value: String? = nil, parameter52Name: String? = nil, parameter52Value: String? = nil, parameter53Name: String? = nil, parameter53Value: String? = nil, parameter54Name: String? = nil, parameter54Value: String? = nil, parameter55Name: String? = nil, parameter55Value: String? = nil, parameter56Name: String? = nil, parameter56Value: String? = nil, parameter57Name: String? = nil, parameter57Value: String? = nil, parameter58Name: String? = nil, parameter58Value: String? = nil, parameter59Name: String? = nil, parameter59Value: String? = nil, parameter6Name: String? = nil, parameter6Value: String? = nil, parameter60Name: String? = nil, parameter60Value: String? = nil, parameter61Name: String? = nil, parameter61Value: String? = nil, parameter62Name: String? = nil, parameter62Value: String? = nil, parameter63Name: String? = nil, parameter63Value: String? = nil, parameter64Name: String? = nil, parameter64Value: String? = nil, parameter65Name: String? = nil, parameter65Value: String? = nil, parameter66Name: String? = nil, parameter66Value: String? = nil, parameter67Name: String? = nil, parameter67Value: String? = nil, parameter68Name: String? = nil, parameter68Value: String? = nil, parameter69Name: String? = nil, parameter69Value: String? = nil, parameter7Name: String? = nil, parameter7Value: String? = nil, parameter70Name: String? = nil, parameter70Value: String? = nil, parameter71Name: String? = nil, parameter71Value: String? = nil, parameter72Name: String? = nil, parameter72Value: String? = nil, parameter73Name: String? = nil, parameter73Value: String? = nil, parameter74Name: String? = nil, parameter74Value: String? = nil, parameter75Name: String? = nil, parameter75Value: String? = nil, parameter76Name: String? = nil, parameter76Value: String? = nil, parameter77Name: String? = nil, parameter77Value: String? = nil, parameter78Name: String? = nil, parameter78Value: String? = nil, parameter79Name: String? = nil, parameter79Value: String? = nil, parameter8Name: String? = nil, parameter8Value: String? = nil, parameter80Name: String? = nil, parameter80Value: String? = nil, parameter81Name: String? = nil, parameter81Value: String? = nil, parameter82Name: String? = nil, parameter82Value: String? = nil, parameter83Name: String? = nil, parameter83Value: String? = nil, parameter84Name: String? = nil, parameter84Value: String? = nil, parameter85Name: String? = nil, parameter85Value: String? = nil, parameter86Name: String? = nil, parameter86Value: String? = nil, parameter87Name: String? = nil, parameter87Value: String? = nil, parameter88Name: String? = nil, parameter88Value: String? = nil, parameter89Name: String? = nil, parameter89Value: String? = nil, parameter9Name: String? = nil, parameter9Value: String? = nil, parameter90Name: String? = nil, parameter90Value: String? = nil, parameter91Name: String? = nil, parameter91Value: String? = nil, parameter92Name: String? = nil, parameter92Value: String? = nil, parameter93Name: String? = nil, parameter93Value: String? = nil, parameter94Name: String? = nil, parameter94Value: String? = nil, parameter95Name: String? = nil, parameter95Value: String? = nil, parameter96Name: String? = nil, parameter96Value: String? = nil, parameter97Name: String? = nil, parameter97Value: String? = nil, parameter98Name: String? = nil, parameter98Value: String? = nil, parameter99Name: String? = nil, parameter99Value: String? = nil, statusCallback: URL? = nil, statusCallbackMethod: StatusCallbackMethod? = nil, track: Track? = nil) {
                self.connectorName = connectorName
                self.name = name
                self.parameter1Name = parameter1Name
                self.parameter1Value = parameter1Value
                self.parameter10Name = parameter10Name
                self.parameter10Value = parameter10Value
                self.parameter11Name = parameter11Name
                self.parameter11Value = parameter11Value
                self.parameter12Name = parameter12Name
                self.parameter12Value = parameter12Value
                self.parameter13Name = parameter13Name
                self.parameter13Value = parameter13Value
                self.parameter14Name = parameter14Name
                self.parameter14Value = parameter14Value
                self.parameter15Name = parameter15Name
                self.parameter15Value = parameter15Value
                self.parameter16Name = parameter16Name
                self.parameter16Value = parameter16Value
                self.parameter17Name = parameter17Name
                self.parameter17Value = parameter17Value
                self.parameter18Name = parameter18Name
                self.parameter18Value = parameter18Value
                self.parameter19Name = parameter19Name
                self.parameter19Value = parameter19Value
                self.parameter2Name = parameter2Name
                self.parameter2Value = parameter2Value
                self.parameter20Name = parameter20Name
                self.parameter20Value = parameter20Value
                self.parameter21Name = parameter21Name
                self.parameter21Value = parameter21Value
                self.parameter22Name = parameter22Name
                self.parameter22Value = parameter22Value
                self.parameter23Name = parameter23Name
                self.parameter23Value = parameter23Value
                self.parameter24Name = parameter24Name
                self.parameter24Value = parameter24Value
                self.parameter25Name = parameter25Name
                self.parameter25Value = parameter25Value
                self.parameter26Name = parameter26Name
                self.parameter26Value = parameter26Value
                self.parameter27Name = parameter27Name
                self.parameter27Value = parameter27Value
                self.parameter28Name = parameter28Name
                self.parameter28Value = parameter28Value
                self.parameter29Name = parameter29Name
                self.parameter29Value = parameter29Value
                self.parameter3Name = parameter3Name
                self.parameter3Value = parameter3Value
                self.parameter30Name = parameter30Name
                self.parameter30Value = parameter30Value
                self.parameter31Name = parameter31Name
                self.parameter31Value = parameter31Value
                self.parameter32Name = parameter32Name
                self.parameter32Value = parameter32Value
                self.parameter33Name = parameter33Name
                self.parameter33Value = parameter33Value
                self.parameter34Name = parameter34Name
                self.parameter34Value = parameter34Value
                self.parameter35Name = parameter35Name
                self.parameter35Value = parameter35Value
                self.parameter36Name = parameter36Name
                self.parameter36Value = parameter36Value
                self.parameter37Name = parameter37Name
                self.parameter37Value = parameter37Value
                self.parameter38Name = parameter38Name
                self.parameter38Value = parameter38Value
                self.parameter39Name = parameter39Name
                self.parameter39Value = parameter39Value
                self.parameter4Name = parameter4Name
                self.parameter4Value = parameter4Value
                self.parameter40Name = parameter40Name
                self.parameter40Value = parameter40Value
                self.parameter41Name = parameter41Name
                self.parameter41Value = parameter41Value
                self.parameter42Name = parameter42Name
                self.parameter42Value = parameter42Value
                self.parameter43Name = parameter43Name
                self.parameter43Value = parameter43Value
                self.parameter44Name = parameter44Name
                self.parameter44Value = parameter44Value
                self.parameter45Name = parameter45Name
                self.parameter45Value = parameter45Value
                self.parameter46Name = parameter46Name
                self.parameter46Value = parameter46Value
                self.parameter47Name = parameter47Name
                self.parameter47Value = parameter47Value
                self.parameter48Name = parameter48Name
                self.parameter48Value = parameter48Value
                self.parameter49Name = parameter49Name
                self.parameter49Value = parameter49Value
                self.parameter5Name = parameter5Name
                self.parameter5Value = parameter5Value
                self.parameter50Name = parameter50Name
                self.parameter50Value = parameter50Value
                self.parameter51Name = parameter51Name
                self.parameter51Value = parameter51Value
                self.parameter52Name = parameter52Name
                self.parameter52Value = parameter52Value
                self.parameter53Name = parameter53Name
                self.parameter53Value = parameter53Value
                self.parameter54Name = parameter54Name
                self.parameter54Value = parameter54Value
                self.parameter55Name = parameter55Name
                self.parameter55Value = parameter55Value
                self.parameter56Name = parameter56Name
                self.parameter56Value = parameter56Value
                self.parameter57Name = parameter57Name
                self.parameter57Value = parameter57Value
                self.parameter58Name = parameter58Name
                self.parameter58Value = parameter58Value
                self.parameter59Name = parameter59Name
                self.parameter59Value = parameter59Value
                self.parameter6Name = parameter6Name
                self.parameter6Value = parameter6Value
                self.parameter60Name = parameter60Name
                self.parameter60Value = parameter60Value
                self.parameter61Name = parameter61Name
                self.parameter61Value = parameter61Value
                self.parameter62Name = parameter62Name
                self.parameter62Value = parameter62Value
                self.parameter63Name = parameter63Name
                self.parameter63Value = parameter63Value
                self.parameter64Name = parameter64Name
                self.parameter64Value = parameter64Value
                self.parameter65Name = parameter65Name
                self.parameter65Value = parameter65Value
                self.parameter66Name = parameter66Name
                self.parameter66Value = parameter66Value
                self.parameter67Name = parameter67Name
                self.parameter67Value = parameter67Value
                self.parameter68Name = parameter68Name
                self.parameter68Value = parameter68Value
                self.parameter69Name = parameter69Name
                self.parameter69Value = parameter69Value
                self.parameter7Name = parameter7Name
                self.parameter7Value = parameter7Value
                self.parameter70Name = parameter70Name
                self.parameter70Value = parameter70Value
                self.parameter71Name = parameter71Name
                self.parameter71Value = parameter71Value
                self.parameter72Name = parameter72Name
                self.parameter72Value = parameter72Value
                self.parameter73Name = parameter73Name
                self.parameter73Value = parameter73Value
                self.parameter74Name = parameter74Name
                self.parameter74Value = parameter74Value
                self.parameter75Name = parameter75Name
                self.parameter75Value = parameter75Value
                self.parameter76Name = parameter76Name
                self.parameter76Value = parameter76Value
                self.parameter77Name = parameter77Name
                self.parameter77Value = parameter77Value
                self.parameter78Name = parameter78Name
                self.parameter78Value = parameter78Value
                self.parameter79Name = parameter79Name
                self.parameter79Value = parameter79Value
                self.parameter8Name = parameter8Name
                self.parameter8Value = parameter8Value
                self.parameter80Name = parameter80Name
                self.parameter80Value = parameter80Value
                self.parameter81Name = parameter81Name
                self.parameter81Value = parameter81Value
                self.parameter82Name = parameter82Name
                self.parameter82Value = parameter82Value
                self.parameter83Name = parameter83Name
                self.parameter83Value = parameter83Value
                self.parameter84Name = parameter84Name
                self.parameter84Value = parameter84Value
                self.parameter85Name = parameter85Name
                self.parameter85Value = parameter85Value
                self.parameter86Name = parameter86Name
                self.parameter86Value = parameter86Value
                self.parameter87Name = parameter87Name
                self.parameter87Value = parameter87Value
                self.parameter88Name = parameter88Name
                self.parameter88Value = parameter88Value
                self.parameter89Name = parameter89Name
                self.parameter89Value = parameter89Value
                self.parameter9Name = parameter9Name
                self.parameter9Value = parameter9Value
                self.parameter90Name = parameter90Name
                self.parameter90Value = parameter90Value
                self.parameter91Name = parameter91Name
                self.parameter91Value = parameter91Value
                self.parameter92Name = parameter92Name
                self.parameter92Value = parameter92Value
                self.parameter93Name = parameter93Name
                self.parameter93Value = parameter93Value
                self.parameter94Name = parameter94Name
                self.parameter94Value = parameter94Value
                self.parameter95Name = parameter95Name
                self.parameter95Value = parameter95Value
                self.parameter96Name = parameter96Name
                self.parameter96Value = parameter96Value
                self.parameter97Name = parameter97Name
                self.parameter97Value = parameter97Value
                self.parameter98Name = parameter98Name
                self.parameter98Value = parameter98Value
                self.parameter99Name = parameter99Name
                self.parameter99Value = parameter99Value
                self.statusCallback = statusCallback
                self.statusCallbackMethod = statusCallbackMethod
                self.track = track
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("ConnectorName", connectorName?.asQueryValue)
                query.addQueryItem("Name", name?.asQueryValue)
                query.addQueryItem("Parameter1.Name", parameter1Name?.asQueryValue)
                query.addQueryItem("Parameter1.Value", parameter1Value?.asQueryValue)
                query.addQueryItem("Parameter10.Name", parameter10Name?.asQueryValue)
                query.addQueryItem("Parameter10.Value", parameter10Value?.asQueryValue)
                query.addQueryItem("Parameter11.Name", parameter11Name?.asQueryValue)
                query.addQueryItem("Parameter11.Value", parameter11Value?.asQueryValue)
                query.addQueryItem("Parameter12.Name", parameter12Name?.asQueryValue)
                query.addQueryItem("Parameter12.Value", parameter12Value?.asQueryValue)
                query.addQueryItem("Parameter13.Name", parameter13Name?.asQueryValue)
                query.addQueryItem("Parameter13.Value", parameter13Value?.asQueryValue)
                query.addQueryItem("Parameter14.Name", parameter14Name?.asQueryValue)
                query.addQueryItem("Parameter14.Value", parameter14Value?.asQueryValue)
                query.addQueryItem("Parameter15.Name", parameter15Name?.asQueryValue)
                query.addQueryItem("Parameter15.Value", parameter15Value?.asQueryValue)
                query.addQueryItem("Parameter16.Name", parameter16Name?.asQueryValue)
                query.addQueryItem("Parameter16.Value", parameter16Value?.asQueryValue)
                query.addQueryItem("Parameter17.Name", parameter17Name?.asQueryValue)
                query.addQueryItem("Parameter17.Value", parameter17Value?.asQueryValue)
                query.addQueryItem("Parameter18.Name", parameter18Name?.asQueryValue)
                query.addQueryItem("Parameter18.Value", parameter18Value?.asQueryValue)
                query.addQueryItem("Parameter19.Name", parameter19Name?.asQueryValue)
                query.addQueryItem("Parameter19.Value", parameter19Value?.asQueryValue)
                query.addQueryItem("Parameter2.Name", parameter2Name?.asQueryValue)
                query.addQueryItem("Parameter2.Value", parameter2Value?.asQueryValue)
                query.addQueryItem("Parameter20.Name", parameter20Name?.asQueryValue)
                query.addQueryItem("Parameter20.Value", parameter20Value?.asQueryValue)
                query.addQueryItem("Parameter21.Name", parameter21Name?.asQueryValue)
                query.addQueryItem("Parameter21.Value", parameter21Value?.asQueryValue)
                query.addQueryItem("Parameter22.Name", parameter22Name?.asQueryValue)
                query.addQueryItem("Parameter22.Value", parameter22Value?.asQueryValue)
                query.addQueryItem("Parameter23.Name", parameter23Name?.asQueryValue)
                query.addQueryItem("Parameter23.Value", parameter23Value?.asQueryValue)
                query.addQueryItem("Parameter24.Name", parameter24Name?.asQueryValue)
                query.addQueryItem("Parameter24.Value", parameter24Value?.asQueryValue)
                query.addQueryItem("Parameter25.Name", parameter25Name?.asQueryValue)
                query.addQueryItem("Parameter25.Value", parameter25Value?.asQueryValue)
                query.addQueryItem("Parameter26.Name", parameter26Name?.asQueryValue)
                query.addQueryItem("Parameter26.Value", parameter26Value?.asQueryValue)
                query.addQueryItem("Parameter27.Name", parameter27Name?.asQueryValue)
                query.addQueryItem("Parameter27.Value", parameter27Value?.asQueryValue)
                query.addQueryItem("Parameter28.Name", parameter28Name?.asQueryValue)
                query.addQueryItem("Parameter28.Value", parameter28Value?.asQueryValue)
                query.addQueryItem("Parameter29.Name", parameter29Name?.asQueryValue)
                query.addQueryItem("Parameter29.Value", parameter29Value?.asQueryValue)
                query.addQueryItem("Parameter3.Name", parameter3Name?.asQueryValue)
                query.addQueryItem("Parameter3.Value", parameter3Value?.asQueryValue)
                query.addQueryItem("Parameter30.Name", parameter30Name?.asQueryValue)
                query.addQueryItem("Parameter30.Value", parameter30Value?.asQueryValue)
                query.addQueryItem("Parameter31.Name", parameter31Name?.asQueryValue)
                query.addQueryItem("Parameter31.Value", parameter31Value?.asQueryValue)
                query.addQueryItem("Parameter32.Name", parameter32Name?.asQueryValue)
                query.addQueryItem("Parameter32.Value", parameter32Value?.asQueryValue)
                query.addQueryItem("Parameter33.Name", parameter33Name?.asQueryValue)
                query.addQueryItem("Parameter33.Value", parameter33Value?.asQueryValue)
                query.addQueryItem("Parameter34.Name", parameter34Name?.asQueryValue)
                query.addQueryItem("Parameter34.Value", parameter34Value?.asQueryValue)
                query.addQueryItem("Parameter35.Name", parameter35Name?.asQueryValue)
                query.addQueryItem("Parameter35.Value", parameter35Value?.asQueryValue)
                query.addQueryItem("Parameter36.Name", parameter36Name?.asQueryValue)
                query.addQueryItem("Parameter36.Value", parameter36Value?.asQueryValue)
                query.addQueryItem("Parameter37.Name", parameter37Name?.asQueryValue)
                query.addQueryItem("Parameter37.Value", parameter37Value?.asQueryValue)
                query.addQueryItem("Parameter38.Name", parameter38Name?.asQueryValue)
                query.addQueryItem("Parameter38.Value", parameter38Value?.asQueryValue)
                query.addQueryItem("Parameter39.Name", parameter39Name?.asQueryValue)
                query.addQueryItem("Parameter39.Value", parameter39Value?.asQueryValue)
                query.addQueryItem("Parameter4.Name", parameter4Name?.asQueryValue)
                query.addQueryItem("Parameter4.Value", parameter4Value?.asQueryValue)
                query.addQueryItem("Parameter40.Name", parameter40Name?.asQueryValue)
                query.addQueryItem("Parameter40.Value", parameter40Value?.asQueryValue)
                query.addQueryItem("Parameter41.Name", parameter41Name?.asQueryValue)
                query.addQueryItem("Parameter41.Value", parameter41Value?.asQueryValue)
                query.addQueryItem("Parameter42.Name", parameter42Name?.asQueryValue)
                query.addQueryItem("Parameter42.Value", parameter42Value?.asQueryValue)
                query.addQueryItem("Parameter43.Name", parameter43Name?.asQueryValue)
                query.addQueryItem("Parameter43.Value", parameter43Value?.asQueryValue)
                query.addQueryItem("Parameter44.Name", parameter44Name?.asQueryValue)
                query.addQueryItem("Parameter44.Value", parameter44Value?.asQueryValue)
                query.addQueryItem("Parameter45.Name", parameter45Name?.asQueryValue)
                query.addQueryItem("Parameter45.Value", parameter45Value?.asQueryValue)
                query.addQueryItem("Parameter46.Name", parameter46Name?.asQueryValue)
                query.addQueryItem("Parameter46.Value", parameter46Value?.asQueryValue)
                query.addQueryItem("Parameter47.Name", parameter47Name?.asQueryValue)
                query.addQueryItem("Parameter47.Value", parameter47Value?.asQueryValue)
                query.addQueryItem("Parameter48.Name", parameter48Name?.asQueryValue)
                query.addQueryItem("Parameter48.Value", parameter48Value?.asQueryValue)
                query.addQueryItem("Parameter49.Name", parameter49Name?.asQueryValue)
                query.addQueryItem("Parameter49.Value", parameter49Value?.asQueryValue)
                query.addQueryItem("Parameter5.Name", parameter5Name?.asQueryValue)
                query.addQueryItem("Parameter5.Value", parameter5Value?.asQueryValue)
                query.addQueryItem("Parameter50.Name", parameter50Name?.asQueryValue)
                query.addQueryItem("Parameter50.Value", parameter50Value?.asQueryValue)
                query.addQueryItem("Parameter51.Name", parameter51Name?.asQueryValue)
                query.addQueryItem("Parameter51.Value", parameter51Value?.asQueryValue)
                query.addQueryItem("Parameter52.Name", parameter52Name?.asQueryValue)
                query.addQueryItem("Parameter52.Value", parameter52Value?.asQueryValue)
                query.addQueryItem("Parameter53.Name", parameter53Name?.asQueryValue)
                query.addQueryItem("Parameter53.Value", parameter53Value?.asQueryValue)
                query.addQueryItem("Parameter54.Name", parameter54Name?.asQueryValue)
                query.addQueryItem("Parameter54.Value", parameter54Value?.asQueryValue)
                query.addQueryItem("Parameter55.Name", parameter55Name?.asQueryValue)
                query.addQueryItem("Parameter55.Value", parameter55Value?.asQueryValue)
                query.addQueryItem("Parameter56.Name", parameter56Name?.asQueryValue)
                query.addQueryItem("Parameter56.Value", parameter56Value?.asQueryValue)
                query.addQueryItem("Parameter57.Name", parameter57Name?.asQueryValue)
                query.addQueryItem("Parameter57.Value", parameter57Value?.asQueryValue)
                query.addQueryItem("Parameter58.Name", parameter58Name?.asQueryValue)
                query.addQueryItem("Parameter58.Value", parameter58Value?.asQueryValue)
                query.addQueryItem("Parameter59.Name", parameter59Name?.asQueryValue)
                query.addQueryItem("Parameter59.Value", parameter59Value?.asQueryValue)
                query.addQueryItem("Parameter6.Name", parameter6Name?.asQueryValue)
                query.addQueryItem("Parameter6.Value", parameter6Value?.asQueryValue)
                query.addQueryItem("Parameter60.Name", parameter60Name?.asQueryValue)
                query.addQueryItem("Parameter60.Value", parameter60Value?.asQueryValue)
                query.addQueryItem("Parameter61.Name", parameter61Name?.asQueryValue)
                query.addQueryItem("Parameter61.Value", parameter61Value?.asQueryValue)
                query.addQueryItem("Parameter62.Name", parameter62Name?.asQueryValue)
                query.addQueryItem("Parameter62.Value", parameter62Value?.asQueryValue)
                query.addQueryItem("Parameter63.Name", parameter63Name?.asQueryValue)
                query.addQueryItem("Parameter63.Value", parameter63Value?.asQueryValue)
                query.addQueryItem("Parameter64.Name", parameter64Name?.asQueryValue)
                query.addQueryItem("Parameter64.Value", parameter64Value?.asQueryValue)
                query.addQueryItem("Parameter65.Name", parameter65Name?.asQueryValue)
                query.addQueryItem("Parameter65.Value", parameter65Value?.asQueryValue)
                query.addQueryItem("Parameter66.Name", parameter66Name?.asQueryValue)
                query.addQueryItem("Parameter66.Value", parameter66Value?.asQueryValue)
                query.addQueryItem("Parameter67.Name", parameter67Name?.asQueryValue)
                query.addQueryItem("Parameter67.Value", parameter67Value?.asQueryValue)
                query.addQueryItem("Parameter68.Name", parameter68Name?.asQueryValue)
                query.addQueryItem("Parameter68.Value", parameter68Value?.asQueryValue)
                query.addQueryItem("Parameter69.Name", parameter69Name?.asQueryValue)
                query.addQueryItem("Parameter69.Value", parameter69Value?.asQueryValue)
                query.addQueryItem("Parameter7.Name", parameter7Name?.asQueryValue)
                query.addQueryItem("Parameter7.Value", parameter7Value?.asQueryValue)
                query.addQueryItem("Parameter70.Name", parameter70Name?.asQueryValue)
                query.addQueryItem("Parameter70.Value", parameter70Value?.asQueryValue)
                query.addQueryItem("Parameter71.Name", parameter71Name?.asQueryValue)
                query.addQueryItem("Parameter71.Value", parameter71Value?.asQueryValue)
                query.addQueryItem("Parameter72.Name", parameter72Name?.asQueryValue)
                query.addQueryItem("Parameter72.Value", parameter72Value?.asQueryValue)
                query.addQueryItem("Parameter73.Name", parameter73Name?.asQueryValue)
                query.addQueryItem("Parameter73.Value", parameter73Value?.asQueryValue)
                query.addQueryItem("Parameter74.Name", parameter74Name?.asQueryValue)
                query.addQueryItem("Parameter74.Value", parameter74Value?.asQueryValue)
                query.addQueryItem("Parameter75.Name", parameter75Name?.asQueryValue)
                query.addQueryItem("Parameter75.Value", parameter75Value?.asQueryValue)
                query.addQueryItem("Parameter76.Name", parameter76Name?.asQueryValue)
                query.addQueryItem("Parameter76.Value", parameter76Value?.asQueryValue)
                query.addQueryItem("Parameter77.Name", parameter77Name?.asQueryValue)
                query.addQueryItem("Parameter77.Value", parameter77Value?.asQueryValue)
                query.addQueryItem("Parameter78.Name", parameter78Name?.asQueryValue)
                query.addQueryItem("Parameter78.Value", parameter78Value?.asQueryValue)
                query.addQueryItem("Parameter79.Name", parameter79Name?.asQueryValue)
                query.addQueryItem("Parameter79.Value", parameter79Value?.asQueryValue)
                query.addQueryItem("Parameter8.Name", parameter8Name?.asQueryValue)
                query.addQueryItem("Parameter8.Value", parameter8Value?.asQueryValue)
                query.addQueryItem("Parameter80.Name", parameter80Name?.asQueryValue)
                query.addQueryItem("Parameter80.Value", parameter80Value?.asQueryValue)
                query.addQueryItem("Parameter81.Name", parameter81Name?.asQueryValue)
                query.addQueryItem("Parameter81.Value", parameter81Value?.asQueryValue)
                query.addQueryItem("Parameter82.Name", parameter82Name?.asQueryValue)
                query.addQueryItem("Parameter82.Value", parameter82Value?.asQueryValue)
                query.addQueryItem("Parameter83.Name", parameter83Name?.asQueryValue)
                query.addQueryItem("Parameter83.Value", parameter83Value?.asQueryValue)
                query.addQueryItem("Parameter84.Name", parameter84Name?.asQueryValue)
                query.addQueryItem("Parameter84.Value", parameter84Value?.asQueryValue)
                query.addQueryItem("Parameter85.Name", parameter85Name?.asQueryValue)
                query.addQueryItem("Parameter85.Value", parameter85Value?.asQueryValue)
                query.addQueryItem("Parameter86.Name", parameter86Name?.asQueryValue)
                query.addQueryItem("Parameter86.Value", parameter86Value?.asQueryValue)
                query.addQueryItem("Parameter87.Name", parameter87Name?.asQueryValue)
                query.addQueryItem("Parameter87.Value", parameter87Value?.asQueryValue)
                query.addQueryItem("Parameter88.Name", parameter88Name?.asQueryValue)
                query.addQueryItem("Parameter88.Value", parameter88Value?.asQueryValue)
                query.addQueryItem("Parameter89.Name", parameter89Name?.asQueryValue)
                query.addQueryItem("Parameter89.Value", parameter89Value?.asQueryValue)
                query.addQueryItem("Parameter9.Name", parameter9Name?.asQueryValue)
                query.addQueryItem("Parameter9.Value", parameter9Value?.asQueryValue)
                query.addQueryItem("Parameter90.Name", parameter90Name?.asQueryValue)
                query.addQueryItem("Parameter90.Value", parameter90Value?.asQueryValue)
                query.addQueryItem("Parameter91.Name", parameter91Name?.asQueryValue)
                query.addQueryItem("Parameter91.Value", parameter91Value?.asQueryValue)
                query.addQueryItem("Parameter92.Name", parameter92Name?.asQueryValue)
                query.addQueryItem("Parameter92.Value", parameter92Value?.asQueryValue)
                query.addQueryItem("Parameter93.Name", parameter93Name?.asQueryValue)
                query.addQueryItem("Parameter93.Value", parameter93Value?.asQueryValue)
                query.addQueryItem("Parameter94.Name", parameter94Name?.asQueryValue)
                query.addQueryItem("Parameter94.Value", parameter94Value?.asQueryValue)
                query.addQueryItem("Parameter95.Name", parameter95Name?.asQueryValue)
                query.addQueryItem("Parameter95.Value", parameter95Value?.asQueryValue)
                query.addQueryItem("Parameter96.Name", parameter96Name?.asQueryValue)
                query.addQueryItem("Parameter96.Value", parameter96Value?.asQueryValue)
                query.addQueryItem("Parameter97.Name", parameter97Name?.asQueryValue)
                query.addQueryItem("Parameter97.Value", parameter97Value?.asQueryValue)
                query.addQueryItem("Parameter98.Name", parameter98Name?.asQueryValue)
                query.addQueryItem("Parameter98.Value", parameter98Value?.asQueryValue)
                query.addQueryItem("Parameter99.Name", parameter99Name?.asQueryValue)
                query.addQueryItem("Parameter99.Value", parameter99Value?.asQueryValue)
                query.addQueryItem("StatusCallback", statusCallback?.asQueryValue)
                query.addQueryItem("StatusCallbackMethod", statusCallbackMethod?.asQueryValue)
                query.addQueryItem("Track", track?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Calls.WithCallSid {
    public var siprec: Siprec {
        Siprec(path: path + "/Siprec")
    }

    public struct Siprec {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Siprec`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Calls.WithCallSid.Siprec {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Siprec/{Sid}.json`
        public let path: String

        /// Stop a Siprec using either the SID of the Siprec resource or the `name` used when creating the resource
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountCallSiprec> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateSiprecRequest
        public struct PostRequest: Encodable {
            /// The status. Must have the value `stopped`
            public var status: Status

            /// The status. Must have the value `stopped`
            public enum Status: String, Codable, CaseIterable {
                case stopped
            }

            public init(status: Status) {
                self.status = status
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("Status", status.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Calls {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json`
        public let path: String

        /// Fetch the call specified by the provided Call SID
        public var get: Request<TwilioAPI.APIV2010AccountCall> {
            .get(path)
        }

        /// Initiates a call redirect or terminates a call
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountCall> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateCallRequest
        public struct PostRequest: Encodable {
            /// The HTTP method that we should use to request the `fallback_url`. Can be: `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is present, this parameter is ignored.
            public var fallbackMethod: FallbackMethod?
            /// The URL that we call using the `fallback_method` if an error occurs when requesting or executing the TwiML at `url`. If an `application_sid` parameter is present, this parameter is ignored.
            public var fallbackURL: URL?
            /// The HTTP method we should use when calling the `url`. Can be: `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is present, this parameter is ignored.
            public var method: Method?
            /// The new status of the resource. Can be: `canceled` or `completed`. Specifying `canceled` will attempt to hang up calls that are queued or ringing; however, it will not affect calls already in progress. Specifying `completed` will attempt to hang up a call even if it's already in progress.
            public var status: Status?
            /// The URL we should call using the `status_callback_method` to send status information to your application. If no `status_callback_event` is specified, we will send the `completed` status. If an `application_sid` parameter is present, this parameter is ignored. URLs must contain a valid hostname (underscores are not permitted).
            public var statusCallback: URL?
            /// The HTTP method we should use when requesting the `status_callback` URL. Can be: `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is present, this parameter is ignored.
            public var statusCallbackMethod: StatusCallbackMethod?
            /// The maximum duration of the call in seconds. Constraints depend on account and configuration.
            public var timeLimit: Int?
            /// TwiML instructions for the call Twilio will use without fetching Twiml from url. Twiml and url parameters are mutually exclusive
            public var twiml: String?
            /// The absolute URL that returns the TwiML instructions for the call. We will call this URL using the `method` when the call connects. For more information, see the [Url Parameter](https://www.twilio.com/docs/voice/make-calls#specify-a-url-parameter) section in [Making Calls](https://www.twilio.com/docs/voice/make-calls).
            public var url: URL?

            /// The HTTP method that we should use to request the `fallback_url`. Can be: `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is present, this parameter is ignored.
            public enum FallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use when calling the `url`. Can be: `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is present, this parameter is ignored.
            public enum Method: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The new status of the resource. Can be: `canceled` or `completed`. Specifying `canceled` will attempt to hang up calls that are queued or ringing; however, it will not affect calls already in progress. Specifying `completed` will attempt to hang up a call even if it's already in progress.
            public enum Status: String, Codable, CaseIterable {
                case canceled
                case completed
            }

            /// The HTTP method we should use when requesting the `status_callback` URL. Can be: `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is present, this parameter is ignored.
            public enum StatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            public init(fallbackMethod: FallbackMethod? = nil, fallbackURL: URL? = nil, method: Method? = nil, status: Status? = nil, statusCallback: URL? = nil, statusCallbackMethod: StatusCallbackMethod? = nil, timeLimit: Int? = nil, twiml: String? = nil, url: URL? = nil) {
                self.fallbackMethod = fallbackMethod
                self.fallbackURL = fallbackURL
                self.method = method
                self.status = status
                self.statusCallback = statusCallback
                self.statusCallbackMethod = statusCallbackMethod
                self.timeLimit = timeLimit
                self.twiml = twiml
                self.url = url
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("FallbackMethod", fallbackMethod?.asQueryValue)
                query.addQueryItem("FallbackUrl", fallbackURL?.asQueryValue)
                query.addQueryItem("Method", method?.asQueryValue)
                query.addQueryItem("Status", status?.asQueryValue)
                query.addQueryItem("StatusCallback", statusCallback?.asQueryValue)
                query.addQueryItem("StatusCallbackMethod", statusCallbackMethod?.asQueryValue)
                query.addQueryItem("TimeLimit", timeLimit?.asQueryValue)
                query.addQueryItem("Twiml", twiml?.asQueryValue)
                query.addQueryItem("Url", url?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }

        /// Delete a Call record from your account. Once the record is deleted, it will no longer appear in the API and Account Portal logs.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var conferencesJSON: ConferencesJSON {
        ConferencesJSON(path: path + "/Conferences.json")
    }

    public struct ConferencesJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Conferences.json`
        public let path: String

        /// Retrieve a list of conferences belonging to the account used to make the request
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListConferenceResponse
        public struct GetResponse: Decodable {
            public var conferences: [TwilioAPI.APIV2010AccountConference]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(conferences: [TwilioAPI.APIV2010AccountConference]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.conferences = conferences
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case conferences
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var dateCreated: NaiveDate?
            public var dateCreatedLessThan: NaiveDate?
            public var dateCreatedGreaterThan: NaiveDate?
            public var dateUpdated: NaiveDate?
            public var dateUpdatedLessThan: NaiveDate?
            public var dateUpdatedGreaterThan: NaiveDate?
            public var friendlyName: String?
            public var status: Status?
            public var pageSize: Int?

            public enum Status: String, Codable, CaseIterable {
                case `init`
                case inProgress = "in-progress"
                case completed
            }

            public init(dateCreated: NaiveDate? = nil, dateCreatedLessThan: NaiveDate? = nil, dateCreatedGreaterThan: NaiveDate? = nil, dateUpdated: NaiveDate? = nil, dateUpdatedLessThan: NaiveDate? = nil, dateUpdatedGreaterThan: NaiveDate? = nil, friendlyName: String? = nil, status: Status? = nil, pageSize: Int? = nil) {
                self.dateCreated = dateCreated
                self.dateCreatedLessThan = dateCreatedLessThan
                self.dateCreatedGreaterThan = dateCreatedGreaterThan
                self.dateUpdated = dateUpdated
                self.dateUpdatedLessThan = dateUpdatedLessThan
                self.dateUpdatedGreaterThan = dateUpdatedGreaterThan
                self.friendlyName = friendlyName
                self.status = status
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("DateCreated", dateCreated?.asQueryValue)
                query.addQueryItem("DateCreated<", dateCreatedLessThan?.asQueryValue)
                query.addQueryItem("DateCreated>", dateCreatedGreaterThan?.asQueryValue)
                query.addQueryItem("DateUpdated", dateUpdated?.asQueryValue)
                query.addQueryItem("DateUpdated<", dateUpdatedLessThan?.asQueryValue)
                query.addQueryItem("DateUpdated>", dateUpdatedGreaterThan?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("Status", status?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var conferences: Conferences {
        Conferences(path: path + "/Conferences")
    }

    public struct Conferences {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Conferences`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Conferences {
    public func conferenceSid(_ conferenceSid: String) -> WithConferenceSid {
        WithConferenceSid(path: "\(path)/\(conferenceSid)")
    }

    public struct WithConferenceSid {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Conferences.WithConferenceSid {
    public var participantsJSON: ParticipantsJSON {
        ParticipantsJSON(path: path + "/Participants.json")
    }

    public struct ParticipantsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants.json`
        public let path: String

        /// Retrieve a list of participants belonging to the account used to make the request
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListParticipantResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var participants: [TwilioAPI.APIV2010AccountConferenceParticipant]?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, participants: [TwilioAPI.APIV2010AccountConferenceParticipant]? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.participants = participants
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case participants
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var isMuted: Bool?
            public var isHold: Bool?
            public var isCoaching: Bool?
            public var pageSize: Int?

            public init(isMuted: Bool? = nil, isHold: Bool? = nil, isCoaching: Bool? = nil, pageSize: Int? = nil) {
                self.isMuted = isMuted
                self.isHold = isHold
                self.isCoaching = isCoaching
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("Muted", isMuted?.asQueryValue)
                query.addQueryItem("Hold", isHold?.asQueryValue)
                query.addQueryItem("Coaching", isCoaching?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }

        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountConferenceParticipant> {
            .post(path, body: body?.asQuery())
        }

        /// CreateParticipantRequest
        public struct PostRequest: Encodable {
            /// Whether to play a notification beep to the conference when the participant joins. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.
            public var beep: String?
            /// The SID of a BYOC (Bring Your Own Carrier) trunk to route this call with. Note that `byoc` is only meaningful when `to` is a phone number; it will otherwise be ignored. (Beta)
            public var byoc: String?
            /// The Reason for the outgoing call. Use it to specify the purpose of the call that is presented on the called party's phone. (Branded Calls Beta)
            public var callReason: String?
            /// The SID of the participant who is being `coached`. The participant being coached is the only participant who can hear the participant who is `coaching`.
            public var callSidToCoach: String?
            /// The phone number, Client identifier, or username portion of SIP address that made this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). Client identifiers are formatted `client:name`. If using a phone number, it must be a Twilio number or a Verified [outgoing caller id](https://www.twilio.com/docs/voice/api/outgoing-caller-ids) for your account. If the `to` parameter is a phone number, `callerId` must also be a phone number. If `to` is sip address, this value of `callerId` should be a username portion to be used to populate the From header that is passed to the SIP endpoint.
            public var callerID: String?
            /// Whether the participant is coaching another call. Can be: `true` or `false`. If not present, defaults to `false` unless `call_sid_to_coach` is defined. If `true`, `call_sid_to_coach` must be defined.
            public var isCoaching: Bool?
            /// Whether to record the conference the participant is joining. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.
            public var conferenceRecord: String?
            /// The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.
            public var conferenceRecordingStatusCallback: URL?
            /// The conference recording state changes that generate a call to `conference_recording_status_callback`. Can be: `in-progress`, `completed`, `failed`, and `absent`. Separate multiple values with a space, ex: `'in-progress completed failed'`
            public var conferenceRecordingStatusCallbackEvent: [String]?
            /// The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
            public var conferenceRecordingStatusCallbackMethod: ConferenceRecordingStatusCallbackMethod?
            /// The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.
            public var conferenceStatusCallback: URL?
            /// The conference state changes that should generate a call to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `modify`, `speaker`, and `announcement`. Separate multiple values with a space. Defaults to `start end`.
            public var conferenceStatusCallbackEvent: [String]?
            /// The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
            public var conferenceStatusCallbackMethod: ConferenceStatusCallbackMethod?
            /// Whether to trim leading and trailing silence from your recorded conference audio files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.
            public var conferenceTrim: String?
            /// Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. Can be: `true` or `false` and defaults to `true`.
            public var isEarlyMedia: Bool?
            /// Whether to end the conference when the participant leaves. Can be: `true` or `false` and defaults to `false`.
            public var isEndConferenceOnExit: Bool?
            /// The phone number, Client identifier, or username portion of SIP address that made this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). Client identifiers are formatted `client:name`. If using a phone number, it must be a Twilio number or a Verified [outgoing caller id](https://www.twilio.com/docs/voice/api/outgoing-caller-ids) for your account. If the `to` parameter is a phone number, `from` must also be a phone number. If `to` is sip address, this value of `from` should be a username portion to be used to populate the P-Asserted-Identity header that is passed to the SIP endpoint.
            public var from: String
            /// Jitter buffer size for the connecting participant. Twilio will use this setting to apply Jitter Buffer before participant's audio is mixed into the conference. Can be: `off`, `small`, `medium`, and `large`. Default to `large`.
            public var jitterBufferSize: String?
            /// A label for this participant. If one is supplied, it may subsequently be used to fetch, update or delete the participant.
            public var label: String?
            /// The maximum number of participants in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.
            public var maxParticipants: Int?
            /// Whether the agent is muted in the conference. Can be `true` or `false` and the default is `false`.
            public var isMuted: Bool?
            /// Whether to record the participant and their conferences, including the time between conferences. Can be `true` or `false` and the default is `false`.
            public var isRecord: Bool?
            /// The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.
            public var recordingChannels: String?
            /// The URL that we should call using the `recording_status_callback_method` when the recording status changes.
            public var recordingStatusCallback: URL?
            /// The recording state changes that should generate a call to `recording_status_callback`. Can be: `started`, `in-progress`, `paused`, `resumed`, `stopped`, `completed`, `failed`, and `absent`. Separate multiple values with a space, ex: `'in-progress completed failed'`.
            public var recordingStatusCallbackEvent: [String]?
            /// The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
            public var recordingStatusCallbackMethod: RecordingStatusCallbackMethod?
            /// The audio track to record for the call. Can be: `inbound`, `outbound` or `both`. The default is `both`. `inbound` records the audio that is received by Twilio. `outbound` records the audio that is sent from Twilio. `both` records the audio that is received and sent by Twilio.
            public var recordingTrack: String?
            /// The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.
            public var region: String?
            /// The SIP password for authentication.
            public var sipAuthPassword: String?
            /// The SIP username used for authentication.
            public var sipAuthUsername: String?
            /// Whether to start the conference when the participant joins, if it has not already started. Can be: `true` or `false` and the default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.
            public var isStartConferenceOnEnter: Bool?
            /// The URL we should call using the `status_callback_method` to send status information to your application.
            public var statusCallback: URL?
            /// The conference state changes that should generate a call to `status_callback`. Can be: `initiated`, `ringing`, `answered`, and `completed`. Separate multiple values with a space. The default value is `completed`.
            public var statusCallbackEvent: [String]?
            /// The HTTP method we should use to call `status_callback`. Can be: `GET` and `POST` and defaults to `POST`.
            public var statusCallbackMethod: StatusCallbackMethod?
            /// The maximum duration of the call in seconds. Constraints depend on account and configuration.
            public var timeLimit: Int?
            /// The number of seconds that we should allow the phone to ring before assuming there is no answer. Can be an integer between `5` and `600`, inclusive. The default value is `60`. We always add a 5-second timeout buffer to outgoing calls, so  value of 10 would result in an actual timeout that was closer to 15 seconds.
            public var timeout: Int?
            /// The phone number, SIP address, or Client identifier that received this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). SIP addresses are formatted as `sip:name@company.com`. Client identifiers are formatted `client:name`. [Custom parameters](https://www.twilio.com/docs/voice/api/conference-participant-resource#custom-parameters) may also be specified.
            public var to: String
            /// The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
            public var waitMethod: WaitMethod?
            /// The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).
            public var waitURL: URL?

            /// The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum ConferenceRecordingStatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum ConferenceStatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum RecordingStatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `status_callback`. Can be: `GET` and `POST` and defaults to `POST`.
            public enum StatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
            public enum WaitMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            public init(beep: String? = nil, byoc: String? = nil, callReason: String? = nil, callSidToCoach: String? = nil, callerID: String? = nil, isCoaching: Bool? = nil, conferenceRecord: String? = nil, conferenceRecordingStatusCallback: URL? = nil, conferenceRecordingStatusCallbackEvent: [String]? = nil, conferenceRecordingStatusCallbackMethod: ConferenceRecordingStatusCallbackMethod? = nil, conferenceStatusCallback: URL? = nil, conferenceStatusCallbackEvent: [String]? = nil, conferenceStatusCallbackMethod: ConferenceStatusCallbackMethod? = nil, conferenceTrim: String? = nil, isEarlyMedia: Bool? = nil, isEndConferenceOnExit: Bool? = nil, from: String, jitterBufferSize: String? = nil, label: String? = nil, maxParticipants: Int? = nil, isMuted: Bool? = nil, isRecord: Bool? = nil, recordingChannels: String? = nil, recordingStatusCallback: URL? = nil, recordingStatusCallbackEvent: [String]? = nil, recordingStatusCallbackMethod: RecordingStatusCallbackMethod? = nil, recordingTrack: String? = nil, region: String? = nil, sipAuthPassword: String? = nil, sipAuthUsername: String? = nil, isStartConferenceOnEnter: Bool? = nil, statusCallback: URL? = nil, statusCallbackEvent: [String]? = nil, statusCallbackMethod: StatusCallbackMethod? = nil, timeLimit: Int? = nil, timeout: Int? = nil, to: String, waitMethod: WaitMethod? = nil, waitURL: URL? = nil) {
                self.beep = beep
                self.byoc = byoc
                self.callReason = callReason
                self.callSidToCoach = callSidToCoach
                self.callerID = callerID
                self.isCoaching = isCoaching
                self.conferenceRecord = conferenceRecord
                self.conferenceRecordingStatusCallback = conferenceRecordingStatusCallback
                self.conferenceRecordingStatusCallbackEvent = conferenceRecordingStatusCallbackEvent
                self.conferenceRecordingStatusCallbackMethod = conferenceRecordingStatusCallbackMethod
                self.conferenceStatusCallback = conferenceStatusCallback
                self.conferenceStatusCallbackEvent = conferenceStatusCallbackEvent
                self.conferenceStatusCallbackMethod = conferenceStatusCallbackMethod
                self.conferenceTrim = conferenceTrim
                self.isEarlyMedia = isEarlyMedia
                self.isEndConferenceOnExit = isEndConferenceOnExit
                self.from = from
                self.jitterBufferSize = jitterBufferSize
                self.label = label
                self.maxParticipants = maxParticipants
                self.isMuted = isMuted
                self.isRecord = isRecord
                self.recordingChannels = recordingChannels
                self.recordingStatusCallback = recordingStatusCallback
                self.recordingStatusCallbackEvent = recordingStatusCallbackEvent
                self.recordingStatusCallbackMethod = recordingStatusCallbackMethod
                self.recordingTrack = recordingTrack
                self.region = region
                self.sipAuthPassword = sipAuthPassword
                self.sipAuthUsername = sipAuthUsername
                self.isStartConferenceOnEnter = isStartConferenceOnEnter
                self.statusCallback = statusCallback
                self.statusCallbackEvent = statusCallbackEvent
                self.statusCallbackMethod = statusCallbackMethod
                self.timeLimit = timeLimit
                self.timeout = timeout
                self.to = to
                self.waitMethod = waitMethod
                self.waitURL = waitURL
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("Beep", beep?.asQueryValue)
                query.addQueryItem("Byoc", byoc?.asQueryValue)
                query.addQueryItem("CallReason", callReason?.asQueryValue)
                query.addQueryItem("CallSidToCoach", callSidToCoach?.asQueryValue)
                query.addQueryItem("CallerId", callerID?.asQueryValue)
                query.addQueryItem("Coaching", isCoaching?.asQueryValue)
                query.addQueryItem("ConferenceRecord", conferenceRecord?.asQueryValue)
                query.addQueryItem("ConferenceRecordingStatusCallback", conferenceRecordingStatusCallback?.asQueryValue)
                for value in conferenceRecordingStatusCallbackEvent ?? [] {
                    query.addQueryItem("ConferenceRecordingStatusCallbackEvent", value.asQueryValue)
                }
                query.addQueryItem("ConferenceRecordingStatusCallbackMethod", conferenceRecordingStatusCallbackMethod?.asQueryValue)
                query.addQueryItem("ConferenceStatusCallback", conferenceStatusCallback?.asQueryValue)
                for value in conferenceStatusCallbackEvent ?? [] {
                    query.addQueryItem("ConferenceStatusCallbackEvent", value.asQueryValue)
                }
                query.addQueryItem("ConferenceStatusCallbackMethod", conferenceStatusCallbackMethod?.asQueryValue)
                query.addQueryItem("ConferenceTrim", conferenceTrim?.asQueryValue)
                query.addQueryItem("EarlyMedia", isEarlyMedia?.asQueryValue)
                query.addQueryItem("EndConferenceOnExit", isEndConferenceOnExit?.asQueryValue)
                query.addQueryItem("From", from.asQueryValue)
                query.addQueryItem("JitterBufferSize", jitterBufferSize?.asQueryValue)
                query.addQueryItem("Label", label?.asQueryValue)
                query.addQueryItem("MaxParticipants", maxParticipants?.asQueryValue)
                query.addQueryItem("Muted", isMuted?.asQueryValue)
                query.addQueryItem("Record", isRecord?.asQueryValue)
                query.addQueryItem("RecordingChannels", recordingChannels?.asQueryValue)
                query.addQueryItem("RecordingStatusCallback", recordingStatusCallback?.asQueryValue)
                for value in recordingStatusCallbackEvent ?? [] {
                    query.addQueryItem("RecordingStatusCallbackEvent", value.asQueryValue)
                }
                query.addQueryItem("RecordingStatusCallbackMethod", recordingStatusCallbackMethod?.asQueryValue)
                query.addQueryItem("RecordingTrack", recordingTrack?.asQueryValue)
                query.addQueryItem("Region", region?.asQueryValue)
                query.addQueryItem("SipAuthPassword", sipAuthPassword?.asQueryValue)
                query.addQueryItem("SipAuthUsername", sipAuthUsername?.asQueryValue)
                query.addQueryItem("StartConferenceOnEnter", isStartConferenceOnEnter?.asQueryValue)
                query.addQueryItem("StatusCallback", statusCallback?.asQueryValue)
                for value in statusCallbackEvent ?? [] {
                    query.addQueryItem("StatusCallbackEvent", value.asQueryValue)
                }
                query.addQueryItem("StatusCallbackMethod", statusCallbackMethod?.asQueryValue)
                query.addQueryItem("TimeLimit", timeLimit?.asQueryValue)
                query.addQueryItem("Timeout", timeout?.asQueryValue)
                query.addQueryItem("To", to.asQueryValue)
                query.addQueryItem("WaitMethod", waitMethod?.asQueryValue)
                query.addQueryItem("WaitUrl", waitURL?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Conferences.WithConferenceSid {
    public var participants: Participants {
        Participants(path: path + "/Participants")
    }

    public struct Participants {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Conferences.WithConferenceSid.Participants {
    public func callSid(_ callSid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(callSid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json`
        public let path: String

        /// Fetch an instance of a participant
        public var get: Request<TwilioAPI.APIV2010AccountConferenceParticipant> {
            .get(path)
        }

        /// Update the properties of the participant
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountConferenceParticipant> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateParticipantRequest
        public struct PostRequest: Encodable {
            /// The HTTP method we should use to call `announce_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var announceMethod: AnnounceMethod?
            /// The URL we call using the `announce_method` for an announcement to the participant. The URL must return an MP3 file, a WAV file, or a TwiML document that contains `<Play>` or `<Say>` commands.
            public var announceURL: URL?
            /// Whether to play a notification beep to the conference when the participant exits. Can be: `true` or `false`.
            public var isBeepOnExit: Bool?
            /// The SID of the participant who is being `coached`. The participant being coached is the only participant who can hear the participant who is `coaching`.
            public var callSidToCoach: String?
            /// Whether the participant is coaching another call. Can be: `true` or `false`. If not present, defaults to `false` unless `call_sid_to_coach` is defined. If `true`, `call_sid_to_coach` must be defined.
            public var isCoaching: Bool?
            /// Whether to end the conference when the participant leaves. Can be: `true` or `false` and defaults to `false`.
            public var isEndConferenceOnExit: Bool?
            /// Whether the participant should be on hold. Can be: `true` or `false`. `true` puts the participant on hold, and `false` lets them rejoin the conference.
            public var isHold: Bool?
            /// The HTTP method we should use to call `hold_url`. Can be: `GET` or `POST` and the default is `GET`.
            public var holdMethod: HoldMethod?
            /// The URL we call using the `hold_method` for  music that plays when the participant is on hold. The URL may return an MP3 file, a WAV file, or a TwiML document that contains the `<Play>`, `<Say>` or `<Redirect>` commands.
            public var holdURL: URL?
            /// Whether the participant should be muted. Can be `true` or `false`. `true` will mute the participant, and `false` will un-mute them. Anything value other than `true` or `false` is interpreted as `false`.
            public var isMuted: Bool?
            /// The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
            public var waitMethod: WaitMethod?
            /// The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).
            public var waitURL: URL?

            /// The HTTP method we should use to call `announce_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum AnnounceMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `hold_url`. Can be: `GET` or `POST` and the default is `GET`.
            public enum HoldMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
            public enum WaitMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            public init(announceMethod: AnnounceMethod? = nil, announceURL: URL? = nil, isBeepOnExit: Bool? = nil, callSidToCoach: String? = nil, isCoaching: Bool? = nil, isEndConferenceOnExit: Bool? = nil, isHold: Bool? = nil, holdMethod: HoldMethod? = nil, holdURL: URL? = nil, isMuted: Bool? = nil, waitMethod: WaitMethod? = nil, waitURL: URL? = nil) {
                self.announceMethod = announceMethod
                self.announceURL = announceURL
                self.isBeepOnExit = isBeepOnExit
                self.callSidToCoach = callSidToCoach
                self.isCoaching = isCoaching
                self.isEndConferenceOnExit = isEndConferenceOnExit
                self.isHold = isHold
                self.holdMethod = holdMethod
                self.holdURL = holdURL
                self.isMuted = isMuted
                self.waitMethod = waitMethod
                self.waitURL = waitURL
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("AnnounceMethod", announceMethod?.asQueryValue)
                query.addQueryItem("AnnounceUrl", announceURL?.asQueryValue)
                query.addQueryItem("BeepOnExit", isBeepOnExit?.asQueryValue)
                query.addQueryItem("CallSidToCoach", callSidToCoach?.asQueryValue)
                query.addQueryItem("Coaching", isCoaching?.asQueryValue)
                query.addQueryItem("EndConferenceOnExit", isEndConferenceOnExit?.asQueryValue)
                query.addQueryItem("Hold", isHold?.asQueryValue)
                query.addQueryItem("HoldMethod", holdMethod?.asQueryValue)
                query.addQueryItem("HoldUrl", holdURL?.asQueryValue)
                query.addQueryItem("Muted", isMuted?.asQueryValue)
                query.addQueryItem("WaitMethod", waitMethod?.asQueryValue)
                query.addQueryItem("WaitUrl", waitURL?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }

        /// Kick a participant from a given conference
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.Conferences.WithConferenceSid {
    public var recordingsJSON: RecordingsJSON {
        RecordingsJSON(path: path + "/Recordings.json")
    }

    public struct RecordingsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings.json`
        public let path: String

        /// Retrieve a list of recordings belonging to the call used to make the request
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListConferenceRecordingResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var recordings: [TwilioAPI.APIV2010AccountConferenceConferenceRecording]?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, recordings: [TwilioAPI.APIV2010AccountConferenceConferenceRecording]? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.recordings = recordings
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case recordings
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var dateCreated: NaiveDate?
            public var dateCreatedLessThan: NaiveDate?
            public var dateCreatedGreaterThan: NaiveDate?
            public var pageSize: Int?

            public init(dateCreated: NaiveDate? = nil, dateCreatedLessThan: NaiveDate? = nil, dateCreatedGreaterThan: NaiveDate? = nil, pageSize: Int? = nil) {
                self.dateCreated = dateCreated
                self.dateCreatedLessThan = dateCreatedLessThan
                self.dateCreatedGreaterThan = dateCreatedGreaterThan
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("DateCreated", dateCreated?.asQueryValue)
                query.addQueryItem("DateCreated<", dateCreatedLessThan?.asQueryValue)
                query.addQueryItem("DateCreated>", dateCreatedGreaterThan?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Conferences.WithConferenceSid {
    public var recordings: Recordings {
        Recordings(path: path + "/Recordings")
    }

    public struct Recordings {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Conferences.WithConferenceSid.Recordings {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json`
        public let path: String

        /// Fetch an instance of a recording for a call
        public var get: Request<TwilioAPI.APIV2010AccountConferenceConferenceRecording> {
            .get(path)
        }

        /// Changes the status of the recording to paused, stopped, or in-progress. Note: To use `Twilio.CURRENT`, pass it as recording sid.
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountConferenceConferenceRecording> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateConferenceRecordingRequest
        public struct PostRequest: Encodable {
            /// Whether to record during a pause. Can be: `skip` or `silence` and the default is `silence`. `skip` does not record during the pause period, while `silence` will replace the actual audio of the call with silence during the pause period. This parameter only applies when setting `status` is set to `paused`.
            public var pauseBehavior: String?
            /// The new status of the recording. Can be: `stopped`, `paused`, `in-progress`.
            public var status: Status

            /// The new status of the recording. Can be: `stopped`, `paused`, `in-progress`.
            public enum Status: String, Codable, CaseIterable {
                case inProgress = "in-progress"
                case paused
                case stopped
                case processing
                case completed
                case absent
            }

            public init(pauseBehavior: String? = nil, status: Status) {
                self.pauseBehavior = pauseBehavior
                self.status = status
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("PauseBehavior", pauseBehavior?.asQueryValue)
                query.addQueryItem("Status", status.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }

        /// Delete a recording from your account
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.Conferences {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Conferences/{Sid}.json`
        public let path: String

        /// Fetch an instance of a conference
        public var get: Request<TwilioAPI.APIV2010AccountConference> {
            .get(path)
        }

        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountConference> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateConferenceRequest
        public struct PostRequest: Encodable {
            /// The HTTP method used to call `announce_url`. Can be: `GET` or `POST` and the default is `POST`
            public var announceMethod: AnnounceMethod?
            /// The URL we should call to announce something into the conference. The URL can return an MP3, a WAV, or a TwiML document with `<Play>` or `<Say>`.
            public var announceURL: URL?
            /// The new status of the resource. Can be:  Can be: `init`, `in-progress`, or `completed`. Specifying `completed` will end the conference and hang up all participants
            public var status: Status?

            /// The HTTP method used to call `announce_url`. Can be: `GET` or `POST` and the default is `POST`
            public enum AnnounceMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The new status of the resource. Can be:  Can be: `init`, `in-progress`, or `completed`. Specifying `completed` will end the conference and hang up all participants
            public enum Status: String, Codable, CaseIterable {
                case completed
            }

            public init(announceMethod: AnnounceMethod? = nil, announceURL: URL? = nil, status: Status? = nil) {
                self.announceMethod = announceMethod
                self.announceURL = announceURL
                self.status = status
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("AnnounceMethod", announceMethod?.asQueryValue)
                query.addQueryItem("AnnounceUrl", announceURL?.asQueryValue)
                query.addQueryItem("Status", status?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var connectAppsJSON: ConnectAppsJSON {
        ConnectAppsJSON(path: path + "/ConnectApps.json")
    }

    public struct ConnectAppsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/ConnectApps.json`
        public let path: String

        /// Retrieve a list of connect-apps belonging to the account used to make the request
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListConnectAppResponse
        public struct GetResponse: Decodable {
            public var connectApps: [TwilioAPI.APIV2010AccountConnectApp]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(connectApps: [TwilioAPI.APIV2010AccountConnectApp]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.connectApps = connectApps
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case connectApps = "connect_apps"
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var connectApps: ConnectApps {
        ConnectApps(path: path + "/ConnectApps")
    }

    public struct ConnectApps {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/ConnectApps`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.ConnectApps {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json`
        public let path: String

        /// Fetch an instance of a connect-app
        public var get: Request<TwilioAPI.APIV2010AccountConnectApp> {
            .get(path)
        }

        /// Update a connect-app with the specified parameters
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountConnectApp> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateConnectAppRequest
        public struct PostRequest: Encodable {
            /// The URL to redirect the user to after we authenticate the user and obtain authorization to access the Connect App.
            public var authorizeRedirectURL: URL?
            /// The company name to set for the Connect App.
            public var companyName: String?
            /// The HTTP method to use when calling `deauthorize_callback_url`.
            public var deauthorizeCallbackMethod: DeauthorizeCallbackMethod?
            /// The URL to call using the `deauthorize_callback_method` to de-authorize the Connect App.
            public var deauthorizeCallbackURL: URL?
            /// A description of the Connect App.
            public var description: String?
            /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
            public var friendlyName: String?
            /// A public URL where users can obtain more information about this Connect App.
            public var homepageURL: URL?
            /// A comma-separated list of the permissions you will request from the users of this ConnectApp.  Can include: `get-all` and `post-all`.
            public var permissions: [Permission]?

            /// The HTTP method to use when calling `deauthorize_callback_url`.
            public enum DeauthorizeCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            public enum Permission: String, Codable, CaseIterable {
                case getAll = "get-all"
                case postAll = "post-all"
            }

            public init(authorizeRedirectURL: URL? = nil, companyName: String? = nil, deauthorizeCallbackMethod: DeauthorizeCallbackMethod? = nil, deauthorizeCallbackURL: URL? = nil, description: String? = nil, friendlyName: String? = nil, homepageURL: URL? = nil, permissions: [Permission]? = nil) {
                self.authorizeRedirectURL = authorizeRedirectURL
                self.companyName = companyName
                self.deauthorizeCallbackMethod = deauthorizeCallbackMethod
                self.deauthorizeCallbackURL = deauthorizeCallbackURL
                self.description = description
                self.friendlyName = friendlyName
                self.homepageURL = homepageURL
                self.permissions = permissions
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("AuthorizeRedirectUrl", authorizeRedirectURL?.asQueryValue)
                query.addQueryItem("CompanyName", companyName?.asQueryValue)
                query.addQueryItem("DeauthorizeCallbackMethod", deauthorizeCallbackMethod?.asQueryValue)
                query.addQueryItem("DeauthorizeCallbackUrl", deauthorizeCallbackURL?.asQueryValue)
                query.addQueryItem("Description", description?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("HomepageUrl", homepageURL?.asQueryValue)
                for value in permissions ?? [] {
                    query.addQueryItem("Permissions", value.asQueryValue)
                }
                return query.asPercentEncodedQuery
            }
        }

        /// Delete an instance of a connect-app
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var incomingPhoneNumbersJSON: IncomingPhoneNumbersJSON {
        IncomingPhoneNumbersJSON(path: path + "/IncomingPhoneNumbers.json")
    }

    public struct IncomingPhoneNumbersJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers.json`
        public let path: String

        /// Retrieve a list of incoming-phone-numbers belonging to the account used to make the request.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListIncomingPhoneNumberResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var incomingPhoneNumbers: [TwilioAPI.APIV2010AccountIncomingPhoneNumber]?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, incomingPhoneNumbers: [TwilioAPI.APIV2010AccountIncomingPhoneNumber]? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.incomingPhoneNumbers = incomingPhoneNumbers
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case incomingPhoneNumbers = "incoming_phone_numbers"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var isBeta: Bool?
            public var friendlyName: String?
            public var phoneNumber: String?
            public var origin: String?
            public var pageSize: Int?

            public init(isBeta: Bool? = nil, friendlyName: String? = nil, phoneNumber: String? = nil, origin: String? = nil, pageSize: Int? = nil) {
                self.isBeta = isBeta
                self.friendlyName = friendlyName
                self.phoneNumber = phoneNumber
                self.origin = origin
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("Beta", isBeta?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("PhoneNumber", phoneNumber?.asQueryValue)
                query.addQueryItem("Origin", origin?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }

        /// Purchase a phone-number for the account.
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountIncomingPhoneNumber> {
            .post(path, body: body?.asQuery())
        }

        /// CreateIncomingPhoneNumberRequest
        public struct PostRequest: Encodable {
            /// The SID of the Address resource we should associate with the new phone number. Some regions require addresses to meet local regulations.
            public var addressSid: String?
            /// The API version to use for incoming calls made to the new phone number. The default is `2010-04-01`.
            public var apiVersion: String?
            /// The desired area code for your new incoming phone number. Can be any three-digit, US or Canada area code. We will provision an available phone number within this area code for you. **You must provide an `area_code` or a `phone_number`.** (US and Canada only).
            public var areaCode: String?
            /// The SID of the Bundle resource that you associate with the phone number. Some regions require a Bundle to meet local Regulations.
            public var bundleSid: String?
            /// The SID of the emergency address configuration to use for emergency calling from the new phone number.
            public var emergencyAddressSid: String?
            /// The parameter displays if emergency calling is enabled for this number. Active numbers may place emergency calls by dialing valid emergency numbers for the country.
            public var emergencyStatus: EmergencyStatus?
            /// A descriptive string that you created to describe the new phone number. It can be up to 64 characters long. By default, this is a formatted version of the new phone number.
            public var friendlyName: String?
            /// The SID of the Identity resource that we should associate with the new phone number. Some regions require an identity to meet local regulations.
            public var identitySid: String?
            /// The phone number to purchase specified in [E.164](https://www.twilio.com/docs/glossary/what-e164) format.  E.164 phone numbers consist of a + followed by the country code and subscriber number without punctuation characters. For example, +14155551234.
            public var phoneNumber: String?
            /// The SID of the application that should handle SMS messages sent to the new phone number. If an `sms_application_sid` is present, we ignore all of the `sms_*_url` urls and use those set on the application.
            public var smsApplicationSid: String?
            /// The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var smsFallbackMethod: SmsFallbackMethod?
            /// The URL that we should call when an error occurs while requesting or executing the TwiML defined by `sms_url`.
            public var smsFallbackURL: URL?
            /// The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var smsMethod: SmsMethod?
            /// The URL we should call when the new phone number receives an incoming SMS message.
            public var smsURL: URL?
            /// The URL we should call using the `status_callback_method` to send status information to your application.
            public var statusCallback: URL?
            /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
            public var statusCallbackMethod: StatusCallbackMethod?
            /// The SID of the Trunk we should use to handle calls to the new phone number. If a `trunk_sid` is present, we ignore all of the voice urls and voice applications and use only those set on the Trunk. Setting a `trunk_sid` will automatically delete your `voice_application_sid` and vice versa.
            public var trunkSid: String?
            /// The SID of the application we should use to handle calls to the new phone number. If a `voice_application_sid` is present, we ignore all of the voice urls and use only those set on the application. Setting a `voice_application_sid` will automatically delete your `trunk_sid` and vice versa.
            public var voiceApplicationSid: String?
            /// Whether to lookup the caller's name from the CNAM database and post it to your app. Can be: `true` or `false` and defaults to `false`.
            public var isVoiceCallerIDLookup: Bool?
            /// The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var voiceFallbackMethod: VoiceFallbackMethod?
            /// The URL that we should call when an error occurs retrieving or executing the TwiML requested by `url`.
            public var voiceFallbackURL: URL?
            /// The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var voiceMethod: VoiceMethod?
            /// The configuration parameter for the new phone number to receive incoming voice calls or faxes. Can be: `fax` or `voice` and defaults to `voice`.
            public var voiceReceiveMode: VoiceReceiveMode?
            /// The URL that we should call to answer a call to the new phone number. The `voice_url` will not be called if a `voice_application_sid` or a `trunk_sid` is set.
            public var voiceURL: URL?

            /// The parameter displays if emergency calling is enabled for this number. Active numbers may place emergency calls by dialing valid emergency numbers for the country.
            public enum EmergencyStatus: String, Codable, CaseIterable {
                case active = "Active"
                case inactive = "Inactive"
            }

            /// The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum SmsFallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum SmsMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum StatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum VoiceFallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum VoiceMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The configuration parameter for the new phone number to receive incoming voice calls or faxes. Can be: `fax` or `voice` and defaults to `voice`.
            public enum VoiceReceiveMode: String, Codable, CaseIterable {
                case voice
                case fax
            }

            public init(addressSid: String? = nil, apiVersion: String? = nil, areaCode: String? = nil, bundleSid: String? = nil, emergencyAddressSid: String? = nil, emergencyStatus: EmergencyStatus? = nil, friendlyName: String? = nil, identitySid: String? = nil, phoneNumber: String? = nil, smsApplicationSid: String? = nil, smsFallbackMethod: SmsFallbackMethod? = nil, smsFallbackURL: URL? = nil, smsMethod: SmsMethod? = nil, smsURL: URL? = nil, statusCallback: URL? = nil, statusCallbackMethod: StatusCallbackMethod? = nil, trunkSid: String? = nil, voiceApplicationSid: String? = nil, isVoiceCallerIDLookup: Bool? = nil, voiceFallbackMethod: VoiceFallbackMethod? = nil, voiceFallbackURL: URL? = nil, voiceMethod: VoiceMethod? = nil, voiceReceiveMode: VoiceReceiveMode? = nil, voiceURL: URL? = nil) {
                self.addressSid = addressSid
                self.apiVersion = apiVersion
                self.areaCode = areaCode
                self.bundleSid = bundleSid
                self.emergencyAddressSid = emergencyAddressSid
                self.emergencyStatus = emergencyStatus
                self.friendlyName = friendlyName
                self.identitySid = identitySid
                self.phoneNumber = phoneNumber
                self.smsApplicationSid = smsApplicationSid
                self.smsFallbackMethod = smsFallbackMethod
                self.smsFallbackURL = smsFallbackURL
                self.smsMethod = smsMethod
                self.smsURL = smsURL
                self.statusCallback = statusCallback
                self.statusCallbackMethod = statusCallbackMethod
                self.trunkSid = trunkSid
                self.voiceApplicationSid = voiceApplicationSid
                self.isVoiceCallerIDLookup = isVoiceCallerIDLookup
                self.voiceFallbackMethod = voiceFallbackMethod
                self.voiceFallbackURL = voiceFallbackURL
                self.voiceMethod = voiceMethod
                self.voiceReceiveMode = voiceReceiveMode
                self.voiceURL = voiceURL
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("AddressSid", addressSid?.asQueryValue)
                query.addQueryItem("ApiVersion", apiVersion?.asQueryValue)
                query.addQueryItem("AreaCode", areaCode?.asQueryValue)
                query.addQueryItem("BundleSid", bundleSid?.asQueryValue)
                query.addQueryItem("EmergencyAddressSid", emergencyAddressSid?.asQueryValue)
                query.addQueryItem("EmergencyStatus", emergencyStatus?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("IdentitySid", identitySid?.asQueryValue)
                query.addQueryItem("PhoneNumber", phoneNumber?.asQueryValue)
                query.addQueryItem("SmsApplicationSid", smsApplicationSid?.asQueryValue)
                query.addQueryItem("SmsFallbackMethod", smsFallbackMethod?.asQueryValue)
                query.addQueryItem("SmsFallbackUrl", smsFallbackURL?.asQueryValue)
                query.addQueryItem("SmsMethod", smsMethod?.asQueryValue)
                query.addQueryItem("SmsUrl", smsURL?.asQueryValue)
                query.addQueryItem("StatusCallback", statusCallback?.asQueryValue)
                query.addQueryItem("StatusCallbackMethod", statusCallbackMethod?.asQueryValue)
                query.addQueryItem("TrunkSid", trunkSid?.asQueryValue)
                query.addQueryItem("VoiceApplicationSid", voiceApplicationSid?.asQueryValue)
                query.addQueryItem("VoiceCallerIdLookup", isVoiceCallerIDLookup?.asQueryValue)
                query.addQueryItem("VoiceFallbackMethod", voiceFallbackMethod?.asQueryValue)
                query.addQueryItem("VoiceFallbackUrl", voiceFallbackURL?.asQueryValue)
                query.addQueryItem("VoiceMethod", voiceMethod?.asQueryValue)
                query.addQueryItem("VoiceReceiveMode", voiceReceiveMode?.asQueryValue)
                query.addQueryItem("VoiceUrl", voiceURL?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var incomingPhoneNumbers: IncomingPhoneNumbers {
        IncomingPhoneNumbers(path: path + "/IncomingPhoneNumbers")
    }

    public struct IncomingPhoneNumbers {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.IncomingPhoneNumbers {
    public var localJSON: LocalJSON {
        LocalJSON(path: path + "/Local.json")
    }

    public struct LocalJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Local.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListIncomingPhoneNumberLocalResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var incomingPhoneNumbers: [TwilioAPI.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal]?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, incomingPhoneNumbers: [TwilioAPI.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal]? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.incomingPhoneNumbers = incomingPhoneNumbers
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case incomingPhoneNumbers = "incoming_phone_numbers"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var isBeta: Bool?
            public var friendlyName: String?
            public var phoneNumber: String?
            public var origin: String?
            public var pageSize: Int?

            public init(isBeta: Bool? = nil, friendlyName: String? = nil, phoneNumber: String? = nil, origin: String? = nil, pageSize: Int? = nil) {
                self.isBeta = isBeta
                self.friendlyName = friendlyName
                self.phoneNumber = phoneNumber
                self.origin = origin
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("Beta", isBeta?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("PhoneNumber", phoneNumber?.asQueryValue)
                query.addQueryItem("Origin", origin?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }

        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal> {
            .post(path, body: body?.asQuery())
        }

        /// CreateIncomingPhoneNumberLocalRequest
        public struct PostRequest: Encodable {
            /// The SID of the Address resource we should associate with the new phone number. Some regions require addresses to meet local regulations.
            public var addressSid: String?
            /// The API version to use for incoming calls made to the new phone number. The default is `2010-04-01`.
            public var apiVersion: String?
            /// The SID of the Bundle resource that you associate with the phone number. Some regions require a Bundle to meet local Regulations.
            public var bundleSid: String?
            /// The SID of the emergency address configuration to use for emergency calling from the new phone number.
            public var emergencyAddressSid: String?
            /// The parameter displays if emergency calling is enabled for this number. Active numbers may place emergency calls by dialing valid emergency numbers for the country.
            public var emergencyStatus: EmergencyStatus?
            /// A descriptive string that you created to describe the new phone number. It can be up to 64 characters long. By default, this is a formatted version of the phone number.
            public var friendlyName: String?
            /// The SID of the Identity resource that we should associate with the new phone number. Some regions require an identity to meet local regulations.
            public var identitySid: String?
            /// The phone number to purchase specified in [E.164](https://www.twilio.com/docs/glossary/what-e164) format.  E.164 phone numbers consist of a + followed by the country code and subscriber number without punctuation characters. For example, +14155551234.
            public var phoneNumber: String
            /// The SID of the application that should handle SMS messages sent to the new phone number. If an `sms_application_sid` is present, we ignore all of the `sms_*_url` urls and use those set on the application.
            public var smsApplicationSid: String?
            /// The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var smsFallbackMethod: SmsFallbackMethod?
            /// The URL that we should call when an error occurs while requesting or executing the TwiML defined by `sms_url`.
            public var smsFallbackURL: URL?
            /// The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var smsMethod: SmsMethod?
            /// The URL we should call when the new phone number receives an incoming SMS message.
            public var smsURL: URL?
            /// The URL we should call using the `status_callback_method` to send status information to your application.
            public var statusCallback: URL?
            /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
            public var statusCallbackMethod: StatusCallbackMethod?
            /// The SID of the Trunk we should use to handle calls to the new phone number. If a `trunk_sid` is present, we ignore all of the voice urls and voice applications and use only those set on the Trunk. Setting a `trunk_sid` will automatically delete your `voice_application_sid` and vice versa.
            public var trunkSid: String?
            /// The SID of the application we should use to handle calls to the new phone number. If a `voice_application_sid` is present, we ignore all of the voice urls and use only those set on the application. Setting a `voice_application_sid` will automatically delete your `trunk_sid` and vice versa.
            public var voiceApplicationSid: String?
            /// Whether to lookup the caller's name from the CNAM database and post it to your app. Can be: `true` or `false` and defaults to `false`.
            public var isVoiceCallerIDLookup: Bool?
            /// The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var voiceFallbackMethod: VoiceFallbackMethod?
            /// The URL that we should call when an error occurs retrieving or executing the TwiML requested by `url`.
            public var voiceFallbackURL: URL?
            /// The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var voiceMethod: VoiceMethod?
            /// The configuration parameter for the new phone number to receive incoming voice calls or faxes. Can be: `fax` or `voice` and defaults to `voice`.
            public var voiceReceiveMode: VoiceReceiveMode?
            /// The URL that we should call to answer a call to the new phone number. The `voice_url` will not be called if a `voice_application_sid` or a `trunk_sid` is set.
            public var voiceURL: URL?

            /// The parameter displays if emergency calling is enabled for this number. Active numbers may place emergency calls by dialing valid emergency numbers for the country.
            public enum EmergencyStatus: String, Codable, CaseIterable {
                case active = "Active"
                case inactive = "Inactive"
            }

            /// The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum SmsFallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum SmsMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum StatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum VoiceFallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum VoiceMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The configuration parameter for the new phone number to receive incoming voice calls or faxes. Can be: `fax` or `voice` and defaults to `voice`.
            public enum VoiceReceiveMode: String, Codable, CaseIterable {
                case voice
                case fax
            }

            public init(addressSid: String? = nil, apiVersion: String? = nil, bundleSid: String? = nil, emergencyAddressSid: String? = nil, emergencyStatus: EmergencyStatus? = nil, friendlyName: String? = nil, identitySid: String? = nil, phoneNumber: String, smsApplicationSid: String? = nil, smsFallbackMethod: SmsFallbackMethod? = nil, smsFallbackURL: URL? = nil, smsMethod: SmsMethod? = nil, smsURL: URL? = nil, statusCallback: URL? = nil, statusCallbackMethod: StatusCallbackMethod? = nil, trunkSid: String? = nil, voiceApplicationSid: String? = nil, isVoiceCallerIDLookup: Bool? = nil, voiceFallbackMethod: VoiceFallbackMethod? = nil, voiceFallbackURL: URL? = nil, voiceMethod: VoiceMethod? = nil, voiceReceiveMode: VoiceReceiveMode? = nil, voiceURL: URL? = nil) {
                self.addressSid = addressSid
                self.apiVersion = apiVersion
                self.bundleSid = bundleSid
                self.emergencyAddressSid = emergencyAddressSid
                self.emergencyStatus = emergencyStatus
                self.friendlyName = friendlyName
                self.identitySid = identitySid
                self.phoneNumber = phoneNumber
                self.smsApplicationSid = smsApplicationSid
                self.smsFallbackMethod = smsFallbackMethod
                self.smsFallbackURL = smsFallbackURL
                self.smsMethod = smsMethod
                self.smsURL = smsURL
                self.statusCallback = statusCallback
                self.statusCallbackMethod = statusCallbackMethod
                self.trunkSid = trunkSid
                self.voiceApplicationSid = voiceApplicationSid
                self.isVoiceCallerIDLookup = isVoiceCallerIDLookup
                self.voiceFallbackMethod = voiceFallbackMethod
                self.voiceFallbackURL = voiceFallbackURL
                self.voiceMethod = voiceMethod
                self.voiceReceiveMode = voiceReceiveMode
                self.voiceURL = voiceURL
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("AddressSid", addressSid?.asQueryValue)
                query.addQueryItem("ApiVersion", apiVersion?.asQueryValue)
                query.addQueryItem("BundleSid", bundleSid?.asQueryValue)
                query.addQueryItem("EmergencyAddressSid", emergencyAddressSid?.asQueryValue)
                query.addQueryItem("EmergencyStatus", emergencyStatus?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("IdentitySid", identitySid?.asQueryValue)
                query.addQueryItem("PhoneNumber", phoneNumber.asQueryValue)
                query.addQueryItem("SmsApplicationSid", smsApplicationSid?.asQueryValue)
                query.addQueryItem("SmsFallbackMethod", smsFallbackMethod?.asQueryValue)
                query.addQueryItem("SmsFallbackUrl", smsFallbackURL?.asQueryValue)
                query.addQueryItem("SmsMethod", smsMethod?.asQueryValue)
                query.addQueryItem("SmsUrl", smsURL?.asQueryValue)
                query.addQueryItem("StatusCallback", statusCallback?.asQueryValue)
                query.addQueryItem("StatusCallbackMethod", statusCallbackMethod?.asQueryValue)
                query.addQueryItem("TrunkSid", trunkSid?.asQueryValue)
                query.addQueryItem("VoiceApplicationSid", voiceApplicationSid?.asQueryValue)
                query.addQueryItem("VoiceCallerIdLookup", isVoiceCallerIDLookup?.asQueryValue)
                query.addQueryItem("VoiceFallbackMethod", voiceFallbackMethod?.asQueryValue)
                query.addQueryItem("VoiceFallbackUrl", voiceFallbackURL?.asQueryValue)
                query.addQueryItem("VoiceMethod", voiceMethod?.asQueryValue)
                query.addQueryItem("VoiceReceiveMode", voiceReceiveMode?.asQueryValue)
                query.addQueryItem("VoiceUrl", voiceURL?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.IncomingPhoneNumbers {
    public var mobileJSON: MobileJSON {
        MobileJSON(path: path + "/Mobile.json")
    }

    public struct MobileJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Mobile.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListIncomingPhoneNumberMobileResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var incomingPhoneNumbers: [TwilioAPI.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile]?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, incomingPhoneNumbers: [TwilioAPI.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile]? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.incomingPhoneNumbers = incomingPhoneNumbers
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case incomingPhoneNumbers = "incoming_phone_numbers"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var isBeta: Bool?
            public var friendlyName: String?
            public var phoneNumber: String?
            public var origin: String?
            public var pageSize: Int?

            public init(isBeta: Bool? = nil, friendlyName: String? = nil, phoneNumber: String? = nil, origin: String? = nil, pageSize: Int? = nil) {
                self.isBeta = isBeta
                self.friendlyName = friendlyName
                self.phoneNumber = phoneNumber
                self.origin = origin
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("Beta", isBeta?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("PhoneNumber", phoneNumber?.asQueryValue)
                query.addQueryItem("Origin", origin?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }

        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile> {
            .post(path, body: body?.asQuery())
        }

        /// CreateIncomingPhoneNumberMobileRequest
        public struct PostRequest: Encodable {
            /// The SID of the Address resource we should associate with the new phone number. Some regions require addresses to meet local regulations.
            public var addressSid: String?
            /// The API version to use for incoming calls made to the new phone number. The default is `2010-04-01`.
            public var apiVersion: String?
            /// The SID of the Bundle resource that you associate with the phone number. Some regions require a Bundle to meet local Regulations.
            public var bundleSid: String?
            /// The SID of the emergency address configuration to use for emergency calling from the new phone number.
            public var emergencyAddressSid: String?
            /// The parameter displays if emergency calling is enabled for this number. Active numbers may place emergency calls by dialing valid emergency numbers for the country.
            public var emergencyStatus: EmergencyStatus?
            /// A descriptive string that you created to describe the new phone number. It can be up to 64 characters long. By default, the is a formatted version of the phone number.
            public var friendlyName: String?
            /// The SID of the Identity resource that we should associate with the new phone number. Some regions require an identity to meet local regulations.
            public var identitySid: String?
            /// The phone number to purchase specified in [E.164](https://www.twilio.com/docs/glossary/what-e164) format.  E.164 phone numbers consist of a + followed by the country code and subscriber number without punctuation characters. For example, +14155551234.
            public var phoneNumber: String
            /// The SID of the application that should handle SMS messages sent to the new phone number. If an `sms_application_sid` is present, we ignore all of the `sms_*_url` urls and use those of the application.
            public var smsApplicationSid: String?
            /// The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var smsFallbackMethod: SmsFallbackMethod?
            /// The URL that we should call when an error occurs while requesting or executing the TwiML defined by `sms_url`.
            public var smsFallbackURL: URL?
            /// The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var smsMethod: SmsMethod?
            /// The URL we should call when the new phone number receives an incoming SMS message.
            public var smsURL: URL?
            /// The URL we should call using the `status_callback_method` to send status information to your application.
            public var statusCallback: URL?
            /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
            public var statusCallbackMethod: StatusCallbackMethod?
            /// The SID of the Trunk we should use to handle calls to the new phone number. If a `trunk_sid` is present, we ignore all of the voice urls and voice applications and use only those set on the Trunk. Setting a `trunk_sid` will automatically delete your `voice_application_sid` and vice versa.
            public var trunkSid: String?
            /// The SID of the application we should use to handle calls to the new phone number. If a `voice_application_sid` is present, we ignore all of the voice urls and use only those set on the application. Setting a `voice_application_sid` will automatically delete your `trunk_sid` and vice versa.
            public var voiceApplicationSid: String?
            /// Whether to lookup the caller's name from the CNAM database and post it to your app. Can be: `true` or `false` and defaults to `false`.
            public var isVoiceCallerIDLookup: Bool?
            /// The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var voiceFallbackMethod: VoiceFallbackMethod?
            /// The URL that we should call when an error occurs retrieving or executing the TwiML requested by `url`.
            public var voiceFallbackURL: URL?
            /// The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var voiceMethod: VoiceMethod?
            /// The configuration parameter for the new phone number to receive incoming voice calls or faxes. Can be: `fax` or `voice` and defaults to `voice`.
            public var voiceReceiveMode: VoiceReceiveMode?
            /// The URL that we should call to answer a call to the new phone number. The `voice_url` will not be called if a `voice_application_sid` or a `trunk_sid` is set.
            public var voiceURL: URL?

            /// The parameter displays if emergency calling is enabled for this number. Active numbers may place emergency calls by dialing valid emergency numbers for the country.
            public enum EmergencyStatus: String, Codable, CaseIterable {
                case active = "Active"
                case inactive = "Inactive"
            }

            /// The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum SmsFallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum SmsMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum StatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum VoiceFallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum VoiceMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The configuration parameter for the new phone number to receive incoming voice calls or faxes. Can be: `fax` or `voice` and defaults to `voice`.
            public enum VoiceReceiveMode: String, Codable, CaseIterable {
                case voice
                case fax
            }

            public init(addressSid: String? = nil, apiVersion: String? = nil, bundleSid: String? = nil, emergencyAddressSid: String? = nil, emergencyStatus: EmergencyStatus? = nil, friendlyName: String? = nil, identitySid: String? = nil, phoneNumber: String, smsApplicationSid: String? = nil, smsFallbackMethod: SmsFallbackMethod? = nil, smsFallbackURL: URL? = nil, smsMethod: SmsMethod? = nil, smsURL: URL? = nil, statusCallback: URL? = nil, statusCallbackMethod: StatusCallbackMethod? = nil, trunkSid: String? = nil, voiceApplicationSid: String? = nil, isVoiceCallerIDLookup: Bool? = nil, voiceFallbackMethod: VoiceFallbackMethod? = nil, voiceFallbackURL: URL? = nil, voiceMethod: VoiceMethod? = nil, voiceReceiveMode: VoiceReceiveMode? = nil, voiceURL: URL? = nil) {
                self.addressSid = addressSid
                self.apiVersion = apiVersion
                self.bundleSid = bundleSid
                self.emergencyAddressSid = emergencyAddressSid
                self.emergencyStatus = emergencyStatus
                self.friendlyName = friendlyName
                self.identitySid = identitySid
                self.phoneNumber = phoneNumber
                self.smsApplicationSid = smsApplicationSid
                self.smsFallbackMethod = smsFallbackMethod
                self.smsFallbackURL = smsFallbackURL
                self.smsMethod = smsMethod
                self.smsURL = smsURL
                self.statusCallback = statusCallback
                self.statusCallbackMethod = statusCallbackMethod
                self.trunkSid = trunkSid
                self.voiceApplicationSid = voiceApplicationSid
                self.isVoiceCallerIDLookup = isVoiceCallerIDLookup
                self.voiceFallbackMethod = voiceFallbackMethod
                self.voiceFallbackURL = voiceFallbackURL
                self.voiceMethod = voiceMethod
                self.voiceReceiveMode = voiceReceiveMode
                self.voiceURL = voiceURL
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("AddressSid", addressSid?.asQueryValue)
                query.addQueryItem("ApiVersion", apiVersion?.asQueryValue)
                query.addQueryItem("BundleSid", bundleSid?.asQueryValue)
                query.addQueryItem("EmergencyAddressSid", emergencyAddressSid?.asQueryValue)
                query.addQueryItem("EmergencyStatus", emergencyStatus?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("IdentitySid", identitySid?.asQueryValue)
                query.addQueryItem("PhoneNumber", phoneNumber.asQueryValue)
                query.addQueryItem("SmsApplicationSid", smsApplicationSid?.asQueryValue)
                query.addQueryItem("SmsFallbackMethod", smsFallbackMethod?.asQueryValue)
                query.addQueryItem("SmsFallbackUrl", smsFallbackURL?.asQueryValue)
                query.addQueryItem("SmsMethod", smsMethod?.asQueryValue)
                query.addQueryItem("SmsUrl", smsURL?.asQueryValue)
                query.addQueryItem("StatusCallback", statusCallback?.asQueryValue)
                query.addQueryItem("StatusCallbackMethod", statusCallbackMethod?.asQueryValue)
                query.addQueryItem("TrunkSid", trunkSid?.asQueryValue)
                query.addQueryItem("VoiceApplicationSid", voiceApplicationSid?.asQueryValue)
                query.addQueryItem("VoiceCallerIdLookup", isVoiceCallerIDLookup?.asQueryValue)
                query.addQueryItem("VoiceFallbackMethod", voiceFallbackMethod?.asQueryValue)
                query.addQueryItem("VoiceFallbackUrl", voiceFallbackURL?.asQueryValue)
                query.addQueryItem("VoiceMethod", voiceMethod?.asQueryValue)
                query.addQueryItem("VoiceReceiveMode", voiceReceiveMode?.asQueryValue)
                query.addQueryItem("VoiceUrl", voiceURL?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.IncomingPhoneNumbers {
    public var tollFreeJSON: TollFreeJSON {
        TollFreeJSON(path: path + "/TollFree.json")
    }

    public struct TollFreeJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/TollFree.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListIncomingPhoneNumberTollFreeResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var incomingPhoneNumbers: [TwilioAPI.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree]?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, incomingPhoneNumbers: [TwilioAPI.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree]? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.incomingPhoneNumbers = incomingPhoneNumbers
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case incomingPhoneNumbers = "incoming_phone_numbers"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var isBeta: Bool?
            public var friendlyName: String?
            public var phoneNumber: String?
            public var origin: String?
            public var pageSize: Int?

            public init(isBeta: Bool? = nil, friendlyName: String? = nil, phoneNumber: String? = nil, origin: String? = nil, pageSize: Int? = nil) {
                self.isBeta = isBeta
                self.friendlyName = friendlyName
                self.phoneNumber = phoneNumber
                self.origin = origin
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("Beta", isBeta?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("PhoneNumber", phoneNumber?.asQueryValue)
                query.addQueryItem("Origin", origin?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }

        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree> {
            .post(path, body: body?.asQuery())
        }

        /// CreateIncomingPhoneNumberTollFreeRequest
        public struct PostRequest: Encodable {
            /// The SID of the Address resource we should associate with the new phone number. Some regions require addresses to meet local regulations.
            public var addressSid: String?
            /// The API version to use for incoming calls made to the new phone number. The default is `2010-04-01`.
            public var apiVersion: String?
            /// The SID of the Bundle resource that you associate with the phone number. Some regions require a Bundle to meet local Regulations.
            public var bundleSid: String?
            /// The SID of the emergency address configuration to use for emergency calling from the new phone number.
            public var emergencyAddressSid: String?
            /// The parameter displays if emergency calling is enabled for this number. Active numbers may place emergency calls by dialing valid emergency numbers for the country.
            public var emergencyStatus: EmergencyStatus?
            /// A descriptive string that you created to describe the new phone number. It can be up to 64 characters long. By default, this is a formatted version of the phone number.
            public var friendlyName: String?
            /// The SID of the Identity resource that we should associate with the new phone number. Some regions require an Identity to meet local regulations.
            public var identitySid: String?
            /// The phone number to purchase specified in [E.164](https://www.twilio.com/docs/glossary/what-e164) format.  E.164 phone numbers consist of a + followed by the country code and subscriber number without punctuation characters. For example, +14155551234.
            public var phoneNumber: String
            /// The SID of the application that should handle SMS messages sent to the new phone number. If an `sms_application_sid` is present, we ignore all `sms_*_url` values and use those of the application.
            public var smsApplicationSid: String?
            /// The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var smsFallbackMethod: SmsFallbackMethod?
            /// The URL that we should call when an error occurs while requesting or executing the TwiML defined by `sms_url`.
            public var smsFallbackURL: URL?
            /// The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var smsMethod: SmsMethod?
            /// The URL we should call when the new phone number receives an incoming SMS message.
            public var smsURL: URL?
            /// The URL we should call using the `status_callback_method` to send status information to your application.
            public var statusCallback: URL?
            /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
            public var statusCallbackMethod: StatusCallbackMethod?
            /// The SID of the Trunk we should use to handle calls to the new phone number. If a `trunk_sid` is present, we ignore all of the voice urls and voice applications and use only those set on the Trunk. Setting a `trunk_sid` will automatically delete your `voice_application_sid` and vice versa.
            public var trunkSid: String?
            /// The SID of the application we should use to handle calls to the new phone number. If a `voice_application_sid` is present, we ignore all of the voice urls and use those set on the application. Setting a `voice_application_sid` will automatically delete your `trunk_sid` and vice versa.
            public var voiceApplicationSid: String?
            /// Whether to lookup the caller's name from the CNAM database and post it to your app. Can be: `true` or `false` and defaults to `false`.
            public var isVoiceCallerIDLookup: Bool?
            /// The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var voiceFallbackMethod: VoiceFallbackMethod?
            /// The URL that we should call when an error occurs retrieving or executing the TwiML requested by `url`.
            public var voiceFallbackURL: URL?
            /// The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var voiceMethod: VoiceMethod?
            /// The configuration parameter for the new phone number to receive incoming voice calls or faxes. Can be: `fax` or `voice` and defaults to `voice`.
            public var voiceReceiveMode: VoiceReceiveMode?
            /// The URL that we should call to answer a call to the new phone number. The `voice_url` will not be called if a `voice_application_sid` or a `trunk_sid` is set.
            public var voiceURL: URL?

            /// The parameter displays if emergency calling is enabled for this number. Active numbers may place emergency calls by dialing valid emergency numbers for the country.
            public enum EmergencyStatus: String, Codable, CaseIterable {
                case active = "Active"
                case inactive = "Inactive"
            }

            /// The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum SmsFallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum SmsMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum StatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum VoiceFallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum VoiceMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The configuration parameter for the new phone number to receive incoming voice calls or faxes. Can be: `fax` or `voice` and defaults to `voice`.
            public enum VoiceReceiveMode: String, Codable, CaseIterable {
                case voice
                case fax
            }

            public init(addressSid: String? = nil, apiVersion: String? = nil, bundleSid: String? = nil, emergencyAddressSid: String? = nil, emergencyStatus: EmergencyStatus? = nil, friendlyName: String? = nil, identitySid: String? = nil, phoneNumber: String, smsApplicationSid: String? = nil, smsFallbackMethod: SmsFallbackMethod? = nil, smsFallbackURL: URL? = nil, smsMethod: SmsMethod? = nil, smsURL: URL? = nil, statusCallback: URL? = nil, statusCallbackMethod: StatusCallbackMethod? = nil, trunkSid: String? = nil, voiceApplicationSid: String? = nil, isVoiceCallerIDLookup: Bool? = nil, voiceFallbackMethod: VoiceFallbackMethod? = nil, voiceFallbackURL: URL? = nil, voiceMethod: VoiceMethod? = nil, voiceReceiveMode: VoiceReceiveMode? = nil, voiceURL: URL? = nil) {
                self.addressSid = addressSid
                self.apiVersion = apiVersion
                self.bundleSid = bundleSid
                self.emergencyAddressSid = emergencyAddressSid
                self.emergencyStatus = emergencyStatus
                self.friendlyName = friendlyName
                self.identitySid = identitySid
                self.phoneNumber = phoneNumber
                self.smsApplicationSid = smsApplicationSid
                self.smsFallbackMethod = smsFallbackMethod
                self.smsFallbackURL = smsFallbackURL
                self.smsMethod = smsMethod
                self.smsURL = smsURL
                self.statusCallback = statusCallback
                self.statusCallbackMethod = statusCallbackMethod
                self.trunkSid = trunkSid
                self.voiceApplicationSid = voiceApplicationSid
                self.isVoiceCallerIDLookup = isVoiceCallerIDLookup
                self.voiceFallbackMethod = voiceFallbackMethod
                self.voiceFallbackURL = voiceFallbackURL
                self.voiceMethod = voiceMethod
                self.voiceReceiveMode = voiceReceiveMode
                self.voiceURL = voiceURL
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("AddressSid", addressSid?.asQueryValue)
                query.addQueryItem("ApiVersion", apiVersion?.asQueryValue)
                query.addQueryItem("BundleSid", bundleSid?.asQueryValue)
                query.addQueryItem("EmergencyAddressSid", emergencyAddressSid?.asQueryValue)
                query.addQueryItem("EmergencyStatus", emergencyStatus?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("IdentitySid", identitySid?.asQueryValue)
                query.addQueryItem("PhoneNumber", phoneNumber.asQueryValue)
                query.addQueryItem("SmsApplicationSid", smsApplicationSid?.asQueryValue)
                query.addQueryItem("SmsFallbackMethod", smsFallbackMethod?.asQueryValue)
                query.addQueryItem("SmsFallbackUrl", smsFallbackURL?.asQueryValue)
                query.addQueryItem("SmsMethod", smsMethod?.asQueryValue)
                query.addQueryItem("SmsUrl", smsURL?.asQueryValue)
                query.addQueryItem("StatusCallback", statusCallback?.asQueryValue)
                query.addQueryItem("StatusCallbackMethod", statusCallbackMethod?.asQueryValue)
                query.addQueryItem("TrunkSid", trunkSid?.asQueryValue)
                query.addQueryItem("VoiceApplicationSid", voiceApplicationSid?.asQueryValue)
                query.addQueryItem("VoiceCallerIdLookup", isVoiceCallerIDLookup?.asQueryValue)
                query.addQueryItem("VoiceFallbackMethod", voiceFallbackMethod?.asQueryValue)
                query.addQueryItem("VoiceFallbackUrl", voiceFallbackURL?.asQueryValue)
                query.addQueryItem("VoiceMethod", voiceMethod?.asQueryValue)
                query.addQueryItem("VoiceReceiveMode", voiceReceiveMode?.asQueryValue)
                query.addQueryItem("VoiceUrl", voiceURL?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.IncomingPhoneNumbers {
    public func resourceSid(_ resourceSid: String) -> WithResourceSid {
        WithResourceSid(path: "\(path)/\(resourceSid)")
    }

    public struct WithResourceSid {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.IncomingPhoneNumbers.WithResourceSid {
    public var assignedAddOnsJSON: AssignedAddOnsJSON {
        AssignedAddOnsJSON(path: path + "/AssignedAddOns.json")
    }

    public struct AssignedAddOnsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns.json`
        public let path: String

        /// Retrieve a list of Add-on installations currently assigned to this Number.
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListIncomingPhoneNumberAssignedAddOnResponse
        public struct GetResponse: Decodable {
            public var assignedAddOns: [TwilioAPI.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(assignedAddOns: [TwilioAPI.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.assignedAddOns = assignedAddOns
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case assignedAddOns = "assigned_add_ons"
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }

        /// Assign an Add-on installation to the Number specified.
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn> {
            .post(path, body: body?.asQuery())
        }

        /// CreateIncomingPhoneNumberAssignedAddOnRequest
        public struct PostRequest: Encodable {
            /// The SID that identifies the Add-on installation.
            public var installedAddOnSid: String

            public init(installedAddOnSid: String) {
                self.installedAddOnSid = installedAddOnSid
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("InstalledAddOnSid", installedAddOnSid.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.IncomingPhoneNumbers.WithResourceSid {
    public var assignedAddOns: AssignedAddOns {
        AssignedAddOns(path: path + "/AssignedAddOns")
    }

    public struct AssignedAddOns {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.IncomingPhoneNumbers.WithResourceSid.AssignedAddOns {
    public func assignedAddOnSid(_ assignedAddOnSid: String) -> WithAssignedAddOnSid {
        WithAssignedAddOnSid(path: "\(path)/\(assignedAddOnSid)")
    }

    public struct WithAssignedAddOnSid {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{AssignedAddOnSid}`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.IncomingPhoneNumbers.WithResourceSid.AssignedAddOns.WithAssignedAddOnSid {
    public var extensionsJSON: ExtensionsJSON {
        ExtensionsJSON(path: path + "/Extensions.json")
    }

    public struct ExtensionsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{AssignedAddOnSid}/Extensions.json`
        public let path: String

        /// Retrieve a list of Extensions for the Assigned Add-on.
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListIncomingPhoneNumberAssignedAddOnExtensionResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var extensions: [TwilioAPI.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension]?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, extensions: [TwilioAPI.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension]? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.extensions = extensions
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case extensions
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }
    }
}

extension Paths.Accounts.WithAccountSid.IncomingPhoneNumbers.WithResourceSid.AssignedAddOns.WithAssignedAddOnSid {
    public var extensions: Extensions {
        Extensions(path: path + "/Extensions")
    }

    public struct Extensions {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{AssignedAddOnSid}/Extensions`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.IncomingPhoneNumbers.WithResourceSid.AssignedAddOns.WithAssignedAddOnSid.Extensions {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{AssignedAddOnSid}/Extensions/{Sid}.json`
        public let path: String

        /// Fetch an instance of an Extension for the Assigned Add-on.
        public var get: Request<TwilioAPI.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension> {
            .get(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.IncomingPhoneNumbers.WithResourceSid.AssignedAddOns {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{Sid}.json`
        public let path: String

        /// Fetch an instance of an Add-on installation currently assigned to this Number.
        public var get: Request<TwilioAPI.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn> {
            .get(path)
        }

        /// Remove the assignment of an Add-on installation from the Number specified.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.IncomingPhoneNumbers {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json`
        public let path: String

        /// Fetch an incoming-phone-number belonging to the account used to make the request.
        public var get: Request<TwilioAPI.APIV2010AccountIncomingPhoneNumber> {
            .get(path)
        }

        /// Update an incoming-phone-number instance.
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountIncomingPhoneNumber> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateIncomingPhoneNumberRequest
        public struct PostRequest: Encodable {
            /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IncomingPhoneNumber resource to update.  For more information, see [Exchanging Numbers Between Subaccounts](https://www.twilio.com/docs/iam/api/subaccounts#exchanging-numbers).
            public var accountSid: String?
            /// The SID of the Address resource we should associate with the phone number. Some regions require addresses to meet local regulations.
            public var addressSid: String?
            /// The API version to use for incoming calls made to the phone number. The default is `2010-04-01`.
            public var apiVersion: String?
            /// The SID of the Bundle resource that you associate with the phone number. Some regions require a Bundle to meet local Regulations.
            public var bundleSid: String?
            /// The SID of the emergency address configuration to use for emergency calling from this phone number.
            public var emergencyAddressSid: String?
            /// The parameter displays if emergency calling is enabled for this number. Active numbers may place emergency calls by dialing valid emergency numbers for the country.
            public var emergencyStatus: EmergencyStatus?
            /// A descriptive string that you created to describe this phone number. It can be up to 64 characters long. By default, this is a formatted version of the phone number.
            public var friendlyName: String?
            /// The SID of the Identity resource that we should associate with the phone number. Some regions require an identity to meet local regulations.
            public var identitySid: String?
            /// The SID of the application that should handle SMS messages sent to the number. If an `sms_application_sid` is present, we ignore all of the `sms_*_url` urls and use those set on the application.
            public var smsApplicationSid: String?
            /// The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var smsFallbackMethod: SmsFallbackMethod?
            /// The URL that we should call when an error occurs while requesting or executing the TwiML defined by `sms_url`.
            public var smsFallbackURL: URL?
            /// The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var smsMethod: SmsMethod?
            /// The URL we should call when the phone number receives an incoming SMS message.
            public var smsURL: URL?
            /// The URL we should call using the `status_callback_method` to send status information to your application.
            public var statusCallback: URL?
            /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
            public var statusCallbackMethod: StatusCallbackMethod?
            /// The SID of the Trunk we should use to handle phone calls to the phone number. If a `trunk_sid` is present, we ignore all of the voice urls and voice applications and use only those set on the Trunk. Setting a `trunk_sid` will automatically delete your `voice_application_sid` and vice versa.
            public var trunkSid: String?
            /// The SID of the application we should use to handle phone calls to the phone number. If a `voice_application_sid` is present, we ignore all of the voice urls and use only those set on the application. Setting a `voice_application_sid` will automatically delete your `trunk_sid` and vice versa.
            public var voiceApplicationSid: String?
            /// Whether to lookup the caller's name from the CNAM database and post it to your app. Can be: `true` or `false` and defaults to `false`.
            public var isVoiceCallerIDLookup: Bool?
            /// The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var voiceFallbackMethod: VoiceFallbackMethod?
            /// The URL that we should call when an error occurs retrieving or executing the TwiML requested by `url`.
            public var voiceFallbackURL: URL?
            /// The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public var voiceMethod: VoiceMethod?
            /// The configuration parameter for the phone number to receive incoming voice calls or faxes. Can be: `fax` or `voice` and defaults to `voice`.
            public var voiceReceiveMode: VoiceReceiveMode?
            /// The URL that we should call to answer a call to the phone number. The `voice_url` will not be called if a `voice_application_sid` or a `trunk_sid` is set.
            public var voiceURL: URL?

            /// The parameter displays if emergency calling is enabled for this number. Active numbers may place emergency calls by dialing valid emergency numbers for the country.
            public enum EmergencyStatus: String, Codable, CaseIterable {
                case active = "Active"
                case inactive = "Inactive"
            }

            /// The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum SmsFallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum SmsMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum StatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum VoiceFallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and defaults to `POST`.
            public enum VoiceMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The configuration parameter for the phone number to receive incoming voice calls or faxes. Can be: `fax` or `voice` and defaults to `voice`.
            public enum VoiceReceiveMode: String, Codable, CaseIterable {
                case voice
                case fax
            }

            public init(accountSid: String? = nil, addressSid: String? = nil, apiVersion: String? = nil, bundleSid: String? = nil, emergencyAddressSid: String? = nil, emergencyStatus: EmergencyStatus? = nil, friendlyName: String? = nil, identitySid: String? = nil, smsApplicationSid: String? = nil, smsFallbackMethod: SmsFallbackMethod? = nil, smsFallbackURL: URL? = nil, smsMethod: SmsMethod? = nil, smsURL: URL? = nil, statusCallback: URL? = nil, statusCallbackMethod: StatusCallbackMethod? = nil, trunkSid: String? = nil, voiceApplicationSid: String? = nil, isVoiceCallerIDLookup: Bool? = nil, voiceFallbackMethod: VoiceFallbackMethod? = nil, voiceFallbackURL: URL? = nil, voiceMethod: VoiceMethod? = nil, voiceReceiveMode: VoiceReceiveMode? = nil, voiceURL: URL? = nil) {
                self.accountSid = accountSid
                self.addressSid = addressSid
                self.apiVersion = apiVersion
                self.bundleSid = bundleSid
                self.emergencyAddressSid = emergencyAddressSid
                self.emergencyStatus = emergencyStatus
                self.friendlyName = friendlyName
                self.identitySid = identitySid
                self.smsApplicationSid = smsApplicationSid
                self.smsFallbackMethod = smsFallbackMethod
                self.smsFallbackURL = smsFallbackURL
                self.smsMethod = smsMethod
                self.smsURL = smsURL
                self.statusCallback = statusCallback
                self.statusCallbackMethod = statusCallbackMethod
                self.trunkSid = trunkSid
                self.voiceApplicationSid = voiceApplicationSid
                self.isVoiceCallerIDLookup = isVoiceCallerIDLookup
                self.voiceFallbackMethod = voiceFallbackMethod
                self.voiceFallbackURL = voiceFallbackURL
                self.voiceMethod = voiceMethod
                self.voiceReceiveMode = voiceReceiveMode
                self.voiceURL = voiceURL
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("AccountSid", accountSid?.asQueryValue)
                query.addQueryItem("AddressSid", addressSid?.asQueryValue)
                query.addQueryItem("ApiVersion", apiVersion?.asQueryValue)
                query.addQueryItem("BundleSid", bundleSid?.asQueryValue)
                query.addQueryItem("EmergencyAddressSid", emergencyAddressSid?.asQueryValue)
                query.addQueryItem("EmergencyStatus", emergencyStatus?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("IdentitySid", identitySid?.asQueryValue)
                query.addQueryItem("SmsApplicationSid", smsApplicationSid?.asQueryValue)
                query.addQueryItem("SmsFallbackMethod", smsFallbackMethod?.asQueryValue)
                query.addQueryItem("SmsFallbackUrl", smsFallbackURL?.asQueryValue)
                query.addQueryItem("SmsMethod", smsMethod?.asQueryValue)
                query.addQueryItem("SmsUrl", smsURL?.asQueryValue)
                query.addQueryItem("StatusCallback", statusCallback?.asQueryValue)
                query.addQueryItem("StatusCallbackMethod", statusCallbackMethod?.asQueryValue)
                query.addQueryItem("TrunkSid", trunkSid?.asQueryValue)
                query.addQueryItem("VoiceApplicationSid", voiceApplicationSid?.asQueryValue)
                query.addQueryItem("VoiceCallerIdLookup", isVoiceCallerIDLookup?.asQueryValue)
                query.addQueryItem("VoiceFallbackMethod", voiceFallbackMethod?.asQueryValue)
                query.addQueryItem("VoiceFallbackUrl", voiceFallbackURL?.asQueryValue)
                query.addQueryItem("VoiceMethod", voiceMethod?.asQueryValue)
                query.addQueryItem("VoiceReceiveMode", voiceReceiveMode?.asQueryValue)
                query.addQueryItem("VoiceUrl", voiceURL?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }

        /// Delete a phone-numbers belonging to the account used to make the request.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var keysJSON: KeysJSON {
        KeysJSON(path: path + "/Keys.json")
    }

    public struct KeysJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Keys.json`
        public let path: String

        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListKeyResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var keys: [TwilioAPI.APIV2010AccountKey]?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, keys: [TwilioAPI.APIV2010AccountKey]? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.keys = keys
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case keys
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }

        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountNewKey> {
            .post(path, body: body?.asQuery())
        }

        /// CreateNewKeyRequest
        public struct PostRequest: Encodable {
            /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
            public var friendlyName: String?

            public init(friendlyName: String? = nil) {
                self.friendlyName = friendlyName
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var keys: Keys {
        Keys(path: path + "/Keys")
    }

    public struct Keys {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Keys`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Keys {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json`
        public let path: String

        public var get: Request<TwilioAPI.APIV2010AccountKey> {
            .get(path)
        }

        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountKey> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateKeyRequest
        public struct PostRequest: Encodable {
            /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
            public var friendlyName: String?

            public init(friendlyName: String? = nil) {
                self.friendlyName = friendlyName
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var messagesJSON: MessagesJSON {
        MessagesJSON(path: path + "/Messages.json")
    }

    public struct MessagesJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Messages.json`
        public let path: String

        /// Retrieve a list of messages belonging to the account used to make the request
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListMessageResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var messages: [TwilioAPI.APIV2010AccountMessage]?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, messages: [TwilioAPI.APIV2010AccountMessage]? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.messages = messages
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case messages
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var to: String?
            public var from: String?
            public var dateSent: Date?
            public var dateSentLessThan: Date?
            public var dateSentGreaterThan: Date?
            public var pageSize: Int?

            public init(to: String? = nil, from: String? = nil, dateSent: Date? = nil, dateSentLessThan: Date? = nil, dateSentGreaterThan: Date? = nil, pageSize: Int? = nil) {
                self.to = to
                self.from = from
                self.dateSent = dateSent
                self.dateSentLessThan = dateSentLessThan
                self.dateSentGreaterThan = dateSentGreaterThan
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("To", to?.asQueryValue)
                query.addQueryItem("From", from?.asQueryValue)
                query.addQueryItem("DateSent", dateSent?.asQueryValue)
                query.addQueryItem("DateSent<", dateSentLessThan?.asQueryValue)
                query.addQueryItem("DateSent>", dateSentGreaterThan?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }

        /// Send a message from the account used to make the request
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountMessage> {
            .post(path, body: body?.asQuery())
        }

        /// CreateMessageRequest
        public struct PostRequest: Encodable {
            /// Determines if the address can be stored or obfuscated based on privacy settings
            public var addressRetention: AddressRetention?
            /// The SID of the application that should receive message status. We POST a `message_sid` parameter and a `message_status` parameter with a value of `sent` or `failed` to the [application](https://www.twilio.com/docs/usage/api/applications)'s `message_status_callback`. If a `status_callback` parameter is also passed, it will be ignored and the application's `message_status_callback` parameter will be used.
            public var applicationSid: String?
            /// Total number of attempts made ( including this ) to send out the message regardless of the provider used
            public var attempt: Int?
            /// The text of the message you want to send. Can be up to 1,600 characters in length.
            public var body: String?
            /// Determines if the message content can be stored or redacted based on privacy settings
            public var contentRetention: ContentRetention?
            /// Reserved
            public var isForceDelivery: Bool?
            /// A Twilio phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, an [alphanumeric sender ID](https://www.twilio.com/docs/sms/send-messages#use-an-alphanumeric-sender-id), or a [Channel Endpoint address](https://www.twilio.com/docs/sms/channels#channel-addresses) that is enabled for the type of message you want to send. Phone numbers or [short codes](https://www.twilio.com/docs/sms/api/short-code) purchased from Twilio also work here. You cannot, for example, spoof messages from a private cell phone number. If you are using `messaging_service_sid`, this parameter must be empty.
            public var from: String?
            /// The maximum total price in US dollars that you will pay for the message to be delivered. Can be a decimal value that has up to 4 decimal places. All messages are queued for delivery and the message cost is checked before the message is sent. If the cost exceeds `max_price`, the message will fail and a status of `Failed` is sent to the status callback. If `MaxPrice` is not set, the message cost is not checked.
            public var maxPrice: Double?
            /// The URL of the media to send with the message. The media can be of type `gif`, `png`, and `jpeg` and will be formatted correctly on the recipient's device. The media size limit is 5MB for supported file types (JPEG, PNG, GIF) and 500KB for [other types](https://www.twilio.com/docs/sms/accepted-mime-types) of accepted media. To send more than one image in the message body, provide multiple `media_url` parameters in the POST request. You can include up to 10 `media_url` parameters per message. You can send images in an SMS message in only the US and Canada.
            public var mediaURL: [URL]?
            /// The SID of the [Messaging Service](https://www.twilio.com/docs/sms/services#send-a-message-with-copilot) you want to associate with the Message. Set this parameter to use the [Messaging Service Settings and Copilot Features](https://www.twilio.com/console/sms/services) you have configured and leave the `from` parameter empty. When only this parameter is set, Twilio will use your enabled Copilot Features to select the `from` phone number for delivery.
            public var messagingServiceSid: String?
            /// Rich actions for Channels Messages.
            public var persistentAction: [String]?
            /// Whether to confirm delivery of the message. Set this value to `true` if you are sending messages that have a trackable user action and you intend to confirm delivery of the message using the [Message Feedback API](https://www.twilio.com/docs/sms/api/message-feedback-resource). This parameter is `false` by default.
            public var isProvideFeedback: Bool?
            /// If set to True, Twilio will deliver the message as a single MMS message, regardless of the presence of media. This is a Beta Feature.
            public var isSendAsMms: Bool?
            /// Whether to detect Unicode characters that have a similar GSM-7 character and replace them. Can be: `true` or `false`.
            public var isSmartEncoded: Bool?
            /// The URL we should call using the `status_callback_method` to send status information to your application. If specified, we POST these message status changes to the URL: `queued`, `failed`, `sent`, `delivered`, or `undelivered`. Twilio will POST its [standard request parameters](https://www.twilio.com/docs/sms/twiml#request-parameters) as well as some additional parameters including `MessageSid`, `MessageStatus`, and `ErrorCode`. If you include this parameter with the `messaging_service_sid`, we use this URL instead of the Status Callback URL of the [Messaging Service](https://www.twilio.com/docs/sms/services/api). URLs must contain a valid hostname and underscores are not allowed.
            public var statusCallback: URL?
            /// The destination phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format for SMS/MMS or [Channel user address](https://www.twilio.com/docs/sms/channels#channel-addresses) for other 3rd-party channels.
            public var to: String
            /// How long in seconds the message can remain in our outgoing message queue. After this period elapses, the message fails and we call your status callback. Can be between 1 and the default value of 14,400 seconds. After a message has been accepted by a carrier, however, we cannot guarantee that the message will not be queued after this period. We recommend that this value be at least 5 seconds.
            public var validityPeriod: Int?

            /// Determines if the address can be stored or obfuscated based on privacy settings
            public enum AddressRetention: String, Codable, CaseIterable {
                case retain
            }

            /// Determines if the message content can be stored or redacted based on privacy settings
            public enum ContentRetention: String, Codable, CaseIterable {
                case retain
            }

            public init(addressRetention: AddressRetention? = nil, applicationSid: String? = nil, attempt: Int? = nil, body: String? = nil, contentRetention: ContentRetention? = nil, isForceDelivery: Bool? = nil, from: String? = nil, maxPrice: Double? = nil, mediaURL: [URL]? = nil, messagingServiceSid: String? = nil, persistentAction: [String]? = nil, isProvideFeedback: Bool? = nil, isSendAsMms: Bool? = nil, isSmartEncoded: Bool? = nil, statusCallback: URL? = nil, to: String, validityPeriod: Int? = nil) {
                self.addressRetention = addressRetention
                self.applicationSid = applicationSid
                self.attempt = attempt
                self.body = body
                self.contentRetention = contentRetention
                self.isForceDelivery = isForceDelivery
                self.from = from
                self.maxPrice = maxPrice
                self.mediaURL = mediaURL
                self.messagingServiceSid = messagingServiceSid
                self.persistentAction = persistentAction
                self.isProvideFeedback = isProvideFeedback
                self.isSendAsMms = isSendAsMms
                self.isSmartEncoded = isSmartEncoded
                self.statusCallback = statusCallback
                self.to = to
                self.validityPeriod = validityPeriod
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("AddressRetention", addressRetention?.asQueryValue)
                query.addQueryItem("ApplicationSid", applicationSid?.asQueryValue)
                query.addQueryItem("Attempt", attempt?.asQueryValue)
                query.addQueryItem("Body", body?.asQueryValue)
                query.addQueryItem("ContentRetention", contentRetention?.asQueryValue)
                query.addQueryItem("ForceDelivery", isForceDelivery?.asQueryValue)
                query.addQueryItem("From", from?.asQueryValue)
                query.addQueryItem("MaxPrice", maxPrice?.asQueryValue)
                for value in mediaURL ?? [] {
                    query.addQueryItem("MediaUrl", value.asQueryValue)
                }
                query.addQueryItem("MessagingServiceSid", messagingServiceSid?.asQueryValue)
                for value in persistentAction ?? [] {
                    query.addQueryItem("PersistentAction", value.asQueryValue)
                }
                query.addQueryItem("ProvideFeedback", isProvideFeedback?.asQueryValue)
                query.addQueryItem("SendAsMms", isSendAsMms?.asQueryValue)
                query.addQueryItem("SmartEncoded", isSmartEncoded?.asQueryValue)
                query.addQueryItem("StatusCallback", statusCallback?.asQueryValue)
                query.addQueryItem("To", to.asQueryValue)
                query.addQueryItem("ValidityPeriod", validityPeriod?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var messages: Messages {
        Messages(path: path + "/Messages")
    }

    public struct Messages {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Messages`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Messages {
    public func messageSid(_ messageSid: String) -> WithMessageSid {
        WithMessageSid(path: "\(path)/\(messageSid)")
    }

    public struct WithMessageSid {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Messages.WithMessageSid {
    public var feedbackJSON: FeedbackJSON {
        FeedbackJSON(path: path + "/Feedback.json")
    }

    public struct FeedbackJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Feedback.json`
        public let path: String

        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountMessageMessageFeedback> {
            .post(path, body: body?.asQuery())
        }

        /// CreateMessageFeedbackRequest
        public struct PostRequest: Encodable {
            /// Whether the feedback has arrived. Can be: `unconfirmed` or `confirmed`. If `provide_feedback`=`true` in [the initial HTTP POST](https://www.twilio.com/docs/sms/api/message-resource#create-a-message-resource), the initial value of this property is `unconfirmed`. After the message arrives, update the value to `confirmed`.
            public var outcome: Outcome?

            /// Whether the feedback has arrived. Can be: `unconfirmed` or `confirmed`. If `provide_feedback`=`true` in [the initial HTTP POST](https://www.twilio.com/docs/sms/api/message-resource#create-a-message-resource), the initial value of this property is `unconfirmed`. After the message arrives, update the value to `confirmed`.
            public enum Outcome: String, Codable, CaseIterable {
                case confirmed
                case unconfirmed
            }

            public init(outcome: Outcome? = nil) {
                self.outcome = outcome
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("Outcome", outcome?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Messages.WithMessageSid {
    public var mediaJSON: MediaJSON {
        MediaJSON(path: path + "/Media.json")
    }

    public struct MediaJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media.json`
        public let path: String

        /// Retrieve a list of Media resources belonging to the account used to make the request
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListMediaResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var mediaList: [TwilioAPI.APIV2010AccountMessageMedia]?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, mediaList: [TwilioAPI.APIV2010AccountMessageMedia]? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.mediaList = mediaList
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case mediaList = "media_list"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var dateCreated: Date?
            public var dateCreatedLessThan: Date?
            public var dateCreatedGreaterThan: Date?
            public var pageSize: Int?

            public init(dateCreated: Date? = nil, dateCreatedLessThan: Date? = nil, dateCreatedGreaterThan: Date? = nil, pageSize: Int? = nil) {
                self.dateCreated = dateCreated
                self.dateCreatedLessThan = dateCreatedLessThan
                self.dateCreatedGreaterThan = dateCreatedGreaterThan
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("DateCreated", dateCreated?.asQueryValue)
                query.addQueryItem("DateCreated<", dateCreatedLessThan?.asQueryValue)
                query.addQueryItem("DateCreated>", dateCreatedGreaterThan?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Messages.WithMessageSid {
    public var media: Media {
        Media(path: path + "/Media")
    }

    public struct Media {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Messages.WithMessageSid.Media {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media/{Sid}.json`
        public let path: String

        /// Fetch a single media instance belonging to the account used to make the request
        public var get: Request<TwilioAPI.APIV2010AccountMessageMedia> {
            .get(path)
        }

        /// Delete media from your account. Once delete, you will no longer be billed
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.Messages {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json`
        public let path: String

        /// Fetch a message belonging to the account used to make the request
        public var get: Request<TwilioAPI.APIV2010AccountMessage> {
            .get(path)
        }

        /// To redact a message-body from a post-flight message record, post to the message instance resource with an empty body
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountMessage> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateMessageRequest
        public struct PostRequest: Encodable {
            /// The text of the message you want to send. Can be up to 1,600 characters long.
            public var body: String?

            public init(body: String? = nil) {
                self.body = body
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("Body", body?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }

        /// Deletes a message record from your account
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var notificationsJSON: NotificationsJSON {
        NotificationsJSON(path: path + "/Notifications.json")
    }

    public struct NotificationsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Notifications.json`
        public let path: String

        /// Retrieve a list of notifications belonging to the account used to make the request
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListNotificationResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var notifications: [TwilioAPI.APIV2010AccountNotification]?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, notifications: [TwilioAPI.APIV2010AccountNotification]? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.notifications = notifications
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case notifications
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var log: Int?
            public var messageDate: NaiveDate?
            public var messageDateLessThan: NaiveDate?
            public var messageDateGreaterThan: NaiveDate?
            public var pageSize: Int?

            public init(log: Int? = nil, messageDate: NaiveDate? = nil, messageDateLessThan: NaiveDate? = nil, messageDateGreaterThan: NaiveDate? = nil, pageSize: Int? = nil) {
                self.log = log
                self.messageDate = messageDate
                self.messageDateLessThan = messageDateLessThan
                self.messageDateGreaterThan = messageDateGreaterThan
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("Log", log?.asQueryValue)
                query.addQueryItem("MessageDate", messageDate?.asQueryValue)
                query.addQueryItem("MessageDate<", messageDateLessThan?.asQueryValue)
                query.addQueryItem("MessageDate>", messageDateGreaterThan?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var notifications: Notifications {
        Notifications(path: path + "/Notifications")
    }

    public struct Notifications {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Notifications`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Notifications {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Notifications/{Sid}.json`
        public let path: String

        /// Fetch a notification belonging to the account used to make the request
        public var get: Request<TwilioAPI.APIV2010AccountNotificationInstance> {
            .get(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var outgoingCallerIDsJSON: OutgoingCallerIDsJSON {
        OutgoingCallerIDsJSON(path: path + "/OutgoingCallerIds.json")
    }

    public struct OutgoingCallerIDsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds.json`
        public let path: String

        /// Retrieve a list of outgoing-caller-ids belonging to the account used to make the request
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListOutgoingCallerIdResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var outgoingCallerIDs: [TwilioAPI.APIV2010AccountOutgoingCallerID]?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, outgoingCallerIDs: [TwilioAPI.APIV2010AccountOutgoingCallerID]? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.outgoingCallerIDs = outgoingCallerIDs
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case outgoingCallerIDs = "outgoing_caller_ids"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var phoneNumber: String?
            public var friendlyName: String?
            public var pageSize: Int?

            public init(phoneNumber: String? = nil, friendlyName: String? = nil, pageSize: Int? = nil) {
                self.phoneNumber = phoneNumber
                self.friendlyName = friendlyName
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("PhoneNumber", phoneNumber?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }

        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountValidationRequest> {
            .post(path, body: body?.asQuery())
        }

        /// CreateValidationRequestRequest
        public struct PostRequest: Encodable {
            /// The number of seconds to delay before initiating the verification call. Can be an integer between `0` and `60`, inclusive. The default is `0`.
            public var callDelay: Int?
            /// The digits to dial after connecting the verification call.
            public var `extension`: String?
            /// A descriptive string that you create to describe the new caller ID resource. It can be up to 64 characters long. The default value is a formatted version of the phone number.
            public var friendlyName: String?
            /// The phone number to verify in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, which consists of a + followed by the country code and subscriber number.
            public var phoneNumber: String
            /// The URL we should call using the `status_callback_method` to send status information about the verification process to your application.
            public var statusCallback: URL?
            /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST`, and the default is `POST`.
            public var statusCallbackMethod: StatusCallbackMethod?

            /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST`, and the default is `POST`.
            public enum StatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            public init(callDelay: Int? = nil, `extension`: String? = nil, friendlyName: String? = nil, phoneNumber: String, statusCallback: URL? = nil, statusCallbackMethod: StatusCallbackMethod? = nil) {
                self.callDelay = callDelay
                self.extension = `extension`
                self.friendlyName = friendlyName
                self.phoneNumber = phoneNumber
                self.statusCallback = statusCallback
                self.statusCallbackMethod = statusCallbackMethod
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("CallDelay", callDelay?.asQueryValue)
                query.addQueryItem("Extension", `extension`?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("PhoneNumber", phoneNumber.asQueryValue)
                query.addQueryItem("StatusCallback", statusCallback?.asQueryValue)
                query.addQueryItem("StatusCallbackMethod", statusCallbackMethod?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var outgoingCallerIDs: OutgoingCallerIDs {
        OutgoingCallerIDs(path: path + "/OutgoingCallerIds")
    }

    public struct OutgoingCallerIDs {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.OutgoingCallerIDs {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json`
        public let path: String

        /// Fetch an outgoing-caller-id belonging to the account used to make the request
        public var get: Request<TwilioAPI.APIV2010AccountOutgoingCallerID> {
            .get(path)
        }

        /// Updates the caller-id
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountOutgoingCallerID> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateOutgoingCallerIdRequest
        public struct PostRequest: Encodable {
            /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
            public var friendlyName: String?

            public init(friendlyName: String? = nil) {
                self.friendlyName = friendlyName
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }

        /// Delete the caller-id specified from the account
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var queuesJSON: QueuesJSON {
        QueuesJSON(path: path + "/Queues.json")
    }

    public struct QueuesJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Queues.json`
        public let path: String

        /// Retrieve a list of queues belonging to the account used to make the request
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListQueueResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var queues: [TwilioAPI.APIV2010AccountQueue]?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, queues: [TwilioAPI.APIV2010AccountQueue]? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.queues = queues
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case queues
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }

        /// Create a queue
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountQueue> {
            .post(path, body: body?.asQuery())
        }

        /// CreateQueueRequest
        public struct PostRequest: Encodable {
            /// A descriptive string that you created to describe this resource. It can be up to 64 characters long.
            public var friendlyName: String
            /// The maximum number of calls allowed to be in the queue. The default is 100. The maximum is 5000.
            public var maxSize: Int?

            public init(friendlyName: String, maxSize: Int? = nil) {
                self.friendlyName = friendlyName
                self.maxSize = maxSize
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("FriendlyName", friendlyName.asQueryValue)
                query.addQueryItem("MaxSize", maxSize?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var queues: Queues {
        Queues(path: path + "/Queues")
    }

    public struct Queues {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Queues`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Queues {
    public func queueSid(_ queueSid: String) -> WithQueueSid {
        WithQueueSid(path: "\(path)/\(queueSid)")
    }

    public struct WithQueueSid {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Queues.WithQueueSid {
    public var membersJSON: MembersJSON {
        MembersJSON(path: path + "/Members.json")
    }

    public struct MembersJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members.json`
        public let path: String

        /// Retrieve the members of the queue
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListMemberResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var queueMembers: [TwilioAPI.APIV2010AccountQueueMember]?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, queueMembers: [TwilioAPI.APIV2010AccountQueueMember]? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.queueMembers = queueMembers
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case queueMembers = "queue_members"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }
    }
}

extension Paths.Accounts.WithAccountSid.Queues.WithQueueSid {
    public var members: Members {
        Members(path: path + "/Members")
    }

    public struct Members {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Queues.WithQueueSid.Members {
    public func callSid(_ callSid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(callSid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members/{CallSid}.json`
        public let path: String

        /// Fetch a specific member from the queue
        public var get: Request<TwilioAPI.APIV2010AccountQueueMember> {
            .get(path)
        }

        /// Dequeue a member from a queue and have the member's call begin executing the TwiML document at that URL
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountQueueMember> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateMemberRequest
        public struct PostRequest: Encodable {
            /// How to pass the update request data. Can be `GET` or `POST` and the default is `POST`. `POST` sends the data as encoded form data and `GET` sends the data as query parameters.
            public var method: Method?
            /// The absolute URL of the Queue resource.
            public var url: URL

            /// How to pass the update request data. Can be `GET` or `POST` and the default is `POST`. `POST` sends the data as encoded form data and `GET` sends the data as query parameters.
            public enum Method: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            public init(method: Method? = nil, url: URL) {
                self.method = method
                self.url = url
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("Method", method?.asQueryValue)
                query.addQueryItem("Url", url.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Queues {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json`
        public let path: String

        /// Fetch an instance of a queue identified by the QueueSid
        public var get: Request<TwilioAPI.APIV2010AccountQueue> {
            .get(path)
        }

        /// Update the queue with the new parameters
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountQueue> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateQueueRequest
        public struct PostRequest: Encodable {
            /// A descriptive string that you created to describe this resource. It can be up to 64 characters long.
            public var friendlyName: String?
            /// The maximum number of calls allowed to be in the queue. The default is 100. The maximum is 5000.
            public var maxSize: Int?

            public init(friendlyName: String? = nil, maxSize: Int? = nil) {
                self.friendlyName = friendlyName
                self.maxSize = maxSize
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("MaxSize", maxSize?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }

        /// Remove an empty queue
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var recordingsJSON: RecordingsJSON {
        RecordingsJSON(path: path + "/Recordings.json")
    }

    public struct RecordingsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Recordings.json`
        public let path: String

        /// Retrieve a list of recordings belonging to the account used to make the request
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListRecordingResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var recordings: [TwilioAPI.APIV2010AccountRecording]?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, recordings: [TwilioAPI.APIV2010AccountRecording]? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.recordings = recordings
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case recordings
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var dateCreated: Date?
            public var dateCreatedLessThan: Date?
            public var dateCreatedGreaterThan: Date?
            public var callSid: String?
            public var conferenceSid: String?
            public var pageSize: Int?

            public init(dateCreated: Date? = nil, dateCreatedLessThan: Date? = nil, dateCreatedGreaterThan: Date? = nil, callSid: String? = nil, conferenceSid: String? = nil, pageSize: Int? = nil) {
                self.dateCreated = dateCreated
                self.dateCreatedLessThan = dateCreatedLessThan
                self.dateCreatedGreaterThan = dateCreatedGreaterThan
                self.callSid = callSid
                self.conferenceSid = conferenceSid
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("DateCreated", dateCreated?.asQueryValue)
                query.addQueryItem("DateCreated<", dateCreatedLessThan?.asQueryValue)
                query.addQueryItem("DateCreated>", dateCreatedGreaterThan?.asQueryValue)
                query.addQueryItem("CallSid", callSid?.asQueryValue)
                query.addQueryItem("ConferenceSid", conferenceSid?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var recordings: Recordings {
        Recordings(path: path + "/Recordings")
    }

    public struct Recordings {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Recordings`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Recordings {
    public func recordingSid(_ recordingSid: String) -> WithRecordingSid {
        WithRecordingSid(path: "\(path)/\(recordingSid)")
    }

    public struct WithRecordingSid {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Recordings.WithRecordingSid {
    public var transcriptionsJSON: TranscriptionsJSON {
        TranscriptionsJSON(path: path + "/Transcriptions.json")
    }

    public struct TranscriptionsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions.json`
        public let path: String

        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListRecordingTranscriptionResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var transcriptions: [TwilioAPI.APIV2010AccountRecordingRecordingTranscription]?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, transcriptions: [TwilioAPI.APIV2010AccountRecordingRecordingTranscription]? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.transcriptions = transcriptions
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case transcriptions
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }
    }
}

extension Paths.Accounts.WithAccountSid.Recordings.WithRecordingSid {
    public var transcriptions: Transcriptions {
        Transcriptions(path: path + "/Transcriptions")
    }

    public struct Transcriptions {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Recordings.WithRecordingSid.Transcriptions {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions/{Sid}.json`
        public let path: String

        public var get: Request<TwilioAPI.APIV2010AccountRecordingRecordingTranscription> {
            .get(path)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.Recordings {
    public func referenceSid(_ referenceSid: String) -> WithReferenceSid {
        WithReferenceSid(path: "\(path)/\(referenceSid)")
    }

    public struct WithReferenceSid {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Recordings.WithReferenceSid {
    public var addOnResultsJSON: AddOnResultsJSON {
        AddOnResultsJSON(path: path + "/AddOnResults.json")
    }

    public struct AddOnResultsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults.json`
        public let path: String

        /// Retrieve a list of results belonging to the recording
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListRecordingAddOnResultResponse
        public struct GetResponse: Decodable {
            public var addOnResults: [TwilioAPI.APIV2010AccountRecordingRecordingAddOnResult]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(addOnResults: [TwilioAPI.APIV2010AccountRecordingRecordingAddOnResult]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.addOnResults = addOnResults
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case addOnResults = "add_on_results"
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }
    }
}

extension Paths.Accounts.WithAccountSid.Recordings.WithReferenceSid {
    public var addOnResults: AddOnResults {
        AddOnResults(path: path + "/AddOnResults")
    }

    public struct AddOnResults {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Recordings.WithReferenceSid.AddOnResults {
    public func addOnResultSid(_ addOnResultSid: String) -> WithAddOnResultSid {
        WithAddOnResultSid(path: "\(path)/\(addOnResultSid)")
    }

    public struct WithAddOnResultSid {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Recordings.WithReferenceSid.AddOnResults.WithAddOnResultSid {
    public var payloadsJSON: PayloadsJSON {
        PayloadsJSON(path: path + "/Payloads.json")
    }

    public struct PayloadsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads.json`
        public let path: String

        /// Retrieve a list of payloads belonging to the AddOnResult
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListRecordingAddOnResultPayloadResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var payloads: [TwilioAPI.APIV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload]?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, payloads: [TwilioAPI.APIV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload]? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.payloads = payloads
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case payloads
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }
    }
}

extension Paths.Accounts.WithAccountSid.Recordings.WithReferenceSid.AddOnResults.WithAddOnResultSid {
    public var payloads: Payloads {
        Payloads(path: path + "/Payloads")
    }

    public struct Payloads {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Recordings.WithReferenceSid.AddOnResults.WithAddOnResultSid.Payloads {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads/{Sid}.json`
        public let path: String

        /// Fetch an instance of a result payload
        public var get: Request<TwilioAPI.APIV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload> {
            .get(path)
        }

        /// Delete a payload from the result along with all associated Data
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.Recordings.WithReferenceSid.AddOnResults {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{Sid}.json`
        public let path: String

        /// Fetch an instance of an AddOnResult
        public var get: Request<TwilioAPI.APIV2010AccountRecordingRecordingAddOnResult> {
            .get(path)
        }

        /// Delete a result and purge all associated Payloads
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.Recordings {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Recordings/{Sid}.json`
        public let path: String

        /// Fetch an instance of a recording
        public var get: Request<TwilioAPI.APIV2010AccountRecording> {
            .get(path)
        }

        /// Delete a recording from your account
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var sip: Sip {
        Sip(path: path + "/SIP")
    }

    public struct Sip {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sip {
    public var credentialListsJSON: CredentialListsJSON {
        CredentialListsJSON(path: path + "/CredentialLists.json")
    }

    public struct CredentialListsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists.json`
        public let path: String

        /// Get All Credential Lists
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListSipCredentialListResponse
        public struct GetResponse: Decodable {
            public var credentialLists: [TwilioAPI.APIV2010AccountSipSipCredentialList]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(credentialLists: [TwilioAPI.APIV2010AccountSipSipCredentialList]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.credentialLists = credentialLists
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case credentialLists = "credential_lists"
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }

        /// Create a Credential List
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountSipSipCredentialList> {
            .post(path, body: body?.asQuery())
        }

        /// CreateSipCredentialListRequest
        public struct PostRequest: Encodable {
            /// A human readable descriptive text that describes the CredentialList, up to 64 characters long.
            public var friendlyName: String

            public init(friendlyName: String) {
                self.friendlyName = friendlyName
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("FriendlyName", friendlyName.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip {
    public var credentialLists: CredentialLists {
        CredentialLists(path: path + "/CredentialLists")
    }

    public struct CredentialLists {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sip.CredentialLists {
    public func credentialListSid(_ credentialListSid: String) -> WithCredentialListSid {
        WithCredentialListSid(path: "\(path)/\(credentialListSid)")
    }

    public struct WithCredentialListSid {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sip.CredentialLists.WithCredentialListSid {
    public var credentialsJSON: CredentialsJSON {
        CredentialsJSON(path: path + "/Credentials.json")
    }

    public struct CredentialsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials.json`
        public let path: String

        /// Retrieve a list of credentials.
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListSipCredentialResponse
        public struct GetResponse: Decodable {
            public var credentials: [TwilioAPI.APIV2010AccountSipSipCredentialListSipCredential]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(credentials: [TwilioAPI.APIV2010AccountSipSipCredentialListSipCredential]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.credentials = credentials
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case credentials
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }

        /// Create a new credential resource.
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountSipSipCredentialListSipCredential> {
            .post(path, body: body?.asQuery())
        }

        /// CreateSipCredentialRequest
        public struct PostRequest: Encodable {
            /// The password that the username will use when authenticating SIP requests. The password must be a minimum of 12 characters, contain at least 1 digit, and have mixed case. (eg `IWasAtSignal2018`)
            public var password: String
            /// The username that will be passed when authenticating SIP requests. The username should be sent in response to Twilio's challenge of the initial INVITE. It can be up to 32 characters long.
            public var username: String

            public init(password: String, username: String) {
                self.password = password
                self.username = username
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("Password", password.asQueryValue)
                query.addQueryItem("Username", username.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip.CredentialLists.WithCredentialListSid {
    public var credentials: Credentials {
        Credentials(path: path + "/Credentials")
    }

    public struct Credentials {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sip.CredentialLists.WithCredentialListSid.Credentials {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json`
        public let path: String

        /// Fetch a single credential.
        public var get: Request<TwilioAPI.APIV2010AccountSipSipCredentialListSipCredential> {
            .get(path)
        }

        /// Update a credential resource.
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountSipSipCredentialListSipCredential> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateSipCredentialRequest
        public struct PostRequest: Encodable {
            /// The password that the username will use when authenticating SIP requests. The password must be a minimum of 12 characters, contain at least 1 digit, and have mixed case. (eg `IWasAtSignal2018`)
            public var password: String?

            public init(password: String? = nil) {
                self.password = password
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("Password", password?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }

        /// Delete a credential resource.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip.CredentialLists {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json`
        public let path: String

        /// Get a Credential List
        public var get: Request<TwilioAPI.APIV2010AccountSipSipCredentialList> {
            .get(path)
        }

        /// Update a Credential List
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountSipSipCredentialList> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateSipCredentialListRequest
        public struct PostRequest: Encodable {
            /// A human readable descriptive text for a CredentialList, up to 64 characters long.
            public var friendlyName: String

            public init(friendlyName: String) {
                self.friendlyName = friendlyName
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("FriendlyName", friendlyName.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }

        /// Delete a Credential List
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip {
    public var domainsJSON: DomainsJSON {
        DomainsJSON(path: path + "/Domains.json")
    }

    public struct DomainsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains.json`
        public let path: String

        /// Retrieve a list of domains belonging to the account used to make the request
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListSipDomainResponse
        public struct GetResponse: Decodable {
            public var domains: [TwilioAPI.APIV2010AccountSipSipDomain]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(domains: [TwilioAPI.APIV2010AccountSipSipDomain]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.domains = domains
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case domains
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }

        /// Create a new Domain
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountSipSipDomain> {
            .post(path, body: body?.asQuery())
        }

        /// CreateSipDomainRequest
        public struct PostRequest: Encodable {
            /// The SID of the BYOC Trunk(Bring Your Own Carrier) resource that the Sip Domain will be associated with.
            public var byocTrunkSid: String?
            /// The unique address you reserve on Twilio to which you route your SIP traffic. Domain names can contain letters, digits, and "-" and must end with `sip.twilio.com`.
            public var domainName: String
            /// Whether an emergency caller sid is configured for the domain. If present, this phone number will be used as the callback for the emergency call.
            public var emergencyCallerSid: String?
            /// Whether emergency calling is enabled for the domain. If enabled, allows emergency calls on the domain from phone numbers with validated addresses.
            public var isEmergencyCallingEnabled: Bool?
            /// A descriptive string that you created to describe the resource. It can be up to 64 characters long.
            public var friendlyName: String?
            /// Whether secure SIP is enabled for the domain. If enabled, TLS will be enforced and SRTP will be negotiated on all incoming calls to this sip domain.
            public var isSecure: Bool?
            /// Whether to allow SIP Endpoints to register with the domain to receive calls. Can be `true` or `false`. `true` allows SIP Endpoints to register with the domain to receive calls, `false` does not.
            public var isSipRegistration: Bool?
            /// The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`.
            public var voiceFallbackMethod: VoiceFallbackMethod?
            /// The URL that we should call when an error occurs while retrieving or executing the TwiML from `voice_url`.
            public var voiceFallbackURL: URL?
            /// The HTTP method we should use to call `voice_url`. Can be: `GET` or `POST`.
            public var voiceMethod: VoiceMethod?
            /// The HTTP method we should use to call `voice_status_callback_url`. Can be: `GET` or `POST`.
            public var voiceStatusCallbackMethod: VoiceStatusCallbackMethod?
            /// The URL that we should call to pass status parameters (such as call ended) to your application.
            public var voiceStatusCallbackURL: URL?
            /// The URL we should when the domain receives a call.
            public var voiceURL: URL?

            /// The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`.
            public enum VoiceFallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `voice_url`. Can be: `GET` or `POST`.
            public enum VoiceMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `voice_status_callback_url`. Can be: `GET` or `POST`.
            public enum VoiceStatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            public init(byocTrunkSid: String? = nil, domainName: String, emergencyCallerSid: String? = nil, isEmergencyCallingEnabled: Bool? = nil, friendlyName: String? = nil, isSecure: Bool? = nil, isSipRegistration: Bool? = nil, voiceFallbackMethod: VoiceFallbackMethod? = nil, voiceFallbackURL: URL? = nil, voiceMethod: VoiceMethod? = nil, voiceStatusCallbackMethod: VoiceStatusCallbackMethod? = nil, voiceStatusCallbackURL: URL? = nil, voiceURL: URL? = nil) {
                self.byocTrunkSid = byocTrunkSid
                self.domainName = domainName
                self.emergencyCallerSid = emergencyCallerSid
                self.isEmergencyCallingEnabled = isEmergencyCallingEnabled
                self.friendlyName = friendlyName
                self.isSecure = isSecure
                self.isSipRegistration = isSipRegistration
                self.voiceFallbackMethod = voiceFallbackMethod
                self.voiceFallbackURL = voiceFallbackURL
                self.voiceMethod = voiceMethod
                self.voiceStatusCallbackMethod = voiceStatusCallbackMethod
                self.voiceStatusCallbackURL = voiceStatusCallbackURL
                self.voiceURL = voiceURL
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("ByocTrunkSid", byocTrunkSid?.asQueryValue)
                query.addQueryItem("DomainName", domainName.asQueryValue)
                query.addQueryItem("EmergencyCallerSid", emergencyCallerSid?.asQueryValue)
                query.addQueryItem("EmergencyCallingEnabled", isEmergencyCallingEnabled?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("Secure", isSecure?.asQueryValue)
                query.addQueryItem("SipRegistration", isSipRegistration?.asQueryValue)
                query.addQueryItem("VoiceFallbackMethod", voiceFallbackMethod?.asQueryValue)
                query.addQueryItem("VoiceFallbackUrl", voiceFallbackURL?.asQueryValue)
                query.addQueryItem("VoiceMethod", voiceMethod?.asQueryValue)
                query.addQueryItem("VoiceStatusCallbackMethod", voiceStatusCallbackMethod?.asQueryValue)
                query.addQueryItem("VoiceStatusCallbackUrl", voiceStatusCallbackURL?.asQueryValue)
                query.addQueryItem("VoiceUrl", voiceURL?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip {
    public var domains: Domains {
        Domains(path: path + "/Domains")
    }

    public struct Domains {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains {
    public func domainSid(_ domainSid: String) -> WithDomainSid {
        WithDomainSid(path: "\(path)/\(domainSid)")
    }

    public struct WithDomainSid {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains.WithDomainSid {
    public var auth: Auth {
        Auth(path: path + "/Auth")
    }

    public struct Auth {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains.WithDomainSid.Auth {
    public var calls: Calls {
        Calls(path: path + "/Calls")
    }

    public struct Calls {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains.WithDomainSid.Auth.Calls {
    public var credentialListMappingsJSON: CredentialListMappingsJSON {
        CredentialListMappingsJSON(path: path + "/CredentialListMappings.json")
    }

    public struct CredentialListMappingsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings.json`
        public let path: String

        /// Retrieve a list of credential list mappings belonging to the domain used in the request
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListSipAuthCallsCredentialListMappingResponse
        public struct GetResponse: Decodable {
            public var contents: [TwilioAPI.APIV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(contents: [TwilioAPI.APIV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.contents = contents
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case contents
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }

        /// Create a new credential list mapping resource
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping> {
            .post(path, body: body?.asQuery())
        }

        /// CreateSipAuthCallsCredentialListMappingRequest
        public struct PostRequest: Encodable {
            /// The SID of the CredentialList resource to map to the SIP domain.
            public var credentialListSid: String

            public init(credentialListSid: String) {
                self.credentialListSid = credentialListSid
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("CredentialListSid", credentialListSid.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains.WithDomainSid.Auth.Calls {
    public var credentialListMappings: CredentialListMappings {
        CredentialListMappings(path: path + "/CredentialListMappings")
    }

    public struct CredentialListMappings {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains.WithDomainSid.Auth.Calls.CredentialListMappings {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings/{Sid}.json`
        public let path: String

        /// Fetch a specific instance of a credential list mapping
        public var get: Request<TwilioAPI.APIV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping> {
            .get(path)
        }

        /// Delete a credential list mapping from the requested domain
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains.WithDomainSid.Auth.Calls {
    public var ipAccessControlListMappingsJSON: IpAccessControlListMappingsJSON {
        IpAccessControlListMappingsJSON(path: path + "/IpAccessControlListMappings.json")
    }

    public struct IpAccessControlListMappingsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings.json`
        public let path: String

        /// Retrieve a list of IP Access Control List mappings belonging to the domain used in the request
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListSipAuthCallsIpAccessControlListMappingResponse
        public struct GetResponse: Decodable {
            public var contents: [TwilioAPI.APIV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(contents: [TwilioAPI.APIV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.contents = contents
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case contents
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }

        /// Create a new IP Access Control List mapping
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping> {
            .post(path, body: body?.asQuery())
        }

        /// CreateSipAuthCallsIpAccessControlListMappingRequest
        public struct PostRequest: Encodable {
            /// The SID of the IpAccessControlList resource to map to the SIP domain.
            public var ipAccessControlListSid: String

            public init(ipAccessControlListSid: String) {
                self.ipAccessControlListSid = ipAccessControlListSid
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("IpAccessControlListSid", ipAccessControlListSid.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains.WithDomainSid.Auth.Calls {
    public var ipAccessControlListMappings: IpAccessControlListMappings {
        IpAccessControlListMappings(path: path + "/IpAccessControlListMappings")
    }

    public struct IpAccessControlListMappings {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains.WithDomainSid.Auth.Calls.IpAccessControlListMappings {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings/{Sid}.json`
        public let path: String

        /// Fetch a specific instance of an IP Access Control List mapping
        public var get: Request<TwilioAPI.APIV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping> {
            .get(path)
        }

        /// Delete an IP Access Control List mapping from the requested domain
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains.WithDomainSid.Auth {
    public var registrations: Registrations {
        Registrations(path: path + "/Registrations")
    }

    public struct Registrations {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains.WithDomainSid.Auth.Registrations {
    public var credentialListMappingsJSON: CredentialListMappingsJSON {
        CredentialListMappingsJSON(path: path + "/CredentialListMappings.json")
    }

    public struct CredentialListMappingsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings.json`
        public let path: String

        /// Retrieve a list of credential list mappings belonging to the domain used in the request
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListSipAuthRegistrationsCredentialListMappingResponse
        public struct GetResponse: Decodable {
            public var contents: [TwilioAPI.APIV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(contents: [TwilioAPI.APIV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.contents = contents
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case contents
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }

        /// Create a new credential list mapping resource
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping> {
            .post(path, body: body?.asQuery())
        }

        /// CreateSipAuthRegistrationsCredentialListMappingRequest
        public struct PostRequest: Encodable {
            /// The SID of the CredentialList resource to map to the SIP domain.
            public var credentialListSid: String

            public init(credentialListSid: String) {
                self.credentialListSid = credentialListSid
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("CredentialListSid", credentialListSid.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains.WithDomainSid.Auth.Registrations {
    public var credentialListMappings: CredentialListMappings {
        CredentialListMappings(path: path + "/CredentialListMappings")
    }

    public struct CredentialListMappings {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains.WithDomainSid.Auth.Registrations.CredentialListMappings {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings/{Sid}.json`
        public let path: String

        /// Fetch a specific instance of a credential list mapping
        public var get: Request<TwilioAPI.APIV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping> {
            .get(path)
        }

        /// Delete a credential list mapping from the requested domain
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains.WithDomainSid {
    public var credentialListMappingsJSON: CredentialListMappingsJSON {
        CredentialListMappingsJSON(path: path + "/CredentialListMappings.json")
    }

    public struct CredentialListMappingsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings.json`
        public let path: String

        /// Read multiple CredentialListMapping resources from an account.
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListSipCredentialListMappingResponse
        public struct GetResponse: Decodable {
            public var credentialListMappings: [TwilioAPI.APIV2010AccountSipSipDomainSipCredentialListMapping]?
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(credentialListMappings: [TwilioAPI.APIV2010AccountSipSipDomainSipCredentialListMapping]? = nil, end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.credentialListMappings = credentialListMappings
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case credentialListMappings = "credential_list_mappings"
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }

        /// Create a CredentialListMapping resource for an account.
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountSipSipDomainSipCredentialListMapping> {
            .post(path, body: body?.asQuery())
        }

        /// CreateSipCredentialListMappingRequest
        public struct PostRequest: Encodable {
            /// A 34 character string that uniquely identifies the CredentialList resource to map to the SIP domain.
            public var credentialListSid: String

            public init(credentialListSid: String) {
                self.credentialListSid = credentialListSid
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("CredentialListSid", credentialListSid.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains.WithDomainSid {
    public var credentialListMappings: CredentialListMappings {
        CredentialListMappings(path: path + "/CredentialListMappings")
    }

    public struct CredentialListMappings {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains.WithDomainSid.CredentialListMappings {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings/{Sid}.json`
        public let path: String

        /// Fetch a single CredentialListMapping resource from an account.
        public var get: Request<TwilioAPI.APIV2010AccountSipSipDomainSipCredentialListMapping> {
            .get(path)
        }

        /// Delete a CredentialListMapping resource from an account.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains.WithDomainSid {
    public var ipAccessControlListMappingsJSON: IpAccessControlListMappingsJSON {
        IpAccessControlListMappingsJSON(path: path + "/IpAccessControlListMappings.json")
    }

    public struct IpAccessControlListMappingsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings.json`
        public let path: String

        /// Retrieve a list of IpAccessControlListMapping resources.
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListSipIpAccessControlListMappingResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var ipAccessControlListMappings: [TwilioAPI.APIV2010AccountSipSipDomainSipIpAccessControlListMapping]?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, ipAccessControlListMappings: [TwilioAPI.APIV2010AccountSipSipDomainSipIpAccessControlListMapping]? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.ipAccessControlListMappings = ipAccessControlListMappings
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case ipAccessControlListMappings = "ip_access_control_list_mappings"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }

        /// Create a new IpAccessControlListMapping resource.
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountSipSipDomainSipIpAccessControlListMapping> {
            .post(path, body: body?.asQuery())
        }

        /// CreateSipIpAccessControlListMappingRequest
        public struct PostRequest: Encodable {
            /// The unique id of the IP access control list to map to the SIP domain.
            public var ipAccessControlListSid: String

            public init(ipAccessControlListSid: String) {
                self.ipAccessControlListSid = ipAccessControlListSid
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("IpAccessControlListSid", ipAccessControlListSid.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains.WithDomainSid {
    public var ipAccessControlListMappings: IpAccessControlListMappings {
        IpAccessControlListMappings(path: path + "/IpAccessControlListMappings")
    }

    public struct IpAccessControlListMappings {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains.WithDomainSid.IpAccessControlListMappings {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings/{Sid}.json`
        public let path: String

        /// Fetch an IpAccessControlListMapping resource.
        public var get: Request<TwilioAPI.APIV2010AccountSipSipDomainSipIpAccessControlListMapping> {
            .get(path)
        }

        /// Delete an IpAccessControlListMapping resource.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip.Domains {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json`
        public let path: String

        /// Fetch an instance of a Domain
        public var get: Request<TwilioAPI.APIV2010AccountSipSipDomain> {
            .get(path)
        }

        /// Update the attributes of a domain
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountSipSipDomain> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateSipDomainRequest
        public struct PostRequest: Encodable {
            /// The SID of the BYOC Trunk(Bring Your Own Carrier) resource that the Sip Domain will be associated with.
            public var byocTrunkSid: String?
            /// The unique address you reserve on Twilio to which you route your SIP traffic. Domain names can contain letters, digits, and "-" and must end with `sip.twilio.com`.
            public var domainName: String?
            /// Whether an emergency caller sid is configured for the domain. If present, this phone number will be used as the callback for the emergency call.
            public var emergencyCallerSid: String?
            /// Whether emergency calling is enabled for the domain. If enabled, allows emergency calls on the domain from phone numbers with validated addresses.
            public var isEmergencyCallingEnabled: Bool?
            /// A descriptive string that you created to describe the resource. It can be up to 64 characters long.
            public var friendlyName: String?
            /// Whether secure SIP is enabled for the domain. If enabled, TLS will be enforced and SRTP will be negotiated on all incoming calls to this sip domain.
            public var isSecure: Bool?
            /// Whether to allow SIP Endpoints to register with the domain to receive calls. Can be `true` or `false`. `true` allows SIP Endpoints to register with the domain to receive calls, `false` does not.
            public var isSipRegistration: Bool?
            /// The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`.
            public var voiceFallbackMethod: VoiceFallbackMethod?
            /// The URL that we should call when an error occurs while retrieving or executing the TwiML requested by `voice_url`.
            public var voiceFallbackURL: URL?
            /// The HTTP method we should use to call `voice_url`
            public var voiceMethod: VoiceMethod?
            /// The HTTP method we should use to call `voice_status_callback_url`. Can be: `GET` or `POST`.
            public var voiceStatusCallbackMethod: VoiceStatusCallbackMethod?
            /// The URL that we should call to pass status parameters (such as call ended) to your application.
            public var voiceStatusCallbackURL: URL?
            /// The URL we should call when the domain receives a call.
            public var voiceURL: URL?

            /// The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`.
            public enum VoiceFallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `voice_url`
            public enum VoiceMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use to call `voice_status_callback_url`. Can be: `GET` or `POST`.
            public enum VoiceStatusCallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            public init(byocTrunkSid: String? = nil, domainName: String? = nil, emergencyCallerSid: String? = nil, isEmergencyCallingEnabled: Bool? = nil, friendlyName: String? = nil, isSecure: Bool? = nil, isSipRegistration: Bool? = nil, voiceFallbackMethod: VoiceFallbackMethod? = nil, voiceFallbackURL: URL? = nil, voiceMethod: VoiceMethod? = nil, voiceStatusCallbackMethod: VoiceStatusCallbackMethod? = nil, voiceStatusCallbackURL: URL? = nil, voiceURL: URL? = nil) {
                self.byocTrunkSid = byocTrunkSid
                self.domainName = domainName
                self.emergencyCallerSid = emergencyCallerSid
                self.isEmergencyCallingEnabled = isEmergencyCallingEnabled
                self.friendlyName = friendlyName
                self.isSecure = isSecure
                self.isSipRegistration = isSipRegistration
                self.voiceFallbackMethod = voiceFallbackMethod
                self.voiceFallbackURL = voiceFallbackURL
                self.voiceMethod = voiceMethod
                self.voiceStatusCallbackMethod = voiceStatusCallbackMethod
                self.voiceStatusCallbackURL = voiceStatusCallbackURL
                self.voiceURL = voiceURL
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("ByocTrunkSid", byocTrunkSid?.asQueryValue)
                query.addQueryItem("DomainName", domainName?.asQueryValue)
                query.addQueryItem("EmergencyCallerSid", emergencyCallerSid?.asQueryValue)
                query.addQueryItem("EmergencyCallingEnabled", isEmergencyCallingEnabled?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("Secure", isSecure?.asQueryValue)
                query.addQueryItem("SipRegistration", isSipRegistration?.asQueryValue)
                query.addQueryItem("VoiceFallbackMethod", voiceFallbackMethod?.asQueryValue)
                query.addQueryItem("VoiceFallbackUrl", voiceFallbackURL?.asQueryValue)
                query.addQueryItem("VoiceMethod", voiceMethod?.asQueryValue)
                query.addQueryItem("VoiceStatusCallbackMethod", voiceStatusCallbackMethod?.asQueryValue)
                query.addQueryItem("VoiceStatusCallbackUrl", voiceStatusCallbackURL?.asQueryValue)
                query.addQueryItem("VoiceUrl", voiceURL?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }

        /// Delete an instance of a Domain
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip {
    public var ipAccessControlListsJSON: IpAccessControlListsJSON {
        IpAccessControlListsJSON(path: path + "/IpAccessControlLists.json")
    }

    public struct IpAccessControlListsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists.json`
        public let path: String

        /// Retrieve a list of IpAccessControlLists that belong to the account used to make the request
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListSipIpAccessControlListResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var ipAccessControlLists: [TwilioAPI.APIV2010AccountSipSipIpAccessControlList]?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, ipAccessControlLists: [TwilioAPI.APIV2010AccountSipSipIpAccessControlList]? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.ipAccessControlLists = ipAccessControlLists
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case ipAccessControlLists = "ip_access_control_lists"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }

        /// Create a new IpAccessControlList resource
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountSipSipIpAccessControlList> {
            .post(path, body: body?.asQuery())
        }

        /// CreateSipIpAccessControlListRequest
        public struct PostRequest: Encodable {
            /// A human readable descriptive text that describes the IpAccessControlList, up to 64 characters long.
            public var friendlyName: String

            public init(friendlyName: String) {
                self.friendlyName = friendlyName
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("FriendlyName", friendlyName.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip {
    public var ipAccessControlLists: IpAccessControlLists {
        IpAccessControlLists(path: path + "/IpAccessControlLists")
    }

    public struct IpAccessControlLists {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sip.IpAccessControlLists {
    public func ipAccessControlListSid(_ ipAccessControlListSid: String) -> WithIpAccessControlListSid {
        WithIpAccessControlListSid(path: "\(path)/\(ipAccessControlListSid)")
    }

    public struct WithIpAccessControlListSid {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sip.IpAccessControlLists.WithIpAccessControlListSid {
    public var ipAddressesJSON: IpAddressesJSON {
        IpAddressesJSON(path: path + "/IpAddresses.json")
    }

    public struct IpAddressesJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses.json`
        public let path: String

        /// Read multiple IpAddress resources.
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListSipIpAddressResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var ipAddresses: [TwilioAPI.APIV2010AccountSipSipIpAccessControlListSipIpAddress]?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, ipAddresses: [TwilioAPI.APIV2010AccountSipSipIpAccessControlListSipIpAddress]? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.ipAddresses = ipAddresses
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case ipAddresses = "ip_addresses"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }

        /// Create a new IpAddress resource.
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountSipSipIpAccessControlListSipIpAddress> {
            .post(path, body: body?.asQuery())
        }

        /// CreateSipIpAddressRequest
        public struct PostRequest: Encodable {
            /// An integer representing the length of the CIDR prefix to use with this IP address when accepting traffic. By default the entire IP address is used.
            public var cidrPrefixLength: Int?
            /// A human readable descriptive text for this resource, up to 64 characters long.
            public var friendlyName: String
            /// An IP address in dotted decimal notation from which you want to accept traffic. Any SIP requests from this IP address will be allowed by Twilio. IPv4 only supported today.
            public var ipAddress: String

            public init(cidrPrefixLength: Int? = nil, friendlyName: String, ipAddress: String) {
                self.cidrPrefixLength = cidrPrefixLength
                self.friendlyName = friendlyName
                self.ipAddress = ipAddress
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("CidrPrefixLength", cidrPrefixLength?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName.asQueryValue)
                query.addQueryItem("IpAddress", ipAddress.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip.IpAccessControlLists.WithIpAccessControlListSid {
    public var ipAddresses: IpAddresses {
        IpAddresses(path: path + "/IpAddresses")
    }

    public struct IpAddresses {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sip.IpAccessControlLists.WithIpAccessControlListSid.IpAddresses {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json`
        public let path: String

        /// Read one IpAddress resource.
        public var get: Request<TwilioAPI.APIV2010AccountSipSipIpAccessControlListSipIpAddress> {
            .get(path)
        }

        /// Update an IpAddress resource.
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountSipSipIpAccessControlListSipIpAddress> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateSipIpAddressRequest
        public struct PostRequest: Encodable {
            /// An integer representing the length of the CIDR prefix to use with this IP address when accepting traffic. By default the entire IP address is used.
            public var cidrPrefixLength: Int?
            /// A human readable descriptive text for this resource, up to 64 characters long.
            public var friendlyName: String?
            /// An IP address in dotted decimal notation from which you want to accept traffic. Any SIP requests from this IP address will be allowed by Twilio. IPv4 only supported today.
            public var ipAddress: String?

            public init(cidrPrefixLength: Int? = nil, friendlyName: String? = nil, ipAddress: String? = nil) {
                self.cidrPrefixLength = cidrPrefixLength
                self.friendlyName = friendlyName
                self.ipAddress = ipAddress
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("CidrPrefixLength", cidrPrefixLength?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("IpAddress", ipAddress?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }

        /// Delete an IpAddress resource.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sip.IpAccessControlLists {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json`
        public let path: String

        /// Fetch a specific instance of an IpAccessControlList
        public var get: Request<TwilioAPI.APIV2010AccountSipSipIpAccessControlList> {
            .get(path)
        }

        /// Rename an IpAccessControlList
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountSipSipIpAccessControlList> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateSipIpAccessControlListRequest
        public struct PostRequest: Encodable {
            /// A human readable descriptive text, up to 64 characters long.
            public var friendlyName: String

            public init(friendlyName: String) {
                self.friendlyName = friendlyName
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("FriendlyName", friendlyName.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }

        /// Delete an IpAccessControlList from the requested account
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var sms: Sms {
        Sms(path: path + "/SMS")
    }

    public struct Sms {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SMS`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sms {
    public var shortCodesJSON: ShortCodesJSON {
        ShortCodesJSON(path: path + "/ShortCodes.json")
    }

    public struct ShortCodesJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes.json`
        public let path: String

        /// Retrieve a list of short-codes belonging to the account used to make the request
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListShortCodeResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var shortCodes: [TwilioAPI.APIV2010AccountShortCode]?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, shortCodes: [TwilioAPI.APIV2010AccountShortCode]? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.shortCodes = shortCodes
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case shortCodes = "short_codes"
                case start
                case uri
            }
        }

        public struct GetParameters {
            public var friendlyName: String?
            public var shortCode: String?
            public var pageSize: Int?

            public init(friendlyName: String? = nil, shortCode: String? = nil, pageSize: Int? = nil) {
                self.friendlyName = friendlyName
                self.shortCode = shortCode
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("ShortCode", shortCode?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Sms {
    public var shortCodes: ShortCodes {
        ShortCodes(path: path + "/ShortCodes")
    }

    public struct ShortCodes {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Sms.ShortCodes {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes/{Sid}.json`
        public let path: String

        /// Fetch an instance of a short code
        public var get: Request<TwilioAPI.APIV2010AccountShortCode> {
            .get(path)
        }

        /// Update a short code with the following parameters
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountShortCode> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateShortCodeRequest
        public struct PostRequest: Encodable {
            /// The API version to use to start a new TwiML session. Can be: `2010-04-01` or `2008-08-01`.
            public var apiVersion: String?
            /// A descriptive string that you created to describe this resource. It can be up to 64 characters long. By default, the `FriendlyName` is the short code.
            public var friendlyName: String?
            /// The HTTP method that we should use to call the `sms_fallback_url`. Can be: `GET` or `POST`.
            public var smsFallbackMethod: SmsFallbackMethod?
            /// The URL that we should call if an error occurs while retrieving or executing the TwiML from `sms_url`.
            public var smsFallbackURL: URL?
            /// The HTTP method we should use when calling the `sms_url`. Can be: `GET` or `POST`.
            public var smsMethod: SmsMethod?
            /// The URL we should call when receiving an incoming SMS message to this short code.
            public var smsURL: URL?

            /// The HTTP method that we should use to call the `sms_fallback_url`. Can be: `GET` or `POST`.
            public enum SmsFallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The HTTP method we should use when calling the `sms_url`. Can be: `GET` or `POST`.
            public enum SmsMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            public init(apiVersion: String? = nil, friendlyName: String? = nil, smsFallbackMethod: SmsFallbackMethod? = nil, smsFallbackURL: URL? = nil, smsMethod: SmsMethod? = nil, smsURL: URL? = nil) {
                self.apiVersion = apiVersion
                self.friendlyName = friendlyName
                self.smsFallbackMethod = smsFallbackMethod
                self.smsFallbackURL = smsFallbackURL
                self.smsMethod = smsMethod
                self.smsURL = smsURL
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("ApiVersion", apiVersion?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("SmsFallbackMethod", smsFallbackMethod?.asQueryValue)
                query.addQueryItem("SmsFallbackUrl", smsFallbackURL?.asQueryValue)
                query.addQueryItem("SmsMethod", smsMethod?.asQueryValue)
                query.addQueryItem("SmsUrl", smsURL?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var signingKeysJSON: SigningKeysJSON {
        SigningKeysJSON(path: path + "/SigningKeys.json")
    }

    public struct SigningKeysJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SigningKeys.json`
        public let path: String

        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListSigningKeyResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var signingKeys: [TwilioAPI.APIV2010AccountSigningKey]?
            public var start: Int?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, signingKeys: [TwilioAPI.APIV2010AccountSigningKey]? = nil, start: Int? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.signingKeys = signingKeys
                self.start = start
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case signingKeys = "signing_keys"
                case start
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }

        /// Create a new Signing Key for the account making the request.
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountNewSigningKey> {
            .post(path, body: body?.asQuery())
        }

        /// CreateNewSigningKeyRequest
        public struct PostRequest: Encodable {
            /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
            public var friendlyName: String?

            public init(friendlyName: String? = nil) {
                self.friendlyName = friendlyName
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var signingKeys: SigningKeys {
        SigningKeys(path: path + "/SigningKeys")
    }

    public struct SigningKeys {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SigningKeys`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.SigningKeys {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json`
        public let path: String

        public var get: Request<TwilioAPI.APIV2010AccountSigningKey> {
            .get(path)
        }

        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountSigningKey> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateSigningKeyRequest
        public struct PostRequest: Encodable {
            public var friendlyName: String?

            public init(friendlyName: String? = nil) {
                self.friendlyName = friendlyName
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var tokensJSON: TokensJSON {
        TokensJSON(path: path + "/Tokens.json")
    }

    public struct TokensJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Tokens.json`
        public let path: String

        /// Create a new token for ICE servers
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountToken> {
            .post(path, body: body?.asQuery())
        }

        /// CreateTokenRequest
        public struct PostRequest: Encodable {
            /// The duration in seconds for which the generated credentials are valid. The default value is 86400 (24 hours).
            public var ttl: Int?

            public init(ttl: Int? = nil) {
                self.ttl = ttl
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("Ttl", ttl?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var transcriptionsJSON: TranscriptionsJSON {
        TranscriptionsJSON(path: path + "/Transcriptions.json")
    }

    public struct TranscriptionsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Transcriptions.json`
        public let path: String

        /// Retrieve a list of transcriptions belonging to the account used to make the request
        public func get(pageSize: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize))
        }

        /// ListTranscriptionResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var transcriptions: [TwilioAPI.APIV2010AccountTranscription]?
            public var uri: URL?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, transcriptions: [TwilioAPI.APIV2010AccountTranscription]? = nil, uri: URL? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.transcriptions = transcriptions
                self.uri = uri
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case transcriptions
                case uri
            }
        }

        private func makeGetQuery(_ pageSize: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("PageSize", pageSize?.asQueryValue)
            return query
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var transcriptions: Transcriptions {
        Transcriptions(path: path + "/Transcriptions")
    }

    public struct Transcriptions {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Transcriptions`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Transcriptions {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Transcriptions/{Sid}.json`
        public let path: String

        /// Fetch an instance of a Transcription
        public var get: Request<TwilioAPI.APIV2010AccountTranscription> {
            .get(path)
        }

        /// Delete a transcription from the account used to make the request
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountSid {
    public var usage: Usage {
        Usage(path: path + "/Usage")
    }

    public struct Usage {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Usage`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Usage {
    public var recordsJSON: RecordsJSON {
        RecordsJSON(path: path + "/Records.json")
    }

    public struct RecordsJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Usage/Records.json`
        public let path: String

        /// Retrieve a list of usage-records belonging to the account used to make the request
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListUsageRecordResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?
            public var usageRecords: [TwilioAPI.APIV2010AccountUsageUsageRecord]?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil, usageRecords: [TwilioAPI.APIV2010AccountUsageUsageRecord]? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
                self.usageRecords = usageRecords
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
                case usageRecords = "usage_records"
            }
        }

        public struct GetParameters {
            public var category: Category?
            public var startDate: NaiveDate?
            public var endDate: NaiveDate?
            public var isIncludeSubaccounts: Bool?
            public var pageSize: Int?

            public enum Category: String, Codable, CaseIterable {
                case agentConference = "agent-conference"
                case answeringMachineDetection = "answering-machine-detection"
                case authyAuthentications = "authy-authentications"
                case authyCallsOutbound = "authy-calls-outbound"
                case authyMonthlyFees = "authy-monthly-fees"
                case authyPhoneIntelligence = "authy-phone-intelligence"
                case authyPhoneVerifications = "authy-phone-verifications"
                case authySmsOutbound = "authy-sms-outbound"
                case callProgessEvents = "call-progess-events"
                case calleridlookups
                case calls
                case callsClient = "calls-client"
                case callsGlobalconference = "calls-globalconference"
                case callsInbound = "calls-inbound"
                case callsInboundLocal = "calls-inbound-local"
                case callsInboundMobile = "calls-inbound-mobile"
                case callsInboundTollfree = "calls-inbound-tollfree"
                case callsOutbound = "calls-outbound"
                case callsPayVerbTransactions = "calls-pay-verb-transactions"
                case callsRecordings = "calls-recordings"
                case callsSip = "calls-sip"
                case callsSipInbound = "calls-sip-inbound"
                case callsSipOutbound = "calls-sip-outbound"
                case callsTransfers = "calls-transfers"
                case carrierLookups = "carrier-lookups"
                case conversations
                case conversationsAPIRequests = "conversations-api-requests"
                case conversationsConversationEvents = "conversations-conversation-events"
                case conversationsEndpointConnectivity = "conversations-endpoint-connectivity"
                case conversationsEvents = "conversations-events"
                case conversationsParticipantEvents = "conversations-participant-events"
                case conversationsParticipants = "conversations-participants"
                case cps
                case flexUsage = "flex-usage"
                case fraudLookups = "fraud-lookups"
                case groupRooms = "group-rooms"
                case groupRoomsDataTrack = "group-rooms-data-track"
                case groupRoomsEncryptedMediaRecorded = "group-rooms-encrypted-media-recorded"
                case groupRoomsMediaDownloaded = "group-rooms-media-downloaded"
                case groupRoomsMediaRecorded = "group-rooms-media-recorded"
                case groupRoomsMediaRouted = "group-rooms-media-routed"
                case groupRoomsMediaStored = "group-rooms-media-stored"
                case groupRoomsParticipantMinutes = "group-rooms-participant-minutes"
                case groupRoomsRecordedMinutes = "group-rooms-recorded-minutes"
                case impV1Usage = "imp-v1-usage"
                case lookups
                case marketplace
                case marketplaceAlgorithmiaNamedEntityRecognition = "marketplace-algorithmia-named-entity-recognition"
                case marketplaceCadenceTranscription = "marketplace-cadence-transcription"
                case marketplaceCadenceTranslation = "marketplace-cadence-translation"
                case marketplaceCapioSpeechToText = "marketplace-capio-speech-to-text"
                case marketplaceConvrizaAbaba = "marketplace-convriza-ababa"
                case marketplaceDeepgramPhraseDetector = "marketplace-deepgram-phrase-detector"
                case marketplaceDigitalSegmentBusinessInfo = "marketplace-digital-segment-business-info"
                case marketplaceFacebookOfflineConversions = "marketplace-facebook-offline-conversions"
                case marketplaceGoogleSpeechToText = "marketplace-google-speech-to-text"
                case marketplaceIbmWatsonMessageInsights = "marketplace-ibm-watson-message-insights"
                case marketplaceIbmWatsonMessageSentiment = "marketplace-ibm-watson-message-sentiment"
                case marketplaceIbmWatsonRecordingAnalysis = "marketplace-ibm-watson-recording-analysis"
                case marketplaceIbmWatsonToneAnalyzer = "marketplace-ibm-watson-tone-analyzer"
                case marketplaceIcehookSystemsScout = "marketplace-icehook-systems-scout"
                case marketplaceInfogroupDataaxleBizinfo = "marketplace-infogroup-dataaxle-bizinfo"
                case marketplaceKeenIoContactCenterAnalytics = "marketplace-keen-io-contact-center-analytics"
                case marketplaceMarchexCleancall = "marketplace-marchex-cleancall"
                case marketplaceMarchexSentimentAnalysisForSms = "marketplace-marchex-sentiment-analysis-for-sms"
                case marketplaceMarketplaceNextcallerSocialID = "marketplace-marketplace-nextcaller-social-id"
                case marketplaceMobileCommonsOptOutClassifier = "marketplace-mobile-commons-opt-out-classifier"
                case marketplaceNexiwaveVoicemailToText = "marketplace-nexiwave-voicemail-to-text"
                case marketplaceNextcallerAdvancedCallerIdentification = "marketplace-nextcaller-advanced-caller-identification"
                case marketplaceNomoroboSpamScore = "marketplace-nomorobo-spam-score"
                case marketplacePayfoneTcpaCompliance = "marketplace-payfone-tcpa-compliance"
                case marketplaceRemeetingAutomaticSpeechRecognition = "marketplace-remeeting-automatic-speech-recognition"
                case marketplaceTcpaDefenseSolutionsBlacklistFeed = "marketplace-tcpa-defense-solutions-blacklist-feed"
                case marketplaceTeloOpencnam = "marketplace-telo-opencnam"
                case marketplaceTruecnamTrueSpam = "marketplace-truecnam-true-spam"
                case marketplaceTwilioCallerNameLookupUs = "marketplace-twilio-caller-name-lookup-us"
                case marketplaceTwilioCarrierInformationLookup = "marketplace-twilio-carrier-information-lookup"
                case marketplaceVoicebasePci = "marketplace-voicebase-pci"
                case marketplaceVoicebaseTranscription = "marketplace-voicebase-transcription"
                case marketplaceVoicebaseTranscriptionCustomVocabulary = "marketplace-voicebase-transcription-custom-vocabulary"
                case marketplaceWhitepagesProCallerIdentification = "marketplace-whitepages-pro-caller-identification"
                case marketplaceWhitepagesProPhoneIntelligence = "marketplace-whitepages-pro-phone-intelligence"
                case marketplaceWhitepagesProPhoneReputation = "marketplace-whitepages-pro-phone-reputation"
                case marketplaceWolfarmSpokenResults = "marketplace-wolfarm-spoken-results"
                case marketplaceWolframShortAnswer = "marketplace-wolfram-short-answer"
                case marketplaceYticaContactCenterReportingAnalytics = "marketplace-ytica-contact-center-reporting-analytics"
                case mediastorage
                case mms
                case mmsInbound = "mms-inbound"
                case mmsInboundLongcode = "mms-inbound-longcode"
                case mmsInboundShortcode = "mms-inbound-shortcode"
                case mmsMessagesCarrierfees = "mms-messages-carrierfees"
                case mmsOutbound = "mms-outbound"
                case mmsOutboundLongcode = "mms-outbound-longcode"
                case mmsOutboundShortcode = "mms-outbound-shortcode"
                case monitorReads = "monitor-reads"
                case monitorStorage = "monitor-storage"
                case monitorWrites = "monitor-writes"
                case notify
                case notifyActionsAttempts = "notify-actions-attempts"
                case notifyChannels = "notify-channels"
                case numberFormatLookups = "number-format-lookups"
                case pchat
                case pchatUsers = "pchat-users"
                case peerToPeerRoomsParticipantMinutes = "peer-to-peer-rooms-participant-minutes"
                case pfax
                case pfaxMinutes = "pfax-minutes"
                case pfaxMinutesInbound = "pfax-minutes-inbound"
                case pfaxMinutesOutbound = "pfax-minutes-outbound"
                case pfaxPages = "pfax-pages"
                case phonenumbers
                case phonenumbersCps = "phonenumbers-cps"
                case phonenumbersEmergency = "phonenumbers-emergency"
                case phonenumbersLocal = "phonenumbers-local"
                case phonenumbersMobile = "phonenumbers-mobile"
                case phonenumbersSetups = "phonenumbers-setups"
                case phonenumbersTollfree = "phonenumbers-tollfree"
                case premiumsupport
                case proxy
                case proxyActiveSessions = "proxy-active-sessions"
                case pstnconnectivity
                case pv
                case pvCompositionMediaDownloaded = "pv-composition-media-downloaded"
                case pvCompositionMediaEncrypted = "pv-composition-media-encrypted"
                case pvCompositionMediaStored = "pv-composition-media-stored"
                case pvCompositionMinutes = "pv-composition-minutes"
                case pvRecordingCompositions = "pv-recording-compositions"
                case pvRoomParticipants = "pv-room-participants"
                case pvRoomParticipantsAu1 = "pv-room-participants-au1"
                case pvRoomParticipantsBr1 = "pv-room-participants-br1"
                case pvRoomParticipantsIe1 = "pv-room-participants-ie1"
                case pvRoomParticipantsJp1 = "pv-room-participants-jp1"
                case pvRoomParticipantsSg1 = "pv-room-participants-sg1"
                case pvRoomParticipantsUs1 = "pv-room-participants-us1"
                case pvRoomParticipantsUs2 = "pv-room-participants-us2"
                case pvRooms = "pv-rooms"
                case pvSipEndpointRegistrations = "pv-sip-endpoint-registrations"
                case recordings
                case recordingstorage
                case roomsGroupBandwidth = "rooms-group-bandwidth"
                case roomsGroupMinutes = "rooms-group-minutes"
                case roomsPeerToPeerMinutes = "rooms-peer-to-peer-minutes"
                case shortcodes
                case shortcodesCustomerowned = "shortcodes-customerowned"
                case shortcodesMmsEnablement = "shortcodes-mms-enablement"
                case shortcodesMps = "shortcodes-mps"
                case shortcodesRandom = "shortcodes-random"
                case shortcodesUk = "shortcodes-uk"
                case shortcodesVanity = "shortcodes-vanity"
                case smallGroupRooms = "small-group-rooms"
                case smallGroupRoomsDataTrack = "small-group-rooms-data-track"
                case smallGroupRoomsParticipantMinutes = "small-group-rooms-participant-minutes"
                case sms
                case smsInbound = "sms-inbound"
                case smsInboundLongcode = "sms-inbound-longcode"
                case smsInboundShortcode = "sms-inbound-shortcode"
                case smsMessagesCarrierfees = "sms-messages-carrierfees"
                case smsMessagesFeatures = "sms-messages-features"
                case smsMessagesFeaturesSenderid = "sms-messages-features-senderid"
                case smsOutbound = "sms-outbound"
                case smsOutboundContentInspection = "sms-outbound-content-inspection"
                case smsOutboundLongcode = "sms-outbound-longcode"
                case smsOutboundShortcode = "sms-outbound-shortcode"
                case speechRecognition = "speech-recognition"
                case studioEngagements = "studio-engagements"
                case sync
                case syncActions = "sync-actions"
                case syncEndpointHours = "sync-endpoint-hours"
                case syncEndpointHoursAboveDailyCap = "sync-endpoint-hours-above-daily-cap"
                case taskrouterTasks = "taskrouter-tasks"
                case totalprice
                case transcriptions
                case trunkingCps = "trunking-cps"
                case trunkingEmergencyCalls = "trunking-emergency-calls"
                case trunkingOrigination = "trunking-origination"
                case trunkingOriginationLocal = "trunking-origination-local"
                case trunkingOriginationMobile = "trunking-origination-mobile"
                case trunkingOriginationTollfree = "trunking-origination-tollfree"
                case trunkingRecordings = "trunking-recordings"
                case trunkingSecure = "trunking-secure"
                case trunkingTermination = "trunking-termination"
                case turnmegabytes
                case turnmegabytesAustralia = "turnmegabytes-australia"
                case turnmegabytesBrasil = "turnmegabytes-brasil"
                case turnmegabytesGermany = "turnmegabytes-germany"
                case turnmegabytesIndia = "turnmegabytes-india"
                case turnmegabytesIreland = "turnmegabytes-ireland"
                case turnmegabytesJapan = "turnmegabytes-japan"
                case turnmegabytesSingapore = "turnmegabytes-singapore"
                case turnmegabytesUseast = "turnmegabytes-useast"
                case turnmegabytesUswest = "turnmegabytes-uswest"
                case twilioInterconnect = "twilio-interconnect"
                case verifyPush = "verify-push"
                case videoRecordings = "video-recordings"
                case voiceInsights = "voice-insights"
                case voiceInsightsClientInsightsOnDemandMinute = "voice-insights-client-insights-on-demand-minute"
                case voiceInsightsPtsnInsightsOnDemandMinute = "voice-insights-ptsn-insights-on-demand-minute"
                case voiceInsightsSipInterfaceInsightsOnDemandMinute = "voice-insights-sip-interface-insights-on-demand-minute"
                case voiceInsightsSipTrunkingInsightsOnDemandMinute = "voice-insights-sip-trunking-insights-on-demand-minute"
                case wireless
                case wirelessOrders = "wireless-orders"
                case wirelessOrdersArtwork = "wireless-orders-artwork"
                case wirelessOrdersBulk = "wireless-orders-bulk"
                case wirelessOrdersEsim = "wireless-orders-esim"
                case wirelessOrdersStarter = "wireless-orders-starter"
                case wirelessUsage = "wireless-usage"
                case wirelessUsageCommands = "wireless-usage-commands"
                case wirelessUsageCommandsAfrica = "wireless-usage-commands-africa"
                case wirelessUsageCommandsAsia = "wireless-usage-commands-asia"
                case wirelessUsageCommandsCentralandsouthamerica = "wireless-usage-commands-centralandsouthamerica"
                case wirelessUsageCommandsEurope = "wireless-usage-commands-europe"
                case wirelessUsageCommandsHome = "wireless-usage-commands-home"
                case wirelessUsageCommandsNorthamerica = "wireless-usage-commands-northamerica"
                case wirelessUsageCommandsOceania = "wireless-usage-commands-oceania"
                case wirelessUsageCommandsRoaming = "wireless-usage-commands-roaming"
                case wirelessUsageData = "wireless-usage-data"
                case wirelessUsageDataAfrica = "wireless-usage-data-africa"
                case wirelessUsageDataAsia = "wireless-usage-data-asia"
                case wirelessUsageDataCentralandsouthamerica = "wireless-usage-data-centralandsouthamerica"
                case wirelessUsageDataCustomAdditionalmb = "wireless-usage-data-custom-additionalmb"
                case wirelessUsageDataCustomFirst5mb = "wireless-usage-data-custom-first5mb"
                case wirelessUsageDataDomesticRoaming = "wireless-usage-data-domestic-roaming"
                case wirelessUsageDataEurope = "wireless-usage-data-europe"
                case wirelessUsageDataIndividualAdditionalgb = "wireless-usage-data-individual-additionalgb"
                case wirelessUsageDataIndividualFirstgb = "wireless-usage-data-individual-firstgb"
                case wirelessUsageDataInternationalRoamingCanada = "wireless-usage-data-international-roaming-canada"
                case wirelessUsageDataInternationalRoamingIndia = "wireless-usage-data-international-roaming-india"
                case wirelessUsageDataInternationalRoamingMexico = "wireless-usage-data-international-roaming-mexico"
                case wirelessUsageDataNorthamerica = "wireless-usage-data-northamerica"
                case wirelessUsageDataOceania = "wireless-usage-data-oceania"
                case wirelessUsageDataPooled = "wireless-usage-data-pooled"
                case wirelessUsageDataPooledDownlink = "wireless-usage-data-pooled-downlink"
                case wirelessUsageDataPooledUplink = "wireless-usage-data-pooled-uplink"
                case wirelessUsageMrc = "wireless-usage-mrc"
                case wirelessUsageMrcCustom = "wireless-usage-mrc-custom"
                case wirelessUsageMrcIndividual = "wireless-usage-mrc-individual"
                case wirelessUsageMrcPooled = "wireless-usage-mrc-pooled"
                case wirelessUsageMrcSuspended = "wireless-usage-mrc-suspended"
                case wirelessUsageSms = "wireless-usage-sms"
                case wirelessUsageVoice = "wireless-usage-voice"
            }

            public init(category: Category? = nil, startDate: NaiveDate? = nil, endDate: NaiveDate? = nil, isIncludeSubaccounts: Bool? = nil, pageSize: Int? = nil) {
                self.category = category
                self.startDate = startDate
                self.endDate = endDate
                self.isIncludeSubaccounts = isIncludeSubaccounts
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("Category", category?.asQueryValue)
                query.addQueryItem("StartDate", startDate?.asQueryValue)
                query.addQueryItem("EndDate", endDate?.asQueryValue)
                query.addQueryItem("IncludeSubaccounts", isIncludeSubaccounts?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Usage {
    public var records: Records {
        Records(path: path + "/Records")
    }

    public struct Records {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Usage/Records`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Usage.Records {
    public var allTimeJSON: AllTimeJSON {
        AllTimeJSON(path: path + "/AllTime.json")
    }

    public struct AllTimeJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Usage/Records/AllTime.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListUsageRecordAllTimeResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?
            public var usageRecords: [TwilioAPI.APIV2010AccountUsageUsageRecordUsageRecordAllTime]?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil, usageRecords: [TwilioAPI.APIV2010AccountUsageUsageRecordUsageRecordAllTime]? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
                self.usageRecords = usageRecords
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
                case usageRecords = "usage_records"
            }
        }

        public struct GetParameters {
            public var category: Category?
            public var startDate: NaiveDate?
            public var endDate: NaiveDate?
            public var isIncludeSubaccounts: Bool?
            public var pageSize: Int?

            public enum Category: String, Codable, CaseIterable {
                case agentConference = "agent-conference"
                case answeringMachineDetection = "answering-machine-detection"
                case authyAuthentications = "authy-authentications"
                case authyCallsOutbound = "authy-calls-outbound"
                case authyMonthlyFees = "authy-monthly-fees"
                case authyPhoneIntelligence = "authy-phone-intelligence"
                case authyPhoneVerifications = "authy-phone-verifications"
                case authySmsOutbound = "authy-sms-outbound"
                case callProgessEvents = "call-progess-events"
                case calleridlookups
                case calls
                case callsClient = "calls-client"
                case callsGlobalconference = "calls-globalconference"
                case callsInbound = "calls-inbound"
                case callsInboundLocal = "calls-inbound-local"
                case callsInboundMobile = "calls-inbound-mobile"
                case callsInboundTollfree = "calls-inbound-tollfree"
                case callsOutbound = "calls-outbound"
                case callsPayVerbTransactions = "calls-pay-verb-transactions"
                case callsRecordings = "calls-recordings"
                case callsSip = "calls-sip"
                case callsSipInbound = "calls-sip-inbound"
                case callsSipOutbound = "calls-sip-outbound"
                case callsTransfers = "calls-transfers"
                case carrierLookups = "carrier-lookups"
                case conversations
                case conversationsAPIRequests = "conversations-api-requests"
                case conversationsConversationEvents = "conversations-conversation-events"
                case conversationsEndpointConnectivity = "conversations-endpoint-connectivity"
                case conversationsEvents = "conversations-events"
                case conversationsParticipantEvents = "conversations-participant-events"
                case conversationsParticipants = "conversations-participants"
                case cps
                case flexUsage = "flex-usage"
                case fraudLookups = "fraud-lookups"
                case groupRooms = "group-rooms"
                case groupRoomsDataTrack = "group-rooms-data-track"
                case groupRoomsEncryptedMediaRecorded = "group-rooms-encrypted-media-recorded"
                case groupRoomsMediaDownloaded = "group-rooms-media-downloaded"
                case groupRoomsMediaRecorded = "group-rooms-media-recorded"
                case groupRoomsMediaRouted = "group-rooms-media-routed"
                case groupRoomsMediaStored = "group-rooms-media-stored"
                case groupRoomsParticipantMinutes = "group-rooms-participant-minutes"
                case groupRoomsRecordedMinutes = "group-rooms-recorded-minutes"
                case impV1Usage = "imp-v1-usage"
                case lookups
                case marketplace
                case marketplaceAlgorithmiaNamedEntityRecognition = "marketplace-algorithmia-named-entity-recognition"
                case marketplaceCadenceTranscription = "marketplace-cadence-transcription"
                case marketplaceCadenceTranslation = "marketplace-cadence-translation"
                case marketplaceCapioSpeechToText = "marketplace-capio-speech-to-text"
                case marketplaceConvrizaAbaba = "marketplace-convriza-ababa"
                case marketplaceDeepgramPhraseDetector = "marketplace-deepgram-phrase-detector"
                case marketplaceDigitalSegmentBusinessInfo = "marketplace-digital-segment-business-info"
                case marketplaceFacebookOfflineConversions = "marketplace-facebook-offline-conversions"
                case marketplaceGoogleSpeechToText = "marketplace-google-speech-to-text"
                case marketplaceIbmWatsonMessageInsights = "marketplace-ibm-watson-message-insights"
                case marketplaceIbmWatsonMessageSentiment = "marketplace-ibm-watson-message-sentiment"
                case marketplaceIbmWatsonRecordingAnalysis = "marketplace-ibm-watson-recording-analysis"
                case marketplaceIbmWatsonToneAnalyzer = "marketplace-ibm-watson-tone-analyzer"
                case marketplaceIcehookSystemsScout = "marketplace-icehook-systems-scout"
                case marketplaceInfogroupDataaxleBizinfo = "marketplace-infogroup-dataaxle-bizinfo"
                case marketplaceKeenIoContactCenterAnalytics = "marketplace-keen-io-contact-center-analytics"
                case marketplaceMarchexCleancall = "marketplace-marchex-cleancall"
                case marketplaceMarchexSentimentAnalysisForSms = "marketplace-marchex-sentiment-analysis-for-sms"
                case marketplaceMarketplaceNextcallerSocialID = "marketplace-marketplace-nextcaller-social-id"
                case marketplaceMobileCommonsOptOutClassifier = "marketplace-mobile-commons-opt-out-classifier"
                case marketplaceNexiwaveVoicemailToText = "marketplace-nexiwave-voicemail-to-text"
                case marketplaceNextcallerAdvancedCallerIdentification = "marketplace-nextcaller-advanced-caller-identification"
                case marketplaceNomoroboSpamScore = "marketplace-nomorobo-spam-score"
                case marketplacePayfoneTcpaCompliance = "marketplace-payfone-tcpa-compliance"
                case marketplaceRemeetingAutomaticSpeechRecognition = "marketplace-remeeting-automatic-speech-recognition"
                case marketplaceTcpaDefenseSolutionsBlacklistFeed = "marketplace-tcpa-defense-solutions-blacklist-feed"
                case marketplaceTeloOpencnam = "marketplace-telo-opencnam"
                case marketplaceTruecnamTrueSpam = "marketplace-truecnam-true-spam"
                case marketplaceTwilioCallerNameLookupUs = "marketplace-twilio-caller-name-lookup-us"
                case marketplaceTwilioCarrierInformationLookup = "marketplace-twilio-carrier-information-lookup"
                case marketplaceVoicebasePci = "marketplace-voicebase-pci"
                case marketplaceVoicebaseTranscription = "marketplace-voicebase-transcription"
                case marketplaceVoicebaseTranscriptionCustomVocabulary = "marketplace-voicebase-transcription-custom-vocabulary"
                case marketplaceWhitepagesProCallerIdentification = "marketplace-whitepages-pro-caller-identification"
                case marketplaceWhitepagesProPhoneIntelligence = "marketplace-whitepages-pro-phone-intelligence"
                case marketplaceWhitepagesProPhoneReputation = "marketplace-whitepages-pro-phone-reputation"
                case marketplaceWolfarmSpokenResults = "marketplace-wolfarm-spoken-results"
                case marketplaceWolframShortAnswer = "marketplace-wolfram-short-answer"
                case marketplaceYticaContactCenterReportingAnalytics = "marketplace-ytica-contact-center-reporting-analytics"
                case mediastorage
                case mms
                case mmsInbound = "mms-inbound"
                case mmsInboundLongcode = "mms-inbound-longcode"
                case mmsInboundShortcode = "mms-inbound-shortcode"
                case mmsMessagesCarrierfees = "mms-messages-carrierfees"
                case mmsOutbound = "mms-outbound"
                case mmsOutboundLongcode = "mms-outbound-longcode"
                case mmsOutboundShortcode = "mms-outbound-shortcode"
                case monitorReads = "monitor-reads"
                case monitorStorage = "monitor-storage"
                case monitorWrites = "monitor-writes"
                case notify
                case notifyActionsAttempts = "notify-actions-attempts"
                case notifyChannels = "notify-channels"
                case numberFormatLookups = "number-format-lookups"
                case pchat
                case pchatUsers = "pchat-users"
                case peerToPeerRoomsParticipantMinutes = "peer-to-peer-rooms-participant-minutes"
                case pfax
                case pfaxMinutes = "pfax-minutes"
                case pfaxMinutesInbound = "pfax-minutes-inbound"
                case pfaxMinutesOutbound = "pfax-minutes-outbound"
                case pfaxPages = "pfax-pages"
                case phonenumbers
                case phonenumbersCps = "phonenumbers-cps"
                case phonenumbersEmergency = "phonenumbers-emergency"
                case phonenumbersLocal = "phonenumbers-local"
                case phonenumbersMobile = "phonenumbers-mobile"
                case phonenumbersSetups = "phonenumbers-setups"
                case phonenumbersTollfree = "phonenumbers-tollfree"
                case premiumsupport
                case proxy
                case proxyActiveSessions = "proxy-active-sessions"
                case pstnconnectivity
                case pv
                case pvCompositionMediaDownloaded = "pv-composition-media-downloaded"
                case pvCompositionMediaEncrypted = "pv-composition-media-encrypted"
                case pvCompositionMediaStored = "pv-composition-media-stored"
                case pvCompositionMinutes = "pv-composition-minutes"
                case pvRecordingCompositions = "pv-recording-compositions"
                case pvRoomParticipants = "pv-room-participants"
                case pvRoomParticipantsAu1 = "pv-room-participants-au1"
                case pvRoomParticipantsBr1 = "pv-room-participants-br1"
                case pvRoomParticipantsIe1 = "pv-room-participants-ie1"
                case pvRoomParticipantsJp1 = "pv-room-participants-jp1"
                case pvRoomParticipantsSg1 = "pv-room-participants-sg1"
                case pvRoomParticipantsUs1 = "pv-room-participants-us1"
                case pvRoomParticipantsUs2 = "pv-room-participants-us2"
                case pvRooms = "pv-rooms"
                case pvSipEndpointRegistrations = "pv-sip-endpoint-registrations"
                case recordings
                case recordingstorage
                case roomsGroupBandwidth = "rooms-group-bandwidth"
                case roomsGroupMinutes = "rooms-group-minutes"
                case roomsPeerToPeerMinutes = "rooms-peer-to-peer-minutes"
                case shortcodes
                case shortcodesCustomerowned = "shortcodes-customerowned"
                case shortcodesMmsEnablement = "shortcodes-mms-enablement"
                case shortcodesMps = "shortcodes-mps"
                case shortcodesRandom = "shortcodes-random"
                case shortcodesUk = "shortcodes-uk"
                case shortcodesVanity = "shortcodes-vanity"
                case smallGroupRooms = "small-group-rooms"
                case smallGroupRoomsDataTrack = "small-group-rooms-data-track"
                case smallGroupRoomsParticipantMinutes = "small-group-rooms-participant-minutes"
                case sms
                case smsInbound = "sms-inbound"
                case smsInboundLongcode = "sms-inbound-longcode"
                case smsInboundShortcode = "sms-inbound-shortcode"
                case smsMessagesCarrierfees = "sms-messages-carrierfees"
                case smsMessagesFeatures = "sms-messages-features"
                case smsMessagesFeaturesSenderid = "sms-messages-features-senderid"
                case smsOutbound = "sms-outbound"
                case smsOutboundContentInspection = "sms-outbound-content-inspection"
                case smsOutboundLongcode = "sms-outbound-longcode"
                case smsOutboundShortcode = "sms-outbound-shortcode"
                case speechRecognition = "speech-recognition"
                case studioEngagements = "studio-engagements"
                case sync
                case syncActions = "sync-actions"
                case syncEndpointHours = "sync-endpoint-hours"
                case syncEndpointHoursAboveDailyCap = "sync-endpoint-hours-above-daily-cap"
                case taskrouterTasks = "taskrouter-tasks"
                case totalprice
                case transcriptions
                case trunkingCps = "trunking-cps"
                case trunkingEmergencyCalls = "trunking-emergency-calls"
                case trunkingOrigination = "trunking-origination"
                case trunkingOriginationLocal = "trunking-origination-local"
                case trunkingOriginationMobile = "trunking-origination-mobile"
                case trunkingOriginationTollfree = "trunking-origination-tollfree"
                case trunkingRecordings = "trunking-recordings"
                case trunkingSecure = "trunking-secure"
                case trunkingTermination = "trunking-termination"
                case turnmegabytes
                case turnmegabytesAustralia = "turnmegabytes-australia"
                case turnmegabytesBrasil = "turnmegabytes-brasil"
                case turnmegabytesGermany = "turnmegabytes-germany"
                case turnmegabytesIndia = "turnmegabytes-india"
                case turnmegabytesIreland = "turnmegabytes-ireland"
                case turnmegabytesJapan = "turnmegabytes-japan"
                case turnmegabytesSingapore = "turnmegabytes-singapore"
                case turnmegabytesUseast = "turnmegabytes-useast"
                case turnmegabytesUswest = "turnmegabytes-uswest"
                case twilioInterconnect = "twilio-interconnect"
                case verifyPush = "verify-push"
                case videoRecordings = "video-recordings"
                case voiceInsights = "voice-insights"
                case voiceInsightsClientInsightsOnDemandMinute = "voice-insights-client-insights-on-demand-minute"
                case voiceInsightsPtsnInsightsOnDemandMinute = "voice-insights-ptsn-insights-on-demand-minute"
                case voiceInsightsSipInterfaceInsightsOnDemandMinute = "voice-insights-sip-interface-insights-on-demand-minute"
                case voiceInsightsSipTrunkingInsightsOnDemandMinute = "voice-insights-sip-trunking-insights-on-demand-minute"
                case wireless
                case wirelessOrders = "wireless-orders"
                case wirelessOrdersArtwork = "wireless-orders-artwork"
                case wirelessOrdersBulk = "wireless-orders-bulk"
                case wirelessOrdersEsim = "wireless-orders-esim"
                case wirelessOrdersStarter = "wireless-orders-starter"
                case wirelessUsage = "wireless-usage"
                case wirelessUsageCommands = "wireless-usage-commands"
                case wirelessUsageCommandsAfrica = "wireless-usage-commands-africa"
                case wirelessUsageCommandsAsia = "wireless-usage-commands-asia"
                case wirelessUsageCommandsCentralandsouthamerica = "wireless-usage-commands-centralandsouthamerica"
                case wirelessUsageCommandsEurope = "wireless-usage-commands-europe"
                case wirelessUsageCommandsHome = "wireless-usage-commands-home"
                case wirelessUsageCommandsNorthamerica = "wireless-usage-commands-northamerica"
                case wirelessUsageCommandsOceania = "wireless-usage-commands-oceania"
                case wirelessUsageCommandsRoaming = "wireless-usage-commands-roaming"
                case wirelessUsageData = "wireless-usage-data"
                case wirelessUsageDataAfrica = "wireless-usage-data-africa"
                case wirelessUsageDataAsia = "wireless-usage-data-asia"
                case wirelessUsageDataCentralandsouthamerica = "wireless-usage-data-centralandsouthamerica"
                case wirelessUsageDataCustomAdditionalmb = "wireless-usage-data-custom-additionalmb"
                case wirelessUsageDataCustomFirst5mb = "wireless-usage-data-custom-first5mb"
                case wirelessUsageDataDomesticRoaming = "wireless-usage-data-domestic-roaming"
                case wirelessUsageDataEurope = "wireless-usage-data-europe"
                case wirelessUsageDataIndividualAdditionalgb = "wireless-usage-data-individual-additionalgb"
                case wirelessUsageDataIndividualFirstgb = "wireless-usage-data-individual-firstgb"
                case wirelessUsageDataInternationalRoamingCanada = "wireless-usage-data-international-roaming-canada"
                case wirelessUsageDataInternationalRoamingIndia = "wireless-usage-data-international-roaming-india"
                case wirelessUsageDataInternationalRoamingMexico = "wireless-usage-data-international-roaming-mexico"
                case wirelessUsageDataNorthamerica = "wireless-usage-data-northamerica"
                case wirelessUsageDataOceania = "wireless-usage-data-oceania"
                case wirelessUsageDataPooled = "wireless-usage-data-pooled"
                case wirelessUsageDataPooledDownlink = "wireless-usage-data-pooled-downlink"
                case wirelessUsageDataPooledUplink = "wireless-usage-data-pooled-uplink"
                case wirelessUsageMrc = "wireless-usage-mrc"
                case wirelessUsageMrcCustom = "wireless-usage-mrc-custom"
                case wirelessUsageMrcIndividual = "wireless-usage-mrc-individual"
                case wirelessUsageMrcPooled = "wireless-usage-mrc-pooled"
                case wirelessUsageMrcSuspended = "wireless-usage-mrc-suspended"
                case wirelessUsageSms = "wireless-usage-sms"
                case wirelessUsageVoice = "wireless-usage-voice"
            }

            public init(category: Category? = nil, startDate: NaiveDate? = nil, endDate: NaiveDate? = nil, isIncludeSubaccounts: Bool? = nil, pageSize: Int? = nil) {
                self.category = category
                self.startDate = startDate
                self.endDate = endDate
                self.isIncludeSubaccounts = isIncludeSubaccounts
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("Category", category?.asQueryValue)
                query.addQueryItem("StartDate", startDate?.asQueryValue)
                query.addQueryItem("EndDate", endDate?.asQueryValue)
                query.addQueryItem("IncludeSubaccounts", isIncludeSubaccounts?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Usage.Records {
    public var dailyJSON: DailyJSON {
        DailyJSON(path: path + "/Daily.json")
    }

    public struct DailyJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Usage/Records/Daily.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListUsageRecordDailyResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?
            public var usageRecords: [TwilioAPI.APIV2010AccountUsageUsageRecordUsageRecordDaily]?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil, usageRecords: [TwilioAPI.APIV2010AccountUsageUsageRecordUsageRecordDaily]? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
                self.usageRecords = usageRecords
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
                case usageRecords = "usage_records"
            }
        }

        public struct GetParameters {
            public var category: Category?
            public var startDate: NaiveDate?
            public var endDate: NaiveDate?
            public var isIncludeSubaccounts: Bool?
            public var pageSize: Int?

            public enum Category: String, Codable, CaseIterable {
                case agentConference = "agent-conference"
                case answeringMachineDetection = "answering-machine-detection"
                case authyAuthentications = "authy-authentications"
                case authyCallsOutbound = "authy-calls-outbound"
                case authyMonthlyFees = "authy-monthly-fees"
                case authyPhoneIntelligence = "authy-phone-intelligence"
                case authyPhoneVerifications = "authy-phone-verifications"
                case authySmsOutbound = "authy-sms-outbound"
                case callProgessEvents = "call-progess-events"
                case calleridlookups
                case calls
                case callsClient = "calls-client"
                case callsGlobalconference = "calls-globalconference"
                case callsInbound = "calls-inbound"
                case callsInboundLocal = "calls-inbound-local"
                case callsInboundMobile = "calls-inbound-mobile"
                case callsInboundTollfree = "calls-inbound-tollfree"
                case callsOutbound = "calls-outbound"
                case callsPayVerbTransactions = "calls-pay-verb-transactions"
                case callsRecordings = "calls-recordings"
                case callsSip = "calls-sip"
                case callsSipInbound = "calls-sip-inbound"
                case callsSipOutbound = "calls-sip-outbound"
                case callsTransfers = "calls-transfers"
                case carrierLookups = "carrier-lookups"
                case conversations
                case conversationsAPIRequests = "conversations-api-requests"
                case conversationsConversationEvents = "conversations-conversation-events"
                case conversationsEndpointConnectivity = "conversations-endpoint-connectivity"
                case conversationsEvents = "conversations-events"
                case conversationsParticipantEvents = "conversations-participant-events"
                case conversationsParticipants = "conversations-participants"
                case cps
                case flexUsage = "flex-usage"
                case fraudLookups = "fraud-lookups"
                case groupRooms = "group-rooms"
                case groupRoomsDataTrack = "group-rooms-data-track"
                case groupRoomsEncryptedMediaRecorded = "group-rooms-encrypted-media-recorded"
                case groupRoomsMediaDownloaded = "group-rooms-media-downloaded"
                case groupRoomsMediaRecorded = "group-rooms-media-recorded"
                case groupRoomsMediaRouted = "group-rooms-media-routed"
                case groupRoomsMediaStored = "group-rooms-media-stored"
                case groupRoomsParticipantMinutes = "group-rooms-participant-minutes"
                case groupRoomsRecordedMinutes = "group-rooms-recorded-minutes"
                case impV1Usage = "imp-v1-usage"
                case lookups
                case marketplace
                case marketplaceAlgorithmiaNamedEntityRecognition = "marketplace-algorithmia-named-entity-recognition"
                case marketplaceCadenceTranscription = "marketplace-cadence-transcription"
                case marketplaceCadenceTranslation = "marketplace-cadence-translation"
                case marketplaceCapioSpeechToText = "marketplace-capio-speech-to-text"
                case marketplaceConvrizaAbaba = "marketplace-convriza-ababa"
                case marketplaceDeepgramPhraseDetector = "marketplace-deepgram-phrase-detector"
                case marketplaceDigitalSegmentBusinessInfo = "marketplace-digital-segment-business-info"
                case marketplaceFacebookOfflineConversions = "marketplace-facebook-offline-conversions"
                case marketplaceGoogleSpeechToText = "marketplace-google-speech-to-text"
                case marketplaceIbmWatsonMessageInsights = "marketplace-ibm-watson-message-insights"
                case marketplaceIbmWatsonMessageSentiment = "marketplace-ibm-watson-message-sentiment"
                case marketplaceIbmWatsonRecordingAnalysis = "marketplace-ibm-watson-recording-analysis"
                case marketplaceIbmWatsonToneAnalyzer = "marketplace-ibm-watson-tone-analyzer"
                case marketplaceIcehookSystemsScout = "marketplace-icehook-systems-scout"
                case marketplaceInfogroupDataaxleBizinfo = "marketplace-infogroup-dataaxle-bizinfo"
                case marketplaceKeenIoContactCenterAnalytics = "marketplace-keen-io-contact-center-analytics"
                case marketplaceMarchexCleancall = "marketplace-marchex-cleancall"
                case marketplaceMarchexSentimentAnalysisForSms = "marketplace-marchex-sentiment-analysis-for-sms"
                case marketplaceMarketplaceNextcallerSocialID = "marketplace-marketplace-nextcaller-social-id"
                case marketplaceMobileCommonsOptOutClassifier = "marketplace-mobile-commons-opt-out-classifier"
                case marketplaceNexiwaveVoicemailToText = "marketplace-nexiwave-voicemail-to-text"
                case marketplaceNextcallerAdvancedCallerIdentification = "marketplace-nextcaller-advanced-caller-identification"
                case marketplaceNomoroboSpamScore = "marketplace-nomorobo-spam-score"
                case marketplacePayfoneTcpaCompliance = "marketplace-payfone-tcpa-compliance"
                case marketplaceRemeetingAutomaticSpeechRecognition = "marketplace-remeeting-automatic-speech-recognition"
                case marketplaceTcpaDefenseSolutionsBlacklistFeed = "marketplace-tcpa-defense-solutions-blacklist-feed"
                case marketplaceTeloOpencnam = "marketplace-telo-opencnam"
                case marketplaceTruecnamTrueSpam = "marketplace-truecnam-true-spam"
                case marketplaceTwilioCallerNameLookupUs = "marketplace-twilio-caller-name-lookup-us"
                case marketplaceTwilioCarrierInformationLookup = "marketplace-twilio-carrier-information-lookup"
                case marketplaceVoicebasePci = "marketplace-voicebase-pci"
                case marketplaceVoicebaseTranscription = "marketplace-voicebase-transcription"
                case marketplaceVoicebaseTranscriptionCustomVocabulary = "marketplace-voicebase-transcription-custom-vocabulary"
                case marketplaceWhitepagesProCallerIdentification = "marketplace-whitepages-pro-caller-identification"
                case marketplaceWhitepagesProPhoneIntelligence = "marketplace-whitepages-pro-phone-intelligence"
                case marketplaceWhitepagesProPhoneReputation = "marketplace-whitepages-pro-phone-reputation"
                case marketplaceWolfarmSpokenResults = "marketplace-wolfarm-spoken-results"
                case marketplaceWolframShortAnswer = "marketplace-wolfram-short-answer"
                case marketplaceYticaContactCenterReportingAnalytics = "marketplace-ytica-contact-center-reporting-analytics"
                case mediastorage
                case mms
                case mmsInbound = "mms-inbound"
                case mmsInboundLongcode = "mms-inbound-longcode"
                case mmsInboundShortcode = "mms-inbound-shortcode"
                case mmsMessagesCarrierfees = "mms-messages-carrierfees"
                case mmsOutbound = "mms-outbound"
                case mmsOutboundLongcode = "mms-outbound-longcode"
                case mmsOutboundShortcode = "mms-outbound-shortcode"
                case monitorReads = "monitor-reads"
                case monitorStorage = "monitor-storage"
                case monitorWrites = "monitor-writes"
                case notify
                case notifyActionsAttempts = "notify-actions-attempts"
                case notifyChannels = "notify-channels"
                case numberFormatLookups = "number-format-lookups"
                case pchat
                case pchatUsers = "pchat-users"
                case peerToPeerRoomsParticipantMinutes = "peer-to-peer-rooms-participant-minutes"
                case pfax
                case pfaxMinutes = "pfax-minutes"
                case pfaxMinutesInbound = "pfax-minutes-inbound"
                case pfaxMinutesOutbound = "pfax-minutes-outbound"
                case pfaxPages = "pfax-pages"
                case phonenumbers
                case phonenumbersCps = "phonenumbers-cps"
                case phonenumbersEmergency = "phonenumbers-emergency"
                case phonenumbersLocal = "phonenumbers-local"
                case phonenumbersMobile = "phonenumbers-mobile"
                case phonenumbersSetups = "phonenumbers-setups"
                case phonenumbersTollfree = "phonenumbers-tollfree"
                case premiumsupport
                case proxy
                case proxyActiveSessions = "proxy-active-sessions"
                case pstnconnectivity
                case pv
                case pvCompositionMediaDownloaded = "pv-composition-media-downloaded"
                case pvCompositionMediaEncrypted = "pv-composition-media-encrypted"
                case pvCompositionMediaStored = "pv-composition-media-stored"
                case pvCompositionMinutes = "pv-composition-minutes"
                case pvRecordingCompositions = "pv-recording-compositions"
                case pvRoomParticipants = "pv-room-participants"
                case pvRoomParticipantsAu1 = "pv-room-participants-au1"
                case pvRoomParticipantsBr1 = "pv-room-participants-br1"
                case pvRoomParticipantsIe1 = "pv-room-participants-ie1"
                case pvRoomParticipantsJp1 = "pv-room-participants-jp1"
                case pvRoomParticipantsSg1 = "pv-room-participants-sg1"
                case pvRoomParticipantsUs1 = "pv-room-participants-us1"
                case pvRoomParticipantsUs2 = "pv-room-participants-us2"
                case pvRooms = "pv-rooms"
                case pvSipEndpointRegistrations = "pv-sip-endpoint-registrations"
                case recordings
                case recordingstorage
                case roomsGroupBandwidth = "rooms-group-bandwidth"
                case roomsGroupMinutes = "rooms-group-minutes"
                case roomsPeerToPeerMinutes = "rooms-peer-to-peer-minutes"
                case shortcodes
                case shortcodesCustomerowned = "shortcodes-customerowned"
                case shortcodesMmsEnablement = "shortcodes-mms-enablement"
                case shortcodesMps = "shortcodes-mps"
                case shortcodesRandom = "shortcodes-random"
                case shortcodesUk = "shortcodes-uk"
                case shortcodesVanity = "shortcodes-vanity"
                case smallGroupRooms = "small-group-rooms"
                case smallGroupRoomsDataTrack = "small-group-rooms-data-track"
                case smallGroupRoomsParticipantMinutes = "small-group-rooms-participant-minutes"
                case sms
                case smsInbound = "sms-inbound"
                case smsInboundLongcode = "sms-inbound-longcode"
                case smsInboundShortcode = "sms-inbound-shortcode"
                case smsMessagesCarrierfees = "sms-messages-carrierfees"
                case smsMessagesFeatures = "sms-messages-features"
                case smsMessagesFeaturesSenderid = "sms-messages-features-senderid"
                case smsOutbound = "sms-outbound"
                case smsOutboundContentInspection = "sms-outbound-content-inspection"
                case smsOutboundLongcode = "sms-outbound-longcode"
                case smsOutboundShortcode = "sms-outbound-shortcode"
                case speechRecognition = "speech-recognition"
                case studioEngagements = "studio-engagements"
                case sync
                case syncActions = "sync-actions"
                case syncEndpointHours = "sync-endpoint-hours"
                case syncEndpointHoursAboveDailyCap = "sync-endpoint-hours-above-daily-cap"
                case taskrouterTasks = "taskrouter-tasks"
                case totalprice
                case transcriptions
                case trunkingCps = "trunking-cps"
                case trunkingEmergencyCalls = "trunking-emergency-calls"
                case trunkingOrigination = "trunking-origination"
                case trunkingOriginationLocal = "trunking-origination-local"
                case trunkingOriginationMobile = "trunking-origination-mobile"
                case trunkingOriginationTollfree = "trunking-origination-tollfree"
                case trunkingRecordings = "trunking-recordings"
                case trunkingSecure = "trunking-secure"
                case trunkingTermination = "trunking-termination"
                case turnmegabytes
                case turnmegabytesAustralia = "turnmegabytes-australia"
                case turnmegabytesBrasil = "turnmegabytes-brasil"
                case turnmegabytesGermany = "turnmegabytes-germany"
                case turnmegabytesIndia = "turnmegabytes-india"
                case turnmegabytesIreland = "turnmegabytes-ireland"
                case turnmegabytesJapan = "turnmegabytes-japan"
                case turnmegabytesSingapore = "turnmegabytes-singapore"
                case turnmegabytesUseast = "turnmegabytes-useast"
                case turnmegabytesUswest = "turnmegabytes-uswest"
                case twilioInterconnect = "twilio-interconnect"
                case verifyPush = "verify-push"
                case videoRecordings = "video-recordings"
                case voiceInsights = "voice-insights"
                case voiceInsightsClientInsightsOnDemandMinute = "voice-insights-client-insights-on-demand-minute"
                case voiceInsightsPtsnInsightsOnDemandMinute = "voice-insights-ptsn-insights-on-demand-minute"
                case voiceInsightsSipInterfaceInsightsOnDemandMinute = "voice-insights-sip-interface-insights-on-demand-minute"
                case voiceInsightsSipTrunkingInsightsOnDemandMinute = "voice-insights-sip-trunking-insights-on-demand-minute"
                case wireless
                case wirelessOrders = "wireless-orders"
                case wirelessOrdersArtwork = "wireless-orders-artwork"
                case wirelessOrdersBulk = "wireless-orders-bulk"
                case wirelessOrdersEsim = "wireless-orders-esim"
                case wirelessOrdersStarter = "wireless-orders-starter"
                case wirelessUsage = "wireless-usage"
                case wirelessUsageCommands = "wireless-usage-commands"
                case wirelessUsageCommandsAfrica = "wireless-usage-commands-africa"
                case wirelessUsageCommandsAsia = "wireless-usage-commands-asia"
                case wirelessUsageCommandsCentralandsouthamerica = "wireless-usage-commands-centralandsouthamerica"
                case wirelessUsageCommandsEurope = "wireless-usage-commands-europe"
                case wirelessUsageCommandsHome = "wireless-usage-commands-home"
                case wirelessUsageCommandsNorthamerica = "wireless-usage-commands-northamerica"
                case wirelessUsageCommandsOceania = "wireless-usage-commands-oceania"
                case wirelessUsageCommandsRoaming = "wireless-usage-commands-roaming"
                case wirelessUsageData = "wireless-usage-data"
                case wirelessUsageDataAfrica = "wireless-usage-data-africa"
                case wirelessUsageDataAsia = "wireless-usage-data-asia"
                case wirelessUsageDataCentralandsouthamerica = "wireless-usage-data-centralandsouthamerica"
                case wirelessUsageDataCustomAdditionalmb = "wireless-usage-data-custom-additionalmb"
                case wirelessUsageDataCustomFirst5mb = "wireless-usage-data-custom-first5mb"
                case wirelessUsageDataDomesticRoaming = "wireless-usage-data-domestic-roaming"
                case wirelessUsageDataEurope = "wireless-usage-data-europe"
                case wirelessUsageDataIndividualAdditionalgb = "wireless-usage-data-individual-additionalgb"
                case wirelessUsageDataIndividualFirstgb = "wireless-usage-data-individual-firstgb"
                case wirelessUsageDataInternationalRoamingCanada = "wireless-usage-data-international-roaming-canada"
                case wirelessUsageDataInternationalRoamingIndia = "wireless-usage-data-international-roaming-india"
                case wirelessUsageDataInternationalRoamingMexico = "wireless-usage-data-international-roaming-mexico"
                case wirelessUsageDataNorthamerica = "wireless-usage-data-northamerica"
                case wirelessUsageDataOceania = "wireless-usage-data-oceania"
                case wirelessUsageDataPooled = "wireless-usage-data-pooled"
                case wirelessUsageDataPooledDownlink = "wireless-usage-data-pooled-downlink"
                case wirelessUsageDataPooledUplink = "wireless-usage-data-pooled-uplink"
                case wirelessUsageMrc = "wireless-usage-mrc"
                case wirelessUsageMrcCustom = "wireless-usage-mrc-custom"
                case wirelessUsageMrcIndividual = "wireless-usage-mrc-individual"
                case wirelessUsageMrcPooled = "wireless-usage-mrc-pooled"
                case wirelessUsageMrcSuspended = "wireless-usage-mrc-suspended"
                case wirelessUsageSms = "wireless-usage-sms"
                case wirelessUsageVoice = "wireless-usage-voice"
            }

            public init(category: Category? = nil, startDate: NaiveDate? = nil, endDate: NaiveDate? = nil, isIncludeSubaccounts: Bool? = nil, pageSize: Int? = nil) {
                self.category = category
                self.startDate = startDate
                self.endDate = endDate
                self.isIncludeSubaccounts = isIncludeSubaccounts
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("Category", category?.asQueryValue)
                query.addQueryItem("StartDate", startDate?.asQueryValue)
                query.addQueryItem("EndDate", endDate?.asQueryValue)
                query.addQueryItem("IncludeSubaccounts", isIncludeSubaccounts?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Usage.Records {
    public var lastMonthJSON: LastMonthJSON {
        LastMonthJSON(path: path + "/LastMonth.json")
    }

    public struct LastMonthJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Usage/Records/LastMonth.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListUsageRecordLastMonthResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?
            public var usageRecords: [TwilioAPI.APIV2010AccountUsageUsageRecordUsageRecordLastMonth]?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil, usageRecords: [TwilioAPI.APIV2010AccountUsageUsageRecordUsageRecordLastMonth]? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
                self.usageRecords = usageRecords
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
                case usageRecords = "usage_records"
            }
        }

        public struct GetParameters {
            public var category: Category?
            public var startDate: NaiveDate?
            public var endDate: NaiveDate?
            public var isIncludeSubaccounts: Bool?
            public var pageSize: Int?

            public enum Category: String, Codable, CaseIterable {
                case agentConference = "agent-conference"
                case answeringMachineDetection = "answering-machine-detection"
                case authyAuthentications = "authy-authentications"
                case authyCallsOutbound = "authy-calls-outbound"
                case authyMonthlyFees = "authy-monthly-fees"
                case authyPhoneIntelligence = "authy-phone-intelligence"
                case authyPhoneVerifications = "authy-phone-verifications"
                case authySmsOutbound = "authy-sms-outbound"
                case callProgessEvents = "call-progess-events"
                case calleridlookups
                case calls
                case callsClient = "calls-client"
                case callsGlobalconference = "calls-globalconference"
                case callsInbound = "calls-inbound"
                case callsInboundLocal = "calls-inbound-local"
                case callsInboundMobile = "calls-inbound-mobile"
                case callsInboundTollfree = "calls-inbound-tollfree"
                case callsOutbound = "calls-outbound"
                case callsPayVerbTransactions = "calls-pay-verb-transactions"
                case callsRecordings = "calls-recordings"
                case callsSip = "calls-sip"
                case callsSipInbound = "calls-sip-inbound"
                case callsSipOutbound = "calls-sip-outbound"
                case callsTransfers = "calls-transfers"
                case carrierLookups = "carrier-lookups"
                case conversations
                case conversationsAPIRequests = "conversations-api-requests"
                case conversationsConversationEvents = "conversations-conversation-events"
                case conversationsEndpointConnectivity = "conversations-endpoint-connectivity"
                case conversationsEvents = "conversations-events"
                case conversationsParticipantEvents = "conversations-participant-events"
                case conversationsParticipants = "conversations-participants"
                case cps
                case flexUsage = "flex-usage"
                case fraudLookups = "fraud-lookups"
                case groupRooms = "group-rooms"
                case groupRoomsDataTrack = "group-rooms-data-track"
                case groupRoomsEncryptedMediaRecorded = "group-rooms-encrypted-media-recorded"
                case groupRoomsMediaDownloaded = "group-rooms-media-downloaded"
                case groupRoomsMediaRecorded = "group-rooms-media-recorded"
                case groupRoomsMediaRouted = "group-rooms-media-routed"
                case groupRoomsMediaStored = "group-rooms-media-stored"
                case groupRoomsParticipantMinutes = "group-rooms-participant-minutes"
                case groupRoomsRecordedMinutes = "group-rooms-recorded-minutes"
                case impV1Usage = "imp-v1-usage"
                case lookups
                case marketplace
                case marketplaceAlgorithmiaNamedEntityRecognition = "marketplace-algorithmia-named-entity-recognition"
                case marketplaceCadenceTranscription = "marketplace-cadence-transcription"
                case marketplaceCadenceTranslation = "marketplace-cadence-translation"
                case marketplaceCapioSpeechToText = "marketplace-capio-speech-to-text"
                case marketplaceConvrizaAbaba = "marketplace-convriza-ababa"
                case marketplaceDeepgramPhraseDetector = "marketplace-deepgram-phrase-detector"
                case marketplaceDigitalSegmentBusinessInfo = "marketplace-digital-segment-business-info"
                case marketplaceFacebookOfflineConversions = "marketplace-facebook-offline-conversions"
                case marketplaceGoogleSpeechToText = "marketplace-google-speech-to-text"
                case marketplaceIbmWatsonMessageInsights = "marketplace-ibm-watson-message-insights"
                case marketplaceIbmWatsonMessageSentiment = "marketplace-ibm-watson-message-sentiment"
                case marketplaceIbmWatsonRecordingAnalysis = "marketplace-ibm-watson-recording-analysis"
                case marketplaceIbmWatsonToneAnalyzer = "marketplace-ibm-watson-tone-analyzer"
                case marketplaceIcehookSystemsScout = "marketplace-icehook-systems-scout"
                case marketplaceInfogroupDataaxleBizinfo = "marketplace-infogroup-dataaxle-bizinfo"
                case marketplaceKeenIoContactCenterAnalytics = "marketplace-keen-io-contact-center-analytics"
                case marketplaceMarchexCleancall = "marketplace-marchex-cleancall"
                case marketplaceMarchexSentimentAnalysisForSms = "marketplace-marchex-sentiment-analysis-for-sms"
                case marketplaceMarketplaceNextcallerSocialID = "marketplace-marketplace-nextcaller-social-id"
                case marketplaceMobileCommonsOptOutClassifier = "marketplace-mobile-commons-opt-out-classifier"
                case marketplaceNexiwaveVoicemailToText = "marketplace-nexiwave-voicemail-to-text"
                case marketplaceNextcallerAdvancedCallerIdentification = "marketplace-nextcaller-advanced-caller-identification"
                case marketplaceNomoroboSpamScore = "marketplace-nomorobo-spam-score"
                case marketplacePayfoneTcpaCompliance = "marketplace-payfone-tcpa-compliance"
                case marketplaceRemeetingAutomaticSpeechRecognition = "marketplace-remeeting-automatic-speech-recognition"
                case marketplaceTcpaDefenseSolutionsBlacklistFeed = "marketplace-tcpa-defense-solutions-blacklist-feed"
                case marketplaceTeloOpencnam = "marketplace-telo-opencnam"
                case marketplaceTruecnamTrueSpam = "marketplace-truecnam-true-spam"
                case marketplaceTwilioCallerNameLookupUs = "marketplace-twilio-caller-name-lookup-us"
                case marketplaceTwilioCarrierInformationLookup = "marketplace-twilio-carrier-information-lookup"
                case marketplaceVoicebasePci = "marketplace-voicebase-pci"
                case marketplaceVoicebaseTranscription = "marketplace-voicebase-transcription"
                case marketplaceVoicebaseTranscriptionCustomVocabulary = "marketplace-voicebase-transcription-custom-vocabulary"
                case marketplaceWhitepagesProCallerIdentification = "marketplace-whitepages-pro-caller-identification"
                case marketplaceWhitepagesProPhoneIntelligence = "marketplace-whitepages-pro-phone-intelligence"
                case marketplaceWhitepagesProPhoneReputation = "marketplace-whitepages-pro-phone-reputation"
                case marketplaceWolfarmSpokenResults = "marketplace-wolfarm-spoken-results"
                case marketplaceWolframShortAnswer = "marketplace-wolfram-short-answer"
                case marketplaceYticaContactCenterReportingAnalytics = "marketplace-ytica-contact-center-reporting-analytics"
                case mediastorage
                case mms
                case mmsInbound = "mms-inbound"
                case mmsInboundLongcode = "mms-inbound-longcode"
                case mmsInboundShortcode = "mms-inbound-shortcode"
                case mmsMessagesCarrierfees = "mms-messages-carrierfees"
                case mmsOutbound = "mms-outbound"
                case mmsOutboundLongcode = "mms-outbound-longcode"
                case mmsOutboundShortcode = "mms-outbound-shortcode"
                case monitorReads = "monitor-reads"
                case monitorStorage = "monitor-storage"
                case monitorWrites = "monitor-writes"
                case notify
                case notifyActionsAttempts = "notify-actions-attempts"
                case notifyChannels = "notify-channels"
                case numberFormatLookups = "number-format-lookups"
                case pchat
                case pchatUsers = "pchat-users"
                case peerToPeerRoomsParticipantMinutes = "peer-to-peer-rooms-participant-minutes"
                case pfax
                case pfaxMinutes = "pfax-minutes"
                case pfaxMinutesInbound = "pfax-minutes-inbound"
                case pfaxMinutesOutbound = "pfax-minutes-outbound"
                case pfaxPages = "pfax-pages"
                case phonenumbers
                case phonenumbersCps = "phonenumbers-cps"
                case phonenumbersEmergency = "phonenumbers-emergency"
                case phonenumbersLocal = "phonenumbers-local"
                case phonenumbersMobile = "phonenumbers-mobile"
                case phonenumbersSetups = "phonenumbers-setups"
                case phonenumbersTollfree = "phonenumbers-tollfree"
                case premiumsupport
                case proxy
                case proxyActiveSessions = "proxy-active-sessions"
                case pstnconnectivity
                case pv
                case pvCompositionMediaDownloaded = "pv-composition-media-downloaded"
                case pvCompositionMediaEncrypted = "pv-composition-media-encrypted"
                case pvCompositionMediaStored = "pv-composition-media-stored"
                case pvCompositionMinutes = "pv-composition-minutes"
                case pvRecordingCompositions = "pv-recording-compositions"
                case pvRoomParticipants = "pv-room-participants"
                case pvRoomParticipantsAu1 = "pv-room-participants-au1"
                case pvRoomParticipantsBr1 = "pv-room-participants-br1"
                case pvRoomParticipantsIe1 = "pv-room-participants-ie1"
                case pvRoomParticipantsJp1 = "pv-room-participants-jp1"
                case pvRoomParticipantsSg1 = "pv-room-participants-sg1"
                case pvRoomParticipantsUs1 = "pv-room-participants-us1"
                case pvRoomParticipantsUs2 = "pv-room-participants-us2"
                case pvRooms = "pv-rooms"
                case pvSipEndpointRegistrations = "pv-sip-endpoint-registrations"
                case recordings
                case recordingstorage
                case roomsGroupBandwidth = "rooms-group-bandwidth"
                case roomsGroupMinutes = "rooms-group-minutes"
                case roomsPeerToPeerMinutes = "rooms-peer-to-peer-minutes"
                case shortcodes
                case shortcodesCustomerowned = "shortcodes-customerowned"
                case shortcodesMmsEnablement = "shortcodes-mms-enablement"
                case shortcodesMps = "shortcodes-mps"
                case shortcodesRandom = "shortcodes-random"
                case shortcodesUk = "shortcodes-uk"
                case shortcodesVanity = "shortcodes-vanity"
                case smallGroupRooms = "small-group-rooms"
                case smallGroupRoomsDataTrack = "small-group-rooms-data-track"
                case smallGroupRoomsParticipantMinutes = "small-group-rooms-participant-minutes"
                case sms
                case smsInbound = "sms-inbound"
                case smsInboundLongcode = "sms-inbound-longcode"
                case smsInboundShortcode = "sms-inbound-shortcode"
                case smsMessagesCarrierfees = "sms-messages-carrierfees"
                case smsMessagesFeatures = "sms-messages-features"
                case smsMessagesFeaturesSenderid = "sms-messages-features-senderid"
                case smsOutbound = "sms-outbound"
                case smsOutboundContentInspection = "sms-outbound-content-inspection"
                case smsOutboundLongcode = "sms-outbound-longcode"
                case smsOutboundShortcode = "sms-outbound-shortcode"
                case speechRecognition = "speech-recognition"
                case studioEngagements = "studio-engagements"
                case sync
                case syncActions = "sync-actions"
                case syncEndpointHours = "sync-endpoint-hours"
                case syncEndpointHoursAboveDailyCap = "sync-endpoint-hours-above-daily-cap"
                case taskrouterTasks = "taskrouter-tasks"
                case totalprice
                case transcriptions
                case trunkingCps = "trunking-cps"
                case trunkingEmergencyCalls = "trunking-emergency-calls"
                case trunkingOrigination = "trunking-origination"
                case trunkingOriginationLocal = "trunking-origination-local"
                case trunkingOriginationMobile = "trunking-origination-mobile"
                case trunkingOriginationTollfree = "trunking-origination-tollfree"
                case trunkingRecordings = "trunking-recordings"
                case trunkingSecure = "trunking-secure"
                case trunkingTermination = "trunking-termination"
                case turnmegabytes
                case turnmegabytesAustralia = "turnmegabytes-australia"
                case turnmegabytesBrasil = "turnmegabytes-brasil"
                case turnmegabytesGermany = "turnmegabytes-germany"
                case turnmegabytesIndia = "turnmegabytes-india"
                case turnmegabytesIreland = "turnmegabytes-ireland"
                case turnmegabytesJapan = "turnmegabytes-japan"
                case turnmegabytesSingapore = "turnmegabytes-singapore"
                case turnmegabytesUseast = "turnmegabytes-useast"
                case turnmegabytesUswest = "turnmegabytes-uswest"
                case twilioInterconnect = "twilio-interconnect"
                case verifyPush = "verify-push"
                case videoRecordings = "video-recordings"
                case voiceInsights = "voice-insights"
                case voiceInsightsClientInsightsOnDemandMinute = "voice-insights-client-insights-on-demand-minute"
                case voiceInsightsPtsnInsightsOnDemandMinute = "voice-insights-ptsn-insights-on-demand-minute"
                case voiceInsightsSipInterfaceInsightsOnDemandMinute = "voice-insights-sip-interface-insights-on-demand-minute"
                case voiceInsightsSipTrunkingInsightsOnDemandMinute = "voice-insights-sip-trunking-insights-on-demand-minute"
                case wireless
                case wirelessOrders = "wireless-orders"
                case wirelessOrdersArtwork = "wireless-orders-artwork"
                case wirelessOrdersBulk = "wireless-orders-bulk"
                case wirelessOrdersEsim = "wireless-orders-esim"
                case wirelessOrdersStarter = "wireless-orders-starter"
                case wirelessUsage = "wireless-usage"
                case wirelessUsageCommands = "wireless-usage-commands"
                case wirelessUsageCommandsAfrica = "wireless-usage-commands-africa"
                case wirelessUsageCommandsAsia = "wireless-usage-commands-asia"
                case wirelessUsageCommandsCentralandsouthamerica = "wireless-usage-commands-centralandsouthamerica"
                case wirelessUsageCommandsEurope = "wireless-usage-commands-europe"
                case wirelessUsageCommandsHome = "wireless-usage-commands-home"
                case wirelessUsageCommandsNorthamerica = "wireless-usage-commands-northamerica"
                case wirelessUsageCommandsOceania = "wireless-usage-commands-oceania"
                case wirelessUsageCommandsRoaming = "wireless-usage-commands-roaming"
                case wirelessUsageData = "wireless-usage-data"
                case wirelessUsageDataAfrica = "wireless-usage-data-africa"
                case wirelessUsageDataAsia = "wireless-usage-data-asia"
                case wirelessUsageDataCentralandsouthamerica = "wireless-usage-data-centralandsouthamerica"
                case wirelessUsageDataCustomAdditionalmb = "wireless-usage-data-custom-additionalmb"
                case wirelessUsageDataCustomFirst5mb = "wireless-usage-data-custom-first5mb"
                case wirelessUsageDataDomesticRoaming = "wireless-usage-data-domestic-roaming"
                case wirelessUsageDataEurope = "wireless-usage-data-europe"
                case wirelessUsageDataIndividualAdditionalgb = "wireless-usage-data-individual-additionalgb"
                case wirelessUsageDataIndividualFirstgb = "wireless-usage-data-individual-firstgb"
                case wirelessUsageDataInternationalRoamingCanada = "wireless-usage-data-international-roaming-canada"
                case wirelessUsageDataInternationalRoamingIndia = "wireless-usage-data-international-roaming-india"
                case wirelessUsageDataInternationalRoamingMexico = "wireless-usage-data-international-roaming-mexico"
                case wirelessUsageDataNorthamerica = "wireless-usage-data-northamerica"
                case wirelessUsageDataOceania = "wireless-usage-data-oceania"
                case wirelessUsageDataPooled = "wireless-usage-data-pooled"
                case wirelessUsageDataPooledDownlink = "wireless-usage-data-pooled-downlink"
                case wirelessUsageDataPooledUplink = "wireless-usage-data-pooled-uplink"
                case wirelessUsageMrc = "wireless-usage-mrc"
                case wirelessUsageMrcCustom = "wireless-usage-mrc-custom"
                case wirelessUsageMrcIndividual = "wireless-usage-mrc-individual"
                case wirelessUsageMrcPooled = "wireless-usage-mrc-pooled"
                case wirelessUsageMrcSuspended = "wireless-usage-mrc-suspended"
                case wirelessUsageSms = "wireless-usage-sms"
                case wirelessUsageVoice = "wireless-usage-voice"
            }

            public init(category: Category? = nil, startDate: NaiveDate? = nil, endDate: NaiveDate? = nil, isIncludeSubaccounts: Bool? = nil, pageSize: Int? = nil) {
                self.category = category
                self.startDate = startDate
                self.endDate = endDate
                self.isIncludeSubaccounts = isIncludeSubaccounts
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("Category", category?.asQueryValue)
                query.addQueryItem("StartDate", startDate?.asQueryValue)
                query.addQueryItem("EndDate", endDate?.asQueryValue)
                query.addQueryItem("IncludeSubaccounts", isIncludeSubaccounts?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Usage.Records {
    public var monthlyJSON: MonthlyJSON {
        MonthlyJSON(path: path + "/Monthly.json")
    }

    public struct MonthlyJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Usage/Records/Monthly.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListUsageRecordMonthlyResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?
            public var usageRecords: [TwilioAPI.APIV2010AccountUsageUsageRecordUsageRecordMonthly]?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil, usageRecords: [TwilioAPI.APIV2010AccountUsageUsageRecordUsageRecordMonthly]? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
                self.usageRecords = usageRecords
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
                case usageRecords = "usage_records"
            }
        }

        public struct GetParameters {
            public var category: Category?
            public var startDate: NaiveDate?
            public var endDate: NaiveDate?
            public var isIncludeSubaccounts: Bool?
            public var pageSize: Int?

            public enum Category: String, Codable, CaseIterable {
                case agentConference = "agent-conference"
                case answeringMachineDetection = "answering-machine-detection"
                case authyAuthentications = "authy-authentications"
                case authyCallsOutbound = "authy-calls-outbound"
                case authyMonthlyFees = "authy-monthly-fees"
                case authyPhoneIntelligence = "authy-phone-intelligence"
                case authyPhoneVerifications = "authy-phone-verifications"
                case authySmsOutbound = "authy-sms-outbound"
                case callProgessEvents = "call-progess-events"
                case calleridlookups
                case calls
                case callsClient = "calls-client"
                case callsGlobalconference = "calls-globalconference"
                case callsInbound = "calls-inbound"
                case callsInboundLocal = "calls-inbound-local"
                case callsInboundMobile = "calls-inbound-mobile"
                case callsInboundTollfree = "calls-inbound-tollfree"
                case callsOutbound = "calls-outbound"
                case callsPayVerbTransactions = "calls-pay-verb-transactions"
                case callsRecordings = "calls-recordings"
                case callsSip = "calls-sip"
                case callsSipInbound = "calls-sip-inbound"
                case callsSipOutbound = "calls-sip-outbound"
                case callsTransfers = "calls-transfers"
                case carrierLookups = "carrier-lookups"
                case conversations
                case conversationsAPIRequests = "conversations-api-requests"
                case conversationsConversationEvents = "conversations-conversation-events"
                case conversationsEndpointConnectivity = "conversations-endpoint-connectivity"
                case conversationsEvents = "conversations-events"
                case conversationsParticipantEvents = "conversations-participant-events"
                case conversationsParticipants = "conversations-participants"
                case cps
                case flexUsage = "flex-usage"
                case fraudLookups = "fraud-lookups"
                case groupRooms = "group-rooms"
                case groupRoomsDataTrack = "group-rooms-data-track"
                case groupRoomsEncryptedMediaRecorded = "group-rooms-encrypted-media-recorded"
                case groupRoomsMediaDownloaded = "group-rooms-media-downloaded"
                case groupRoomsMediaRecorded = "group-rooms-media-recorded"
                case groupRoomsMediaRouted = "group-rooms-media-routed"
                case groupRoomsMediaStored = "group-rooms-media-stored"
                case groupRoomsParticipantMinutes = "group-rooms-participant-minutes"
                case groupRoomsRecordedMinutes = "group-rooms-recorded-minutes"
                case impV1Usage = "imp-v1-usage"
                case lookups
                case marketplace
                case marketplaceAlgorithmiaNamedEntityRecognition = "marketplace-algorithmia-named-entity-recognition"
                case marketplaceCadenceTranscription = "marketplace-cadence-transcription"
                case marketplaceCadenceTranslation = "marketplace-cadence-translation"
                case marketplaceCapioSpeechToText = "marketplace-capio-speech-to-text"
                case marketplaceConvrizaAbaba = "marketplace-convriza-ababa"
                case marketplaceDeepgramPhraseDetector = "marketplace-deepgram-phrase-detector"
                case marketplaceDigitalSegmentBusinessInfo = "marketplace-digital-segment-business-info"
                case marketplaceFacebookOfflineConversions = "marketplace-facebook-offline-conversions"
                case marketplaceGoogleSpeechToText = "marketplace-google-speech-to-text"
                case marketplaceIbmWatsonMessageInsights = "marketplace-ibm-watson-message-insights"
                case marketplaceIbmWatsonMessageSentiment = "marketplace-ibm-watson-message-sentiment"
                case marketplaceIbmWatsonRecordingAnalysis = "marketplace-ibm-watson-recording-analysis"
                case marketplaceIbmWatsonToneAnalyzer = "marketplace-ibm-watson-tone-analyzer"
                case marketplaceIcehookSystemsScout = "marketplace-icehook-systems-scout"
                case marketplaceInfogroupDataaxleBizinfo = "marketplace-infogroup-dataaxle-bizinfo"
                case marketplaceKeenIoContactCenterAnalytics = "marketplace-keen-io-contact-center-analytics"
                case marketplaceMarchexCleancall = "marketplace-marchex-cleancall"
                case marketplaceMarchexSentimentAnalysisForSms = "marketplace-marchex-sentiment-analysis-for-sms"
                case marketplaceMarketplaceNextcallerSocialID = "marketplace-marketplace-nextcaller-social-id"
                case marketplaceMobileCommonsOptOutClassifier = "marketplace-mobile-commons-opt-out-classifier"
                case marketplaceNexiwaveVoicemailToText = "marketplace-nexiwave-voicemail-to-text"
                case marketplaceNextcallerAdvancedCallerIdentification = "marketplace-nextcaller-advanced-caller-identification"
                case marketplaceNomoroboSpamScore = "marketplace-nomorobo-spam-score"
                case marketplacePayfoneTcpaCompliance = "marketplace-payfone-tcpa-compliance"
                case marketplaceRemeetingAutomaticSpeechRecognition = "marketplace-remeeting-automatic-speech-recognition"
                case marketplaceTcpaDefenseSolutionsBlacklistFeed = "marketplace-tcpa-defense-solutions-blacklist-feed"
                case marketplaceTeloOpencnam = "marketplace-telo-opencnam"
                case marketplaceTruecnamTrueSpam = "marketplace-truecnam-true-spam"
                case marketplaceTwilioCallerNameLookupUs = "marketplace-twilio-caller-name-lookup-us"
                case marketplaceTwilioCarrierInformationLookup = "marketplace-twilio-carrier-information-lookup"
                case marketplaceVoicebasePci = "marketplace-voicebase-pci"
                case marketplaceVoicebaseTranscription = "marketplace-voicebase-transcription"
                case marketplaceVoicebaseTranscriptionCustomVocabulary = "marketplace-voicebase-transcription-custom-vocabulary"
                case marketplaceWhitepagesProCallerIdentification = "marketplace-whitepages-pro-caller-identification"
                case marketplaceWhitepagesProPhoneIntelligence = "marketplace-whitepages-pro-phone-intelligence"
                case marketplaceWhitepagesProPhoneReputation = "marketplace-whitepages-pro-phone-reputation"
                case marketplaceWolfarmSpokenResults = "marketplace-wolfarm-spoken-results"
                case marketplaceWolframShortAnswer = "marketplace-wolfram-short-answer"
                case marketplaceYticaContactCenterReportingAnalytics = "marketplace-ytica-contact-center-reporting-analytics"
                case mediastorage
                case mms
                case mmsInbound = "mms-inbound"
                case mmsInboundLongcode = "mms-inbound-longcode"
                case mmsInboundShortcode = "mms-inbound-shortcode"
                case mmsMessagesCarrierfees = "mms-messages-carrierfees"
                case mmsOutbound = "mms-outbound"
                case mmsOutboundLongcode = "mms-outbound-longcode"
                case mmsOutboundShortcode = "mms-outbound-shortcode"
                case monitorReads = "monitor-reads"
                case monitorStorage = "monitor-storage"
                case monitorWrites = "monitor-writes"
                case notify
                case notifyActionsAttempts = "notify-actions-attempts"
                case notifyChannels = "notify-channels"
                case numberFormatLookups = "number-format-lookups"
                case pchat
                case pchatUsers = "pchat-users"
                case peerToPeerRoomsParticipantMinutes = "peer-to-peer-rooms-participant-minutes"
                case pfax
                case pfaxMinutes = "pfax-minutes"
                case pfaxMinutesInbound = "pfax-minutes-inbound"
                case pfaxMinutesOutbound = "pfax-minutes-outbound"
                case pfaxPages = "pfax-pages"
                case phonenumbers
                case phonenumbersCps = "phonenumbers-cps"
                case phonenumbersEmergency = "phonenumbers-emergency"
                case phonenumbersLocal = "phonenumbers-local"
                case phonenumbersMobile = "phonenumbers-mobile"
                case phonenumbersSetups = "phonenumbers-setups"
                case phonenumbersTollfree = "phonenumbers-tollfree"
                case premiumsupport
                case proxy
                case proxyActiveSessions = "proxy-active-sessions"
                case pstnconnectivity
                case pv
                case pvCompositionMediaDownloaded = "pv-composition-media-downloaded"
                case pvCompositionMediaEncrypted = "pv-composition-media-encrypted"
                case pvCompositionMediaStored = "pv-composition-media-stored"
                case pvCompositionMinutes = "pv-composition-minutes"
                case pvRecordingCompositions = "pv-recording-compositions"
                case pvRoomParticipants = "pv-room-participants"
                case pvRoomParticipantsAu1 = "pv-room-participants-au1"
                case pvRoomParticipantsBr1 = "pv-room-participants-br1"
                case pvRoomParticipantsIe1 = "pv-room-participants-ie1"
                case pvRoomParticipantsJp1 = "pv-room-participants-jp1"
                case pvRoomParticipantsSg1 = "pv-room-participants-sg1"
                case pvRoomParticipantsUs1 = "pv-room-participants-us1"
                case pvRoomParticipantsUs2 = "pv-room-participants-us2"
                case pvRooms = "pv-rooms"
                case pvSipEndpointRegistrations = "pv-sip-endpoint-registrations"
                case recordings
                case recordingstorage
                case roomsGroupBandwidth = "rooms-group-bandwidth"
                case roomsGroupMinutes = "rooms-group-minutes"
                case roomsPeerToPeerMinutes = "rooms-peer-to-peer-minutes"
                case shortcodes
                case shortcodesCustomerowned = "shortcodes-customerowned"
                case shortcodesMmsEnablement = "shortcodes-mms-enablement"
                case shortcodesMps = "shortcodes-mps"
                case shortcodesRandom = "shortcodes-random"
                case shortcodesUk = "shortcodes-uk"
                case shortcodesVanity = "shortcodes-vanity"
                case smallGroupRooms = "small-group-rooms"
                case smallGroupRoomsDataTrack = "small-group-rooms-data-track"
                case smallGroupRoomsParticipantMinutes = "small-group-rooms-participant-minutes"
                case sms
                case smsInbound = "sms-inbound"
                case smsInboundLongcode = "sms-inbound-longcode"
                case smsInboundShortcode = "sms-inbound-shortcode"
                case smsMessagesCarrierfees = "sms-messages-carrierfees"
                case smsMessagesFeatures = "sms-messages-features"
                case smsMessagesFeaturesSenderid = "sms-messages-features-senderid"
                case smsOutbound = "sms-outbound"
                case smsOutboundContentInspection = "sms-outbound-content-inspection"
                case smsOutboundLongcode = "sms-outbound-longcode"
                case smsOutboundShortcode = "sms-outbound-shortcode"
                case speechRecognition = "speech-recognition"
                case studioEngagements = "studio-engagements"
                case sync
                case syncActions = "sync-actions"
                case syncEndpointHours = "sync-endpoint-hours"
                case syncEndpointHoursAboveDailyCap = "sync-endpoint-hours-above-daily-cap"
                case taskrouterTasks = "taskrouter-tasks"
                case totalprice
                case transcriptions
                case trunkingCps = "trunking-cps"
                case trunkingEmergencyCalls = "trunking-emergency-calls"
                case trunkingOrigination = "trunking-origination"
                case trunkingOriginationLocal = "trunking-origination-local"
                case trunkingOriginationMobile = "trunking-origination-mobile"
                case trunkingOriginationTollfree = "trunking-origination-tollfree"
                case trunkingRecordings = "trunking-recordings"
                case trunkingSecure = "trunking-secure"
                case trunkingTermination = "trunking-termination"
                case turnmegabytes
                case turnmegabytesAustralia = "turnmegabytes-australia"
                case turnmegabytesBrasil = "turnmegabytes-brasil"
                case turnmegabytesGermany = "turnmegabytes-germany"
                case turnmegabytesIndia = "turnmegabytes-india"
                case turnmegabytesIreland = "turnmegabytes-ireland"
                case turnmegabytesJapan = "turnmegabytes-japan"
                case turnmegabytesSingapore = "turnmegabytes-singapore"
                case turnmegabytesUseast = "turnmegabytes-useast"
                case turnmegabytesUswest = "turnmegabytes-uswest"
                case twilioInterconnect = "twilio-interconnect"
                case verifyPush = "verify-push"
                case videoRecordings = "video-recordings"
                case voiceInsights = "voice-insights"
                case voiceInsightsClientInsightsOnDemandMinute = "voice-insights-client-insights-on-demand-minute"
                case voiceInsightsPtsnInsightsOnDemandMinute = "voice-insights-ptsn-insights-on-demand-minute"
                case voiceInsightsSipInterfaceInsightsOnDemandMinute = "voice-insights-sip-interface-insights-on-demand-minute"
                case voiceInsightsSipTrunkingInsightsOnDemandMinute = "voice-insights-sip-trunking-insights-on-demand-minute"
                case wireless
                case wirelessOrders = "wireless-orders"
                case wirelessOrdersArtwork = "wireless-orders-artwork"
                case wirelessOrdersBulk = "wireless-orders-bulk"
                case wirelessOrdersEsim = "wireless-orders-esim"
                case wirelessOrdersStarter = "wireless-orders-starter"
                case wirelessUsage = "wireless-usage"
                case wirelessUsageCommands = "wireless-usage-commands"
                case wirelessUsageCommandsAfrica = "wireless-usage-commands-africa"
                case wirelessUsageCommandsAsia = "wireless-usage-commands-asia"
                case wirelessUsageCommandsCentralandsouthamerica = "wireless-usage-commands-centralandsouthamerica"
                case wirelessUsageCommandsEurope = "wireless-usage-commands-europe"
                case wirelessUsageCommandsHome = "wireless-usage-commands-home"
                case wirelessUsageCommandsNorthamerica = "wireless-usage-commands-northamerica"
                case wirelessUsageCommandsOceania = "wireless-usage-commands-oceania"
                case wirelessUsageCommandsRoaming = "wireless-usage-commands-roaming"
                case wirelessUsageData = "wireless-usage-data"
                case wirelessUsageDataAfrica = "wireless-usage-data-africa"
                case wirelessUsageDataAsia = "wireless-usage-data-asia"
                case wirelessUsageDataCentralandsouthamerica = "wireless-usage-data-centralandsouthamerica"
                case wirelessUsageDataCustomAdditionalmb = "wireless-usage-data-custom-additionalmb"
                case wirelessUsageDataCustomFirst5mb = "wireless-usage-data-custom-first5mb"
                case wirelessUsageDataDomesticRoaming = "wireless-usage-data-domestic-roaming"
                case wirelessUsageDataEurope = "wireless-usage-data-europe"
                case wirelessUsageDataIndividualAdditionalgb = "wireless-usage-data-individual-additionalgb"
                case wirelessUsageDataIndividualFirstgb = "wireless-usage-data-individual-firstgb"
                case wirelessUsageDataInternationalRoamingCanada = "wireless-usage-data-international-roaming-canada"
                case wirelessUsageDataInternationalRoamingIndia = "wireless-usage-data-international-roaming-india"
                case wirelessUsageDataInternationalRoamingMexico = "wireless-usage-data-international-roaming-mexico"
                case wirelessUsageDataNorthamerica = "wireless-usage-data-northamerica"
                case wirelessUsageDataOceania = "wireless-usage-data-oceania"
                case wirelessUsageDataPooled = "wireless-usage-data-pooled"
                case wirelessUsageDataPooledDownlink = "wireless-usage-data-pooled-downlink"
                case wirelessUsageDataPooledUplink = "wireless-usage-data-pooled-uplink"
                case wirelessUsageMrc = "wireless-usage-mrc"
                case wirelessUsageMrcCustom = "wireless-usage-mrc-custom"
                case wirelessUsageMrcIndividual = "wireless-usage-mrc-individual"
                case wirelessUsageMrcPooled = "wireless-usage-mrc-pooled"
                case wirelessUsageMrcSuspended = "wireless-usage-mrc-suspended"
                case wirelessUsageSms = "wireless-usage-sms"
                case wirelessUsageVoice = "wireless-usage-voice"
            }

            public init(category: Category? = nil, startDate: NaiveDate? = nil, endDate: NaiveDate? = nil, isIncludeSubaccounts: Bool? = nil, pageSize: Int? = nil) {
                self.category = category
                self.startDate = startDate
                self.endDate = endDate
                self.isIncludeSubaccounts = isIncludeSubaccounts
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("Category", category?.asQueryValue)
                query.addQueryItem("StartDate", startDate?.asQueryValue)
                query.addQueryItem("EndDate", endDate?.asQueryValue)
                query.addQueryItem("IncludeSubaccounts", isIncludeSubaccounts?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Usage.Records {
    public var thisMonthJSON: ThisMonthJSON {
        ThisMonthJSON(path: path + "/ThisMonth.json")
    }

    public struct ThisMonthJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Usage/Records/ThisMonth.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListUsageRecordThisMonthResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?
            public var usageRecords: [TwilioAPI.APIV2010AccountUsageUsageRecordUsageRecordThisMonth]?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil, usageRecords: [TwilioAPI.APIV2010AccountUsageUsageRecordUsageRecordThisMonth]? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
                self.usageRecords = usageRecords
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
                case usageRecords = "usage_records"
            }
        }

        public struct GetParameters {
            public var category: Category?
            public var startDate: NaiveDate?
            public var endDate: NaiveDate?
            public var isIncludeSubaccounts: Bool?
            public var pageSize: Int?

            public enum Category: String, Codable, CaseIterable {
                case agentConference = "agent-conference"
                case answeringMachineDetection = "answering-machine-detection"
                case authyAuthentications = "authy-authentications"
                case authyCallsOutbound = "authy-calls-outbound"
                case authyMonthlyFees = "authy-monthly-fees"
                case authyPhoneIntelligence = "authy-phone-intelligence"
                case authyPhoneVerifications = "authy-phone-verifications"
                case authySmsOutbound = "authy-sms-outbound"
                case callProgessEvents = "call-progess-events"
                case calleridlookups
                case calls
                case callsClient = "calls-client"
                case callsGlobalconference = "calls-globalconference"
                case callsInbound = "calls-inbound"
                case callsInboundLocal = "calls-inbound-local"
                case callsInboundMobile = "calls-inbound-mobile"
                case callsInboundTollfree = "calls-inbound-tollfree"
                case callsOutbound = "calls-outbound"
                case callsPayVerbTransactions = "calls-pay-verb-transactions"
                case callsRecordings = "calls-recordings"
                case callsSip = "calls-sip"
                case callsSipInbound = "calls-sip-inbound"
                case callsSipOutbound = "calls-sip-outbound"
                case callsTransfers = "calls-transfers"
                case carrierLookups = "carrier-lookups"
                case conversations
                case conversationsAPIRequests = "conversations-api-requests"
                case conversationsConversationEvents = "conversations-conversation-events"
                case conversationsEndpointConnectivity = "conversations-endpoint-connectivity"
                case conversationsEvents = "conversations-events"
                case conversationsParticipantEvents = "conversations-participant-events"
                case conversationsParticipants = "conversations-participants"
                case cps
                case flexUsage = "flex-usage"
                case fraudLookups = "fraud-lookups"
                case groupRooms = "group-rooms"
                case groupRoomsDataTrack = "group-rooms-data-track"
                case groupRoomsEncryptedMediaRecorded = "group-rooms-encrypted-media-recorded"
                case groupRoomsMediaDownloaded = "group-rooms-media-downloaded"
                case groupRoomsMediaRecorded = "group-rooms-media-recorded"
                case groupRoomsMediaRouted = "group-rooms-media-routed"
                case groupRoomsMediaStored = "group-rooms-media-stored"
                case groupRoomsParticipantMinutes = "group-rooms-participant-minutes"
                case groupRoomsRecordedMinutes = "group-rooms-recorded-minutes"
                case impV1Usage = "imp-v1-usage"
                case lookups
                case marketplace
                case marketplaceAlgorithmiaNamedEntityRecognition = "marketplace-algorithmia-named-entity-recognition"
                case marketplaceCadenceTranscription = "marketplace-cadence-transcription"
                case marketplaceCadenceTranslation = "marketplace-cadence-translation"
                case marketplaceCapioSpeechToText = "marketplace-capio-speech-to-text"
                case marketplaceConvrizaAbaba = "marketplace-convriza-ababa"
                case marketplaceDeepgramPhraseDetector = "marketplace-deepgram-phrase-detector"
                case marketplaceDigitalSegmentBusinessInfo = "marketplace-digital-segment-business-info"
                case marketplaceFacebookOfflineConversions = "marketplace-facebook-offline-conversions"
                case marketplaceGoogleSpeechToText = "marketplace-google-speech-to-text"
                case marketplaceIbmWatsonMessageInsights = "marketplace-ibm-watson-message-insights"
                case marketplaceIbmWatsonMessageSentiment = "marketplace-ibm-watson-message-sentiment"
                case marketplaceIbmWatsonRecordingAnalysis = "marketplace-ibm-watson-recording-analysis"
                case marketplaceIbmWatsonToneAnalyzer = "marketplace-ibm-watson-tone-analyzer"
                case marketplaceIcehookSystemsScout = "marketplace-icehook-systems-scout"
                case marketplaceInfogroupDataaxleBizinfo = "marketplace-infogroup-dataaxle-bizinfo"
                case marketplaceKeenIoContactCenterAnalytics = "marketplace-keen-io-contact-center-analytics"
                case marketplaceMarchexCleancall = "marketplace-marchex-cleancall"
                case marketplaceMarchexSentimentAnalysisForSms = "marketplace-marchex-sentiment-analysis-for-sms"
                case marketplaceMarketplaceNextcallerSocialID = "marketplace-marketplace-nextcaller-social-id"
                case marketplaceMobileCommonsOptOutClassifier = "marketplace-mobile-commons-opt-out-classifier"
                case marketplaceNexiwaveVoicemailToText = "marketplace-nexiwave-voicemail-to-text"
                case marketplaceNextcallerAdvancedCallerIdentification = "marketplace-nextcaller-advanced-caller-identification"
                case marketplaceNomoroboSpamScore = "marketplace-nomorobo-spam-score"
                case marketplacePayfoneTcpaCompliance = "marketplace-payfone-tcpa-compliance"
                case marketplaceRemeetingAutomaticSpeechRecognition = "marketplace-remeeting-automatic-speech-recognition"
                case marketplaceTcpaDefenseSolutionsBlacklistFeed = "marketplace-tcpa-defense-solutions-blacklist-feed"
                case marketplaceTeloOpencnam = "marketplace-telo-opencnam"
                case marketplaceTruecnamTrueSpam = "marketplace-truecnam-true-spam"
                case marketplaceTwilioCallerNameLookupUs = "marketplace-twilio-caller-name-lookup-us"
                case marketplaceTwilioCarrierInformationLookup = "marketplace-twilio-carrier-information-lookup"
                case marketplaceVoicebasePci = "marketplace-voicebase-pci"
                case marketplaceVoicebaseTranscription = "marketplace-voicebase-transcription"
                case marketplaceVoicebaseTranscriptionCustomVocabulary = "marketplace-voicebase-transcription-custom-vocabulary"
                case marketplaceWhitepagesProCallerIdentification = "marketplace-whitepages-pro-caller-identification"
                case marketplaceWhitepagesProPhoneIntelligence = "marketplace-whitepages-pro-phone-intelligence"
                case marketplaceWhitepagesProPhoneReputation = "marketplace-whitepages-pro-phone-reputation"
                case marketplaceWolfarmSpokenResults = "marketplace-wolfarm-spoken-results"
                case marketplaceWolframShortAnswer = "marketplace-wolfram-short-answer"
                case marketplaceYticaContactCenterReportingAnalytics = "marketplace-ytica-contact-center-reporting-analytics"
                case mediastorage
                case mms
                case mmsInbound = "mms-inbound"
                case mmsInboundLongcode = "mms-inbound-longcode"
                case mmsInboundShortcode = "mms-inbound-shortcode"
                case mmsMessagesCarrierfees = "mms-messages-carrierfees"
                case mmsOutbound = "mms-outbound"
                case mmsOutboundLongcode = "mms-outbound-longcode"
                case mmsOutboundShortcode = "mms-outbound-shortcode"
                case monitorReads = "monitor-reads"
                case monitorStorage = "monitor-storage"
                case monitorWrites = "monitor-writes"
                case notify
                case notifyActionsAttempts = "notify-actions-attempts"
                case notifyChannels = "notify-channels"
                case numberFormatLookups = "number-format-lookups"
                case pchat
                case pchatUsers = "pchat-users"
                case peerToPeerRoomsParticipantMinutes = "peer-to-peer-rooms-participant-minutes"
                case pfax
                case pfaxMinutes = "pfax-minutes"
                case pfaxMinutesInbound = "pfax-minutes-inbound"
                case pfaxMinutesOutbound = "pfax-minutes-outbound"
                case pfaxPages = "pfax-pages"
                case phonenumbers
                case phonenumbersCps = "phonenumbers-cps"
                case phonenumbersEmergency = "phonenumbers-emergency"
                case phonenumbersLocal = "phonenumbers-local"
                case phonenumbersMobile = "phonenumbers-mobile"
                case phonenumbersSetups = "phonenumbers-setups"
                case phonenumbersTollfree = "phonenumbers-tollfree"
                case premiumsupport
                case proxy
                case proxyActiveSessions = "proxy-active-sessions"
                case pstnconnectivity
                case pv
                case pvCompositionMediaDownloaded = "pv-composition-media-downloaded"
                case pvCompositionMediaEncrypted = "pv-composition-media-encrypted"
                case pvCompositionMediaStored = "pv-composition-media-stored"
                case pvCompositionMinutes = "pv-composition-minutes"
                case pvRecordingCompositions = "pv-recording-compositions"
                case pvRoomParticipants = "pv-room-participants"
                case pvRoomParticipantsAu1 = "pv-room-participants-au1"
                case pvRoomParticipantsBr1 = "pv-room-participants-br1"
                case pvRoomParticipantsIe1 = "pv-room-participants-ie1"
                case pvRoomParticipantsJp1 = "pv-room-participants-jp1"
                case pvRoomParticipantsSg1 = "pv-room-participants-sg1"
                case pvRoomParticipantsUs1 = "pv-room-participants-us1"
                case pvRoomParticipantsUs2 = "pv-room-participants-us2"
                case pvRooms = "pv-rooms"
                case pvSipEndpointRegistrations = "pv-sip-endpoint-registrations"
                case recordings
                case recordingstorage
                case roomsGroupBandwidth = "rooms-group-bandwidth"
                case roomsGroupMinutes = "rooms-group-minutes"
                case roomsPeerToPeerMinutes = "rooms-peer-to-peer-minutes"
                case shortcodes
                case shortcodesCustomerowned = "shortcodes-customerowned"
                case shortcodesMmsEnablement = "shortcodes-mms-enablement"
                case shortcodesMps = "shortcodes-mps"
                case shortcodesRandom = "shortcodes-random"
                case shortcodesUk = "shortcodes-uk"
                case shortcodesVanity = "shortcodes-vanity"
                case smallGroupRooms = "small-group-rooms"
                case smallGroupRoomsDataTrack = "small-group-rooms-data-track"
                case smallGroupRoomsParticipantMinutes = "small-group-rooms-participant-minutes"
                case sms
                case smsInbound = "sms-inbound"
                case smsInboundLongcode = "sms-inbound-longcode"
                case smsInboundShortcode = "sms-inbound-shortcode"
                case smsMessagesCarrierfees = "sms-messages-carrierfees"
                case smsMessagesFeatures = "sms-messages-features"
                case smsMessagesFeaturesSenderid = "sms-messages-features-senderid"
                case smsOutbound = "sms-outbound"
                case smsOutboundContentInspection = "sms-outbound-content-inspection"
                case smsOutboundLongcode = "sms-outbound-longcode"
                case smsOutboundShortcode = "sms-outbound-shortcode"
                case speechRecognition = "speech-recognition"
                case studioEngagements = "studio-engagements"
                case sync
                case syncActions = "sync-actions"
                case syncEndpointHours = "sync-endpoint-hours"
                case syncEndpointHoursAboveDailyCap = "sync-endpoint-hours-above-daily-cap"
                case taskrouterTasks = "taskrouter-tasks"
                case totalprice
                case transcriptions
                case trunkingCps = "trunking-cps"
                case trunkingEmergencyCalls = "trunking-emergency-calls"
                case trunkingOrigination = "trunking-origination"
                case trunkingOriginationLocal = "trunking-origination-local"
                case trunkingOriginationMobile = "trunking-origination-mobile"
                case trunkingOriginationTollfree = "trunking-origination-tollfree"
                case trunkingRecordings = "trunking-recordings"
                case trunkingSecure = "trunking-secure"
                case trunkingTermination = "trunking-termination"
                case turnmegabytes
                case turnmegabytesAustralia = "turnmegabytes-australia"
                case turnmegabytesBrasil = "turnmegabytes-brasil"
                case turnmegabytesGermany = "turnmegabytes-germany"
                case turnmegabytesIndia = "turnmegabytes-india"
                case turnmegabytesIreland = "turnmegabytes-ireland"
                case turnmegabytesJapan = "turnmegabytes-japan"
                case turnmegabytesSingapore = "turnmegabytes-singapore"
                case turnmegabytesUseast = "turnmegabytes-useast"
                case turnmegabytesUswest = "turnmegabytes-uswest"
                case twilioInterconnect = "twilio-interconnect"
                case verifyPush = "verify-push"
                case videoRecordings = "video-recordings"
                case voiceInsights = "voice-insights"
                case voiceInsightsClientInsightsOnDemandMinute = "voice-insights-client-insights-on-demand-minute"
                case voiceInsightsPtsnInsightsOnDemandMinute = "voice-insights-ptsn-insights-on-demand-minute"
                case voiceInsightsSipInterfaceInsightsOnDemandMinute = "voice-insights-sip-interface-insights-on-demand-minute"
                case voiceInsightsSipTrunkingInsightsOnDemandMinute = "voice-insights-sip-trunking-insights-on-demand-minute"
                case wireless
                case wirelessOrders = "wireless-orders"
                case wirelessOrdersArtwork = "wireless-orders-artwork"
                case wirelessOrdersBulk = "wireless-orders-bulk"
                case wirelessOrdersEsim = "wireless-orders-esim"
                case wirelessOrdersStarter = "wireless-orders-starter"
                case wirelessUsage = "wireless-usage"
                case wirelessUsageCommands = "wireless-usage-commands"
                case wirelessUsageCommandsAfrica = "wireless-usage-commands-africa"
                case wirelessUsageCommandsAsia = "wireless-usage-commands-asia"
                case wirelessUsageCommandsCentralandsouthamerica = "wireless-usage-commands-centralandsouthamerica"
                case wirelessUsageCommandsEurope = "wireless-usage-commands-europe"
                case wirelessUsageCommandsHome = "wireless-usage-commands-home"
                case wirelessUsageCommandsNorthamerica = "wireless-usage-commands-northamerica"
                case wirelessUsageCommandsOceania = "wireless-usage-commands-oceania"
                case wirelessUsageCommandsRoaming = "wireless-usage-commands-roaming"
                case wirelessUsageData = "wireless-usage-data"
                case wirelessUsageDataAfrica = "wireless-usage-data-africa"
                case wirelessUsageDataAsia = "wireless-usage-data-asia"
                case wirelessUsageDataCentralandsouthamerica = "wireless-usage-data-centralandsouthamerica"
                case wirelessUsageDataCustomAdditionalmb = "wireless-usage-data-custom-additionalmb"
                case wirelessUsageDataCustomFirst5mb = "wireless-usage-data-custom-first5mb"
                case wirelessUsageDataDomesticRoaming = "wireless-usage-data-domestic-roaming"
                case wirelessUsageDataEurope = "wireless-usage-data-europe"
                case wirelessUsageDataIndividualAdditionalgb = "wireless-usage-data-individual-additionalgb"
                case wirelessUsageDataIndividualFirstgb = "wireless-usage-data-individual-firstgb"
                case wirelessUsageDataInternationalRoamingCanada = "wireless-usage-data-international-roaming-canada"
                case wirelessUsageDataInternationalRoamingIndia = "wireless-usage-data-international-roaming-india"
                case wirelessUsageDataInternationalRoamingMexico = "wireless-usage-data-international-roaming-mexico"
                case wirelessUsageDataNorthamerica = "wireless-usage-data-northamerica"
                case wirelessUsageDataOceania = "wireless-usage-data-oceania"
                case wirelessUsageDataPooled = "wireless-usage-data-pooled"
                case wirelessUsageDataPooledDownlink = "wireless-usage-data-pooled-downlink"
                case wirelessUsageDataPooledUplink = "wireless-usage-data-pooled-uplink"
                case wirelessUsageMrc = "wireless-usage-mrc"
                case wirelessUsageMrcCustom = "wireless-usage-mrc-custom"
                case wirelessUsageMrcIndividual = "wireless-usage-mrc-individual"
                case wirelessUsageMrcPooled = "wireless-usage-mrc-pooled"
                case wirelessUsageMrcSuspended = "wireless-usage-mrc-suspended"
                case wirelessUsageSms = "wireless-usage-sms"
                case wirelessUsageVoice = "wireless-usage-voice"
            }

            public init(category: Category? = nil, startDate: NaiveDate? = nil, endDate: NaiveDate? = nil, isIncludeSubaccounts: Bool? = nil, pageSize: Int? = nil) {
                self.category = category
                self.startDate = startDate
                self.endDate = endDate
                self.isIncludeSubaccounts = isIncludeSubaccounts
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("Category", category?.asQueryValue)
                query.addQueryItem("StartDate", startDate?.asQueryValue)
                query.addQueryItem("EndDate", endDate?.asQueryValue)
                query.addQueryItem("IncludeSubaccounts", isIncludeSubaccounts?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Usage.Records {
    public var todayJSON: TodayJSON {
        TodayJSON(path: path + "/Today.json")
    }

    public struct TodayJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Usage/Records/Today.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListUsageRecordTodayResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?
            public var usageRecords: [TwilioAPI.APIV2010AccountUsageUsageRecordUsageRecordToday]?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil, usageRecords: [TwilioAPI.APIV2010AccountUsageUsageRecordUsageRecordToday]? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
                self.usageRecords = usageRecords
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
                case usageRecords = "usage_records"
            }
        }

        public struct GetParameters {
            public var category: Category?
            public var startDate: NaiveDate?
            public var endDate: NaiveDate?
            public var isIncludeSubaccounts: Bool?
            public var pageSize: Int?

            public enum Category: String, Codable, CaseIterable {
                case agentConference = "agent-conference"
                case answeringMachineDetection = "answering-machine-detection"
                case authyAuthentications = "authy-authentications"
                case authyCallsOutbound = "authy-calls-outbound"
                case authyMonthlyFees = "authy-monthly-fees"
                case authyPhoneIntelligence = "authy-phone-intelligence"
                case authyPhoneVerifications = "authy-phone-verifications"
                case authySmsOutbound = "authy-sms-outbound"
                case callProgessEvents = "call-progess-events"
                case calleridlookups
                case calls
                case callsClient = "calls-client"
                case callsGlobalconference = "calls-globalconference"
                case callsInbound = "calls-inbound"
                case callsInboundLocal = "calls-inbound-local"
                case callsInboundMobile = "calls-inbound-mobile"
                case callsInboundTollfree = "calls-inbound-tollfree"
                case callsOutbound = "calls-outbound"
                case callsPayVerbTransactions = "calls-pay-verb-transactions"
                case callsRecordings = "calls-recordings"
                case callsSip = "calls-sip"
                case callsSipInbound = "calls-sip-inbound"
                case callsSipOutbound = "calls-sip-outbound"
                case callsTransfers = "calls-transfers"
                case carrierLookups = "carrier-lookups"
                case conversations
                case conversationsAPIRequests = "conversations-api-requests"
                case conversationsConversationEvents = "conversations-conversation-events"
                case conversationsEndpointConnectivity = "conversations-endpoint-connectivity"
                case conversationsEvents = "conversations-events"
                case conversationsParticipantEvents = "conversations-participant-events"
                case conversationsParticipants = "conversations-participants"
                case cps
                case flexUsage = "flex-usage"
                case fraudLookups = "fraud-lookups"
                case groupRooms = "group-rooms"
                case groupRoomsDataTrack = "group-rooms-data-track"
                case groupRoomsEncryptedMediaRecorded = "group-rooms-encrypted-media-recorded"
                case groupRoomsMediaDownloaded = "group-rooms-media-downloaded"
                case groupRoomsMediaRecorded = "group-rooms-media-recorded"
                case groupRoomsMediaRouted = "group-rooms-media-routed"
                case groupRoomsMediaStored = "group-rooms-media-stored"
                case groupRoomsParticipantMinutes = "group-rooms-participant-minutes"
                case groupRoomsRecordedMinutes = "group-rooms-recorded-minutes"
                case impV1Usage = "imp-v1-usage"
                case lookups
                case marketplace
                case marketplaceAlgorithmiaNamedEntityRecognition = "marketplace-algorithmia-named-entity-recognition"
                case marketplaceCadenceTranscription = "marketplace-cadence-transcription"
                case marketplaceCadenceTranslation = "marketplace-cadence-translation"
                case marketplaceCapioSpeechToText = "marketplace-capio-speech-to-text"
                case marketplaceConvrizaAbaba = "marketplace-convriza-ababa"
                case marketplaceDeepgramPhraseDetector = "marketplace-deepgram-phrase-detector"
                case marketplaceDigitalSegmentBusinessInfo = "marketplace-digital-segment-business-info"
                case marketplaceFacebookOfflineConversions = "marketplace-facebook-offline-conversions"
                case marketplaceGoogleSpeechToText = "marketplace-google-speech-to-text"
                case marketplaceIbmWatsonMessageInsights = "marketplace-ibm-watson-message-insights"
                case marketplaceIbmWatsonMessageSentiment = "marketplace-ibm-watson-message-sentiment"
                case marketplaceIbmWatsonRecordingAnalysis = "marketplace-ibm-watson-recording-analysis"
                case marketplaceIbmWatsonToneAnalyzer = "marketplace-ibm-watson-tone-analyzer"
                case marketplaceIcehookSystemsScout = "marketplace-icehook-systems-scout"
                case marketplaceInfogroupDataaxleBizinfo = "marketplace-infogroup-dataaxle-bizinfo"
                case marketplaceKeenIoContactCenterAnalytics = "marketplace-keen-io-contact-center-analytics"
                case marketplaceMarchexCleancall = "marketplace-marchex-cleancall"
                case marketplaceMarchexSentimentAnalysisForSms = "marketplace-marchex-sentiment-analysis-for-sms"
                case marketplaceMarketplaceNextcallerSocialID = "marketplace-marketplace-nextcaller-social-id"
                case marketplaceMobileCommonsOptOutClassifier = "marketplace-mobile-commons-opt-out-classifier"
                case marketplaceNexiwaveVoicemailToText = "marketplace-nexiwave-voicemail-to-text"
                case marketplaceNextcallerAdvancedCallerIdentification = "marketplace-nextcaller-advanced-caller-identification"
                case marketplaceNomoroboSpamScore = "marketplace-nomorobo-spam-score"
                case marketplacePayfoneTcpaCompliance = "marketplace-payfone-tcpa-compliance"
                case marketplaceRemeetingAutomaticSpeechRecognition = "marketplace-remeeting-automatic-speech-recognition"
                case marketplaceTcpaDefenseSolutionsBlacklistFeed = "marketplace-tcpa-defense-solutions-blacklist-feed"
                case marketplaceTeloOpencnam = "marketplace-telo-opencnam"
                case marketplaceTruecnamTrueSpam = "marketplace-truecnam-true-spam"
                case marketplaceTwilioCallerNameLookupUs = "marketplace-twilio-caller-name-lookup-us"
                case marketplaceTwilioCarrierInformationLookup = "marketplace-twilio-carrier-information-lookup"
                case marketplaceVoicebasePci = "marketplace-voicebase-pci"
                case marketplaceVoicebaseTranscription = "marketplace-voicebase-transcription"
                case marketplaceVoicebaseTranscriptionCustomVocabulary = "marketplace-voicebase-transcription-custom-vocabulary"
                case marketplaceWhitepagesProCallerIdentification = "marketplace-whitepages-pro-caller-identification"
                case marketplaceWhitepagesProPhoneIntelligence = "marketplace-whitepages-pro-phone-intelligence"
                case marketplaceWhitepagesProPhoneReputation = "marketplace-whitepages-pro-phone-reputation"
                case marketplaceWolfarmSpokenResults = "marketplace-wolfarm-spoken-results"
                case marketplaceWolframShortAnswer = "marketplace-wolfram-short-answer"
                case marketplaceYticaContactCenterReportingAnalytics = "marketplace-ytica-contact-center-reporting-analytics"
                case mediastorage
                case mms
                case mmsInbound = "mms-inbound"
                case mmsInboundLongcode = "mms-inbound-longcode"
                case mmsInboundShortcode = "mms-inbound-shortcode"
                case mmsMessagesCarrierfees = "mms-messages-carrierfees"
                case mmsOutbound = "mms-outbound"
                case mmsOutboundLongcode = "mms-outbound-longcode"
                case mmsOutboundShortcode = "mms-outbound-shortcode"
                case monitorReads = "monitor-reads"
                case monitorStorage = "monitor-storage"
                case monitorWrites = "monitor-writes"
                case notify
                case notifyActionsAttempts = "notify-actions-attempts"
                case notifyChannels = "notify-channels"
                case numberFormatLookups = "number-format-lookups"
                case pchat
                case pchatUsers = "pchat-users"
                case peerToPeerRoomsParticipantMinutes = "peer-to-peer-rooms-participant-minutes"
                case pfax
                case pfaxMinutes = "pfax-minutes"
                case pfaxMinutesInbound = "pfax-minutes-inbound"
                case pfaxMinutesOutbound = "pfax-minutes-outbound"
                case pfaxPages = "pfax-pages"
                case phonenumbers
                case phonenumbersCps = "phonenumbers-cps"
                case phonenumbersEmergency = "phonenumbers-emergency"
                case phonenumbersLocal = "phonenumbers-local"
                case phonenumbersMobile = "phonenumbers-mobile"
                case phonenumbersSetups = "phonenumbers-setups"
                case phonenumbersTollfree = "phonenumbers-tollfree"
                case premiumsupport
                case proxy
                case proxyActiveSessions = "proxy-active-sessions"
                case pstnconnectivity
                case pv
                case pvCompositionMediaDownloaded = "pv-composition-media-downloaded"
                case pvCompositionMediaEncrypted = "pv-composition-media-encrypted"
                case pvCompositionMediaStored = "pv-composition-media-stored"
                case pvCompositionMinutes = "pv-composition-minutes"
                case pvRecordingCompositions = "pv-recording-compositions"
                case pvRoomParticipants = "pv-room-participants"
                case pvRoomParticipantsAu1 = "pv-room-participants-au1"
                case pvRoomParticipantsBr1 = "pv-room-participants-br1"
                case pvRoomParticipantsIe1 = "pv-room-participants-ie1"
                case pvRoomParticipantsJp1 = "pv-room-participants-jp1"
                case pvRoomParticipantsSg1 = "pv-room-participants-sg1"
                case pvRoomParticipantsUs1 = "pv-room-participants-us1"
                case pvRoomParticipantsUs2 = "pv-room-participants-us2"
                case pvRooms = "pv-rooms"
                case pvSipEndpointRegistrations = "pv-sip-endpoint-registrations"
                case recordings
                case recordingstorage
                case roomsGroupBandwidth = "rooms-group-bandwidth"
                case roomsGroupMinutes = "rooms-group-minutes"
                case roomsPeerToPeerMinutes = "rooms-peer-to-peer-minutes"
                case shortcodes
                case shortcodesCustomerowned = "shortcodes-customerowned"
                case shortcodesMmsEnablement = "shortcodes-mms-enablement"
                case shortcodesMps = "shortcodes-mps"
                case shortcodesRandom = "shortcodes-random"
                case shortcodesUk = "shortcodes-uk"
                case shortcodesVanity = "shortcodes-vanity"
                case smallGroupRooms = "small-group-rooms"
                case smallGroupRoomsDataTrack = "small-group-rooms-data-track"
                case smallGroupRoomsParticipantMinutes = "small-group-rooms-participant-minutes"
                case sms
                case smsInbound = "sms-inbound"
                case smsInboundLongcode = "sms-inbound-longcode"
                case smsInboundShortcode = "sms-inbound-shortcode"
                case smsMessagesCarrierfees = "sms-messages-carrierfees"
                case smsMessagesFeatures = "sms-messages-features"
                case smsMessagesFeaturesSenderid = "sms-messages-features-senderid"
                case smsOutbound = "sms-outbound"
                case smsOutboundContentInspection = "sms-outbound-content-inspection"
                case smsOutboundLongcode = "sms-outbound-longcode"
                case smsOutboundShortcode = "sms-outbound-shortcode"
                case speechRecognition = "speech-recognition"
                case studioEngagements = "studio-engagements"
                case sync
                case syncActions = "sync-actions"
                case syncEndpointHours = "sync-endpoint-hours"
                case syncEndpointHoursAboveDailyCap = "sync-endpoint-hours-above-daily-cap"
                case taskrouterTasks = "taskrouter-tasks"
                case totalprice
                case transcriptions
                case trunkingCps = "trunking-cps"
                case trunkingEmergencyCalls = "trunking-emergency-calls"
                case trunkingOrigination = "trunking-origination"
                case trunkingOriginationLocal = "trunking-origination-local"
                case trunkingOriginationMobile = "trunking-origination-mobile"
                case trunkingOriginationTollfree = "trunking-origination-tollfree"
                case trunkingRecordings = "trunking-recordings"
                case trunkingSecure = "trunking-secure"
                case trunkingTermination = "trunking-termination"
                case turnmegabytes
                case turnmegabytesAustralia = "turnmegabytes-australia"
                case turnmegabytesBrasil = "turnmegabytes-brasil"
                case turnmegabytesGermany = "turnmegabytes-germany"
                case turnmegabytesIndia = "turnmegabytes-india"
                case turnmegabytesIreland = "turnmegabytes-ireland"
                case turnmegabytesJapan = "turnmegabytes-japan"
                case turnmegabytesSingapore = "turnmegabytes-singapore"
                case turnmegabytesUseast = "turnmegabytes-useast"
                case turnmegabytesUswest = "turnmegabytes-uswest"
                case twilioInterconnect = "twilio-interconnect"
                case verifyPush = "verify-push"
                case videoRecordings = "video-recordings"
                case voiceInsights = "voice-insights"
                case voiceInsightsClientInsightsOnDemandMinute = "voice-insights-client-insights-on-demand-minute"
                case voiceInsightsPtsnInsightsOnDemandMinute = "voice-insights-ptsn-insights-on-demand-minute"
                case voiceInsightsSipInterfaceInsightsOnDemandMinute = "voice-insights-sip-interface-insights-on-demand-minute"
                case voiceInsightsSipTrunkingInsightsOnDemandMinute = "voice-insights-sip-trunking-insights-on-demand-minute"
                case wireless
                case wirelessOrders = "wireless-orders"
                case wirelessOrdersArtwork = "wireless-orders-artwork"
                case wirelessOrdersBulk = "wireless-orders-bulk"
                case wirelessOrdersEsim = "wireless-orders-esim"
                case wirelessOrdersStarter = "wireless-orders-starter"
                case wirelessUsage = "wireless-usage"
                case wirelessUsageCommands = "wireless-usage-commands"
                case wirelessUsageCommandsAfrica = "wireless-usage-commands-africa"
                case wirelessUsageCommandsAsia = "wireless-usage-commands-asia"
                case wirelessUsageCommandsCentralandsouthamerica = "wireless-usage-commands-centralandsouthamerica"
                case wirelessUsageCommandsEurope = "wireless-usage-commands-europe"
                case wirelessUsageCommandsHome = "wireless-usage-commands-home"
                case wirelessUsageCommandsNorthamerica = "wireless-usage-commands-northamerica"
                case wirelessUsageCommandsOceania = "wireless-usage-commands-oceania"
                case wirelessUsageCommandsRoaming = "wireless-usage-commands-roaming"
                case wirelessUsageData = "wireless-usage-data"
                case wirelessUsageDataAfrica = "wireless-usage-data-africa"
                case wirelessUsageDataAsia = "wireless-usage-data-asia"
                case wirelessUsageDataCentralandsouthamerica = "wireless-usage-data-centralandsouthamerica"
                case wirelessUsageDataCustomAdditionalmb = "wireless-usage-data-custom-additionalmb"
                case wirelessUsageDataCustomFirst5mb = "wireless-usage-data-custom-first5mb"
                case wirelessUsageDataDomesticRoaming = "wireless-usage-data-domestic-roaming"
                case wirelessUsageDataEurope = "wireless-usage-data-europe"
                case wirelessUsageDataIndividualAdditionalgb = "wireless-usage-data-individual-additionalgb"
                case wirelessUsageDataIndividualFirstgb = "wireless-usage-data-individual-firstgb"
                case wirelessUsageDataInternationalRoamingCanada = "wireless-usage-data-international-roaming-canada"
                case wirelessUsageDataInternationalRoamingIndia = "wireless-usage-data-international-roaming-india"
                case wirelessUsageDataInternationalRoamingMexico = "wireless-usage-data-international-roaming-mexico"
                case wirelessUsageDataNorthamerica = "wireless-usage-data-northamerica"
                case wirelessUsageDataOceania = "wireless-usage-data-oceania"
                case wirelessUsageDataPooled = "wireless-usage-data-pooled"
                case wirelessUsageDataPooledDownlink = "wireless-usage-data-pooled-downlink"
                case wirelessUsageDataPooledUplink = "wireless-usage-data-pooled-uplink"
                case wirelessUsageMrc = "wireless-usage-mrc"
                case wirelessUsageMrcCustom = "wireless-usage-mrc-custom"
                case wirelessUsageMrcIndividual = "wireless-usage-mrc-individual"
                case wirelessUsageMrcPooled = "wireless-usage-mrc-pooled"
                case wirelessUsageMrcSuspended = "wireless-usage-mrc-suspended"
                case wirelessUsageSms = "wireless-usage-sms"
                case wirelessUsageVoice = "wireless-usage-voice"
            }

            public init(category: Category? = nil, startDate: NaiveDate? = nil, endDate: NaiveDate? = nil, isIncludeSubaccounts: Bool? = nil, pageSize: Int? = nil) {
                self.category = category
                self.startDate = startDate
                self.endDate = endDate
                self.isIncludeSubaccounts = isIncludeSubaccounts
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("Category", category?.asQueryValue)
                query.addQueryItem("StartDate", startDate?.asQueryValue)
                query.addQueryItem("EndDate", endDate?.asQueryValue)
                query.addQueryItem("IncludeSubaccounts", isIncludeSubaccounts?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Usage.Records {
    public var yearlyJSON: YearlyJSON {
        YearlyJSON(path: path + "/Yearly.json")
    }

    public struct YearlyJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Usage/Records/Yearly.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListUsageRecordYearlyResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?
            public var usageRecords: [TwilioAPI.APIV2010AccountUsageUsageRecordUsageRecordYearly]?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil, usageRecords: [TwilioAPI.APIV2010AccountUsageUsageRecordUsageRecordYearly]? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
                self.usageRecords = usageRecords
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
                case usageRecords = "usage_records"
            }
        }

        public struct GetParameters {
            public var category: Category?
            public var startDate: NaiveDate?
            public var endDate: NaiveDate?
            public var isIncludeSubaccounts: Bool?
            public var pageSize: Int?

            public enum Category: String, Codable, CaseIterable {
                case agentConference = "agent-conference"
                case answeringMachineDetection = "answering-machine-detection"
                case authyAuthentications = "authy-authentications"
                case authyCallsOutbound = "authy-calls-outbound"
                case authyMonthlyFees = "authy-monthly-fees"
                case authyPhoneIntelligence = "authy-phone-intelligence"
                case authyPhoneVerifications = "authy-phone-verifications"
                case authySmsOutbound = "authy-sms-outbound"
                case callProgessEvents = "call-progess-events"
                case calleridlookups
                case calls
                case callsClient = "calls-client"
                case callsGlobalconference = "calls-globalconference"
                case callsInbound = "calls-inbound"
                case callsInboundLocal = "calls-inbound-local"
                case callsInboundMobile = "calls-inbound-mobile"
                case callsInboundTollfree = "calls-inbound-tollfree"
                case callsOutbound = "calls-outbound"
                case callsPayVerbTransactions = "calls-pay-verb-transactions"
                case callsRecordings = "calls-recordings"
                case callsSip = "calls-sip"
                case callsSipInbound = "calls-sip-inbound"
                case callsSipOutbound = "calls-sip-outbound"
                case callsTransfers = "calls-transfers"
                case carrierLookups = "carrier-lookups"
                case conversations
                case conversationsAPIRequests = "conversations-api-requests"
                case conversationsConversationEvents = "conversations-conversation-events"
                case conversationsEndpointConnectivity = "conversations-endpoint-connectivity"
                case conversationsEvents = "conversations-events"
                case conversationsParticipantEvents = "conversations-participant-events"
                case conversationsParticipants = "conversations-participants"
                case cps
                case flexUsage = "flex-usage"
                case fraudLookups = "fraud-lookups"
                case groupRooms = "group-rooms"
                case groupRoomsDataTrack = "group-rooms-data-track"
                case groupRoomsEncryptedMediaRecorded = "group-rooms-encrypted-media-recorded"
                case groupRoomsMediaDownloaded = "group-rooms-media-downloaded"
                case groupRoomsMediaRecorded = "group-rooms-media-recorded"
                case groupRoomsMediaRouted = "group-rooms-media-routed"
                case groupRoomsMediaStored = "group-rooms-media-stored"
                case groupRoomsParticipantMinutes = "group-rooms-participant-minutes"
                case groupRoomsRecordedMinutes = "group-rooms-recorded-minutes"
                case impV1Usage = "imp-v1-usage"
                case lookups
                case marketplace
                case marketplaceAlgorithmiaNamedEntityRecognition = "marketplace-algorithmia-named-entity-recognition"
                case marketplaceCadenceTranscription = "marketplace-cadence-transcription"
                case marketplaceCadenceTranslation = "marketplace-cadence-translation"
                case marketplaceCapioSpeechToText = "marketplace-capio-speech-to-text"
                case marketplaceConvrizaAbaba = "marketplace-convriza-ababa"
                case marketplaceDeepgramPhraseDetector = "marketplace-deepgram-phrase-detector"
                case marketplaceDigitalSegmentBusinessInfo = "marketplace-digital-segment-business-info"
                case marketplaceFacebookOfflineConversions = "marketplace-facebook-offline-conversions"
                case marketplaceGoogleSpeechToText = "marketplace-google-speech-to-text"
                case marketplaceIbmWatsonMessageInsights = "marketplace-ibm-watson-message-insights"
                case marketplaceIbmWatsonMessageSentiment = "marketplace-ibm-watson-message-sentiment"
                case marketplaceIbmWatsonRecordingAnalysis = "marketplace-ibm-watson-recording-analysis"
                case marketplaceIbmWatsonToneAnalyzer = "marketplace-ibm-watson-tone-analyzer"
                case marketplaceIcehookSystemsScout = "marketplace-icehook-systems-scout"
                case marketplaceInfogroupDataaxleBizinfo = "marketplace-infogroup-dataaxle-bizinfo"
                case marketplaceKeenIoContactCenterAnalytics = "marketplace-keen-io-contact-center-analytics"
                case marketplaceMarchexCleancall = "marketplace-marchex-cleancall"
                case marketplaceMarchexSentimentAnalysisForSms = "marketplace-marchex-sentiment-analysis-for-sms"
                case marketplaceMarketplaceNextcallerSocialID = "marketplace-marketplace-nextcaller-social-id"
                case marketplaceMobileCommonsOptOutClassifier = "marketplace-mobile-commons-opt-out-classifier"
                case marketplaceNexiwaveVoicemailToText = "marketplace-nexiwave-voicemail-to-text"
                case marketplaceNextcallerAdvancedCallerIdentification = "marketplace-nextcaller-advanced-caller-identification"
                case marketplaceNomoroboSpamScore = "marketplace-nomorobo-spam-score"
                case marketplacePayfoneTcpaCompliance = "marketplace-payfone-tcpa-compliance"
                case marketplaceRemeetingAutomaticSpeechRecognition = "marketplace-remeeting-automatic-speech-recognition"
                case marketplaceTcpaDefenseSolutionsBlacklistFeed = "marketplace-tcpa-defense-solutions-blacklist-feed"
                case marketplaceTeloOpencnam = "marketplace-telo-opencnam"
                case marketplaceTruecnamTrueSpam = "marketplace-truecnam-true-spam"
                case marketplaceTwilioCallerNameLookupUs = "marketplace-twilio-caller-name-lookup-us"
                case marketplaceTwilioCarrierInformationLookup = "marketplace-twilio-carrier-information-lookup"
                case marketplaceVoicebasePci = "marketplace-voicebase-pci"
                case marketplaceVoicebaseTranscription = "marketplace-voicebase-transcription"
                case marketplaceVoicebaseTranscriptionCustomVocabulary = "marketplace-voicebase-transcription-custom-vocabulary"
                case marketplaceWhitepagesProCallerIdentification = "marketplace-whitepages-pro-caller-identification"
                case marketplaceWhitepagesProPhoneIntelligence = "marketplace-whitepages-pro-phone-intelligence"
                case marketplaceWhitepagesProPhoneReputation = "marketplace-whitepages-pro-phone-reputation"
                case marketplaceWolfarmSpokenResults = "marketplace-wolfarm-spoken-results"
                case marketplaceWolframShortAnswer = "marketplace-wolfram-short-answer"
                case marketplaceYticaContactCenterReportingAnalytics = "marketplace-ytica-contact-center-reporting-analytics"
                case mediastorage
                case mms
                case mmsInbound = "mms-inbound"
                case mmsInboundLongcode = "mms-inbound-longcode"
                case mmsInboundShortcode = "mms-inbound-shortcode"
                case mmsMessagesCarrierfees = "mms-messages-carrierfees"
                case mmsOutbound = "mms-outbound"
                case mmsOutboundLongcode = "mms-outbound-longcode"
                case mmsOutboundShortcode = "mms-outbound-shortcode"
                case monitorReads = "monitor-reads"
                case monitorStorage = "monitor-storage"
                case monitorWrites = "monitor-writes"
                case notify
                case notifyActionsAttempts = "notify-actions-attempts"
                case notifyChannels = "notify-channels"
                case numberFormatLookups = "number-format-lookups"
                case pchat
                case pchatUsers = "pchat-users"
                case peerToPeerRoomsParticipantMinutes = "peer-to-peer-rooms-participant-minutes"
                case pfax
                case pfaxMinutes = "pfax-minutes"
                case pfaxMinutesInbound = "pfax-minutes-inbound"
                case pfaxMinutesOutbound = "pfax-minutes-outbound"
                case pfaxPages = "pfax-pages"
                case phonenumbers
                case phonenumbersCps = "phonenumbers-cps"
                case phonenumbersEmergency = "phonenumbers-emergency"
                case phonenumbersLocal = "phonenumbers-local"
                case phonenumbersMobile = "phonenumbers-mobile"
                case phonenumbersSetups = "phonenumbers-setups"
                case phonenumbersTollfree = "phonenumbers-tollfree"
                case premiumsupport
                case proxy
                case proxyActiveSessions = "proxy-active-sessions"
                case pstnconnectivity
                case pv
                case pvCompositionMediaDownloaded = "pv-composition-media-downloaded"
                case pvCompositionMediaEncrypted = "pv-composition-media-encrypted"
                case pvCompositionMediaStored = "pv-composition-media-stored"
                case pvCompositionMinutes = "pv-composition-minutes"
                case pvRecordingCompositions = "pv-recording-compositions"
                case pvRoomParticipants = "pv-room-participants"
                case pvRoomParticipantsAu1 = "pv-room-participants-au1"
                case pvRoomParticipantsBr1 = "pv-room-participants-br1"
                case pvRoomParticipantsIe1 = "pv-room-participants-ie1"
                case pvRoomParticipantsJp1 = "pv-room-participants-jp1"
                case pvRoomParticipantsSg1 = "pv-room-participants-sg1"
                case pvRoomParticipantsUs1 = "pv-room-participants-us1"
                case pvRoomParticipantsUs2 = "pv-room-participants-us2"
                case pvRooms = "pv-rooms"
                case pvSipEndpointRegistrations = "pv-sip-endpoint-registrations"
                case recordings
                case recordingstorage
                case roomsGroupBandwidth = "rooms-group-bandwidth"
                case roomsGroupMinutes = "rooms-group-minutes"
                case roomsPeerToPeerMinutes = "rooms-peer-to-peer-minutes"
                case shortcodes
                case shortcodesCustomerowned = "shortcodes-customerowned"
                case shortcodesMmsEnablement = "shortcodes-mms-enablement"
                case shortcodesMps = "shortcodes-mps"
                case shortcodesRandom = "shortcodes-random"
                case shortcodesUk = "shortcodes-uk"
                case shortcodesVanity = "shortcodes-vanity"
                case smallGroupRooms = "small-group-rooms"
                case smallGroupRoomsDataTrack = "small-group-rooms-data-track"
                case smallGroupRoomsParticipantMinutes = "small-group-rooms-participant-minutes"
                case sms
                case smsInbound = "sms-inbound"
                case smsInboundLongcode = "sms-inbound-longcode"
                case smsInboundShortcode = "sms-inbound-shortcode"
                case smsMessagesCarrierfees = "sms-messages-carrierfees"
                case smsMessagesFeatures = "sms-messages-features"
                case smsMessagesFeaturesSenderid = "sms-messages-features-senderid"
                case smsOutbound = "sms-outbound"
                case smsOutboundContentInspection = "sms-outbound-content-inspection"
                case smsOutboundLongcode = "sms-outbound-longcode"
                case smsOutboundShortcode = "sms-outbound-shortcode"
                case speechRecognition = "speech-recognition"
                case studioEngagements = "studio-engagements"
                case sync
                case syncActions = "sync-actions"
                case syncEndpointHours = "sync-endpoint-hours"
                case syncEndpointHoursAboveDailyCap = "sync-endpoint-hours-above-daily-cap"
                case taskrouterTasks = "taskrouter-tasks"
                case totalprice
                case transcriptions
                case trunkingCps = "trunking-cps"
                case trunkingEmergencyCalls = "trunking-emergency-calls"
                case trunkingOrigination = "trunking-origination"
                case trunkingOriginationLocal = "trunking-origination-local"
                case trunkingOriginationMobile = "trunking-origination-mobile"
                case trunkingOriginationTollfree = "trunking-origination-tollfree"
                case trunkingRecordings = "trunking-recordings"
                case trunkingSecure = "trunking-secure"
                case trunkingTermination = "trunking-termination"
                case turnmegabytes
                case turnmegabytesAustralia = "turnmegabytes-australia"
                case turnmegabytesBrasil = "turnmegabytes-brasil"
                case turnmegabytesGermany = "turnmegabytes-germany"
                case turnmegabytesIndia = "turnmegabytes-india"
                case turnmegabytesIreland = "turnmegabytes-ireland"
                case turnmegabytesJapan = "turnmegabytes-japan"
                case turnmegabytesSingapore = "turnmegabytes-singapore"
                case turnmegabytesUseast = "turnmegabytes-useast"
                case turnmegabytesUswest = "turnmegabytes-uswest"
                case twilioInterconnect = "twilio-interconnect"
                case verifyPush = "verify-push"
                case videoRecordings = "video-recordings"
                case voiceInsights = "voice-insights"
                case voiceInsightsClientInsightsOnDemandMinute = "voice-insights-client-insights-on-demand-minute"
                case voiceInsightsPtsnInsightsOnDemandMinute = "voice-insights-ptsn-insights-on-demand-minute"
                case voiceInsightsSipInterfaceInsightsOnDemandMinute = "voice-insights-sip-interface-insights-on-demand-minute"
                case voiceInsightsSipTrunkingInsightsOnDemandMinute = "voice-insights-sip-trunking-insights-on-demand-minute"
                case wireless
                case wirelessOrders = "wireless-orders"
                case wirelessOrdersArtwork = "wireless-orders-artwork"
                case wirelessOrdersBulk = "wireless-orders-bulk"
                case wirelessOrdersEsim = "wireless-orders-esim"
                case wirelessOrdersStarter = "wireless-orders-starter"
                case wirelessUsage = "wireless-usage"
                case wirelessUsageCommands = "wireless-usage-commands"
                case wirelessUsageCommandsAfrica = "wireless-usage-commands-africa"
                case wirelessUsageCommandsAsia = "wireless-usage-commands-asia"
                case wirelessUsageCommandsCentralandsouthamerica = "wireless-usage-commands-centralandsouthamerica"
                case wirelessUsageCommandsEurope = "wireless-usage-commands-europe"
                case wirelessUsageCommandsHome = "wireless-usage-commands-home"
                case wirelessUsageCommandsNorthamerica = "wireless-usage-commands-northamerica"
                case wirelessUsageCommandsOceania = "wireless-usage-commands-oceania"
                case wirelessUsageCommandsRoaming = "wireless-usage-commands-roaming"
                case wirelessUsageData = "wireless-usage-data"
                case wirelessUsageDataAfrica = "wireless-usage-data-africa"
                case wirelessUsageDataAsia = "wireless-usage-data-asia"
                case wirelessUsageDataCentralandsouthamerica = "wireless-usage-data-centralandsouthamerica"
                case wirelessUsageDataCustomAdditionalmb = "wireless-usage-data-custom-additionalmb"
                case wirelessUsageDataCustomFirst5mb = "wireless-usage-data-custom-first5mb"
                case wirelessUsageDataDomesticRoaming = "wireless-usage-data-domestic-roaming"
                case wirelessUsageDataEurope = "wireless-usage-data-europe"
                case wirelessUsageDataIndividualAdditionalgb = "wireless-usage-data-individual-additionalgb"
                case wirelessUsageDataIndividualFirstgb = "wireless-usage-data-individual-firstgb"
                case wirelessUsageDataInternationalRoamingCanada = "wireless-usage-data-international-roaming-canada"
                case wirelessUsageDataInternationalRoamingIndia = "wireless-usage-data-international-roaming-india"
                case wirelessUsageDataInternationalRoamingMexico = "wireless-usage-data-international-roaming-mexico"
                case wirelessUsageDataNorthamerica = "wireless-usage-data-northamerica"
                case wirelessUsageDataOceania = "wireless-usage-data-oceania"
                case wirelessUsageDataPooled = "wireless-usage-data-pooled"
                case wirelessUsageDataPooledDownlink = "wireless-usage-data-pooled-downlink"
                case wirelessUsageDataPooledUplink = "wireless-usage-data-pooled-uplink"
                case wirelessUsageMrc = "wireless-usage-mrc"
                case wirelessUsageMrcCustom = "wireless-usage-mrc-custom"
                case wirelessUsageMrcIndividual = "wireless-usage-mrc-individual"
                case wirelessUsageMrcPooled = "wireless-usage-mrc-pooled"
                case wirelessUsageMrcSuspended = "wireless-usage-mrc-suspended"
                case wirelessUsageSms = "wireless-usage-sms"
                case wirelessUsageVoice = "wireless-usage-voice"
            }

            public init(category: Category? = nil, startDate: NaiveDate? = nil, endDate: NaiveDate? = nil, isIncludeSubaccounts: Bool? = nil, pageSize: Int? = nil) {
                self.category = category
                self.startDate = startDate
                self.endDate = endDate
                self.isIncludeSubaccounts = isIncludeSubaccounts
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("Category", category?.asQueryValue)
                query.addQueryItem("StartDate", startDate?.asQueryValue)
                query.addQueryItem("EndDate", endDate?.asQueryValue)
                query.addQueryItem("IncludeSubaccounts", isIncludeSubaccounts?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Usage.Records {
    public var yesterdayJSON: YesterdayJSON {
        YesterdayJSON(path: path + "/Yesterday.json")
    }

    public struct YesterdayJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Usage/Records/Yesterday.json`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListUsageRecordYesterdayResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?
            public var usageRecords: [TwilioAPI.APIV2010AccountUsageUsageRecordUsageRecordYesterday]?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil, usageRecords: [TwilioAPI.APIV2010AccountUsageUsageRecordUsageRecordYesterday]? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
                self.usageRecords = usageRecords
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
                case usageRecords = "usage_records"
            }
        }

        public struct GetParameters {
            public var category: Category?
            public var startDate: NaiveDate?
            public var endDate: NaiveDate?
            public var isIncludeSubaccounts: Bool?
            public var pageSize: Int?

            public enum Category: String, Codable, CaseIterable {
                case agentConference = "agent-conference"
                case answeringMachineDetection = "answering-machine-detection"
                case authyAuthentications = "authy-authentications"
                case authyCallsOutbound = "authy-calls-outbound"
                case authyMonthlyFees = "authy-monthly-fees"
                case authyPhoneIntelligence = "authy-phone-intelligence"
                case authyPhoneVerifications = "authy-phone-verifications"
                case authySmsOutbound = "authy-sms-outbound"
                case callProgessEvents = "call-progess-events"
                case calleridlookups
                case calls
                case callsClient = "calls-client"
                case callsGlobalconference = "calls-globalconference"
                case callsInbound = "calls-inbound"
                case callsInboundLocal = "calls-inbound-local"
                case callsInboundMobile = "calls-inbound-mobile"
                case callsInboundTollfree = "calls-inbound-tollfree"
                case callsOutbound = "calls-outbound"
                case callsPayVerbTransactions = "calls-pay-verb-transactions"
                case callsRecordings = "calls-recordings"
                case callsSip = "calls-sip"
                case callsSipInbound = "calls-sip-inbound"
                case callsSipOutbound = "calls-sip-outbound"
                case callsTransfers = "calls-transfers"
                case carrierLookups = "carrier-lookups"
                case conversations
                case conversationsAPIRequests = "conversations-api-requests"
                case conversationsConversationEvents = "conversations-conversation-events"
                case conversationsEndpointConnectivity = "conversations-endpoint-connectivity"
                case conversationsEvents = "conversations-events"
                case conversationsParticipantEvents = "conversations-participant-events"
                case conversationsParticipants = "conversations-participants"
                case cps
                case flexUsage = "flex-usage"
                case fraudLookups = "fraud-lookups"
                case groupRooms = "group-rooms"
                case groupRoomsDataTrack = "group-rooms-data-track"
                case groupRoomsEncryptedMediaRecorded = "group-rooms-encrypted-media-recorded"
                case groupRoomsMediaDownloaded = "group-rooms-media-downloaded"
                case groupRoomsMediaRecorded = "group-rooms-media-recorded"
                case groupRoomsMediaRouted = "group-rooms-media-routed"
                case groupRoomsMediaStored = "group-rooms-media-stored"
                case groupRoomsParticipantMinutes = "group-rooms-participant-minutes"
                case groupRoomsRecordedMinutes = "group-rooms-recorded-minutes"
                case impV1Usage = "imp-v1-usage"
                case lookups
                case marketplace
                case marketplaceAlgorithmiaNamedEntityRecognition = "marketplace-algorithmia-named-entity-recognition"
                case marketplaceCadenceTranscription = "marketplace-cadence-transcription"
                case marketplaceCadenceTranslation = "marketplace-cadence-translation"
                case marketplaceCapioSpeechToText = "marketplace-capio-speech-to-text"
                case marketplaceConvrizaAbaba = "marketplace-convriza-ababa"
                case marketplaceDeepgramPhraseDetector = "marketplace-deepgram-phrase-detector"
                case marketplaceDigitalSegmentBusinessInfo = "marketplace-digital-segment-business-info"
                case marketplaceFacebookOfflineConversions = "marketplace-facebook-offline-conversions"
                case marketplaceGoogleSpeechToText = "marketplace-google-speech-to-text"
                case marketplaceIbmWatsonMessageInsights = "marketplace-ibm-watson-message-insights"
                case marketplaceIbmWatsonMessageSentiment = "marketplace-ibm-watson-message-sentiment"
                case marketplaceIbmWatsonRecordingAnalysis = "marketplace-ibm-watson-recording-analysis"
                case marketplaceIbmWatsonToneAnalyzer = "marketplace-ibm-watson-tone-analyzer"
                case marketplaceIcehookSystemsScout = "marketplace-icehook-systems-scout"
                case marketplaceInfogroupDataaxleBizinfo = "marketplace-infogroup-dataaxle-bizinfo"
                case marketplaceKeenIoContactCenterAnalytics = "marketplace-keen-io-contact-center-analytics"
                case marketplaceMarchexCleancall = "marketplace-marchex-cleancall"
                case marketplaceMarchexSentimentAnalysisForSms = "marketplace-marchex-sentiment-analysis-for-sms"
                case marketplaceMarketplaceNextcallerSocialID = "marketplace-marketplace-nextcaller-social-id"
                case marketplaceMobileCommonsOptOutClassifier = "marketplace-mobile-commons-opt-out-classifier"
                case marketplaceNexiwaveVoicemailToText = "marketplace-nexiwave-voicemail-to-text"
                case marketplaceNextcallerAdvancedCallerIdentification = "marketplace-nextcaller-advanced-caller-identification"
                case marketplaceNomoroboSpamScore = "marketplace-nomorobo-spam-score"
                case marketplacePayfoneTcpaCompliance = "marketplace-payfone-tcpa-compliance"
                case marketplaceRemeetingAutomaticSpeechRecognition = "marketplace-remeeting-automatic-speech-recognition"
                case marketplaceTcpaDefenseSolutionsBlacklistFeed = "marketplace-tcpa-defense-solutions-blacklist-feed"
                case marketplaceTeloOpencnam = "marketplace-telo-opencnam"
                case marketplaceTruecnamTrueSpam = "marketplace-truecnam-true-spam"
                case marketplaceTwilioCallerNameLookupUs = "marketplace-twilio-caller-name-lookup-us"
                case marketplaceTwilioCarrierInformationLookup = "marketplace-twilio-carrier-information-lookup"
                case marketplaceVoicebasePci = "marketplace-voicebase-pci"
                case marketplaceVoicebaseTranscription = "marketplace-voicebase-transcription"
                case marketplaceVoicebaseTranscriptionCustomVocabulary = "marketplace-voicebase-transcription-custom-vocabulary"
                case marketplaceWhitepagesProCallerIdentification = "marketplace-whitepages-pro-caller-identification"
                case marketplaceWhitepagesProPhoneIntelligence = "marketplace-whitepages-pro-phone-intelligence"
                case marketplaceWhitepagesProPhoneReputation = "marketplace-whitepages-pro-phone-reputation"
                case marketplaceWolfarmSpokenResults = "marketplace-wolfarm-spoken-results"
                case marketplaceWolframShortAnswer = "marketplace-wolfram-short-answer"
                case marketplaceYticaContactCenterReportingAnalytics = "marketplace-ytica-contact-center-reporting-analytics"
                case mediastorage
                case mms
                case mmsInbound = "mms-inbound"
                case mmsInboundLongcode = "mms-inbound-longcode"
                case mmsInboundShortcode = "mms-inbound-shortcode"
                case mmsMessagesCarrierfees = "mms-messages-carrierfees"
                case mmsOutbound = "mms-outbound"
                case mmsOutboundLongcode = "mms-outbound-longcode"
                case mmsOutboundShortcode = "mms-outbound-shortcode"
                case monitorReads = "monitor-reads"
                case monitorStorage = "monitor-storage"
                case monitorWrites = "monitor-writes"
                case notify
                case notifyActionsAttempts = "notify-actions-attempts"
                case notifyChannels = "notify-channels"
                case numberFormatLookups = "number-format-lookups"
                case pchat
                case pchatUsers = "pchat-users"
                case peerToPeerRoomsParticipantMinutes = "peer-to-peer-rooms-participant-minutes"
                case pfax
                case pfaxMinutes = "pfax-minutes"
                case pfaxMinutesInbound = "pfax-minutes-inbound"
                case pfaxMinutesOutbound = "pfax-minutes-outbound"
                case pfaxPages = "pfax-pages"
                case phonenumbers
                case phonenumbersCps = "phonenumbers-cps"
                case phonenumbersEmergency = "phonenumbers-emergency"
                case phonenumbersLocal = "phonenumbers-local"
                case phonenumbersMobile = "phonenumbers-mobile"
                case phonenumbersSetups = "phonenumbers-setups"
                case phonenumbersTollfree = "phonenumbers-tollfree"
                case premiumsupport
                case proxy
                case proxyActiveSessions = "proxy-active-sessions"
                case pstnconnectivity
                case pv
                case pvCompositionMediaDownloaded = "pv-composition-media-downloaded"
                case pvCompositionMediaEncrypted = "pv-composition-media-encrypted"
                case pvCompositionMediaStored = "pv-composition-media-stored"
                case pvCompositionMinutes = "pv-composition-minutes"
                case pvRecordingCompositions = "pv-recording-compositions"
                case pvRoomParticipants = "pv-room-participants"
                case pvRoomParticipantsAu1 = "pv-room-participants-au1"
                case pvRoomParticipantsBr1 = "pv-room-participants-br1"
                case pvRoomParticipantsIe1 = "pv-room-participants-ie1"
                case pvRoomParticipantsJp1 = "pv-room-participants-jp1"
                case pvRoomParticipantsSg1 = "pv-room-participants-sg1"
                case pvRoomParticipantsUs1 = "pv-room-participants-us1"
                case pvRoomParticipantsUs2 = "pv-room-participants-us2"
                case pvRooms = "pv-rooms"
                case pvSipEndpointRegistrations = "pv-sip-endpoint-registrations"
                case recordings
                case recordingstorage
                case roomsGroupBandwidth = "rooms-group-bandwidth"
                case roomsGroupMinutes = "rooms-group-minutes"
                case roomsPeerToPeerMinutes = "rooms-peer-to-peer-minutes"
                case shortcodes
                case shortcodesCustomerowned = "shortcodes-customerowned"
                case shortcodesMmsEnablement = "shortcodes-mms-enablement"
                case shortcodesMps = "shortcodes-mps"
                case shortcodesRandom = "shortcodes-random"
                case shortcodesUk = "shortcodes-uk"
                case shortcodesVanity = "shortcodes-vanity"
                case smallGroupRooms = "small-group-rooms"
                case smallGroupRoomsDataTrack = "small-group-rooms-data-track"
                case smallGroupRoomsParticipantMinutes = "small-group-rooms-participant-minutes"
                case sms
                case smsInbound = "sms-inbound"
                case smsInboundLongcode = "sms-inbound-longcode"
                case smsInboundShortcode = "sms-inbound-shortcode"
                case smsMessagesCarrierfees = "sms-messages-carrierfees"
                case smsMessagesFeatures = "sms-messages-features"
                case smsMessagesFeaturesSenderid = "sms-messages-features-senderid"
                case smsOutbound = "sms-outbound"
                case smsOutboundContentInspection = "sms-outbound-content-inspection"
                case smsOutboundLongcode = "sms-outbound-longcode"
                case smsOutboundShortcode = "sms-outbound-shortcode"
                case speechRecognition = "speech-recognition"
                case studioEngagements = "studio-engagements"
                case sync
                case syncActions = "sync-actions"
                case syncEndpointHours = "sync-endpoint-hours"
                case syncEndpointHoursAboveDailyCap = "sync-endpoint-hours-above-daily-cap"
                case taskrouterTasks = "taskrouter-tasks"
                case totalprice
                case transcriptions
                case trunkingCps = "trunking-cps"
                case trunkingEmergencyCalls = "trunking-emergency-calls"
                case trunkingOrigination = "trunking-origination"
                case trunkingOriginationLocal = "trunking-origination-local"
                case trunkingOriginationMobile = "trunking-origination-mobile"
                case trunkingOriginationTollfree = "trunking-origination-tollfree"
                case trunkingRecordings = "trunking-recordings"
                case trunkingSecure = "trunking-secure"
                case trunkingTermination = "trunking-termination"
                case turnmegabytes
                case turnmegabytesAustralia = "turnmegabytes-australia"
                case turnmegabytesBrasil = "turnmegabytes-brasil"
                case turnmegabytesGermany = "turnmegabytes-germany"
                case turnmegabytesIndia = "turnmegabytes-india"
                case turnmegabytesIreland = "turnmegabytes-ireland"
                case turnmegabytesJapan = "turnmegabytes-japan"
                case turnmegabytesSingapore = "turnmegabytes-singapore"
                case turnmegabytesUseast = "turnmegabytes-useast"
                case turnmegabytesUswest = "turnmegabytes-uswest"
                case twilioInterconnect = "twilio-interconnect"
                case verifyPush = "verify-push"
                case videoRecordings = "video-recordings"
                case voiceInsights = "voice-insights"
                case voiceInsightsClientInsightsOnDemandMinute = "voice-insights-client-insights-on-demand-minute"
                case voiceInsightsPtsnInsightsOnDemandMinute = "voice-insights-ptsn-insights-on-demand-minute"
                case voiceInsightsSipInterfaceInsightsOnDemandMinute = "voice-insights-sip-interface-insights-on-demand-minute"
                case voiceInsightsSipTrunkingInsightsOnDemandMinute = "voice-insights-sip-trunking-insights-on-demand-minute"
                case wireless
                case wirelessOrders = "wireless-orders"
                case wirelessOrdersArtwork = "wireless-orders-artwork"
                case wirelessOrdersBulk = "wireless-orders-bulk"
                case wirelessOrdersEsim = "wireless-orders-esim"
                case wirelessOrdersStarter = "wireless-orders-starter"
                case wirelessUsage = "wireless-usage"
                case wirelessUsageCommands = "wireless-usage-commands"
                case wirelessUsageCommandsAfrica = "wireless-usage-commands-africa"
                case wirelessUsageCommandsAsia = "wireless-usage-commands-asia"
                case wirelessUsageCommandsCentralandsouthamerica = "wireless-usage-commands-centralandsouthamerica"
                case wirelessUsageCommandsEurope = "wireless-usage-commands-europe"
                case wirelessUsageCommandsHome = "wireless-usage-commands-home"
                case wirelessUsageCommandsNorthamerica = "wireless-usage-commands-northamerica"
                case wirelessUsageCommandsOceania = "wireless-usage-commands-oceania"
                case wirelessUsageCommandsRoaming = "wireless-usage-commands-roaming"
                case wirelessUsageData = "wireless-usage-data"
                case wirelessUsageDataAfrica = "wireless-usage-data-africa"
                case wirelessUsageDataAsia = "wireless-usage-data-asia"
                case wirelessUsageDataCentralandsouthamerica = "wireless-usage-data-centralandsouthamerica"
                case wirelessUsageDataCustomAdditionalmb = "wireless-usage-data-custom-additionalmb"
                case wirelessUsageDataCustomFirst5mb = "wireless-usage-data-custom-first5mb"
                case wirelessUsageDataDomesticRoaming = "wireless-usage-data-domestic-roaming"
                case wirelessUsageDataEurope = "wireless-usage-data-europe"
                case wirelessUsageDataIndividualAdditionalgb = "wireless-usage-data-individual-additionalgb"
                case wirelessUsageDataIndividualFirstgb = "wireless-usage-data-individual-firstgb"
                case wirelessUsageDataInternationalRoamingCanada = "wireless-usage-data-international-roaming-canada"
                case wirelessUsageDataInternationalRoamingIndia = "wireless-usage-data-international-roaming-india"
                case wirelessUsageDataInternationalRoamingMexico = "wireless-usage-data-international-roaming-mexico"
                case wirelessUsageDataNorthamerica = "wireless-usage-data-northamerica"
                case wirelessUsageDataOceania = "wireless-usage-data-oceania"
                case wirelessUsageDataPooled = "wireless-usage-data-pooled"
                case wirelessUsageDataPooledDownlink = "wireless-usage-data-pooled-downlink"
                case wirelessUsageDataPooledUplink = "wireless-usage-data-pooled-uplink"
                case wirelessUsageMrc = "wireless-usage-mrc"
                case wirelessUsageMrcCustom = "wireless-usage-mrc-custom"
                case wirelessUsageMrcIndividual = "wireless-usage-mrc-individual"
                case wirelessUsageMrcPooled = "wireless-usage-mrc-pooled"
                case wirelessUsageMrcSuspended = "wireless-usage-mrc-suspended"
                case wirelessUsageSms = "wireless-usage-sms"
                case wirelessUsageVoice = "wireless-usage-voice"
            }

            public init(category: Category? = nil, startDate: NaiveDate? = nil, endDate: NaiveDate? = nil, isIncludeSubaccounts: Bool? = nil, pageSize: Int? = nil) {
                self.category = category
                self.startDate = startDate
                self.endDate = endDate
                self.isIncludeSubaccounts = isIncludeSubaccounts
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("Category", category?.asQueryValue)
                query.addQueryItem("StartDate", startDate?.asQueryValue)
                query.addQueryItem("EndDate", endDate?.asQueryValue)
                query.addQueryItem("IncludeSubaccounts", isIncludeSubaccounts?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Usage {
    public var triggersJSON: TriggersJSON {
        TriggersJSON(path: path + "/Triggers.json")
    }

    public struct TriggersJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Usage/Triggers.json`
        public let path: String

        /// Retrieve a list of usage-triggers belonging to the account used to make the request
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        /// ListUsageTriggerResponse
        public struct GetResponse: Decodable {
            public var end: Int?
            public var firstPageUri: URL?
            public var nextPageUri: URL?
            public var page: Int?
            public var pageSize: Int?
            public var previousPageUri: URL?
            public var start: Int?
            public var uri: URL?
            public var usageTriggers: [TwilioAPI.APIV2010AccountUsageUsageTrigger]?

            public init(end: Int? = nil, firstPageUri: URL? = nil, nextPageUri: URL? = nil, page: Int? = nil, pageSize: Int? = nil, previousPageUri: URL? = nil, start: Int? = nil, uri: URL? = nil, usageTriggers: [TwilioAPI.APIV2010AccountUsageUsageTrigger]? = nil) {
                self.end = end
                self.firstPageUri = firstPageUri
                self.nextPageUri = nextPageUri
                self.page = page
                self.pageSize = pageSize
                self.previousPageUri = previousPageUri
                self.start = start
                self.uri = uri
                self.usageTriggers = usageTriggers
            }

            private enum CodingKeys: String, CodingKey {
                case end
                case firstPageUri = "first_page_uri"
                case nextPageUri = "next_page_uri"
                case page
                case pageSize = "page_size"
                case previousPageUri = "previous_page_uri"
                case start
                case uri
                case usageTriggers = "usage_triggers"
            }
        }

        public struct GetParameters {
            public var recurring: Recurring?
            public var triggerBy: TriggerBy?
            public var usageCategory: UsageCategory?
            public var pageSize: Int?

            public enum Recurring: String, Codable, CaseIterable {
                case daily
                case monthly
                case yearly
                case alltime
            }

            public enum TriggerBy: String, Codable, CaseIterable {
                case count
                case usage
                case price
            }

            public enum UsageCategory: String, Codable, CaseIterable {
                case agentConference = "agent-conference"
                case answeringMachineDetection = "answering-machine-detection"
                case authyAuthentications = "authy-authentications"
                case authyCallsOutbound = "authy-calls-outbound"
                case authyMonthlyFees = "authy-monthly-fees"
                case authyPhoneIntelligence = "authy-phone-intelligence"
                case authyPhoneVerifications = "authy-phone-verifications"
                case authySmsOutbound = "authy-sms-outbound"
                case callProgessEvents = "call-progess-events"
                case calleridlookups
                case calls
                case callsClient = "calls-client"
                case callsGlobalconference = "calls-globalconference"
                case callsInbound = "calls-inbound"
                case callsInboundLocal = "calls-inbound-local"
                case callsInboundMobile = "calls-inbound-mobile"
                case callsInboundTollfree = "calls-inbound-tollfree"
                case callsOutbound = "calls-outbound"
                case callsPayVerbTransactions = "calls-pay-verb-transactions"
                case callsRecordings = "calls-recordings"
                case callsSip = "calls-sip"
                case callsSipInbound = "calls-sip-inbound"
                case callsSipOutbound = "calls-sip-outbound"
                case callsTransfers = "calls-transfers"
                case carrierLookups = "carrier-lookups"
                case conversations
                case conversationsAPIRequests = "conversations-api-requests"
                case conversationsConversationEvents = "conversations-conversation-events"
                case conversationsEndpointConnectivity = "conversations-endpoint-connectivity"
                case conversationsEvents = "conversations-events"
                case conversationsParticipantEvents = "conversations-participant-events"
                case conversationsParticipants = "conversations-participants"
                case cps
                case flexUsage = "flex-usage"
                case fraudLookups = "fraud-lookups"
                case groupRooms = "group-rooms"
                case groupRoomsDataTrack = "group-rooms-data-track"
                case groupRoomsEncryptedMediaRecorded = "group-rooms-encrypted-media-recorded"
                case groupRoomsMediaDownloaded = "group-rooms-media-downloaded"
                case groupRoomsMediaRecorded = "group-rooms-media-recorded"
                case groupRoomsMediaRouted = "group-rooms-media-routed"
                case groupRoomsMediaStored = "group-rooms-media-stored"
                case groupRoomsParticipantMinutes = "group-rooms-participant-minutes"
                case groupRoomsRecordedMinutes = "group-rooms-recorded-minutes"
                case impV1Usage = "imp-v1-usage"
                case lookups
                case marketplace
                case marketplaceAlgorithmiaNamedEntityRecognition = "marketplace-algorithmia-named-entity-recognition"
                case marketplaceCadenceTranscription = "marketplace-cadence-transcription"
                case marketplaceCadenceTranslation = "marketplace-cadence-translation"
                case marketplaceCapioSpeechToText = "marketplace-capio-speech-to-text"
                case marketplaceConvrizaAbaba = "marketplace-convriza-ababa"
                case marketplaceDeepgramPhraseDetector = "marketplace-deepgram-phrase-detector"
                case marketplaceDigitalSegmentBusinessInfo = "marketplace-digital-segment-business-info"
                case marketplaceFacebookOfflineConversions = "marketplace-facebook-offline-conversions"
                case marketplaceGoogleSpeechToText = "marketplace-google-speech-to-text"
                case marketplaceIbmWatsonMessageInsights = "marketplace-ibm-watson-message-insights"
                case marketplaceIbmWatsonMessageSentiment = "marketplace-ibm-watson-message-sentiment"
                case marketplaceIbmWatsonRecordingAnalysis = "marketplace-ibm-watson-recording-analysis"
                case marketplaceIbmWatsonToneAnalyzer = "marketplace-ibm-watson-tone-analyzer"
                case marketplaceIcehookSystemsScout = "marketplace-icehook-systems-scout"
                case marketplaceInfogroupDataaxleBizinfo = "marketplace-infogroup-dataaxle-bizinfo"
                case marketplaceKeenIoContactCenterAnalytics = "marketplace-keen-io-contact-center-analytics"
                case marketplaceMarchexCleancall = "marketplace-marchex-cleancall"
                case marketplaceMarchexSentimentAnalysisForSms = "marketplace-marchex-sentiment-analysis-for-sms"
                case marketplaceMarketplaceNextcallerSocialID = "marketplace-marketplace-nextcaller-social-id"
                case marketplaceMobileCommonsOptOutClassifier = "marketplace-mobile-commons-opt-out-classifier"
                case marketplaceNexiwaveVoicemailToText = "marketplace-nexiwave-voicemail-to-text"
                case marketplaceNextcallerAdvancedCallerIdentification = "marketplace-nextcaller-advanced-caller-identification"
                case marketplaceNomoroboSpamScore = "marketplace-nomorobo-spam-score"
                case marketplacePayfoneTcpaCompliance = "marketplace-payfone-tcpa-compliance"
                case marketplaceRemeetingAutomaticSpeechRecognition = "marketplace-remeeting-automatic-speech-recognition"
                case marketplaceTcpaDefenseSolutionsBlacklistFeed = "marketplace-tcpa-defense-solutions-blacklist-feed"
                case marketplaceTeloOpencnam = "marketplace-telo-opencnam"
                case marketplaceTruecnamTrueSpam = "marketplace-truecnam-true-spam"
                case marketplaceTwilioCallerNameLookupUs = "marketplace-twilio-caller-name-lookup-us"
                case marketplaceTwilioCarrierInformationLookup = "marketplace-twilio-carrier-information-lookup"
                case marketplaceVoicebasePci = "marketplace-voicebase-pci"
                case marketplaceVoicebaseTranscription = "marketplace-voicebase-transcription"
                case marketplaceVoicebaseTranscriptionCustomVocabulary = "marketplace-voicebase-transcription-custom-vocabulary"
                case marketplaceWhitepagesProCallerIdentification = "marketplace-whitepages-pro-caller-identification"
                case marketplaceWhitepagesProPhoneIntelligence = "marketplace-whitepages-pro-phone-intelligence"
                case marketplaceWhitepagesProPhoneReputation = "marketplace-whitepages-pro-phone-reputation"
                case marketplaceWolfarmSpokenResults = "marketplace-wolfarm-spoken-results"
                case marketplaceWolframShortAnswer = "marketplace-wolfram-short-answer"
                case marketplaceYticaContactCenterReportingAnalytics = "marketplace-ytica-contact-center-reporting-analytics"
                case mediastorage
                case mms
                case mmsInbound = "mms-inbound"
                case mmsInboundLongcode = "mms-inbound-longcode"
                case mmsInboundShortcode = "mms-inbound-shortcode"
                case mmsMessagesCarrierfees = "mms-messages-carrierfees"
                case mmsOutbound = "mms-outbound"
                case mmsOutboundLongcode = "mms-outbound-longcode"
                case mmsOutboundShortcode = "mms-outbound-shortcode"
                case monitorReads = "monitor-reads"
                case monitorStorage = "monitor-storage"
                case monitorWrites = "monitor-writes"
                case notify
                case notifyActionsAttempts = "notify-actions-attempts"
                case notifyChannels = "notify-channels"
                case numberFormatLookups = "number-format-lookups"
                case pchat
                case pchatUsers = "pchat-users"
                case peerToPeerRoomsParticipantMinutes = "peer-to-peer-rooms-participant-minutes"
                case pfax
                case pfaxMinutes = "pfax-minutes"
                case pfaxMinutesInbound = "pfax-minutes-inbound"
                case pfaxMinutesOutbound = "pfax-minutes-outbound"
                case pfaxPages = "pfax-pages"
                case phonenumbers
                case phonenumbersCps = "phonenumbers-cps"
                case phonenumbersEmergency = "phonenumbers-emergency"
                case phonenumbersLocal = "phonenumbers-local"
                case phonenumbersMobile = "phonenumbers-mobile"
                case phonenumbersSetups = "phonenumbers-setups"
                case phonenumbersTollfree = "phonenumbers-tollfree"
                case premiumsupport
                case proxy
                case proxyActiveSessions = "proxy-active-sessions"
                case pstnconnectivity
                case pv
                case pvCompositionMediaDownloaded = "pv-composition-media-downloaded"
                case pvCompositionMediaEncrypted = "pv-composition-media-encrypted"
                case pvCompositionMediaStored = "pv-composition-media-stored"
                case pvCompositionMinutes = "pv-composition-minutes"
                case pvRecordingCompositions = "pv-recording-compositions"
                case pvRoomParticipants = "pv-room-participants"
                case pvRoomParticipantsAu1 = "pv-room-participants-au1"
                case pvRoomParticipantsBr1 = "pv-room-participants-br1"
                case pvRoomParticipantsIe1 = "pv-room-participants-ie1"
                case pvRoomParticipantsJp1 = "pv-room-participants-jp1"
                case pvRoomParticipantsSg1 = "pv-room-participants-sg1"
                case pvRoomParticipantsUs1 = "pv-room-participants-us1"
                case pvRoomParticipantsUs2 = "pv-room-participants-us2"
                case pvRooms = "pv-rooms"
                case pvSipEndpointRegistrations = "pv-sip-endpoint-registrations"
                case recordings
                case recordingstorage
                case roomsGroupBandwidth = "rooms-group-bandwidth"
                case roomsGroupMinutes = "rooms-group-minutes"
                case roomsPeerToPeerMinutes = "rooms-peer-to-peer-minutes"
                case shortcodes
                case shortcodesCustomerowned = "shortcodes-customerowned"
                case shortcodesMmsEnablement = "shortcodes-mms-enablement"
                case shortcodesMps = "shortcodes-mps"
                case shortcodesRandom = "shortcodes-random"
                case shortcodesUk = "shortcodes-uk"
                case shortcodesVanity = "shortcodes-vanity"
                case smallGroupRooms = "small-group-rooms"
                case smallGroupRoomsDataTrack = "small-group-rooms-data-track"
                case smallGroupRoomsParticipantMinutes = "small-group-rooms-participant-minutes"
                case sms
                case smsInbound = "sms-inbound"
                case smsInboundLongcode = "sms-inbound-longcode"
                case smsInboundShortcode = "sms-inbound-shortcode"
                case smsMessagesCarrierfees = "sms-messages-carrierfees"
                case smsMessagesFeatures = "sms-messages-features"
                case smsMessagesFeaturesSenderid = "sms-messages-features-senderid"
                case smsOutbound = "sms-outbound"
                case smsOutboundContentInspection = "sms-outbound-content-inspection"
                case smsOutboundLongcode = "sms-outbound-longcode"
                case smsOutboundShortcode = "sms-outbound-shortcode"
                case speechRecognition = "speech-recognition"
                case studioEngagements = "studio-engagements"
                case sync
                case syncActions = "sync-actions"
                case syncEndpointHours = "sync-endpoint-hours"
                case syncEndpointHoursAboveDailyCap = "sync-endpoint-hours-above-daily-cap"
                case taskrouterTasks = "taskrouter-tasks"
                case totalprice
                case transcriptions
                case trunkingCps = "trunking-cps"
                case trunkingEmergencyCalls = "trunking-emergency-calls"
                case trunkingOrigination = "trunking-origination"
                case trunkingOriginationLocal = "trunking-origination-local"
                case trunkingOriginationMobile = "trunking-origination-mobile"
                case trunkingOriginationTollfree = "trunking-origination-tollfree"
                case trunkingRecordings = "trunking-recordings"
                case trunkingSecure = "trunking-secure"
                case trunkingTermination = "trunking-termination"
                case turnmegabytes
                case turnmegabytesAustralia = "turnmegabytes-australia"
                case turnmegabytesBrasil = "turnmegabytes-brasil"
                case turnmegabytesGermany = "turnmegabytes-germany"
                case turnmegabytesIndia = "turnmegabytes-india"
                case turnmegabytesIreland = "turnmegabytes-ireland"
                case turnmegabytesJapan = "turnmegabytes-japan"
                case turnmegabytesSingapore = "turnmegabytes-singapore"
                case turnmegabytesUseast = "turnmegabytes-useast"
                case turnmegabytesUswest = "turnmegabytes-uswest"
                case twilioInterconnect = "twilio-interconnect"
                case verifyPush = "verify-push"
                case videoRecordings = "video-recordings"
                case voiceInsights = "voice-insights"
                case voiceInsightsClientInsightsOnDemandMinute = "voice-insights-client-insights-on-demand-minute"
                case voiceInsightsPtsnInsightsOnDemandMinute = "voice-insights-ptsn-insights-on-demand-minute"
                case voiceInsightsSipInterfaceInsightsOnDemandMinute = "voice-insights-sip-interface-insights-on-demand-minute"
                case voiceInsightsSipTrunkingInsightsOnDemandMinute = "voice-insights-sip-trunking-insights-on-demand-minute"
                case wireless
                case wirelessOrders = "wireless-orders"
                case wirelessOrdersArtwork = "wireless-orders-artwork"
                case wirelessOrdersBulk = "wireless-orders-bulk"
                case wirelessOrdersEsim = "wireless-orders-esim"
                case wirelessOrdersStarter = "wireless-orders-starter"
                case wirelessUsage = "wireless-usage"
                case wirelessUsageCommands = "wireless-usage-commands"
                case wirelessUsageCommandsAfrica = "wireless-usage-commands-africa"
                case wirelessUsageCommandsAsia = "wireless-usage-commands-asia"
                case wirelessUsageCommandsCentralandsouthamerica = "wireless-usage-commands-centralandsouthamerica"
                case wirelessUsageCommandsEurope = "wireless-usage-commands-europe"
                case wirelessUsageCommandsHome = "wireless-usage-commands-home"
                case wirelessUsageCommandsNorthamerica = "wireless-usage-commands-northamerica"
                case wirelessUsageCommandsOceania = "wireless-usage-commands-oceania"
                case wirelessUsageCommandsRoaming = "wireless-usage-commands-roaming"
                case wirelessUsageData = "wireless-usage-data"
                case wirelessUsageDataAfrica = "wireless-usage-data-africa"
                case wirelessUsageDataAsia = "wireless-usage-data-asia"
                case wirelessUsageDataCentralandsouthamerica = "wireless-usage-data-centralandsouthamerica"
                case wirelessUsageDataCustomAdditionalmb = "wireless-usage-data-custom-additionalmb"
                case wirelessUsageDataCustomFirst5mb = "wireless-usage-data-custom-first5mb"
                case wirelessUsageDataDomesticRoaming = "wireless-usage-data-domestic-roaming"
                case wirelessUsageDataEurope = "wireless-usage-data-europe"
                case wirelessUsageDataIndividualAdditionalgb = "wireless-usage-data-individual-additionalgb"
                case wirelessUsageDataIndividualFirstgb = "wireless-usage-data-individual-firstgb"
                case wirelessUsageDataInternationalRoamingCanada = "wireless-usage-data-international-roaming-canada"
                case wirelessUsageDataInternationalRoamingIndia = "wireless-usage-data-international-roaming-india"
                case wirelessUsageDataInternationalRoamingMexico = "wireless-usage-data-international-roaming-mexico"
                case wirelessUsageDataNorthamerica = "wireless-usage-data-northamerica"
                case wirelessUsageDataOceania = "wireless-usage-data-oceania"
                case wirelessUsageDataPooled = "wireless-usage-data-pooled"
                case wirelessUsageDataPooledDownlink = "wireless-usage-data-pooled-downlink"
                case wirelessUsageDataPooledUplink = "wireless-usage-data-pooled-uplink"
                case wirelessUsageMrc = "wireless-usage-mrc"
                case wirelessUsageMrcCustom = "wireless-usage-mrc-custom"
                case wirelessUsageMrcIndividual = "wireless-usage-mrc-individual"
                case wirelessUsageMrcPooled = "wireless-usage-mrc-pooled"
                case wirelessUsageMrcSuspended = "wireless-usage-mrc-suspended"
                case wirelessUsageSms = "wireless-usage-sms"
                case wirelessUsageVoice = "wireless-usage-voice"
            }

            public init(recurring: Recurring? = nil, triggerBy: TriggerBy? = nil, usageCategory: UsageCategory? = nil, pageSize: Int? = nil) {
                self.recurring = recurring
                self.triggerBy = triggerBy
                self.usageCategory = usageCategory
                self.pageSize = pageSize
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("Recurring", recurring?.asQueryValue)
                query.addQueryItem("TriggerBy", triggerBy?.asQueryValue)
                query.addQueryItem("UsageCategory", usageCategory?.asQueryValue)
                query.addQueryItem("PageSize", pageSize?.asQueryValue)
                return query
            }
        }

        /// Create a new UsageTrigger
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountUsageUsageTrigger> {
            .post(path, body: body?.asQuery())
        }

        /// CreateUsageTriggerRequest
        public struct PostRequest: Encodable {
            /// The HTTP method we should use to call `callback_url`. Can be: `GET` or `POST` and the default is `POST`.
            public var callbackMethod: CallbackMethod?
            /// The URL we should call using `callback_method` when the trigger fires.
            public var callbackURL: URL
            /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
            public var friendlyName: String?
            /// The frequency of a recurring UsageTrigger.  Can be: `daily`, `monthly`, or `yearly` for recurring triggers or empty for non-recurring triggers. A trigger will only fire once during each period. Recurring times are in GMT.
            public var recurring: Recurring?
            /// The field in the [UsageRecord](https://www.twilio.com/docs/usage/api/usage-record) resource that should fire the trigger.  Can be: `count`, `usage`, or `price` as described in the [UsageRecords documentation](https://www.twilio.com/docs/usage/api/usage-record#usage-count-price).  The default is `usage`.
            public var triggerBy: TriggerBy?
            /// The usage value at which the trigger should fire.  For convenience, you can use an offset value such as `+30` to specify a trigger_value that is 30 units more than the current usage value. Be sure to urlencode a `+` as `%2B`.
            public var triggerValue: String
            /// The usage category that the trigger should watch.  Use one of the supported [usage categories](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) for this value.
            public var usageCategory: UsageCategory

            /// The HTTP method we should use to call `callback_url`. Can be: `GET` or `POST` and the default is `POST`.
            public enum CallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            /// The frequency of a recurring UsageTrigger.  Can be: `daily`, `monthly`, or `yearly` for recurring triggers or empty for non-recurring triggers. A trigger will only fire once during each period. Recurring times are in GMT.
            public enum Recurring: String, Codable, CaseIterable {
                case daily
                case monthly
                case yearly
                case alltime
            }

            /// The field in the [UsageRecord](https://www.twilio.com/docs/usage/api/usage-record) resource that should fire the trigger.  Can be: `count`, `usage`, or `price` as described in the [UsageRecords documentation](https://www.twilio.com/docs/usage/api/usage-record#usage-count-price).  The default is `usage`.
            public enum TriggerBy: String, Codable, CaseIterable {
                case count
                case usage
                case price
            }

            /// The usage category that the trigger should watch.  Use one of the supported [usage categories](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) for this value.
            public enum UsageCategory: String, Codable, CaseIterable {
                case agentConference = "agent-conference"
                case answeringMachineDetection = "answering-machine-detection"
                case authyAuthentications = "authy-authentications"
                case authyCallsOutbound = "authy-calls-outbound"
                case authyMonthlyFees = "authy-monthly-fees"
                case authyPhoneIntelligence = "authy-phone-intelligence"
                case authyPhoneVerifications = "authy-phone-verifications"
                case authySmsOutbound = "authy-sms-outbound"
                case callProgessEvents = "call-progess-events"
                case calleridlookups
                case calls
                case callsClient = "calls-client"
                case callsGlobalconference = "calls-globalconference"
                case callsInbound = "calls-inbound"
                case callsInboundLocal = "calls-inbound-local"
                case callsInboundMobile = "calls-inbound-mobile"
                case callsInboundTollfree = "calls-inbound-tollfree"
                case callsOutbound = "calls-outbound"
                case callsPayVerbTransactions = "calls-pay-verb-transactions"
                case callsRecordings = "calls-recordings"
                case callsSip = "calls-sip"
                case callsSipInbound = "calls-sip-inbound"
                case callsSipOutbound = "calls-sip-outbound"
                case callsTransfers = "calls-transfers"
                case carrierLookups = "carrier-lookups"
                case conversations
                case conversationsAPIRequests = "conversations-api-requests"
                case conversationsConversationEvents = "conversations-conversation-events"
                case conversationsEndpointConnectivity = "conversations-endpoint-connectivity"
                case conversationsEvents = "conversations-events"
                case conversationsParticipantEvents = "conversations-participant-events"
                case conversationsParticipants = "conversations-participants"
                case cps
                case flexUsage = "flex-usage"
                case fraudLookups = "fraud-lookups"
                case groupRooms = "group-rooms"
                case groupRoomsDataTrack = "group-rooms-data-track"
                case groupRoomsEncryptedMediaRecorded = "group-rooms-encrypted-media-recorded"
                case groupRoomsMediaDownloaded = "group-rooms-media-downloaded"
                case groupRoomsMediaRecorded = "group-rooms-media-recorded"
                case groupRoomsMediaRouted = "group-rooms-media-routed"
                case groupRoomsMediaStored = "group-rooms-media-stored"
                case groupRoomsParticipantMinutes = "group-rooms-participant-minutes"
                case groupRoomsRecordedMinutes = "group-rooms-recorded-minutes"
                case impV1Usage = "imp-v1-usage"
                case lookups
                case marketplace
                case marketplaceAlgorithmiaNamedEntityRecognition = "marketplace-algorithmia-named-entity-recognition"
                case marketplaceCadenceTranscription = "marketplace-cadence-transcription"
                case marketplaceCadenceTranslation = "marketplace-cadence-translation"
                case marketplaceCapioSpeechToText = "marketplace-capio-speech-to-text"
                case marketplaceConvrizaAbaba = "marketplace-convriza-ababa"
                case marketplaceDeepgramPhraseDetector = "marketplace-deepgram-phrase-detector"
                case marketplaceDigitalSegmentBusinessInfo = "marketplace-digital-segment-business-info"
                case marketplaceFacebookOfflineConversions = "marketplace-facebook-offline-conversions"
                case marketplaceGoogleSpeechToText = "marketplace-google-speech-to-text"
                case marketplaceIbmWatsonMessageInsights = "marketplace-ibm-watson-message-insights"
                case marketplaceIbmWatsonMessageSentiment = "marketplace-ibm-watson-message-sentiment"
                case marketplaceIbmWatsonRecordingAnalysis = "marketplace-ibm-watson-recording-analysis"
                case marketplaceIbmWatsonToneAnalyzer = "marketplace-ibm-watson-tone-analyzer"
                case marketplaceIcehookSystemsScout = "marketplace-icehook-systems-scout"
                case marketplaceInfogroupDataaxleBizinfo = "marketplace-infogroup-dataaxle-bizinfo"
                case marketplaceKeenIoContactCenterAnalytics = "marketplace-keen-io-contact-center-analytics"
                case marketplaceMarchexCleancall = "marketplace-marchex-cleancall"
                case marketplaceMarchexSentimentAnalysisForSms = "marketplace-marchex-sentiment-analysis-for-sms"
                case marketplaceMarketplaceNextcallerSocialID = "marketplace-marketplace-nextcaller-social-id"
                case marketplaceMobileCommonsOptOutClassifier = "marketplace-mobile-commons-opt-out-classifier"
                case marketplaceNexiwaveVoicemailToText = "marketplace-nexiwave-voicemail-to-text"
                case marketplaceNextcallerAdvancedCallerIdentification = "marketplace-nextcaller-advanced-caller-identification"
                case marketplaceNomoroboSpamScore = "marketplace-nomorobo-spam-score"
                case marketplacePayfoneTcpaCompliance = "marketplace-payfone-tcpa-compliance"
                case marketplaceRemeetingAutomaticSpeechRecognition = "marketplace-remeeting-automatic-speech-recognition"
                case marketplaceTcpaDefenseSolutionsBlacklistFeed = "marketplace-tcpa-defense-solutions-blacklist-feed"
                case marketplaceTeloOpencnam = "marketplace-telo-opencnam"
                case marketplaceTruecnamTrueSpam = "marketplace-truecnam-true-spam"
                case marketplaceTwilioCallerNameLookupUs = "marketplace-twilio-caller-name-lookup-us"
                case marketplaceTwilioCarrierInformationLookup = "marketplace-twilio-carrier-information-lookup"
                case marketplaceVoicebasePci = "marketplace-voicebase-pci"
                case marketplaceVoicebaseTranscription = "marketplace-voicebase-transcription"
                case marketplaceVoicebaseTranscriptionCustomVocabulary = "marketplace-voicebase-transcription-custom-vocabulary"
                case marketplaceWhitepagesProCallerIdentification = "marketplace-whitepages-pro-caller-identification"
                case marketplaceWhitepagesProPhoneIntelligence = "marketplace-whitepages-pro-phone-intelligence"
                case marketplaceWhitepagesProPhoneReputation = "marketplace-whitepages-pro-phone-reputation"
                case marketplaceWolfarmSpokenResults = "marketplace-wolfarm-spoken-results"
                case marketplaceWolframShortAnswer = "marketplace-wolfram-short-answer"
                case marketplaceYticaContactCenterReportingAnalytics = "marketplace-ytica-contact-center-reporting-analytics"
                case mediastorage
                case mms
                case mmsInbound = "mms-inbound"
                case mmsInboundLongcode = "mms-inbound-longcode"
                case mmsInboundShortcode = "mms-inbound-shortcode"
                case mmsMessagesCarrierfees = "mms-messages-carrierfees"
                case mmsOutbound = "mms-outbound"
                case mmsOutboundLongcode = "mms-outbound-longcode"
                case mmsOutboundShortcode = "mms-outbound-shortcode"
                case monitorReads = "monitor-reads"
                case monitorStorage = "monitor-storage"
                case monitorWrites = "monitor-writes"
                case notify
                case notifyActionsAttempts = "notify-actions-attempts"
                case notifyChannels = "notify-channels"
                case numberFormatLookups = "number-format-lookups"
                case pchat
                case pchatUsers = "pchat-users"
                case peerToPeerRoomsParticipantMinutes = "peer-to-peer-rooms-participant-minutes"
                case pfax
                case pfaxMinutes = "pfax-minutes"
                case pfaxMinutesInbound = "pfax-minutes-inbound"
                case pfaxMinutesOutbound = "pfax-minutes-outbound"
                case pfaxPages = "pfax-pages"
                case phonenumbers
                case phonenumbersCps = "phonenumbers-cps"
                case phonenumbersEmergency = "phonenumbers-emergency"
                case phonenumbersLocal = "phonenumbers-local"
                case phonenumbersMobile = "phonenumbers-mobile"
                case phonenumbersSetups = "phonenumbers-setups"
                case phonenumbersTollfree = "phonenumbers-tollfree"
                case premiumsupport
                case proxy
                case proxyActiveSessions = "proxy-active-sessions"
                case pstnconnectivity
                case pv
                case pvCompositionMediaDownloaded = "pv-composition-media-downloaded"
                case pvCompositionMediaEncrypted = "pv-composition-media-encrypted"
                case pvCompositionMediaStored = "pv-composition-media-stored"
                case pvCompositionMinutes = "pv-composition-minutes"
                case pvRecordingCompositions = "pv-recording-compositions"
                case pvRoomParticipants = "pv-room-participants"
                case pvRoomParticipantsAu1 = "pv-room-participants-au1"
                case pvRoomParticipantsBr1 = "pv-room-participants-br1"
                case pvRoomParticipantsIe1 = "pv-room-participants-ie1"
                case pvRoomParticipantsJp1 = "pv-room-participants-jp1"
                case pvRoomParticipantsSg1 = "pv-room-participants-sg1"
                case pvRoomParticipantsUs1 = "pv-room-participants-us1"
                case pvRoomParticipantsUs2 = "pv-room-participants-us2"
                case pvRooms = "pv-rooms"
                case pvSipEndpointRegistrations = "pv-sip-endpoint-registrations"
                case recordings
                case recordingstorage
                case roomsGroupBandwidth = "rooms-group-bandwidth"
                case roomsGroupMinutes = "rooms-group-minutes"
                case roomsPeerToPeerMinutes = "rooms-peer-to-peer-minutes"
                case shortcodes
                case shortcodesCustomerowned = "shortcodes-customerowned"
                case shortcodesMmsEnablement = "shortcodes-mms-enablement"
                case shortcodesMps = "shortcodes-mps"
                case shortcodesRandom = "shortcodes-random"
                case shortcodesUk = "shortcodes-uk"
                case shortcodesVanity = "shortcodes-vanity"
                case smallGroupRooms = "small-group-rooms"
                case smallGroupRoomsDataTrack = "small-group-rooms-data-track"
                case smallGroupRoomsParticipantMinutes = "small-group-rooms-participant-minutes"
                case sms
                case smsInbound = "sms-inbound"
                case smsInboundLongcode = "sms-inbound-longcode"
                case smsInboundShortcode = "sms-inbound-shortcode"
                case smsMessagesCarrierfees = "sms-messages-carrierfees"
                case smsMessagesFeatures = "sms-messages-features"
                case smsMessagesFeaturesSenderid = "sms-messages-features-senderid"
                case smsOutbound = "sms-outbound"
                case smsOutboundContentInspection = "sms-outbound-content-inspection"
                case smsOutboundLongcode = "sms-outbound-longcode"
                case smsOutboundShortcode = "sms-outbound-shortcode"
                case speechRecognition = "speech-recognition"
                case studioEngagements = "studio-engagements"
                case sync
                case syncActions = "sync-actions"
                case syncEndpointHours = "sync-endpoint-hours"
                case syncEndpointHoursAboveDailyCap = "sync-endpoint-hours-above-daily-cap"
                case taskrouterTasks = "taskrouter-tasks"
                case totalprice
                case transcriptions
                case trunkingCps = "trunking-cps"
                case trunkingEmergencyCalls = "trunking-emergency-calls"
                case trunkingOrigination = "trunking-origination"
                case trunkingOriginationLocal = "trunking-origination-local"
                case trunkingOriginationMobile = "trunking-origination-mobile"
                case trunkingOriginationTollfree = "trunking-origination-tollfree"
                case trunkingRecordings = "trunking-recordings"
                case trunkingSecure = "trunking-secure"
                case trunkingTermination = "trunking-termination"
                case turnmegabytes
                case turnmegabytesAustralia = "turnmegabytes-australia"
                case turnmegabytesBrasil = "turnmegabytes-brasil"
                case turnmegabytesGermany = "turnmegabytes-germany"
                case turnmegabytesIndia = "turnmegabytes-india"
                case turnmegabytesIreland = "turnmegabytes-ireland"
                case turnmegabytesJapan = "turnmegabytes-japan"
                case turnmegabytesSingapore = "turnmegabytes-singapore"
                case turnmegabytesUseast = "turnmegabytes-useast"
                case turnmegabytesUswest = "turnmegabytes-uswest"
                case twilioInterconnect = "twilio-interconnect"
                case verifyPush = "verify-push"
                case videoRecordings = "video-recordings"
                case voiceInsights = "voice-insights"
                case voiceInsightsClientInsightsOnDemandMinute = "voice-insights-client-insights-on-demand-minute"
                case voiceInsightsPtsnInsightsOnDemandMinute = "voice-insights-ptsn-insights-on-demand-minute"
                case voiceInsightsSipInterfaceInsightsOnDemandMinute = "voice-insights-sip-interface-insights-on-demand-minute"
                case voiceInsightsSipTrunkingInsightsOnDemandMinute = "voice-insights-sip-trunking-insights-on-demand-minute"
                case wireless
                case wirelessOrders = "wireless-orders"
                case wirelessOrdersArtwork = "wireless-orders-artwork"
                case wirelessOrdersBulk = "wireless-orders-bulk"
                case wirelessOrdersEsim = "wireless-orders-esim"
                case wirelessOrdersStarter = "wireless-orders-starter"
                case wirelessUsage = "wireless-usage"
                case wirelessUsageCommands = "wireless-usage-commands"
                case wirelessUsageCommandsAfrica = "wireless-usage-commands-africa"
                case wirelessUsageCommandsAsia = "wireless-usage-commands-asia"
                case wirelessUsageCommandsCentralandsouthamerica = "wireless-usage-commands-centralandsouthamerica"
                case wirelessUsageCommandsEurope = "wireless-usage-commands-europe"
                case wirelessUsageCommandsHome = "wireless-usage-commands-home"
                case wirelessUsageCommandsNorthamerica = "wireless-usage-commands-northamerica"
                case wirelessUsageCommandsOceania = "wireless-usage-commands-oceania"
                case wirelessUsageCommandsRoaming = "wireless-usage-commands-roaming"
                case wirelessUsageData = "wireless-usage-data"
                case wirelessUsageDataAfrica = "wireless-usage-data-africa"
                case wirelessUsageDataAsia = "wireless-usage-data-asia"
                case wirelessUsageDataCentralandsouthamerica = "wireless-usage-data-centralandsouthamerica"
                case wirelessUsageDataCustomAdditionalmb = "wireless-usage-data-custom-additionalmb"
                case wirelessUsageDataCustomFirst5mb = "wireless-usage-data-custom-first5mb"
                case wirelessUsageDataDomesticRoaming = "wireless-usage-data-domestic-roaming"
                case wirelessUsageDataEurope = "wireless-usage-data-europe"
                case wirelessUsageDataIndividualAdditionalgb = "wireless-usage-data-individual-additionalgb"
                case wirelessUsageDataIndividualFirstgb = "wireless-usage-data-individual-firstgb"
                case wirelessUsageDataInternationalRoamingCanada = "wireless-usage-data-international-roaming-canada"
                case wirelessUsageDataInternationalRoamingIndia = "wireless-usage-data-international-roaming-india"
                case wirelessUsageDataInternationalRoamingMexico = "wireless-usage-data-international-roaming-mexico"
                case wirelessUsageDataNorthamerica = "wireless-usage-data-northamerica"
                case wirelessUsageDataOceania = "wireless-usage-data-oceania"
                case wirelessUsageDataPooled = "wireless-usage-data-pooled"
                case wirelessUsageDataPooledDownlink = "wireless-usage-data-pooled-downlink"
                case wirelessUsageDataPooledUplink = "wireless-usage-data-pooled-uplink"
                case wirelessUsageMrc = "wireless-usage-mrc"
                case wirelessUsageMrcCustom = "wireless-usage-mrc-custom"
                case wirelessUsageMrcIndividual = "wireless-usage-mrc-individual"
                case wirelessUsageMrcPooled = "wireless-usage-mrc-pooled"
                case wirelessUsageMrcSuspended = "wireless-usage-mrc-suspended"
                case wirelessUsageSms = "wireless-usage-sms"
                case wirelessUsageVoice = "wireless-usage-voice"
            }

            public init(callbackMethod: CallbackMethod? = nil, callbackURL: URL, friendlyName: String? = nil, recurring: Recurring? = nil, triggerBy: TriggerBy? = nil, triggerValue: String, usageCategory: UsageCategory) {
                self.callbackMethod = callbackMethod
                self.callbackURL = callbackURL
                self.friendlyName = friendlyName
                self.recurring = recurring
                self.triggerBy = triggerBy
                self.triggerValue = triggerValue
                self.usageCategory = usageCategory
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("CallbackMethod", callbackMethod?.asQueryValue)
                query.addQueryItem("CallbackUrl", callbackURL.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("Recurring", recurring?.asQueryValue)
                query.addQueryItem("TriggerBy", triggerBy?.asQueryValue)
                query.addQueryItem("TriggerValue", triggerValue.asQueryValue)
                query.addQueryItem("UsageCategory", usageCategory.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Accounts.WithAccountSid.Usage {
    public var triggers: Triggers {
        Triggers(path: path + "/Triggers")
    }

    public struct Triggers {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Usage/Triggers`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountSid.Usage.Triggers {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json`
        public let path: String

        /// Fetch and instance of a usage-trigger
        public var get: Request<TwilioAPI.APIV2010AccountUsageUsageTrigger> {
            .get(path)
        }

        /// Update an instance of a usage trigger
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010AccountUsageUsageTrigger> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateUsageTriggerRequest
        public struct PostRequest: Encodable {
            /// The HTTP method we should use to call `callback_url`. Can be: `GET` or `POST` and the default is `POST`.
            public var callbackMethod: CallbackMethod?
            /// The URL we should call using `callback_method` when the trigger fires.
            public var callbackURL: URL?
            /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
            public var friendlyName: String?

            /// The HTTP method we should use to call `callback_url`. Can be: `GET` or `POST` and the default is `POST`.
            public enum CallbackMethod: String, Codable, CaseIterable {
                case head = "HEAD"
                case get = "GET"
                case post = "POST"
                case patch = "PATCH"
                case put = "PUT"
                case delete = "DELETE"
            }

            public init(callbackMethod: CallbackMethod? = nil, callbackURL: URL? = nil, friendlyName: String? = nil) {
                self.callbackMethod = callbackMethod
                self.callbackURL = callbackURL
                self.friendlyName = friendlyName
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("CallbackMethod", callbackMethod?.asQueryValue)
                query.addQueryItem("CallbackUrl", callbackURL?.asQueryValue)
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts {
    public func sid(_ sid: String) -> WithJSON {
        WithJSON(path: "\(path)/\(sid).json")
    }

    public struct WithJSON {
        /// Path: `/2010-04-01/Accounts/{Sid}.json`
        public let path: String

        /// Fetch the account specified by the provided Account Sid
        public var get: Request<TwilioAPI.APIV2010Account> {
            .get(path)
        }

        /// Modify the properties of a given Account
        public func post(_ body: PostRequest? = nil) -> Request<TwilioAPI.APIV2010Account> {
            .post(path, body: body?.asQuery())
        }

        /// UpdateAccountRequest
        public struct PostRequest: Encodable {
            /// Update the human-readable description of this Account
            public var friendlyName: String?
            /// Alter the status of this account: use `closed` to irreversibly close this account, `suspended` to temporarily suspend it, or `active` to reactivate it.
            public var status: Status?

            /// Alter the status of this account: use `closed` to irreversibly close this account, `suspended` to temporarily suspend it, or `active` to reactivate it.
            public enum Status: String, Codable, CaseIterable {
                case active
                case suspended
                case closed
            }

            public init(friendlyName: String? = nil, status: Status? = nil) {
                self.friendlyName = friendlyName
                self.status = status
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("FriendlyName", friendlyName?.asQueryValue)
                query.addQueryItem("Status", status?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

public enum Paths {}

extension Bool {
    var asQueryValue: String {
        self ? "true" : "false"
    }
}

extension Date {
    var asQueryValue: String {
        ISO8601DateFormatter().string(from: self)
    }
}

extension Double {
    var asQueryValue: String {
        String(self)
    }
}

extension Int {
    var asQueryValue: String {
        String(self)
    }
}

extension Int32 {
    var asQueryValue: String {
        String(self)
    }
}

extension Int64 {
    var asQueryValue: String {
        String(self)
    }
}

extension NaiveDate {
    var asQueryValue: String {
        String(self)
    }
}

extension String {
    var asQueryValue: String {
        self
    }
}

extension URL {
    var asQueryValue: String {
        absoluteString
    }
}

extension RawRepresentable where RawValue == String {
    var asQueryValue: String {
        rawValue
    }
}

extension Array where Element == (String, String?) {
    mutating func addQueryItem(_ name: String, _ value: String?) {
        guard let value = value, !value.isEmpty else { return }
        append((name, value))
    }

    var asPercentEncodedQuery: String {
        var components = URLComponents()
        components.queryItems = self.map(URLQueryItem.init)
        return components.percentEncodedQuery ?? ""
    }
}
