// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

public struct A2pUpgradeLeaseDto: Codable {
    public var id: Int?
    public var a2pType: A2pType?
    public var campaignID: String?
    public var brandID: String?
    public var invoiceID: Int?
    public var prepaidDiscountID: Int?
    public var isCanceled: Bool?
    public var isDeleted: Bool?
    public var blocked: Date?
    public var isPackaged: Bool?
    public var nextBilling: Date?
    public var createdAt: Date?
    public var updatedAt: Date?
    public var type: `Type`?
    public var upgradedSmsRateLimit: Int?
    public var upgradedMmsRateLimit: Int?
    public var price: Double?

    public enum A2pType: String, Codable, CaseIterable {
        case a2pRegular = "A2P_REGULAR"
        case a2pLite = "A2P_LITE"
    }

    public enum `Type`: String, Codable, CaseIterable {
        case plan = "PLAN"
        case extra = "EXTRA"
    }

    public init(id: Int? = nil, a2pType: A2pType? = nil, campaignID: String? = nil, brandID: String? = nil, invoiceID: Int? = nil, prepaidDiscountID: Int? = nil, isCanceled: Bool? = nil, isDeleted: Bool? = nil, blocked: Date? = nil, isPackaged: Bool? = nil, nextBilling: Date? = nil, createdAt: Date? = nil, updatedAt: Date? = nil, type: `Type`? = nil, upgradedSmsRateLimit: Int? = nil, upgradedMmsRateLimit: Int? = nil, price: Double? = nil) {
        self.id = id
        self.a2pType = a2pType
        self.campaignID = campaignID
        self.brandID = brandID
        self.invoiceID = invoiceID
        self.prepaidDiscountID = prepaidDiscountID
        self.isCanceled = isCanceled
        self.isDeleted = isDeleted
        self.blocked = blocked
        self.isPackaged = isPackaged
        self.nextBilling = nextBilling
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.type = type
        self.upgradedSmsRateLimit = upgradedSmsRateLimit
        self.upgradedMmsRateLimit = upgradedMmsRateLimit
        self.price = price
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case a2pType
        case campaignID = "campaignId"
        case brandID = "brandId"
        case invoiceID = "invoiceId"
        case prepaidDiscountID = "prepaidDiscountId"
        case isCanceled = "canceled"
        case isDeleted = "deleted"
        case blocked
        case isPackaged = "packaged"
        case nextBilling
        case createdAt
        case updatedAt
        case type
        case upgradedSmsRateLimit
        case upgradedMmsRateLimit
        case price
    }
}

public struct A2pUpgradeLeasePage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [A2pUpgradeLeaseDto]?

    public init(page: Page, items: [A2pUpgradeLeaseDto]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([A2pUpgradeLeaseDto].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// Object represents user account in Callfire system
public final class Account: Codable {
    public var soaAccount: Account?
    public var country: Country?
    public var locale: Locale?
    public var timeZone: TimeZone?
    /// Name associated with an account
    public var name: String?
    public var key: String?
    /// An id of an account
    public var id: Int?
    public var isActive: Bool?
    public var created: Date?
    public var brand: Brand?
    public var isAllowedToCreateCampaign: Bool?
    public var isEz: Bool?
    public var isAgencyManagedAccounts: Bool?
    public var dateTimeZone: DateTimeZone?
    public var defaultNumberID: Int?
    public var industry: Industry?
    public var trustLevel: TrustLevel?
    public var outboundThreshold: Int?
    public var textOutboundThreshold: Int?
    public var countryOrDefault: CountryOrDefault?
    public var timeZoneID: ZoneID?
    public var website: String?
    public var localTimeZoneRestriction: LocalTimeZoneRestriction?
    public var isStartCapable: Bool?
    public var isAutoAddDoNotContact: Bool?
    public var isScrub: Bool?
    public var messageClass: String?
    public var uiContext: String?
    public var failedVerificationAttempts: Int?
    public var sharedShortCodeID: Int?
    public var isSharedShortCodeAllowed: Bool?
    public var isCanceled: Bool?
    public var apiCallLimit: Int?
    public var defaultNotificationTtlMillis: Int?
    public var tsrAgreement: Date?
    public var tsrInitials: String?
    public var isReceiverPeriodEnabled: Bool?
    public var receiverPeriodGlobal: Int?
    public var receiverPeriodCall: Int?
    public var receiverPeriodText: Int?
    public var receiverPeriodTimeUnit: ReceiverPeriodTimeUnit?
    public var isRetainOnlyMetadata: Bool?
    public var maxAgents: Int?
    public var retainOnlyMetadataLastModified: Date?
    public var retainOnlyMetadataLastDetailRecordID: Int?
    public var fromNumberPool: String?
    public var industryName: String?
    public var status: Status?
    public var age: Duration?
    public var isUniversal: Bool?

    public enum Country: String, Codable, CaseIterable {
        case us = "US"
        case ca = "CA"
    }

    public enum Brand: String, Codable, CaseIterable {
        case eztexting = "EZTEXTING"
        case clubtexting = "CLUBTEXTING"
        case grouptexting = "GROUPTEXTING"
        case tellmycell = "TELLMYCELL"
        case ez = "EZ"
        case callfire = "CALLFIRE"
        case tesla = "TESLA"
    }

    public enum Industry: String, Codable, CaseIterable {
        case unknown = "UNKNOWN"
        case advertising = "ADVERTISING"
        case automotive = "AUTOMOTIVE"
        case collections = "COLLECTIONS"
        case consulting = "CONSULTING"
        case decline = "DECLINE"
        case education = "EDUCATION"
        case emergency = "EMERGENCY"
        case entertainment = "ENTERTAINMENT"
        case finance = "FINANCE"
        case hospitality = "HOSPITALITY"
        case healthfitness = "HEALTHFITNESS"
        case healthcare = "HEALTHCARE"
        case insurance = "INSURANCE"
        case lead = "LEAD"
        case other = "OTHER"
        case political = "POLITICAL"
        case realEstate = "REAL_ESTATE"
        case retail = "RETAIL"
        case searchMarketing = "SEARCH_MARKETING"
        case telecom = "TELECOM"
    }

    public enum TrustLevel: String, Codable, CaseIterable {
        case locked = "LOCKED"
        case suspended = "SUSPENDED"
        case probation = "PROBATION"
        case normal = "NORMAL"
        case trusted = "TRUSTED"
    }

    public enum CountryOrDefault: String, Codable, CaseIterable {
        case us = "US"
        case ca = "CA"
    }

    public enum ReceiverPeriodTimeUnit: String, Codable, CaseIterable {
        case nanoseconds = "NANOSECONDS"
        case microseconds = "MICROSECONDS"
        case milliseconds = "MILLISECONDS"
        case seconds = "SECONDS"
        case minutes = "MINUTES"
        case hours = "HOURS"
        case days = "DAYS"
    }

    public enum Status: String, Codable, CaseIterable {
        case active = "ACTIVE"
        case pendingCancelled = "PENDING_CANCELLED"
        case cancelled = "CANCELLED"
    }

    public init(soaAccount: Account? = nil, country: Country? = nil, locale: Locale? = nil, timeZone: TimeZone? = nil, name: String? = nil, key: String? = nil, id: Int? = nil, isActive: Bool? = nil, created: Date? = nil, brand: Brand? = nil, isAllowedToCreateCampaign: Bool? = nil, isEz: Bool? = nil, isAgencyManagedAccounts: Bool? = nil, dateTimeZone: DateTimeZone? = nil, defaultNumberID: Int? = nil, industry: Industry? = nil, trustLevel: TrustLevel? = nil, outboundThreshold: Int? = nil, textOutboundThreshold: Int? = nil, countryOrDefault: CountryOrDefault? = nil, timeZoneID: ZoneID? = nil, website: String? = nil, localTimeZoneRestriction: LocalTimeZoneRestriction? = nil, isStartCapable: Bool? = nil, isAutoAddDoNotContact: Bool? = nil, isScrub: Bool? = nil, messageClass: String? = nil, uiContext: String? = nil, failedVerificationAttempts: Int? = nil, sharedShortCodeID: Int? = nil, isSharedShortCodeAllowed: Bool? = nil, isCanceled: Bool? = nil, apiCallLimit: Int? = nil, defaultNotificationTtlMillis: Int? = nil, tsrAgreement: Date? = nil, tsrInitials: String? = nil, isReceiverPeriodEnabled: Bool? = nil, receiverPeriodGlobal: Int? = nil, receiverPeriodCall: Int? = nil, receiverPeriodText: Int? = nil, receiverPeriodTimeUnit: ReceiverPeriodTimeUnit? = nil, isRetainOnlyMetadata: Bool? = nil, maxAgents: Int? = nil, retainOnlyMetadataLastModified: Date? = nil, retainOnlyMetadataLastDetailRecordID: Int? = nil, fromNumberPool: String? = nil, industryName: String? = nil, status: Status? = nil, age: Duration? = nil, isUniversal: Bool? = nil) {
        self.soaAccount = soaAccount
        self.country = country
        self.locale = locale
        self.timeZone = timeZone
        self.name = name
        self.key = key
        self.id = id
        self.isActive = isActive
        self.created = created
        self.brand = brand
        self.isAllowedToCreateCampaign = isAllowedToCreateCampaign
        self.isEz = isEz
        self.isAgencyManagedAccounts = isAgencyManagedAccounts
        self.dateTimeZone = dateTimeZone
        self.defaultNumberID = defaultNumberID
        self.industry = industry
        self.trustLevel = trustLevel
        self.outboundThreshold = outboundThreshold
        self.textOutboundThreshold = textOutboundThreshold
        self.countryOrDefault = countryOrDefault
        self.timeZoneID = timeZoneID
        self.website = website
        self.localTimeZoneRestriction = localTimeZoneRestriction
        self.isStartCapable = isStartCapable
        self.isAutoAddDoNotContact = isAutoAddDoNotContact
        self.isScrub = isScrub
        self.messageClass = messageClass
        self.uiContext = uiContext
        self.failedVerificationAttempts = failedVerificationAttempts
        self.sharedShortCodeID = sharedShortCodeID
        self.isSharedShortCodeAllowed = isSharedShortCodeAllowed
        self.isCanceled = isCanceled
        self.apiCallLimit = apiCallLimit
        self.defaultNotificationTtlMillis = defaultNotificationTtlMillis
        self.tsrAgreement = tsrAgreement
        self.tsrInitials = tsrInitials
        self.isReceiverPeriodEnabled = isReceiverPeriodEnabled
        self.receiverPeriodGlobal = receiverPeriodGlobal
        self.receiverPeriodCall = receiverPeriodCall
        self.receiverPeriodText = receiverPeriodText
        self.receiverPeriodTimeUnit = receiverPeriodTimeUnit
        self.isRetainOnlyMetadata = isRetainOnlyMetadata
        self.maxAgents = maxAgents
        self.retainOnlyMetadataLastModified = retainOnlyMetadataLastModified
        self.retainOnlyMetadataLastDetailRecordID = retainOnlyMetadataLastDetailRecordID
        self.fromNumberPool = fromNumberPool
        self.industryName = industryName
        self.status = status
        self.age = age
        self.isUniversal = isUniversal
    }

    private enum CodingKeys: String, CodingKey {
        case soaAccount
        case country
        case locale
        case timeZone
        case name
        case key
        case id
        case isActive = "active"
        case created
        case brand
        case isAllowedToCreateCampaign = "allowedToCreateCampaign"
        case isEz = "ez"
        case isAgencyManagedAccounts = "agencyManagedAccounts"
        case dateTimeZone
        case defaultNumberID = "defaultNumberId"
        case industry
        case trustLevel
        case outboundThreshold
        case textOutboundThreshold
        case countryOrDefault
        case timeZoneID = "timeZoneId"
        case website
        case localTimeZoneRestriction
        case isStartCapable = "startCapable"
        case isAutoAddDoNotContact = "autoAddDoNotContact"
        case isScrub = "scrub"
        case messageClass
        case uiContext
        case failedVerificationAttempts
        case sharedShortCodeID = "sharedShortCodeId"
        case isSharedShortCodeAllowed = "sharedShortCodeAllowed"
        case isCanceled = "canceled"
        case apiCallLimit
        case defaultNotificationTtlMillis
        case tsrAgreement
        case tsrInitials
        case isReceiverPeriodEnabled = "receiverPeriodEnabled"
        case receiverPeriodGlobal
        case receiverPeriodCall
        case receiverPeriodText
        case receiverPeriodTimeUnit
        case isRetainOnlyMetadata = "retainOnlyMetadata"
        case maxAgents
        case retainOnlyMetadataLastModified
        case retainOnlyMetadataLastDetailRecordID = "retainOnlyMetadataLastDetailRecordId"
        case fromNumberPool
        case industryName
        case status
        case age
        case isUniversal = "universal"
    }
}

/// Request object for adding new contacts to an existing contact list
public struct AddContactListContactsRequest: Codable {
    /// A list of new contact objects which need to be added
    public var contacts: [Contact]?
    /// A list of ids of existing contacts in CallFire system
    public var contactIDs: [Int]?
    /// A phone number in E.164 format (11-digit). Examples: 12132000384
    public var contactNumbers: [String]?
    /// A type of phone number (homePhone, workPhone, mobilePhone). This parameter works together with contactNumbers and specifies which types of numbers are included to a list
    public var contactNumbersField: String?
    /// A flag to indicate how to define property names for contacts. If true, uses the field and property names exactly as defined. If false will assign custom properties and fields to A, B, C, etc
    public var useCustomFields: Bool?

    public init(contacts: [Contact]? = nil, contactIDs: [Int]? = nil, contactNumbers: [String]? = nil, contactNumbersField: String? = nil, useCustomFields: Bool? = nil) {
        self.contacts = contacts
        self.contactIDs = contactIDs
        self.contactNumbers = contactNumbers
        self.contactNumbersField = contactNumbersField
        self.useCustomFields = useCustomFields
    }

    private enum CodingKeys: String, CodingKey {
        case contacts
        case contactIDs = "contactIds"
        case contactNumbers
        case contactNumbersField
        case useCustomFields
    }
}

/// Request object for adding new Do-Not-Contact records to account.
public struct AddDoNotContactRequest: Codable {
    /// A list of new contact objects which need to be added. Default value: Api V2
    public var source: String?
    /// If set to true add all given numbers to Do-Not-Call list. Default value: true
    public var isCall: Bool?
    /// If set to true add all given numbers to Do-Not-Text list. Default value: true
    public var isText: Bool?
    public var isInboundCall: Bool?
    public var isInboundText: Bool?
    /// A list of phone numbers in E.164 format (11-digit), example: 12132000384, 14142777322
    public var numbers: [String]?

    public init(source: String? = nil, isCall: Bool? = nil, isText: Bool? = nil, isInboundCall: Bool? = nil, isInboundText: Bool? = nil, numbers: [String]? = nil) {
        self.source = source
        self.isCall = isCall
        self.isText = isText
        self.isInboundCall = isInboundCall
        self.isInboundText = isInboundText
        self.numbers = numbers
    }

    private enum CodingKeys: String, CodingKey {
        case source
        case isCall = "call"
        case isText = "text"
        case isInboundCall = "inboundCall"
        case isInboundText = "inboundText"
        case numbers
    }
}

/// An object represents API user in CallFire system. Use /me/api/credentials endpoint to manage API users on your account
public struct APICredential: Codable {
    /// An id of an API credential
    public var id: Int?
    /// A name of an API credential
    public var name: String?
    /// Username for credential
    public var username: String?
    /// A password for credential
    public var password: String?
    /// Is credential enabled
    public var isEnabled: Bool?

    public init(id: Int? = nil, name: String? = nil, username: String? = nil, password: String? = nil, isEnabled: Bool? = nil) {
        self.id = id
        self.name = name
        self.username = username
        self.password = password
        self.isEnabled = isEnabled
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case username
        case password
        case isEnabled = "enabled"
    }
}

public struct APICredentialPage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [APICredential]?

    public init(page: Page, items: [APICredential]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([APICredential].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

public struct APIValidator: Codable {
    public var exceptionHandler: [String: AnyJSON]?

    public init(exceptionHandler: [String: AnyJSON]? = nil) {
        self.exceptionHandler = exceptionHandler
    }
}

public struct AuthController: Codable {
    public var authToken: AuthToken?
    public var authBrand: AuthBrand?
    public var isAdmin: Bool?

    public enum AuthBrand: String, Codable, CaseIterable {
        case eztexting = "EZTEXTING"
        case clubtexting = "CLUBTEXTING"
        case grouptexting = "GROUPTEXTING"
        case tellmycell = "TELLMYCELL"
        case ez = "EZ"
        case callfire = "CALLFIRE"
        case tesla = "TESLA"
    }

    public init(authToken: AuthToken? = nil, authBrand: AuthBrand? = nil, isAdmin: Bool? = nil) {
        self.authToken = authToken
        self.authBrand = authBrand
        self.isAdmin = isAdmin
    }

    private enum CodingKeys: String, CodingKey {
        case authToken
        case authBrand
        case isAdmin = "admin"
    }
}

public final class AuthToken: Codable {
    public var sessionID: String?
    public var userID: Int?
    public var accountID: Int?
    public var brand: Brand?
    public var adminToken: AuthToken?
    public var session: OAuthSession?
    public var isEzSpaClient: Bool?
    public var isAdminClient: Bool?

    public enum Brand: String, Codable, CaseIterable {
        case eztexting = "EZTEXTING"
        case clubtexting = "CLUBTEXTING"
        case grouptexting = "GROUPTEXTING"
        case tellmycell = "TELLMYCELL"
        case ez = "EZ"
        case callfire = "CALLFIRE"
        case tesla = "TESLA"
    }

    public init(sessionID: String? = nil, userID: Int? = nil, accountID: Int? = nil, brand: Brand? = nil, adminToken: AuthToken? = nil, session: OAuthSession? = nil, isEzSpaClient: Bool? = nil, isAdminClient: Bool? = nil) {
        self.sessionID = sessionID
        self.userID = userID
        self.accountID = accountID
        self.brand = brand
        self.adminToken = adminToken
        self.session = session
        self.isEzSpaClient = isEzSpaClient
        self.isAdminClient = isAdminClient
    }

    private enum CodingKeys: String, CodingKey {
        case sessionID = "sessionId"
        case userID = "userId"
        case accountID = "accountId"
        case brand
        case adminToken
        case session
        case isEzSpaClient = "ezSpaClient"
        case isAdminClient = "adminClient"
    }
}

/// A batch represents a group of contacts which can be dialed or texted via call/text broadcast
public struct Batch: Codable {
    /// A id of a batch
    public var id: Int?
    /// A batch name
    public var name: String?
    /// A status of batch (NEW, VALIDATING, ERRORS, SOURCE_ERROR, ACTIVE). NEW - batch is queued for validation; VALIDATING - batch is currently validating; ERRORS - batch is processed, some validation errors occurred; SOURCE_ERROR - if contact source is contact list in CallFire system and it has an error; ACTIVE - batch is processed and ready
    public var status: Status?
    /// An id of broadcast which batch belongs to
    public var broadcastID: Int?
    /// A date and time when batch was created, formatted in unix time milliseconds. Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT
    public var created: Int?
    /// A total number of contacts in batch
    public var size: Int?
    /// A number of contacts remaining undialed/untexted
    public var remaining: Int?
    /// An enabled batch. If batch is disabled its contacts remain undialed/untexted
    public var isEnabled: Bool?

    /// A status of batch (NEW, VALIDATING, ERRORS, SOURCE_ERROR, ACTIVE). NEW - batch is queued for validation; VALIDATING - batch is currently validating; ERRORS - batch is processed, some validation errors occurred; SOURCE_ERROR - if contact source is contact list in CallFire system and it has an error; ACTIVE - batch is processed and ready
    public enum Status: String, Codable, CaseIterable {
        case new = "NEW"
        case validating = "VALIDATING"
        case errors = "ERRORS"
        case sourceError = "SOURCE_ERROR"
        case active = "ACTIVE"
    }

    public init(id: Int? = nil, name: String? = nil, status: Status? = nil, broadcastID: Int? = nil, created: Int? = nil, size: Int? = nil, remaining: Int? = nil, isEnabled: Bool? = nil) {
        self.id = id
        self.name = name
        self.status = status
        self.broadcastID = broadcastID
        self.created = created
        self.size = size
        self.remaining = remaining
        self.isEnabled = isEnabled
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case status
        case broadcastID = "broadcastId"
        case created
        case size
        case remaining
        case isEnabled = "enabled"
    }
}

public struct BatchPage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [Batch]?

    public init(page: Page, items: [Batch]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([Batch].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// Request object is used for adding new batch to an existing broadcast
public struct BatchRequest: Codable {
    /// A name of batch
    public var name: String?
    /// An id of existing contact list
    public var contactListID: Int?
    /// A list of Recipient objects. For each recipient you can set its phone number or existing contact id to use contact which already exists in account
    public var recipients: [Recipient]?
    /// Removes duplicate recipients from batch if true
    public var isScrubDuplicates: Bool?

    public init(name: String? = nil, contactListID: Int? = nil, recipients: [Recipient]? = nil, isScrubDuplicates: Bool? = nil) {
        self.name = name
        self.contactListID = contactListID
        self.recipients = recipients
        self.isScrubDuplicates = isScrubDuplicates
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case contactListID = "contactListId"
        case recipients
        case isScrubDuplicates = "scrubDuplicates"
    }
}

/// Contains statistics of billing plan usage
public struct BillingPlanUsage: Codable {
    /// Start of usage period formatted in unix time milliseconds. Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT
    public var intervalStart: Int?
    /// End of usage period formatted in unix time milliseconds. Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT
    public var intervalEnd: Int?
    /// Remaining credits are rounded to nearest whole value associated with a plan
    public var remainingPlanCredits: Double?
    /// Remaining pay as you go credits are rounded to nearest whole value
    public var remainingPayAsYouGoCredits: Double?
    /// Total number of remaining credits (remainingPlanCredits + remainingPayAsYouGoCredits)
    public var totalRemainingCredits: Double?

    public init(intervalStart: Int? = nil, intervalEnd: Int? = nil, remainingPlanCredits: Double? = nil, remainingPayAsYouGoCredits: Double? = nil, totalRemainingCredits: Double? = nil) {
        self.intervalStart = intervalStart
        self.intervalEnd = intervalEnd
        self.remainingPlanCredits = remainingPlanCredits
        self.remainingPayAsYouGoCredits = remainingPayAsYouGoCredits
        self.totalRemainingCredits = totalRemainingCredits
    }
}

/// Represents a call action sent or received by CallFire platform
public struct Call: Codable {
    /// An id of  an action
    public var id: Int?
    /// A sender's phone number in E.164 (11-digit) format
    public var fromNumber: String?
    /// A recipient's phone number in E.164 (11-digit) format
    public var toNumber: String?
    /// Map of user-defined string attributes associated with an action
    public var attributes: [String: String]?
    /// State of an action (READY, SELECTED, CALLBACK, DISABLED, FINISHED, DNC, DUP, INVALID, TIMEOUT, PERIOD_LIMIT). See [call states and results](https://developers.callfire.com/results-responses-errors.html)
    public var state: State?
    /// An id of broadcast associated with an action if call is sent as part of call broadcast
    public var campaignID: Int?
    /// An id of contact batch associated with an action
    public var batchID: Int?
    /// Represents a contact in CallFire platform. Contains info about the people you want to contact. It allows you to store a user-defined properties for each contact
    public var contact: Contact?
    /// Is action inbound
    public var isInbound: Bool?
    /// The time when the given resource was created, formatted in unix time milliseconds (read only). Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT
    public var created: Int?
    /// The time when the given resource was modified, formatted in unix time milliseconds (read only). Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT
    public var modified: Int?
    /// Labels associated with action or broadcast for this action
    public var labels: [String]?
    /// Result of a call (LA, AM, BUSY, DNC, XFER, NO_ANS, XFER_LEG, INTERNAL_ERROR, CARRIER_ERROR, CARRIER_TEMP_ERROR, UNDIALED, SD, POSTPONED, ABANDONED, SKIPPED). See [call states and results](https://developers.callfire.com/results-responses-errors.html)
    public var finalCallResult: FinalCallResult?
    /// List of call records, each record contains call details like originate time, duration, cost, notes made by agents. A single contact may have a multiple phone numbers. In this case if given call was sent as a part of broadcast with configured retry logic then each call record will contain details about attempted phone number
    public var records: [CallRecord]?
    /// An internal call to an agent
    public var isAgentCall: Bool?
    /// Notes of call added by an agent
    public var notes: [Note]?

    /// State of an action (READY, SELECTED, CALLBACK, DISABLED, FINISHED, DNC, DUP, INVALID, TIMEOUT, PERIOD_LIMIT). See [call states and results](https://developers.callfire.com/results-responses-errors.html)
    public enum State: String, Codable, CaseIterable {
        case ready = "READY"
        case selected = "SELECTED"
        case callback = "CALLBACK"
        case finished = "FINISHED"
        case disabled = "DISABLED"
        case skipped = "SKIPPED"
        case dnc = "DNC"
        case dup = "DUP"
        case invalid = "INVALID"
        case timeout = "TIMEOUT"
        case periodLimit = "PERIOD_LIMIT"
    }

    /// Result of a call (LA, AM, BUSY, DNC, XFER, NO_ANS, XFER_LEG, INTERNAL_ERROR, CARRIER_ERROR, CARRIER_TEMP_ERROR, UNDIALED, SD, POSTPONED, ABANDONED, SKIPPED). See [call states and results](https://developers.callfire.com/results-responses-errors.html)
    public enum FinalCallResult: String, Codable, CaseIterable {
        case la = "LA"
        case am = "AM"
        case busy = "BUSY"
        case dnc = "DNC"
        case xfer = "XFER"
        case noAns = "NO_ANS"
        case xferLeg = "XFER_LEG"
        case internalError = "INTERNAL_ERROR"
        case carrierError = "CARRIER_ERROR"
        case carrierTempError = "CARRIER_TEMP_ERROR"
        case undialed = "UNDIALED"
        case sd = "SD"
        case postponed = "POSTPONED"
        case abandoned = "ABANDONED"
        case skipped = "SKIPPED"
    }

    public init(id: Int? = nil, fromNumber: String? = nil, toNumber: String? = nil, attributes: [String: String]? = nil, state: State? = nil, campaignID: Int? = nil, batchID: Int? = nil, contact: Contact? = nil, isInbound: Bool? = nil, created: Int? = nil, modified: Int? = nil, labels: [String]? = nil, finalCallResult: FinalCallResult? = nil, records: [CallRecord]? = nil, isAgentCall: Bool? = nil, notes: [Note]? = nil) {
        self.id = id
        self.fromNumber = fromNumber
        self.toNumber = toNumber
        self.attributes = attributes
        self.state = state
        self.campaignID = campaignID
        self.batchID = batchID
        self.contact = contact
        self.isInbound = isInbound
        self.created = created
        self.modified = modified
        self.labels = labels
        self.finalCallResult = finalCallResult
        self.records = records
        self.isAgentCall = isAgentCall
        self.notes = notes
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case fromNumber
        case toNumber
        case attributes
        case state
        case campaignID = "campaignId"
        case batchID = "batchId"
        case contact
        case isInbound = "inbound"
        case created
        case modified
        case labels
        case finalCallResult
        case records
        case isAgentCall = "agentCall"
        case notes
    }
}

/// Call broadcast can be used to send out a voice message to a group of numbers. It supports IVR scripting, scheduling, retry logic, playing pre-recorded sounds, answering machine detection
public struct CallBroadcast: Codable {
    /// A unique id of broadcast (readonly)
    public var id: Int?
    /// A name of a broadcast
    public var name: String?
    /// A status of a broadcast (read only). SETUP - campaign isn't configured yet; START_PENDING - waiting for contact batch population; RUNNING - campaign is running; STOPPED - campaign is stopped; FINISHED - campaign is finished; ARCHIVED - campaign was archived
    public var status: Status?
    /// The time when a given resource was updated, formatted in unix time milliseconds (read only). Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT
    public var lastModified: Int?
    /// Phone number in E.164 format (11-digit) or short code for text. Example: 12132000384, 67076
    public var fromNumber: String?
    /// Represents a range of time during which CallFire will send a call or text to recipients. Timeframe uses the local timezone of recipient's number
    public var localTimeRestriction: LocalTimeRestriction?
    /// A list of schedule objects which specifies a range of time when broadcast should be started and stopped. Supports the scheduling per day of week
    public var schedules: [Schedule]?
    /// Sets a maximum number of calls to be dialed by CallFire at once
    public var maxActive: Int?
    /// Labels of a broadcast
    public var labels: [String]?
    /// If true resumes the unfinished campaign to the next day
    public var isResumeNextDay: Bool?
    /// Retry configuration will help you to resend a call or text if it was not delivered first time
    public var retryConfig: RetryConfig?
    /// Recipients of a call broadcast, can be either existing contacts or a new ones
    public var recipients: [Recipient]?
    /// IVR xml is a document which describes the dialplan to setup the IVR broadcast
    public var dialplanXml: String?
    /// A set of sounds assigned to a voice broadcast to play according to an answering machine configuration. You can add the existing sounds from the account's sound library or to provide a text which will be converted into a speech. There are four sound options available for a Voice Broadcast campaign
    public var sounds: CallBroadcastSounds?
    /// Specifies which action should be taken if answering machine was detected, default value: AM_AND_LIVE. Available values: AM_ONLY - run AMD (Answering Machine Detection), hang up if LA (Live Answer); AM_AND_LIVE - run AMD, play separate live vs. machine sound; LIVE_WITH_AMD, run AMD, hang up if machine answers; LIVE_IMMEDIATE - no AMD, play live sound immediately
    public var answeringMachineConfig: AnsweringMachineConfig?
    /// A maximum number of active transfers
    public var maxActiveTransfers: Int?

    /// A status of a broadcast (read only). SETUP - campaign isn't configured yet; START_PENDING - waiting for contact batch population; RUNNING - campaign is running; STOPPED - campaign is stopped; FINISHED - campaign is finished; ARCHIVED - campaign was archived
    public enum Status: String, Codable, CaseIterable {
        case test = "TEST"
        case setup = "SETUP"
        case startPending = "START_PENDING"
        case running = "RUNNING"
        case scheduled = "SCHEDULED"
        case stopped = "STOPPED"
        case suspended = "SUSPENDED"
        case finished = "FINISHED"
        case archived = "ARCHIVED"
        case validatingStart = "VALIDATING_START"
        case validatingEmail = "VALIDATING_EMAIL"
        case blockedSuspicious = "BLOCKED_SUSPICIOUS"
        case declined = "DECLINED"
        case approved = "APPROVED"
    }

    /// Specifies which action should be taken if answering machine was detected, default value: AM_AND_LIVE. Available values: AM_ONLY - run AMD (Answering Machine Detection), hang up if LA (Live Answer); AM_AND_LIVE - run AMD, play separate live vs. machine sound; LIVE_WITH_AMD, run AMD, hang up if machine answers; LIVE_IMMEDIATE - no AMD, play live sound immediately
    public enum AnsweringMachineConfig: String, Codable, CaseIterable {
        case amOnly = "AM_ONLY"
        case amAndLive = "AM_AND_LIVE"
        case liveWithAmd = "LIVE_WITH_AMD"
        case liveImmediate = "LIVE_IMMEDIATE"
    }

    public init(id: Int? = nil, name: String? = nil, status: Status? = nil, lastModified: Int? = nil, fromNumber: String? = nil, localTimeRestriction: LocalTimeRestriction? = nil, schedules: [Schedule]? = nil, maxActive: Int? = nil, labels: [String]? = nil, isResumeNextDay: Bool? = nil, retryConfig: RetryConfig? = nil, recipients: [Recipient]? = nil, dialplanXml: String? = nil, sounds: CallBroadcastSounds? = nil, answeringMachineConfig: AnsweringMachineConfig? = nil, maxActiveTransfers: Int? = nil) {
        self.id = id
        self.name = name
        self.status = status
        self.lastModified = lastModified
        self.fromNumber = fromNumber
        self.localTimeRestriction = localTimeRestriction
        self.schedules = schedules
        self.maxActive = maxActive
        self.labels = labels
        self.isResumeNextDay = isResumeNextDay
        self.retryConfig = retryConfig
        self.recipients = recipients
        self.dialplanXml = dialplanXml
        self.sounds = sounds
        self.answeringMachineConfig = answeringMachineConfig
        self.maxActiveTransfers = maxActiveTransfers
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case status
        case lastModified
        case fromNumber
        case localTimeRestriction
        case schedules
        case maxActive
        case labels
        case isResumeNextDay = "resumeNextDay"
        case retryConfig
        case recipients
        case dialplanXml
        case sounds
        case answeringMachineConfig
        case maxActiveTransfers
    }
}

public struct CallBroadcastPage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [CallBroadcast]?

    public init(page: Page, items: [CallBroadcast]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([CallBroadcast].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// A set of sounds assigned to a voice broadcast to play according to an answering machine configuration. You can add the existing sounds from the account's sound library or to provide a text which will be converted into a speech. There are four sound options available for a Voice Broadcast campaign
public struct CallBroadcastSounds: Codable {
    /// Text to be used to turned into a sound. This text will be played when the phone is answered
    public var liveSoundText: String?
    /// The voice to be used (MALE1, FEMALE1, FEMALE2, SPANISH1, FRENCHCANADIAN1) for a live sound
    public var liveSoundTextVoice: LiveSoundTextVoice?
    /// An id of sound file to play if phone is answered
    public var liveSoundID: Int?
    /// Text to be turned into a sound. This text will be played when answering machine is detected
    public var machineSoundText: String?
    /// The voice to be used (MALE1, FEMALE1 , FEMALE2, SPANISH1, FRENCHCANADIAN1) for a machine sound
    public var machineSoundTextVoice: MachineSoundTextVoice?
    /// An id of a sound file to play if answering machine is detected
    public var machineSoundID: Int?
    /// Text to be turned into a sound. This text will be played when the transfer digit is played
    public var transferSoundText: String?
    /// The voice to be used (MALE1, FEMALE1, FEMALE2, SPANISH1, FRENCHCANADIAN1) for a sound transfer
    public var transferSoundTextVoice: TransferSoundTextVoice?
    /// An id of a file to play if call is transferred
    public var transferSoundID: Int?
    /// Digit pressed to initiate a transfer
    public var transferDigit: String?
    /// Phone number in E.164 format (11-digit) to transfer call to.  Example: 12132000384, 67076
    public var transferNumber: String?
    /// Text to be turned into sound, plays to notify that Do Not Call digit has been pressed and inform your contact of their placement on the Do Not Call list
    public var dncSoundText: String?
    /// The voice to be used (MALE1, FEMALE1, FEMALE2, SPANISH1, FRENCHCANADIAN1)
    public var dncSoundTextVoice: DncSoundTextVoice?
    /// An id of sound file to play when recipient decided to opt out and pressed DNC digit
    public var dncSoundID: Int?
    /// Digit pressed to place contact in DNC list
    public var dncDigit: String?

    /// The voice to be used (MALE1, FEMALE1, FEMALE2, SPANISH1, FRENCHCANADIAN1) for a live sound
    public enum LiveSoundTextVoice: String, Codable, CaseIterable {
        case male1 = "MALE1"
        case female1 = "FEMALE1"
        case female2 = "FEMALE2"
        case spanish1 = "SPANISH1"
        case frenchcanadian1 = "FRENCHCANADIAN1"
    }

    /// The voice to be used (MALE1, FEMALE1 , FEMALE2, SPANISH1, FRENCHCANADIAN1) for a machine sound
    public enum MachineSoundTextVoice: String, Codable, CaseIterable {
        case male1 = "MALE1"
        case female1 = "FEMALE1"
        case female2 = "FEMALE2"
        case spanish1 = "SPANISH1"
        case frenchcanadian1 = "FRENCHCANADIAN1"
    }

    /// The voice to be used (MALE1, FEMALE1, FEMALE2, SPANISH1, FRENCHCANADIAN1) for a sound transfer
    public enum TransferSoundTextVoice: String, Codable, CaseIterable {
        case male1 = "MALE1"
        case female1 = "FEMALE1"
        case female2 = "FEMALE2"
        case spanish1 = "SPANISH1"
        case frenchcanadian1 = "FRENCHCANADIAN1"
    }

    /// The voice to be used (MALE1, FEMALE1, FEMALE2, SPANISH1, FRENCHCANADIAN1)
    public enum DncSoundTextVoice: String, Codable, CaseIterable {
        case male1 = "MALE1"
        case female1 = "FEMALE1"
        case female2 = "FEMALE2"
        case spanish1 = "SPANISH1"
        case frenchcanadian1 = "FRENCHCANADIAN1"
    }

    public init(liveSoundText: String? = nil, liveSoundTextVoice: LiveSoundTextVoice? = nil, liveSoundID: Int? = nil, machineSoundText: String? = nil, machineSoundTextVoice: MachineSoundTextVoice? = nil, machineSoundID: Int? = nil, transferSoundText: String? = nil, transferSoundTextVoice: TransferSoundTextVoice? = nil, transferSoundID: Int? = nil, transferDigit: String? = nil, transferNumber: String? = nil, dncSoundText: String? = nil, dncSoundTextVoice: DncSoundTextVoice? = nil, dncSoundID: Int? = nil, dncDigit: String? = nil) {
        self.liveSoundText = liveSoundText
        self.liveSoundTextVoice = liveSoundTextVoice
        self.liveSoundID = liveSoundID
        self.machineSoundText = machineSoundText
        self.machineSoundTextVoice = machineSoundTextVoice
        self.machineSoundID = machineSoundID
        self.transferSoundText = transferSoundText
        self.transferSoundTextVoice = transferSoundTextVoice
        self.transferSoundID = transferSoundID
        self.transferDigit = transferDigit
        self.transferNumber = transferNumber
        self.dncSoundText = dncSoundText
        self.dncSoundTextVoice = dncSoundTextVoice
        self.dncSoundID = dncSoundID
        self.dncDigit = dncDigit
    }

    private enum CodingKeys: String, CodingKey {
        case liveSoundText
        case liveSoundTextVoice
        case liveSoundID = "liveSoundId"
        case machineSoundText
        case machineSoundTextVoice
        case machineSoundID = "machineSoundId"
        case transferSoundText
        case transferSoundTextVoice
        case transferSoundID = "transferSoundId"
        case transferDigit
        case transferNumber
        case dncSoundText
        case dncSoundTextVoice
        case dncSoundID = "dncSoundId"
        case dncDigit
    }
}

public struct CallBroadcastStats: Codable {
    public var totalOutboundCount: Int?
    public var remainingOutboundCount: Int?
    public var billedAmount: Double?
    public var callsAttempted: Int?
    public var callsPlaced: Int?
    public var callsDuration: Int?
    public var billedDuration: Int?
    public var responseRatePercent: Int?
    public var callsRemaining: Int?
    public var callsAwaitingRedial: Int?
    public var callsLiveAnswer: Int?
    public var totalCount: Int?
    public var answeringMachineCount: Int?
    public var busyCount: Int?
    public var dialedCount: Int?
    public var doNotCallCount: Int?
    public var errorCount: Int?
    public var liveCount: Int?
    public var miscCount: Int?
    public var noAnswerCount: Int?
    public var transferCount: Int?

    public init(totalOutboundCount: Int? = nil, remainingOutboundCount: Int? = nil, billedAmount: Double? = nil, callsAttempted: Int? = nil, callsPlaced: Int? = nil, callsDuration: Int? = nil, billedDuration: Int? = nil, responseRatePercent: Int? = nil, callsRemaining: Int? = nil, callsAwaitingRedial: Int? = nil, callsLiveAnswer: Int? = nil, totalCount: Int? = nil, answeringMachineCount: Int? = nil, busyCount: Int? = nil, dialedCount: Int? = nil, doNotCallCount: Int? = nil, errorCount: Int? = nil, liveCount: Int? = nil, miscCount: Int? = nil, noAnswerCount: Int? = nil, transferCount: Int? = nil) {
        self.totalOutboundCount = totalOutboundCount
        self.remainingOutboundCount = remainingOutboundCount
        self.billedAmount = billedAmount
        self.callsAttempted = callsAttempted
        self.callsPlaced = callsPlaced
        self.callsDuration = callsDuration
        self.billedDuration = billedDuration
        self.responseRatePercent = responseRatePercent
        self.callsRemaining = callsRemaining
        self.callsAwaitingRedial = callsAwaitingRedial
        self.callsLiveAnswer = callsLiveAnswer
        self.totalCount = totalCount
        self.answeringMachineCount = answeringMachineCount
        self.busyCount = busyCount
        self.dialedCount = dialedCount
        self.doNotCallCount = doNotCallCount
        self.errorCount = errorCount
        self.liveCount = liveCount
        self.miscCount = miscCount
        self.noAnswerCount = noAnswerCount
        self.transferCount = transferCount
    }
}

/// Request object is used for creating sound via a phone call. This sound will appear in account's sound library
public struct CallCreateSound: Codable {
    /// Name of a sound to create
    public var name: String?
    /// Phone number in E.164 11-digit format to call to record a sound.  Example: 12132000384
    public var toNumber: String?

    public init(name: String? = nil, toNumber: String? = nil) {
        self.name = name
        self.toNumber = toNumber
    }
}

public struct CallList: Codable {
    public var itemList: ItemList
    public var items: [Call]?

    public init(itemList: ItemList, items: [Call]? = nil) {
        self.itemList = itemList
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.itemList = try ItemList(from: decoder)
        self.items = try values.decodeIfPresent([Call].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(itemList, forKey: "itemList")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

public struct CallPage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [Call]?

    public init(page: Page, items: [Call]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([Call].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// Recipient of a campaign action. Can be a phone number, contact, or contact list with attributes added to action. It is required to specify one of this values
public struct CallRecipient: Codable {
    /// Recipient's phone number in E.164 format (11-digit) or short code. Example: 12132000384
    public var phoneNumber: String?
    public var fromNumber: String?
    /// An id of existing contact used as recipient
    public var contactID: Int?
    /// Map of user-defined string attributes associated with recipient
    public var attributes: [String: String]?
    /// An IVR xml document describing dialplan to setup an IVR broadcast. If dialplan is set there is no need to set live, machine and transfer sounds (or vice versa)
    public var dialplanXml: String?
    /// Text to be turned into a sound, this text will be played when the phone is answered
    public var liveMessage: String?
    /// An id of a sound file to play if phone is answered
    public var liveMessageSoundID: Int?
    /// Text to be used to turn into sound, this text will be played when answering machine is detected
    public var machineMessage: String?
    /// An id of a sound file to play if answering machine is detected
    public var machineMessageSoundID: Int?
    /// Text to be turned into sound, this text will be played when the transfer digit is played
    public var transferMessage: String?
    /// An id of a sound file to play if call is transferred
    public var transferMessageSoundID: Int?
    /// A digit pressed to initiate the transfer
    public var transferDigit: String?
    /// Phone number in E.164 format (11-digit) to transfer the call to. Example: 12132000384
    public var transferNumber: String?
    /// The voice to be used (MALE1, FEMALE1, FEMALE2, SPANISH1, FRENCHCANADIAN1)
    public var voice: Voice?

    /// The voice to be used (MALE1, FEMALE1, FEMALE2, SPANISH1, FRENCHCANADIAN1)
    public enum Voice: String, Codable, CaseIterable {
        case male1 = "MALE1"
        case female1 = "FEMALE1"
        case female2 = "FEMALE2"
        case spanish1 = "SPANISH1"
        case frenchcanadian1 = "FRENCHCANADIAN1"
    }

    public init(phoneNumber: String? = nil, fromNumber: String? = nil, contactID: Int? = nil, attributes: [String: String]? = nil, dialplanXml: String? = nil, liveMessage: String? = nil, liveMessageSoundID: Int? = nil, machineMessage: String? = nil, machineMessageSoundID: Int? = nil, transferMessage: String? = nil, transferMessageSoundID: Int? = nil, transferDigit: String? = nil, transferNumber: String? = nil, voice: Voice? = nil) {
        self.phoneNumber = phoneNumber
        self.fromNumber = fromNumber
        self.contactID = contactID
        self.attributes = attributes
        self.dialplanXml = dialplanXml
        self.liveMessage = liveMessage
        self.liveMessageSoundID = liveMessageSoundID
        self.machineMessage = machineMessage
        self.machineMessageSoundID = machineMessageSoundID
        self.transferMessage = transferMessage
        self.transferMessageSoundID = transferMessageSoundID
        self.transferDigit = transferDigit
        self.transferNumber = transferNumber
        self.voice = voice
    }

    private enum CodingKeys: String, CodingKey {
        case phoneNumber
        case fromNumber
        case contactID = "contactId"
        case attributes
        case dialplanXml
        case liveMessage
        case liveMessageSoundID = "liveMessageSoundId"
        case machineMessage
        case machineMessageSoundID = "machineMessageSoundId"
        case transferMessage
        case transferMessageSoundID = "transferMessageSoundId"
        case transferDigit
        case transferNumber
        case voice
    }
}

/// Represents a call sent to a contact's number
public struct CallRecord: Codable {
    /// An id of a call record
    public var id: Int?
    /// A phone number to which a call was addressed. Phone number in E.164 format (11-digit). Example: 12132000384
    public var toNumber: String?
    /// A cost of the call
    public var billedAmount: Double?
    /// Timestamp when call was finished, formatted in unix time milliseconds (read only). Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT
    public var finishTime: Int?
    public var switchID: String?
    public var callerName: String?
    /// Labels associated with a call action
    public var labels: [String]?
    public var result: Result?
    /// A date and time (timestamp) when call was originated by CallFire platform and went to downstream provider, formatted in unix time milliseconds (read only). Example: 1473781817000
    public var originateTime: Int?
    /// Timestamp when call was answered, formatted in unix time milliseconds (read only). Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT
    public var answerTime: Int?
    /// Duration of the call in seconds
    public var duration: Int?
    /// Notes of call added by agent
    public var notes: [Note]?
    /// A list of voice recordings of the call
    public var recordings: [CallRecording]?
    /// Notes of call added by an agent
    public var questionResponses: [QuestionResponse]?

    public enum Result: String, Codable, CaseIterable {
        case la = "LA"
        case am = "AM"
        case busy = "BUSY"
        case dnc = "DNC"
        case xfer = "XFER"
        case noAns = "NO_ANS"
        case xferLeg = "XFER_LEG"
        case internalError = "INTERNAL_ERROR"
        case carrierError = "CARRIER_ERROR"
        case carrierTempError = "CARRIER_TEMP_ERROR"
        case undialed = "UNDIALED"
        case sd = "SD"
        case postponed = "POSTPONED"
        case abandoned = "ABANDONED"
        case skipped = "SKIPPED"
    }

    public init(id: Int? = nil, toNumber: String? = nil, billedAmount: Double? = nil, finishTime: Int? = nil, switchID: String? = nil, callerName: String? = nil, labels: [String]? = nil, result: Result? = nil, originateTime: Int? = nil, answerTime: Int? = nil, duration: Int? = nil, notes: [Note]? = nil, recordings: [CallRecording]? = nil, questionResponses: [QuestionResponse]? = nil) {
        self.id = id
        self.toNumber = toNumber
        self.billedAmount = billedAmount
        self.finishTime = finishTime
        self.switchID = switchID
        self.callerName = callerName
        self.labels = labels
        self.result = result
        self.originateTime = originateTime
        self.answerTime = answerTime
        self.duration = duration
        self.notes = notes
        self.recordings = recordings
        self.questionResponses = questionResponses
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case toNumber
        case billedAmount
        case finishTime
        case switchID = "switchId"
        case callerName
        case labels
        case result
        case originateTime
        case answerTime
        case duration
        case notes
        case recordings
        case questionResponses
    }
}

/// Represents a recording of a voice call
public struct CallRecording: Codable {
    /// An id of a call recording
    public var id: Int?
    /// An id of a call action
    public var callID: Int?
    /// Contains broadcast id if call was sent as a part of voice broadcast
    public var campaignID: Int?
    /// A name of a recording
    public var name: String?
    /// The time when the given resource was created, formatted in unix time milliseconds (read only). Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT
    public var created: Int?
    /// A size of a recording file in bytes
    public var lengthInBytes: Int?
    /// Duration of a recording in seconds
    public var lengthInSeconds: Int?
    /// A unique string hash identifier of a recording
    public var hash: String?
    /// A public URL of a call recording
    public var mp3URL: String?
    /// Current state of a recording, available values: RECORDING - recording is in progress, READY - recording is ready, ERROR - error has occurred and recording can be broken
    public var state: State?

    /// Current state of a recording, available values: RECORDING - recording is in progress, READY - recording is ready, ERROR - error has occurred and recording can be broken
    public enum State: String, Codable, CaseIterable {
        case recording = "RECORDING"
        case ready = "READY"
        case error = "ERROR"
    }

    public init(id: Int? = nil, callID: Int? = nil, campaignID: Int? = nil, name: String? = nil, created: Int? = nil, lengthInBytes: Int? = nil, lengthInSeconds: Int? = nil, hash: String? = nil, mp3URL: String? = nil, state: State? = nil) {
        self.id = id
        self.callID = callID
        self.campaignID = campaignID
        self.name = name
        self.created = created
        self.lengthInBytes = lengthInBytes
        self.lengthInSeconds = lengthInSeconds
        self.hash = hash
        self.mp3URL = mp3URL
        self.state = state
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case callID = "callId"
        case campaignID = "campaignId"
        case name
        case created
        case lengthInBytes
        case lengthInSeconds
        case hash
        case mp3URL = "mp3Url"
        case state
    }
}

public struct CallRecordingList: Codable {
    public var itemList: ItemList
    public var items: [CallRecording]?

    public init(itemList: ItemList, items: [CallRecording]? = nil) {
        self.itemList = itemList
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.itemList = try ItemList(from: decoder)
        self.items = try values.decodeIfPresent([CallRecording].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(itemList, forKey: "itemList")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// Call tracking configuration allows you track incoming calls, analyze, respond to customers using sms or voice replies. For more information see [call tracking page](https://www.callfire.com/products/call-tracking)
public struct CallTrackingConfig: Codable {
    /// List of phone numbers in E.164 format (11-digit) are used for transfer. Example: 12132000384
    public var transferNumbers: [String]?
    /// Screens the incoming calls
    public var isScreen: Bool?
    /// Records all inbound calls
    public var isRecorded: Bool?
    /// Enables voicemail if call is not transferred
    public var isVoicemail: Bool?
    /// An id of sound file, played if call is answered
    public var introSoundID: Int?
    /// An id of sound file, played if call is screened
    public var whisperSoundID: Int?
    /// An id of sound file, played if voicemail is enabled and a call isn't transferred
    public var voicemailSoundID: Int?
    /// An id of sound file, played if caller can not be connected to transfer number for any reason
    public var failedTransferSoundID: Int?
    /// Weekly schedule allows to schedule operations by day of week and time of the day
    public var weeklySchedule: WeeklySchedule?
    /// Google Analytics for Call Tracking
    public var googleAnalytics: GoogleAnalytics?

    public init(transferNumbers: [String]? = nil, isScreen: Bool? = nil, isRecorded: Bool? = nil, isVoicemail: Bool? = nil, introSoundID: Int? = nil, whisperSoundID: Int? = nil, voicemailSoundID: Int? = nil, failedTransferSoundID: Int? = nil, weeklySchedule: WeeklySchedule? = nil, googleAnalytics: GoogleAnalytics? = nil) {
        self.transferNumbers = transferNumbers
        self.isScreen = isScreen
        self.isRecorded = isRecorded
        self.isVoicemail = isVoicemail
        self.introSoundID = introSoundID
        self.whisperSoundID = whisperSoundID
        self.voicemailSoundID = voicemailSoundID
        self.failedTransferSoundID = failedTransferSoundID
        self.weeklySchedule = weeklySchedule
        self.googleAnalytics = googleAnalytics
    }

    private enum CodingKeys: String, CodingKey {
        case transferNumbers
        case isScreen = "screen"
        case isRecorded = "recorded"
        case isVoicemail = "voicemail"
        case introSoundID = "introSoundId"
        case whisperSoundID = "whisperSoundId"
        case voicemailSoundID = "voicemailSoundId"
        case failedTransferSoundID = "failedTransferSoundId"
        case weeklySchedule
        case googleAnalytics
    }
}

public struct CallerID: Codable {
    public var phoneNumber: String?

    public init(phoneNumber: String? = nil) {
        self.phoneNumber = phoneNumber
    }
}

public struct CallerIDList: Codable {
    public var itemList: ItemList
    public var items: [CallerID]?

    public init(itemList: ItemList, items: [CallerID]? = nil) {
        self.itemList = itemList
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.itemList = try ItemList(from: decoder)
        self.items = try values.decodeIfPresent([CallerID].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(itemList, forKey: "itemList")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// Request which is used to verify a new caller id number
public struct CallerIDVerificationRequest: Codable {
    /// The code used to verify a caller id number
    public var verificationCode: String?

    public init(verificationCode: String? = nil) {
        self.verificationCode = verificationCode
    }
}

/// Represents a sound recording from account's sound library which can be used in different API operations
public struct CampaignSound: Codable {
    /// An id of a sound file
    public var id: Int?
    /// A name of a sound file
    public var name: String?
    /// The time when the given resource was created, formatted in unix time milliseconds (read only). Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT
    public var created: Int?
    /// Length of a sound in seconds
    public var lengthInSeconds: Int?
    /// A current status of a sound, available values: UPLOAD - uploading is in progress, RECORDING - recording of sound is in progress, ACTIVE - sound is ready, FAILED, ARCHIVED - sound was archived, SCRUBBED - sound was scrubbed
    public var status: Status?
    /// True if the same sound file exists in a sound library of account
    public var isDuplicate: Bool?

    /// A current status of a sound, available values: UPLOAD - uploading is in progress, RECORDING - recording of sound is in progress, ACTIVE - sound is ready, FAILED, ARCHIVED - sound was archived, SCRUBBED - sound was scrubbed
    public enum Status: String, Codable, CaseIterable {
        case upload = "UPLOAD"
        case recording = "RECORDING"
        case active = "ACTIVE"
        case activeSystem = "ACTIVE_SYSTEM"
        case failed = "FAILED"
        case archived = "ARCHIVED"
        case scrubbed = "SCRUBBED"
    }

    public init(id: Int? = nil, name: String? = nil, created: Int? = nil, lengthInSeconds: Int? = nil, status: Status? = nil, isDuplicate: Bool? = nil) {
        self.id = id
        self.name = name
        self.created = created
        self.lengthInSeconds = lengthInSeconds
        self.status = status
        self.isDuplicate = isDuplicate
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case created
        case lengthInSeconds
        case status
        case isDuplicate = "duplicate"
    }
}

public struct CampaignSoundPage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [CampaignSound]?

    public init(page: Page, items: [CampaignSound]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([CampaignSound].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// Represents a contact in CallFire platform. Contains info about the people you want to contact. It allows you to store a user-defined properties for each contact
public struct Contact: Codable {
    /// An id of a contact
    public var id: Int?
    /// A first name of a contact
    public var firstName: String?
    /// A last name of a contact
    public var lastName: String?
    /// A Zip code of a contact
    public var zipcode: String?
    /// Phone number in E.164 format (11-digit). Example: 12132000384
    public var homePhone: String?
    /// Phone number in E.164 format (11-digit). Example: 12132000384
    public var workPhone: String?
    /// Phone number in E.164 format (11-digit). Example: 12132000384
    public var mobilePhone: String?
    /// Phone number in E.164 format (11-digit). Example: 12132000384
    public var extraPhone1: String?
    /// Phone number in E.164 format (11-digit). Example: 12132000384
    public var extraPhone2: String?
    /// Phone number in E.164 format (11-digit). Example: 12132000384
    public var extraPhone3: String?
    /// An external id of a contact for syncing with external sources
    public var externalID: String?
    /// External system that external id refers to
    public var externalSystem: String?
    /// Map of user-defined string properties for contact
    public var properties: [String: String]?
    /// A deleted contact, deleted contacts are hidden from search results
    public var isDeleted: Bool?

    public init(id: Int? = nil, firstName: String? = nil, lastName: String? = nil, zipcode: String? = nil, homePhone: String? = nil, workPhone: String? = nil, mobilePhone: String? = nil, extraPhone1: String? = nil, extraPhone2: String? = nil, extraPhone3: String? = nil, externalID: String? = nil, externalSystem: String? = nil, properties: [String: String]? = nil, isDeleted: Bool? = nil) {
        self.id = id
        self.firstName = firstName
        self.lastName = lastName
        self.zipcode = zipcode
        self.homePhone = homePhone
        self.workPhone = workPhone
        self.mobilePhone = mobilePhone
        self.extraPhone1 = extraPhone1
        self.extraPhone2 = extraPhone2
        self.extraPhone3 = extraPhone3
        self.externalID = externalID
        self.externalSystem = externalSystem
        self.properties = properties
        self.isDeleted = isDeleted
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case firstName
        case lastName
        case zipcode
        case homePhone
        case workPhone
        case mobilePhone
        case extraPhone1
        case extraPhone2
        case extraPhone3
        case externalID = "externalId"
        case externalSystem
        case properties
        case isDeleted = "deleted"
    }
}

/// Contains history of all calls and texts addressed to a given contact
public struct ContactHistory: Codable {
    /// An id of a contact
    public var id: Int?
    /// List of Call objects addressed to a given contact
    public var calls: [Call]?
    /// List of Text objects addressed to a given contact
    public var texts: [Text]?

    public init(id: Int? = nil, calls: [Call]? = nil, texts: [Text]? = nil) {
        self.id = id
        self.calls = calls
        self.texts = texts
    }
}

/// Represents a contact list in CallFire system
public struct ContactList: Codable {
    /// An Id of a contact list
    public var id: Int?
    /// A name of a contact list
    public var name: String?
    /// A number of contacts in a contact list
    public var size: Int?
    /// A time when a given resource was created, formatted in unix time milliseconds (read only). Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT
    public var created: Int?
    /// A current status of a contact list, available values: ACTIVE - contact list is ready, VALIDATING - contact list validation is in progress, IMPORTING - importing is in progress, IMPORT_FAILED - in case of errors occurred during the importing, ERRORS - contact list has validation errors, DELETED - contact list was deleted, PARSE_FAILED - contacts cannot be parsed, COLUMN_TOO_LARGE - if size of phone number or any other column exceeds 255 characters
    public var status: Status?

    /// A current status of a contact list, available values: ACTIVE - contact list is ready, VALIDATING - contact list validation is in progress, IMPORTING - importing is in progress, IMPORT_FAILED - in case of errors occurred during the importing, ERRORS - contact list has validation errors, DELETED - contact list was deleted, PARSE_FAILED - contacts cannot be parsed, COLUMN_TOO_LARGE - if size of phone number or any other column exceeds 255 characters
    public enum Status: String, Codable, CaseIterable {
        case active = "ACTIVE"
        case validating = "VALIDATING"
        case importing = "IMPORTING"
        case importFailed = "IMPORT_FAILED"
        case errors = "ERRORS"
        case deleted = "DELETED"
        case parseFailed = "PARSE_FAILED"
        case columnTooLarge = "COLUMN_TOO_LARGE"
    }

    public init(id: Int? = nil, name: String? = nil, size: Int? = nil, created: Int? = nil, status: Status? = nil) {
        self.id = id
        self.name = name
        self.size = size
        self.created = created
        self.status = status
    }
}

public struct ContactListPage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [ContactList]?

    public init(page: Page, items: [ContactList]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([ContactList].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

public struct ContactPage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [Contact]?

    public init(page: Page, items: [Contact]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([Contact].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// A request object is used to create a contact list from one of available contact sources
public struct CreateContactListRequest: Codable {
    /// A list of new contact objects to be added
    public var contacts: [Contact]?
    /// A list of ids of existing contacts in CallFire system
    public var contactIDs: [Int]?
    /// List of numbers in E.164 format (11-digit). Example: 12132000384
    public var contactNumbers: [String]?
    /// A type of a phone number (homePhone, workPhone, mobilePhone). This parameter is used with contactNumbers and specifies which types of phone numbers are included to a contact list
    public var contactNumbersField: String?
    /// A flag to indicate how to define property names for contacts. If true, uses the field and property names exactly as defined. If false will assign custom properties and fields to A, B, C, etc
    public var useCustomFields: Bool?
    /// A name of a contact list
    public var name: String?

    public init(contacts: [Contact]? = nil, contactIDs: [Int]? = nil, contactNumbers: [String]? = nil, contactNumbersField: String? = nil, useCustomFields: Bool? = nil, name: String? = nil) {
        self.contacts = contacts
        self.contactIDs = contactIDs
        self.contactNumbers = contactNumbers
        self.contactNumbersField = contactNumbersField
        self.useCustomFields = useCustomFields
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case contacts
        case contactIDs = "contactIds"
        case contactNumbers
        case contactNumbersField
        case useCustomFields
        case name
    }
}

/// Contains statistics of billing plan usage
public struct CreditUsage: Codable {
    /// Start of usage period formatted in unix time milliseconds. Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT
    public var intervalBegin: Int?
    /// End of usage period formatted in unix time milliseconds. Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT
    public var intervalEnd: Int?
    /// Sum of calls duration rounded to nearest whole minute
    public var callsDurationMinutes: Int?
    /// Number of texts sent
    public var textsSent: Int?
    /// Total credits used calls and texts.
    public var creditsUsed: Double?

    public init(intervalBegin: Int? = nil, intervalEnd: Int? = nil, callsDurationMinutes: Int? = nil, textsSent: Int? = nil, creditsUsed: Double? = nil) {
        self.intervalBegin = intervalBegin
        self.intervalEnd = intervalEnd
        self.callsDurationMinutes = callsDurationMinutes
        self.textsSent = textsSent
        self.creditsUsed = creditsUsed
    }
}

public struct DateTimeZone: Codable {
    public var id: String?
    public var isFixed: Bool?

    public init(id: String? = nil, isFixed: Bool? = nil) {
        self.id = id
        self.isFixed = isFixed
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case isFixed = "fixed"
    }
}

public struct DeliveryReport: Codable {
    public var messageText: String?
    public var fromNumber: String?
    public var toNumber: String?
    public var campaignID: Int?
    public var deliveryCategory: DeliveryCategory?
    public var deliveryState: DeliveryState?
    public var carrier: String?
    public var updated: Date?

    public enum DeliveryCategory: String, Codable, CaseIterable {
        case noData = "NO_DATA"
        case optedOut = "OPTED_OUT"
        case bounced = "BOUNCED"
        case noCredits = "NO_CREDITS"
        case delivered = "DELIVERED"
    }

    public enum DeliveryState: String, Codable, CaseIterable {
        case delivered = "DELIVERED"
        case unsentOptedOutGlobal = "UNSENT_OPTED_OUT_GLOBAL"
        case unsentOptedOutLocal = "UNSENT_OPTED_OUT_LOCAL"
        case unsentNoCredits = "UNSENT_NO_CREDITS"
        case gatewayRejected = "GATEWAY_REJECTED"
        case carrierRejected = "CARRIER_REJECTED"
        case notDelivered = "NOT_DELIVERED"
        case unsentInvalidNumber = "UNSENT_INVALID_NUMBER"
        case unsentBadData = "UNSENT_BAD_DATA"
        case unsentForceStopped = "UNSENT_FORCE_STOPPED"
        case unsentPeriodLimit = "UNSENT_PERIOD_LIMIT"
        case unsentInternational = "UNSENT_INTERNATIONAL"
        case unsentInvalidTimezoneOrDnc = "UNSENT_INVALID_TIMEZONE_OR_DNC"
        case unsentAlreadyScrubbed = "UNSENT_ALREADY_SCRUBBED"
        case unsentSystemError = "UNSENT_SYSTEM_ERROR"
        case unsentNoWirelessCarrier = "UNSENT_NO_WIRELESS_CARRIER"
        case unsentMessageTooLong = "UNSENT_MESSAGE_TOO_LONG"
        case unsentMessageBlocked = "UNSENT_MESSAGE_BLOCKED"
        case unsentQueueLimitReached = "UNSENT_QUEUE_LIMIT_REACHED"
        case unsentTokenLimitReached = "UNSENT_TOKEN_LIMIT_REACHED"
        case unsentTimeLimitReached = "UNSENT_TIME_LIMIT_REACHED"
        case unsentSchedulerCapacityExceeded = "UNSENT_SCHEDULER_CAPACITY_EXCEEDED"
        case spamDetected = "SPAM_DETECTED"
        case unsentNoGateway = "UNSENT_NO_GATEWAY"
        case originated = "ORIGINATED"
        case submitted = "SUBMITTED"
        case forwarded = "FORWARDED"
        case notGiven = "NOT_GIVEN"
        case unknown = "UNKNOWN"
        case retryMmsAsSms = "RETRY_MMS_AS_SMS"
        case queued = "QUEUED"
        case queuedTranscode = "QUEUED_TRANSCODE"
        case original = "ORIGINAL"
        case dupe = "DUPE"
        case truncated = "TRUNCATED"
        case requeuedRateLimited = "REQUEUED_RATE_LIMITED"
        case buffered = "BUFFERED"
        case rateLimitExceeded = "RATE_LIMIT_EXCEEDED"
        case serviceUnavailable = "SERVICE_UNAVAILABLE"
        case sendMmsAsSms = "SEND_MMS_AS_SMS"
        case requeuedRecoverableError = "REQUEUED_RECOVERABLE_ERROR"
        case sendWithAdditionalSpid = "SEND_WITH_ADDITIONAL_SPID"
    }

    public init(messageText: String? = nil, fromNumber: String? = nil, toNumber: String? = nil, campaignID: Int? = nil, deliveryCategory: DeliveryCategory? = nil, deliveryState: DeliveryState? = nil, carrier: String? = nil, updated: Date? = nil) {
        self.messageText = messageText
        self.fromNumber = fromNumber
        self.toNumber = toNumber
        self.campaignID = campaignID
        self.deliveryCategory = deliveryCategory
        self.deliveryState = deliveryState
        self.carrier = carrier
        self.updated = updated
    }

    private enum CodingKeys: String, CodingKey {
        case messageText
        case fromNumber
        case toNumber
        case campaignID = "campaignId"
        case deliveryCategory
        case deliveryState
        case carrier
        case updated
    }
}

public struct DncListDto: Codable {
    public var itemList: ItemList
    public var items: [DoNotContact]?

    public init(itemList: ItemList, items: [DoNotContact]? = nil) {
        self.itemList = itemList
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.itemList = try ItemList(from: decoder)
        self.items = try values.decodeIfPresent([DoNotContact].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(itemList, forKey: "itemList")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// Represents an opted out contact
public struct DoNotContact: Codable {
    /// A single DNC number in E.164 format (11-digit). Example: 12132000384
    public var number: String?
    /// A number on Do-Not-Call list
    public var isCall: Bool?
    /// A number on Do-Not-Text list
    public var isText: Bool?
    public var isInboundCall: Bool?
    public var isInboundText: Bool?
    /// The name of DNC source (can be the name of DNC list that user uploads to CallFire)
    public var source: String?
    /// An Id of a campaign which was used to send a message to DNC number
    public var campaignID: Int?
    /// A time when a given resource was created, formatted in unix time milliseconds (read only). Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT
    public var created: Int?

    public init(number: String? = nil, isCall: Bool? = nil, isText: Bool? = nil, isInboundCall: Bool? = nil, isInboundText: Bool? = nil, source: String? = nil, campaignID: Int? = nil, created: Int? = nil) {
        self.number = number
        self.isCall = isCall
        self.isText = isText
        self.isInboundCall = isInboundCall
        self.isInboundText = isInboundText
        self.source = source
        self.campaignID = campaignID
        self.created = created
    }

    private enum CodingKeys: String, CodingKey {
        case number
        case isCall = "call"
        case isText = "text"
        case isInboundCall = "inboundCall"
        case isInboundText = "inboundText"
        case source
        case campaignID = "campaignId"
        case created
    }
}

public struct DoNotContactPage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [DoNotContact]?

    public init(page: Page, items: [DoNotContact]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([DoNotContact].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

public struct Duration: Codable {
    public var standardDays: Int?
    public var standardHours: Int?
    public var standardMinutes: Int?
    public var standardSeconds: Int?
    public var millis: Int?

    public init(standardDays: Int? = nil, standardHours: Int? = nil, standardMinutes: Int? = nil, standardSeconds: Int? = nil, millis: Int? = nil) {
        self.standardDays = standardDays
        self.standardHours = standardHours
        self.standardMinutes = standardMinutes
        self.standardSeconds = standardSeconds
        self.millis = millis
    }
}

/// Error response containing error info
public struct ErrorResponse: Codable {
    public var httpstatusCode: Int?
    public var internalCode: String?
    public var message: String?
    public var developerMessage: String?
    public var helpLink: String?

    public init(httpstatusCode: Int? = nil, internalCode: String? = nil, message: String? = nil, developerMessage: String? = nil, helpLink: String? = nil) {
        self.httpstatusCode = httpstatusCode
        self.internalCode = internalCode
        self.message = message
        self.developerMessage = developerMessage
        self.helpLink = helpLink
    }

    private enum CodingKeys: String, CodingKey {
        case httpstatusCode = "httpStatusCode"
        case internalCode
        case message
        case developerMessage
        case helpLink
    }
}

/// Google Analytics for Call Tracking
public struct GoogleAnalytics: Codable {
    /// A domain name for analytics
    public var domain: String?
    /// An id of a Google account, example: UA-XXXXX-2X
    public var googleAccountID: String?
    /// A category to group. For example: Sales or Support
    public var category: String?

    public init(domain: String? = nil, googleAccountID: String? = nil, category: String? = nil) {
        self.domain = domain
        self.googleAccountID = googleAccountID
        self.category = category
    }

    private enum CodingKeys: String, CodingKey {
        case domain
        case googleAccountID = "googleAccountId"
        case category
    }
}

public struct ItemList: Codable {
    public var items: [[String: AnyJSON]]?

    public init(items: [[String: AnyJSON]]? = nil) {
        self.items = items
    }
}

public struct ItemListUniversalDoNotContact: Codable {
    public var items: [UniversalDoNotContact]?

    public init(items: [UniversalDoNotContact]? = nil) {
        self.items = items
    }
}

public struct ItemListWebhookResource: Codable {
    public var items: [WebhookResource]?

    public init(items: [WebhookResource]? = nil) {
        self.items = items
    }
}

public struct IvrInboundConfig: Codable {
    public var dialplanXml: String?

    public init(dialplanXml: String? = nil) {
        self.dialplanXml = dialplanXml
    }
}

public struct Keyword: Codable {
    public var shortCode: String?
    public var keyword: String?

    public init(shortCode: String? = nil, keyword: String? = nil) {
        self.shortCode = shortCode
        self.keyword = keyword
    }
}

public struct KeywordConfig: Codable {
    public var textInboundConfig: TextInboundConfig?
    public var keyword: String?

    public init(textInboundConfig: TextInboundConfig? = nil, keyword: String? = nil) {
        self.textInboundConfig = textInboundConfig
        self.keyword = keyword
    }
}

/// Represents a lease object for a given keyword
public struct KeywordLease: Codable {
    /// A short code assigned to keyword. Example: 67076
    public var shortCode: String?
    /// A text used as a keyword
    public var keyword: String?
    /// A time of a lease timestamp, formatted in unix time milliseconds (read only). Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT
    public var leaseBegin: Int?
    /// A date and time when the keyword lease is finishes. Timestamp, formatted in unix time milliseconds (read only). Example: 1473781817000
    public var leaseEnd: Int?
    /// Enables the auto renewal of a keyword lease at the end of each billing cycle
    public var isAutoRenew: Bool?
    /// Enable/disable double opt in feature
    public var isDoubleOptInEnabled: Bool?
    /// Opt in confirmation message
    public var optInConfirmationMessage: String?
    /// Existing contact list ID
    public var contactListID: Int?
    /// A lease status. Available values: PENDING, ACTIVE, RELEASED, UNAVAILABLE
    public var status: Status?
    public var labels: [String]?

    /// A lease status. Available values: PENDING, ACTIVE, RELEASED, UNAVAILABLE
    public enum Status: String, Codable, CaseIterable {
        case pending = "PENDING"
        case active = "ACTIVE"
        case released = "RELEASED"
        case unavailable = "UNAVAILABLE"
    }

    public init(shortCode: String? = nil, keyword: String? = nil, leaseBegin: Int? = nil, leaseEnd: Int? = nil, isAutoRenew: Bool? = nil, isDoubleOptInEnabled: Bool? = nil, optInConfirmationMessage: String? = nil, contactListID: Int? = nil, status: Status? = nil, labels: [String]? = nil) {
        self.shortCode = shortCode
        self.keyword = keyword
        self.leaseBegin = leaseBegin
        self.leaseEnd = leaseEnd
        self.isAutoRenew = isAutoRenew
        self.isDoubleOptInEnabled = isDoubleOptInEnabled
        self.optInConfirmationMessage = optInConfirmationMessage
        self.contactListID = contactListID
        self.status = status
        self.labels = labels
    }

    private enum CodingKeys: String, CodingKey {
        case shortCode
        case keyword
        case leaseBegin
        case leaseEnd
        case isAutoRenew = "autoRenew"
        case isDoubleOptInEnabled = "doubleOptInEnabled"
        case optInConfirmationMessage
        case contactListID = "contactListId"
        case status
        case labels
    }
}

public struct KeywordLeasePage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [KeywordLease]?

    public init(page: Page, items: [KeywordLease]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([KeywordLease].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

public struct KeywordList: Codable {
    public var itemList: ItemList
    public var items: [Keyword]?

    public init(itemList: ItemList, items: [Keyword]? = nil) {
        self.itemList = itemList
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.itemList = try ItemList(from: decoder)
        self.items = try values.decodeIfPresent([Keyword].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(itemList, forKey: "itemList")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// Request object is used to purchase keywords
public struct KeywordPurchaseRequest: Codable {
    /// A list of keywords
    public var keywords: [String]?

    public init(keywords: [String]? = nil) {
        self.keywords = keywords
    }
}

/// Represents a date object (without time part)
public struct LocalDate: Codable {
    /// A year. Example: 2020
    public var year: Int?
    /// A month of the year. Available values: 1-12
    public var month: Int?
    /// A day of the month. Available values: 1-31
    public var day: Int?

    public init(year: Int? = nil, month: Int? = nil, day: Int? = nil) {
        self.year = year
        self.month = month
        self.day = day
    }
}

/// Represents a time part of a given date
public struct LocalTime: Codable {
    /// An hour of the day. Available values: 0-23
    public var hour: Int?
    /// The minutes. Available values: 0-59
    public var minute: Int?
    /// The seconds.  Available values: 0-59
    public var second: Int?
    public var nano: Int?

    public init(hour: Int? = nil, minute: Int? = nil, second: Int? = nil, nano: Int? = nil) {
        self.hour = hour
        self.minute = minute
        self.second = second
        self.nano = nano
    }
}

/// Represents a range of time during which CallFire will send a call or text to recipients. Timeframe uses the local timezone of recipient's number
public struct LocalTimeRestriction: Codable {
    /// A restriction enabled
    public var isEnabled: Bool?
    /// An hour of restriction start
    public var beginHour: Int?
    /// The minutes to start a restriction
    public var beginMinute: Int?
    /// An hour of restriction end
    public var endHour: Int?
    /// The minutes of restriction end
    public var endMinute: Int?

    public init(isEnabled: Bool? = nil, beginHour: Int? = nil, beginMinute: Int? = nil, endHour: Int? = nil, endMinute: Int? = nil) {
        self.isEnabled = isEnabled
        self.beginHour = beginHour
        self.beginMinute = beginMinute
        self.endHour = endHour
        self.endMinute = endMinute
    }

    private enum CodingKeys: String, CodingKey {
        case isEnabled = "enabled"
        case beginHour
        case beginMinute
        case endHour
        case endMinute
    }
}

public struct LocalTimeZoneRestriction: Codable {
    public var startTime: Date?
    public var stopTime: Date?
    public var isEnabled: Bool?

    public init(startTime: Date? = nil, stopTime: Date? = nil, isEnabled: Bool? = nil) {
        self.startTime = startTime
        self.stopTime = stopTime
        self.isEnabled = isEnabled
    }

    private enum CodingKeys: String, CodingKey {
        case startTime
        case stopTime
        case isEnabled = "enabled"
    }
}

public struct Locale: Codable {
    public var displayName: String?
    public var script: String?
    public var country: String?
    public var variant: String?
    public var extensionKeys: [String]?
    public var unicodeLocaleAttributes: [String]?
    public var unicodeLocaleKeys: [String]?
    public var iso3Language: String?
    public var iso3Country: String?
    public var displayLanguage: String?
    public var displayScript: String?
    public var displayCountry: String?
    public var displayVariant: String?
    public var language: String?

    public init(displayName: String? = nil, script: String? = nil, country: String? = nil, variant: String? = nil, extensionKeys: [String]? = nil, unicodeLocaleAttributes: [String]? = nil, unicodeLocaleKeys: [String]? = nil, iso3Language: String? = nil, iso3Country: String? = nil, displayLanguage: String? = nil, displayScript: String? = nil, displayCountry: String? = nil, displayVariant: String? = nil, language: String? = nil) {
        self.displayName = displayName
        self.script = script
        self.country = country
        self.variant = variant
        self.extensionKeys = extensionKeys
        self.unicodeLocaleAttributes = unicodeLocaleAttributes
        self.unicodeLocaleKeys = unicodeLocaleKeys
        self.iso3Language = iso3Language
        self.iso3Country = iso3Country
        self.displayLanguage = displayLanguage
        self.displayScript = displayScript
        self.displayCountry = displayCountry
        self.displayVariant = displayVariant
        self.language = language
    }
}

public struct ManagedAccountDto: Codable {
    public var id: String?
    public var accountHolderID: String?
    public var email: String?
    public var name: String?
    public var state: State?
    public var lastLogin: Date?
    public var credits: Double?

    public enum State: String, Codable, CaseIterable {
        case active = "ACTIVE"
        case pending = "PENDING"
        case pendingVerification = "PENDING_VERIFICATION"
        case inReview = "IN_REVIEW"
    }

    public init(id: String? = nil, accountHolderID: String? = nil, email: String? = nil, name: String? = nil, state: State? = nil, lastLogin: Date? = nil, credits: Double? = nil) {
        self.id = id
        self.accountHolderID = accountHolderID
        self.email = email
        self.name = name
        self.state = state
        self.lastLogin = lastLogin
        self.credits = credits
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case accountHolderID = "accountHolderId"
        case email
        case name
        case state
        case lastLogin
        case credits
    }
}

public struct ManagedAccountsPage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [ManagedAccountDto]?

    public init(page: Page, items: [ManagedAccountDto]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([ManagedAccountDto].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// Represents a media file which can be added to a text message
public struct Media: Codable {
    /// An id of a media file
    public var id: Int?
    public var accountID: Int?
    /// A name of a media file
    public var name: String?
    /// The time when the given resource was created, formatted in unix time milliseconds (read only). Example: 1473781817000
    public var created: Int?
    /// A size of a media file in bytes
    public var lengthInBytes: Int?
    /// A MIME type of media file, ex: image/jpeg, image/png, video/mp4, audio/mp3, etc
    public var mediaType: String?
    /// A public URL of a media file
    public var publicURL: String?

    public init(id: Int? = nil, accountID: Int? = nil, name: String? = nil, created: Int? = nil, lengthInBytes: Int? = nil, mediaType: String? = nil, publicURL: String? = nil) {
        self.id = id
        self.accountID = accountID
        self.name = name
        self.created = created
        self.lengthInBytes = lengthInBytes
        self.mediaType = mediaType
        self.publicURL = publicURL
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case accountID = "accountId"
        case name
        case created
        case lengthInBytes
        case mediaType
        case publicURL = "publicUrl"
    }
}

public struct MediaPage: Codable {
    public var items: [Media]?
    public var limit: Int?
    public var offset: Int?
    public var totalCount: Int?

    public init(items: [Media]? = nil, limit: Int? = nil, offset: Int? = nil, totalCount: Int? = nil) {
        self.items = items
        self.limit = limit
        self.offset = offset
        self.totalCount = totalCount
    }
}

public struct MessageTemplateCategory: Codable {
    public var id: Int?
    public var name: String?

    public init(id: Int? = nil, name: String? = nil) {
        self.id = id
        self.name = name
    }
}

public struct MessageTemplateCategoryPage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [MessageTemplateCategory]?

    public init(page: Page, items: [MessageTemplateCategory]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([MessageTemplateCategory].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// Represents a note which can be added to a call
public struct Note: Codable {
    /// A text of a note
    public var text: String?
    /// The time when the given resource was created, formatted in unix time milliseconds (read only). Example: 1473781817000
    public var created: Int?

    public init(text: String? = nil, created: Int? = nil) {
        self.text = text
        self.created = created
    }
}

public struct Number: Codable {
    public var number: String?
    public var nationalFormat: String?
    public var isTollFree: Bool?
    /// Every local number associated with a region. You can query regions to use them in subsequent purchase requests
    public var region: Region?

    public init(number: String? = nil, nationalFormat: String? = nil, isTollFree: Bool? = nil, region: Region? = nil) {
        self.number = number
        self.nationalFormat = nationalFormat
        self.isTollFree = isTollFree
        self.region = region
    }

    private enum CodingKeys: String, CodingKey {
        case number
        case nationalFormat
        case isTollFree = "tollFree"
        case region
    }
}

/// Represents the configuration of a phone number purchased by user. You can configure number to accept inbound calls, play sounds to customer, make a transfer or setup an IVR script to interact with customer. See [CallFire IVR](https://www.callfire.com/products/ivr) for more info
public struct NumberConfig: Codable {
    public var textInboundConfig: TextInboundConfig?
    /// Phone number in E.164 format (11-digit). Example: 12132000384
    public var number: String?
    /// A type of config. Available values: TRACKING, IVR
    public var configType: ConfigType?
    /// Call tracking configuration allows you track incoming calls, analyze, respond to customers using sms or voice replies. For more information see [call tracking page](https://www.callfire.com/products/call-tracking)
    public var callTrackingConfig: CallTrackingConfig?
    public var ivrInboundConfig: IvrInboundConfig?

    /// A type of config. Available values: TRACKING, IVR
    public enum ConfigType: String, Codable, CaseIterable {
        case ivr = "IVR"
        case tracking = "TRACKING"
    }

    public init(textInboundConfig: TextInboundConfig? = nil, number: String? = nil, configType: ConfigType? = nil, callTrackingConfig: CallTrackingConfig? = nil, ivrInboundConfig: IvrInboundConfig? = nil) {
        self.textInboundConfig = textInboundConfig
        self.number = number
        self.configType = configType
        self.callTrackingConfig = callTrackingConfig
        self.ivrInboundConfig = ivrInboundConfig
    }
}

public struct NumberConfigPage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [NumberConfig]?

    public init(page: Page, items: [NumberConfig]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([NumberConfig].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// Represents a lease object for a given phone number
public struct NumberLease: Codable {
    /// A phone number in E.164 format (11-digit). Example: 12132000384
    public var number: String?
    /// Formatted number with a country code
    public var nationalFormat: String?
    /// A  toll-free number
    public var isTollFree: Bool?
    /// Every local number associated with a region. You can query regions to use them in subsequent purchase requests
    public var region: Region?
    /// A date and time of a lease start. Timestamp, formatted in unix time milliseconds (read only). Example: 1473781817000
    public var leaseBegin: Int?
    /// A data and time of a lease finish. Timestamp, formatted in unix time milliseconds (read only). Example: 1473781817000
    public var leaseEnd: Int?
    /// Enables the auto renewal of number lease at end of each billing cycle
    public var isAutoRenew: Bool?
    /// A lease status. Available values: PENDING, ACTIVE, RELEASED, UNAVAILABLE
    public var status: Status?
    /// A status of a call feature. Available values: DISABLED, ENABLED
    public var callFeatureStatus: CallFeatureStatus?
    /// A status of a text feature. Available values: DISABLED, ENABLED
    public var textFeatureStatus: TextFeatureStatus?
    public var labels: [String]?

    /// A lease status. Available values: PENDING, ACTIVE, RELEASED, UNAVAILABLE
    public enum Status: String, Codable, CaseIterable {
        case pending = "PENDING"
        case active = "ACTIVE"
        case released = "RELEASED"
        case unavailable = "UNAVAILABLE"
    }

    /// A status of a call feature. Available values: DISABLED, ENABLED
    public enum CallFeatureStatus: String, Codable, CaseIterable {
        case unsupported = "UNSUPPORTED"
        case pending = "PENDING"
        case disabled = "DISABLED"
        case enabled = "ENABLED"
    }

    /// A status of a text feature. Available values: DISABLED, ENABLED
    public enum TextFeatureStatus: String, Codable, CaseIterable {
        case unsupported = "UNSUPPORTED"
        case pending = "PENDING"
        case disabled = "DISABLED"
        case enabled = "ENABLED"
    }

    public init(number: String? = nil, nationalFormat: String? = nil, isTollFree: Bool? = nil, region: Region? = nil, leaseBegin: Int? = nil, leaseEnd: Int? = nil, isAutoRenew: Bool? = nil, status: Status? = nil, callFeatureStatus: CallFeatureStatus? = nil, textFeatureStatus: TextFeatureStatus? = nil, labels: [String]? = nil) {
        self.number = number
        self.nationalFormat = nationalFormat
        self.isTollFree = isTollFree
        self.region = region
        self.leaseBegin = leaseBegin
        self.leaseEnd = leaseEnd
        self.isAutoRenew = isAutoRenew
        self.status = status
        self.callFeatureStatus = callFeatureStatus
        self.textFeatureStatus = textFeatureStatus
        self.labels = labels
    }

    private enum CodingKeys: String, CodingKey {
        case number
        case nationalFormat
        case isTollFree = "tollFree"
        case region
        case leaseBegin
        case leaseEnd
        case isAutoRenew = "autoRenew"
        case status
        case callFeatureStatus
        case textFeatureStatus
        case labels
    }
}

public struct NumberLeasePage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [NumberLease]?

    public init(page: Page, items: [NumberLease]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([NumberLease].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

public struct NumberList: Codable {
    public var itemList: ItemList
    public var items: [Number]?

    public init(itemList: ItemList, items: [Number]? = nil) {
        self.itemList = itemList
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.itemList = try ItemList(from: decoder)
        self.items = try values.decodeIfPresent([Number].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(itemList, forKey: "itemList")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// Represents an order created on the CallFire platform
public struct NumberOrder: Codable {
    /// An id of an order
    public var id: Int?
    /// A current status of an order. Available values: NEW, PROCESSING, FINISHED, ERRORED, VOID, WAIT_FOR_PAYMENT, REJECTED
    public var status: Status?
    /// The time when the given resource was created, formatted in unix time milliseconds (read only). Example: 1473781817000
    public var created: Int?
    /// A total cost of an order
    public var totalCost: Double?
    public var total: Double?
    public var summary: Double?
    public var salesTax: Double?
    /// Represents an order item of a particular order
    public var localNumbers: NumberOrderItem?
    /// Represents an order item of a particular order
    public var tollFreeNumbers: NumberOrderItem?
    /// Represents an order item of a particular order
    public var keywords: NumberOrderItem?

    /// A current status of an order. Available values: NEW, PROCESSING, FINISHED, ERRORED, VOID, WAIT_FOR_PAYMENT, REJECTED
    public enum Status: String, Codable, CaseIterable {
        case processing = "PROCESSING"
        case finished = "FINISHED"
        case paymentError = "PAYMENT_ERROR"
        case void = "VOID"
        case waitForPayment = "WAIT_FOR_PAYMENT"
        case partiallyAdjusted = "PARTIALLY_ADJUSTED"
        case adjusted = "ADJUSTED"
        case new = "NEW"
        case errored = "ERRORED"
        case approveTierOne = "APPROVE_TIER_ONE"
        case approveTierTwo = "APPROVE_TIER_TWO"
        case rejected = "REJECTED"
    }

    public init(id: Int? = nil, status: Status? = nil, created: Int? = nil, totalCost: Double? = nil, total: Double? = nil, summary: Double? = nil, salesTax: Double? = nil, localNumbers: NumberOrderItem? = nil, tollFreeNumbers: NumberOrderItem? = nil, keywords: NumberOrderItem? = nil) {
        self.id = id
        self.status = status
        self.created = created
        self.totalCost = totalCost
        self.total = total
        self.summary = summary
        self.salesTax = salesTax
        self.localNumbers = localNumbers
        self.tollFreeNumbers = tollFreeNumbers
        self.keywords = keywords
    }
}

/// Represents an order item of a particular order
public struct NumberOrderItem: Codable {
    /// A total number of items bought within a single order item
    public var ordered: Int?
    /// A cost of unit
    public var unitCost: Double?
    /// List of fulfilled items, e.g. phone numbers, keywords
    public var fulfilled: [String]?

    public init(ordered: Int? = nil, unitCost: Double? = nil, fulfilled: [String]? = nil) {
        self.ordered = ordered
        self.unitCost = unitCost
        self.fulfilled = fulfilled
    }
}

/// Request object is used to order a local or toll-free numbers
public struct NumberPurchaseRequest: Codable {
    /// Total count of toll-free numbers requested
    public var tollFreeCount: Int?
    /// Total count of local numbers requested
    public var localCount: Int?
    /// Country prefix of requested numbers
    public var prefix: String?
    /// City of requested numbers
    public var city: String?
    /// A two-letter state code of requested numbers
    public var state: String?
    /// A five-digit Zip code of requested numbers
    public var zipcode: String?
    /// A list of phone numbers in E.164 format (11-digit) to buy. Example: 12132000384
    public var numbers: [String]?
    public var promo: String?

    public init(tollFreeCount: Int? = nil, localCount: Int? = nil, prefix: String? = nil, city: String? = nil, state: String? = nil, zipcode: String? = nil, numbers: [String]? = nil, promo: String? = nil) {
        self.tollFreeCount = tollFreeCount
        self.localCount = localCount
        self.prefix = prefix
        self.city = city
        self.state = state
        self.zipcode = zipcode
        self.numbers = numbers
        self.promo = promo
    }
}

public final class OAuthSession: Codable {
    public var clientID: String?
    public var brand: Brand?
    public var id: String?
    public var scope: String?
    public var issued: Date?
    public var expires: Date?
    public var ipAddress: String?
    public var accountID: String?
    public var userID: String?
    public var username: String?
    public var email: String?
    public var sid: Int?
    public var grantType: GrantType?
    public var actor: OAuthSession?
    public var isVerificationRequired: Bool?

    public enum Brand: String, Codable, CaseIterable {
        case eztexting = "EZTEXTING"
        case clubtexting = "CLUBTEXTING"
        case grouptexting = "GROUPTEXTING"
        case tellmycell = "TELLMYCELL"
        case ez = "EZ"
        case callfire = "CALLFIRE"
        case tesla = "TESLA"
    }

    public enum GrantType: String, Codable, CaseIterable {
        case authorizationCode = "AUTHORIZATION_CODE"
        case password = "PASSWORD"
        case refreshToken = "REFRESH_TOKEN"
        case clientCredentials = "CLIENT_CREDENTIALS"
        case jwtBearer = "JWT_BEARER"
        case impersonate = "IMPERSONATE"
        case exchange = "EXCHANGE"
    }

    public init(clientID: String? = nil, brand: Brand? = nil, id: String? = nil, scope: String? = nil, issued: Date? = nil, expires: Date? = nil, ipAddress: String? = nil, accountID: String? = nil, userID: String? = nil, username: String? = nil, email: String? = nil, sid: Int? = nil, grantType: GrantType? = nil, actor: OAuthSession? = nil, isVerificationRequired: Bool? = nil) {
        self.clientID = clientID
        self.brand = brand
        self.id = id
        self.scope = scope
        self.issued = issued
        self.expires = expires
        self.ipAddress = ipAddress
        self.accountID = accountID
        self.userID = userID
        self.username = username
        self.email = email
        self.sid = sid
        self.grantType = grantType
        self.actor = actor
        self.isVerificationRequired = isVerificationRequired
    }

    private enum CodingKeys: String, CodingKey {
        case clientID = "clientId"
        case brand
        case id
        case scope
        case issued
        case expires
        case ipAddress
        case accountID = "accountId"
        case userID = "userId"
        case username
        case email
        case sid
        case grantType
        case actor
        case isVerificationRequired = "verificationRequired"
    }
}

/// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
public struct Page: Codable {
    /// A list of returned items
    public var items: [[String: AnyJSON]]?
    /// A maximum number of returned items. If items.size() < limit assume no more items
    public var limit: Int?
    /// An offset from a start of paging source
    public var offset: Int?
    /// Total count of available results. -1 if unknown
    public var totalCount: Int?

    public init(items: [[String: AnyJSON]]? = nil, limit: Int? = nil, offset: Int? = nil, totalCount: Int? = nil) {
        self.items = items
        self.limit = limit
        self.offset = offset
        self.totalCount = totalCount
    }
}

public struct PageDeliveryReport: Codable {
    public var items: [DeliveryReport]?
    public var limit: Int?
    public var offset: Int?
    public var totalCount: Int?

    public init(items: [DeliveryReport]? = nil, limit: Int? = nil, offset: Int? = nil, totalCount: Int? = nil) {
        self.items = items
        self.limit = limit
        self.offset = offset
        self.totalCount = totalCount
    }
}

public struct PageNumberOrder: Codable {
    public var items: [NumberOrder]?
    public var limit: Int?
    public var offset: Int?
    public var totalCount: Int?

    public init(items: [NumberOrder]? = nil, limit: Int? = nil, offset: Int? = nil, totalCount: Int? = nil) {
        self.items = items
        self.limit = limit
        self.offset = offset
        self.totalCount = totalCount
    }
}

public struct PageText: Codable {
    public var items: [Text]?
    public var limit: Int?
    public var offset: Int?
    public var totalCount: Int?

    public init(items: [Text]? = nil, limit: Int? = nil, offset: Int? = nil, totalCount: Int? = nil) {
        self.items = items
        self.limit = limit
        self.offset = offset
        self.totalCount = totalCount
    }
}

/// Object represents the question and client's answer, used in cloud call center / IVR campaign
public struct QuestionResponse: Codable {
    /// A text of a question
    public var question: String?
    /// Client's answer
    public var response: String?

    public init(question: String? = nil, response: String? = nil) {
        self.question = question
        self.response = response
    }
}

/// A recipient of a campaign action. It can be a phone number, contact, or contact list with attributes added to an action, one of these values should be set
public struct Recipient: Codable {
    /// A recipient's phone number in E.164 format (11-digit) or short code. Example: 12132000384, 67076
    public var phoneNumber: String?
    public var fromNumber: String?
    /// An id of existing contact used as recipient
    public var contactID: Int?
    /// Map of user-defined string attributes associated with recipient
    public var attributes: [String: String]?

    public init(phoneNumber: String? = nil, fromNumber: String? = nil, contactID: Int? = nil, attributes: [String: String]? = nil) {
        self.phoneNumber = phoneNumber
        self.fromNumber = fromNumber
        self.contactID = contactID
        self.attributes = attributes
    }

    private enum CodingKeys: String, CodingKey {
        case phoneNumber
        case fromNumber
        case contactID = "contactId"
        case attributes
    }
}

/// Every local number associated with a region. You can query regions to use them in subsequent purchase requests
public struct Region: Codable {
    /// A country prefix of a region. 4-7 digit
    public var prefix: String?
    /// A city of a region
    public var city: String?
    /// A two-letter state code of region
    public var state: String?
    /// A five-digit zip code of a region
    public var zipcode: String?
    /// A country of a region
    public var country: String?
    /// A latitude of a region
    public var latitude: Double?
    /// A longitude of a region
    public var longitude: Double?
    /// A timezone of a region
    public var timeZone: String?

    public init(prefix: String? = nil, city: String? = nil, state: String? = nil, zipcode: String? = nil, country: String? = nil, latitude: Double? = nil, longitude: Double? = nil, timeZone: String? = nil) {
        self.prefix = prefix
        self.city = city
        self.state = state
        self.zipcode = zipcode
        self.country = country
        self.latitude = latitude
        self.longitude = longitude
        self.timeZone = timeZone
    }
}

public struct RegionPage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [Region]?

    public init(page: Page, items: [Region]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([Region].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// An id of a resource
public struct ResourceID: Codable {
    /// An id of a resource
    public var id: Int?

    public init(id: Int? = nil) {
        self.id = id
    }
}

public struct ResourceIDList: Codable {
    public var itemList: ItemList
    public var items: [ResourceID]?

    public init(itemList: ItemList, items: [ResourceID]? = nil) {
        self.itemList = itemList
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.itemList = try ItemList(from: decoder)
        self.items = try values.decodeIfPresent([ResourceID].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(itemList, forKey: "itemList")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// Retry configuration will help you to resend a call or text if it was not delivered first time
public struct RetryConfig: Codable {
    /// Maximum number of retry attempts. Default value: 1
    public var maxAttempts: Int?
    /// A number of minutes between retry attempts. Default value: 60
    public var minutesBetweenAttempts: Int?
    /// List of result states when a call/text should be addressed to this contact again. Supports any combination of result statuses. Available values: LA, BUSY, AM, NO_ANS, SENT, RECEIVED, etc. See [call/text states and results](https://developers.callfire.com/results-responses-errors.html)
    public var retryResults: [String]?
    /// A list of phone number types to retry. Available values: FIRST_NUMBER, HOME_PHONE, WORK_PHONE, MOBILE_PHONE
    public var retryPhoneTypes: [String]?

    public init(maxAttempts: Int? = nil, minutesBetweenAttempts: Int? = nil, retryResults: [String]? = nil, retryPhoneTypes: [String]? = nil) {
        self.maxAttempts = maxAttempts
        self.minutesBetweenAttempts = minutesBetweenAttempts
        self.retryResults = retryResults
        self.retryPhoneTypes = retryPhoneTypes
    }
}

/// A campaign schedule
public struct Schedule: Codable {
    /// Represents a time part of a given date
    public var startTimeOfDay: LocalTime?
    /// Represents a time part of a given date
    public var stopTimeOfDay: LocalTime?
    public var daysOfWeek: [String]?
    public var timeZone: String?
    public var id: Int?
    public var campaignID: Int?
    /// Represents a date object (without time part)
    public var startDate: LocalDate?
    /// Represents a date object (without time part)
    public var stopDate: LocalDate?

    public init(startTimeOfDay: LocalTime? = nil, stopTimeOfDay: LocalTime? = nil, daysOfWeek: [String]? = nil, timeZone: String? = nil, id: Int? = nil, campaignID: Int? = nil, startDate: LocalDate? = nil, stopDate: LocalDate? = nil) {
        self.startTimeOfDay = startTimeOfDay
        self.stopTimeOfDay = stopTimeOfDay
        self.daysOfWeek = daysOfWeek
        self.timeZone = timeZone
        self.id = id
        self.campaignID = campaignID
        self.startDate = startDate
        self.stopDate = stopDate
    }

    private enum CodingKeys: String, CodingKey {
        case startTimeOfDay
        case stopTimeOfDay
        case daysOfWeek
        case timeZone
        case id
        case campaignID = "campaignId"
        case startDate
        case stopDate
    }
}

public struct StringList: Codable {
    public var itemList: ItemList
    public var items: [String]?

    public init(itemList: ItemList, items: [String]? = nil) {
        self.itemList = itemList
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.itemList = try ItemList(from: decoder)
        self.items = try values.decodeIfPresent([String].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(itemList, forKey: "itemList")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

public struct TemporalUnit: Codable {
    public var isDateBased: Bool?
    public var isTimeBased: Bool?
    public var duration: Duration?
    public var isDurationEstimated: Bool?

    public init(isDateBased: Bool? = nil, isTimeBased: Bool? = nil, duration: Duration? = nil, isDurationEstimated: Bool? = nil) {
        self.isDateBased = isDateBased
        self.isTimeBased = isTimeBased
        self.duration = duration
        self.isDurationEstimated = isDurationEstimated
    }

    private enum CodingKeys: String, CodingKey {
        case isDateBased = "dateBased"
        case isTimeBased = "timeBased"
        case duration
        case isDurationEstimated = "durationEstimated"
    }
}

/// Represents a text action sent or received by CallFire platform
public struct Text: Codable {
    /// An id of an action
    public var id: Int?
    /// Sender's phone number in E.164 format (11-digit) or short code. Example: 12132000384, 67076
    public var fromNumber: String?
    /// Recipient's phone number in E.164 format (11-digit) or short code. Example: 12132000384, 67076
    public var toNumber: String?
    /// Map of user-defined string attributes associated with an action
    public var attributes: [String: String]?
    /// Current state of an action (READY, SELECTED, CALLBACK, DISABLED, FINISHED, DNC, DUP, INVALID, TIMEOUT, PERIOD_LIMIT). See [call states and results](https://developers.callfire.com/results-responses-errors.html)
    public var state: State?
    /// An id of broadcast if given text was sent as a part of text broadcast
    public var campaignID: Int?
    /// An id of contact batch associated with an action
    public var batchID: Int?
    /// Represents a contact in CallFire platform. Contains info about the people you want to contact. It allows you to store a user-defined properties for each contact
    public var contact: Contact?
    /// An action inbound
    public var isInbound: Bool?
    /// The time when the given resource was created, formatted in unix time milliseconds (read only). Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT
    public var created: Int?
    /// The time when the given resource was modified, formatted in unix time milliseconds (read only). Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT
    public var modified: Int?
    /// Labels associated with an action
    public var labels: [String]?
    /// A text message
    public var message: String?
    /// Result of text (SENT, RECEIVED, DNT, TOO_BIG, INTERNAL_ERROR, CARRIER_ERROR, CARRIER_TEMP_ERROR, UNDIALED). See [call states and results](https://developers.callfire.com/results-responses-errors.html)
    public var finalTextResult: FinalTextResult?
    /// List of text records, each record contains additional details: time of sending, cost, current state.  A single contact may have multiple numbers. If given text was sent as part of broadcast with configured retry logic then each text record will contain details about attempted number
    public var records: [TextRecord]?
    public var media: [Media]?

    /// Current state of an action (READY, SELECTED, CALLBACK, DISABLED, FINISHED, DNC, DUP, INVALID, TIMEOUT, PERIOD_LIMIT). See [call states and results](https://developers.callfire.com/results-responses-errors.html)
    public enum State: String, Codable, CaseIterable {
        case ready = "READY"
        case selected = "SELECTED"
        case callback = "CALLBACK"
        case finished = "FINISHED"
        case disabled = "DISABLED"
        case skipped = "SKIPPED"
        case dnc = "DNC"
        case dup = "DUP"
        case invalid = "INVALID"
        case timeout = "TIMEOUT"
        case periodLimit = "PERIOD_LIMIT"
    }

    /// Result of text (SENT, RECEIVED, DNT, TOO_BIG, INTERNAL_ERROR, CARRIER_ERROR, CARRIER_TEMP_ERROR, UNDIALED). See [call states and results](https://developers.callfire.com/results-responses-errors.html)
    public enum FinalTextResult: String, Codable, CaseIterable {
        case sent = "SENT"
        case received = "RECEIVED"
        case dnt = "DNT"
        case tooBig = "TOO_BIG"
        case internalError = "INTERNAL_ERROR"
        case carrierError = "CARRIER_ERROR"
        case carrierTempError = "CARRIER_TEMP_ERROR"
        case undialed = "UNDIALED"
        case invalidNumber = "INVALID_NUMBER"
    }

    public init(id: Int? = nil, fromNumber: String? = nil, toNumber: String? = nil, attributes: [String: String]? = nil, state: State? = nil, campaignID: Int? = nil, batchID: Int? = nil, contact: Contact? = nil, isInbound: Bool? = nil, created: Int? = nil, modified: Int? = nil, labels: [String]? = nil, message: String? = nil, finalTextResult: FinalTextResult? = nil, records: [TextRecord]? = nil, media: [Media]? = nil) {
        self.id = id
        self.fromNumber = fromNumber
        self.toNumber = toNumber
        self.attributes = attributes
        self.state = state
        self.campaignID = campaignID
        self.batchID = batchID
        self.contact = contact
        self.isInbound = isInbound
        self.created = created
        self.modified = modified
        self.labels = labels
        self.message = message
        self.finalTextResult = finalTextResult
        self.records = records
        self.media = media
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case fromNumber
        case toNumber
        case attributes
        case state
        case campaignID = "campaignId"
        case batchID = "batchId"
        case contact
        case isInbound = "inbound"
        case created
        case modified
        case labels
        case message
        case finalTextResult
        case records
        case media
    }
}

/// CallFire allows you to set up auto reply messages for your numbers CallFire allows you to set up auto reply messages for your numbers and keywords. You can set a general auto reply for anyone who texts your number (keyword). Also you can include a text to match, so that the auto reply would be sent only to those recipients whose texts the matched text
public struct TextAutoReply: Codable {
    /// An id of a text auto reply
    public var id: Int?
    /// Setup autoreply for a given phone number, E.164 format (11-digit). Example: 12132000384
    public var number: String?
    /// Setup autoreply for a given keyword
    public var keyword: String?
    /// Text to match. If it is set then autoreply will be sent to a person who texted message with matched text. Case insensitive, if parameter is not specified then all texts will be matched
    public var match: String?
    /// A text message to return as an auto reply
    public var message: String?

    public init(id: Int? = nil, number: String? = nil, keyword: String? = nil, match: String? = nil, message: String? = nil) {
        self.id = id
        self.number = number
        self.keyword = keyword
        self.match = match
        self.message = message
    }
}

public struct TextAutoReplyPage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [TextAutoReply]?

    public init(page: Page, items: [TextAutoReply]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([TextAutoReply].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// A text campaign allows you to send a text message to a number of recipients. It supports scheduling, retry logic and pattern-based messages
public struct TextBroadcast: Codable {
    /// A unique id of a broadcast
    public var id: Int?
    /// A name of a broadcast
    public var name: String?
    /// A status of a broadcast. SETUP - campaign isn't configured yet; START_PENDING - waiting for contact batch population; RUNNING - campaign is running; STOPPED - campaign is stopped; FINISHED - campaign is finished; ARCHIVED - campaign was archived
    public var status: Status?
    /// A time when the given resource was updated, formatted in unix time milliseconds (read only). Example: 1473781817000
    public var lastModified: Int?
    /// A phone number in E.164 format (11-digit) or short code. Example: 12132000384, 67076, etc
    public var fromNumber: String?
    /// Represents a range of time during which CallFire will send a call or text to recipients. Timeframe uses the local timezone of recipient's number
    public var localTimeRestriction: LocalTimeRestriction?
    public var schedules: [Schedule]?
    /// A maximum number of texts that CallFire dials at once
    public var maxActive: Int?
    /// A labels of a broadcast
    public var labels: [String]?
    public var isResumeNextDay: Bool?
    /// Recipients of a text campaign, can be an existing contacts or a new one
    public var recipients: [TextRecipient]?
    /// A text message
    public var message: String?
    /// If message length exceeds 160 characters, multiple messages will be sent, SEND_MULTIPLE strategy is chosen by default. Available values: SEND_MULTIPLE - send text as multiple messages, DO_NOT_SEND - do not send text if it exceeds 160 characters, TRIM - trims text message to 160 characters
    public var bigMessageStrategy: BigMessageStrategy?
    public var media: [Media]?

    /// A status of a broadcast. SETUP - campaign isn't configured yet; START_PENDING - waiting for contact batch population; RUNNING - campaign is running; STOPPED - campaign is stopped; FINISHED - campaign is finished; ARCHIVED - campaign was archived
    public enum Status: String, Codable, CaseIterable {
        case test = "TEST"
        case setup = "SETUP"
        case startPending = "START_PENDING"
        case running = "RUNNING"
        case scheduled = "SCHEDULED"
        case stopped = "STOPPED"
        case suspended = "SUSPENDED"
        case finished = "FINISHED"
        case archived = "ARCHIVED"
        case validatingStart = "VALIDATING_START"
        case validatingEmail = "VALIDATING_EMAIL"
        case blockedSuspicious = "BLOCKED_SUSPICIOUS"
        case declined = "DECLINED"
        case approved = "APPROVED"
    }

    /// If message length exceeds 160 characters, multiple messages will be sent, SEND_MULTIPLE strategy is chosen by default. Available values: SEND_MULTIPLE - send text as multiple messages, DO_NOT_SEND - do not send text if it exceeds 160 characters, TRIM - trims text message to 160 characters
    public enum BigMessageStrategy: String, Codable, CaseIterable {
        case sendMultiple = "SEND_MULTIPLE"
        case doNotSend = "DO_NOT_SEND"
        case trim = "TRIM"
        case mms = "MMS"
    }

    public init(id: Int? = nil, name: String? = nil, status: Status? = nil, lastModified: Int? = nil, fromNumber: String? = nil, localTimeRestriction: LocalTimeRestriction? = nil, schedules: [Schedule]? = nil, maxActive: Int? = nil, labels: [String]? = nil, isResumeNextDay: Bool? = nil, recipients: [TextRecipient]? = nil, message: String? = nil, bigMessageStrategy: BigMessageStrategy? = nil, media: [Media]? = nil) {
        self.id = id
        self.name = name
        self.status = status
        self.lastModified = lastModified
        self.fromNumber = fromNumber
        self.localTimeRestriction = localTimeRestriction
        self.schedules = schedules
        self.maxActive = maxActive
        self.labels = labels
        self.isResumeNextDay = isResumeNextDay
        self.recipients = recipients
        self.message = message
        self.bigMessageStrategy = bigMessageStrategy
        self.media = media
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case status
        case lastModified
        case fromNumber
        case localTimeRestriction
        case schedules
        case maxActive
        case labels
        case isResumeNextDay = "resumeNextDay"
        case recipients
        case message
        case bigMessageStrategy
        case media
    }
}

public struct TextBroadcastCreateResponse: Codable {
    public var id: Int?

    public init(id: Int? = nil) {
        self.id = id
    }
}

public struct TextBroadcastPage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [TextBroadcast]?

    public init(page: Page, items: [TextBroadcast]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([TextBroadcast].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

public struct TextBroadcastStatsDto: Codable {
    public var totalOutboundCount: Int?
    public var remainingOutboundCount: Int?
    public var billedAmount: Double?
    public var sentCount: Int?
    public var unsentCount: Int?
    public var recievedCount: Int?
    public var doNotTextCount: Int?
    public var tooBigCount: Int?
    public var errorCount: Int?

    public init(totalOutboundCount: Int? = nil, remainingOutboundCount: Int? = nil, billedAmount: Double? = nil, sentCount: Int? = nil, unsentCount: Int? = nil, recievedCount: Int? = nil, doNotTextCount: Int? = nil, tooBigCount: Int? = nil, errorCount: Int? = nil) {
        self.totalOutboundCount = totalOutboundCount
        self.remainingOutboundCount = remainingOutboundCount
        self.billedAmount = billedAmount
        self.sentCount = sentCount
        self.unsentCount = unsentCount
        self.recievedCount = recievedCount
        self.doNotTextCount = doNotTextCount
        self.tooBigCount = tooBigCount
        self.errorCount = errorCount
    }
}

public struct TextInboundConfig: Codable {
    public var isForwardEnabled: Bool?
    public var forwardNumber: String?

    public init(isForwardEnabled: Bool? = nil, forwardNumber: String? = nil) {
        self.isForwardEnabled = isForwardEnabled
        self.forwardNumber = forwardNumber
    }

    private enum CodingKeys: String, CodingKey {
        case isForwardEnabled = "forwardEnabled"
        case forwardNumber
    }
}

public struct TextList: Codable {
    public var itemList: ItemList
    public var items: [Text]?

    public init(itemList: ItemList, items: [Text]? = nil) {
        self.itemList = itemList
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.itemList = try ItemList(from: decoder)
        self.items = try values.decodeIfPresent([Text].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(itemList, forKey: "itemList")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

public struct TextPage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [Text]?

    public init(page: Page, items: [Text]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([Text].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// A recipient of a text message. You should provide either phone number or contact id of existing contact
public struct TextRecipient: Codable {
    /// Phone number in E.164 format (11-digit) or short code. Example: 12132000384, 67076
    public var phoneNumber: String?
    public var fromNumber: String?
    /// An id of existing contact in account
    public var contactID: Int?
    /// A map of string attributes associated with a recipient
    public var attributes: [String: String]?
    /// A text message
    public var message: String?
    /// A list of media objects' ids associated with a text message
    public var media: [Media]?

    public init(phoneNumber: String? = nil, fromNumber: String? = nil, contactID: Int? = nil, attributes: [String: String]? = nil, message: String? = nil, media: [Media]? = nil) {
        self.phoneNumber = phoneNumber
        self.fromNumber = fromNumber
        self.contactID = contactID
        self.attributes = attributes
        self.message = message
        self.media = media
    }

    private enum CodingKeys: String, CodingKey {
        case phoneNumber
        case fromNumber
        case contactID = "contactId"
        case attributes
        case message
        case media
    }
}

/// Represents a text message sent to a contact's number
public struct TextRecord: Codable {
    /// An id of a text record
    public var id: Int?
    /// An attempted phone number
    public var toNumber: String?
    /// A cost of a sent text
    public var billedAmount: Double?
    /// A time when the given resource was updated, formatted in unix time milliseconds (read only). Example: 1473781817000
    public var finishTime: Int?
    public var switchID: String?
    public var callerName: String?
    /// Labels associated with a text action
    public var labels: [String]?
    /// A text message
    public var message: String?
    /// Result of a text (SENT, RECEIVED, DNT, TOO_BIG, INTERNAL_ERROR, CARRIER_ERROR, CARRIER_TEMP_ERROR, UNDIALED). See [call states and results](https://developers.callfire.com/results-responses-errors.html)
    public var textResult: TextResult?

    /// Result of a text (SENT, RECEIVED, DNT, TOO_BIG, INTERNAL_ERROR, CARRIER_ERROR, CARRIER_TEMP_ERROR, UNDIALED). See [call states and results](https://developers.callfire.com/results-responses-errors.html)
    public enum TextResult: String, Codable, CaseIterable {
        case sent = "SENT"
        case received = "RECEIVED"
        case dnt = "DNT"
        case tooBig = "TOO_BIG"
        case internalError = "INTERNAL_ERROR"
        case carrierError = "CARRIER_ERROR"
        case carrierTempError = "CARRIER_TEMP_ERROR"
        case undialed = "UNDIALED"
        case invalidNumber = "INVALID_NUMBER"
    }

    public init(id: Int? = nil, toNumber: String? = nil, billedAmount: Double? = nil, finishTime: Int? = nil, switchID: String? = nil, callerName: String? = nil, labels: [String]? = nil, message: String? = nil, textResult: TextResult? = nil) {
        self.id = id
        self.toNumber = toNumber
        self.billedAmount = billedAmount
        self.finishTime = finishTime
        self.switchID = switchID
        self.callerName = callerName
        self.labels = labels
        self.message = message
        self.textResult = textResult
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case toNumber
        case billedAmount
        case finishTime
        case switchID = "switchId"
        case callerName
        case labels
        case message
        case textResult
    }
}

/// Request object is used to create a sound from provided text using text to speech engine
public struct TextToSpeech: Codable {
    /// A voice to be used. Available values: MALE1, FEMALE1 , FEMALE2, SPANISH1, FRENCHCANADIAN1
    public var voice: Voice?
    /// A text to be turned into sound
    public var message: String?

    /// A voice to be used. Available values: MALE1, FEMALE1 , FEMALE2, SPANISH1, FRENCHCANADIAN1
    public enum Voice: String, Codable, CaseIterable {
        case male1 = "MALE1"
        case female1 = "FEMALE1"
        case female2 = "FEMALE2"
        case spanish1 = "SPANISH1"
        case frenchcanadian1 = "FRENCHCANADIAN1"
    }

    public init(voice: Voice? = nil, message: String? = nil) {
        self.voice = voice
        self.message = message
    }
}

public struct TimeZone: Codable {
    public var displayName: String?
    public var id: String?
    public var dstsavings: Int?
    public var rawOffset: Int?

    public init(displayName: String? = nil, id: String? = nil, dstsavings: Int? = nil, rawOffset: Int? = nil) {
        self.displayName = displayName
        self.id = id
        self.dstsavings = dstsavings
        self.rawOffset = rawOffset
    }
}

/// Represents a Universal (platform-wide) Do-Not-Contact object for a given phone number. Shows whether inbound/outbound actions are allowed for a given number.
public struct UniversalDoNotContact: Codable {
    /// Destination DNC number in E.164 format (11-digit). Example: 12132000384
    public var toNumber: String?
    /// Optional source number in E.164 format (11-digit). Example: 12132000384
    public var fromNumber: String?
    /// If toNumber can receive calls or If toNumber can call fromNumber.
    public var isInboundCall: Bool?
    /// If toNumber can receive texts or If toNumber can text fromNumber.
    public var isInboundText: Bool?
    /// If toNumber can send calls or If fromNumber can call toNumber.
    public var isOutboundCall: Bool?
    /// If toNumber can send texts or If fromNumber can text toNumber.
    public var isOutboundText: Bool?

    public init(toNumber: String? = nil, fromNumber: String? = nil, isInboundCall: Bool? = nil, isInboundText: Bool? = nil, isOutboundCall: Bool? = nil, isOutboundText: Bool? = nil) {
        self.toNumber = toNumber
        self.fromNumber = fromNumber
        self.isInboundCall = isInboundCall
        self.isInboundText = isInboundText
        self.isOutboundCall = isOutboundCall
        self.isOutboundText = isOutboundText
    }

    private enum CodingKeys: String, CodingKey {
        case toNumber
        case fromNumber
        case isInboundCall = "inboundCall"
        case isInboundText = "inboundText"
        case isOutboundCall = "outboundCall"
        case isOutboundText = "outboundText"
    }
}

/// A request object which is used to update a contact list
public struct UpdateContactListRequest: Codable {
    /// A name of a contact list
    public var name: String?

    public init(name: String? = nil) {
        self.name = name
    }
}

public final class User: Codable {
    public var soaUser: User?
    public var account: Account?
    public var fullName: String?
    public var permissions: [String]?
    public var id: Int?
    public var isActive: Bool?
    public var isVisible: Bool?
    public var created: Date?
    public var brand: Brand?
    public var accountID: Int?
    public var phoneNumber: String?
    public var profileEmail: String?
    public var userState: UserState?
    public var isCccAgent: Bool?
    public var dateOfBirth: Date?
    public var phoneNumberExtension: String?
    public var phoneNumberExtensionDelaySec: Int?
    public var optInNumber: String?
    public var isOptIn: Bool?
    public var musicOnHold: MusicOnHold?
    public var isNotificationSoundEnabled: Bool?
    public var isPhoneNumberVerified: Bool?
    public var isAccountHolder: Bool?
    public var firstName: String?
    public var lastName: String?
    public var apiPasswordLastFour: String?
    public var phoneNumberForDisplay: String?
    public var isSignupComplete: Bool?
    public var industryName: String?
    public var isUserStatePending: Bool?
    public var isDisabled: Bool?

    public enum Brand: String, Codable, CaseIterable {
        case eztexting = "EZTEXTING"
        case clubtexting = "CLUBTEXTING"
        case grouptexting = "GROUPTEXTING"
        case tellmycell = "TELLMYCELL"
        case ez = "EZ"
        case callfire = "CALLFIRE"
        case tesla = "TESLA"
    }

    public enum UserState: String, Codable, CaseIterable {
        case active = "ACTIVE"
        case newAuthInvite = "NEW_AUTH_INVITE"
        case newUserInvite = "NEW_USER_INVITE"
        case existingUserInvite = "EXISTING_USER_INVITE"
    }

    public enum MusicOnHold: String, Codable, CaseIterable {
        case `default` = "DEFAULT"
        case silence = "SILENCE"
        case alternative = "ALTERNATIVE"
        case blues = "BLUES"
        case celtic = "CELTIC"
        case classical = "CLASSICAL"
        case country = "COUNTRY"
        case instrumental = "INSTRUMENTAL"
        case jazz = "JAZZ"
        case neopunk = "NEOPUNK"
        case newAge = "NEW_AGE"
        case pop = "POP"
        case rock = "ROCK"
        case swing = "SWING"
        case techno = "TECHNO"
    }

    public init(soaUser: User? = nil, account: Account? = nil, fullName: String? = nil, permissions: [String]? = nil, id: Int? = nil, isActive: Bool? = nil, isVisible: Bool? = nil, created: Date? = nil, brand: Brand? = nil, accountID: Int? = nil, phoneNumber: String? = nil, profileEmail: String? = nil, userState: UserState? = nil, isCccAgent: Bool? = nil, dateOfBirth: Date? = nil, phoneNumberExtension: String? = nil, phoneNumberExtensionDelaySec: Int? = nil, optInNumber: String? = nil, isOptIn: Bool? = nil, musicOnHold: MusicOnHold? = nil, isNotificationSoundEnabled: Bool? = nil, isPhoneNumberVerified: Bool? = nil, isAccountHolder: Bool? = nil, firstName: String? = nil, lastName: String? = nil, apiPasswordLastFour: String? = nil, phoneNumberForDisplay: String? = nil, isSignupComplete: Bool? = nil, industryName: String? = nil, isUserStatePending: Bool? = nil, isDisabled: Bool? = nil) {
        self.soaUser = soaUser
        self.account = account
        self.fullName = fullName
        self.permissions = permissions
        self.id = id
        self.isActive = isActive
        self.isVisible = isVisible
        self.created = created
        self.brand = brand
        self.accountID = accountID
        self.phoneNumber = phoneNumber
        self.profileEmail = profileEmail
        self.userState = userState
        self.isCccAgent = isCccAgent
        self.dateOfBirth = dateOfBirth
        self.phoneNumberExtension = phoneNumberExtension
        self.phoneNumberExtensionDelaySec = phoneNumberExtensionDelaySec
        self.optInNumber = optInNumber
        self.isOptIn = isOptIn
        self.musicOnHold = musicOnHold
        self.isNotificationSoundEnabled = isNotificationSoundEnabled
        self.isPhoneNumberVerified = isPhoneNumberVerified
        self.isAccountHolder = isAccountHolder
        self.firstName = firstName
        self.lastName = lastName
        self.apiPasswordLastFour = apiPasswordLastFour
        self.phoneNumberForDisplay = phoneNumberForDisplay
        self.isSignupComplete = isSignupComplete
        self.industryName = industryName
        self.isUserStatePending = isUserStatePending
        self.isDisabled = isDisabled
    }

    private enum CodingKeys: String, CodingKey {
        case soaUser
        case account
        case fullName
        case permissions
        case id
        case isActive = "active"
        case isVisible = "visible"
        case created
        case brand
        case accountID = "accountId"
        case phoneNumber
        case profileEmail
        case userState
        case isCccAgent = "cccAgent"
        case dateOfBirth
        case phoneNumberExtension
        case phoneNumberExtensionDelaySec
        case optInNumber
        case isOptIn = "optIn"
        case musicOnHold
        case isNotificationSoundEnabled = "notificationSoundEnabled"
        case isPhoneNumberVerified = "phoneNumberVerified"
        case isAccountHolder = "accountHolder"
        case firstName
        case lastName
        case apiPasswordLastFour
        case phoneNumberForDisplay
        case isSignupComplete = "signupComplete"
        case industryName
        case isUserStatePending = "userStatePending"
        case isDisabled = "disabled"
    }
}

/// Webhook is a user-defined callback, which can be maintained via API. CallFire will send POST request to a client's endpoint defined in webhook once one of assigned events is triggered. See [webhooks guide](https://developers.callfire.com/webhooks-guide.html) for more information about CallFire Webhooks API.
public struct Webhook: Codable {
    /// An id of a webhook
    public var id: Int?
    /// A parameter which allows the webhook to send requests to unknown ssl endpoints (ssl certificate verification is disabled)
    public var isEnabled: Bool?
    /// A parameter which allows the webhook to send requests to unknown ssl endpoints (ssl certificate verification is disabled)
    public var isNonStrictSSL: Bool?
    /// A name of a webhook
    public var name: String?
    /// A resource name that webhook is watching events on. Use GET /webhooks/resources to determine resources and events available (ex: InboundCall, OutboundCall, InboundText, OutboundText, CallBroadcast, TextBroadcast, etc...)
    public var resource: String?
    /// Comma separated list of events on resource that will trigger callbacks (ex: STARTED, STOPPED, FINISHED, etc...).
    public var events: [String]?
    /// A limit callback response to a particular fields
    public var fields: String?
    /// URL that webhook will send POST to on resource event trigger
    public var callback: String?
    /// Webhook secret token which is used as a signing key to HmacSHA1 hash of json payload which is returned in 'X-CallFire-Signature' header. This header can be used to verify callback POST is coming from CallFire. See [security guide](https://developers.callfire.com/security-guide.html)
    public var secret: String?
    /// If true is set then webhook triggers only once. Afterwards the webhook will be deleted
    public var singleUse: Bool?
    /// A time when the given resource was created, formatted in unix time milliseconds (read only). Example: 1473781817000
    public var createdAt: Int?
    /// A time when the given resource was updated, formatted in unix time milliseconds (read only). Example: 1473781817000
    public var updatedAt: Int?
    public var expiresAt: Int?

    public init(id: Int? = nil, isEnabled: Bool? = nil, isNonStrictSSL: Bool? = nil, name: String? = nil, resource: String? = nil, events: [String]? = nil, fields: String? = nil, callback: String? = nil, secret: String? = nil, singleUse: Bool? = nil, createdAt: Int? = nil, updatedAt: Int? = nil, expiresAt: Int? = nil) {
        self.id = id
        self.isEnabled = isEnabled
        self.isNonStrictSSL = isNonStrictSSL
        self.name = name
        self.resource = resource
        self.events = events
        self.fields = fields
        self.callback = callback
        self.secret = secret
        self.singleUse = singleUse
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.expiresAt = expiresAt
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case isEnabled = "enabled"
        case isNonStrictSSL = "nonStrictSsl"
        case name
        case resource
        case events
        case fields
        case callback
        case secret
        case singleUse
        case createdAt
        case updatedAt
        case expiresAt
    }
}

public struct WebhookPage: Codable {
    /// Represents a page with results returned by query operation. Check [pagination](https://developers.callfire.com/docs.html#pagination) page for more information about pagination in CallFire API.
    public var page: Page
    public var items: [Webhook]?

    public init(page: Page, items: [Webhook]? = nil) {
        self.page = page
        self.items = items
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.page = try Page(from: decoder)
        self.items = try values.decodeIfPresent([Webhook].self, forKey: "items")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(page, forKey: "page")
        try values.encodeIfPresent(items, forKey: "items")
    }
}

/// WebhookResource describes a resource and a list of supported events, once event is triggered CallFire performs an HTTP POST request to a client's endpoint
public struct WebhookResource: Codable {
    /// A name of a webhook resource (ex: InboundCall, OutboundCall, InboundText, OutboundText, CallBroadcast, TextBroadcast, etc...)
    public var resource: String?
    /// A list of event names which are supported by webhook resource (ex: Started, Stopped, Finished, etc.)
    public var supportedEvents: [String]?

    public init(resource: String? = nil, supportedEvents: [String]? = nil) {
        self.resource = resource
        self.supportedEvents = supportedEvents
    }
}

/// Weekly schedule allows to schedule operations by day of week and time of the day
public struct WeeklySchedule: Codable {
    /// Represents a time part of a given date
    public var startTimeOfDay: LocalTime?
    /// Represents a time part of a given date
    public var stopTimeOfDay: LocalTime?
    /// A scheduled days when operation will trigger
    public var daysOfWeek: [String]?
    /// A user's timezone
    public var timeZone: String?

    public init(startTimeOfDay: LocalTime? = nil, stopTimeOfDay: LocalTime? = nil, daysOfWeek: [String]? = nil, timeZone: String? = nil) {
        self.startTimeOfDay = startTimeOfDay
        self.stopTimeOfDay = stopTimeOfDay
        self.daysOfWeek = daysOfWeek
        self.timeZone = timeZone
    }
}

public struct ZoneID: Codable {
    public var rules: ZoneRules?
    public var id: String?

    public init(rules: ZoneRules? = nil, id: String? = nil) {
        self.rules = rules
        self.id = id
    }
}

public struct ZoneOffset: Codable {
    public var totalSeconds: Int?
    public var id: String?
    public var rules: ZoneRules?

    public init(totalSeconds: Int? = nil, id: String? = nil, rules: ZoneRules? = nil) {
        self.totalSeconds = totalSeconds
        self.id = id
        self.rules = rules
    }
}

public struct ZoneOffsetTransition: Codable {
    public var offsetBefore: ZoneOffset?
    public var offsetAfter: ZoneOffset?
    public var instant: Int?
    public var isOverlap: Bool?
    public var duration: Duration?
    public var isGap: Bool?
    public var dateTimeBefore: Date?
    public var dateTimeAfter: Date?

    public init(offsetBefore: ZoneOffset? = nil, offsetAfter: ZoneOffset? = nil, instant: Int? = nil, isOverlap: Bool? = nil, duration: Duration? = nil, isGap: Bool? = nil, dateTimeBefore: Date? = nil, dateTimeAfter: Date? = nil) {
        self.offsetBefore = offsetBefore
        self.offsetAfter = offsetAfter
        self.instant = instant
        self.isOverlap = isOverlap
        self.duration = duration
        self.isGap = isGap
        self.dateTimeBefore = dateTimeBefore
        self.dateTimeAfter = dateTimeAfter
    }

    private enum CodingKeys: String, CodingKey {
        case offsetBefore
        case offsetAfter
        case instant
        case isOverlap = "overlap"
        case duration
        case isGap = "gap"
        case dateTimeBefore
        case dateTimeAfter
    }
}

public struct ZoneOffsetTransitionRule: Codable {
    public var month: Month?
    public var timeDefinition: TimeDefinition?
    public var standardOffset: ZoneOffset?
    public var offsetBefore: ZoneOffset?
    public var offsetAfter: ZoneOffset?
    public var dayOfWeek: DayOfWeek?
    public var dayOfMonthIndicator: Int?
    /// Represents a time part of a given date
    public var localTime: LocalTime?
    public var isMidnightEndOfDay: Bool?

    public enum Month: String, Codable, CaseIterable {
        case january = "JANUARY"
        case february = "FEBRUARY"
        case march = "MARCH"
        case april = "APRIL"
        case may = "MAY"
        case june = "JUNE"
        case july = "JULY"
        case august = "AUGUST"
        case september = "SEPTEMBER"
        case october = "OCTOBER"
        case november = "NOVEMBER"
        case december = "DECEMBER"
    }

    public enum TimeDefinition: String, Codable, CaseIterable {
        case utc = "UTC"
        case wall = "WALL"
        case standard = "STANDARD"
    }

    public enum DayOfWeek: String, Codable, CaseIterable {
        case monday = "MONDAY"
        case tuesday = "TUESDAY"
        case wednesday = "WEDNESDAY"
        case thursday = "THURSDAY"
        case friday = "FRIDAY"
        case saturday = "SATURDAY"
        case sunday = "SUNDAY"
    }

    public init(month: Month? = nil, timeDefinition: TimeDefinition? = nil, standardOffset: ZoneOffset? = nil, offsetBefore: ZoneOffset? = nil, offsetAfter: ZoneOffset? = nil, dayOfWeek: DayOfWeek? = nil, dayOfMonthIndicator: Int? = nil, localTime: LocalTime? = nil, isMidnightEndOfDay: Bool? = nil) {
        self.month = month
        self.timeDefinition = timeDefinition
        self.standardOffset = standardOffset
        self.offsetBefore = offsetBefore
        self.offsetAfter = offsetAfter
        self.dayOfWeek = dayOfWeek
        self.dayOfMonthIndicator = dayOfMonthIndicator
        self.localTime = localTime
        self.isMidnightEndOfDay = isMidnightEndOfDay
    }

    private enum CodingKeys: String, CodingKey {
        case month
        case timeDefinition
        case standardOffset
        case offsetBefore
        case offsetAfter
        case dayOfWeek
        case dayOfMonthIndicator
        case localTime
        case isMidnightEndOfDay = "midnightEndOfDay"
    }
}

public struct ZoneRules: Codable {
    public var isFixedOffset: Bool?
    public var transitions: [ZoneOffsetTransition]?
    public var transitionRules: [ZoneOffsetTransitionRule]?

    public init(isFixedOffset: Bool? = nil, transitions: [ZoneOffsetTransition]? = nil, transitionRules: [ZoneOffsetTransitionRule]? = nil) {
        self.isFixedOffset = isFixedOffset
        self.transitions = transitions
        self.transitionRules = transitionRules
    }

    private enum CodingKeys: String, CodingKey {
        case isFixedOffset = "fixedOffset"
        case transitions
        case transitionRules
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
