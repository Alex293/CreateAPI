// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var calls: Calls {
        Calls(path: "/calls")
    }

    public struct Calls {
        /// Path: `/calls`
        public let path: String

        /// Find calls
        ///
        /// To search for all calls sent or received by the user. Use "id=0" for the campaignId parameter to query for all calls sent through the POST /calls API. See [call states and results](https://developers.callfire.com/results-responses-errors.html)
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.CallPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: String?
            public var limit: Int?
            public var offset: Int?
            public var id: [Int]?
            public var campaignID: Int?
            public var batchID: Int?
            public var fromNumber: String?
            public var toNumber: String?
            public var label: String?
            public var states: String?
            public var results: String?
            public var isInbound: Bool?
            public var intervalBegin: Int?
            public var intervalEnd: Int?

            public init(fields: String? = nil, limit: Int? = nil, offset: Int? = nil, id: [Int]? = nil, campaignID: Int? = nil, batchID: Int? = nil, fromNumber: String? = nil, toNumber: String? = nil, label: String? = nil, states: String? = nil, results: String? = nil, isInbound: Bool? = nil, intervalBegin: Int? = nil, intervalEnd: Int? = nil) {
                self.fields = fields
                self.limit = limit
                self.offset = offset
                self.id = id
                self.campaignID = campaignID
                self.batchID = batchID
                self.fromNumber = fromNumber
                self.toNumber = toNumber
                self.label = label
                self.states = states
                self.results = results
                self.isInbound = isInbound
                self.intervalBegin = intervalBegin
                self.intervalEnd = intervalEnd
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(id, forKey: "id")
                encoder.encode(campaignID, forKey: "campaignId")
                encoder.encode(batchID, forKey: "batchId")
                encoder.encode(fromNumber, forKey: "fromNumber")
                encoder.encode(toNumber, forKey: "toNumber")
                encoder.encode(label, forKey: "label")
                encoder.encode(states, forKey: "states")
                encoder.encode(results, forKey: "results")
                encoder.encode(isInbound, forKey: "inbound")
                encoder.encode(intervalBegin, forKey: "intervalBegin")
                encoder.encode(intervalEnd, forKey: "intervalEnd")
                return encoder.items
            }
        }

        /// Send calls
        ///
        /// Use the /calls API to send individual calls quickly. A verified Caller ID and sufficient credits are required to make a call. CallRecipient represents a single recipient identified by phone number or contact id in CallFire system. You can attach user-defined attributes to a Call action via CallRecipient.attributes property, attributes are available in Call action response
        public func post(parameters: PostParameters? = nil, _ body: [CallfireAPI.CallRecipient]? = nil) -> Request<CallfireAPI.CallList> {
            .post(path, query: parameters?.asQuery, body: body)
        }

        public struct PostParameters {
            public var fields: String?
            public var campaignID: Int?
            public var defaultLiveMessage: String?
            public var defaultMachineMessage: String?
            public var defaultLiveMessageSoundID: Int?
            public var defaultMachineMessageSoundID: Int?
            public var defaultVoice: DefaultVoice?
            public var isStrictValidation: Bool?

            public enum DefaultVoice: String, Codable, CaseIterable {
                case male1 = "MALE1"
                case female1 = "FEMALE1"
                case female2 = "FEMALE2"
                case spanish1 = "SPANISH1"
                case frenchcanadian1 = "FRENCHCANADIAN1"
            }

            public init(fields: String? = nil, campaignID: Int? = nil, defaultLiveMessage: String? = nil, defaultMachineMessage: String? = nil, defaultLiveMessageSoundID: Int? = nil, defaultMachineMessageSoundID: Int? = nil, defaultVoice: DefaultVoice? = nil, isStrictValidation: Bool? = nil) {
                self.fields = fields
                self.campaignID = campaignID
                self.defaultLiveMessage = defaultLiveMessage
                self.defaultMachineMessage = defaultMachineMessage
                self.defaultLiveMessageSoundID = defaultLiveMessageSoundID
                self.defaultMachineMessageSoundID = defaultMachineMessageSoundID
                self.defaultVoice = defaultVoice
                self.isStrictValidation = isStrictValidation
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields")
                encoder.encode(campaignID, forKey: "campaignId")
                encoder.encode(defaultLiveMessage, forKey: "defaultLiveMessage")
                encoder.encode(defaultMachineMessage, forKey: "defaultMachineMessage")
                encoder.encode(defaultLiveMessageSoundID, forKey: "defaultLiveMessageSoundId")
                encoder.encode(defaultMachineMessageSoundID, forKey: "defaultMachineMessageSoundId")
                encoder.encode(defaultVoice, forKey: "defaultVoice")
                encoder.encode(isStrictValidation, forKey: "strictValidation")
                return encoder.items
            }
        }
    }
}

extension Paths.Calls {
    public var broadcasts: Broadcasts {
        Broadcasts(path: path + "/broadcasts")
    }

    public struct Broadcasts {
        /// Path: `/calls/broadcasts`
        public let path: String

        /// Find call broadcasts
        ///
        /// Searches for all voice broadcasts created by user. Can query on label, name, and the current running status of the campaign. Returns a paged list of voice broadcasts
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.CallBroadcastPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: String?
            public var limit: Int?
            public var offset: Int?
            public var label: String?
            public var name: String?
            public var isRunning: Bool?
            public var isScheduled: Bool?
            public var intervalBegin: Int?
            public var intervalEnd: Int?

            public init(fields: String? = nil, limit: Int? = nil, offset: Int? = nil, label: String? = nil, name: String? = nil, isRunning: Bool? = nil, isScheduled: Bool? = nil, intervalBegin: Int? = nil, intervalEnd: Int? = nil) {
                self.fields = fields
                self.limit = limit
                self.offset = offset
                self.label = label
                self.name = name
                self.isRunning = isRunning
                self.isScheduled = isScheduled
                self.intervalBegin = intervalBegin
                self.intervalEnd = intervalEnd
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(label, forKey: "label")
                encoder.encode(name, forKey: "name")
                encoder.encode(isRunning, forKey: "running")
                encoder.encode(isScheduled, forKey: "scheduled")
                encoder.encode(intervalBegin, forKey: "intervalBegin")
                encoder.encode(intervalEnd, forKey: "intervalEnd")
                return encoder.items
            }
        }

        /// Create a call broadcast
        ///
        /// Creates a call broadcast campaign using the Call Broadcast API. Send a CallBroadcast in the message body to add details in a voice broadcast campaign. The campaign can be created without contacts and bare minimum configuration, but contacts will have to be added further on to use the campaign
        public func post(isStart: Bool? = nil, isStrictValidation: Bool? = nil, _ body: CallfireAPI.CallBroadcast? = nil) -> Request<CallfireAPI.ResourceID> {
            .post(path, query: makePostQuery(isStart, isStrictValidation), body: body)
        }

        private func makePostQuery(_ isStart: Bool?, _ isStrictValidation: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStart, forKey: "start")
            encoder.encode(isStrictValidation, forKey: "strictValidation")
            return encoder.items
        }
    }
}

extension Paths.Calls.Broadcasts {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/calls/broadcasts/{id}`
        public let path: String

        /// Find a specific call broadcast
        ///
        /// Returns a single CallBroadcast instance for a given call broadcast campaign id
        public func get(fields: String? = nil) -> Request<CallfireAPI.CallBroadcast> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }

        /// Update a call broadcast
        ///
        /// This operation lets the user modify the configuration of a voice broadcast campaign after call broadcast campaign is created. See CallBroadcast for more information on what can/can't be updated on this API
        public func put(isStrictValidation: Bool? = nil, _ body: CallfireAPI.CallBroadcast? = nil) -> Request<Void> {
            .put(path, query: makePutQuery(isStrictValidation), body: body)
        }

        private func makePutQuery(_ isStrictValidation: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStrictValidation, forKey: "strictValidation")
            return encoder.items
        }
    }
}

extension Paths.Calls.Broadcasts.WithID {
    public var archive: Archive {
        Archive(path: path + "/archive")
    }

    public struct Archive {
        /// Path: `/calls/broadcasts/{id}/archive`
        public let path: String

        /// Archive voice broadcast
        ///
        /// Archives a voice broadcast (voice broadcast will be hidden in search results)
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Calls.Broadcasts.WithID {
    public var batches: Batches {
        Batches(path: path + "/batches")
    }

    public struct Batches {
        /// Path: `/calls/broadcasts/{id}/batches`
        public let path: String

        /// Find batches in a call broadcast
        ///
        /// This endpoint will enable the user to page through all of the batches for a particular voice broadcast campaign
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.BatchPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: String?
            public var limit: Int?
            public var offset: Int?

            public init(fields: String? = nil, limit: Int? = nil, offset: Int? = nil) {
                self.fields = fields
                self.limit = limit
                self.offset = offset
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                return encoder.items
            }
        }

        /// Add batches to a call broadcast
        ///
        /// The 'add batch' API allows user to add additional batches to an already created voice broadcast campaign. The added batch will go through the CallFire validation process, unlike in the recipients version of this API. That is why you can use the scrubDuplicates flag to remove duplicates from your batch. Batches may be added as a contact list id, a list of contact ids, or a list of numbers
        public func post(isStrictValidation: Bool? = nil, _ body: CallfireAPI.BatchRequest? = nil) -> Request<CallfireAPI.ResourceID> {
            .post(path, query: makePostQuery(isStrictValidation), body: body)
        }

        private func makePostQuery(_ isStrictValidation: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStrictValidation, forKey: "strictValidation")
            return encoder.items
        }
    }
}

extension Paths.Calls.Broadcasts.WithID {
    public var calls: Calls {
        Calls(path: path + "/calls")
    }

    public struct Calls {
        /// Path: `/calls/broadcasts/{id}/calls`
        public let path: String

        /// Find calls in a call broadcast
        ///
        /// This endpoint will enable the user to page through all calls for a particular call broadcast campaign
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.CallPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var batchID: Int?
            public var fields: String?
            public var limit: Int?
            public var offset: Int?

            public init(batchID: Int? = nil, fields: String? = nil, limit: Int? = nil, offset: Int? = nil) {
                self.batchID = batchID
                self.fields = fields
                self.limit = limit
                self.offset = offset
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(batchID, forKey: "batchId")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                return encoder.items
            }
        }
    }
}

extension Paths.Calls.Broadcasts.WithID {
    public var recipients: Recipients {
        Recipients(path: path + "/recipients")
    }

    public struct Recipients {
        /// Path: `/calls/broadcasts/{id}/recipients`
        public let path: String

        /// Add recipients to a call broadcast
        ///
        /// Use this API to add the recipients to an existing voice broadcast. Post a list of Recipient objects to be added to the voice broadcast campaign. These contacts will not go through validation process, and will be acted upon as they are added. Recipients may be added as a list of contact ids, or list of numbers
        public func post(fields: String? = nil, isStrictValidation: Bool? = nil, _ body: [CallfireAPI.Recipient]? = nil) -> Request<CallfireAPI.CallList> {
            .post(path, query: makePostQuery(fields, isStrictValidation), body: body)
        }

        private func makePostQuery(_ fields: String?, _ isStrictValidation: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            encoder.encode(isStrictValidation, forKey: "strictValidation")
            return encoder.items
        }
    }
}

extension Paths.Calls.Broadcasts.WithID {
    public var start: Start {
        Start(path: path + "/start")
    }

    public struct Start {
        /// Path: `/calls/broadcasts/{id}/start`
        public let path: String

        /// Start voice broadcast
        ///
        /// Start a voice broadcast
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Calls.Broadcasts.WithID {
    public var stats: Stats {
        Stats(path: path + "/stats")
    }

    public struct Stats {
        /// Path: `/calls/broadcasts/{id}/stats`
        public let path: String

        /// Get statistics on call broadcast
        ///
        /// Returns broadcast statistics like total number of sent/received actions, total cost, number of remaining outbound actions, error count, etc
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.CallBroadcastStats> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: String?
            public var begin: Int?
            public var end: Int?

            public init(fields: String? = nil, begin: Int? = nil, end: Int? = nil) {
                self.fields = fields
                self.begin = begin
                self.end = end
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields")
                encoder.encode(begin, forKey: "begin")
                encoder.encode(end, forKey: "end")
                return encoder.items
            }
        }
    }
}

extension Paths.Calls.Broadcasts.WithID {
    public var stop: Stop {
        Stop(path: path + "/stop")
    }

    public struct Stop {
        /// Path: `/calls/broadcasts/{id}/stop`
        public let path: String

        /// Stop voice broadcast
        ///
        /// Stop a voice broadcast
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Calls.Broadcasts.WithID {
    public var toggleRecipientsStatus: ToggleRecipientsStatus {
        ToggleRecipientsStatus(path: path + "/toggleRecipientsStatus")
    }

    public struct ToggleRecipientsStatus {
        /// Path: `/calls/broadcasts/{id}/toggleRecipientsStatus`
        public let path: String

        /// Disable/enable undialed recipients in broadcast
        ///
        /// This operation lets the user to disable/enable undialed recipients in created broadcast
        public func post(enable: Bool? = nil, _ body: [CallfireAPI.Recipient]? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(enable), body: body)
        }

        private func makePostQuery(_ enable: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(enable, forKey: "enable")
            return encoder.items
        }
    }
}

extension Paths.Calls {
    public var recordings: Recordings {
        Recordings(path: path + "/recordings")
    }

    public struct Recordings {
        /// Path: `/calls/recordings`
        public let path: String
    }
}

extension Paths.Calls.Recordings {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/calls/recordings/{id}`
        public let path: String

        /// Get call recording by id
        ///
        /// Returns metadata of recording of a particular call. Metadata contains a link to a MP3 recording
        public func get(fields: String? = nil) -> Request<CallfireAPI.CallRecording> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths.Calls.Recordings {
    public func id(_ id: Int) -> WithMp3 {
        WithMp3(path: "\(path)/\(id).mp3")
    }

    public struct WithMp3 {
        /// Path: `/calls/recordings/{id}.mp3`
        public let path: String

        /// Get call recording in mp3 format
        ///
        /// Returns an MP3 recording of particular call, response contains binary data, content type is 'audio/mpeg'
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Calls {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/calls/{id}`
        public let path: String

        /// Find a specific call
        ///
        /// Returns a single Call instance for a given call id.
        public func get(fields: String? = nil) -> Request<CallfireAPI.Call> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths.Calls.WithID {
    public var recordings: Recordings {
        Recordings(path: path + "/recordings")
    }

    public struct Recordings {
        /// Path: `/calls/{id}/recordings`
        public let path: String

        /// Get call recordings for a call
        ///
        /// Returns a list of recordings metadata of particular call. Metadata contains link to a MP3 recording
        public func get(fields: String? = nil) -> Request<CallfireAPI.CallRecordingList> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths.Calls.WithID.Recordings {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/calls/{id}/recordings/{name}`
        public let path: String

        /// Get call recording by name
        ///
        /// Returns recording metadata of particular call. Metadata contains link to a MP3 recording
        public func get(fields: String? = nil) -> Request<CallfireAPI.CallRecording> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths.Calls.WithID.Recordings {
    public func name(_ name: String) -> WithMp3 {
        WithMp3(path: "\(path)/\(name).mp3")
    }

    public struct WithMp3 {
        /// Path: `/calls/{id}/recordings/{name}.mp3`
        public let path: String

        /// Get call mp3 recording by name
        ///
        /// Returns a MP3 recording of a particular call, response contains binary data, content type is 'audio/mpeg'
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths {
    public static var campaigns: Campaigns {
        Campaigns(path: "/campaigns")
    }

    public struct Campaigns {
        /// Path: `/campaigns`
        public let path: String
    }
}

extension Paths.Campaigns {
    public var batches: Batches {
        Batches(path: path + "/batches")
    }

    public struct Batches {
        /// Path: `/campaigns/batches`
        public let path: String
    }
}

extension Paths.Campaigns.Batches {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/campaigns/batches/{id}`
        public let path: String

        /// Find a specific batch
        ///
        /// Returns a single Batch instance for a given batch id. This API is useful for determining the state of a validating batch
        public func get(fields: String? = nil) -> Request<CallfireAPI.Batch> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }

        /// Update a batch
        ///
        /// Updates a single Batch instance, currently batch can only be turned "on/off"
        public func put(_ body: CallfireAPI.Batch? = nil) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.Campaigns {
    public var sounds: Sounds {
        Sounds(path: path + "/sounds")
    }

    public struct Sounds {
        /// Path: `/campaigns/sounds`
        public let path: String

        /// Find sounds
        ///
        /// To find all campaign sounds which were created by user. Returns all sounds available to be used in campaigns
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.CampaignSoundPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var limit: Int?
            public var offset: Int?
            public var filter: String?
            public var isIncludeArchived: Bool?
            public var isIncludePending: Bool?
            public var isIncludeScrubbed: Bool?
            public var fields: String?

            public init(limit: Int? = nil, offset: Int? = nil, filter: String? = nil, isIncludeArchived: Bool? = nil, isIncludePending: Bool? = nil, isIncludeScrubbed: Bool? = nil, fields: String? = nil) {
                self.limit = limit
                self.offset = offset
                self.filter = filter
                self.isIncludeArchived = isIncludeArchived
                self.isIncludePending = isIncludePending
                self.isIncludeScrubbed = isIncludeScrubbed
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(filter, forKey: "filter")
                encoder.encode(isIncludeArchived, forKey: "includeArchived")
                encoder.encode(isIncludePending, forKey: "includePending")
                encoder.encode(isIncludeScrubbed, forKey: "includeScrubbed")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Campaigns.Sounds {
    public var calls: Calls {
        Calls(path: path + "/calls")
    }

    public struct Calls {
        /// Path: `/campaigns/sounds/calls`
        public let path: String

        /// Add sound via call
        ///
        /// Use this API to create a sound via a phone call. Provide the required phone number in the CallCreateSound object inside the request, and user will receive a call shortly after with instructions on how to record a sound over the phone.
        public func post(fields: String? = nil, _ body: CallfireAPI.CallCreateSound? = nil) -> Request<CallfireAPI.CampaignSound> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths.Campaigns.Sounds {
    public var files: Files {
        Files(path: path + "/files")
    }

    public struct Files {
        /// Path: `/campaigns/sounds/files`
        public let path: String

        /// Add sound via file
        ///
        /// Create a campaign sound file via a supplied .mp3 or .wav file
        public func post(fields: String? = nil, _ body: Data) -> Request<CallfireAPI.CampaignSound> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths.Campaigns.Sounds {
    public var tts: Tts {
        Tts(path: path + "/tts")
    }

    public struct Tts {
        /// Path: `/campaigns/sounds/tts`
        public let path: String

        /// Add sound via text-to-speech
        ///
        /// Use this API to create a sound file via a supplied string of text. Add a text in the TextToSpeech.message field, and pick a voice in the TextToSpeech.voice field. Available voices are: MALE1, FEMALE1, FEMALE2, SPANISH1, FRENCHCANADIAN1
        public func post(fields: String? = nil, _ body: CallfireAPI.TextToSpeech? = nil) -> Request<CallfireAPI.CampaignSound> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths.Campaigns.Sounds {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/campaigns/sounds/{id}`
        public let path: String

        /// Find a specific sound
        ///
        /// Returns a single CampaignSound instance for a given sound id in campaign. This is a meta data to the sounds. No audio data is returned from this API
        public func get(fields: String? = nil) -> Request<CallfireAPI.CampaignSound> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }

        /// Delete a specific sound
        ///
        /// Deletes a single campaign sound instance for a specific campaign sound id, this operation does not delete sound completely, it sets sound status to ARCHIVED which means that sound will no longer appear in 'find' operation results, but still accessible via 'get' operation
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Campaigns.Sounds {
    public func id(_ id: Int) -> WithMp3 {
        WithMp3(path: "\(path)/\(id).mp3")
    }

    public struct WithMp3 {
        /// Path: `/campaigns/sounds/{id}.mp3`
        public let path: String

        /// Download a MP3 sound
        ///
        /// Download the MP3 version of a hosted file. This is an audio data endpoint. Returns binary response of the 'audio/mpeg' content type
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Campaigns.Sounds {
    public func id(_ id: Int) -> WithWav {
        WithWav(path: "\(path)/\(id).wav")
    }

    public struct WithWav {
        /// Path: `/campaigns/sounds/{id}.wav`
        public let path: String

        /// Download a WAV sound
        ///
        /// Download the WAV version of the hosted file. This is an audio data endpoint. Returns binary response of the 'audio/mpeg' content type
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths {
    public static var contacts: Contacts {
        Contacts(path: "/contacts")
    }

    public struct Contacts {
        /// Path: `/contacts`
        public let path: String

        /// Find contacts
        ///
        /// Find user's contacts by id, contact list, or on any property name. Returns a paged list of contacts
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.ContactPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: String?
            public var limit: Int?
            public var offset: Int?
            public var id: [Int]?
            public var number: [String]?
            public var contactListID: Int?
            public var propertyName: String?
            public var propertyValue: String?

            public init(fields: String? = nil, limit: Int? = nil, offset: Int? = nil, id: [Int]? = nil, number: [String]? = nil, contactListID: Int? = nil, propertyName: String? = nil, propertyValue: String? = nil) {
                self.fields = fields
                self.limit = limit
                self.offset = offset
                self.id = id
                self.number = number
                self.contactListID = contactListID
                self.propertyName = propertyName
                self.propertyValue = propertyValue
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(id, forKey: "id")
                encoder.encode(number, forKey: "number")
                encoder.encode(contactListID, forKey: "contactListId")
                encoder.encode(propertyName, forKey: "propertyName")
                encoder.encode(propertyValue, forKey: "propertyValue")
                return encoder.items
            }
        }

        /// Create contacts
        ///
        /// Creates contacts in CallFire system. Only values from the next list can be used as external system parameter in contact creation: **NATION_BUILDER, SALES_FORCE_CONTACTS, SALES_FORCE_LEADS, SALES_FORCE_REPORTS, ZOHO, NETSUITE, MAIL_CHIMP**. See [contacts validation rules](https://www.callfire.com/help/docs/getting-started/managing-contacts/validating-contacts#section1)
        public func post(_ body: [CallfireAPI.Contact]? = nil) -> Request<CallfireAPI.ResourceIDList> {
            .post(path, body: body)
        }
    }
}

extension Paths.Contacts {
    public var dncs: Dncs {
        Dncs(path: path + "/dncs")
    }

    public struct Dncs {
        /// Path: `/contacts/dncs`
        public let path: String

        /// Find do not contact (dnc) items
        ///
        /// Searches for all Do Not Contact (DNC) objects created by user. These DoNotContact entries only affect calls/texts/campaigns on this account. Returns a paged list of DoNotContact objects
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.DoNotContactPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: String?
            public var limit: Int?
            public var offset: Int?
            public var prefix: String?
            public var campaignID: Int?
            public var source: String?
            public var isCall: Bool?
            public var isText: Bool?
            public var isInboundCall: Bool?
            public var isInboundText: Bool?
            public var number: [String]?

            public init(fields: String? = nil, limit: Int? = nil, offset: Int? = nil, prefix: String? = nil, campaignID: Int? = nil, source: String? = nil, isCall: Bool? = nil, isText: Bool? = nil, isInboundCall: Bool? = nil, isInboundText: Bool? = nil, number: [String]? = nil) {
                self.fields = fields
                self.limit = limit
                self.offset = offset
                self.prefix = prefix
                self.campaignID = campaignID
                self.source = source
                self.isCall = isCall
                self.isText = isText
                self.isInboundCall = isInboundCall
                self.isInboundText = isInboundText
                self.number = number
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(prefix, forKey: "prefix")
                encoder.encode(campaignID, forKey: "campaignId")
                encoder.encode(source, forKey: "source")
                encoder.encode(isCall, forKey: "call")
                encoder.encode(isText, forKey: "text")
                encoder.encode(isInboundCall, forKey: "inboundCall")
                encoder.encode(isInboundText, forKey: "inboundText")
                encoder.encode(number, forKey: "number")
                return encoder.items
            }
        }

        /// Add do not contact (dnc) numbers
        ///
        /// Add or update a list of Do Not Contact (DNC) contact entries. Can toggle whether the DNCs are enabled for calls/texts.
        public func post(_ body: CallfireAPI.AddDoNotContactRequest? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Contacts.Dncs {
    public var sources: Sources {
        Sources(path: path + "/sources")
    }

    public struct Sources {
        /// Path: `/contacts/dncs/sources`
        public let path: String
    }
}

extension Paths.Contacts.Dncs.Sources {
    public func source(_ source: String) -> WithSource {
        WithSource(path: "\(path)/\(source)")
    }

    public struct WithSource {
        /// Path: `/contacts/dncs/sources/{source}`
        public let path: String

        /// Delete do not contact (dnc) numbers contained in source.
        ///
        /// Delete Do Not Contact (DNC) contact entries contained in source.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Contacts.Dncs {
    public var universals: Universals {
        Universals(path: path + "/universals")
    }

    public struct Universals {
        /// Path: `/contacts/dncs/universals`
        public let path: String
    }
}

extension Paths.Contacts.Dncs.Universals {
    public func toNumber(_ toNumber: String) -> WithToNumber {
        WithToNumber(path: "\(path)/\(toNumber)")
    }

    public struct WithToNumber {
        /// Path: `/contacts/dncs/universals/{toNumber}`
        public let path: String

        /// Find universal do not contacts (udnc) associated with toNumber
        ///
        /// Searches for a UniversalDoNotContact object for a given phone number. Shows whether inbound/outbound actions are allowed for a given number
        public func get(fromNumber: String? = nil, fields: String? = nil) -> Request<CallfireAPI.ItemListUniversalDoNotContact> {
            .get(path, query: makeGetQuery(fromNumber, fields))
        }

        private func makeGetQuery(_ fromNumber: String?, _ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fromNumber, forKey: "fromNumber")
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths.Contacts.Dncs {
    public func number(_ number: String) -> WithNumber {
        WithNumber(path: "\(path)/\(number)")
    }

    public struct WithNumber {
        /// Path: `/contacts/dncs/{number}`
        public let path: String

        /// Get do not contact (dnc)
        ///
        /// Get Do Not Contact (DNC) object create by user. This DoNotContact entry only affects calls/texts/campaigns on this account.
        public var get: Request<CallfireAPI.DoNotContact> {
            .get(path)
        }

        /// Update an individual do not contact (dnc) number
        ///
        /// Update a Do Not Contact (DNC) contact entry. Can toggle whether the DNC is enabled for calls/texts.
        public func put(_ body: CallfireAPI.DoNotContact? = nil) -> Request<Void> {
            .put(path, body: body)
        }

        /// Delete do not contact (dnc) number. If number contains commas treat as list of numbers
        ///
        /// Delete a Do Not Contact (DNC) contact entry.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Contacts {
    public var lists: Lists {
        Lists(path: path + "/lists")
    }

    public struct Lists {
        /// Path: `/contacts/lists`
        public let path: String

        /// Find contact lists
        ///
        /// Searches for all contact lists which are available for the current user. Returns a paged list of contact lists
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.ContactListPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: String?
            public var limit: Int?
            public var offset: Int?
            public var name: String?
            public var isExactMatch: Bool?
            public var contactCount: Int?
            public var orderBy: String?

            public init(fields: String? = nil, limit: Int? = nil, offset: Int? = nil, name: String? = nil, isExactMatch: Bool? = nil, contactCount: Int? = nil, orderBy: String? = nil) {
                self.fields = fields
                self.limit = limit
                self.offset = offset
                self.name = name
                self.isExactMatch = isExactMatch
                self.contactCount = contactCount
                self.orderBy = orderBy
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(name, forKey: "name")
                encoder.encode(isExactMatch, forKey: "exactMatch")
                encoder.encode(contactCount, forKey: "contactCount")
                encoder.encode(orderBy, forKey: "orderBy")
                return encoder.items
            }
        }

        /// Create contact lists
        ///
        /// Creates a contact list for use with campaigns using 1 of 3 inputs. A List of Contact objects, a list of String E.164 numbers, or a list of CallFire contactIds can be used as the data source for the created contact list. After contact list is added into the CallFire system, contact lists goes through seven system safeguards that check the accuracy and consistency of the data. For example, our system checks that contact number is formatted correctly, is valid, is not duplicated in another contact list, or is not added on a specific DNC list. You can configure to keep/merge or remove contacts which do not complies these rules. If contacts were not added to a contact list after the validation, this means the data needs to be properly formatted and corrected before calling this API
        public func post(fields: String? = nil, _ body: CallfireAPI.CreateContactListRequest? = nil) -> Request<CallfireAPI.ContactList> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths.Contacts.Lists {
    public var upload: Upload {
        Upload(path: path + "/upload")
    }

    public struct Upload {
        /// Path: `/contacts/lists/upload`
        public let path: String

        /// Create contact list from file
        ///
        /// Creates a contact list to be used with campaigns through uploading a .csv file. Returns the id of created list
        public func post(_ body: Data) -> Request<CallfireAPI.ResourceID> {
            .post(path, body: body)
        }
    }
}

extension Paths.Contacts.Lists {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/contacts/lists/{id}`
        public let path: String

        /// Find a specific contact list
        ///
        /// Returns a single ContactList instance for a given contact list id
        public func get(fields: String? = nil) -> Request<CallfireAPI.ContactList> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }

        /// Update a contact list
        ///
        /// Updates contact list instance.
        public func put(_ body: CallfireAPI.UpdateContactListRequest? = nil) -> Request<Void> {
            .put(path, body: body)
        }

        /// Delete a contact list
        ///
        /// Deletes a contact list, included contacts will not be deleted.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Contacts.Lists.WithID {
    public var items: Items {
        Items(path: path + "/items")
    }

    public struct Items {
        /// Path: `/contacts/lists/{id}/items`
        public let path: String

        /// Find contacts in a contact list
        ///
        /// Searches for all entries in a contact list with specified id. Returns a paged list of contact entries
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.ContactPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: String?
            public var limit: Int?
            public var offset: Int?

            public init(fields: String? = nil, limit: Int? = nil, offset: Int? = nil) {
                self.fields = fields
                self.limit = limit
                self.offset = offset
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                return encoder.items
            }
        }

        /// Add contacts to a contact list
        ///
        /// Adds contacts to a contact list. Available contact sources are: list of the contact entities, list of ids of existing contacts in user's account, list of phone numbers in E.164 format (11-digits)
        public func post(_ body: CallfireAPI.AddContactListContactsRequest? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        /// Delete contacts from a contact list
        ///
        /// Deletes contacts from a contact list. List the contact ids in request to delete multiple contacts with one request.
        public func delete(contactID: [Int]? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(contactID))
        }

        private func makeDeleteQuery(_ contactID: [Int]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(contactID, forKey: "contactId")
            return encoder.items
        }
    }
}

extension Paths.Contacts.Lists.WithID.Items {
    public func contactID(_ contactID: Int) -> WithContactID {
        WithContactID(path: "\(path)/\(contactID)")
    }

    public struct WithContactID {
        /// Path: `/contacts/lists/{id}/items/{contactId}`
        public let path: String

        /// Delete a contact from a contact list
        ///
        /// Deletes a single contact from a contact list
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Contacts {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/contacts/{id}`
        public let path: String

        /// Find a specific contact
        ///
        /// Returns a Contact instance for a given contact id. Deleted contacts can be still retrieved but will be marked as deleted. Deleted contacts will not be shown in search request.
        public func get(fields: String? = nil) -> Request<CallfireAPI.Contact> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }

        /// Update a contact
        ///
        /// Updates a single contact instance with id specified. See [contact validation rules](https://www.callfire.com/help/docs/getting-started/managing-contacts/validating-contacts#section1)
        public func put(_ body: CallfireAPI.Contact? = nil) -> Request<Void> {
            .put(path, body: body)
        }

        /// Delete a contact
        ///
        /// Deletes a contact instance from account
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Contacts.WithID {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/contacts/{id}/history`
        public let path: String

        /// Find a contact's history
        ///
        /// Searches for all texts and calls attributed to a contact. Returns a list of calls and texts a contact has been involved with
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.ContactHistory> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var limit: Int?
            public var offset: Int?
            public var fields: String?

            public init(limit: Int? = nil, offset: Int? = nil, fields: String? = nil) {
                self.limit = limit
                self.offset = offset
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var keywords: Keywords {
        Keywords(path: "/keywords")
    }

    public struct Keywords {
        /// Path: `/keywords`
        public let path: String

        /// Find keywords
        ///
        /// Searches for all keywords available for purchase on the CallFire platform. If a keyword appears in the response, it is available for purchase. List the 'keywords' in a query parameter to search for multiple keywords (at least one keyword should be sent in request). Keyword should only consist of uppercase and lowercase letters and numbers. Number of characters must be greater than 2, but less than 65.
        public func get(keywords: [String]? = nil) -> Request<CallfireAPI.KeywordList> {
            .get(path, query: makeGetQuery(keywords))
        }

        private func makeGetQuery(_ keywords: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(keywords, forKey: "keywords")
            return encoder.items
        }
    }
}

extension Paths.Keywords {
    public var leases: Leases {
        Leases(path: path + "/leases")
    }

    public struct Leases {
        /// Path: `/keywords/leases`
        public let path: String

        /// Find keyword leases
        ///
        /// Searches for all keywords owned by user. A keyword lease is the ownership information involving a keyword
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.KeywordLeasePage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var limit: Int?
            public var offset: Int?
            public var filter: String?
            public var labelName: String?
            public var fields: String?

            public init(limit: Int? = nil, offset: Int? = nil, filter: String? = nil, labelName: String? = nil, fields: String? = nil) {
                self.limit = limit
                self.offset = offset
                self.filter = filter
                self.labelName = labelName
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(filter, forKey: "filter")
                encoder.encode(labelName, forKey: "labelName")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Keywords.Leases {
    public var configs: Configs {
        Configs(path: path + "/configs")
    }

    public struct Configs {
        /// Path: `/keywords/leases/configs`
        public let path: String

        /// Find keyword lease configs
        ///
        /// Searches for all keyword lease configs for the user. Returns a paged list of KeywordConfig
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.Page> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var limit: Int?
            public var offset: Int?
            public var filter: String?
            public var labelName: String?
            public var fields: String?

            public init(limit: Int? = nil, offset: Int? = nil, filter: String? = nil, labelName: String? = nil, fields: String? = nil) {
                self.limit = limit
                self.offset = offset
                self.filter = filter
                self.labelName = labelName
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(filter, forKey: "filter")
                encoder.encode(labelName, forKey: "labelName")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Keywords.Leases.Configs {
    public func keyword(_ keyword: String) -> WithKeyword {
        WithKeyword(path: "\(path)/\(keyword)")
    }

    public struct WithKeyword {
        /// Path: `/keywords/leases/configs/{keyword}`
        public let path: String

        /// Find a specific keyword lease config
        ///
        /// Returns a single KeywordConfig instance for a given keyword lease
        public func get(fields: String? = nil) -> Request<CallfireAPI.KeywordConfig> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }

        /// Update a keyword lease config
        ///
        /// Updates a keyword lease configuration. Use this API endpoint to enable/disable inbound SMS forwarding, set forward number. Forward number must be in E.164 format)
        public func put(_ body: CallfireAPI.KeywordConfig? = nil) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.Keywords.Leases {
    public var id: ID {
        ID(path: path + "/id")
    }

    public struct ID {
        /// Path: `/keywords/leases/id`
        public let path: String
    }
}

extension Paths.Keywords.Leases.ID {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/keywords/leases/id/{id}`
        public let path: String

        /// Find a keyword by id
        ///
        /// Get keyword by id
        public func get(fields: String? = nil) -> Request<CallfireAPI.KeywordLease> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths.Keywords.Leases {
    public func keyword(_ keyword: String) -> WithKeyword {
        WithKeyword(path: "\(path)/\(keyword)")
    }

    public struct WithKeyword {
        /// Path: `/keywords/leases/{keyword}`
        public let path: String

        /// Find a specific lease
        ///
        /// Searches for all keywords owned by user
        public func get(fields: String? = nil) -> Request<CallfireAPI.KeywordLease> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }

        /// Update a lease
        ///
        /// Updates a keyword lease. Turns the autoRenew on/off. Configure double opt in feature. Add/remove contact list from keyword.
        public func put(_ body: CallfireAPI.KeywordLease? = nil) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.Keywords {
    public func keyword(_ keyword: String) -> WithKeyword {
        WithKeyword(path: "\(path)/\(keyword)")
    }

    public struct WithKeyword {
        /// Path: `/keywords/{keyword}`
        public let path: String
    }
}

extension Paths.Keywords.WithKeyword {
    public var available: Available {
        Available(path: path + "/available")
    }

    public struct Available {
        /// Path: `/keywords/{keyword}/available`
        public let path: String

        /// Check for a specific keyword
        ///
        /// Searches for the specific keyword to purchase on the CallFire platform. Returns 'true' if keyword is available. Keyword should only consist of uppercase and lowercase letters and numbers. Number of characters must be greater than 2, but less than 65.
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths {
    public static var me: Me {
        Me(path: "/me")
    }

    public struct Me {
        /// Path: `/me`
        public let path: String
    }
}

extension Paths.Me {
    public var account: Account {
        Account(path: path + "/account")
    }

    public struct Account {
        /// Path: `/me/account`
        public let path: String

        /// Find account details
        ///
        /// Searches for the user account details. Details include name, email, and basic account permissions. For authentication use api credentials.
        public func get(fields: String? = nil) -> Request<CallfireAPI.Account> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths.Me {
    public var api: API {
        API(path: path + "/api")
    }

    public struct API {
        /// Path: `/me/api`
        public let path: String
    }
}

extension Paths.Me.API {
    public var credentials: Credentials {
        Credentials(path: path + "/credentials")
    }

    public struct Credentials {
        /// Path: `/me/api/credentials`
        public let path: String

        /// Find api credentials
        ///
        /// Searches for all credentials generated by user. Returns a paged list of the API credentials. Only ACCOUNT_HOLDER can invoke this API. For authentication use account credentials.
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.APICredentialPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var name: String?
            public var fields: String?
            public var limit: Int?
            public var offset: Int?

            public init(name: String? = nil, fields: String? = nil, limit: Int? = nil, offset: Int? = nil) {
                self.name = name
                self.fields = fields
                self.limit = limit
                self.offset = offset
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(name, forKey: "name")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                return encoder.items
            }
        }

        /// Create api credentials
        ///
        /// Creates an API credentials for the CallFire API. This endpoint requires full CallFire account credentials to be used, authenticated using Basic Authentication. At the moment user provides only the name for the credentials. The generated credentials can be used to access any CallFire APIs. For authentication use account credentials.
        public func post(_ body: CallfireAPI.APICredential? = nil) -> Request<CallfireAPI.APICredential> {
            .post(path, body: body)
        }
    }
}

extension Paths.Me.API.Credentials {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/me/api/credentials/{id}`
        public let path: String

        /// Find a specific api credential
        ///
        /// Returns an API credential instance for a given api credential id. Only ACCOUNT_HOLDER can invoke this API. For authentication use account credentials.
        public func get(fields: String? = nil) -> Request<CallfireAPI.APICredential> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }

        /// Delete api credentials
        ///
        /// Deletes a specified API credential. Currently, removes the ability to access the API. Only ACCOUNT_HOLDER can invoke this API. For authentication use account credentials.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Me.API.Credentials.WithID {
    public var disable: Disable {
        Disable(path: path + "/disable")
    }

    public struct Disable {
        /// Path: `/me/api/credentials/{id}/disable`
        public let path: String

        /// Disable specified API credentials
        ///
        /// Disables a specified API credential. Currently, removes the ability to access the API. Only ACCOUNT_HOLDER can invoke this API. For authentication use account credentials.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Me.API.Credentials.WithID {
    public var enable: Enable {
        Enable(path: path + "/enable")
    }

    public struct Enable {
        /// Path: `/me/api/credentials/{id}/enable`
        public let path: String

        /// Enable specified API credentials
        ///
        /// Enables a specified API credential. Currently, adds the ability to access the API. Only ACCOUNT_HOLDER can invoke this API. For authentication use account credentials.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Me {
    public var billing: Billing {
        Billing(path: path + "/billing")
    }

    public struct Billing {
        /// Path: `/me/billing`
        public let path: String
    }
}

extension Paths.Me.Billing {
    public var creditUsage: CreditUsage {
        CreditUsage(path: path + "/credit-usage")
    }

    public struct CreditUsage {
        /// Path: `/me/billing/credit-usage`
        public let path: String

        /// Find credit usage
        ///
        /// Find credit usage for the user. Returns credits usage for time period specified or if unspecified then total for all time. For authentication use api credentials.
        public func get(intervalBegin: Int? = nil, intervalEnd: Int? = nil) -> Request<CallfireAPI.CreditUsage> {
            .get(path, query: makeGetQuery(intervalBegin, intervalEnd))
        }

        private func makeGetQuery(_ intervalBegin: Int?, _ intervalEnd: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(intervalBegin, forKey: "intervalBegin")
            encoder.encode(intervalEnd, forKey: "intervalEnd")
            return encoder.items
        }
    }
}

extension Paths.Me.Billing {
    public var planUsage: PlanUsage {
        PlanUsage(path: path + "/plan-usage")
    }

    public struct PlanUsage {
        /// Path: `/me/billing/plan-usage`
        public let path: String

        /// Find plan usage
        ///
        /// Searches for the data of a billing plan usage for the user. Returns the data of a billing plan usage for the current month. For authentication use api credentials.
        public var get: Request<CallfireAPI.BillingPlanUsage> {
            .get(path)
        }
    }
}

extension Paths.Me {
    public var callerids: Callerids {
        Callerids(path: path + "/callerids")
    }

    public struct Callerids {
        /// Path: `/me/callerids`
        public let path: String

        /// Find caller ids
        ///
        /// Returns a list of verified caller ids. If the number is not shown in the list, then it is not verified. In this case sending of a verification code is required. For authentication use api credentials.
        public var get: Request<CallfireAPI.CallerIDList> {
            .get(path)
        }
    }
}

extension Paths.Me.Callerids {
    public func callerid(_ callerid: String) -> WithCallerid {
        WithCallerid(path: "\(path)/\(callerid)")
    }

    public struct WithCallerid {
        /// Path: `/me/callerids/{callerid}`
        public let path: String

        /// Create a caller id
        ///
        /// Generates and sends a verification code to the phone number provided in the path. The verification code is delivered via a phone call. This code needs to be submitted to the verify caller id API endpoint to complete verification. For authentication use api credentials.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Me.Callerids.WithCallerid {
    public var verificationCode: VerificationCode {
        VerificationCode(path: path + "/verification-code")
    }

    public struct VerificationCode {
        /// Path: `/me/callerids/{callerid}/verification-code`
        public let path: String

        /// Verify a caller id
        ///
        /// With the verification code received from the Create caller id endpoint, a call to this endpoint is required to finish verification. For authentication use api credentials.
        public func post(_ body: CallfireAPI.CallerIDVerificationRequest? = nil) -> Request<Data> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var media: Media {
        Media(path: "/media")
    }

    public struct Media {
        /// Path: `/media`
        public let path: String

        /// Find media
        ///
        /// Find media files created by user
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.MediaPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var limit: Int?
            public var offset: Int?
            public var filter: String?
            public var fields: String?

            public init(limit: Int? = nil, offset: Int? = nil, filter: String? = nil, fields: String? = nil) {
                self.limit = limit
                self.offset = offset
                self.filter = filter
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(filter, forKey: "filter")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }

        /// Create media
        ///
        /// Uploads media file to account, acceptable media formats: bmp, gif, jpg, m4a, mp3, mp4, png, wav
        public func post(_ body: Data) -> Request<CallfireAPI.ResourceID> {
            .post(path, body: body)
        }
    }
}

extension Paths.Media {
    public var `public`: Public {
        Public(path: path + "/public")
    }

    public struct Public {
        /// Path: `/media/public`
        public let path: String
    }
}

extension Paths.Media.Public {
    public func key(_ key: String) -> WithExtension {
        WithExtension(path: "\(path)/\(key).{extension}")
    }

    public struct WithExtension {
        /// Path: `/media/public/{key}.{extension}`
        public let path: String

        /// Download media by extension
        ///
        /// Download a media file. Available types of files: bmp, gif, jpg, m4a, mp3, mp4, png, wav. Content type in response depends on 'extension' parameter, e.g. image/jpeg, image/png, audio/mp3, etc
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Media {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/media/{id}`
        public let path: String

        /// Get a specific media
        ///
        /// Get media resource by id
        public func get(fields: String? = nil) -> Request<CallfireAPI.Media> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths.Media {
    public func id(_ id: Int) -> WithExtension {
        WithExtension(path: "\(path)/\(id).{extension}")
    }

    public struct WithExtension {
        /// Path: `/media/{id}.{extension}`
        public let path: String

        /// Download media by extension
        ///
        /// Download a media file. Available types of files: bmp, gif, jpg, m4a, mp3, mp4, png, wav. Content type in response depends on 'extension' parameter, e.g. image/jpeg, image/png, audio/mp3, etc
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Media.WithID {
    public var file: File {
        File(path: path + "/file")
    }

    public struct File {
        /// Path: `/media/{id}/file`
        public let path: String

        /// Download a MP3 media
        ///
        /// Download a MP3 media, endpoint returns application/binary content-type
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths {
    public static var numbers: Numbers {
        Numbers(path: "/numbers")
    }

    public struct Numbers {
        /// Path: `/numbers`
        public let path: String
    }
}

extension Paths.Numbers {
    public var leases: Leases {
        Leases(path: path + "/leases")
    }

    public struct Leases {
        /// Path: `/numbers/leases`
        public let path: String

        /// Find leases
        ///
        /// Searches for all numbers leased by account user. This API is useful for finding all numbers currently owned by the user. Returns a paged list of number leases.
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.NumberLeasePage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var limit: Int?
            public var offset: Int?
            public var prefix: String?
            public var city: String?
            public var state: String?
            public var zipcode: String?
            public var labelName: String?
            public var isTollFree: Bool?
            public var fields: String?

            public init(limit: Int? = nil, offset: Int? = nil, prefix: String? = nil, city: String? = nil, state: String? = nil, zipcode: String? = nil, labelName: String? = nil, isTollFree: Bool? = nil, fields: String? = nil) {
                self.limit = limit
                self.offset = offset
                self.prefix = prefix
                self.city = city
                self.state = state
                self.zipcode = zipcode
                self.labelName = labelName
                self.isTollFree = isTollFree
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(prefix, forKey: "prefix")
                encoder.encode(city, forKey: "city")
                encoder.encode(state, forKey: "state")
                encoder.encode(zipcode, forKey: "zipcode")
                encoder.encode(labelName, forKey: "labelName")
                encoder.encode(isTollFree, forKey: "tollFree")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Numbers.Leases {
    public var configs: Configs {
        Configs(path: path + "/configs")
    }

    public struct Configs {
        /// Path: `/numbers/leases/configs`
        public let path: String

        /// Find lease configs
        ///
        /// Searches for all number lease configs for the user. Returns a paged list of NumberConfig
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.NumberConfigPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var limit: Int?
            public var offset: Int?
            public var prefix: String?
            public var city: String?
            public var state: String?
            public var zipcode: String?
            public var labelName: String?
            public var fields: String?

            public init(limit: Int? = nil, offset: Int? = nil, prefix: String? = nil, city: String? = nil, state: String? = nil, zipcode: String? = nil, labelName: String? = nil, fields: String? = nil) {
                self.limit = limit
                self.offset = offset
                self.prefix = prefix
                self.city = city
                self.state = state
                self.zipcode = zipcode
                self.labelName = labelName
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(prefix, forKey: "prefix")
                encoder.encode(city, forKey: "city")
                encoder.encode(state, forKey: "state")
                encoder.encode(zipcode, forKey: "zipcode")
                encoder.encode(labelName, forKey: "labelName")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Numbers.Leases.Configs {
    public func number(_ number: String) -> WithNumber {
        WithNumber(path: "\(path)/\(number)")
    }

    public struct WithNumber {
        /// Path: `/numbers/leases/configs/{number}`
        public let path: String

        /// Find a specific lease config
        ///
        /// Returns a single NumberConfig instance for a given number lease
        public func get(fields: String? = nil) -> Request<CallfireAPI.NumberConfig> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }

        /// Update a lease config
        ///
        /// Updates a phone number lease configuration. Use this API endpoint to add an Inbound IVR or Call Tracking feature to a CallFire phone number. Call tracking configuration allows you to track the incoming calls, to analyze and to respond customers using sms or voice replies. For more information see [call tracking page](https://www.callfire.com/products/call-tracking)
        public func put(_ body: CallfireAPI.NumberConfig? = nil) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.Numbers.Leases {
    public func number(_ number: String) -> WithNumber {
        WithNumber(path: "\(path)/\(number)")
    }

    public struct WithNumber {
        /// Path: `/numbers/leases/{number}`
        public let path: String

        /// Find a specific lease
        ///
        /// Returns a single NumberLease instance for a given number
        public func get(fields: String? = nil) -> Request<CallfireAPI.NumberLease> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }

        /// Update a lease
        ///
        /// Updates a number lease instance. Ability to turn on/off autoRenew and toggle call/text features for a particular number
        public func put(_ body: CallfireAPI.NumberLease? = nil) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.Numbers {
    public var local: Local {
        Local(path: path + "/local")
    }

    public struct Local {
        /// Path: `/numbers/local`
        public let path: String

        /// Find local numbers
        ///
        /// Searches for numbers available for purchase in CallFire local numbers catalog . At least one additional parameter is required. User may filter local numbers by their region information. If all numbers with desirable zip code is already busy search will return available numbers with nearest zip code.
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.NumberList> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var limit: Int?
            public var prefix: String?
            public var city: String?
            public var state: String?
            public var zipcode: String?
            public var fields: String?

            public init(limit: Int? = nil, prefix: String? = nil, city: String? = nil, state: String? = nil, zipcode: String? = nil, fields: String? = nil) {
                self.limit = limit
                self.prefix = prefix
                self.city = city
                self.state = state
                self.zipcode = zipcode
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(prefix, forKey: "prefix")
                encoder.encode(city, forKey: "city")
                encoder.encode(state, forKey: "state")
                encoder.encode(zipcode, forKey: "zipcode")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Numbers {
    public var regions: Regions {
        Regions(path: path + "/regions")
    }

    public struct Regions {
        /// Path: `/numbers/regions`
        public let path: String

        /// Find number regions
        ///
        /// Searches for region information. Use this API to obtain detailed region information that can be used to query for more specific phone numbers than a general query.
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.RegionPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var limit: Int?
            public var offset: Int?
            public var prefix: String?
            public var city: String?
            public var state: String?
            public var zipcode: String?
            public var fields: String?

            public init(limit: Int? = nil, offset: Int? = nil, prefix: String? = nil, city: String? = nil, state: String? = nil, zipcode: String? = nil, fields: String? = nil) {
                self.limit = limit
                self.offset = offset
                self.prefix = prefix
                self.city = city
                self.state = state
                self.zipcode = zipcode
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(prefix, forKey: "prefix")
                encoder.encode(city, forKey: "city")
                encoder.encode(state, forKey: "state")
                encoder.encode(zipcode, forKey: "zipcode")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Numbers {
    public var tollfree: Tollfree {
        Tollfree(path: path + "/tollfree")
    }

    public struct Tollfree {
        /// Path: `/numbers/tollfree`
        public let path: String

        /// Find tollfree numbers
        ///
        /// Searches for the toll free numbers which are available for purchase in the CallFire catalog
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.NumberList> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var pattern: String?
            public var limit: Int?
            public var fields: String?

            public init(pattern: String? = nil, limit: Int? = nil, fields: String? = nil) {
                self.pattern = pattern
                self.limit = limit
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(pattern, forKey: "pattern")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var orders: Orders {
        Orders(path: "/orders")
    }

    public struct Orders {
        /// Path: `/orders`
        public let path: String

        /// Find orders
        ///
        /// Searches for account orders
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.PageNumberOrder> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var limit: Int?
            public var offset: Int?
            public var fields: String?
            public var status: [String]?
            public var intervalBegin: Int?
            public var intervalEnd: Int?

            public init(limit: Int? = nil, offset: Int? = nil, fields: String? = nil, status: [String]? = nil, intervalBegin: Int? = nil, intervalEnd: Int? = nil) {
                self.limit = limit
                self.offset = offset
                self.fields = fields
                self.status = status
                self.intervalBegin = intervalBegin
                self.intervalEnd = intervalEnd
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(status, forKey: "status")
                encoder.encode(intervalBegin, forKey: "intervalBegin")
                encoder.encode(intervalEnd, forKey: "intervalEnd")
                return encoder.items
            }
        }
    }
}

extension Paths.Orders {
    public var keywords: Keywords {
        Keywords(path: path + "/keywords")
    }

    public struct Keywords {
        /// Path: `/orders/keywords`
        public let path: String

        /// Purchase keywords
        ///
        /// Purchase keywords. Send a list of available keywords into this API to purchase them using CallFire credits. Make sure the account has enough credits before trying to purchase the keywords. Keyword should only consist of uppercase and lowercase letters and numbers. Number of characters must be greater than 2, but less than 65.
        public func post(fields: String? = nil, _ body: CallfireAPI.KeywordPurchaseRequest? = nil) -> Request<CallfireAPI.ResourceID> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths.Orders {
    public var numbers: Numbers {
        Numbers(path: path + "/numbers")
    }

    public struct Numbers {
        /// Path: `/orders/numbers`
        public let path: String

        /// Purchase numbers
        ///
        /// Purchase numbers. There are many ways to purchase a number. Set either 'tollFreeCount' or 'localCount' along with some querying fields to purchase numbers by bulk query. Set the list of numbers to purchase by list. Available numbers will be purchased using CallFire credits owned by the user. Make sure the account has enough credits before trying to purchase
        public func post(fields: String? = nil, _ body: CallfireAPI.NumberPurchaseRequest? = nil) -> Request<CallfireAPI.ResourceID> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths.Orders {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/orders/{id}`
        public let path: String

        /// Find a specific order
        ///
        /// Returns a single NumberOrder instance for a given order id. Order contains information about purchased keywords, local, toll-free numbers
        public func get(fields: String? = nil) -> Request<CallfireAPI.NumberOrder> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths {
    public static var reports: Reports {
        Reports(path: "/reports")
    }

    public struct Reports {
        /// Path: `/reports`
        public let path: String
    }
}

extension Paths.Reports {
    public var delivery: Delivery {
        Delivery(path: path + "/delivery")
    }

    public struct Delivery {
        /// Path: `/reports/delivery`
        public let path: String

        /// Get delivery reports by ad hoc criteria
        ///
        /// Get delivery reports
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.PageDeliveryReport> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var startDate: String?
            public var endDate: String?
            public var limit: Int?
            public var offset: Int?
            public var campaignID: Int?
            public var fromNumber: String?
            public var toNumber: String?
            public var deliveryCategory: DeliveryCategory?
            public var deliveryState: DeliveryState?
            public var carrier: String?
            public var messageText: String?

            public enum DeliveryCategory: String, Codable, CaseIterable {
                case noData = "NO_DATA"
                case optedOut = "OPTED_OUT"
                case bounced = "BOUNCED"
                case noCredits = "NO_CREDITS"
                case delivered = "DELIVERED"
            }

            public enum DeliveryState: String, Codable, CaseIterable {
                case delivered = "DELIVERED"
                case unsentOptedOutGlobal = "UNSENT_OPTED_OUT_GLOBAL"
                case unsentOptedOutLocal = "UNSENT_OPTED_OUT_LOCAL"
                case unsentNoCredits = "UNSENT_NO_CREDITS"
                case gatewayRejected = "GATEWAY_REJECTED"
                case carrierRejected = "CARRIER_REJECTED"
                case notDelivered = "NOT_DELIVERED"
                case unsentInvalidNumber = "UNSENT_INVALID_NUMBER"
                case unsentBadData = "UNSENT_BAD_DATA"
                case unsentForceStopped = "UNSENT_FORCE_STOPPED"
                case unsentPeriodLimit = "UNSENT_PERIOD_LIMIT"
                case unsentInternational = "UNSENT_INTERNATIONAL"
                case unsentInvalidTimezoneOrDnc = "UNSENT_INVALID_TIMEZONE_OR_DNC"
                case unsentAlreadyScrubbed = "UNSENT_ALREADY_SCRUBBED"
                case unsentSystemError = "UNSENT_SYSTEM_ERROR"
                case unsentNoWirelessCarrier = "UNSENT_NO_WIRELESS_CARRIER"
                case unsentMessageTooLong = "UNSENT_MESSAGE_TOO_LONG"
                case unsentMessageBlocked = "UNSENT_MESSAGE_BLOCKED"
                case unsentQueueLimitReached = "UNSENT_QUEUE_LIMIT_REACHED"
                case unsentTokenLimitReached = "UNSENT_TOKEN_LIMIT_REACHED"
                case unsentTimeLimitReached = "UNSENT_TIME_LIMIT_REACHED"
                case unsentSchedulerCapacityExceeded = "UNSENT_SCHEDULER_CAPACITY_EXCEEDED"
                case spamDetected = "SPAM_DETECTED"
                case unsentNoGateway = "UNSENT_NO_GATEWAY"
                case originated = "ORIGINATED"
                case submitted = "SUBMITTED"
                case forwarded = "FORWARDED"
                case notGiven = "NOT_GIVEN"
                case unknown = "UNKNOWN"
                case retryMmsAsSms = "RETRY_MMS_AS_SMS"
                case queued = "QUEUED"
                case queuedTranscode = "QUEUED_TRANSCODE"
                case original = "ORIGINAL"
                case dupe = "DUPE"
                case truncated = "TRUNCATED"
                case requeuedRateLimited = "REQUEUED_RATE_LIMITED"
                case buffered = "BUFFERED"
                case rateLimitExceeded = "RATE_LIMIT_EXCEEDED"
                case serviceUnavailable = "SERVICE_UNAVAILABLE"
                case sendMmsAsSms = "SEND_MMS_AS_SMS"
                case requeuedRecoverableError = "REQUEUED_RECOVERABLE_ERROR"
                case sendWithAdditionalSpid = "SEND_WITH_ADDITIONAL_SPID"
            }

            public init(startDate: String? = nil, endDate: String? = nil, limit: Int? = nil, offset: Int? = nil, campaignID: Int? = nil, fromNumber: String? = nil, toNumber: String? = nil, deliveryCategory: DeliveryCategory? = nil, deliveryState: DeliveryState? = nil, carrier: String? = nil, messageText: String? = nil) {
                self.startDate = startDate
                self.endDate = endDate
                self.limit = limit
                self.offset = offset
                self.campaignID = campaignID
                self.fromNumber = fromNumber
                self.toNumber = toNumber
                self.deliveryCategory = deliveryCategory
                self.deliveryState = deliveryState
                self.carrier = carrier
                self.messageText = messageText
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(startDate, forKey: "startDate")
                encoder.encode(endDate, forKey: "endDate")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(campaignID, forKey: "campaignId")
                encoder.encode(fromNumber, forKey: "fromNumber")
                encoder.encode(toNumber, forKey: "toNumber")
                encoder.encode(deliveryCategory, forKey: "deliveryCategory")
                encoder.encode(deliveryState, forKey: "deliveryState")
                encoder.encode(carrier, forKey: "carrier")
                encoder.encode(messageText, forKey: "messageText")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var texts: Texts {
        Texts(path: "/texts")
    }

    public struct Texts {
        /// Path: `/texts`
        public let path: String

        /// Find texts
        ///
        /// Searches for texts sent or received by user. Use "campaignId=0" parameter to query for all texts sent through the POST /texts API. See [call states and results](https://developers.callfire.com/results-responses-errors.html)
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.TextPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var id: [Int]?
            public var campaignID: Int?
            public var batchID: Int?
            public var fromNumber: String?
            public var toNumber: String?
            public var label: String?
            public var states: String?
            public var results: String?
            public var isInbound: Bool?
            public var intervalBegin: Int?
            public var intervalEnd: Int?
            public var limit: Int?
            public var offset: Int?
            public var fields: String?

            public init(id: [Int]? = nil, campaignID: Int? = nil, batchID: Int? = nil, fromNumber: String? = nil, toNumber: String? = nil, label: String? = nil, states: String? = nil, results: String? = nil, isInbound: Bool? = nil, intervalBegin: Int? = nil, intervalEnd: Int? = nil, limit: Int? = nil, offset: Int? = nil, fields: String? = nil) {
                self.id = id
                self.campaignID = campaignID
                self.batchID = batchID
                self.fromNumber = fromNumber
                self.toNumber = toNumber
                self.label = label
                self.states = states
                self.results = results
                self.isInbound = isInbound
                self.intervalBegin = intervalBegin
                self.intervalEnd = intervalEnd
                self.limit = limit
                self.offset = offset
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(id, forKey: "id")
                encoder.encode(campaignID, forKey: "campaignId")
                encoder.encode(batchID, forKey: "batchId")
                encoder.encode(fromNumber, forKey: "fromNumber")
                encoder.encode(toNumber, forKey: "toNumber")
                encoder.encode(label, forKey: "label")
                encoder.encode(states, forKey: "states")
                encoder.encode(results, forKey: "results")
                encoder.encode(isInbound, forKey: "inbound")
                encoder.encode(intervalBegin, forKey: "intervalBegin")
                encoder.encode(intervalEnd, forKey: "intervalEnd")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }

        /// Send texts
        ///
        /// Use the /texts API to send individual texts quickly. By default all texts are going out from CallFire's dedicated short code. Example: 67076, 818818 etc
        public func post(parameters: PostParameters? = nil, _ body: [CallfireAPI.TextRecipient]? = nil) -> Request<CallfireAPI.TextList> {
            .post(path, query: parameters?.asQuery, body: body)
        }

        public struct PostParameters {
            public var fields: String?
            public var campaignID: Int?
            public var defaultMessage: String?
            public var isStrictValidation: Bool?

            public init(fields: String? = nil, campaignID: Int? = nil, defaultMessage: String? = nil, isStrictValidation: Bool? = nil) {
                self.fields = fields
                self.campaignID = campaignID
                self.defaultMessage = defaultMessage
                self.isStrictValidation = isStrictValidation
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields")
                encoder.encode(campaignID, forKey: "campaignId")
                encoder.encode(defaultMessage, forKey: "defaultMessage")
                encoder.encode(isStrictValidation, forKey: "strictValidation")
                return encoder.items
            }
        }
    }
}

extension Paths.Texts {
    public var autoReplys: AutoReplys {
        AutoReplys(path: path + "/auto-replys")
    }

    public struct AutoReplys {
        /// Path: `/texts/auto-replys`
        public let path: String

        /// Find auto replies
        ///
        /// Find all text autoreplies created by user. Returns a paged list of TextAutoReply
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.TextAutoReplyPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: String?
            public var limit: Int?
            public var offset: Int?
            public var number: String?

            public init(fields: String? = nil, limit: Int? = nil, offset: Int? = nil, number: String? = nil) {
                self.fields = fields
                self.limit = limit
                self.offset = offset
                self.number = number
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(number, forKey: "number")
                return encoder.items
            }
        }

        /// Create an auto reply
        ///
        /// CallFire gives you possibility to set up auto reply messages for your numbers and keywords. You can set a general auto reply for anyone who texts your number, keyword, and/or include a text to match, so that the auto reply would be sent only to those who text the matched text
        public func post(_ body: CallfireAPI.TextAutoReply? = nil) -> Request<CallfireAPI.ResourceID> {
            .post(path, body: body)
        }
    }
}

extension Paths.Texts.AutoReplys {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/texts/auto-replys/{id}`
        public let path: String

        /// Find a specific auto reply
        ///
        /// Returns a single TextAutoReply instance for a given text auto reply id
        public func get(fields: String? = nil) -> Request<CallfireAPI.TextAutoReply> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }

        /// Delete an auto reply
        ///
        /// Deletes a text auto reply and removes the configuration. Can not delete a TextAutoReply which is currently active for a campaign
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Texts {
    public var broadcasts: Broadcasts {
        Broadcasts(path: path + "/broadcasts")
    }

    public struct Broadcasts {
        /// Path: `/texts/broadcasts`
        public let path: String

        /// Find text broadcasts
        ///
        /// Searches for all text broadcasts created by user. Can query on label, name, and the current running status of the campaign. Returns a paged list of text broadcasts
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.TextBroadcastPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var name: String?
            public var label: String?
            public var isRunning: Bool?
            public var isScheduled: Bool?
            public var intervalBegin: Int?
            public var intervalEnd: Int?
            public var limit: Int?
            public var offset: Int?
            public var fields: String?

            public init(name: String? = nil, label: String? = nil, isRunning: Bool? = nil, isScheduled: Bool? = nil, intervalBegin: Int? = nil, intervalEnd: Int? = nil, limit: Int? = nil, offset: Int? = nil, fields: String? = nil) {
                self.name = name
                self.label = label
                self.isRunning = isRunning
                self.isScheduled = isScheduled
                self.intervalBegin = intervalBegin
                self.intervalEnd = intervalEnd
                self.limit = limit
                self.offset = offset
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(name, forKey: "name")
                encoder.encode(label, forKey: "label")
                encoder.encode(isRunning, forKey: "running")
                encoder.encode(isScheduled, forKey: "scheduled")
                encoder.encode(intervalBegin, forKey: "intervalBegin")
                encoder.encode(intervalEnd, forKey: "intervalEnd")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(fields, forKey: "fields")
                return encoder.items
            }
        }

        /// Create a text broadcast
        ///
        /// Creates a text broadcast campaign using the Text Broadcast API. Send a TextBroadcast object in the message body to detail a text broadcast campaign. A campaign can be created without contacts and with bare minimum configuration, but contacts have to be added further on to use the campaign. It supports scheduling, retry logic, pattern-based messages.
        public func post(isStart: Bool? = nil, isStrictValidation: Bool? = nil, _ body: CallfireAPI.TextBroadcast? = nil) -> Request<CallfireAPI.ResourceID> {
            .post(path, query: makePostQuery(isStart, isStrictValidation), body: body)
        }

        private func makePostQuery(_ isStart: Bool?, _ isStrictValidation: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStart, forKey: "start")
            encoder.encode(isStrictValidation, forKey: "strictValidation")
            return encoder.items
        }
    }
}

extension Paths.Texts.Broadcasts {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/texts/broadcasts/{id}`
        public let path: String

        /// Find a specific text broadcast
        ///
        /// Returns a single TextBroadcast instance for a given text broadcast id
        public func get(fields: String? = nil) -> Request<CallfireAPI.TextBroadcast> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }

        /// Update a text broadcast
        ///
        /// Allows modifying the configuration of existing text broadcast campaign. See TextBroadcast for more information on what can/can't be updated on this API
        public func put(isStrictValidation: Bool? = nil, _ body: CallfireAPI.TextBroadcast? = nil) -> Request<CallfireAPI.TextBroadcastCreateResponse> {
            .put(path, query: makePutQuery(isStrictValidation), body: body)
        }

        private func makePutQuery(_ isStrictValidation: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStrictValidation, forKey: "strictValidation")
            return encoder.items
        }
    }
}

extension Paths.Texts.Broadcasts.WithID {
    public var archive: Archive {
        Archive(path: path + "/archive")
    }

    public struct Archive {
        /// Path: `/texts/broadcasts/{id}/archive`
        public let path: String

        /// Archive text broadcast
        ///
        /// Archives a text broadcast (and hides it in the search results)
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Texts.Broadcasts.WithID {
    public var batches: Batches {
        Batches(path: path + "/batches")
    }

    public struct Batches {
        /// Path: `/texts/broadcasts/{id}/batches`
        public let path: String

        /// Find batches in a text broadcast
        ///
        /// This endpoint will enable the user to page through all of the batches for a particular text broadcast campaign
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.BatchPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: String?
            public var limit: Int?
            public var offset: Int?

            public init(fields: String? = nil, limit: Int? = nil, offset: Int? = nil) {
                self.fields = fields
                self.limit = limit
                self.offset = offset
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                return encoder.items
            }
        }

        /// Add batches to a text broadcast
        ///
        /// Allows adding an extra batches to an already created text broadcast campaign. The batches which being  added pass the CallFire validation process (unlike in the recipients version of this API). That is why using of a scrubDuplicates flag remove duplicates from your batch. Batches may be added as a contact list id, a list of contact ids, or a list of numbers
        public func post(isStrictValidation: Bool? = nil, _ body: CallfireAPI.BatchRequest? = nil) -> Request<CallfireAPI.ResourceID> {
            .post(path, query: makePostQuery(isStrictValidation), body: body)
        }

        private func makePostQuery(_ isStrictValidation: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStrictValidation, forKey: "strictValidation")
            return encoder.items
        }
    }
}

extension Paths.Texts.Broadcasts.WithID {
    public var recipients: Recipients {
        Recipients(path: path + "/recipients")
    }

    public struct Recipients {
        /// Path: `/texts/broadcasts/{id}/recipients`
        public let path: String

        /// Add recipients to a text broadcast
        ///
        /// Use this API to add recipients to a text broadcast which is already created. Post a list of Recipient objects to be immediately added to the text broadcast campaign. These contacts will not go through validation process, and will be acted upon as they are added. Recipients may be added as a list of contact ids, or list of numbers
        public func post(fields: String? = nil, isStrictValidation: Bool? = nil, _ body: [CallfireAPI.TextRecipient]? = nil) -> Request<CallfireAPI.TextList> {
            .post(path, query: makePostQuery(fields, isStrictValidation), body: body)
        }

        private func makePostQuery(_ fields: String?, _ isStrictValidation: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            encoder.encode(isStrictValidation, forKey: "strictValidation")
            return encoder.items
        }
    }
}

extension Paths.Texts.Broadcasts.WithID {
    public var start: Start {
        Start(path: path + "/start")
    }

    public struct Start {
        /// Path: `/texts/broadcasts/{id}/start`
        public let path: String

        /// Start text broadcast
        ///
        /// Starts a text broadcast
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Texts.Broadcasts.WithID {
    public var stats: Stats {
        Stats(path: path + "/stats")
    }

    public struct Stats {
        /// Path: `/texts/broadcasts/{id}/stats`
        public let path: String

        /// Get statistics on text broadcast
        ///
        /// Returns the broadcast statistics. Example: total number of the sent/received actions, total cost, number of remaining outbound actions, error count, etc
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.TextBroadcastStatsDto> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: String?
            public var begin: Int?
            public var end: Int?

            public init(fields: String? = nil, begin: Int? = nil, end: Int? = nil) {
                self.fields = fields
                self.begin = begin
                self.end = end
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields")
                encoder.encode(begin, forKey: "begin")
                encoder.encode(end, forKey: "end")
                return encoder.items
            }
        }
    }
}

extension Paths.Texts.Broadcasts.WithID {
    public var stop: Stop {
        Stop(path: path + "/stop")
    }

    public struct Stop {
        /// Path: `/texts/broadcasts/{id}/stop`
        public let path: String

        /// Stop text broadcast
        ///
        /// Stops a text broadcast
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Texts.Broadcasts.WithID {
    public var texts: Texts {
        Texts(path: path + "/texts")
    }

    public struct Texts {
        /// Path: `/texts/broadcasts/{id}/texts`
        public let path: String

        /// Find texts in a text broadcast
        ///
        /// This endpoint will enable the user to page through all of the texts for a particular text broadcast campaign
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.TextPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var batchID: Int?
            public var fields: String?
            public var limit: Int?
            public var offset: Int?

            public init(batchID: Int? = nil, fields: String? = nil, limit: Int? = nil, offset: Int? = nil) {
                self.batchID = batchID
                self.fields = fields
                self.limit = limit
                self.offset = offset
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(batchID, forKey: "batchId")
                encoder.encode(fields, forKey: "fields")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                return encoder.items
            }
        }
    }
}

extension Paths.Texts.Broadcasts.WithID {
    public var toggleRecipientsStatus: ToggleRecipientsStatus {
        ToggleRecipientsStatus(path: path + "/toggleRecipientsStatus")
    }

    public struct ToggleRecipientsStatus {
        /// Path: `/texts/broadcasts/{id}/toggleRecipientsStatus`
        public let path: String

        /// Disable/enable undialed recipients in broadcast
        ///
        /// This operation lets the user to disable/enable undialed contacts in created broadcast
        public func post(enable: Bool? = nil, _ body: [CallfireAPI.Recipient]? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(enable), body: body)
        }

        private func makePostQuery(_ enable: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(enable, forKey: "enable")
            return encoder.items
        }
    }
}

extension Paths.Texts {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/texts/{id}`
        public let path: String

        /// Find a specific text
        ///
        /// Returns a single Text instance for a given text id
        public func get(fields: String? = nil) -> Request<CallfireAPI.Text> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths {
    public static var webhooks: Webhooks {
        Webhooks(path: "/webhooks")
    }

    public struct Webhooks {
        /// Path: `/webhooks`
        public let path: String

        /// Find webhooks
        ///
        /// Searches all webhooks available for a current user. Searches by name, resource, event, callback URL, or whether they are enabled. Returns a paged list of Webhooks
        public func get(parameters: GetParameters? = nil) -> Request<CallfireAPI.WebhookPage> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: String?
            public var limit: Int?
            public var offset: Int?
            public var name: String?
            public var resource: String?
            public var event: String?
            public var callback: String?
            public var isEnabled: Bool?

            public init(fields: String? = nil, limit: Int? = nil, offset: Int? = nil, name: String? = nil, resource: String? = nil, event: String? = nil, callback: String? = nil, isEnabled: Bool? = nil) {
                self.fields = fields
                self.limit = limit
                self.offset = offset
                self.name = name
                self.resource = resource
                self.event = event
                self.callback = callback
                self.isEnabled = isEnabled
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(name, forKey: "name")
                encoder.encode(resource, forKey: "resource")
                encoder.encode(event, forKey: "event")
                encoder.encode(callback, forKey: "callback")
                encoder.encode(isEnabled, forKey: "enabled")
                return encoder.items
            }
        }

        /// Create a webhook
        ///
        /// Create a Webhook for notification in the CallFire system. Use the webhooks API to receive notifications of important CallFire events. Select the resource to listen to, and then choose the resource events to receive notifications on. When an event triggers, a POST will be made to the callback URL with a payload of notification information. Available resources and their events include 'CccCampaign': ['started', 'stopped', 'finished'], 'CallBroadcast': ['started', 'stopped', 'finished'], 'TextBroadcast': ['started', 'stopped', 'finished'], 'OutboundCall': ['finished'], 'InboundCall': ['finished'], 'OutboundText': ['finished'], 'InboundText': ['finished'], 'ContactList': ['validationFinished', 'validationFailed'], 'MonthlyRenewal': ['failed', 'finished'], 'LowBalance': ['failed', 'finished']. Webhooks support secret token which is used as signing key to HmacSHA1 hash of json payload which is returned in 'X-CallFire-Signature' header. This header can be used to verify callback POST is coming from CallFire. See [security guide](https://developers.callfire.com/security-guide.html)
        public func post(_ body: CallfireAPI.Webhook? = nil) -> Request<CallfireAPI.ResourceID> {
            .post(path, body: body)
        }
    }
}

extension Paths.Webhooks {
    public var resources: Resources {
        Resources(path: path + "/resources")
    }

    public struct Resources {
        /// Path: `/webhooks/resources`
        public let path: String

        /// Find webhook resources
        ///
        /// Searches for webhook resources. Available resources include 'CccCampaign': ['started', 'stopped', 'finished'], 'CallBroadcast': ['started', 'stopped', 'finished'], 'TextBroadcast': ['started', 'stopped', 'finished'], 'OutboundCall': ['finished'], 'InboundCall': ['finished'], 'OutboundText': ['finished'], 'InboundText': ['finished'], 'ContactList': ['validationFinished', 'validationFailed'], 'MonthlyRenewal': ['failed', 'finished'], 'LowBalance': ['failed', 'finished']
        public func get(fields: String? = nil) -> Request<CallfireAPI.ItemListWebhookResource> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths.Webhooks.Resources {
    public func resource(_ resource: String) -> WithResource {
        WithResource(path: "\(path)/\(resource)")
    }

    public struct WithResource {
        /// Path: `/webhooks/resources/{resource}`
        public let path: String

        /// Find specific webhook resource
        ///
        /// Returns information about supported events for a given webhook resource
        public func get(fields: String? = nil) -> Request<CallfireAPI.WebhookResource> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }
    }
}

extension Paths.Webhooks {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/webhooks/{id}`
        public let path: String

        /// Find a specific webhook
        ///
        /// Returns a single Webhook instance for a given webhook id
        public func get(fields: String? = nil) -> Request<CallfireAPI.Webhook> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields")
            return encoder.items
        }

        /// Update a webhook
        ///
        /// Updates the information in existing webhook
        public func put(_ body: CallfireAPI.Webhook? = nil) -> Request<Void> {
            .put(path, body: body)
        }

        /// Delete a webhook
        ///
        /// Deletes a webhook instance. Will be removed permanently
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

public enum Paths {}
