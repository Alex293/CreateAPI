// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

public struct ChannelDetails: Codable {
    /// The required name of the channel including any qualifier, if any.
    public var channelID: String
    /// In events relating to the activity of a channel in a specific region, this optionally identifies whether or not that region is responsible for global coordination of the channel.
    public var isGlobalMaster: Bool?
    /// In events relating to the activity of a channel in a specific region, this optionally identifies the region.
    public var region: String?
    /// A ChannelStatus instance.
    public var status: ChannelStatus?

    public init(channelID: String, isGlobalMaster: Bool? = nil, region: String? = nil, status: ChannelStatus? = nil) {
        self.channelID = channelID
        self.isGlobalMaster = isGlobalMaster
        self.region = region
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case channelID = "channelId"
        case isGlobalMaster
        case region
        case status
    }
}

/// A ChannelStatus instance.
public struct ChannelStatus: Codable {
    /// A required boolean value indicating whether the channel that is the subject of the event is active. For events indicating regional activity of a channel this indicates activity in that region, not global activity.
    public var isActive: Bool
    /// An Occupancy instance indicating the occupancy of a channel. For events indicating regional activity of a channel this indicates activity in that region, not global activity.
    public var occupancy: Occupancy?

    public init(isActive: Bool, occupancy: Occupancy? = nil) {
        self.isActive = isActive
        self.occupancy = occupancy
    }
}

public struct DeviceDetails: Codable {
    /// Optional trusted client identifier for the device.
    public var clientID: String?
    /// Secret value for the device.
    public var deviceSecret: String?
    /// Form factor of the push device.
    public var formFactor: FormFactor?
    /// Unique identifier for the device generated by the device itself.
    public var id: String?
    /// Optional metadata object for this device. The metadata for a device may only be set by clients with push-admin privileges and will be used more extensively in the future with smart notifications.
    public var metadata: Metadata?
    /// Platform of the push device.
    public var platform: Platform?
    /// Push recipient details for a device.
    public var pushRecipient: Recipient?
    /// The current state of the push device.
    public var pushState: PushState?

    /// Form factor of the push device.
    public enum FormFactor: String, Codable, CaseIterable {
        case phone
        case tablet
        case desktop
        case tv
        case watch
        case car
        case embedded
    }

    /// Optional metadata object for this device. The metadata for a device may only be set by clients with push-admin privileges and will be used more extensively in the future with smart notifications.
    public struct Metadata: Codable {
        public init() {}
    }

    /// Platform of the push device.
    public enum Platform: String, Codable, CaseIterable {
        case ios
        case android
    }

    /// The current state of the push device.
    public enum PushState: String, Codable, CaseIterable {
        case active = "Active"
        case failing = "Failing"
        case failed = "Failed"
    }

    public init(clientID: String? = nil, deviceSecret: String? = nil, formFactor: FormFactor? = nil, id: String? = nil, metadata: Metadata? = nil, platform: Platform? = nil, pushRecipient: Recipient? = nil, pushState: PushState? = nil) {
        self.clientID = clientID
        self.deviceSecret = deviceSecret
        self.formFactor = formFactor
        self.id = id
        self.metadata = metadata
        self.platform = platform
        self.pushRecipient = pushRecipient
        self.pushState = pushState
    }

    private enum CodingKeys: String, CodingKey {
        case clientID = "clientId"
        case deviceSecret
        case formFactor
        case id
        case metadata
        case platform
        case pushRecipient = "push.recipient"
        case pushState = "push.state"
    }
}

/// Returned error from failed REST.
public struct Error: Codable {
    /// Error code.
    public var code: Int?
    /// Link to help with error.
    public var href: String?
    /// Message explaining the error's cause.
    public var message: String?
    /// Server ID with which error was encountered.
    public var serverID: String?
    /// Status error code.
    public var statusCode: Int?

    public init(code: Int? = nil, href: String? = nil, message: String? = nil, serverID: String? = nil, statusCode: Int? = nil) {
        self.code = code
        self.href = href
        self.message = message
        self.serverID = serverID
        self.statusCode = statusCode
    }

    private enum CodingKeys: String, CodingKey {
        case code
        case href
        case message
        case serverID = "serverId"
        case statusCode
    }
}

/// Extras object. Currently only allows for [push](https://www.ably.io/documentation/general/push/publish#channel-broadcast-example) extra.
public struct Extras: Codable {
    public var push: Push?

    public init(push: Push? = nil) {
        self.push = push
    }
}

/// Message object.
public struct Message: Codable {
    /// The [client ID](https://www.ably.io/documentation/core-features/authentication#identified-clients) of the publisher of this message.
    public var clientID: String?
    /// The connection ID of the publisher of this message.
    public var connectionID: String?
    /// The string encoded payload, with the encoding specified below.
    public var data: String?
    /// This will typically be empty as all messages received from Ably are automatically decoded client-side using this value. However, if the message encoding cannot be processed, this attribute will contain the remaining transformations not applied to the data payload.
    public var encoding: String?
    /// Extras object. Currently only allows for [push](https://www.ably.io/documentation/general/push/publish#channel-broadcast-example) extra.
    public var extras: Extras?
    /// A Unique ID that can be specified by the publisher for [idempotent publishing](https://www.ably.io/documentation/rest/messages#idempotent).
    public var id: String?
    /// The event name, if provided.
    public var name: String?
    /// Timestamp when the message was received by the Ably, as milliseconds since the epoch.
    public var timestamp: Int?

    public init(clientID: String? = nil, connectionID: String? = nil, data: String? = nil, encoding: String? = nil, extras: Extras? = nil, id: String? = nil, name: String? = nil, timestamp: Int? = nil) {
        self.clientID = clientID
        self.connectionID = connectionID
        self.data = data
        self.encoding = encoding
        self.extras = extras
        self.id = id
        self.name = name
        self.timestamp = timestamp
    }

    private enum CodingKeys: String, CodingKey {
        case clientID = "clientId"
        case connectionID = "connectionId"
        case data
        case encoding
        case extras
        case id
        case name
        case timestamp
    }
}

public struct Notification: Codable {
    /// Text below title on the expanded notification.
    public var body: String?
    /// Platform-specific, used to group notifications together.
    public var collapseKey: String?
    /// Platform-specific icon for the notification.
    public var icon: String?
    /// Platform-specific sound for the notification.
    public var sound: String?
    /// Title to display at the notification.
    public var title: String?

    public init(body: String? = nil, collapseKey: String? = nil, icon: String? = nil, sound: String? = nil, title: String? = nil) {
        self.body = body
        self.collapseKey = collapseKey
        self.icon = icon
        self.sound = sound
        self.title = title
    }
}

/// An Occupancy instance indicating the occupancy of a channel. For events indicating regional activity of a channel this indicates activity in that region, not global activity.
public struct Occupancy: Codable {
    /// The number of connections that are authorised to enter members into the presence channel.
    public var presenceConnections: Int?
    /// The number of members currently entered into the presence channel.
    public var presenceMembers: Int?
    /// The number of connections that are authorised to subscribe to presence messages.
    public var presenceSubscribers: Int?
    /// The number of connections attached to the channel that are authorised to publish.
    public var publishers: Int?
    /// The number of connections attached that are authorised to subscribe to messages.
    public var subscribers: Int?

    public init(presenceConnections: Int? = nil, presenceMembers: Int? = nil, presenceSubscribers: Int? = nil, publishers: Int? = nil, subscribers: Int? = nil) {
        self.presenceConnections = presenceConnections
        self.presenceMembers = presenceMembers
        self.presenceSubscribers = presenceSubscribers
        self.publishers = publishers
        self.subscribers = subscribers
    }
}

public struct PresenceMessage: Codable {
    /// The event signified by a PresenceMessage.
    public var action: Action?
    /// The client ID of the publisher of this presence update.
    public var clientID: String?
    /// The connection ID of the publisher of this presence update.
    public var connectionID: String?
    /// The presence update payload, if provided.
    public var data: String?
    /// This will typically be empty as all presence updates received from Ably are automatically decoded client-side using this value. However, if the message encoding cannot be processed, this attribute will contain the remaining transformations not applied to the data payload.
    public var encoding: String?
    /// Extras object. Currently only allows for [push](https://www.ably.io/documentation/general/push/publish#channel-broadcast-example) extra.
    public var extras: Extras?
    /// Unique ID assigned by Ably to this presence update.
    public var id: String?
    /// Timestamp when the presence update was received by Ably, as milliseconds since the epoch.
    public var timestamp: Int?

    /// The event signified by a PresenceMessage.
    public enum Action: String, Codable, CaseIterable {
        case absent = "ABSENT"
        case present = "PRESENT"
        case enter = "ENTER"
        case leave = "LEAVE"
        case update = "UPDATE"
    }

    public init(action: Action? = nil, clientID: String? = nil, connectionID: String? = nil, data: String? = nil, encoding: String? = nil, extras: Extras? = nil, id: String? = nil, timestamp: Int? = nil) {
        self.action = action
        self.clientID = clientID
        self.connectionID = connectionID
        self.data = data
        self.encoding = encoding
        self.extras = extras
        self.id = id
        self.timestamp = timestamp
    }

    private enum CodingKeys: String, CodingKey {
        case action
        case clientID = "clientId"
        case connectionID = "connectionId"
        case data
        case encoding
        case extras
        case id
        case timestamp
    }
}

public struct Push: Codable {
    /// Extends and overrides generic values when delivering via APNs. [See examples](https://www.ably.io/documentation/general/push/publish#payload-structure)
    public var apns: Apns?
    /// Arbitrary [key-value string-to-string payload](https://www.ably.io/documentation/general/push/publish#channel-broadcast-example).
    public var data: String?
    /// Extends and overrides generic values when delivering via GCM/FCM. [See examples](https://www.ably.io/documentation/general/push/publish#payload-structure)
    public var fcm: Fcm?
    public var notification: Notification?
    /// Extends and overrides generic values when delivering via web. [See examples](https://www.ably.io/documentation/general/push/publish#payload-structure)
    public var web: Web?

    /// Extends and overrides generic values when delivering via APNs. [See examples](https://www.ably.io/documentation/general/push/publish#payload-structure)
    public struct Apns: Codable {
        public var notification: Notification?

        public init(notification: Notification? = nil) {
            self.notification = notification
        }
    }

    /// Extends and overrides generic values when delivering via GCM/FCM. [See examples](https://www.ably.io/documentation/general/push/publish#payload-structure)
    public struct Fcm: Codable {
        public var notification: Notification?

        public init(notification: Notification? = nil) {
            self.notification = notification
        }
    }

    /// Extends and overrides generic values when delivering via web. [See examples](https://www.ably.io/documentation/general/push/publish#payload-structure)
    public struct Web: Codable {
        public var notification: Notification?

        public init(notification: Notification? = nil) {
            self.notification = notification
        }
    }

    public init(apns: Apns? = nil, data: String? = nil, fcm: Fcm? = nil, notification: Notification? = nil, web: Web? = nil) {
        self.apns = apns
        self.data = data
        self.fcm = fcm
        self.notification = notification
        self.web = web
    }
}

/// Push recipient details for a device.
public struct Recipient: Codable {
    /// Client ID of recipient
    public var clientID: String?
    /// Client ID of recipient
    public var deviceID: String?
    /// When using APNs, specifies the required device token.
    public var deviceToken: String?
    /// When using GCM or FCM, specifies the required registration token.
    public var registrationToken: String?
    /// Defines which push platform is being used.
    public var transportType: TransportType?

    /// Defines which push platform is being used.
    public enum TransportType: String, Codable, CaseIterable {
        case apns
        case fcm
        case gcm
    }

    public init(clientID: String? = nil, deviceID: String? = nil, deviceToken: String? = nil, registrationToken: String? = nil, transportType: TransportType? = nil) {
        self.clientID = clientID
        self.deviceID = deviceID
        self.deviceToken = deviceToken
        self.registrationToken = registrationToken
        self.transportType = transportType
    }

    private enum CodingKeys: String, CodingKey {
        case clientID = "clientId"
        case deviceID = "deviceId"
        case deviceToken
        case registrationToken
        case transportType
    }
}

public struct SignedTokenRequest: Codable {
    public var tokenRequest: TokenRequest
    /// A signature, generated as an HMAC of each of the above components, using the key secret value.
    public var mac: String

    public init(tokenRequest: TokenRequest, mac: String) {
        self.tokenRequest = tokenRequest
        self.mac = mac
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.tokenRequest = try TokenRequest(from: decoder)
        self.mac = try values.decode(String.self, forKey: "mac")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(tokenRequest, forKey: "tokenRequest")
        try values.encode(mac, forKey: "mac")
    }
}

public struct TokenDetails: Codable {
    /// Regular expression representation of the capabilities of the token.
    public var capability: String?
    /// Timestamp of token expiration.
    public var expires: Int?
    /// Timestamp of token creation.
    public var issued: Int?
    /// Name of the key used to create the token
    public var keyName: String?
    /// The Ably Token.
    public var token: String?

    public init(capability: String? = nil, expires: Int? = nil, issued: Int? = nil, keyName: String? = nil, token: String? = nil) {
        self.capability = capability
        self.expires = expires
        self.issued = issued
        self.keyName = keyName
        self.token = token
    }
}

public struct TokenRequest: Codable {
    /// The [capabilities](https://www.ably.io/documentation/core-features/authentication#capabilities-explained) (i.e. a set of channel names/namespaces and, for each, a set of operations) which should be a subset of the set of capabilities associated with the key specified in keyName.
    ///
    /// Example:
    ///
    /// {
    ///   "channel1" : [
    ///     "publish",
    ///     "subscribe"
    ///   ]
    /// }
    public var capability: Capability
    /// The [client ID](https://www.ably.io/documentation/core-features/authentication#identified-clients) to be assosciated with the token. Can be set to * to allow for any client ID to be used.
    public var clientID: String?
    /// Name of the key used for the TokenRequest. The keyName comprises of the app ID and key ID on an API Key.
    ///
    /// Example: "xVLyHw.LMJZxw"
    public var keyName: String
    /// An unquoted, un-escaped random string of at least 16 characters. Used to ensure the Ably TokenRequest cannot be reused.
    public var nonce: String
    /// Time of creation of the Ably TokenRequest.
    public var timestamp: Int

    /// The [capabilities](https://www.ably.io/documentation/core-features/authentication#capabilities-explained) (i.e. a set of channel names/namespaces and, for each, a set of operations) which should be a subset of the set of capabilities associated with the key specified in keyName.
    ///
    /// Example:
    ///
    /// {
    ///   "channel1" : [
    ///     "publish",
    ///     "subscribe"
    ///   ]
    /// }
    public struct Capability: Codable {
        public init() {}
    }

    public init(capability: Capability, clientID: String? = nil, keyName: String, nonce: String, timestamp: Int) {
        self.capability = capability
        self.clientID = clientID
        self.keyName = keyName
        self.nonce = nonce
        self.timestamp = timestamp
    }

    private enum CodingKeys: String, CodingKey {
        case capability
        case clientID = "clientId"
        case keyName
        case nonce
        case timestamp
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
