// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import HTTPHeaders

extension Paths {
    public static var channels: Channels {
        Channels(path: "/channels")
    }

    public struct Channels {
        /// Path: `/channels`
        public let path: String

        /// Enumerate all active channels of the application
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public enum GetResponseHeaders {
            /// Links to related resources, in the format defined by [RFC 5988](https://tools.ietf.org/html/rfc5988#section-5). This will potentially include a link with relation type `next`, `first`, and `current`, where appropiate.
            public static let link = HTTPHeader<String>(field: "link")
        }

        public enum GetResponse: Decodable {
            case channelDetails([PlatformAPI.ChannelDetails])
            case strings([String])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode([PlatformAPI.ChannelDetails].self) {
                    self = .channelDetails(value)
                } else if let value = try? container.decode([String].self) {
                    self = .strings(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        public struct GetParameters {
            public var limit: Int?
            public var prefix: String?
            public var by: By?

            public enum By: String, Codable, CaseIterable {
                case value
                case id
            }

            public init(limit: Int? = nil, prefix: String? = nil, by: By? = nil) {
                self.limit = limit
                self.prefix = prefix
                self.by = by
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("limit", limit)
                query.addQueryItem("prefix", prefix)
                query.addQueryItem("by", by)
                return query
            }
        }
    }
}

extension Paths.Channels {
    public func channelID(_ channelID: String) -> WithChannelID {
        WithChannelID(path: "\(path)/\(channelID)")
    }

    public struct WithChannelID {
        /// Path: `/channels/{channel_id}`
        public let path: String

        /// Get metadata of a channel
        public var get: Request<PlatformAPI.ChannelDetails> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// The ID for the server communicated with.
            public static let ablyServerid = HTTPHeader<String>(field: "x-ably-serverid")
        }
    }
}

extension Paths.Channels.WithChannelID {
    public var messages: Messages {
        Messages(path: path + "/messages")
    }

    public struct Messages {
        /// Path: `/channels/{channel_id}/messages`
        public let path: String

        /// Get message history for a channel
        public func get(parameters: GetParameters? = nil) -> Request<[PlatformAPI.Message]> {
            .get(path, query: parameters?.asQuery)
        }

        public enum GetResponseHeaders {
            /// Links to related resources, in the format defined by [RFC 5988](https://tools.ietf.org/html/rfc5988#section-5). This will potentially include a link with relation type `next`, `first`, and `current`, where appropiate.
            public static let link = HTTPHeader<String>(field: "link")
            /// The ID for the server communicated with.
            public static let ablyServerid = HTTPHeader<String>(field: "x-ably-serverid")
        }

        public struct GetParameters {
            public var start: String?
            public var limit: Int?
            public var end: String?
            public var direction: Direction?

            public enum Direction: String, Codable, CaseIterable {
                case forwards
                case backwards
            }

            public init(start: String? = nil, limit: Int? = nil, end: String? = nil, direction: Direction? = nil) {
                self.start = start
                self.limit = limit
                self.end = end
                self.direction = direction
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("start", start)
                query.addQueryItem("limit", limit)
                query.addQueryItem("end", end)
                query.addQueryItem("direction", direction)
                return query
            }
        }

        /// Publish a message to a channel
        ///
        /// Publish a message to the specified channel
        public func post(_ body: PlatformAPI.Message? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// The ID for the server communicated with.
            public static let ablyServerid = HTTPHeader<String>(field: "x-ably-serverid")
        }

        public struct PostResponse: Decodable {
            public var channel: String?
            public var messageID: String?

            public init(channel: String? = nil, messageID: String? = nil) {
                self.channel = channel
                self.messageID = messageID
            }

            private enum CodingKeys: String, CodingKey {
                case channel
                case messageID = "messageId"
            }
        }
    }
}

extension Paths.Channels.WithChannelID {
    public var presence: Presence {
        Presence(path: path + "/presence")
    }

    public struct Presence {
        /// Path: `/channels/{channel_id}/presence`
        public let path: String

        /// Get presence of a channel
        ///
        /// Get presence on a channel
        public func get(parameters: GetParameters? = nil) -> Request<[PlatformAPI.PresenceMessage]> {
            .get(path, query: parameters?.asQuery)
        }

        public enum GetResponseHeaders {
            /// Links to related resources, in the format defined by [RFC 5988](https://tools.ietf.org/html/rfc5988#section-5). This will potentially include a link with relation type `next`, `first`, and `current`, where appropiate.
            public static let link = HTTPHeader<String>(field: "link")
            /// The ID for the server communicated with.
            public static let ablyServerid = HTTPHeader<String>(field: "x-ably-serverid")
        }

        public struct GetParameters {
            public var clientID: String?
            public var connectionID: String?
            public var limit: Int?

            public init(clientID: String? = nil, connectionID: String? = nil, limit: Int? = nil) {
                self.clientID = clientID
                self.connectionID = connectionID
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("clientId", clientID)
                query.addQueryItem("connectionId", connectionID)
                query.addQueryItem("limit", limit)
                return query
            }
        }
    }
}

extension Paths.Channels.WithChannelID.Presence {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/channels/{channel_id}/presence/history`
        public let path: String

        /// Get presence history of a channel
        ///
        /// Get presence on a channel
        public func get(parameters: GetParameters? = nil) -> Request<[PlatformAPI.PresenceMessage]> {
            .get(path, query: parameters?.asQuery)
        }

        public enum GetResponseHeaders {
            /// Links to related resources, in the format defined by [RFC 5988](https://tools.ietf.org/html/rfc5988#section-5). This will potentially include a link with relation type `next`, `first`, and `current`, where appropiate.
            public static let link = HTTPHeader<String>(field: "link")
        }

        public struct GetParameters {
            public var start: String?
            public var limit: Int?
            public var end: String?
            public var direction: Direction?

            public enum Direction: String, Codable, CaseIterable {
                case forwards
                case backwards
            }

            public init(start: String? = nil, limit: Int? = nil, end: String? = nil, direction: Direction? = nil) {
                self.start = start
                self.limit = limit
                self.end = end
                self.direction = direction
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("start", start)
                query.addQueryItem("limit", limit)
                query.addQueryItem("end", end)
                query.addQueryItem("direction", direction)
                return query
            }
        }
    }
}

extension Paths {
    public static var keys: Keys {
        Keys(path: "/keys")
    }

    public struct Keys {
        /// Path: `/keys`
        public let path: String
    }
}

extension Paths.Keys {
    public func keyName(_ keyName: String) -> WithKeyName {
        WithKeyName(path: "\(path)/\(keyName)")
    }

    public struct WithKeyName {
        /// Path: `/keys/{keyName}`
        public let path: String
    }
}

extension Paths.Keys.WithKeyName {
    public var requestToken: RequestToken {
        RequestToken(path: path + "/requestToken")
    }

    public struct RequestToken {
        /// Path: `/keys/{keyName}/requestToken`
        public let path: String

        /// Request an access token
        ///
        /// This is the means by which clients obtain access tokens to use the service. You can see how to construct an Ably TokenRequest in the [Ably TokenRequest spec](https://www.ably.io/documentation/rest-api/token-request-spec) documentation, although we recommend you use an Ably SDK rather to create a TokenRequest, as the construction of a TokenRequest is complex. The resulting token response object contains the token properties as defined in Ably TokenRequest spec. Authentication is not required if using a Signed TokenRequest.
        public func post(_ body: PostRequest? = nil) -> Request<PlatformAPI.TokenDetails> {
            .post(path, body: body)
        }

        public enum PostRequest: Encodable {
            case tokenRequest(PlatformAPI.TokenRequest)
            case signedTokenRequest(PlatformAPI.SignedTokenRequest)

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .tokenRequest(let value): try container.encode(value)
                case .signedTokenRequest(let value): try container.encode(value)
                }
            }
        }
    }
}

extension Paths {
    public static var push: Push {
        Push(path: "/push")
    }

    public struct Push {
        /// Path: `/push`
        public let path: String
    }
}

extension Paths.Push {
    public var channelSubscriptions: ChannelSubscriptions {
        ChannelSubscriptions(path: path + "/channelSubscriptions")
    }

    public struct ChannelSubscriptions {
        /// Path: `/push/channelSubscriptions`
        public let path: String

        /// List channel subscriptions
        ///
        /// Get a list of push notification subscriptions to channels.
        public func get(parameters: GetParameters? = nil) -> Request<PlatformAPI.DeviceDetails> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var channel: String?
            public var deviceID: String?
            public var clientID: String?
            public var limit: Int?

            public init(channel: String? = nil, deviceID: String? = nil, clientID: String? = nil, limit: Int? = nil) {
                self.channel = channel
                self.deviceID = deviceID
                self.clientID = clientID
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("channel", channel)
                query.addQueryItem("deviceId", deviceID)
                query.addQueryItem("clientId", clientID)
                query.addQueryItem("limit", limit)
                return query
            }
        }

        /// Subscribe a device to a channel
        ///
        /// Subscribe either a single device or all devices associated with a client ID to receive push notifications from messages sent to a channel.
        public func post(_ body: PostRequest? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        public enum PostRequest: Encodable {
            case a(A)
            case b(B)

            public struct A: Encodable {
                /// Channel name.
                public var channel: String?
                /// Must be set when clientId is empty, cannot be used with clientId.
                public var deviceID: String?

                public init(channel: String? = nil, deviceID: String? = nil) {
                    self.channel = channel
                    self.deviceID = deviceID
                }

                private enum CodingKeys: String, CodingKey {
                    case channel
                    case deviceID = "deviceId"
                }
            }

            public struct B: Encodable {
                /// Channel name.
                public var channel: String?
                /// Must be set when deviceId is empty, cannot be used with deviceId.
                public var clientID: String?

                public init(channel: String? = nil, clientID: String? = nil) {
                    self.channel = channel
                    self.clientID = clientID
                }

                private enum CodingKeys: String, CodingKey {
                    case channel
                    case clientID = "clientId"
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .a(let value): try container.encode(value)
                case .b(let value): try container.encode(value)
                }
            }
        }

        /// Delete a registered device's update token
        ///
        /// Delete a device details object.
        public func delete(parameters: DeleteParameters? = nil) -> Request<Void> {
            .delete(path, query: parameters?.asQuery)
        }

        public struct DeleteParameters {
            public var channel: String?
            public var deviceID: String?
            public var clientID: String?

            public init(channel: String? = nil, deviceID: String? = nil, clientID: String? = nil) {
                self.channel = channel
                self.deviceID = deviceID
                self.clientID = clientID
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("channel", channel)
                query.addQueryItem("deviceId", deviceID)
                query.addQueryItem("clientId", clientID)
                return query
            }
        }
    }
}

extension Paths.Push {
    public var channels: Channels {
        Channels(path: path + "/channels")
    }

    public struct Channels {
        /// Path: `/push/channels`
        public let path: String

        /// List all channels with at least one subscribed device
        ///
        /// Returns a paginated response of channel names.
        public var get: Request<[String]> {
            .get(path)
        }
    }
}

extension Paths.Push {
    public var deviceRegistrations: DeviceRegistrations {
        DeviceRegistrations(path: path + "/deviceRegistrations")
    }

    public struct DeviceRegistrations {
        /// Path: `/push/deviceRegistrations`
        public let path: String

        /// List devices registered for receiving push notifications
        ///
        /// List of device details of devices registed for push notifications.
        public func get(parameters: GetParameters? = nil) -> Request<PlatformAPI.DeviceDetails> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var deviceID: String?
            public var clientID: String?
            public var limit: Int?

            public init(deviceID: String? = nil, clientID: String? = nil, limit: Int? = nil) {
                self.deviceID = deviceID
                self.clientID = clientID
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("deviceId", deviceID)
                query.addQueryItem("clientId", clientID)
                query.addQueryItem("limit", limit)
                return query
            }
        }

        /// Register a device for receiving push notifications
        ///
        /// Register a deviceâ€™s details, including the information necessary to deliver push notifications to it. Requires "push-admin" capability.
        public func post(_ body: PlatformAPI.DeviceDetails? = nil) -> Request<PlatformAPI.DeviceDetails> {
            .post(path, body: body)
        }

        /// Unregister matching devices for push notifications
        ///
        /// Unregisters devices. All their subscriptions for receiving push notifications through channels will also be deleted.
        public func delete(deviceID: String? = nil, clientID: String? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(deviceID, clientID))
        }

        private func makeDeleteQuery(_ deviceID: String?, _ clientID: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("deviceId", deviceID)
            query.addQueryItem("clientId", clientID)
            return query
        }
    }
}

extension Paths.Push.DeviceRegistrations {
    public func deviceID(_ deviceID: String) -> WithDeviceID {
        WithDeviceID(path: "\(path)/\(deviceID)")
    }

    public struct WithDeviceID {
        /// Path: `/push/deviceRegistrations/{device_id}`
        public let path: String

        /// Get a device registration
        ///
        /// Get the full details of a device.
        public var get: Request<PlatformAPI.DeviceDetails> {
            .get(path)
        }

        /// Update a device registration
        ///
        /// Device registrations can be upserted (the existing registration is replaced entirely) with a PUT operation. Only clientId, metadata and push.recipient are mutable.
        public func put(_ body: PlatformAPI.DeviceDetails? = nil) -> Request<PlatformAPI.DeviceDetails> {
            .put(path, body: body)
        }

        /// Update a device registration
        ///
        /// Specific attributes of an existing registration can be updated. Only clientId, metadata and push.recipient are mutable.
        public func patch(_ body: PlatformAPI.DeviceDetails? = nil) -> Request<PlatformAPI.DeviceDetails> {
            .patch(path, body: body)
        }

        /// Unregister a single device for push notifications
        ///
        /// Unregisters a single device by its device ID. All its subscriptions for receiving push notifications through channels will also be deleted.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Push.DeviceRegistrations.WithDeviceID {
    public var resetUpdateToken: ResetUpdateToken {
        ResetUpdateToken(path: path + "/resetUpdateToken")
    }

    public struct ResetUpdateToken {
        /// Path: `/push/deviceRegistrations/{device_id}/resetUpdateToken`
        public let path: String

        /// Reset a registered device's update token
        ///
        /// Gets an updated device details object.
        public var get: Request<PlatformAPI.DeviceDetails> {
            .get(path)
        }
    }
}

extension Paths.Push {
    public var publish: Publish {
        Publish(path: path + "/publish")
    }

    public struct Publish {
        /// Path: `/push/publish`
        public let path: String

        /// Publish a push notification to device(s)
        ///
        /// A convenience endpoint to deliver a push notification payload to a single device or set of devices identified by their client identifier.
        public func post(_ body: PostRequest? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            public var push: PlatformAPI.Push?
            /// Push recipient details for a device.
            public var recipient: PlatformAPI.Recipient

            public init(push: PlatformAPI.Push? = nil, recipient: PlatformAPI.Recipient) {
                self.push = push
                self.recipient = recipient
            }
        }
    }
}

extension Paths {
    public static var stats: Stats {
        Stats(path: "/stats")
    }

    public struct Stats {
        /// Path: `/stats`
        public let path: String

        /// Retrieve usage statistics for an application
        ///
        /// The Ably system can be queried to obtain usage statistics for a given application, and results are provided aggregated across all channels in use in the application in the specified period. Stats may be used to track usage against account quotas.
        public func get(parameters: GetParameters? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var start: String?
            public var limit: Int?
            public var end: String?
            public var direction: Direction?
            public var unit: Unit?

            public enum Direction: String, Codable, CaseIterable {
                case forwards
                case backwards
            }

            public enum Unit: String, Codable, CaseIterable {
                case minute
                case hour
                case day
                case month
            }

            public init(start: String? = nil, limit: Int? = nil, end: String? = nil, direction: Direction? = nil, unit: Unit? = nil) {
                self.start = start
                self.limit = limit
                self.end = end
                self.direction = direction
                self.unit = unit
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("start", start)
                query.addQueryItem("limit", limit)
                query.addQueryItem("end", end)
                query.addQueryItem("direction", direction)
                query.addQueryItem("unit", unit)
                return query
            }
        }
    }
}

extension Paths {
    public static var time: Time {
        Time(path: "/time")
    }

    public struct Time {
        /// Path: `/time`
        public let path: String

        /// Get the service time
        ///
        /// This returns the service time in milliseconds since the epoch.
        public var get: Request<[Int]> {
            .get(path)
        }
    }
}

public enum Paths {}

protocol QueryEncodable {
    var asQueryValue: String { get }
}

extension Bool: QueryEncodable {
    var asQueryValue: String {
        self ? "true" : "false"
    }
}

extension Date: QueryEncodable {
    var asQueryValue: String {
        ISO8601DateFormatter().string(from: self)
    }
}

extension Double: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int32: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int64: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension String: QueryEncodable {
    var asQueryValue: String {
        self
    }
}

extension URL: QueryEncodable {
    var asQueryValue: String {
        absoluteString
    }
}

extension RawRepresentable where RawValue == String {
    var asQueryValue: String {
        rawValue
    }
}

extension Array where Element == (String, String?) {
    mutating func addQueryItem<T: RawRepresentable>(_ name: String, _ value: T?) where T.RawValue == String {
        addQueryItem(name, value?.rawValue)
    }
    
    mutating func addQueryItem(_ name: String, _ value: QueryEncodable?) {
        guard let value = value?.asQueryValue, !value.isEmpty else { return }
        append((name, value))
    }
    
    mutating func addDeepObject(_ name: String, _ query: [(String, String?)]) {
        for (key, value) in query {
            addQueryItem("\(name)[\(key)]", value)
        }
    }

    var asPercentEncodedQuery: String {
        var components = URLComponents()
        components.queryItems = self.map(URLQueryItem.init)
        return components.percentEncodedQuery ?? ""
    }
    
    // [("role", "admin"), ("name": "kean)] -> "role,admin,name,kean"
    var asCompactQuery: String {
        flatMap { [$0, $1] }.compactMap { $0 }.joined(separator: ",")
    }
}
