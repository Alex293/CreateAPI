// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var opensearch: Opensearch {
        Opensearch(path: "/2021-01-01/opensearch")
    }

    public struct Opensearch {
        /// Path: `/2021-01-01/opensearch`
        public let path: String
    }
}

extension Paths.Opensearch {
    public var cc: Cc {
        Cc(path: path + "/cc")
    }

    public struct Cc {
        /// Path: `/2021-01-01/opensearch/cc`
        public let path: String
    }
}

extension Paths.Opensearch.Cc {
    public var inboundConnection: InboundConnection {
        InboundConnection(path: path + "/inboundConnection")
    }

    public struct InboundConnection {
        /// Path: `/2021-01-01/opensearch/cc/inboundConnection`
        public let path: String
    }
}

extension Paths.Opensearch.Cc.InboundConnection.WithConnectionID {
    public var accept: Accept {
        Accept(path: path + "/accept")
    }

    public struct Accept {
        /// Path: `/2021-01-01/opensearch/cc/inboundConnection/{ConnectionId}/accept`
        public let path: String

        /// Allows the remote domain owner to accept an inbound cross-cluster connection request.
        public var put: Request<AmazonOpenSearchAPI.AcceptInboundConnectionResponse> {
            .put(path)
        }
    }
}

extension Paths {
    public static var tags: Tags {
        Tags(path: "/2021-01-01/tags")
    }

    public struct Tags {
        /// Path: `/2021-01-01/tags`
        public let path: String

        /// Attaches tags to an existing domain. Tags are a set of case-sensitive key value pairs. An domain can have up to 10 tags. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains.html#managedomains-awsresorcetagging" target="_blank"> Tagging Amazon OpenSearch Service domains</a> for more information.
        public func post(_ body: PostRequest) -> Request<Void> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The Amazon Resource Name (ARN) of the domain. See <a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/index.html" target="_blank">Identifiers for IAM Entities </a> in <i>Using AWS Identity and Access Management</i> for more information.
            public var arn: String
            /// A list of <code>Tag</code>.
            public var tagList: [AmazonOpenSearchAPI.Tag]

            public init(arn: String, tagList: [AmazonOpenSearchAPI.Tag]) {
                self.arn = arn
                self.tagList = tagList
            }

            private enum CodingKeys: String, CodingKey {
                case arn = "ARN"
                case tagList = "TagList"
            }
        }
    }
}

extension Paths.Packages {
    public var associate: Associate {
        Associate(path: path + "/associate")
    }

    public struct Associate {
        /// Path: `/2021-01-01/packages/associate`
        public let path: String
    }
}

extension Paths.Packages.Associate {
    public func packageID(_ packageID: String) -> WithPackageID {
        WithPackageID(path: "\(path)/\(packageID)")
    }

    public struct WithPackageID {
        /// Path: `/2021-01-01/packages/associate/{PackageID}`
        public let path: String
    }
}

extension Paths.Packages.Associate.WithPackageID {
    public func domainName(_ domainName: String) -> WithDomainName {
        WithDomainName(path: "\(path)/\(domainName)")
    }

    public struct WithDomainName {
        /// Path: `/2021-01-01/packages/associate/{PackageID}/{DomainName}`
        public let path: String

        /// Associates a package with an Amazon OpenSearch Service domain.
        public var post: Request<AmazonOpenSearchAPI.AssociatePackageResponse> {
            .post(path)
        }
    }
}

extension Paths.Opensearch {
    public var serviceSoftwareUpdate: ServiceSoftwareUpdate {
        ServiceSoftwareUpdate(path: path + "/serviceSoftwareUpdate")
    }

    public struct ServiceSoftwareUpdate {
        /// Path: `/2021-01-01/opensearch/serviceSoftwareUpdate`
        public let path: String
    }
}

extension Paths.Opensearch.ServiceSoftwareUpdate {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/2021-01-01/opensearch/serviceSoftwareUpdate/cancel`
        public let path: String

        /// Cancels a scheduled service software update for an Amazon OpenSearch Service domain. You can only perform this operation before the <code>AutomatedUpdateDate</code> and when the <code>UpdateStatus</code> is in the <code>PENDING_UPDATE</code> state.
        public func post(domainName: String) -> Request<AmazonOpenSearchAPI.CancelServiceSoftwareUpdateResponse> {
            .post(path, body: ["DomainName": domainName])
        }
    }
}

extension Paths.Opensearch {
    public var domain: Domain {
        Domain(path: path + "/domain")
    }

    public struct Domain {
        /// Path: `/2021-01-01/opensearch/domain`
        public let path: String

        /// Creates a new Amazon OpenSearch Service domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html" target="_blank">Creating and managing Amazon OpenSearch Service domains </a> in the <i>Amazon OpenSearch Service Developer Guide</i>.
        public func post(_ body: PostRequest) -> Request<AmazonOpenSearchAPI.CreateDomainResponse> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
            public var domainName: String
            /// String of format Elasticsearch_X.Y or OpenSearch_X.Y to specify the engine version for the Amazon OpenSearch Service domain. For example, "OpenSearch_1.0" or "Elasticsearch_7.9". For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomains" target="_blank">Creating and managing Amazon OpenSearch Service domains </a>.
            public var engineVersion: String?
            /// The configuration for the domain cluster, such as the type and number of instances.
            public var clusterConfig: ClusterConfig?
            /// Options to enable, disable, and specify the properties of EBS storage volumes.
            public var eBSOptions: EBSOptions?
            /// Access policy rules for a domain service endpoints. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-access-policies" target="_blank">Configuring access policies </a>. The maximum size of a policy document is 100 KB.
            public var accessPolicies: String?
            /// The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.
            public var snapshotOptions: SnapshotOptions?
            /// Options to specify the subnets and security groups for the VPC endpoint. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>.
            public var vPCOptions: VPCOptions?
            /// Options to specify the Cognito user and identity pools for OpenSearch Dashboards authentication. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>.
            public var cognitoOptions: CognitoOptions?
            /// Specifies encryption at rest options.
            public var encryptionAtRestOptions: EncryptionAtRestOptions?
            /// The node-to-node encryption options.
            public var nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions?
            /// <p>Exposes select native OpenSearch configuration values from <code>opensearch.yml</code>. Currently, the following advanced options are available: </p> <ul> <li>Option to allow references to indices in an HTTP request body. Must be <code>false</code> when configuring access to individual sub-resources. By default, the value is <code>true</code>. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced cluster parameters </a> for more information. </li> <li>Option to specify the percentage of heap space allocated to field data. By default, this setting is unbounded. </li> </ul> <p>For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options"> Advanced cluster parameters</a>. </p>
            public var advancedOptions: [String: String]?
            /// Map of <code>LogType</code> and <code>LogPublishingOption</code>, each containing options to publish a given type of OpenSearch log.
            public var logPublishingOptions: [String: AmazonOpenSearchAPI.LogPublishingOption]?
            /// Options to configure the endpoint for the domain.
            public var domainEndpointOptions: DomainEndpointOptions?
            /// The advanced security configuration: whether advanced security is enabled, whether the internal database option is enabled, master username and password (if internal database is enabled), and master user ARN (if IAM is enabled).
            public var advancedSecurityOptions: AdvancedSecurityOptions?
            /// A list of <code>Tag</code>.
            public var tagList: [AmazonOpenSearchAPI.Tag]?
            /// The Auto-Tune options: the Auto-Tune desired state for the domain and list of maintenance schedules.
            public var autoTuneOptions: AutoTuneOptions?

            /// The configuration for the domain cluster, such as the type and number of instances.
            public struct ClusterConfig: Encodable {
                public var instanceType: InstanceType?
                public var instanceCount: InstanceCount?
                public var dedicatedMasterEnabled: DedicatedMasterEnabled?
                public var zoneAwarenessEnabled: ZoneAwarenessEnabled?
                public var zoneAwarenessConfig: ZoneAwarenessConfig?
                public var dedicatedMasterType: DedicatedMasterType?
                public var dedicatedMasterCount: DedicatedMasterCount?
                public var warmEnabled: WarmEnabled?
                public var warmType: WarmType?
                public var warmCount: WarmCount?
                public var coldStorageOptions: ColdStorageOptions?

                public struct InstanceType: Encodable {
                    public var openSearchPartitionInstanceType: AmazonOpenSearchAPI.OpenSearchPartitionInstanceType
                    /// The instance type for an OpenSearch cluster. UltraWarm instance types are not supported for data instances.
                    public var anyJSON: AnyJSON

                    public init(openSearchPartitionInstanceType: AmazonOpenSearchAPI.OpenSearchPartitionInstanceType, anyJSON: AnyJSON) {
                        self.openSearchPartitionInstanceType = openSearchPartitionInstanceType
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(openSearchPartitionInstanceType, forKey: "openSearchPartitionInstanceType")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct InstanceCount: Encodable {
                    public var int: Int
                    /// The number of instances in the specified domain cluster.
                    public var anyJSON: AnyJSON

                    public init(int: Int, anyJSON: AnyJSON) {
                        self.int = int
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(int, forKey: "int")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct DedicatedMasterEnabled: Encodable {
                    public var isBool: Bool
                    /// A boolean value to indicate whether a dedicated master node is enabled. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains.html#managedomains-dedicatedmasternodes" target="_blank">Dedicated master nodes in Amazon OpenSearch Service </a> for more information.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct ZoneAwarenessEnabled: Encodable {
                    public var isBool: Bool
                    /// A boolean value to indicate whether zone awareness is enabled. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html" target="_blank">Configuring a multi-AZ domain in Amazon OpenSearch Service </a> for more information.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct ZoneAwarenessConfig: Encodable {
                    /// The zone awareness configuration for the domain cluster, such as the number of availability zones.
                    public var zoneAwarenessConfig: AmazonOpenSearchAPI.ZoneAwarenessConfig
                    /// The zone awareness configuration for a domain when zone awareness is enabled.
                    public var anyJSON: AnyJSON

                    public init(zoneAwarenessConfig: AmazonOpenSearchAPI.ZoneAwarenessConfig, anyJSON: AnyJSON) {
                        self.zoneAwarenessConfig = zoneAwarenessConfig
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(zoneAwarenessConfig, forKey: "zoneAwarenessConfig")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct DedicatedMasterType: Encodable {
                    public var openSearchPartitionInstanceType: AmazonOpenSearchAPI.OpenSearchPartitionInstanceType
                    /// The instance type for a dedicated master node.
                    public var anyJSON: AnyJSON

                    public init(openSearchPartitionInstanceType: AmazonOpenSearchAPI.OpenSearchPartitionInstanceType, anyJSON: AnyJSON) {
                        self.openSearchPartitionInstanceType = openSearchPartitionInstanceType
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(openSearchPartitionInstanceType, forKey: "openSearchPartitionInstanceType")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct DedicatedMasterCount: Encodable {
                    public var int: Int
                    /// Total number of dedicated master nodes, active and on standby, for the cluster.
                    public var anyJSON: AnyJSON

                    public init(int: Int, anyJSON: AnyJSON) {
                        self.int = int
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(int, forKey: "int")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct WarmEnabled: Encodable {
                    public var isBool: Bool
                    /// True to enable UltraWarm storage.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct WarmType: Encodable {
                    public var openSearchWarmPartitionInstanceType: AmazonOpenSearchAPI.OpenSearchWarmPartitionInstanceType
                    /// The instance type for the OpenSearch cluster's warm nodes.
                    public var anyJSON: AnyJSON

                    public init(openSearchWarmPartitionInstanceType: AmazonOpenSearchAPI.OpenSearchWarmPartitionInstanceType, anyJSON: AnyJSON) {
                        self.openSearchWarmPartitionInstanceType = openSearchWarmPartitionInstanceType
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(openSearchWarmPartitionInstanceType, forKey: "openSearchWarmPartitionInstanceType")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct WarmCount: Encodable {
                    public var int: Int
                    /// The number of UltraWarm nodes in the cluster.
                    public var anyJSON: AnyJSON

                    public init(int: Int, anyJSON: AnyJSON) {
                        self.int = int
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(int, forKey: "int")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct ColdStorageOptions: Encodable {
                    /// Specifies the configuration for cold storage options such as enabled
                    public var coldStorageOptions: AmazonOpenSearchAPI.ColdStorageOptions
                    /// Specifies the <code>ColdStorageOptions</code> config for a Domain
                    public var anyJSON: AnyJSON

                    public init(coldStorageOptions: AmazonOpenSearchAPI.ColdStorageOptions, anyJSON: AnyJSON) {
                        self.coldStorageOptions = coldStorageOptions
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(coldStorageOptions, forKey: "coldStorageOptions")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(instanceType: InstanceType? = nil, instanceCount: InstanceCount? = nil, dedicatedMasterEnabled: DedicatedMasterEnabled? = nil, zoneAwarenessEnabled: ZoneAwarenessEnabled? = nil, zoneAwarenessConfig: ZoneAwarenessConfig? = nil, dedicatedMasterType: DedicatedMasterType? = nil, dedicatedMasterCount: DedicatedMasterCount? = nil, warmEnabled: WarmEnabled? = nil, warmType: WarmType? = nil, warmCount: WarmCount? = nil, coldStorageOptions: ColdStorageOptions? = nil) {
                    self.instanceType = instanceType
                    self.instanceCount = instanceCount
                    self.dedicatedMasterEnabled = dedicatedMasterEnabled
                    self.zoneAwarenessEnabled = zoneAwarenessEnabled
                    self.zoneAwarenessConfig = zoneAwarenessConfig
                    self.dedicatedMasterType = dedicatedMasterType
                    self.dedicatedMasterCount = dedicatedMasterCount
                    self.warmEnabled = warmEnabled
                    self.warmType = warmType
                    self.warmCount = warmCount
                    self.coldStorageOptions = coldStorageOptions
                }

                private enum CodingKeys: String, CodingKey {
                    case instanceType = "InstanceType"
                    case instanceCount = "InstanceCount"
                    case dedicatedMasterEnabled = "DedicatedMasterEnabled"
                    case zoneAwarenessEnabled = "ZoneAwarenessEnabled"
                    case zoneAwarenessConfig = "ZoneAwarenessConfig"
                    case dedicatedMasterType = "DedicatedMasterType"
                    case dedicatedMasterCount = "DedicatedMasterCount"
                    case warmEnabled = "WarmEnabled"
                    case warmType = "WarmType"
                    case warmCount = "WarmCount"
                    case coldStorageOptions = "ColdStorageOptions"
                }
            }

            /// Options to enable, disable, and specify the properties of EBS storage volumes.
            public struct EBSOptions: Encodable {
                public var eBSEnabled: EBSEnabled?
                public var volumeType: VolumeType?
                public var volumeSize: VolumeSize?
                public var iops: Iops?

                public struct EBSEnabled: Encodable {
                    public var isBool: Bool
                    /// Whether EBS-based storage is enabled.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct VolumeType: Encodable {
                    /// The type of EBS volume, standard, gp2, or io1. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/opensearch-createupdatedomains.html#opensearch-createdomain-configure-ebs" target="_blank">Configuring EBS-based Storage</a> for more information.
                    public var volumeType: AmazonOpenSearchAPI.VolumeType
                    /// The volume type for EBS-based storage.
                    public var anyJSON: AnyJSON

                    public init(volumeType: AmazonOpenSearchAPI.VolumeType, anyJSON: AnyJSON) {
                        self.volumeType = volumeType
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(volumeType, forKey: "volumeType")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct VolumeSize: Encodable {
                    public var int: Int
                    /// Integer to specify the size of an EBS volume.
                    public var anyJSON: AnyJSON

                    public init(int: Int, anyJSON: AnyJSON) {
                        self.int = int
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(int, forKey: "int")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct Iops: Encodable {
                    public var int: Int
                    /// The IOPD for a Provisioned IOPS EBS volume (SSD).
                    public var anyJSON: AnyJSON

                    public init(int: Int, anyJSON: AnyJSON) {
                        self.int = int
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(int, forKey: "int")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(eBSEnabled: EBSEnabled? = nil, volumeType: VolumeType? = nil, volumeSize: VolumeSize? = nil, iops: Iops? = nil) {
                    self.eBSEnabled = eBSEnabled
                    self.volumeType = volumeType
                    self.volumeSize = volumeSize
                    self.iops = iops
                }

                private enum CodingKeys: String, CodingKey {
                    case eBSEnabled = "EBSEnabled"
                    case volumeType = "VolumeType"
                    case volumeSize = "VolumeSize"
                    case iops = "Iops"
                }
            }

            /// The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.
            public struct SnapshotOptions: Encodable {
                public var automatedSnapshotStartHour: AutomatedSnapshotStartHour?

                public struct AutomatedSnapshotStartHour: Encodable {
                    public var int: Int
                    /// The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.
                    public var anyJSON: AnyJSON

                    public init(int: Int, anyJSON: AnyJSON) {
                        self.int = int
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(int, forKey: "int")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(automatedSnapshotStartHour: AutomatedSnapshotStartHour? = nil) {
                    self.automatedSnapshotStartHour = automatedSnapshotStartHour
                }

                private enum CodingKeys: String, CodingKey {
                    case automatedSnapshotStartHour = "AutomatedSnapshotStartHour"
                }
            }

            /// Options to specify the subnets and security groups for the VPC endpoint. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>.
            public struct VPCOptions: Encodable {
                public var subnetIDs: SubnetIDs?
                public var securityGroupIDs: SecurityGroupIDs?

                public struct SubnetIDs: Encodable {
                    public var strings: [String]
                    /// The subnets for the VPC endpoint.
                    public var anyJSON: AnyJSON

                    public init(strings: [String], anyJSON: AnyJSON) {
                        self.strings = strings
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(strings, forKey: "strings")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct SecurityGroupIDs: Encodable {
                    public var strings: [String]
                    /// The security groups for the VPC endpoint.
                    public var anyJSON: AnyJSON

                    public init(strings: [String], anyJSON: AnyJSON) {
                        self.strings = strings
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(strings, forKey: "strings")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(subnetIDs: SubnetIDs? = nil, securityGroupIDs: SecurityGroupIDs? = nil) {
                    self.subnetIDs = subnetIDs
                    self.securityGroupIDs = securityGroupIDs
                }

                private enum CodingKeys: String, CodingKey {
                    case subnetIDs = "SubnetIds"
                    case securityGroupIDs = "SecurityGroupIds"
                }
            }

            /// Options to specify the Cognito user and identity pools for OpenSearch Dashboards authentication. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>.
            public struct CognitoOptions: Encodable {
                public var enabled: Enabled?
                public var userPoolID: UserPoolID?
                public var identityPoolID: IdentityPoolId?
                public var roleArn: RoleArn?

                public struct Enabled: Encodable {
                    public var isBool: Bool
                    /// The option to enable Cognito for OpenSearch Dashboards authentication.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct UserPoolID: Encodable {
                    public var userPoolID: AmazonOpenSearchAPI.UserPoolID
                    /// The Cognito user pool ID for OpenSearch Dashboards authentication.
                    public var anyJSON: AnyJSON

                    public init(userPoolID: AmazonOpenSearchAPI.UserPoolID, anyJSON: AnyJSON) {
                        self.userPoolID = userPoolID
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(userPoolID, forKey: "userPoolID")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct IdentityPoolId: Encodable {
                    public var identityPoolID: AmazonOpenSearchAPI.IdentityPoolId
                    /// The Cognito identity pool ID for OpenSearch Dashboards authentication.
                    public var anyJSON: AnyJSON

                    public init(identityPoolID: AmazonOpenSearchAPI.IdentityPoolId, anyJSON: AnyJSON) {
                        self.identityPoolID = identityPoolID
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(identityPoolID, forKey: "identityPoolID")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct RoleArn: Encodable {
                    public var roleArn: AmazonOpenSearchAPI.RoleArn
                    /// The role ARN that provides OpenSearch permissions for accessing Cognito resources.
                    public var anyJSON: AnyJSON

                    public init(roleArn: AmazonOpenSearchAPI.RoleArn, anyJSON: AnyJSON) {
                        self.roleArn = roleArn
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(roleArn, forKey: "roleArn")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(enabled: Enabled? = nil, userPoolID: UserPoolID? = nil, identityPoolID: IdentityPoolId? = nil, roleArn: RoleArn? = nil) {
                    self.enabled = enabled
                    self.userPoolID = userPoolID
                    self.identityPoolID = identityPoolID
                    self.roleArn = roleArn
                }

                private enum CodingKeys: String, CodingKey {
                    case enabled = "Enabled"
                    case userPoolID = "UserPoolId"
                    case identityPoolID = "IdentityPoolId"
                    case roleArn = "RoleArn"
                }
            }

            /// Specifies encryption at rest options.
            public struct EncryptionAtRestOptions: Encodable {
                public var enabled: Enabled?
                public var kmsKeyID: KmsKeyID?

                public struct Enabled: Encodable {
                    public var isBool: Bool
                    /// The option to enable encryption at rest.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct KmsKeyID: Encodable {
                    public var kmsKeyID: AmazonOpenSearchAPI.KmsKeyID
                    /// The KMS key ID for encryption at rest options.
                    public var anyJSON: AnyJSON

                    public init(kmsKeyID: AmazonOpenSearchAPI.KmsKeyID, anyJSON: AnyJSON) {
                        self.kmsKeyID = kmsKeyID
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(kmsKeyID, forKey: "kmsKeyID")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(enabled: Enabled? = nil, kmsKeyID: KmsKeyID? = nil) {
                    self.enabled = enabled
                    self.kmsKeyID = kmsKeyID
                }

                private enum CodingKeys: String, CodingKey {
                    case enabled = "Enabled"
                    case kmsKeyID = "KmsKeyId"
                }
            }

            /// The node-to-node encryption options.
            public struct NodeToNodeEncryptionOptions: Encodable {
                public var enabled: Enabled?

                public struct Enabled: Encodable {
                    public var isBool: Bool
                    /// True to enable node-to-node encryption.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(enabled: Enabled? = nil) {
                    self.enabled = enabled
                }

                private enum CodingKeys: String, CodingKey {
                    case enabled = "Enabled"
                }
            }

            /// Options to configure the endpoint for the domain.
            public struct DomainEndpointOptions: Encodable {
                public var enforceHTTPS: EnforceHTTPS?
                public var tlsSecurityPolicy: TLSSecurityPolicy?
                public var customEndpointEnabled: CustomEndpointEnabled?
                public var customEndpoint: CustomEndpoint?
                public var customEndpointCertificateArn: CustomEndpointCertificateArn?

                public struct EnforceHTTPS: Encodable {
                    public var isBool: Bool
                    /// Whether only HTTPS endpoint should be enabled for the domain.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct TLSSecurityPolicy: Encodable {
                    public var tlsSecurityPolicy: AmazonOpenSearchAPI.TLSSecurityPolicy
                    /// Specify the TLS security policy to apply to the HTTPS endpoint of the domain. <br/> Can be one of the following values: <ul> <li> <b>Policy-Min-TLS-1-0-2019-07:</b> TLS security policy which supports TLSv1.0 and higher. </li> <li> <b>Policy-Min-TLS-1-2-2019-07:</b> TLS security policy which supports only TLSv1.2 </li> </ul>
                    public var anyJSON: AnyJSON

                    public init(tlsSecurityPolicy: AmazonOpenSearchAPI.TLSSecurityPolicy, anyJSON: AnyJSON) {
                        self.tlsSecurityPolicy = tlsSecurityPolicy
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(tlsSecurityPolicy, forKey: "tlsSecurityPolicy")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct CustomEndpointEnabled: Encodable {
                    public var isBool: Bool
                    /// Whether to enable a custom endpoint for the domain.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct CustomEndpoint: Encodable {
                    public var string: String
                    /// The fully qualified domain for your custom endpoint.
                    public var anyJSON: AnyJSON

                    public init(string: String, anyJSON: AnyJSON) {
                        self.string = string
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(string, forKey: "string")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct CustomEndpointCertificateArn: Encodable {
                    /// The Amazon Resource Name (ARN) of the domain. See <a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/index.html" target="_blank">Identifiers for IAM Entities </a> in <i>Using AWS Identity and Access Management</i> for more information.
                    public var string: String
                    /// The ACM certificate ARN for your custom endpoint.
                    public var anyJSON: AnyJSON

                    public init(string: String, anyJSON: AnyJSON) {
                        self.string = string
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(string, forKey: "string")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(enforceHTTPS: EnforceHTTPS? = nil, tlsSecurityPolicy: TLSSecurityPolicy? = nil, customEndpointEnabled: CustomEndpointEnabled? = nil, customEndpoint: CustomEndpoint? = nil, customEndpointCertificateArn: CustomEndpointCertificateArn? = nil) {
                    self.enforceHTTPS = enforceHTTPS
                    self.tlsSecurityPolicy = tlsSecurityPolicy
                    self.customEndpointEnabled = customEndpointEnabled
                    self.customEndpoint = customEndpoint
                    self.customEndpointCertificateArn = customEndpointCertificateArn
                }

                private enum CodingKeys: String, CodingKey {
                    case enforceHTTPS = "EnforceHTTPS"
                    case tlsSecurityPolicy = "TLSSecurityPolicy"
                    case customEndpointEnabled = "CustomEndpointEnabled"
                    case customEndpoint = "CustomEndpoint"
                    case customEndpointCertificateArn = "CustomEndpointCertificateArn"
                }
            }

            /// The advanced security configuration: whether advanced security is enabled, whether the internal database option is enabled, master username and password (if internal database is enabled), and master user ARN (if IAM is enabled).
            public struct AdvancedSecurityOptions: Encodable {
                public var enabled: Enabled?
                public var internalUserDatabaseEnabled: InternalUserDatabaseEnabled?
                public var masterUserOptions: MasterUserOptions?
                public var sAMLOptions: SAMLOptions?

                public struct Enabled: Encodable {
                    public var isBool: Bool
                    /// True if advanced security is enabled.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct InternalUserDatabaseEnabled: Encodable {
                    public var isBool: Bool
                    /// True if the internal user database is enabled.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct MasterUserOptions: Encodable {
                    /// Credentials for the master user: username and password, ARN, or both.
                    public var masterUserOptions: AmazonOpenSearchAPI.MasterUserOptions
                    /// Credentials for the master user: username and password, ARN, or both.
                    public var anyJSON: AnyJSON

                    public init(masterUserOptions: AmazonOpenSearchAPI.MasterUserOptions, anyJSON: AnyJSON) {
                        self.masterUserOptions = masterUserOptions
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(masterUserOptions, forKey: "masterUserOptions")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct SAMLOptions: Encodable {
                    /// The SAML application configuration for the domain.
                    public var sAMLOptionsInput: AmazonOpenSearchAPI.SAMLOptionsInput
                    /// The SAML application configuration for the domain.
                    public var anyJSON: AnyJSON

                    public init(sAMLOptionsInput: AmazonOpenSearchAPI.SAMLOptionsInput, anyJSON: AnyJSON) {
                        self.sAMLOptionsInput = sAMLOptionsInput
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(sAMLOptionsInput, forKey: "sAMLOptionsInput")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(enabled: Enabled? = nil, internalUserDatabaseEnabled: InternalUserDatabaseEnabled? = nil, masterUserOptions: MasterUserOptions? = nil, sAMLOptions: SAMLOptions? = nil) {
                    self.enabled = enabled
                    self.internalUserDatabaseEnabled = internalUserDatabaseEnabled
                    self.masterUserOptions = masterUserOptions
                    self.sAMLOptions = sAMLOptions
                }

                private enum CodingKeys: String, CodingKey {
                    case enabled = "Enabled"
                    case internalUserDatabaseEnabled = "InternalUserDatabaseEnabled"
                    case masterUserOptions = "MasterUserOptions"
                    case sAMLOptions = "SAMLOptions"
                }
            }

            /// The Auto-Tune options: the Auto-Tune desired state for the domain and list of maintenance schedules.
            public struct AutoTuneOptions: Encodable {
                public var desiredState: DesiredState?
                public var maintenanceSchedules: MaintenanceSchedules?

                public struct DesiredState: Encodable {
                    /// The Auto-Tune desired state. Valid values are ENABLED and DISABLED.
                    public var autoTuneDesiredState: AmazonOpenSearchAPI.AutoTuneDesiredState
                    /// The Auto-Tune desired state. Valid values are ENABLED and DISABLED.
                    public var anyJSON: AnyJSON

                    public init(autoTuneDesiredState: AmazonOpenSearchAPI.AutoTuneDesiredState, anyJSON: AnyJSON) {
                        self.autoTuneDesiredState = autoTuneDesiredState
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(autoTuneDesiredState, forKey: "autoTuneDesiredState")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct MaintenanceSchedules: Encodable {
                    public var autoTuneMaintenanceSchedules: [AmazonOpenSearchAPI.AutoTuneMaintenanceSchedule]
                    /// A list of maintenance schedules. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
                    public var anyJSON: AnyJSON

                    public init(autoTuneMaintenanceSchedules: [AmazonOpenSearchAPI.AutoTuneMaintenanceSchedule], anyJSON: AnyJSON) {
                        self.autoTuneMaintenanceSchedules = autoTuneMaintenanceSchedules
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(autoTuneMaintenanceSchedules, forKey: "autoTuneMaintenanceSchedules")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(desiredState: DesiredState? = nil, maintenanceSchedules: MaintenanceSchedules? = nil) {
                    self.desiredState = desiredState
                    self.maintenanceSchedules = maintenanceSchedules
                }

                private enum CodingKeys: String, CodingKey {
                    case desiredState = "DesiredState"
                    case maintenanceSchedules = "MaintenanceSchedules"
                }
            }

            public init(domainName: String, engineVersion: String? = nil, clusterConfig: ClusterConfig? = nil, eBSOptions: EBSOptions? = nil, accessPolicies: String? = nil, snapshotOptions: SnapshotOptions? = nil, vPCOptions: VPCOptions? = nil, cognitoOptions: CognitoOptions? = nil, encryptionAtRestOptions: EncryptionAtRestOptions? = nil, nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions? = nil, advancedOptions: [String: String]? = nil, logPublishingOptions: [String: AmazonOpenSearchAPI.LogPublishingOption]? = nil, domainEndpointOptions: DomainEndpointOptions? = nil, advancedSecurityOptions: AdvancedSecurityOptions? = nil, tagList: [AmazonOpenSearchAPI.Tag]? = nil, autoTuneOptions: AutoTuneOptions? = nil) {
                self.domainName = domainName
                self.engineVersion = engineVersion
                self.clusterConfig = clusterConfig
                self.eBSOptions = eBSOptions
                self.accessPolicies = accessPolicies
                self.snapshotOptions = snapshotOptions
                self.vPCOptions = vPCOptions
                self.cognitoOptions = cognitoOptions
                self.encryptionAtRestOptions = encryptionAtRestOptions
                self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
                self.advancedOptions = advancedOptions
                self.logPublishingOptions = logPublishingOptions
                self.domainEndpointOptions = domainEndpointOptions
                self.advancedSecurityOptions = advancedSecurityOptions
                self.tagList = tagList
                self.autoTuneOptions = autoTuneOptions
            }

            private enum CodingKeys: String, CodingKey {
                case domainName = "DomainName"
                case engineVersion = "EngineVersion"
                case clusterConfig = "ClusterConfig"
                case eBSOptions = "EBSOptions"
                case accessPolicies = "AccessPolicies"
                case snapshotOptions = "SnapshotOptions"
                case vPCOptions = "VPCOptions"
                case cognitoOptions = "CognitoOptions"
                case encryptionAtRestOptions = "EncryptionAtRestOptions"
                case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
                case advancedOptions = "AdvancedOptions"
                case logPublishingOptions = "LogPublishingOptions"
                case domainEndpointOptions = "DomainEndpointOptions"
                case advancedSecurityOptions = "AdvancedSecurityOptions"
                case tagList = "TagList"
                case autoTuneOptions = "AutoTuneOptions"
            }
        }
    }
}

extension Paths.Opensearch.Cc {
    public var outboundConnection: OutboundConnection {
        OutboundConnection(path: path + "/outboundConnection")
    }

    public struct OutboundConnection {
        /// Path: `/2021-01-01/opensearch/cc/outboundConnection`
        public let path: String

        /// Creates a new cross-cluster connection from a local OpenSearch domain to a remote OpenSearch domain.
        public func post(_ body: PostRequest) -> Request<AmazonOpenSearchAPI.CreateOutboundConnectionResponse> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The <code> <a>AWSDomainInformation</a> </code> for the local OpenSearch domain.
            public var localDomainInfo: LocalDomainInfo
            /// The <code> <a>AWSDomainInformation</a> </code> for the remote OpenSearch domain.
            public var remoteDomainInfo: RemoteDomainInfo
            /// The connection alias used used by the customer for this cross-cluster connection.
            public var connectionAlias: String

            /// The <code> <a>AWSDomainInformation</a> </code> for the local OpenSearch domain.
            public struct LocalDomainInfo: Encodable {
                public var aWSDomainInformation: AmazonOpenSearchAPI.AWSDomainInformation?

                public init(aWSDomainInformation: AmazonOpenSearchAPI.AWSDomainInformation? = nil) {
                    self.aWSDomainInformation = aWSDomainInformation
                }

                private enum CodingKeys: String, CodingKey {
                    case aWSDomainInformation = "AWSDomainInformation"
                }
            }

            /// The <code> <a>AWSDomainInformation</a> </code> for the remote OpenSearch domain.
            public struct RemoteDomainInfo: Encodable {
                public var aWSDomainInformation: AmazonOpenSearchAPI.AWSDomainInformation?

                public init(aWSDomainInformation: AmazonOpenSearchAPI.AWSDomainInformation? = nil) {
                    self.aWSDomainInformation = aWSDomainInformation
                }

                private enum CodingKeys: String, CodingKey {
                    case aWSDomainInformation = "AWSDomainInformation"
                }
            }

            public init(localDomainInfo: LocalDomainInfo, remoteDomainInfo: RemoteDomainInfo, connectionAlias: String) {
                self.localDomainInfo = localDomainInfo
                self.remoteDomainInfo = remoteDomainInfo
                self.connectionAlias = connectionAlias
            }

            private enum CodingKeys: String, CodingKey {
                case localDomainInfo = "LocalDomainInfo"
                case remoteDomainInfo = "RemoteDomainInfo"
                case connectionAlias = "ConnectionAlias"
            }
        }
    }
}

extension Paths {
    public static var packages: Packages {
        Packages(path: "/2021-01-01/packages")
    }

    public struct Packages {
        /// Path: `/2021-01-01/packages`
        public let path: String

        /// Create a package for use with Amazon OpenSearch Service domains.
        public func post(_ body: PostRequest) -> Request<AmazonOpenSearchAPI.CreatePackageResponse> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Unique identifier for the package.
            public var packageName: String
            /// Type of package. Currently supports only TXT-DICTIONARY.
            public var packageType: PackageType
            /// Description of the package.
            public var packageDescription: String?
            /// The Amazon S3 location for importing the package specified as <code>S3BucketName</code> and <code>S3Key</code>
            public var packageSource: PackageSource

            /// Type of package. Currently supports only TXT-DICTIONARY.
            public enum PackageType: String, Codable, CaseIterable {
                case txtDictionary = "TXT-DICTIONARY"
            }

            /// The Amazon S3 location for importing the package specified as <code>S3BucketName</code> and <code>S3Key</code>
            public struct PackageSource: Encodable {
                public var s3BucketName: S3BucketName?
                public var s3Key: S3Key?

                public struct S3BucketName: Encodable {
                    public var s3BucketName: AmazonOpenSearchAPI.S3BucketName
                    /// The name of the Amazon S3 bucket containing the package.
                    public var anyJSON: AnyJSON

                    public init(s3BucketName: AmazonOpenSearchAPI.S3BucketName, anyJSON: AnyJSON) {
                        self.s3BucketName = s3BucketName
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(s3BucketName, forKey: "s3BucketName")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct S3Key: Encodable {
                    public var s3Key: AmazonOpenSearchAPI.S3Key
                    /// Key (file name) of the package.
                    public var anyJSON: AnyJSON

                    public init(s3Key: AmazonOpenSearchAPI.S3Key, anyJSON: AnyJSON) {
                        self.s3Key = s3Key
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(s3Key, forKey: "s3Key")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(s3BucketName: S3BucketName? = nil, s3Key: S3Key? = nil) {
                    self.s3BucketName = s3BucketName
                    self.s3Key = s3Key
                }

                private enum CodingKeys: String, CodingKey {
                    case s3BucketName = "S3BucketName"
                    case s3Key = "S3Key"
                }
            }

            public init(packageName: String, packageType: PackageType, packageDescription: String? = nil, packageSource: PackageSource) {
                self.packageName = packageName
                self.packageType = packageType
                self.packageDescription = packageDescription
                self.packageSource = packageSource
            }

            private enum CodingKeys: String, CodingKey {
                case packageName = "PackageName"
                case packageType = "PackageType"
                case packageDescription = "PackageDescription"
                case packageSource = "PackageSource"
            }
        }
    }
}

extension Paths.Opensearch.Domain {
    public func domainName(_ domainName: String) -> WithDomainName {
        WithDomainName(path: "\(path)/\(domainName)")
    }

    public struct WithDomainName {
        /// Path: `/2021-01-01/opensearch/domain/{DomainName}`
        public let path: String

        /// Returns domain configuration information about the specified domain, including the domain ID, domain endpoint, and domain ARN.
        public var get: Request<AmazonOpenSearchAPI.DescribeDomainResponse> {
            .get(path)
        }

        /// Permanently deletes the specified domain and all of its data. Once a domain is deleted, it cannot be recovered.
        public var delete: Request<AmazonOpenSearchAPI.DeleteDomainResponse> {
            .delete(path)
        }
    }
}

extension Paths.Opensearch.Cc.InboundConnection {
    public func connectionID(_ connectionID: String) -> WithConnectionID {
        WithConnectionID(path: "\(path)/\(connectionID)")
    }

    public struct WithConnectionID {
        /// Path: `/2021-01-01/opensearch/cc/inboundConnection/{ConnectionId}`
        public let path: String

        /// Allows the remote domain owner to delete an existing inbound cross-cluster connection.
        public var delete: Request<AmazonOpenSearchAPI.DeleteInboundConnectionResponse> {
            .delete(path)
        }
    }
}

extension Paths.Opensearch.Cc.OutboundConnection {
    public func connectionID(_ connectionID: String) -> WithConnectionID {
        WithConnectionID(path: "\(path)/\(connectionID)")
    }

    public struct WithConnectionID {
        /// Path: `/2021-01-01/opensearch/cc/outboundConnection/{ConnectionId}`
        public let path: String

        /// Allows the local domain owner to delete an existing outbound cross-cluster connection.
        public var delete: Request<AmazonOpenSearchAPI.DeleteOutboundConnectionResponse> {
            .delete(path)
        }
    }
}

extension Paths.Packages {
    public func packageID(_ packageID: String) -> WithPackageID {
        WithPackageID(path: "\(path)/\(packageID)")
    }

    public struct WithPackageID {
        /// Path: `/2021-01-01/packages/{PackageID}`
        public let path: String

        /// Deletes the package.
        public var delete: Request<AmazonOpenSearchAPI.DeletePackageResponse> {
            .delete(path)
        }
    }
}

extension Paths.Opensearch.Domain.WithDomainName {
    public var autoTunes: AutoTunes {
        AutoTunes(path: path + "/autoTunes")
    }

    public struct AutoTunes {
        /// Path: `/2021-01-01/opensearch/domain/{DomainName}/autoTunes`
        public let path: String

        /// Provides scheduled Auto-Tune action details for the domain, such as Auto-Tune action type, description, severity, and scheduled date.
        public func get(maxResults: String? = nil, nextToken: String? = nil) -> Request<AmazonOpenSearchAPI.DescribeDomainAutoTunesResponse> {
            .get(path, query: makeGetQuery(maxResults, nextToken))
        }

        private func makeGetQuery(_ maxResults: String?, _ nextToken: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(maxResults, forKey: "MaxResults")
            encoder.encode(nextToken, forKey: "NextToken")
            return encoder.items
        }
    }
}

extension Paths.Opensearch.Domain.WithDomainName {
    public var config: Config {
        Config(path: path + "/config")
    }

    public struct Config {
        /// Path: `/2021-01-01/opensearch/domain/{DomainName}/config`
        public let path: String

        /// Provides cluster configuration information about the specified domain, such as the state, creation date, update version, and update date for cluster options.
        public var get: Request<AmazonOpenSearchAPI.DescribeDomainConfigResponse> {
            .get(path)
        }

        /// Modifies the cluster configuration of the specified domain, such as setting the instance type and the number of instances.
        public func post(_ body: PostRequest) -> Request<AmazonOpenSearchAPI.UpdateDomainConfigResponse> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The configuration for the domain cluster, such as the type and number of instances.
            public var clusterConfig: ClusterConfig?
            /// Options to enable, disable, and specify the properties of EBS storage volumes.
            public var eBSOptions: EBSOptions?
            /// The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.
            public var snapshotOptions: SnapshotOptions?
            /// Options to specify the subnets and security groups for the VPC endpoint. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>.
            public var vPCOptions: VPCOptions?
            /// Options to specify the Cognito user and identity pools for OpenSearch Dashboards authentication. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>.
            public var cognitoOptions: CognitoOptions?
            /// <p>Exposes select native OpenSearch configuration values from <code>opensearch.yml</code>. Currently, the following advanced options are available: </p> <ul> <li>Option to allow references to indices in an HTTP request body. Must be <code>false</code> when configuring access to individual sub-resources. By default, the value is <code>true</code>. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced cluster parameters </a> for more information. </li> <li>Option to specify the percentage of heap space allocated to field data. By default, this setting is unbounded. </li> </ul> <p>For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options"> Advanced cluster parameters</a>. </p>
            public var advancedOptions: [String: String]?
            /// Access policy rules for a domain service endpoints. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-access-policies" target="_blank">Configuring access policies </a>. The maximum size of a policy document is 100 KB.
            public var accessPolicies: String?
            /// Map of <code>LogType</code> and <code>LogPublishingOption</code>, each containing options to publish a given type of OpenSearch log.
            public var logPublishingOptions: [String: AmazonOpenSearchAPI.LogPublishingOption]?
            /// Specifies encryption at rest options.
            public var encryptionAtRestOptions: EncryptionAtRestOptions?
            /// Options to configure the endpoint for the domain.
            public var domainEndpointOptions: DomainEndpointOptions?
            /// The node-to-node encryption options.
            public var nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions?
            /// The advanced security configuration: whether advanced security is enabled, whether the internal database option is enabled, master username and password (if internal database is enabled), and master user ARN (if IAM is enabled).
            public var advancedSecurityOptions: AdvancedSecurityOptions?
            /// The Auto-Tune options: the Auto-Tune desired state for the domain, rollback state when disabling Auto-Tune options and list of maintenance schedules.
            public var autoTuneOptions: AutoTuneOptions?

            /// The configuration for the domain cluster, such as the type and number of instances.
            public struct ClusterConfig: Encodable {
                public var instanceType: InstanceType?
                public var instanceCount: InstanceCount?
                public var dedicatedMasterEnabled: DedicatedMasterEnabled?
                public var zoneAwarenessEnabled: ZoneAwarenessEnabled?
                public var zoneAwarenessConfig: ZoneAwarenessConfig?
                public var dedicatedMasterType: DedicatedMasterType?
                public var dedicatedMasterCount: DedicatedMasterCount?
                public var warmEnabled: WarmEnabled?
                public var warmType: WarmType?
                public var warmCount: WarmCount?
                public var coldStorageOptions: ColdStorageOptions?

                public struct InstanceType: Encodable {
                    public var openSearchPartitionInstanceType: AmazonOpenSearchAPI.OpenSearchPartitionInstanceType
                    /// The instance type for an OpenSearch cluster. UltraWarm instance types are not supported for data instances.
                    public var anyJSON: AnyJSON

                    public init(openSearchPartitionInstanceType: AmazonOpenSearchAPI.OpenSearchPartitionInstanceType, anyJSON: AnyJSON) {
                        self.openSearchPartitionInstanceType = openSearchPartitionInstanceType
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(openSearchPartitionInstanceType, forKey: "openSearchPartitionInstanceType")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct InstanceCount: Encodable {
                    public var int: Int
                    /// The number of instances in the specified domain cluster.
                    public var anyJSON: AnyJSON

                    public init(int: Int, anyJSON: AnyJSON) {
                        self.int = int
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(int, forKey: "int")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct DedicatedMasterEnabled: Encodable {
                    public var isBool: Bool
                    /// A boolean value to indicate whether a dedicated master node is enabled. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains.html#managedomains-dedicatedmasternodes" target="_blank">Dedicated master nodes in Amazon OpenSearch Service </a> for more information.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct ZoneAwarenessEnabled: Encodable {
                    public var isBool: Bool
                    /// A boolean value to indicate whether zone awareness is enabled. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html" target="_blank">Configuring a multi-AZ domain in Amazon OpenSearch Service </a> for more information.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct ZoneAwarenessConfig: Encodable {
                    /// The zone awareness configuration for the domain cluster, such as the number of availability zones.
                    public var zoneAwarenessConfig: AmazonOpenSearchAPI.ZoneAwarenessConfig
                    /// The zone awareness configuration for a domain when zone awareness is enabled.
                    public var anyJSON: AnyJSON

                    public init(zoneAwarenessConfig: AmazonOpenSearchAPI.ZoneAwarenessConfig, anyJSON: AnyJSON) {
                        self.zoneAwarenessConfig = zoneAwarenessConfig
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(zoneAwarenessConfig, forKey: "zoneAwarenessConfig")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct DedicatedMasterType: Encodable {
                    public var openSearchPartitionInstanceType: AmazonOpenSearchAPI.OpenSearchPartitionInstanceType
                    /// The instance type for a dedicated master node.
                    public var anyJSON: AnyJSON

                    public init(openSearchPartitionInstanceType: AmazonOpenSearchAPI.OpenSearchPartitionInstanceType, anyJSON: AnyJSON) {
                        self.openSearchPartitionInstanceType = openSearchPartitionInstanceType
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(openSearchPartitionInstanceType, forKey: "openSearchPartitionInstanceType")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct DedicatedMasterCount: Encodable {
                    public var int: Int
                    /// Total number of dedicated master nodes, active and on standby, for the cluster.
                    public var anyJSON: AnyJSON

                    public init(int: Int, anyJSON: AnyJSON) {
                        self.int = int
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(int, forKey: "int")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct WarmEnabled: Encodable {
                    public var isBool: Bool
                    /// True to enable UltraWarm storage.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct WarmType: Encodable {
                    public var openSearchWarmPartitionInstanceType: AmazonOpenSearchAPI.OpenSearchWarmPartitionInstanceType
                    /// The instance type for the OpenSearch cluster's warm nodes.
                    public var anyJSON: AnyJSON

                    public init(openSearchWarmPartitionInstanceType: AmazonOpenSearchAPI.OpenSearchWarmPartitionInstanceType, anyJSON: AnyJSON) {
                        self.openSearchWarmPartitionInstanceType = openSearchWarmPartitionInstanceType
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(openSearchWarmPartitionInstanceType, forKey: "openSearchWarmPartitionInstanceType")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct WarmCount: Encodable {
                    public var int: Int
                    /// The number of UltraWarm nodes in the cluster.
                    public var anyJSON: AnyJSON

                    public init(int: Int, anyJSON: AnyJSON) {
                        self.int = int
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(int, forKey: "int")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct ColdStorageOptions: Encodable {
                    /// Specifies the configuration for cold storage options such as enabled
                    public var coldStorageOptions: AmazonOpenSearchAPI.ColdStorageOptions
                    /// Specifies the <code>ColdStorageOptions</code> config for a Domain
                    public var anyJSON: AnyJSON

                    public init(coldStorageOptions: AmazonOpenSearchAPI.ColdStorageOptions, anyJSON: AnyJSON) {
                        self.coldStorageOptions = coldStorageOptions
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(coldStorageOptions, forKey: "coldStorageOptions")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(instanceType: InstanceType? = nil, instanceCount: InstanceCount? = nil, dedicatedMasterEnabled: DedicatedMasterEnabled? = nil, zoneAwarenessEnabled: ZoneAwarenessEnabled? = nil, zoneAwarenessConfig: ZoneAwarenessConfig? = nil, dedicatedMasterType: DedicatedMasterType? = nil, dedicatedMasterCount: DedicatedMasterCount? = nil, warmEnabled: WarmEnabled? = nil, warmType: WarmType? = nil, warmCount: WarmCount? = nil, coldStorageOptions: ColdStorageOptions? = nil) {
                    self.instanceType = instanceType
                    self.instanceCount = instanceCount
                    self.dedicatedMasterEnabled = dedicatedMasterEnabled
                    self.zoneAwarenessEnabled = zoneAwarenessEnabled
                    self.zoneAwarenessConfig = zoneAwarenessConfig
                    self.dedicatedMasterType = dedicatedMasterType
                    self.dedicatedMasterCount = dedicatedMasterCount
                    self.warmEnabled = warmEnabled
                    self.warmType = warmType
                    self.warmCount = warmCount
                    self.coldStorageOptions = coldStorageOptions
                }

                private enum CodingKeys: String, CodingKey {
                    case instanceType = "InstanceType"
                    case instanceCount = "InstanceCount"
                    case dedicatedMasterEnabled = "DedicatedMasterEnabled"
                    case zoneAwarenessEnabled = "ZoneAwarenessEnabled"
                    case zoneAwarenessConfig = "ZoneAwarenessConfig"
                    case dedicatedMasterType = "DedicatedMasterType"
                    case dedicatedMasterCount = "DedicatedMasterCount"
                    case warmEnabled = "WarmEnabled"
                    case warmType = "WarmType"
                    case warmCount = "WarmCount"
                    case coldStorageOptions = "ColdStorageOptions"
                }
            }

            /// Options to enable, disable, and specify the properties of EBS storage volumes.
            public struct EBSOptions: Encodable {
                public var eBSEnabled: EBSEnabled?
                public var volumeType: VolumeType?
                public var volumeSize: VolumeSize?
                public var iops: Iops?

                public struct EBSEnabled: Encodable {
                    public var isBool: Bool
                    /// Whether EBS-based storage is enabled.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct VolumeType: Encodable {
                    /// The type of EBS volume, standard, gp2, or io1. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/opensearch-createupdatedomains.html#opensearch-createdomain-configure-ebs" target="_blank">Configuring EBS-based Storage</a> for more information.
                    public var volumeType: AmazonOpenSearchAPI.VolumeType
                    /// The volume type for EBS-based storage.
                    public var anyJSON: AnyJSON

                    public init(volumeType: AmazonOpenSearchAPI.VolumeType, anyJSON: AnyJSON) {
                        self.volumeType = volumeType
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(volumeType, forKey: "volumeType")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct VolumeSize: Encodable {
                    public var int: Int
                    /// Integer to specify the size of an EBS volume.
                    public var anyJSON: AnyJSON

                    public init(int: Int, anyJSON: AnyJSON) {
                        self.int = int
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(int, forKey: "int")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct Iops: Encodable {
                    public var int: Int
                    /// The IOPD for a Provisioned IOPS EBS volume (SSD).
                    public var anyJSON: AnyJSON

                    public init(int: Int, anyJSON: AnyJSON) {
                        self.int = int
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(int, forKey: "int")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(eBSEnabled: EBSEnabled? = nil, volumeType: VolumeType? = nil, volumeSize: VolumeSize? = nil, iops: Iops? = nil) {
                    self.eBSEnabled = eBSEnabled
                    self.volumeType = volumeType
                    self.volumeSize = volumeSize
                    self.iops = iops
                }

                private enum CodingKeys: String, CodingKey {
                    case eBSEnabled = "EBSEnabled"
                    case volumeType = "VolumeType"
                    case volumeSize = "VolumeSize"
                    case iops = "Iops"
                }
            }

            /// The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.
            public struct SnapshotOptions: Encodable {
                public var automatedSnapshotStartHour: AutomatedSnapshotStartHour?

                public struct AutomatedSnapshotStartHour: Encodable {
                    public var int: Int
                    /// The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.
                    public var anyJSON: AnyJSON

                    public init(int: Int, anyJSON: AnyJSON) {
                        self.int = int
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(int, forKey: "int")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(automatedSnapshotStartHour: AutomatedSnapshotStartHour? = nil) {
                    self.automatedSnapshotStartHour = automatedSnapshotStartHour
                }

                private enum CodingKeys: String, CodingKey {
                    case automatedSnapshotStartHour = "AutomatedSnapshotStartHour"
                }
            }

            /// Options to specify the subnets and security groups for the VPC endpoint. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>.
            public struct VPCOptions: Encodable {
                public var subnetIDs: SubnetIDs?
                public var securityGroupIDs: SecurityGroupIDs?

                public struct SubnetIDs: Encodable {
                    public var strings: [String]
                    /// The subnets for the VPC endpoint.
                    public var anyJSON: AnyJSON

                    public init(strings: [String], anyJSON: AnyJSON) {
                        self.strings = strings
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(strings, forKey: "strings")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct SecurityGroupIDs: Encodable {
                    public var strings: [String]
                    /// The security groups for the VPC endpoint.
                    public var anyJSON: AnyJSON

                    public init(strings: [String], anyJSON: AnyJSON) {
                        self.strings = strings
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(strings, forKey: "strings")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(subnetIDs: SubnetIDs? = nil, securityGroupIDs: SecurityGroupIDs? = nil) {
                    self.subnetIDs = subnetIDs
                    self.securityGroupIDs = securityGroupIDs
                }

                private enum CodingKeys: String, CodingKey {
                    case subnetIDs = "SubnetIds"
                    case securityGroupIDs = "SecurityGroupIds"
                }
            }

            /// Options to specify the Cognito user and identity pools for OpenSearch Dashboards authentication. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>.
            public struct CognitoOptions: Encodable {
                public var enabled: Enabled?
                public var userPoolID: UserPoolID?
                public var identityPoolID: IdentityPoolId?
                public var roleArn: RoleArn?

                public struct Enabled: Encodable {
                    public var isBool: Bool
                    /// The option to enable Cognito for OpenSearch Dashboards authentication.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct UserPoolID: Encodable {
                    public var userPoolID: AmazonOpenSearchAPI.UserPoolID
                    /// The Cognito user pool ID for OpenSearch Dashboards authentication.
                    public var anyJSON: AnyJSON

                    public init(userPoolID: AmazonOpenSearchAPI.UserPoolID, anyJSON: AnyJSON) {
                        self.userPoolID = userPoolID
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(userPoolID, forKey: "userPoolID")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct IdentityPoolId: Encodable {
                    public var identityPoolID: AmazonOpenSearchAPI.IdentityPoolId
                    /// The Cognito identity pool ID for OpenSearch Dashboards authentication.
                    public var anyJSON: AnyJSON

                    public init(identityPoolID: AmazonOpenSearchAPI.IdentityPoolId, anyJSON: AnyJSON) {
                        self.identityPoolID = identityPoolID
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(identityPoolID, forKey: "identityPoolID")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct RoleArn: Encodable {
                    public var roleArn: AmazonOpenSearchAPI.RoleArn
                    /// The role ARN that provides OpenSearch permissions for accessing Cognito resources.
                    public var anyJSON: AnyJSON

                    public init(roleArn: AmazonOpenSearchAPI.RoleArn, anyJSON: AnyJSON) {
                        self.roleArn = roleArn
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(roleArn, forKey: "roleArn")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(enabled: Enabled? = nil, userPoolID: UserPoolID? = nil, identityPoolID: IdentityPoolId? = nil, roleArn: RoleArn? = nil) {
                    self.enabled = enabled
                    self.userPoolID = userPoolID
                    self.identityPoolID = identityPoolID
                    self.roleArn = roleArn
                }

                private enum CodingKeys: String, CodingKey {
                    case enabled = "Enabled"
                    case userPoolID = "UserPoolId"
                    case identityPoolID = "IdentityPoolId"
                    case roleArn = "RoleArn"
                }
            }

            /// Specifies encryption at rest options.
            public struct EncryptionAtRestOptions: Encodable {
                public var enabled: Enabled?
                public var kmsKeyID: KmsKeyID?

                public struct Enabled: Encodable {
                    public var isBool: Bool
                    /// The option to enable encryption at rest.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct KmsKeyID: Encodable {
                    public var kmsKeyID: AmazonOpenSearchAPI.KmsKeyID
                    /// The KMS key ID for encryption at rest options.
                    public var anyJSON: AnyJSON

                    public init(kmsKeyID: AmazonOpenSearchAPI.KmsKeyID, anyJSON: AnyJSON) {
                        self.kmsKeyID = kmsKeyID
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(kmsKeyID, forKey: "kmsKeyID")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(enabled: Enabled? = nil, kmsKeyID: KmsKeyID? = nil) {
                    self.enabled = enabled
                    self.kmsKeyID = kmsKeyID
                }

                private enum CodingKeys: String, CodingKey {
                    case enabled = "Enabled"
                    case kmsKeyID = "KmsKeyId"
                }
            }

            /// Options to configure the endpoint for the domain.
            public struct DomainEndpointOptions: Encodable {
                public var enforceHTTPS: EnforceHTTPS?
                public var tlsSecurityPolicy: TLSSecurityPolicy?
                public var customEndpointEnabled: CustomEndpointEnabled?
                public var customEndpoint: CustomEndpoint?
                public var customEndpointCertificateArn: CustomEndpointCertificateArn?

                public struct EnforceHTTPS: Encodable {
                    public var isBool: Bool
                    /// Whether only HTTPS endpoint should be enabled for the domain.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct TLSSecurityPolicy: Encodable {
                    public var tlsSecurityPolicy: AmazonOpenSearchAPI.TLSSecurityPolicy
                    /// Specify the TLS security policy to apply to the HTTPS endpoint of the domain. <br/> Can be one of the following values: <ul> <li> <b>Policy-Min-TLS-1-0-2019-07:</b> TLS security policy which supports TLSv1.0 and higher. </li> <li> <b>Policy-Min-TLS-1-2-2019-07:</b> TLS security policy which supports only TLSv1.2 </li> </ul>
                    public var anyJSON: AnyJSON

                    public init(tlsSecurityPolicy: AmazonOpenSearchAPI.TLSSecurityPolicy, anyJSON: AnyJSON) {
                        self.tlsSecurityPolicy = tlsSecurityPolicy
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(tlsSecurityPolicy, forKey: "tlsSecurityPolicy")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct CustomEndpointEnabled: Encodable {
                    public var isBool: Bool
                    /// Whether to enable a custom endpoint for the domain.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct CustomEndpoint: Encodable {
                    public var string: String
                    /// The fully qualified domain for your custom endpoint.
                    public var anyJSON: AnyJSON

                    public init(string: String, anyJSON: AnyJSON) {
                        self.string = string
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(string, forKey: "string")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct CustomEndpointCertificateArn: Encodable {
                    /// The Amazon Resource Name (ARN) of the domain. See <a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/index.html" target="_blank">Identifiers for IAM Entities </a> in <i>Using AWS Identity and Access Management</i> for more information.
                    public var string: String
                    /// The ACM certificate ARN for your custom endpoint.
                    public var anyJSON: AnyJSON

                    public init(string: String, anyJSON: AnyJSON) {
                        self.string = string
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(string, forKey: "string")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(enforceHTTPS: EnforceHTTPS? = nil, tlsSecurityPolicy: TLSSecurityPolicy? = nil, customEndpointEnabled: CustomEndpointEnabled? = nil, customEndpoint: CustomEndpoint? = nil, customEndpointCertificateArn: CustomEndpointCertificateArn? = nil) {
                    self.enforceHTTPS = enforceHTTPS
                    self.tlsSecurityPolicy = tlsSecurityPolicy
                    self.customEndpointEnabled = customEndpointEnabled
                    self.customEndpoint = customEndpoint
                    self.customEndpointCertificateArn = customEndpointCertificateArn
                }

                private enum CodingKeys: String, CodingKey {
                    case enforceHTTPS = "EnforceHTTPS"
                    case tlsSecurityPolicy = "TLSSecurityPolicy"
                    case customEndpointEnabled = "CustomEndpointEnabled"
                    case customEndpoint = "CustomEndpoint"
                    case customEndpointCertificateArn = "CustomEndpointCertificateArn"
                }
            }

            /// The node-to-node encryption options.
            public struct NodeToNodeEncryptionOptions: Encodable {
                public var enabled: Enabled?

                public struct Enabled: Encodable {
                    public var isBool: Bool
                    /// True to enable node-to-node encryption.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(enabled: Enabled? = nil) {
                    self.enabled = enabled
                }

                private enum CodingKeys: String, CodingKey {
                    case enabled = "Enabled"
                }
            }

            /// The advanced security configuration: whether advanced security is enabled, whether the internal database option is enabled, master username and password (if internal database is enabled), and master user ARN (if IAM is enabled).
            public struct AdvancedSecurityOptions: Encodable {
                public var enabled: Enabled?
                public var internalUserDatabaseEnabled: InternalUserDatabaseEnabled?
                public var masterUserOptions: MasterUserOptions?
                public var sAMLOptions: SAMLOptions?

                public struct Enabled: Encodable {
                    public var isBool: Bool
                    /// True if advanced security is enabled.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct InternalUserDatabaseEnabled: Encodable {
                    public var isBool: Bool
                    /// True if the internal user database is enabled.
                    public var anyJSON: AnyJSON

                    public init(isBool: Bool, anyJSON: AnyJSON) {
                        self.isBool = isBool
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(isBool, forKey: "bool")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct MasterUserOptions: Encodable {
                    /// Credentials for the master user: username and password, ARN, or both.
                    public var masterUserOptions: AmazonOpenSearchAPI.MasterUserOptions
                    /// Credentials for the master user: username and password, ARN, or both.
                    public var anyJSON: AnyJSON

                    public init(masterUserOptions: AmazonOpenSearchAPI.MasterUserOptions, anyJSON: AnyJSON) {
                        self.masterUserOptions = masterUserOptions
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(masterUserOptions, forKey: "masterUserOptions")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct SAMLOptions: Encodable {
                    /// The SAML application configuration for the domain.
                    public var sAMLOptionsInput: AmazonOpenSearchAPI.SAMLOptionsInput
                    /// The SAML application configuration for the domain.
                    public var anyJSON: AnyJSON

                    public init(sAMLOptionsInput: AmazonOpenSearchAPI.SAMLOptionsInput, anyJSON: AnyJSON) {
                        self.sAMLOptionsInput = sAMLOptionsInput
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(sAMLOptionsInput, forKey: "sAMLOptionsInput")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(enabled: Enabled? = nil, internalUserDatabaseEnabled: InternalUserDatabaseEnabled? = nil, masterUserOptions: MasterUserOptions? = nil, sAMLOptions: SAMLOptions? = nil) {
                    self.enabled = enabled
                    self.internalUserDatabaseEnabled = internalUserDatabaseEnabled
                    self.masterUserOptions = masterUserOptions
                    self.sAMLOptions = sAMLOptions
                }

                private enum CodingKeys: String, CodingKey {
                    case enabled = "Enabled"
                    case internalUserDatabaseEnabled = "InternalUserDatabaseEnabled"
                    case masterUserOptions = "MasterUserOptions"
                    case sAMLOptions = "SAMLOptions"
                }
            }

            /// The Auto-Tune options: the Auto-Tune desired state for the domain, rollback state when disabling Auto-Tune options and list of maintenance schedules.
            public struct AutoTuneOptions: Encodable {
                public var desiredState: DesiredState?
                public var rollbackOnDisable: RollbackOnDisable?
                public var maintenanceSchedules: MaintenanceSchedules?

                public struct DesiredState: Encodable {
                    /// The Auto-Tune desired state. Valid values are ENABLED and DISABLED.
                    public var autoTuneDesiredState: AmazonOpenSearchAPI.AutoTuneDesiredState
                    /// The Auto-Tune desired state. Valid values are ENABLED and DISABLED.
                    public var anyJSON: AnyJSON

                    public init(autoTuneDesiredState: AmazonOpenSearchAPI.AutoTuneDesiredState, anyJSON: AnyJSON) {
                        self.autoTuneDesiredState = autoTuneDesiredState
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(autoTuneDesiredState, forKey: "autoTuneDesiredState")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct RollbackOnDisable: Encodable {
                    /// The rollback state while disabling Auto-Tune for the domain. Valid values are NO_ROLLBACK and DEFAULT_ROLLBACK.
                    public var rollbackOnDisable: AmazonOpenSearchAPI.RollbackOnDisable
                    /// The rollback state while disabling Auto-Tune for the domain. Valid values are NO_ROLLBACK and DEFAULT_ROLLBACK.
                    public var anyJSON: AnyJSON

                    public init(rollbackOnDisable: AmazonOpenSearchAPI.RollbackOnDisable, anyJSON: AnyJSON) {
                        self.rollbackOnDisable = rollbackOnDisable
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(rollbackOnDisable, forKey: "rollbackOnDisable")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct MaintenanceSchedules: Encodable {
                    public var autoTuneMaintenanceSchedules: [AmazonOpenSearchAPI.AutoTuneMaintenanceSchedule]
                    /// A list of maintenance schedules. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
                    public var anyJSON: AnyJSON

                    public init(autoTuneMaintenanceSchedules: [AmazonOpenSearchAPI.AutoTuneMaintenanceSchedule], anyJSON: AnyJSON) {
                        self.autoTuneMaintenanceSchedules = autoTuneMaintenanceSchedules
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(autoTuneMaintenanceSchedules, forKey: "autoTuneMaintenanceSchedules")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(desiredState: DesiredState? = nil, rollbackOnDisable: RollbackOnDisable? = nil, maintenanceSchedules: MaintenanceSchedules? = nil) {
                    self.desiredState = desiredState
                    self.rollbackOnDisable = rollbackOnDisable
                    self.maintenanceSchedules = maintenanceSchedules
                }

                private enum CodingKeys: String, CodingKey {
                    case desiredState = "DesiredState"
                    case rollbackOnDisable = "RollbackOnDisable"
                    case maintenanceSchedules = "MaintenanceSchedules"
                }
            }

            public init(clusterConfig: ClusterConfig? = nil, eBSOptions: EBSOptions? = nil, snapshotOptions: SnapshotOptions? = nil, vPCOptions: VPCOptions? = nil, cognitoOptions: CognitoOptions? = nil, advancedOptions: [String: String]? = nil, accessPolicies: String? = nil, logPublishingOptions: [String: AmazonOpenSearchAPI.LogPublishingOption]? = nil, encryptionAtRestOptions: EncryptionAtRestOptions? = nil, domainEndpointOptions: DomainEndpointOptions? = nil, nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions? = nil, advancedSecurityOptions: AdvancedSecurityOptions? = nil, autoTuneOptions: AutoTuneOptions? = nil) {
                self.clusterConfig = clusterConfig
                self.eBSOptions = eBSOptions
                self.snapshotOptions = snapshotOptions
                self.vPCOptions = vPCOptions
                self.cognitoOptions = cognitoOptions
                self.advancedOptions = advancedOptions
                self.accessPolicies = accessPolicies
                self.logPublishingOptions = logPublishingOptions
                self.encryptionAtRestOptions = encryptionAtRestOptions
                self.domainEndpointOptions = domainEndpointOptions
                self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
                self.advancedSecurityOptions = advancedSecurityOptions
                self.autoTuneOptions = autoTuneOptions
            }

            private enum CodingKeys: String, CodingKey {
                case clusterConfig = "ClusterConfig"
                case eBSOptions = "EBSOptions"
                case snapshotOptions = "SnapshotOptions"
                case vPCOptions = "VPCOptions"
                case cognitoOptions = "CognitoOptions"
                case advancedOptions = "AdvancedOptions"
                case accessPolicies = "AccessPolicies"
                case logPublishingOptions = "LogPublishingOptions"
                case encryptionAtRestOptions = "EncryptionAtRestOptions"
                case domainEndpointOptions = "DomainEndpointOptions"
                case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
                case advancedSecurityOptions = "AdvancedSecurityOptions"
                case autoTuneOptions = "AutoTuneOptions"
            }
        }
    }
}

extension Paths.Opensearch {
    public var domainInfo: DomainInfo {
        DomainInfo(path: path + "/domain-info")
    }

    public struct DomainInfo {
        /// Path: `/2021-01-01/opensearch/domain-info`
        public let path: String

        /// Returns domain configuration information about the specified domains, including the domain ID, domain endpoint, and domain ARN.
        public func post(domainNames: [String]) -> Request<AmazonOpenSearchAPI.DescribeDomainsResponse> {
            .post(path, body: ["DomainNames": domainNames])
        }
    }
}

extension Paths.Opensearch.Cc.InboundConnection {
    public var search: Search {
        Search(path: path + "/search")
    }

    public struct Search {
        /// Path: `/2021-01-01/opensearch/cc/inboundConnection/search`
        public let path: String

        /// Lists all the inbound cross-cluster connections for a remote domain.
        public func post(maxResults: String? = nil, nextToken: String? = nil, _ body: PostRequest) -> Request<AmazonOpenSearchAPI.DescribeInboundConnectionsResponse> {
            .post(path, query: makePostQuery(maxResults, nextToken), body: body)
        }

        private func makePostQuery(_ maxResults: String?, _ nextToken: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(maxResults, forKey: "MaxResults")
            encoder.encode(nextToken, forKey: "NextToken")
            return encoder.items
        }

        public struct PostRequest: Encodable {
            /// A list of filters used to match properties for inbound cross-cluster connections. Available <code> <a>Filter</a> </code> values are: <ul> <li>connection-id</li> <li>local-domain-info.domain-name</li> <li>local-domain-info.owner-id</li> <li>local-domain-info.region</li> <li>remote-domain-info.domain-name</li> </ul>
            public var filters: [AmazonOpenSearchAPI.Filter]?
            /// Set this value to limit the number of results returned.
            public var maxResults: Int?
            /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
            public var nextToken: String?

            public init(filters: [AmazonOpenSearchAPI.Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
                self.filters = filters
                self.maxResults = maxResults
                self.nextToken = nextToken
            }

            private enum CodingKeys: String, CodingKey {
                case filters = "Filters"
                case maxResults = "MaxResults"
                case nextToken = "NextToken"
            }
        }
    }
}

extension Paths.Opensearch {
    public var instanceTypeLimits: InstanceTypeLimits {
        InstanceTypeLimits(path: path + "/instanceTypeLimits")
    }

    public struct InstanceTypeLimits {
        /// Path: `/2021-01-01/opensearch/instanceTypeLimits`
        public let path: String
    }
}

extension Paths.Opensearch.InstanceTypeLimits {
    public func engineVersion(_ engineVersion: String) -> WithEngineVersion {
        WithEngineVersion(path: "\(path)/\(engineVersion)")
    }

    public struct WithEngineVersion {
        /// Path: `/2021-01-01/opensearch/instanceTypeLimits/{EngineVersion}`
        public let path: String
    }
}

extension Paths.Opensearch.InstanceTypeLimits.WithEngineVersion {
    public func instanceType(_ instanceType: String) -> WithInstanceType {
        WithInstanceType(path: "\(path)/\(instanceType)")
    }

    public struct WithInstanceType {
        /// Path: `/2021-01-01/opensearch/instanceTypeLimits/{EngineVersion}/{InstanceType}`
        public let path: String

        /// Describe the limits for a given instance type and OpenSearch or Elasticsearch version. When modifying an existing domain, specify the <code> <a>DomainName</a> </code> to see which limits you can modify.
        public func get(domainName: String? = nil) -> Request<AmazonOpenSearchAPI.DescribeInstanceTypeLimitsResponse> {
            .get(path, query: makeGetQuery(domainName))
        }

        private func makeGetQuery(_ domainName: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(domainName, forKey: "domainName")
            return encoder.items
        }
    }
}

extension Paths.Opensearch.Cc.OutboundConnection {
    public var search: Search {
        Search(path: path + "/search")
    }

    public struct Search {
        /// Path: `/2021-01-01/opensearch/cc/outboundConnection/search`
        public let path: String

        /// Lists all the outbound cross-cluster connections for a local domain.
        public func post(maxResults: String? = nil, nextToken: String? = nil, _ body: PostRequest) -> Request<AmazonOpenSearchAPI.DescribeOutboundConnectionsResponse> {
            .post(path, query: makePostQuery(maxResults, nextToken), body: body)
        }

        private func makePostQuery(_ maxResults: String?, _ nextToken: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(maxResults, forKey: "MaxResults")
            encoder.encode(nextToken, forKey: "NextToken")
            return encoder.items
        }

        public struct PostRequest: Encodable {
            /// A list of filters used to match properties for outbound cross-cluster connections. Available <code> <a>Filter</a> </code> names for this operation are: <ul> <li>connection-id</li> <li>remote-domain-info.domain-name</li> <li>remote-domain-info.owner-id</li> <li>remote-domain-info.region</li> <li>local-domain-info.domain-name</li> </ul>
            public var filters: [AmazonOpenSearchAPI.Filter]?
            /// Set this value to limit the number of results returned.
            public var maxResults: Int?
            /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
            public var nextToken: String?

            public init(filters: [AmazonOpenSearchAPI.Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
                self.filters = filters
                self.maxResults = maxResults
                self.nextToken = nextToken
            }

            private enum CodingKeys: String, CodingKey {
                case filters = "Filters"
                case maxResults = "MaxResults"
                case nextToken = "NextToken"
            }
        }
    }
}

extension Paths.Packages {
    public var describe: Describe {
        Describe(path: path + "/describe")
    }

    public struct Describe {
        /// Path: `/2021-01-01/packages/describe`
        public let path: String

        /// Describes all packages available to Amazon OpenSearch Service domains. Includes options for filtering, limiting the number of results, and pagination.
        public func post(maxResults: String? = nil, nextToken: String? = nil, _ body: PostRequest) -> Request<AmazonOpenSearchAPI.DescribePackagesResponse> {
            .post(path, query: makePostQuery(maxResults, nextToken), body: body)
        }

        private func makePostQuery(_ maxResults: String?, _ nextToken: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(maxResults, forKey: "MaxResults")
            encoder.encode(nextToken, forKey: "NextToken")
            return encoder.items
        }

        public struct PostRequest: Encodable {
            /// A list of <code>DescribePackagesFilter</code> to filter the packages included in a <code>DescribePackages</code> response.
            public var filters: [AmazonOpenSearchAPI.DescribePackagesFilter]?
            /// Set this value to limit the number of results returned.
            public var maxResults: Int?
            /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
            public var nextToken: String?

            public init(filters: [AmazonOpenSearchAPI.DescribePackagesFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
                self.filters = filters
                self.maxResults = maxResults
                self.nextToken = nextToken
            }

            private enum CodingKeys: String, CodingKey {
                case filters = "Filters"
                case maxResults = "MaxResults"
                case nextToken = "NextToken"
            }
        }
    }
}

extension Paths.Opensearch {
    public var reservedInstanceOfferings: ReservedInstanceOfferings {
        ReservedInstanceOfferings(path: path + "/reservedInstanceOfferings")
    }

    public struct ReservedInstanceOfferings {
        /// Path: `/2021-01-01/opensearch/reservedInstanceOfferings`
        public let path: String

        /// Lists available reserved OpenSearch instance offerings.
        public func get(parameters: GetParameters? = nil) -> Request<AmazonOpenSearchAPI.DescribeReservedInstanceOfferingsResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var offeringID: String?
            /// Set this value to limit the number of results returned.
            public var maxResults: Int?
            /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
            public var nextToken: String?

            public init(offeringID: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
                self.offeringID = offeringID
                self.maxResults = maxResults
                self.nextToken = nextToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(offeringID, forKey: "offeringId")
                encoder.encode(maxResults, forKey: "maxResults")
                encoder.encode(nextToken, forKey: "nextToken")
                return encoder.items
            }
        }
    }
}

extension Paths.Opensearch {
    public var reservedInstances: ReservedInstances {
        ReservedInstances(path: path + "/reservedInstances")
    }

    public struct ReservedInstances {
        /// Path: `/2021-01-01/opensearch/reservedInstances`
        public let path: String

        /// Returns information about reserved OpenSearch instances for this account.
        public func get(parameters: GetParameters? = nil) -> Request<AmazonOpenSearchAPI.DescribeReservedInstancesResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var reservationID: String?
            /// Set this value to limit the number of results returned.
            public var maxResults: Int?
            /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
            public var nextToken: String?

            public init(reservationID: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
                self.reservationID = reservationID
                self.maxResults = maxResults
                self.nextToken = nextToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(reservationID, forKey: "reservationId")
                encoder.encode(maxResults, forKey: "maxResults")
                encoder.encode(nextToken, forKey: "nextToken")
                return encoder.items
            }
        }
    }
}

extension Paths.Packages {
    public var dissociate: Dissociate {
        Dissociate(path: path + "/dissociate")
    }

    public struct Dissociate {
        /// Path: `/2021-01-01/packages/dissociate`
        public let path: String
    }
}

extension Paths.Packages.Dissociate {
    public func packageID(_ packageID: String) -> WithPackageID {
        WithPackageID(path: "\(path)/\(packageID)")
    }

    public struct WithPackageID {
        /// Path: `/2021-01-01/packages/dissociate/{PackageID}`
        public let path: String
    }
}

extension Paths.Packages.Dissociate.WithPackageID {
    public func domainName(_ domainName: String) -> WithDomainName {
        WithDomainName(path: "\(path)/\(domainName)")
    }

    public struct WithDomainName {
        /// Path: `/2021-01-01/packages/dissociate/{PackageID}/{DomainName}`
        public let path: String

        /// Dissociates a package from the Amazon OpenSearch Service domain.
        public var post: Request<AmazonOpenSearchAPI.DissociatePackageResponse> {
            .post(path)
        }
    }
}

extension Paths.Opensearch {
    public var compatibleVersions: CompatibleVersions {
        CompatibleVersions(path: path + "/compatibleVersions")
    }

    public struct CompatibleVersions {
        /// Path: `/2021-01-01/opensearch/compatibleVersions`
        public let path: String

        /// Returns a list of upgrade-compatible versions of OpenSearch/Elasticsearch. You can optionally pass a <code> <a>DomainName</a> </code> to get all upgrade-compatible versions of OpenSearch/Elasticsearch for that specific domain.
        public func get(domainName: String? = nil) -> Request<AmazonOpenSearchAPI.GetCompatibleVersionsResponse> {
            .get(path, query: makeGetQuery(domainName))
        }

        private func makeGetQuery(_ domainName: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(domainName, forKey: "domainName")
            return encoder.items
        }
    }
}

extension Paths.Packages.WithPackageID {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/2021-01-01/packages/{PackageID}/history`
        public let path: String

        /// Returns a list of package versions, along with their creation time and commit message.
        public func get(maxResults: Int? = nil, nextToken: String? = nil) -> Request<AmazonOpenSearchAPI.GetPackageVersionHistoryResponse> {
            .get(path, query: makeGetQuery(maxResults, nextToken))
        }

        private func makeGetQuery(_ maxResults: Int?, _ nextToken: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(maxResults, forKey: "maxResults")
            encoder.encode(nextToken, forKey: "nextToken")
            return encoder.items
        }
    }
}

extension Paths.Opensearch.UpgradeDomain {
    public func domainName(_ domainName: String) -> WithDomainName {
        WithDomainName(path: "\(path)/\(domainName)")
    }

    public struct WithDomainName {
        /// Path: `/2021-01-01/opensearch/upgradeDomain/{DomainName}`
        public let path: String
    }
}

extension Paths.Opensearch.UpgradeDomain.WithDomainName {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/2021-01-01/opensearch/upgradeDomain/{DomainName}/history`
        public let path: String

        /// Retrieves the complete history of the last 10 upgrades performed on the domain.
        public func get(maxResults: Int? = nil, nextToken: String? = nil) -> Request<AmazonOpenSearchAPI.GetUpgradeHistoryResponse> {
            .get(path, query: makeGetQuery(maxResults, nextToken))
        }

        private func makeGetQuery(_ maxResults: Int?, _ nextToken: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(maxResults, forKey: "maxResults")
            encoder.encode(nextToken, forKey: "nextToken")
            return encoder.items
        }
    }
}

extension Paths.Opensearch.UpgradeDomain.WithDomainName {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/2021-01-01/opensearch/upgradeDomain/{DomainName}/status`
        public let path: String

        /// Retrieves the latest status of the last upgrade or upgrade eligibility check performed on the domain.
        public var get: Request<AmazonOpenSearchAPI.GetUpgradeStatusResponse> {
            .get(path)
        }
    }
}

extension Paths {
    public static var domain: Domain {
        Domain(path: "/2021-01-01/domain")
    }

    public struct Domain {
        /// Path: `/2021-01-01/domain`
        public let path: String

        /// Returns the names of all domains owned by the current user's account.
        public func get(engineType: EngineType? = nil) -> Request<AmazonOpenSearchAPI.ListDomainNamesResponse> {
            .get(path, query: makeGetQuery(engineType))
        }

        private func makeGetQuery(_ engineType: EngineType?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(engineType, forKey: "engineType")
            return encoder.items
        }

        public enum EngineType: String, Codable, CaseIterable {
            case openSearch = "OpenSearch"
            case elasticsearch = "Elasticsearch"
        }
    }
}

extension Paths.Packages.WithPackageID {
    public var domains: Domains {
        Domains(path: path + "/domains")
    }

    public struct Domains {
        /// Path: `/2021-01-01/packages/{PackageID}/domains`
        public let path: String

        /// Lists all Amazon OpenSearch Service domains associated with the package.
        public func get(maxResults: Int? = nil, nextToken: String? = nil) -> Request<AmazonOpenSearchAPI.ListDomainsForPackageResponse> {
            .get(path, query: makeGetQuery(maxResults, nextToken))
        }

        private func makeGetQuery(_ maxResults: Int?, _ nextToken: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(maxResults, forKey: "maxResults")
            encoder.encode(nextToken, forKey: "nextToken")
            return encoder.items
        }
    }
}

extension Paths.Opensearch {
    public var instanceTypeDetails: InstanceTypeDetails {
        InstanceTypeDetails(path: path + "/instanceTypeDetails")
    }

    public struct InstanceTypeDetails {
        /// Path: `/2021-01-01/opensearch/instanceTypeDetails`
        public let path: String
    }
}

extension Paths.Opensearch.InstanceTypeDetails {
    public func engineVersion(_ engineVersion: String) -> WithEngineVersion {
        WithEngineVersion(path: "\(path)/\(engineVersion)")
    }

    public struct WithEngineVersion {
        /// Path: `/2021-01-01/opensearch/instanceTypeDetails/{EngineVersion}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AmazonOpenSearchAPI.ListInstanceTypeDetailsResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
            public var domainName: String?
            /// Set this value to limit the number of results returned.
            public var maxResults: Int?
            /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
            public var nextToken: String?

            public init(domainName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
                self.domainName = domainName
                self.maxResults = maxResults
                self.nextToken = nextToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(domainName, forKey: "domainName")
                encoder.encode(maxResults, forKey: "maxResults")
                encoder.encode(nextToken, forKey: "nextToken")
                return encoder.items
            }
        }
    }
}

extension Paths.Domain {
    public func domainName(_ domainName: String) -> WithDomainName {
        WithDomainName(path: "\(path)/\(domainName)")
    }

    public struct WithDomainName {
        /// Path: `/2021-01-01/domain/{DomainName}`
        public let path: String
    }
}

extension Paths.Domain.WithDomainName {
    public var packages: Packages {
        Packages(path: path + "/packages")
    }

    public struct Packages {
        /// Path: `/2021-01-01/domain/{DomainName}/packages`
        public let path: String

        /// Lists all packages associated with the Amazon OpenSearch Service domain.
        public func get(maxResults: Int? = nil, nextToken: String? = nil) -> Request<AmazonOpenSearchAPI.ListPackagesForDomainResponse> {
            .get(path, query: makeGetQuery(maxResults, nextToken))
        }

        private func makeGetQuery(_ maxResults: Int?, _ nextToken: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(maxResults, forKey: "maxResults")
            encoder.encode(nextToken, forKey: "nextToken")
            return encoder.items
        }
    }
}

extension Paths.Tags {
    public var arn: Arn {
        Arn(path: path + "/#arn")
    }

    public struct Arn {
        /// Path: `/2021-01-01/tags/#arn`
        public let path: String

        /// Returns all tags for the given domain.
        public func get(arn: String) -> Request<AmazonOpenSearchAPI.ListTagsResponse> {
            .get(path, query: [("arn", arn)])
        }
    }
}

extension Paths.Opensearch {
    public var versions: Versions {
        Versions(path: path + "/versions")
    }

    public struct Versions {
        /// Path: `/2021-01-01/opensearch/versions`
        public let path: String

        /// List all supported versions of OpenSearch and Elasticsearch.
        public func get(maxResults: Int? = nil, nextToken: String? = nil) -> Request<AmazonOpenSearchAPI.ListVersionsResponse> {
            .get(path, query: makeGetQuery(maxResults, nextToken))
        }

        private func makeGetQuery(_ maxResults: Int?, _ nextToken: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(maxResults, forKey: "maxResults")
            encoder.encode(nextToken, forKey: "nextToken")
            return encoder.items
        }
    }
}

extension Paths.Opensearch {
    public var purchaseReservedInstanceOffering: PurchaseReservedInstanceOffering {
        PurchaseReservedInstanceOffering(path: path + "/purchaseReservedInstanceOffering")
    }

    public struct PurchaseReservedInstanceOffering {
        /// Path: `/2021-01-01/opensearch/purchaseReservedInstanceOffering`
        public let path: String

        /// Allows you to purchase reserved OpenSearch instances.
        public func post(_ body: PostRequest) -> Request<AmazonOpenSearchAPI.PurchaseReservedInstanceOfferingResponse> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The ID of the reserved OpenSearch instance offering to purchase.
            public var reservedInstanceOfferingID: String
            /// A customer-specified identifier to track this reservation.
            public var reservationName: String
            /// The number of EC2 instances in the domain.
            public var instanceCount: Int?

            public init(reservedInstanceOfferingID: String, reservationName: String, instanceCount: Int? = nil) {
                self.reservedInstanceOfferingID = reservedInstanceOfferingID
                self.reservationName = reservationName
                self.instanceCount = instanceCount
            }

            private enum CodingKeys: String, CodingKey {
                case reservedInstanceOfferingID = "ReservedInstanceOfferingId"
                case reservationName = "ReservationName"
                case instanceCount = "InstanceCount"
            }
        }
    }
}

extension Paths.Opensearch.Cc.InboundConnection.WithConnectionID {
    public var reject: Reject {
        Reject(path: path + "/reject")
    }

    public struct Reject {
        /// Path: `/2021-01-01/opensearch/cc/inboundConnection/{ConnectionId}/reject`
        public let path: String

        /// Allows the remote domain owner to reject an inbound cross-cluster connection request.
        public var put: Request<AmazonOpenSearchAPI.RejectInboundConnectionResponse> {
            .put(path)
        }
    }
}

extension Paths {
    public static var tagsRemoval: TagsRemoval {
        TagsRemoval(path: "/2021-01-01/tags-removal")
    }

    public struct TagsRemoval {
        /// Path: `/2021-01-01/tags-removal`
        public let path: String

        /// Removes the specified set of tags from the given domain.
        public func post(_ body: PostRequest) -> Request<Void> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The Amazon Resource Name (ARN) of the domain. See <a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/index.html" target="_blank">Identifiers for IAM Entities </a> in <i>Using AWS Identity and Access Management</i> for more information.
            public var arn: String
            /// The <code>TagKey</code> list you want to remove from the domain.
            public var tagKeys: [String]

            public init(arn: String, tagKeys: [String]) {
                self.arn = arn
                self.tagKeys = tagKeys
            }

            private enum CodingKeys: String, CodingKey {
                case arn = "ARN"
                case tagKeys = "TagKeys"
            }
        }
    }
}

extension Paths.Opensearch.ServiceSoftwareUpdate {
    public var start: Start {
        Start(path: path + "/start")
    }

    public struct Start {
        /// Path: `/2021-01-01/opensearch/serviceSoftwareUpdate/start`
        public let path: String

        /// Schedules a service software update for an Amazon OpenSearch Service domain.
        public func post(domainName: String) -> Request<AmazonOpenSearchAPI.StartServiceSoftwareUpdateResponse> {
            .post(path, body: ["DomainName": domainName])
        }
    }
}

extension Paths.Packages {
    public var update: Update {
        Update(path: path + "/update")
    }

    public struct Update {
        /// Path: `/2021-01-01/packages/update`
        public let path: String

        /// Updates a package for use with Amazon OpenSearch Service domains.
        public func post(_ body: PostRequest) -> Request<AmazonOpenSearchAPI.UpdatePackageResponse> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The unique identifier for the package.
            public var packageID: String
            /// The Amazon S3 location for importing the package specified as <code>S3BucketName</code> and <code>S3Key</code>
            public var packageSource: PackageSource
            /// A new description of the package.
            public var packageDescription: String?
            /// A commit message for the new version which is shown as part of <code>GetPackageVersionHistoryResponse</code>.
            public var commitMessage: String?

            /// The Amazon S3 location for importing the package specified as <code>S3BucketName</code> and <code>S3Key</code>
            public struct PackageSource: Encodable {
                public var s3BucketName: S3BucketName?
                public var s3Key: S3Key?

                public struct S3BucketName: Encodable {
                    public var s3BucketName: AmazonOpenSearchAPI.S3BucketName
                    /// The name of the Amazon S3 bucket containing the package.
                    public var anyJSON: AnyJSON

                    public init(s3BucketName: AmazonOpenSearchAPI.S3BucketName, anyJSON: AnyJSON) {
                        self.s3BucketName = s3BucketName
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(s3BucketName, forKey: "s3BucketName")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct S3Key: Encodable {
                    public var s3Key: AmazonOpenSearchAPI.S3Key
                    /// Key (file name) of the package.
                    public var anyJSON: AnyJSON

                    public init(s3Key: AmazonOpenSearchAPI.S3Key, anyJSON: AnyJSON) {
                        self.s3Key = s3Key
                        self.anyJSON = anyJSON
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(s3Key, forKey: "s3Key")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public init(s3BucketName: S3BucketName? = nil, s3Key: S3Key? = nil) {
                    self.s3BucketName = s3BucketName
                    self.s3Key = s3Key
                }

                private enum CodingKeys: String, CodingKey {
                    case s3BucketName = "S3BucketName"
                    case s3Key = "S3Key"
                }
            }

            public init(packageID: String, packageSource: PackageSource, packageDescription: String? = nil, commitMessage: String? = nil) {
                self.packageID = packageID
                self.packageSource = packageSource
                self.packageDescription = packageDescription
                self.commitMessage = commitMessage
            }

            private enum CodingKeys: String, CodingKey {
                case packageID = "PackageID"
                case packageSource = "PackageSource"
                case packageDescription = "PackageDescription"
                case commitMessage = "CommitMessage"
            }
        }
    }
}

extension Paths.Opensearch {
    public var upgradeDomain: UpgradeDomain {
        UpgradeDomain(path: path + "/upgradeDomain")
    }

    public struct UpgradeDomain {
        /// Path: `/2021-01-01/opensearch/upgradeDomain`
        public let path: String

        /// Allows you to either upgrade your domain or perform an upgrade eligibility check to a compatible version of OpenSearch or Elasticsearch.
        public func post(_ body: PostRequest) -> Request<AmazonOpenSearchAPI.UpgradeDomainResponse> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
            public var domainName: String
            /// The version of OpenSearch you intend to upgrade the domain to.
            public var targetVersion: String
            /// When true, indicates that an upgrade eligibility check needs to be performed. Does not actually perform the upgrade.
            public var isPerformCheckOnly: Bool?
            /// <p>Exposes select native OpenSearch configuration values from <code>opensearch.yml</code>. Currently, the following advanced options are available: </p> <ul> <li>Option to allow references to indices in an HTTP request body. Must be <code>false</code> when configuring access to individual sub-resources. By default, the value is <code>true</code>. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced cluster parameters </a> for more information. </li> <li>Option to specify the percentage of heap space allocated to field data. By default, this setting is unbounded. </li> </ul> <p>For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options"> Advanced cluster parameters</a>. </p>
            public var advancedOptions: [String: String]?

            public init(domainName: String, targetVersion: String, isPerformCheckOnly: Bool? = nil, advancedOptions: [String: String]? = nil) {
                self.domainName = domainName
                self.targetVersion = targetVersion
                self.isPerformCheckOnly = isPerformCheckOnly
                self.advancedOptions = advancedOptions
            }

            private enum CodingKeys: String, CodingKey {
                case domainName = "DomainName"
                case targetVersion = "TargetVersion"
                case isPerformCheckOnly = "PerformCheckOnly"
                case advancedOptions = "AdvancedOptions"
            }
        }
    }
}

public enum Paths {}
