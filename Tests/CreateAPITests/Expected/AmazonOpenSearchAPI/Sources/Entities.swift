// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

/// The result of an <code> <a>AcceptInboundConnection</a> </code> operation. Contains details about the accepted inbound connection.
public struct AcceptInboundConnectionResponse: Codable {
    public var connection: Connection?

    public struct Connection: Codable {
        /// Details of an inbound connection.
        public var inboundConnection: InboundConnection
        /// The <code> <a>InboundConnection</a> </code> of the accepted inbound connection.
        public var anyJSON: AnyJSON

        public init(inboundConnection: InboundConnection, anyJSON: AnyJSON) {
            self.inboundConnection = inboundConnection
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.inboundConnection = try InboundConnection(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(inboundConnection, forKey: "inboundConnection")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(connection: Connection? = nil) {
        self.connection = connection
    }

    private enum CodingKeys: String, CodingKey {
        case connection = "Connection"
    }
}

/// A key value pair for a resource tag.
public struct Tag: Codable {
    public var key: Key
    public var value: Value

    public struct Key: Codable {
        /// A string of length from 1 to 128 characters that specifies the key for a tag. Tag keys must be unique for the domain to which they're attached.
        public var string: String
        /// The <code>TagKey</code>, the name of the tag. Tag keys must be unique for the domain to which they are attached.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Value: Codable {
        /// A string of length from 0 to 256 characters that specifies the value for a tag. Tag values can be null and don't have to be unique in a tag set.
        public var string: String
        /// The <code>TagValue</code>, the value assigned to the corresponding tag key. Tag values can be null and don't have to be unique in a tag set. For example, you can have a key value pair in a tag set of <code>project : Trinity</code> and <code>cost-center : Trinity</code>
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(key: Key, value: Value) {
        self.key = key
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }
}

/// Container for the response returned by <code> <a>AssociatePackage</a> </code> operation.
public struct AssociatePackageResponse: Codable {
    public var domainPackageDetails: DomainPackageDetails?

    public final class DomainPackageDetails: Codable {
        /// Information on a package associated with a domain.
        public var domainPackageDetails: AmazonOpenSearchAPI.DomainPackageDetails
        /// <code>DomainPackageDetails</code>
        public var anyJSON: AnyJSON

        public init(domainPackageDetails: AmazonOpenSearchAPI.DomainPackageDetails, anyJSON: AnyJSON) {
            self.domainPackageDetails = domainPackageDetails
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainPackageDetails = try values.decode(AmazonOpenSearchAPI.DomainPackageDetails.self, forKey: "domainPackageDetails")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainPackageDetails, forKey: "domainPackageDetails")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(domainPackageDetails: DomainPackageDetails? = nil) {
        self.domainPackageDetails = domainPackageDetails
    }

    private enum CodingKeys: String, CodingKey {
        case domainPackageDetails = "DomainPackageDetails"
    }
}

/// The result of a <code>CancelServiceSoftwareUpdate</code> operation. Contains the status of the update.
public struct CancelServiceSoftwareUpdateResponse: Codable {
    public var serviceSoftwareOptions: ServiceSoftwareOptions?

    public final class ServiceSoftwareOptions: Codable {
        /// The current options of an domain service software options.
        public var serviceSoftwareOptions: AmazonOpenSearchAPI.ServiceSoftwareOptions
        /// The current status of the OpenSearch service software update.
        public var anyJSON: AnyJSON

        public init(serviceSoftwareOptions: AmazonOpenSearchAPI.ServiceSoftwareOptions, anyJSON: AnyJSON) {
            self.serviceSoftwareOptions = serviceSoftwareOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.serviceSoftwareOptions = try values.decode(AmazonOpenSearchAPI.ServiceSoftwareOptions.self, forKey: "serviceSoftwareOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(serviceSoftwareOptions, forKey: "serviceSoftwareOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(serviceSoftwareOptions: ServiceSoftwareOptions? = nil) {
        self.serviceSoftwareOptions = serviceSoftwareOptions
    }

    private enum CodingKeys: String, CodingKey {
        case serviceSoftwareOptions = "ServiceSoftwareOptions"
    }
}

/// The result of a <code>CreateDomain</code> operation. Contains the status of the newly created Amazon OpenSearch Service domain.
public struct CreateDomainResponse: Codable {
    public var domainStatus: DomainStatus?

    public final class DomainStatus: Codable {
        /// The current status of a domain.
        public var domainStatus: AmazonOpenSearchAPI.DomainStatus
        /// The status of the newly created domain.
        public var anyJSON: AnyJSON

        public init(domainStatus: AmazonOpenSearchAPI.DomainStatus, anyJSON: AnyJSON) {
            self.domainStatus = domainStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainStatus = try values.decode(AmazonOpenSearchAPI.DomainStatus.self, forKey: "domainStatus")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainStatus, forKey: "domainStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(domainStatus: DomainStatus? = nil) {
        self.domainStatus = domainStatus
    }

    private enum CodingKeys: String, CodingKey {
        case domainStatus = "DomainStatus"
    }
}

public enum OpenSearchPartitionInstanceType: String, Codable, CaseIterable {
    case m3MediumSearch = "m3.medium.search"
    case m3LargeSearch = "m3.large.search"
    case m3XlargeSearch = "m3.xlarge.search"
    case m32xlargeSearch = "m3.2xlarge.search"
    case m4LargeSearch = "m4.large.search"
    case m4XlargeSearch = "m4.xlarge.search"
    case m42xlargeSearch = "m4.2xlarge.search"
    case m44xlargeSearch = "m4.4xlarge.search"
    case m410xlargeSearch = "m4.10xlarge.search"
    case m5LargeSearch = "m5.large.search"
    case m5XlargeSearch = "m5.xlarge.search"
    case m52xlargeSearch = "m5.2xlarge.search"
    case m54xlargeSearch = "m5.4xlarge.search"
    case m512xlargeSearch = "m5.12xlarge.search"
    case m524xlargeSearch = "m5.24xlarge.search"
    case r5LargeSearch = "r5.large.search"
    case r5XlargeSearch = "r5.xlarge.search"
    case r52xlargeSearch = "r5.2xlarge.search"
    case r54xlargeSearch = "r5.4xlarge.search"
    case r512xlargeSearch = "r5.12xlarge.search"
    case r524xlargeSearch = "r5.24xlarge.search"
    case c5LargeSearch = "c5.large.search"
    case c5XlargeSearch = "c5.xlarge.search"
    case c52xlargeSearch = "c5.2xlarge.search"
    case c54xlargeSearch = "c5.4xlarge.search"
    case c59xlargeSearch = "c5.9xlarge.search"
    case c518xlargeSearch = "c5.18xlarge.search"
    case t3NanoSearch = "t3.nano.search"
    case t3MicroSearch = "t3.micro.search"
    case t3SmallSearch = "t3.small.search"
    case t3MediumSearch = "t3.medium.search"
    case t3LargeSearch = "t3.large.search"
    case t3XlargeSearch = "t3.xlarge.search"
    case t32xlargeSearch = "t3.2xlarge.search"
    case ultrawarm1MediumSearch = "ultrawarm1.medium.search"
    case ultrawarm1LargeSearch = "ultrawarm1.large.search"
    case ultrawarm1XlargeSearch = "ultrawarm1.xlarge.search"
    case t2MicroSearch = "t2.micro.search"
    case t2SmallSearch = "t2.small.search"
    case t2MediumSearch = "t2.medium.search"
    case r3LargeSearch = "r3.large.search"
    case r3XlargeSearch = "r3.xlarge.search"
    case r32xlargeSearch = "r3.2xlarge.search"
    case r34xlargeSearch = "r3.4xlarge.search"
    case r38xlargeSearch = "r3.8xlarge.search"
    case i2XlargeSearch = "i2.xlarge.search"
    case i22xlargeSearch = "i2.2xlarge.search"
    case d2XlargeSearch = "d2.xlarge.search"
    case d22xlargeSearch = "d2.2xlarge.search"
    case d24xlargeSearch = "d2.4xlarge.search"
    case d28xlargeSearch = "d2.8xlarge.search"
    case c4LargeSearch = "c4.large.search"
    case c4XlargeSearch = "c4.xlarge.search"
    case c42xlargeSearch = "c4.2xlarge.search"
    case c44xlargeSearch = "c4.4xlarge.search"
    case c48xlargeSearch = "c4.8xlarge.search"
    case r4LargeSearch = "r4.large.search"
    case r4XlargeSearch = "r4.xlarge.search"
    case r42xlargeSearch = "r4.2xlarge.search"
    case r44xlargeSearch = "r4.4xlarge.search"
    case r48xlargeSearch = "r4.8xlarge.search"
    case r416xlargeSearch = "r4.16xlarge.search"
    case i3LargeSearch = "i3.large.search"
    case i3XlargeSearch = "i3.xlarge.search"
    case i32xlargeSearch = "i3.2xlarge.search"
    case i34xlargeSearch = "i3.4xlarge.search"
    case i38xlargeSearch = "i3.8xlarge.search"
    case i316xlargeSearch = "i3.16xlarge.search"
    case r6gLargeSearch = "r6g.large.search"
    case r6gXlargeSearch = "r6g.xlarge.search"
    case r6g2xlargeSearch = "r6g.2xlarge.search"
    case r6g4xlargeSearch = "r6g.4xlarge.search"
    case r6g8xlargeSearch = "r6g.8xlarge.search"
    case r6g12xlargeSearch = "r6g.12xlarge.search"
    case m6gLargeSearch = "m6g.large.search"
    case m6gXlargeSearch = "m6g.xlarge.search"
    case m6g2xlargeSearch = "m6g.2xlarge.search"
    case m6g4xlargeSearch = "m6g.4xlarge.search"
    case m6g8xlargeSearch = "m6g.8xlarge.search"
    case m6g12xlargeSearch = "m6g.12xlarge.search"
    case c6gLargeSearch = "c6g.large.search"
    case c6gXlargeSearch = "c6g.xlarge.search"
    case c6g2xlargeSearch = "c6g.2xlarge.search"
    case c6g4xlargeSearch = "c6g.4xlarge.search"
    case c6g8xlargeSearch = "c6g.8xlarge.search"
    case c6g12xlargeSearch = "c6g.12xlarge.search"
    case r6gdLargeSearch = "r6gd.large.search"
    case r6gdXlargeSearch = "r6gd.xlarge.search"
    case r6gd2xlargeSearch = "r6gd.2xlarge.search"
    case r6gd4xlargeSearch = "r6gd.4xlarge.search"
    case r6gd8xlargeSearch = "r6gd.8xlarge.search"
    case r6gd12xlargeSearch = "r6gd.12xlarge.search"
    case r6gd16xlargeSearch = "r6gd.16xlarge.search"
    case t4gSmallSearch = "t4g.small.search"
    case t4gMediumSearch = "t4g.medium.search"
}

/// The zone awareness configuration for the domain cluster, such as the number of availability zones.
public struct ZoneAwarenessConfig: Codable {
    public var availabilityZoneCount: AvailabilityZoneCount?

    public struct AvailabilityZoneCount: Codable {
        public var int: Int
        /// An integer value to indicate the number of availability zones for a domain when zone awareness is enabled. This should be equal to number of subnets if VPC endpoints is enabled.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(availabilityZoneCount: AvailabilityZoneCount? = nil) {
        self.availabilityZoneCount = availabilityZoneCount
    }

    private enum CodingKeys: String, CodingKey {
        case availabilityZoneCount = "AvailabilityZoneCount"
    }
}

public enum OpenSearchWarmPartitionInstanceType: String, Codable, CaseIterable {
    case ultrawarm1MediumSearch = "ultrawarm1.medium.search"
    case ultrawarm1LargeSearch = "ultrawarm1.large.search"
    case ultrawarm1XlargeSearch = "ultrawarm1.xlarge.search"
}

/// Specifies the configuration for cold storage options such as enabled
public struct ColdStorageOptions: Codable {
    public var enabled: Enabled

    public struct Enabled: Codable {
        public var isBool: Bool
        /// Enable cold storage option. Accepted values true or false
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(enabled: Enabled) {
        self.enabled = enabled
    }

    private enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }
}

/// The type of EBS volume, standard, gp2, or io1. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/opensearch-createupdatedomains.html#opensearch-createdomain-configure-ebs" target="_blank">Configuring EBS-based Storage</a> for more information.
public enum VolumeType: String, Codable, CaseIterable {
    case standard
    case gp2
    case io1
}

/// Log Publishing option that is set for a given domain. <br/>Attributes and their details: <ul> <li>CloudWatchLogsLogGroupArn: ARN of the Cloudwatch log group to publish logs to.</li> <li>Enabled: Whether the log publishing for a given log type is enabled or not.</li> </ul>
public struct LogPublishingOption: Codable {
    /// ARN of the Cloudwatch log group to publish logs to.
    public var cloudWatchLogsLogGroupArn: String?
    public var enabled: Enabled?

    public struct Enabled: Codable {
        public var isBool: Bool
        /// Whether the given log publishing option is enabled or not.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(cloudWatchLogsLogGroupArn: String? = nil, enabled: Enabled? = nil) {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.enabled = enabled
    }

    private enum CodingKeys: String, CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case enabled = "Enabled"
    }
}

public enum TLSSecurityPolicy: String, Codable, CaseIterable {
    case policyMinTLS10201907 = "Policy-Min-TLS-1-0-2019-07"
    case policyMinTLS12201907 = "Policy-Min-TLS-1-2-2019-07"
}

/// Credentials for the master user: username and password, ARN, or both.
public struct MasterUserOptions: Codable {
    public var masterUserARN: MasterUserARN?
    public var masterUserName: MasterUserName?
    public var masterUserPassword: MasterUserPassword?

    public struct MasterUserARN: Codable {
        /// The Amazon Resource Name (ARN) of the domain. See <a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/index.html" target="_blank">Identifiers for IAM Entities </a> in <i>Using AWS Identity and Access Management</i> for more information.
        public var string: String
        /// ARN for the master user (if IAM is enabled).
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MasterUserName: Codable {
        public var string: String
        /// The master user's username, which is stored in the Amazon OpenSearch Service domain's internal database.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MasterUserPassword: Codable {
        public var string: String
        /// The master user's password, which is stored in the Amazon OpenSearch Service domain's internal database.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(masterUserARN: MasterUserARN? = nil, masterUserName: MasterUserName? = nil, masterUserPassword: MasterUserPassword? = nil) {
        self.masterUserARN = masterUserARN
        self.masterUserName = masterUserName
        self.masterUserPassword = masterUserPassword
    }

    private enum CodingKeys: String, CodingKey {
        case masterUserARN = "MasterUserARN"
        case masterUserName = "MasterUserName"
        case masterUserPassword = "MasterUserPassword"
    }
}

/// The SAML application configuration for the domain.
public struct SAMLOptionsInput: Codable {
    public var enabled: Enabled?
    public var idp: Idp?
    public var masterUserName: MasterUserName?
    public var masterBackendRole: MasterBackendRole?
    public var subjectKey: SubjectKey?
    public var rolesKey: RolesKey?
    public var sessionTimeoutMinutes: SessionTimeoutMinutes?

    public struct Enabled: Codable {
        public var isBool: Bool
        /// True if SAML is enabled.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Idp: Codable {
        /// The SAML identity povider's information.
        public var sAMLIdp: SAMLIdp
        /// The SAML Identity Provider's information.
        public var anyJSON: AnyJSON

        public init(sAMLIdp: SAMLIdp, anyJSON: AnyJSON) {
            self.sAMLIdp = sAMLIdp
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.sAMLIdp = try SAMLIdp(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(sAMLIdp, forKey: "sAMLIdp")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MasterUserName: Codable {
        public var string: String
        /// The SAML master username, which is stored in the Amazon OpenSearch Service domain's internal database.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MasterBackendRole: Codable {
        public var string: String
        /// The backend role that the SAML master user is mapped to.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SubjectKey: Codable {
        public var string: String
        /// Element of the SAML assertion to use for username. Default is NameID.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct RolesKey: Codable {
        public var string: String
        /// Element of the SAML assertion to use for backend roles. Default is roles.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SessionTimeoutMinutes: Codable {
        public var int: Int
        /// The duration, in minutes, after which a user session becomes inactive. Acceptable values are between 1 and 1440, and the default value is 60.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(enabled: Enabled? = nil, idp: Idp? = nil, masterUserName: MasterUserName? = nil, masterBackendRole: MasterBackendRole? = nil, subjectKey: SubjectKey? = nil, rolesKey: RolesKey? = nil, sessionTimeoutMinutes: SessionTimeoutMinutes? = nil) {
        self.enabled = enabled
        self.idp = idp
        self.masterUserName = masterUserName
        self.masterBackendRole = masterBackendRole
        self.subjectKey = subjectKey
        self.rolesKey = rolesKey
        self.sessionTimeoutMinutes = sessionTimeoutMinutes
    }

    private enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case idp = "Idp"
        case masterUserName = "MasterUserName"
        case masterBackendRole = "MasterBackendRole"
        case subjectKey = "SubjectKey"
        case rolesKey = "RolesKey"
        case sessionTimeoutMinutes = "SessionTimeoutMinutes"
    }
}

/// The Auto-Tune desired state. Valid values are ENABLED and DISABLED.
public enum AutoTuneDesiredState: String, Codable, CaseIterable {
    case enabled = "ENABLED"
    case disabled = "DISABLED"
}

/// The result of a <code> <a>CreateOutboundConnection</a> </code> request. Contains the details about the newly created cross-cluster connection.
public struct CreateOutboundConnectionResponse: Codable {
    public var localDomainInfo: LocalDomainInfo?
    public var remoteDomainInfo: RemoteDomainInfo?
    public var connectionAlias: ConnectionAlias?
    public var connectionStatus: ConnectionStatus?
    public var connectionID: ConnectionID?

    public struct LocalDomainInfo: Codable {
        public var domainInformationContainer: DomainInformationContainer
        /// The <code> <a>AWSDomainInformation</a> </code> for the local OpenSearch domain.
        public var anyJSON: AnyJSON

        public init(domainInformationContainer: DomainInformationContainer, anyJSON: AnyJSON) {
            self.domainInformationContainer = domainInformationContainer
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.domainInformationContainer = try DomainInformationContainer(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainInformationContainer, forKey: "domainInformationContainer")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct RemoteDomainInfo: Codable {
        public var domainInformationContainer: DomainInformationContainer
        /// The <code> <a>AWSDomainInformation</a> </code> for the remote OpenSearch domain.
        public var anyJSON: AnyJSON

        public init(domainInformationContainer: DomainInformationContainer, anyJSON: AnyJSON) {
            self.domainInformationContainer = domainInformationContainer
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.domainInformationContainer = try DomainInformationContainer(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainInformationContainer, forKey: "domainInformationContainer")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class ConnectionAlias: Codable {
        public var connectionAlias: AmazonOpenSearchAPI.ConnectionAlias
        /// The connection alias provided during the create connection request.
        public var anyJSON: AnyJSON

        public init(connectionAlias: AmazonOpenSearchAPI.ConnectionAlias, anyJSON: AnyJSON) {
            self.connectionAlias = connectionAlias
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.connectionAlias = try values.decode(AmazonOpenSearchAPI.ConnectionAlias.self, forKey: "connectionAlias")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(connectionAlias, forKey: "connectionAlias")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ConnectionStatus: Codable {
        /// The connection status of an outbound cross-cluster connection.
        public var outboundConnectionStatus: OutboundConnectionStatus
        /// The <code> <a>OutboundConnectionStatus</a> </code> for the newly created connection.
        public var anyJSON: AnyJSON

        public init(outboundConnectionStatus: OutboundConnectionStatus, anyJSON: AnyJSON) {
            self.outboundConnectionStatus = outboundConnectionStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.outboundConnectionStatus = try OutboundConnectionStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(outboundConnectionStatus, forKey: "outboundConnectionStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class ConnectionID: Codable {
        public var connectionID: AmazonOpenSearchAPI.ConnectionID
        /// The unique ID for the created outbound connection, which is used for subsequent operations on the connection.
        public var anyJSON: AnyJSON

        public init(connectionID: AmazonOpenSearchAPI.ConnectionID, anyJSON: AnyJSON) {
            self.connectionID = connectionID
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.connectionID = try values.decode(AmazonOpenSearchAPI.ConnectionID.self, forKey: "connectionID")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(connectionID, forKey: "connectionID")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(localDomainInfo: LocalDomainInfo? = nil, remoteDomainInfo: RemoteDomainInfo? = nil, connectionAlias: ConnectionAlias? = nil, connectionStatus: ConnectionStatus? = nil, connectionID: ConnectionID? = nil) {
        self.localDomainInfo = localDomainInfo
        self.remoteDomainInfo = remoteDomainInfo
        self.connectionAlias = connectionAlias
        self.connectionStatus = connectionStatus
        self.connectionID = connectionID
    }

    private enum CodingKeys: String, CodingKey {
        case localDomainInfo = "LocalDomainInfo"
        case remoteDomainInfo = "RemoteDomainInfo"
        case connectionAlias = "ConnectionAlias"
        case connectionStatus = "ConnectionStatus"
        case connectionID = "ConnectionId"
    }
}

public struct AWSDomainInformation: Codable {
    public var ownerID: String?
    /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    public var domainName: String
    public var region: String?

    public init(ownerID: String? = nil, domainName: String, region: String? = nil) {
        self.ownerID = ownerID
        self.domainName = domainName
        self.region = region
    }

    private enum CodingKeys: String, CodingKey {
        case ownerID = "OwnerId"
        case domainName = "DomainName"
        case region = "Region"
    }
}

/// Container for the response returned by the <code> <a>CreatePackage</a> </code> operation.
public struct CreatePackageResponse: Codable {
    public var packageDetails: PackageDetails?

    public final class PackageDetails: Codable {
        /// Basic information about a package.
        public var packageDetails: AmazonOpenSearchAPI.PackageDetails
        /// Information about the package.
        public var anyJSON: AnyJSON

        public init(packageDetails: AmazonOpenSearchAPI.PackageDetails, anyJSON: AnyJSON) {
            self.packageDetails = packageDetails
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageDetails = try values.decode(AmazonOpenSearchAPI.PackageDetails.self, forKey: "packageDetails")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageDetails, forKey: "packageDetails")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(packageDetails: PackageDetails? = nil) {
        self.packageDetails = packageDetails
    }

    private enum CodingKeys: String, CodingKey {
        case packageDetails = "PackageDetails"
    }
}

/// The result of a <code>DeleteDomain</code> request. Contains the status of the pending deletion, or a "domain not found" error if the domain and all of its resources have been deleted.
public struct DeleteDomainResponse: Codable {
    public var domainStatus: DomainStatus?

    public final class DomainStatus: Codable {
        /// The current status of a domain.
        public var domainStatus: AmazonOpenSearchAPI.DomainStatus
        /// The status of the domain being deleted.
        public var anyJSON: AnyJSON

        public init(domainStatus: AmazonOpenSearchAPI.DomainStatus, anyJSON: AnyJSON) {
            self.domainStatus = domainStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainStatus = try values.decode(AmazonOpenSearchAPI.DomainStatus.self, forKey: "domainStatus")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainStatus, forKey: "domainStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(domainStatus: DomainStatus? = nil) {
        self.domainStatus = domainStatus
    }

    private enum CodingKeys: String, CodingKey {
        case domainStatus = "DomainStatus"
    }
}

/// The result of a <code> <a>DeleteInboundConnection</a> </code> operation. Contains details about the deleted inbound connection.
public struct DeleteInboundConnectionResponse: Codable {
    public var connection: Connection?

    public struct Connection: Codable {
        /// Details of an inbound connection.
        public var inboundConnection: InboundConnection
        /// The <code> <a>InboundConnection</a> </code> of the deleted inbound connection.
        public var anyJSON: AnyJSON

        public init(inboundConnection: InboundConnection, anyJSON: AnyJSON) {
            self.inboundConnection = inboundConnection
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.inboundConnection = try InboundConnection(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(inboundConnection, forKey: "inboundConnection")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(connection: Connection? = nil) {
        self.connection = connection
    }

    private enum CodingKeys: String, CodingKey {
        case connection = "Connection"
    }
}

/// The result of a <code> <a>DeleteOutboundConnection</a> </code> operation. Contains details about the deleted outbound connection.
public struct DeleteOutboundConnectionResponse: Codable {
    public var connection: Connection?

    public struct Connection: Codable {
        /// Specifies details about an outbound connection.
        public var outboundConnection: OutboundConnection
        /// The <code> <a>OutboundConnection</a> </code> of the deleted outbound connection.
        public var anyJSON: AnyJSON

        public init(outboundConnection: OutboundConnection, anyJSON: AnyJSON) {
            self.outboundConnection = outboundConnection
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.outboundConnection = try OutboundConnection(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(outboundConnection, forKey: "outboundConnection")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(connection: Connection? = nil) {
        self.connection = connection
    }

    private enum CodingKeys: String, CodingKey {
        case connection = "Connection"
    }
}

/// Container for the response parameters to the <code> <a>DeletePackage</a> </code> operation.
public struct DeletePackageResponse: Codable {
    public var packageDetails: PackageDetails?

    public final class PackageDetails: Codable {
        /// Basic information about a package.
        public var packageDetails: AmazonOpenSearchAPI.PackageDetails
        /// <code>PackageDetails</code>
        public var anyJSON: AnyJSON

        public init(packageDetails: AmazonOpenSearchAPI.PackageDetails, anyJSON: AnyJSON) {
            self.packageDetails = packageDetails
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageDetails = try values.decode(AmazonOpenSearchAPI.PackageDetails.self, forKey: "packageDetails")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageDetails, forKey: "packageDetails")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(packageDetails: PackageDetails? = nil) {
        self.packageDetails = packageDetails
    }

    private enum CodingKeys: String, CodingKey {
        case packageDetails = "PackageDetails"
    }
}

/// The result of a <code>DescribeDomain</code> request. Contains the status of the domain specified in the request.
public struct DescribeDomainResponse: Codable {
    public var domainStatus: DomainStatus

    public final class DomainStatus: Codable {
        /// The current status of a domain.
        public var domainStatus: AmazonOpenSearchAPI.DomainStatus
        /// The current status of the domain.
        public var anyJSON: AnyJSON

        public init(domainStatus: AmazonOpenSearchAPI.DomainStatus, anyJSON: AnyJSON) {
            self.domainStatus = domainStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainStatus = try values.decode(AmazonOpenSearchAPI.DomainStatus.self, forKey: "domainStatus")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainStatus, forKey: "domainStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(domainStatus: DomainStatus) {
        self.domainStatus = domainStatus
    }

    private enum CodingKeys: String, CodingKey {
        case domainStatus = "DomainStatus"
    }
}

/// The result of a <code>DescribeDomainAutoTunes</code> request. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
public struct DescribeDomainAutoTunesResponse: Codable {
    public var autoTunes: AutoTunes?
    public var nextToken: NextToken?

    public struct AutoTunes: Codable {
        public var autoTunes: [AutoTune]
        /// The list of setting adjustments that Auto-Tune has made to the domain. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
        public var anyJSON: AnyJSON

        public init(autoTunes: [AutoTune], anyJSON: AnyJSON) {
            self.autoTunes = autoTunes
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.autoTunes = try values.decode([AutoTune].self, forKey: "autoTunes")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(autoTunes, forKey: "autoTunes")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class NextToken: Codable {
        /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
        public var nextToken: AmazonOpenSearchAPI.NextToken
        /// An identifier to allow retrieval of paginated results.
        public var anyJSON: AnyJSON

        public init(nextToken: AmazonOpenSearchAPI.NextToken, anyJSON: AnyJSON) {
            self.nextToken = nextToken
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.nextToken = try values.decode(AmazonOpenSearchAPI.NextToken.self, forKey: "nextToken")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(nextToken, forKey: "nextToken")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(autoTunes: AutoTunes? = nil, nextToken: NextToken? = nil) {
        self.autoTunes = autoTunes
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case autoTunes = "AutoTunes"
        case nextToken = "NextToken"
    }
}

/// The result of a <code>DescribeDomainConfig</code> request. Contains the configuration information of the requested domain.
public struct DescribeDomainConfigResponse: Codable {
    public var domainConfig: DomainConfig

    public final class DomainConfig: Codable {
        /// The configuration of a domain.
        public var domainConfig: AmazonOpenSearchAPI.DomainConfig
        /// The configuration information of the domain requested in the <code>DescribeDomainConfig</code> request.
        public var anyJSON: AnyJSON

        public init(domainConfig: AmazonOpenSearchAPI.DomainConfig, anyJSON: AnyJSON) {
            self.domainConfig = domainConfig
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainConfig = try values.decode(AmazonOpenSearchAPI.DomainConfig.self, forKey: "domainConfig")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainConfig, forKey: "domainConfig")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(domainConfig: DomainConfig) {
        self.domainConfig = domainConfig
    }

    private enum CodingKeys: String, CodingKey {
        case domainConfig = "DomainConfig"
    }
}

/// The result of a <code>DescribeDomains</code> request. Contains the status of the specified domains or all domains owned by the account.
public struct DescribeDomainsResponse: Codable {
    public var domainStatusList: DomainStatusList

    public final class DomainStatusList: Codable {
        /// A list that contains the status of each requested domain.
        public var domainStatusList: AmazonOpenSearchAPI.DomainStatusList
        /// The status of the domains requested in the <code>DescribeDomains</code> request.
        public var anyJSON: AnyJSON

        public init(domainStatusList: AmazonOpenSearchAPI.DomainStatusList, anyJSON: AnyJSON) {
            self.domainStatusList = domainStatusList
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainStatusList = try values.decode(AmazonOpenSearchAPI.DomainStatusList.self, forKey: "domainStatusList")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainStatusList, forKey: "domainStatusList")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(domainStatusList: DomainStatusList) {
        self.domainStatusList = domainStatusList
    }

    private enum CodingKeys: String, CodingKey {
        case domainStatusList = "DomainStatusList"
    }
}

/// The result of a <code> <a>DescribeInboundConnections</a> </code> request. Contains a list of connections matching the filter criteria.
public struct DescribeInboundConnectionsResponse: Codable {
    public var connections: Connections?
    public var nextToken: NextToken?

    public struct Connections: Codable {
        public var inboundConnections: [InboundConnection]
        /// A list of <code> <a>InboundConnection</a> </code> matching the specified filter criteria.
        public var anyJSON: AnyJSON

        public init(inboundConnections: [InboundConnection], anyJSON: AnyJSON) {
            self.inboundConnections = inboundConnections
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.inboundConnections = try values.decode([InboundConnection].self, forKey: "inboundConnections")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(inboundConnections, forKey: "inboundConnections")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class NextToken: Codable {
        /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
        public var nextToken: AmazonOpenSearchAPI.NextToken
        /// If more results are available and NextToken is present, make the next request to the same API with the received NextToken to paginate the remaining results.
        public var anyJSON: AnyJSON

        public init(nextToken: AmazonOpenSearchAPI.NextToken, anyJSON: AnyJSON) {
            self.nextToken = nextToken
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.nextToken = try values.decode(AmazonOpenSearchAPI.NextToken.self, forKey: "nextToken")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(nextToken, forKey: "nextToken")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(connections: Connections? = nil, nextToken: NextToken? = nil) {
        self.connections = connections
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case connections = "Connections"
        case nextToken = "NextToken"
    }
}

/// A filter used to limit results when describing inbound or outbound cross-cluster connections. Multiple values can be specified per filter. A cross-cluster connection must match at least one of the specified values for it to be returned from an operation.
public struct Filter: Codable {
    public var name: Name?
    public var values: Values?

    public struct Name: Codable {
        public var string: String
        /// The name of the filter.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Values: Codable {
        public var strings: [String]
        /// Contains one or more values for the filter.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(name: Name? = nil, values: Values? = nil) {
        self.name = name
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }
}

/// Container for the parameters received from the <code> <a>DescribeInstanceTypeLimits</a> </code> operation.
public struct DescribeInstanceTypeLimitsResponse: Codable {
    /// The role of a given instance and all applicable limits. The role performed by a given OpenSearch instance can be one of the following: <ul> <li>data: If the given InstanceType is used as a data node</li> <li>master: If the given InstanceType is used as a master node</li> <li>ultra_warm: If the given InstanceType is used as a warm node</li> </ul>
    public var limitsByRole: [String: Limits]?

    public init(limitsByRole: [String: Limits]? = nil) {
        self.limitsByRole = limitsByRole
    }

    private enum CodingKeys: String, CodingKey {
        case limitsByRole = "LimitsByRole"
    }
}

/// The result of a <code> <a>DescribeOutboundConnections</a> </code> request. Contains the list of connections matching the filter criteria.
public struct DescribeOutboundConnectionsResponse: Codable {
    public var connections: Connections?
    public var nextToken: NextToken?

    public struct Connections: Codable {
        public var outboundConnections: [OutboundConnection]
        /// A list of <code> <a>OutboundConnection</a> </code> matching the specified filter criteria.
        public var anyJSON: AnyJSON

        public init(outboundConnections: [OutboundConnection], anyJSON: AnyJSON) {
            self.outboundConnections = outboundConnections
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.outboundConnections = try values.decode([OutboundConnection].self, forKey: "outboundConnections")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(outboundConnections, forKey: "outboundConnections")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class NextToken: Codable {
        /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
        public var nextToken: AmazonOpenSearchAPI.NextToken
        /// If more results are available and NextToken is present, make the next request to the same API with the received NextToken to paginate the remaining results.
        public var anyJSON: AnyJSON

        public init(nextToken: AmazonOpenSearchAPI.NextToken, anyJSON: AnyJSON) {
            self.nextToken = nextToken
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.nextToken = try values.decode(AmazonOpenSearchAPI.NextToken.self, forKey: "nextToken")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(nextToken, forKey: "nextToken")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(connections: Connections? = nil, nextToken: NextToken? = nil) {
        self.connections = connections
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case connections = "Connections"
        case nextToken = "NextToken"
    }
}

/// Container for the response returned by the <code> <a>DescribePackages</a> </code> operation.
public struct DescribePackagesResponse: Codable {
    public var packageDetailsList: PackageDetailsList?
    public var nextToken: String?

    public final class PackageDetailsList: Codable {
        public var packageDetailsList: AmazonOpenSearchAPI.PackageDetailsList
        /// List of <code>PackageDetails</code> objects.
        public var anyJSON: AnyJSON

        public init(packageDetailsList: AmazonOpenSearchAPI.PackageDetailsList, anyJSON: AnyJSON) {
            self.packageDetailsList = packageDetailsList
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageDetailsList = try values.decode(AmazonOpenSearchAPI.PackageDetailsList.self, forKey: "packageDetailsList")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageDetailsList, forKey: "packageDetailsList")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(packageDetailsList: PackageDetailsList? = nil, nextToken: String? = nil) {
        self.packageDetailsList = packageDetailsList
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case packageDetailsList = "PackageDetailsList"
        case nextToken = "NextToken"
    }
}

/// A filter to apply to the <code>DescribePackage</code> response.
public struct DescribePackagesFilter: Codable {
    public var name: Name?
    public var value: Value?

    public struct Name: Codable {
        public var describePackagesFilterName: DescribePackagesFilterName
        /// Any field from <code>PackageDetails</code>.
        public var anyJSON: AnyJSON

        public init(describePackagesFilterName: DescribePackagesFilterName, anyJSON: AnyJSON) {
            self.describePackagesFilterName = describePackagesFilterName
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.describePackagesFilterName = try DescribePackagesFilterName(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(describePackagesFilterName, forKey: "describePackagesFilterName")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Value: Codable {
        public var strings: [String]
        /// A list of values for the specified field.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(name: Name? = nil, value: Value? = nil) {
        self.name = name
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }
}

/// Container for results from <code>DescribeReservedInstanceOfferings</code>
public struct DescribeReservedInstanceOfferingsResponse: Codable {
    public var nextToken: NextToken?
    public var reservedInstanceOfferings: ReservedInstanceOfferings?

    public final class NextToken: Codable {
        /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
        public var nextToken: AmazonOpenSearchAPI.NextToken
        /// Provides an identifier to allow retrieval of paginated results.
        public var anyJSON: AnyJSON

        public init(nextToken: AmazonOpenSearchAPI.NextToken, anyJSON: AnyJSON) {
            self.nextToken = nextToken
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.nextToken = try values.decode(AmazonOpenSearchAPI.NextToken.self, forKey: "nextToken")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(nextToken, forKey: "nextToken")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ReservedInstanceOfferings: Codable {
        public var reservedInstanceOfferings: [ReservedInstanceOffering]
        /// List of reserved OpenSearch instance offerings
        public var anyJSON: AnyJSON

        public init(reservedInstanceOfferings: [ReservedInstanceOffering], anyJSON: AnyJSON) {
            self.reservedInstanceOfferings = reservedInstanceOfferings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.reservedInstanceOfferings = try values.decode([ReservedInstanceOffering].self, forKey: "reservedInstanceOfferings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(reservedInstanceOfferings, forKey: "reservedInstanceOfferings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(nextToken: NextToken? = nil, reservedInstanceOfferings: ReservedInstanceOfferings? = nil) {
        self.nextToken = nextToken
        self.reservedInstanceOfferings = reservedInstanceOfferings
    }

    private enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case reservedInstanceOfferings = "ReservedInstanceOfferings"
    }
}

/// Container for results from <code>DescribeReservedInstances</code>
public struct DescribeReservedInstancesResponse: Codable {
    public var nextToken: NextToken?
    public var reservedInstances: ReservedInstances?

    public struct NextToken: Codable {
        public var string: String
        /// Provides an identifier to allow retrieval of paginated results.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ReservedInstances: Codable {
        public var reservedInstances: [ReservedInstance]
        /// List of reserved OpenSearch instances.
        public var anyJSON: AnyJSON

        public init(reservedInstances: [ReservedInstance], anyJSON: AnyJSON) {
            self.reservedInstances = reservedInstances
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.reservedInstances = try values.decode([ReservedInstance].self, forKey: "reservedInstances")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(reservedInstances, forKey: "reservedInstances")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(nextToken: NextToken? = nil, reservedInstances: ReservedInstances? = nil) {
        self.nextToken = nextToken
        self.reservedInstances = reservedInstances
    }

    private enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case reservedInstances = "ReservedInstances"
    }
}

/// Container for the response returned by <code> <a>DissociatePackage</a> </code> operation.
public struct DissociatePackageResponse: Codable {
    public var domainPackageDetails: DomainPackageDetails?

    public final class DomainPackageDetails: Codable {
        /// Information on a package associated with a domain.
        public var domainPackageDetails: AmazonOpenSearchAPI.DomainPackageDetails
        /// <code>DomainPackageDetails</code>
        public var anyJSON: AnyJSON

        public init(domainPackageDetails: AmazonOpenSearchAPI.DomainPackageDetails, anyJSON: AnyJSON) {
            self.domainPackageDetails = domainPackageDetails
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainPackageDetails = try values.decode(AmazonOpenSearchAPI.DomainPackageDetails.self, forKey: "domainPackageDetails")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainPackageDetails, forKey: "domainPackageDetails")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(domainPackageDetails: DomainPackageDetails? = nil) {
        self.domainPackageDetails = domainPackageDetails
    }

    private enum CodingKeys: String, CodingKey {
        case domainPackageDetails = "DomainPackageDetails"
    }
}

/// Container for the response returned by the <code> <a>GetCompatibleVersions</a> </code> operation.
public struct GetCompatibleVersionsResponse: Codable {
    public var compatibleVersions: CompatibleVersions?

    public struct CompatibleVersions: Codable {
        public var compatibleVersionsMaps: [CompatibleVersionsMap]
        /// A map of compatible OpenSearch versions returned as part of the <code> <a>GetCompatibleVersions</a> </code> operation.
        public var anyJSON: AnyJSON

        public init(compatibleVersionsMaps: [CompatibleVersionsMap], anyJSON: AnyJSON) {
            self.compatibleVersionsMaps = compatibleVersionsMaps
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.compatibleVersionsMaps = try values.decode([CompatibleVersionsMap].self, forKey: "compatibleVersionsMaps")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(compatibleVersionsMaps, forKey: "compatibleVersionsMaps")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(compatibleVersions: CompatibleVersions? = nil) {
        self.compatibleVersions = compatibleVersions
    }

    private enum CodingKeys: String, CodingKey {
        case compatibleVersions = "CompatibleVersions"
    }
}

/// Container for response returned by <code> <a>GetPackageVersionHistory</a> </code> operation.
public struct GetPackageVersionHistoryResponse: Codable {
    public var packageID: String?
    public var packageVersionHistoryList: PackageVersionHistoryList?
    public var nextToken: String?

    public final class PackageVersionHistoryList: Codable {
        public var packageVersionHistoryList: AmazonOpenSearchAPI.PackageVersionHistoryList
        /// List of <code>PackageVersionHistory</code> objects.
        public var anyJSON: AnyJSON

        public init(packageVersionHistoryList: AmazonOpenSearchAPI.PackageVersionHistoryList, anyJSON: AnyJSON) {
            self.packageVersionHistoryList = packageVersionHistoryList
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageVersionHistoryList = try values.decode(AmazonOpenSearchAPI.PackageVersionHistoryList.self, forKey: "packageVersionHistoryList")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageVersionHistoryList, forKey: "packageVersionHistoryList")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(packageID: String? = nil, packageVersionHistoryList: PackageVersionHistoryList? = nil, nextToken: String? = nil) {
        self.packageID = packageID
        self.packageVersionHistoryList = packageVersionHistoryList
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case packageID = "PackageID"
        case packageVersionHistoryList = "PackageVersionHistoryList"
        case nextToken = "NextToken"
    }
}

/// Container for the response returned by the <code> <a>GetUpgradeHistory</a> </code> operation.
public struct GetUpgradeHistoryResponse: Codable {
    public var upgradeHistories: UpgradeHistories?
    public var nextToken: NextToken?

    public struct UpgradeHistories: Codable {
        public var upgradeHistories: [UpgradeHistory]
        /// A list of <code> <a>UpgradeHistory</a> </code> objects corresponding to each upgrade or upgrade eligibility check performed on a domain returned as part of the <code> <a>GetUpgradeHistoryResponse</a> </code> object.
        public var anyJSON: AnyJSON

        public init(upgradeHistories: [UpgradeHistory], anyJSON: AnyJSON) {
            self.upgradeHistories = upgradeHistories
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.upgradeHistories = try values.decode([UpgradeHistory].self, forKey: "upgradeHistories")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(upgradeHistories, forKey: "upgradeHistories")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NextToken: Codable {
        public var string: String
        /// Pagination token that needs to be supplied to the next call to get the next page of results.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(upgradeHistories: UpgradeHistories? = nil, nextToken: NextToken? = nil) {
        self.upgradeHistories = upgradeHistories
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case upgradeHistories = "UpgradeHistories"
        case nextToken = "NextToken"
    }
}

/// Container for the response returned by the <code> <a>GetUpgradeStatus</a> </code> operation.
public struct GetUpgradeStatusResponse: Codable {
    public var upgradeStep: UpgradeStep?
    public var stepStatus: StepStatus?
    public var upgradeName: UpgradeName?

    public final class UpgradeStep: Codable {
        public var upgradeStep: AmazonOpenSearchAPI.UpgradeStep
        /// One of three steps an upgrade or upgrade eligibility check goes through: <ul> <li>PreUpgradeCheck</li> <li>Snapshot</li> <li>Upgrade</li> </ul>
        public var anyJSON: AnyJSON

        public init(upgradeStep: AmazonOpenSearchAPI.UpgradeStep, anyJSON: AnyJSON) {
            self.upgradeStep = upgradeStep
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.upgradeStep = try values.decode(AmazonOpenSearchAPI.UpgradeStep.self, forKey: "upgradeStep")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(upgradeStep, forKey: "upgradeStep")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct StepStatus: Codable {
        public var upgradeStatus: UpgradeStatus
        /// One of four statuses an upgrade have, returned as part of the <code> <a>GetUpgradeStatusResponse</a> </code> object. The status can take one of the following values: <ul> <li>In Progress</li> <li>Succeeded</li> <li>Succeeded with Issues</li> <li>Failed</li> </ul>
        public var anyJSON: AnyJSON

        public init(upgradeStatus: UpgradeStatus, anyJSON: AnyJSON) {
            self.upgradeStatus = upgradeStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.upgradeStatus = try UpgradeStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(upgradeStatus, forKey: "upgradeStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class UpgradeName: Codable {
        public var upgradeName: AmazonOpenSearchAPI.UpgradeName
        /// A string that briefly describes the update.
        public var anyJSON: AnyJSON

        public init(upgradeName: AmazonOpenSearchAPI.UpgradeName, anyJSON: AnyJSON) {
            self.upgradeName = upgradeName
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.upgradeName = try values.decode(AmazonOpenSearchAPI.UpgradeName.self, forKey: "upgradeName")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(upgradeName, forKey: "upgradeName")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(upgradeStep: UpgradeStep? = nil, stepStatus: StepStatus? = nil, upgradeName: UpgradeName? = nil) {
        self.upgradeStep = upgradeStep
        self.stepStatus = stepStatus
        self.upgradeName = upgradeName
    }

    private enum CodingKeys: String, CodingKey {
        case upgradeStep = "UpgradeStep"
        case stepStatus = "StepStatus"
        case upgradeName = "UpgradeName"
    }
}

/// The result of a <code>ListDomainNames</code> operation. Contains the names of all domains owned by this account and their respective engine types.
public struct ListDomainNamesResponse: Codable {
    public var domainNames: DomainNames?

    public struct DomainNames: Codable {
        /// Contains the list of domain information.
        public var domainInfos: [DomainInfo]
        /// List of domain names and respective engine types.
        public var anyJSON: AnyJSON

        public init(domainInfos: [DomainInfo], anyJSON: AnyJSON) {
            self.domainInfos = domainInfos
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainInfos = try values.decode([DomainInfo].self, forKey: "domainInfos")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainInfos, forKey: "domainInfos")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(domainNames: DomainNames? = nil) {
        self.domainNames = domainNames
    }

    private enum CodingKeys: String, CodingKey {
        case domainNames = "DomainNames"
    }
}

/// Container for the response parameters to the <code> <a>ListDomainsForPackage</a> </code> operation.
public struct ListDomainsForPackageResponse: Codable {
    public var domainPackageDetailsList: DomainPackageDetailsList?
    public var nextToken: String?

    public final class DomainPackageDetailsList: Codable {
        public var domainPackageDetailsList: AmazonOpenSearchAPI.DomainPackageDetailsList
        /// List of <code>DomainPackageDetails</code> objects.
        public var anyJSON: AnyJSON

        public init(domainPackageDetailsList: AmazonOpenSearchAPI.DomainPackageDetailsList, anyJSON: AnyJSON) {
            self.domainPackageDetailsList = domainPackageDetailsList
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainPackageDetailsList = try values.decode(AmazonOpenSearchAPI.DomainPackageDetailsList.self, forKey: "domainPackageDetailsList")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainPackageDetailsList, forKey: "domainPackageDetailsList")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(domainPackageDetailsList: DomainPackageDetailsList? = nil, nextToken: String? = nil) {
        self.domainPackageDetailsList = domainPackageDetailsList
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case domainPackageDetailsList = "DomainPackageDetailsList"
        case nextToken = "NextToken"
    }
}

public struct ListInstanceTypeDetailsResponse: Codable {
    public var instanceTypeDetails: [InstanceTypeDetails]?
    /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
    public var nextToken: String?

    public init(instanceTypeDetails: [InstanceTypeDetails]? = nil, nextToken: String? = nil) {
        self.instanceTypeDetails = instanceTypeDetails
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case instanceTypeDetails = "InstanceTypeDetails"
        case nextToken = "NextToken"
    }
}

/// Container for the response parameters to the <code> <a>ListPackagesForDomain</a> </code> operation.
public struct ListPackagesForDomainResponse: Codable {
    public var domainPackageDetailsList: DomainPackageDetailsList?
    public var nextToken: NextToken?

    public final class DomainPackageDetailsList: Codable {
        public var domainPackageDetailsList: AmazonOpenSearchAPI.DomainPackageDetailsList
        /// List of <code>DomainPackageDetails</code> objects.
        public var anyJSON: AnyJSON

        public init(domainPackageDetailsList: AmazonOpenSearchAPI.DomainPackageDetailsList, anyJSON: AnyJSON) {
            self.domainPackageDetailsList = domainPackageDetailsList
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainPackageDetailsList = try values.decode(AmazonOpenSearchAPI.DomainPackageDetailsList.self, forKey: "domainPackageDetailsList")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainPackageDetailsList, forKey: "domainPackageDetailsList")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NextToken: Codable {
        public var string: String
        /// Pagination token to supply to the next call to get the next page of results.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(domainPackageDetailsList: DomainPackageDetailsList? = nil, nextToken: NextToken? = nil) {
        self.domainPackageDetailsList = domainPackageDetailsList
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case domainPackageDetailsList = "DomainPackageDetailsList"
        case nextToken = "NextToken"
    }
}

/// The result of a <code>ListTags</code> operation. Contains tags for all requested domains.
public struct ListTagsResponse: Codable {
    public var tagList: TagList?

    public final class TagList: Codable {
        /// A list of <code>Tag</code>.
        public var tagList: AmazonOpenSearchAPI.TagList
        /// List of <code>Tag</code> for the requested domain.
        public var anyJSON: AnyJSON

        public init(tagList: AmazonOpenSearchAPI.TagList, anyJSON: AnyJSON) {
            self.tagList = tagList
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.tagList = try values.decode(AmazonOpenSearchAPI.TagList.self, forKey: "tagList")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(tagList, forKey: "tagList")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(tagList: TagList? = nil) {
        self.tagList = tagList
    }

    private enum CodingKeys: String, CodingKey {
        case tagList = "TagList"
    }
}

/// Container for the parameters for response received from the <code> <a>ListVersions</a> </code> operation.
public struct ListVersionsResponse: Codable {
    /// List of supported OpenSearch versions.
    public var versions: [String]?
    /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
    public var nextToken: String?

    public init(versions: [String]? = nil, nextToken: String? = nil) {
        self.versions = versions
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case versions = "Versions"
        case nextToken = "NextToken"
    }
}

/// Represents the output of a <code>PurchaseReservedInstanceOffering</code> operation.
public struct PurchaseReservedInstanceOfferingResponse: Codable {
    public var reservedInstanceID: ReservedInstanceID?
    public var reservationName: ReservationName?

    public struct ReservedInstanceID: Codable {
        public var string: String
        /// Details of the reserved OpenSearch instance which was purchased.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ReservationName: Codable {
        public var string: String
        /// The customer-specified identifier used to track this reservation.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(reservedInstanceID: ReservedInstanceID? = nil, reservationName: ReservationName? = nil) {
        self.reservedInstanceID = reservedInstanceID
        self.reservationName = reservationName
    }

    private enum CodingKeys: String, CodingKey {
        case reservedInstanceID = "ReservedInstanceId"
        case reservationName = "ReservationName"
    }
}

/// The result of a <code> <a>RejectInboundConnection</a> </code> operation. Contains details about the rejected inbound connection.
public struct RejectInboundConnectionResponse: Codable {
    public var connection: Connection?

    public struct Connection: Codable {
        /// Details of an inbound connection.
        public var inboundConnection: InboundConnection
        /// The <code> <a>InboundConnection</a> </code> of the rejected inbound connection.
        public var anyJSON: AnyJSON

        public init(inboundConnection: InboundConnection, anyJSON: AnyJSON) {
            self.inboundConnection = inboundConnection
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.inboundConnection = try InboundConnection(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(inboundConnection, forKey: "inboundConnection")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(connection: Connection? = nil) {
        self.connection = connection
    }

    private enum CodingKeys: String, CodingKey {
        case connection = "Connection"
    }
}

/// The result of a <code>StartServiceSoftwareUpdate</code> operation. Contains the status of the update.
public struct StartServiceSoftwareUpdateResponse: Codable {
    public var serviceSoftwareOptions: ServiceSoftwareOptions?

    public final class ServiceSoftwareOptions: Codable {
        /// The current options of an domain service software options.
        public var serviceSoftwareOptions: AmazonOpenSearchAPI.ServiceSoftwareOptions
        /// The current status of the OpenSearch service software update.
        public var anyJSON: AnyJSON

        public init(serviceSoftwareOptions: AmazonOpenSearchAPI.ServiceSoftwareOptions, anyJSON: AnyJSON) {
            self.serviceSoftwareOptions = serviceSoftwareOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.serviceSoftwareOptions = try values.decode(AmazonOpenSearchAPI.ServiceSoftwareOptions.self, forKey: "serviceSoftwareOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(serviceSoftwareOptions, forKey: "serviceSoftwareOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(serviceSoftwareOptions: ServiceSoftwareOptions? = nil) {
        self.serviceSoftwareOptions = serviceSoftwareOptions
    }

    private enum CodingKeys: String, CodingKey {
        case serviceSoftwareOptions = "ServiceSoftwareOptions"
    }
}

/// The result of an <code>UpdateDomain</code> request. Contains the status of the domain being updated.
public struct UpdateDomainConfigResponse: Codable {
    public var domainConfig: DomainConfig

    public final class DomainConfig: Codable {
        /// The configuration of a domain.
        public var domainConfig: AmazonOpenSearchAPI.DomainConfig
        /// The status of the updated domain.
        public var anyJSON: AnyJSON

        public init(domainConfig: AmazonOpenSearchAPI.DomainConfig, anyJSON: AnyJSON) {
            self.domainConfig = domainConfig
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainConfig = try values.decode(AmazonOpenSearchAPI.DomainConfig.self, forKey: "domainConfig")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainConfig, forKey: "domainConfig")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(domainConfig: DomainConfig) {
        self.domainConfig = domainConfig
    }

    private enum CodingKeys: String, CodingKey {
        case domainConfig = "DomainConfig"
    }
}

/// The rollback state while disabling Auto-Tune for the domain. Valid values are NO_ROLLBACK and DEFAULT_ROLLBACK.
public enum RollbackOnDisable: String, Codable, CaseIterable {
    case noRollback = "NO_ROLLBACK"
    case defaultRollback = "DEFAULT_ROLLBACK"
}

/// Container for the response returned by the <code> <a>UpdatePackage</a> </code> operation.
public struct UpdatePackageResponse: Codable {
    public var packageDetails: PackageDetails?

    public final class PackageDetails: Codable {
        /// Basic information about a package.
        public var packageDetails: AmazonOpenSearchAPI.PackageDetails
        /// Information about the package.
        public var anyJSON: AnyJSON

        public init(packageDetails: AmazonOpenSearchAPI.PackageDetails, anyJSON: AnyJSON) {
            self.packageDetails = packageDetails
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageDetails = try values.decode(AmazonOpenSearchAPI.PackageDetails.self, forKey: "packageDetails")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageDetails, forKey: "packageDetails")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(packageDetails: PackageDetails? = nil) {
        self.packageDetails = packageDetails
    }

    private enum CodingKeys: String, CodingKey {
        case packageDetails = "PackageDetails"
    }
}

/// Container for response returned by <code> <a>UpgradeDomain</a> </code> operation.
public struct UpgradeDomainResponse: Codable {
    public var upgradeID: String?
    /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    public var domainName: String?
    public var targetVersion: TargetVersion?
    public var performCheckOnly: PerformCheckOnly?
    /// <p>Exposes select native OpenSearch configuration values from <code>opensearch.yml</code>. Currently, the following advanced options are available: </p> <ul> <li>Option to allow references to indices in an HTTP request body. Must be <code>false</code> when configuring access to individual sub-resources. By default, the value is <code>true</code>. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced cluster parameters </a> for more information. </li> <li>Option to specify the percentage of heap space allocated to field data. By default, this setting is unbounded. </li> </ul> <p>For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options"> Advanced cluster parameters</a>. </p>
    public var advancedOptions: [String: String]?

    public struct TargetVersion: Codable {
        public var string: String
        /// The version of OpenSearch that you intend to upgrade the domain to.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct PerformCheckOnly: Codable {
        public var isBool: Bool
        /// When true, indicates that an upgrade eligibility check needs to be performed. Does not actually perform the upgrade.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(upgradeID: String? = nil, domainName: String? = nil, targetVersion: TargetVersion? = nil, performCheckOnly: PerformCheckOnly? = nil, advancedOptions: [String: String]? = nil) {
        self.upgradeID = upgradeID
        self.domainName = domainName
        self.targetVersion = targetVersion
        self.performCheckOnly = performCheckOnly
        self.advancedOptions = advancedOptions
    }

    private enum CodingKeys: String, CodingKey {
        case upgradeID = "UpgradeId"
        case domainName = "DomainName"
        case targetVersion = "TargetVersion"
        case performCheckOnly = "PerformCheckOnly"
        case advancedOptions = "AdvancedOptions"
    }
}

/// Details of an inbound connection.
public struct InboundConnection: Codable {
    public var localDomainInfo: LocalDomainInfo?
    public var remoteDomainInfo: RemoteDomainInfo?
    public var connectionID: ConnectionID?
    public var connectionStatus: ConnectionStatus?

    public struct LocalDomainInfo: Codable {
        public var domainInformationContainer: DomainInformationContainer
        /// The <code> <a>AWSDomainInformation</a> </code> for the local OpenSearch domain.
        public var anyJSON: AnyJSON

        public init(domainInformationContainer: DomainInformationContainer, anyJSON: AnyJSON) {
            self.domainInformationContainer = domainInformationContainer
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.domainInformationContainer = try DomainInformationContainer(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainInformationContainer, forKey: "domainInformationContainer")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct RemoteDomainInfo: Codable {
        public var domainInformationContainer: DomainInformationContainer
        /// The <code> <a>AWSDomainInformation</a> </code> for the remote OpenSearch domain.
        public var anyJSON: AnyJSON

        public init(domainInformationContainer: DomainInformationContainer, anyJSON: AnyJSON) {
            self.domainInformationContainer = domainInformationContainer
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.domainInformationContainer = try DomainInformationContainer(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainInformationContainer, forKey: "domainInformationContainer")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class ConnectionID: Codable {
        public var connectionID: AmazonOpenSearchAPI.ConnectionID
        /// The connection ID for the inbound cross-cluster connection.
        public var anyJSON: AnyJSON

        public init(connectionID: AmazonOpenSearchAPI.ConnectionID, anyJSON: AnyJSON) {
            self.connectionID = connectionID
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.connectionID = try values.decode(AmazonOpenSearchAPI.ConnectionID.self, forKey: "connectionID")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(connectionID, forKey: "connectionID")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ConnectionStatus: Codable {
        /// The connection status of an inbound cross-cluster connection.
        public var inboundConnectionStatus: InboundConnectionStatus
        /// The <code> <a>InboundConnectionStatus</a> </code> for the outbound connection.
        public var anyJSON: AnyJSON

        public init(inboundConnectionStatus: InboundConnectionStatus, anyJSON: AnyJSON) {
            self.inboundConnectionStatus = inboundConnectionStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.inboundConnectionStatus = try InboundConnectionStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(inboundConnectionStatus, forKey: "inboundConnectionStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(localDomainInfo: LocalDomainInfo? = nil, remoteDomainInfo: RemoteDomainInfo? = nil, connectionID: ConnectionID? = nil, connectionStatus: ConnectionStatus? = nil) {
        self.localDomainInfo = localDomainInfo
        self.remoteDomainInfo = remoteDomainInfo
        self.connectionID = connectionID
        self.connectionStatus = connectionStatus
    }

    private enum CodingKeys: String, CodingKey {
        case localDomainInfo = "LocalDomainInfo"
        case remoteDomainInfo = "RemoteDomainInfo"
        case connectionID = "ConnectionId"
        case connectionStatus = "ConnectionStatus"
    }
}

/// Provides the current status of the entity.
public struct OptionStatus: Codable {
    public var creationDate: CreationDate
    public var updateDate: UpdateDate
    public var updateVersion: UpdateVersion?
    public var state: State
    public var pendingDeletion: PendingDeletion?

    public struct CreationDate: Codable {
        public var date: Date
        /// The timestamp of when the entity was created.
        public var anyJSON: AnyJSON

        public init(date: Date, anyJSON: AnyJSON) {
            self.date = date
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(Date.self, forKey: "date")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct UpdateDate: Codable {
        public var date: Date
        /// The timestamp of the last time the entity was updated.
        public var anyJSON: AnyJSON

        public init(date: Date, anyJSON: AnyJSON) {
            self.date = date
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(Date.self, forKey: "date")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct UpdateVersion: Codable {
        public var int: Int
        /// The latest version of the entity.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct State: Codable {
        /// <p>The state of a requested change. One of the following:</p> <ul> <li>Processing: The request change is still in progress.</li> <li>Active: The request change is processed and deployed to the domain.</li> </ul>
        public var optionState: OptionState
        /// Provides the <code>OptionState</code> for the domain.
        public var anyJSON: AnyJSON

        public init(optionState: OptionState, anyJSON: AnyJSON) {
            self.optionState = optionState
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.optionState = try OptionState(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(optionState, forKey: "optionState")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct PendingDeletion: Codable {
        public var isBool: Bool
        /// Indicates whether the domain is being deleted.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(creationDate: CreationDate, updateDate: UpdateDate, updateVersion: UpdateVersion? = nil, state: State, pendingDeletion: PendingDeletion? = nil) {
        self.creationDate = creationDate
        self.updateDate = updateDate
        self.updateVersion = updateVersion
        self.state = state
        self.pendingDeletion = pendingDeletion
    }

    private enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case updateDate = "UpdateDate"
        case updateVersion = "UpdateVersion"
        case state = "State"
        case pendingDeletion = "PendingDeletion"
    }
}

/// The configured access rules for the domain's document and search endpoints, and the current status of those rules.
public struct AccessPoliciesStatus: Codable {
    public var options: Options
    public var status: Status

    public struct Options: Codable {
        /// Access policy rules for a domain service endpoints. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-access-policies" target="_blank">Configuring access policies </a>. The maximum size of a policy document is 100 KB.
        public var string: String
        /// The access policy configured for the domain. Access policies can be resource-based, IP-based, or IAM-based. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-access-policies" target="_blank"> Configuring access policies</a>for more information.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        /// Provides the current status of the entity.
        public var optionStatus: OptionStatus
        /// The status of the access policy for the domain. See <code>OptionStatus</code> for the status information that's included.
        public var anyJSON: AnyJSON

        public init(optionStatus: OptionStatus, anyJSON: AnyJSON) {
            self.optionStatus = optionStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.optionStatus = try OptionStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(optionStatus, forKey: "optionStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(options: Options, status: Status) {
        self.options = options
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }
}

/// Container for the parameters to the <code> <a>AddTags</a> </code> operation. Specifies the tags to attach to the domain.
public struct AddTagsRequest: Codable {
    public var arn: Arn
    public var tagList: TagList

    public final class Arn: Codable {
        /// The Amazon Resource Name (ARN) of the domain. See <a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/index.html" target="_blank">Identifiers for IAM Entities </a> in <i>Using AWS Identity and Access Management</i> for more information.
        public var arn: AmazonOpenSearchAPI.Arn
        /// Specify the <code>ARN</code> of the domain you want to add tags to.
        public var anyJSON: AnyJSON

        public init(arn: AmazonOpenSearchAPI.Arn, anyJSON: AnyJSON) {
            self.arn = arn
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.arn = try values.decode(AmazonOpenSearchAPI.Arn.self, forKey: "arn")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(arn, forKey: "arn")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class TagList: Codable {
        /// A list of <code>Tag</code>.
        public var tagList: AmazonOpenSearchAPI.TagList
        /// List of <code>Tag</code> to add to the domain.
        public var anyJSON: AnyJSON

        public init(tagList: AmazonOpenSearchAPI.TagList, anyJSON: AnyJSON) {
            self.tagList = tagList
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.tagList = try values.decode(AmazonOpenSearchAPI.TagList.self, forKey: "tagList")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(tagList, forKey: "tagList")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(arn: Arn, tagList: TagList) {
        self.arn = arn
        self.tagList = tagList
    }

    private enum CodingKeys: String, CodingKey {
        case arn = "ARN"
        case tagList = "TagList"
    }
}

/// List of limits that are specific to a given InstanceType and for each of its <code> <a>InstanceRole</a> </code> .
public struct AdditionalLimit: Codable {
    public var limitName: LimitName?
    public var limitValues: LimitValues?

    public final class LimitName: Codable {
        public var limitName: AmazonOpenSearchAPI.LimitName
        /// Additional limit is specific to a given InstanceType and for each of its <code> <a>InstanceRole</a> </code> etc. <br/> Attributes and their details: <br/> <ul> <li>MaximumNumberOfDataNodesSupported</li> This attribute is present on the master node only to specify how much data nodes up to which given <code> <a>ESPartitionInstanceType</a> </code> can support as master node. <li>MaximumNumberOfDataNodesWithoutMasterNode</li> This attribute is present on data node only to specify how much data nodes of given <code> <a>ESPartitionInstanceType</a> </code> up to which you don't need any master nodes to govern them. </ul>
        public var anyJSON: AnyJSON

        public init(limitName: AmazonOpenSearchAPI.LimitName, anyJSON: AnyJSON) {
            self.limitName = limitName
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.limitName = try values.decode(AmazonOpenSearchAPI.LimitName.self, forKey: "limitName")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(limitName, forKey: "limitName")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct LimitValues: Codable {
        public var strings: [String]
        /// Value for a given <code> <a>AdditionalLimit$LimitName</a> </code> .
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(limitName: LimitName? = nil, limitValues: LimitValues? = nil) {
        self.limitName = limitName
        self.limitValues = limitValues
    }

    private enum CodingKeys: String, CodingKey {
        case limitName = "LimitName"
        case limitValues = "LimitValues"
    }
}

/// <p>Status of the advanced options for the specified domain. Currently, the following advanced options are available: </p> <ul> <li>Option to allow references to indices in an HTTP request body. Must be <code>false</code> when configuring access to individual sub-resources. By default, the value is <code>true</code>. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced cluster parameters </a> for more information. </li> <li>Option to specify the percentage of heap space allocated to field data. By default, this setting is unbounded. </li> </ul> <p>For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options"> Advanced cluster parameters</a>. </p>
public struct AdvancedOptionsStatus: Codable {
    public var options: Options
    public var status: Status

    public struct Options: Codable {
        /// <p>Exposes select native OpenSearch configuration values from <code>opensearch.yml</code>. Currently, the following advanced options are available: </p> <ul> <li>Option to allow references to indices in an HTTP request body. Must be <code>false</code> when configuring access to individual sub-resources. By default, the value is <code>true</code>. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced cluster parameters </a> for more information. </li> <li>Option to specify the percentage of heap space allocated to field data. By default, this setting is unbounded. </li> </ul> <p>For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options"> Advanced cluster parameters</a>. </p>
        public var stringString: [String: String]
        /// The status of advanced options for the specified domain.
        public var anyJSON: AnyJSON

        public init(stringString: [String: String], anyJSON: AnyJSON) {
            self.stringString = stringString
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.stringString = try values.decode([String: String].self, forKey: "stringString")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(stringString, forKey: "stringString")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        /// Provides the current status of the entity.
        public var optionStatus: OptionStatus
        /// The <code>OptionStatus</code> for advanced options for the specified domain.
        public var anyJSON: AnyJSON

        public init(optionStatus: OptionStatus, anyJSON: AnyJSON) {
            self.optionStatus = optionStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.optionStatus = try OptionStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(optionStatus, forKey: "optionStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(options: Options, status: Status) {
        self.options = options
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }
}

/// Describes the SAML application configured for the domain.
public struct SAMLOptionsOutput: Codable {
    public var enabled: Enabled?
    public var idp: Idp?
    public var subjectKey: SubjectKey?
    public var rolesKey: RolesKey?
    public var sessionTimeoutMinutes: SessionTimeoutMinutes?

    public struct Enabled: Codable {
        public var isBool: Bool
        /// True if SAML is enabled.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Idp: Codable {
        /// The SAML identity povider's information.
        public var sAMLIdp: SAMLIdp
        /// Describes the SAML identity provider's information.
        public var anyJSON: AnyJSON

        public init(sAMLIdp: SAMLIdp, anyJSON: AnyJSON) {
            self.sAMLIdp = sAMLIdp
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.sAMLIdp = try SAMLIdp(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(sAMLIdp, forKey: "sAMLIdp")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SubjectKey: Codable {
        public var string: String
        /// The key used for matching the SAML subject attribute.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct RolesKey: Codable {
        public var string: String
        /// The key used for matching the SAML roles attribute.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SessionTimeoutMinutes: Codable {
        public var int: Int
        /// The duration, in minutes, after which a user session becomes inactive.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(enabled: Enabled? = nil, idp: Idp? = nil, subjectKey: SubjectKey? = nil, rolesKey: RolesKey? = nil, sessionTimeoutMinutes: SessionTimeoutMinutes? = nil) {
        self.enabled = enabled
        self.idp = idp
        self.subjectKey = subjectKey
        self.rolesKey = rolesKey
        self.sessionTimeoutMinutes = sessionTimeoutMinutes
    }

    private enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case idp = "Idp"
        case subjectKey = "SubjectKey"
        case rolesKey = "RolesKey"
        case sessionTimeoutMinutes = "SessionTimeoutMinutes"
    }
}

/// The advanced security configuration: whether advanced security is enabled, whether the internal database option is enabled.
public struct AdvancedSecurityOptions: Codable {
    public var enabled: Enabled?
    public var internalUserDatabaseEnabled: InternalUserDatabaseEnabled?
    public var sAMLOptions: SAMLOptions?

    public struct Enabled: Codable {
        public var isBool: Bool
        /// True if advanced security is enabled.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct InternalUserDatabaseEnabled: Codable {
        public var isBool: Bool
        /// True if the internal user database is enabled.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SAMLOptions: Codable {
        /// Describes the SAML application configured for the domain.
        public var sAMLOptionsOutput: SAMLOptionsOutput
        /// Describes the SAML application configured for a domain.
        public var anyJSON: AnyJSON

        public init(sAMLOptionsOutput: SAMLOptionsOutput, anyJSON: AnyJSON) {
            self.sAMLOptionsOutput = sAMLOptionsOutput
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.sAMLOptionsOutput = try SAMLOptionsOutput(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(sAMLOptionsOutput, forKey: "sAMLOptionsOutput")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(enabled: Enabled? = nil, internalUserDatabaseEnabled: InternalUserDatabaseEnabled? = nil, sAMLOptions: SAMLOptions? = nil) {
        self.enabled = enabled
        self.internalUserDatabaseEnabled = internalUserDatabaseEnabled
        self.sAMLOptions = sAMLOptions
    }

    private enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case internalUserDatabaseEnabled = "InternalUserDatabaseEnabled"
        case sAMLOptions = "SAMLOptions"
    }
}

/// The advanced security configuration: whether advanced security is enabled, whether the internal database option is enabled, master username and password (if internal database is enabled), and master user ARN (if IAM is enabled).
public struct AdvancedSecurityOptionsInput: Codable {
    public var enabled: Enabled?
    public var internalUserDatabaseEnabled: InternalUserDatabaseEnabled?
    public var masterUserOptions: MasterUserOptions?
    public var sAMLOptions: SAMLOptions?

    public struct Enabled: Codable {
        public var isBool: Bool
        /// True if advanced security is enabled.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct InternalUserDatabaseEnabled: Codable {
        public var isBool: Bool
        /// True if the internal user database is enabled.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class MasterUserOptions: Codable {
        /// Credentials for the master user: username and password, ARN, or both.
        public var masterUserOptions: AmazonOpenSearchAPI.MasterUserOptions
        /// Credentials for the master user: username and password, ARN, or both.
        public var anyJSON: AnyJSON

        public init(masterUserOptions: AmazonOpenSearchAPI.MasterUserOptions, anyJSON: AnyJSON) {
            self.masterUserOptions = masterUserOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.masterUserOptions = try values.decode(AmazonOpenSearchAPI.MasterUserOptions.self, forKey: "masterUserOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(masterUserOptions, forKey: "masterUserOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SAMLOptions: Codable {
        /// The SAML application configuration for the domain.
        public var sAMLOptionsInput: SAMLOptionsInput
        /// The SAML application configuration for the domain.
        public var anyJSON: AnyJSON

        public init(sAMLOptionsInput: SAMLOptionsInput, anyJSON: AnyJSON) {
            self.sAMLOptionsInput = sAMLOptionsInput
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.sAMLOptionsInput = try SAMLOptionsInput(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(sAMLOptionsInput, forKey: "sAMLOptionsInput")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(enabled: Enabled? = nil, internalUserDatabaseEnabled: InternalUserDatabaseEnabled? = nil, masterUserOptions: MasterUserOptions? = nil, sAMLOptions: SAMLOptions? = nil) {
        self.enabled = enabled
        self.internalUserDatabaseEnabled = internalUserDatabaseEnabled
        self.masterUserOptions = masterUserOptions
        self.sAMLOptions = sAMLOptions
    }

    private enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case internalUserDatabaseEnabled = "InternalUserDatabaseEnabled"
        case masterUserOptions = "MasterUserOptions"
        case sAMLOptions = "SAMLOptions"
    }
}

/// The status of advanced security options for the specified domain.
public struct AdvancedSecurityOptionsStatus: Codable {
    public var options: Options
    public var status: Status

    public struct Options: Codable {
        /// The advanced security configuration: whether advanced security is enabled, whether the internal database option is enabled.
        public var advancedSecurityOptions: AdvancedSecurityOptions
        /// Advanced security options for the specified domain.
        public var anyJSON: AnyJSON

        public init(advancedSecurityOptions: AdvancedSecurityOptions, anyJSON: AnyJSON) {
            self.advancedSecurityOptions = advancedSecurityOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.advancedSecurityOptions = try AdvancedSecurityOptions(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(advancedSecurityOptions, forKey: "advancedSecurityOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        /// Provides the current status of the entity.
        public var optionStatus: OptionStatus
        /// Status of the advanced security options for the specified domain.
        public var anyJSON: AnyJSON

        public init(optionStatus: OptionStatus, anyJSON: AnyJSON) {
            self.optionStatus = optionStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.optionStatus = try OptionStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(optionStatus, forKey: "optionStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(options: Options, status: Status) {
        self.options = options
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }
}

/// Information on a package associated with a domain.
public struct DomainPackageDetails: Codable {
    public var packageID: PackageID?
    public var packageName: PackageName?
    public var packageType: PackageType?
    public var lastUpdated: LastUpdated?
    public var domainName: DomainName?
    public var domainPackageStatus: DomainPackageStatus?
    public var packageVersion: String?
    public var referencePath: ReferencePath?
    public var errorDetails: ErrorDetails?

    public final class PackageID: Codable {
        public var packageID: AmazonOpenSearchAPI.PackageID
        /// The internal ID of the package.
        public var anyJSON: AnyJSON

        public init(packageID: AmazonOpenSearchAPI.PackageID, anyJSON: AnyJSON) {
            self.packageID = packageID
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageID = try values.decode(AmazonOpenSearchAPI.PackageID.self, forKey: "packageID")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageID, forKey: "packageID")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class PackageName: Codable {
        public var packageName: AmazonOpenSearchAPI.PackageName
        /// User-specified name of the package.
        public var anyJSON: AnyJSON

        public init(packageName: AmazonOpenSearchAPI.PackageName, anyJSON: AnyJSON) {
            self.packageName = packageName
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageName = try values.decode(AmazonOpenSearchAPI.PackageName.self, forKey: "packageName")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageName, forKey: "packageName")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class PackageType: Codable {
        public var packageType: AmazonOpenSearchAPI.PackageType
        /// Currently supports only TXT-DICTIONARY.
        public var anyJSON: AnyJSON

        public init(packageType: AmazonOpenSearchAPI.PackageType, anyJSON: AnyJSON) {
            self.packageType = packageType
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageType = try values.decode(AmazonOpenSearchAPI.PackageType.self, forKey: "packageType")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageType, forKey: "packageType")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class LastUpdated: Codable {
        public var lastUpdated: AmazonOpenSearchAPI.LastUpdated
        /// The timestamp of the most recent update to the package association status.
        public var anyJSON: AnyJSON

        public init(lastUpdated: AmazonOpenSearchAPI.LastUpdated, anyJSON: AnyJSON) {
            self.lastUpdated = lastUpdated
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.lastUpdated = try values.decode(AmazonOpenSearchAPI.LastUpdated.self, forKey: "lastUpdated")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(lastUpdated, forKey: "lastUpdated")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class DomainName: Codable {
        /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
        public var domainName: AmazonOpenSearchAPI.DomainName
        /// The name of the domain you've associated a package with.
        public var anyJSON: AnyJSON

        public init(domainName: AmazonOpenSearchAPI.DomainName, anyJSON: AnyJSON) {
            self.domainName = domainName
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainName = try values.decode(AmazonOpenSearchAPI.DomainName.self, forKey: "domainName")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainName, forKey: "domainName")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class DomainPackageStatus: Codable {
        public var domainPackageStatus: AmazonOpenSearchAPI.DomainPackageStatus
        /// State of the association. Values are ASSOCIATING, ASSOCIATION_FAILED, ACTIVE, DISSOCIATING, and DISSOCIATION_FAILED.
        public var anyJSON: AnyJSON

        public init(domainPackageStatus: AmazonOpenSearchAPI.DomainPackageStatus, anyJSON: AnyJSON) {
            self.domainPackageStatus = domainPackageStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainPackageStatus = try values.decode(AmazonOpenSearchAPI.DomainPackageStatus.self, forKey: "domainPackageStatus")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainPackageStatus, forKey: "domainPackageStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class ReferencePath: Codable {
        public var referencePath: AmazonOpenSearchAPI.ReferencePath
        /// The relative path on Amazon OpenSearch Service nodes, which can be used as synonym_path when the package is a synonym file.
        public var anyJSON: AnyJSON

        public init(referencePath: AmazonOpenSearchAPI.ReferencePath, anyJSON: AnyJSON) {
            self.referencePath = referencePath
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.referencePath = try values.decode(AmazonOpenSearchAPI.ReferencePath.self, forKey: "referencePath")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(referencePath, forKey: "referencePath")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class ErrorDetails: Codable {
        public var errorDetails: AmazonOpenSearchAPI.ErrorDetails
        /// Additional information if the package is in an error state. Null otherwise.
        public var anyJSON: AnyJSON

        public init(errorDetails: AmazonOpenSearchAPI.ErrorDetails, anyJSON: AnyJSON) {
            self.errorDetails = errorDetails
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.errorDetails = try values.decode(AmazonOpenSearchAPI.ErrorDetails.self, forKey: "errorDetails")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(errorDetails, forKey: "errorDetails")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(packageID: PackageID? = nil, packageName: PackageName? = nil, packageType: PackageType? = nil, lastUpdated: LastUpdated? = nil, domainName: DomainName? = nil, domainPackageStatus: DomainPackageStatus? = nil, packageVersion: String? = nil, referencePath: ReferencePath? = nil, errorDetails: ErrorDetails? = nil) {
        self.packageID = packageID
        self.packageName = packageName
        self.packageType = packageType
        self.lastUpdated = lastUpdated
        self.domainName = domainName
        self.domainPackageStatus = domainPackageStatus
        self.packageVersion = packageVersion
        self.referencePath = referencePath
        self.errorDetails = errorDetails
    }

    private enum CodingKeys: String, CodingKey {
        case packageID = "PackageID"
        case packageName = "PackageName"
        case packageType = "PackageType"
        case lastUpdated = "LastUpdated"
        case domainName = "DomainName"
        case domainPackageStatus = "DomainPackageStatus"
        case packageVersion = "PackageVersion"
        case referencePath = "ReferencePath"
        case errorDetails = "ErrorDetails"
    }
}

/// Specifies the Auto-Tune type. Valid value is SCHEDULED_ACTION.
public enum AutoTuneType: String, Codable, CaseIterable {
    case scheduledAction = "SCHEDULED_ACTION"
}

/// Specifies details about the Auto-Tune action. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
public struct AutoTuneDetails: Codable {
    /// Specifies details about the scheduled Auto-Tune action. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
    public var scheduledAutoTuneDetails: ScheduledAutoTuneDetails?

    public init(scheduledAutoTuneDetails: ScheduledAutoTuneDetails? = nil) {
        self.scheduledAutoTuneDetails = scheduledAutoTuneDetails
    }

    private enum CodingKeys: String, CodingKey {
        case scheduledAutoTuneDetails = "ScheduledAutoTuneDetails"
    }
}

/// Specifies the Auto-Tune type and Auto-Tune action details.
public struct AutoTune: Codable {
    public var autoTuneType: AutoTuneType?
    public var autoTuneDetails: AutoTuneDetails?

    public final class AutoTuneType: Codable {
        /// Specifies the Auto-Tune type. Valid value is SCHEDULED_ACTION.
        public var autoTuneType: AmazonOpenSearchAPI.AutoTuneType
        /// Specifies the Auto-Tune type. Valid value is SCHEDULED_ACTION.
        public var anyJSON: AnyJSON

        public init(autoTuneType: AmazonOpenSearchAPI.AutoTuneType, anyJSON: AnyJSON) {
            self.autoTuneType = autoTuneType
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.autoTuneType = try values.decode(AmazonOpenSearchAPI.AutoTuneType.self, forKey: "autoTuneType")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(autoTuneType, forKey: "autoTuneType")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class AutoTuneDetails: Codable {
        /// Specifies details about the Auto-Tune action. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
        public var autoTuneDetails: AmazonOpenSearchAPI.AutoTuneDetails
        /// Specifies details about the Auto-Tune action. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
        public var anyJSON: AnyJSON

        public init(autoTuneDetails: AmazonOpenSearchAPI.AutoTuneDetails, anyJSON: AnyJSON) {
            self.autoTuneDetails = autoTuneDetails
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.autoTuneDetails = try values.decode(AmazonOpenSearchAPI.AutoTuneDetails.self, forKey: "autoTuneDetails")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(autoTuneDetails, forKey: "autoTuneDetails")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(autoTuneType: AutoTuneType? = nil, autoTuneDetails: AutoTuneDetails? = nil) {
        self.autoTuneType = autoTuneType
        self.autoTuneDetails = autoTuneDetails
    }

    private enum CodingKeys: String, CodingKey {
        case autoTuneType = "AutoTuneType"
        case autoTuneDetails = "AutoTuneDetails"
    }
}

/// Specifies details about the scheduled Auto-Tune action. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
public struct ScheduledAutoTuneDetails: Codable {
    public var date: Date?
    public var actionType: ActionType?
    public var action: Action?
    public var severity: Severity?

    public struct Date: Codable {
        /// The timestamp of the Auto-Tune action scheduled for the domain.
        public var date: Date
        /// The timestamp of the Auto-Tune action scheduled for the domain.
        public var anyJSON: AnyJSON

        public init(date: Date, anyJSON: AnyJSON) {
            self.date = date
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(Date.self, forKey: "date")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ActionType: Codable {
        /// The Auto-Tune action type. Valid values are JVM_HEAP_SIZE_TUNING, and JVM_YOUNG_GEN_TUNING.
        public var scheduledAutoTuneActionType: ScheduledAutoTuneActionType
        /// The Auto-Tune action type. Valid values are JVM_HEAP_SIZE_TUNING and JVM_YOUNG_GEN_TUNING.
        public var anyJSON: AnyJSON

        public init(scheduledAutoTuneActionType: ScheduledAutoTuneActionType, anyJSON: AnyJSON) {
            self.scheduledAutoTuneActionType = scheduledAutoTuneActionType
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.scheduledAutoTuneActionType = try ScheduledAutoTuneActionType(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(scheduledAutoTuneActionType, forKey: "scheduledAutoTuneActionType")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Action: Codable {
        /// The Auto-Tune action description.
        public var string: String
        /// The Auto-Tune action description.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Severity: Codable {
        /// The Auto-Tune action severity. Valid values are LOW, MEDIUM, and HIGH.
        public var scheduledAutoTuneSeverityType: ScheduledAutoTuneSeverityType
        /// The Auto-Tune action severity. Valid values are LOW, MEDIUM, and HIGH.
        public var anyJSON: AnyJSON

        public init(scheduledAutoTuneSeverityType: ScheduledAutoTuneSeverityType, anyJSON: AnyJSON) {
            self.scheduledAutoTuneSeverityType = scheduledAutoTuneSeverityType
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.scheduledAutoTuneSeverityType = try ScheduledAutoTuneSeverityType(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(scheduledAutoTuneSeverityType, forKey: "scheduledAutoTuneSeverityType")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(date: Date? = nil, actionType: ActionType? = nil, action: Action? = nil, severity: Severity? = nil) {
        self.date = date
        self.actionType = actionType
        self.action = action
        self.severity = severity
    }

    private enum CodingKeys: String, CodingKey {
        case date = "Date"
        case actionType = "ActionType"
        case action = "Action"
        case severity = "Severity"
    }
}

/// The maintenance schedule duration: duration value and duration unit. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
public struct Duration: Codable {
    public var value: Value?
    public var unit: Unit?

    public struct Value: Codable {
        /// Integer to specify the value of a maintenance schedule duration. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
        public var int: Int
        /// Integer to specify the value of a maintenance schedule duration. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Unit: Codable {
        /// The unit of a maintenance schedule duration. Valid value is HOUR. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
        public var timeUnit: TimeUnit
        /// The unit of a maintenance schedule duration. Valid value is HOURS. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
        public var anyJSON: AnyJSON

        public init(timeUnit: TimeUnit, anyJSON: AnyJSON) {
            self.timeUnit = timeUnit
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.timeUnit = try TimeUnit(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(timeUnit, forKey: "timeUnit")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(value: Value? = nil, unit: Unit? = nil) {
        self.value = value
        self.unit = unit
    }

    private enum CodingKeys: String, CodingKey {
        case value = "Value"
        case unit = "Unit"
    }
}

/// Specifies the Auto-Tune maintenance schedule. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
public struct AutoTuneMaintenanceSchedule: Codable {
    public var startAt: StartAt?
    public var duration: Duration?
    public var cronExpressionForRecurrence: CronExpressionForRecurrence?

    public final class StartAt: Codable {
        public var startAt: AmazonOpenSearchAPI.StartAt
        /// The timestamp at which the Auto-Tune maintenance schedule starts.
        public var anyJSON: AnyJSON

        public init(startAt: AmazonOpenSearchAPI.StartAt, anyJSON: AnyJSON) {
            self.startAt = startAt
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.startAt = try values.decode(AmazonOpenSearchAPI.StartAt.self, forKey: "startAt")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(startAt, forKey: "startAt")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class Duration: Codable {
        /// The maintenance schedule duration: duration value and duration unit. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
        public var duration: AmazonOpenSearchAPI.Duration
        /// Specifies maintenance schedule duration: duration value and duration unit. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
        public var anyJSON: AnyJSON

        public init(duration: AmazonOpenSearchAPI.Duration, anyJSON: AnyJSON) {
            self.duration = duration
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.duration = try values.decode(AmazonOpenSearchAPI.Duration.self, forKey: "duration")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(duration, forKey: "duration")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct CronExpressionForRecurrence: Codable {
        public var string: String
        /// A cron expression for a recurring maintenance schedule. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(startAt: StartAt? = nil, duration: Duration? = nil, cronExpressionForRecurrence: CronExpressionForRecurrence? = nil) {
        self.startAt = startAt
        self.duration = duration
        self.cronExpressionForRecurrence = cronExpressionForRecurrence
    }

    private enum CodingKeys: String, CodingKey {
        case startAt = "StartAt"
        case duration = "Duration"
        case cronExpressionForRecurrence = "CronExpressionForRecurrence"
    }
}

/// The Auto-Tune options: the Auto-Tune desired state for the domain, rollback state when disabling Auto-Tune options and list of maintenance schedules.
public struct AutoTuneOptions: Codable {
    public var desiredState: DesiredState?
    public var rollbackOnDisable: RollbackOnDisable?
    public var maintenanceSchedules: MaintenanceSchedules?

    public struct DesiredState: Codable {
        /// The Auto-Tune desired state. Valid values are ENABLED and DISABLED.
        public var autoTuneDesiredState: AutoTuneDesiredState
        /// The Auto-Tune desired state. Valid values are ENABLED and DISABLED.
        public var anyJSON: AnyJSON

        public init(autoTuneDesiredState: AutoTuneDesiredState, anyJSON: AnyJSON) {
            self.autoTuneDesiredState = autoTuneDesiredState
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.autoTuneDesiredState = try AutoTuneDesiredState(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(autoTuneDesiredState, forKey: "autoTuneDesiredState")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class RollbackOnDisable: Codable {
        /// The rollback state while disabling Auto-Tune for the domain. Valid values are NO_ROLLBACK and DEFAULT_ROLLBACK.
        public var rollbackOnDisable: AmazonOpenSearchAPI.RollbackOnDisable
        /// The rollback state while disabling Auto-Tune for the domain. Valid values are NO_ROLLBACK and DEFAULT_ROLLBACK.
        public var anyJSON: AnyJSON

        public init(rollbackOnDisable: AmazonOpenSearchAPI.RollbackOnDisable, anyJSON: AnyJSON) {
            self.rollbackOnDisable = rollbackOnDisable
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.rollbackOnDisable = try values.decode(AmazonOpenSearchAPI.RollbackOnDisable.self, forKey: "rollbackOnDisable")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(rollbackOnDisable, forKey: "rollbackOnDisable")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MaintenanceSchedules: Codable {
        public var autoTuneMaintenanceSchedules: [AutoTuneMaintenanceSchedule]
        /// A list of maintenance schedules. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
        public var anyJSON: AnyJSON

        public init(autoTuneMaintenanceSchedules: [AutoTuneMaintenanceSchedule], anyJSON: AnyJSON) {
            self.autoTuneMaintenanceSchedules = autoTuneMaintenanceSchedules
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.autoTuneMaintenanceSchedules = try values.decode([AutoTuneMaintenanceSchedule].self, forKey: "autoTuneMaintenanceSchedules")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(autoTuneMaintenanceSchedules, forKey: "autoTuneMaintenanceSchedules")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(desiredState: DesiredState? = nil, rollbackOnDisable: RollbackOnDisable? = nil, maintenanceSchedules: MaintenanceSchedules? = nil) {
        self.desiredState = desiredState
        self.rollbackOnDisable = rollbackOnDisable
        self.maintenanceSchedules = maintenanceSchedules
    }

    private enum CodingKeys: String, CodingKey {
        case desiredState = "DesiredState"
        case rollbackOnDisable = "RollbackOnDisable"
        case maintenanceSchedules = "MaintenanceSchedules"
    }
}

/// The Auto-Tune options: the Auto-Tune desired state for the domain and list of maintenance schedules.
public struct AutoTuneOptionsInput: Codable {
    public var desiredState: DesiredState?
    public var maintenanceSchedules: MaintenanceSchedules?

    public struct DesiredState: Codable {
        /// The Auto-Tune desired state. Valid values are ENABLED and DISABLED.
        public var autoTuneDesiredState: AutoTuneDesiredState
        /// The Auto-Tune desired state. Valid values are ENABLED and DISABLED.
        public var anyJSON: AnyJSON

        public init(autoTuneDesiredState: AutoTuneDesiredState, anyJSON: AnyJSON) {
            self.autoTuneDesiredState = autoTuneDesiredState
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.autoTuneDesiredState = try AutoTuneDesiredState(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(autoTuneDesiredState, forKey: "autoTuneDesiredState")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MaintenanceSchedules: Codable {
        public var autoTuneMaintenanceSchedules: [AutoTuneMaintenanceSchedule]
        /// A list of maintenance schedules. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
        public var anyJSON: AnyJSON

        public init(autoTuneMaintenanceSchedules: [AutoTuneMaintenanceSchedule], anyJSON: AnyJSON) {
            self.autoTuneMaintenanceSchedules = autoTuneMaintenanceSchedules
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.autoTuneMaintenanceSchedules = try values.decode([AutoTuneMaintenanceSchedule].self, forKey: "autoTuneMaintenanceSchedules")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(autoTuneMaintenanceSchedules, forKey: "autoTuneMaintenanceSchedules")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(desiredState: DesiredState? = nil, maintenanceSchedules: MaintenanceSchedules? = nil) {
        self.desiredState = desiredState
        self.maintenanceSchedules = maintenanceSchedules
    }

    private enum CodingKeys: String, CodingKey {
        case desiredState = "DesiredState"
        case maintenanceSchedules = "MaintenanceSchedules"
    }
}

/// The Auto-Tune state for the domain. For valid states see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service</a>.
public enum AutoTuneState: String, Codable, CaseIterable {
    case enabled = "ENABLED"
    case disabled = "DISABLED"
    case enableInProgress = "ENABLE_IN_PROGRESS"
    case disableInProgress = "DISABLE_IN_PROGRESS"
    case disabledAndRollbackScheduled = "DISABLED_AND_ROLLBACK_SCHEDULED"
    case disabledAndRollbackInProgress = "DISABLED_AND_ROLLBACK_IN_PROGRESS"
    case disabledAndRollbackComplete = "DISABLED_AND_ROLLBACK_COMPLETE"
    case disabledAndRollbackError = "DISABLED_AND_ROLLBACK_ERROR"
    case error = "ERROR"
}

/// The Auto-Tune options: the Auto-Tune desired state for the domain and list of maintenance schedules.
public struct AutoTuneOptionsOutput: Codable {
    public var state: State?
    public var errorMessage: ErrorMessage?

    public struct State: Codable {
        /// The Auto-Tune state for the domain. For valid states see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service</a>.
        public var autoTuneState: AutoTuneState
        /// The <code>AutoTuneState</code> for the domain.
        public var anyJSON: AnyJSON

        public init(autoTuneState: AutoTuneState, anyJSON: AnyJSON) {
            self.autoTuneState = autoTuneState
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.autoTuneState = try AutoTuneState(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(autoTuneState, forKey: "autoTuneState")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ErrorMessage: Codable {
        public var string: String
        /// The error message while enabling or disabling Auto-Tune.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(state: State? = nil, errorMessage: ErrorMessage? = nil) {
        self.state = state
        self.errorMessage = errorMessage
    }

    private enum CodingKeys: String, CodingKey {
        case state = "State"
        case errorMessage = "ErrorMessage"
    }
}

/// Provides the current Auto-Tune status for the domain.
public struct AutoTuneStatus: Codable {
    public var creationDate: CreationDate
    public var updateDate: UpdateDate
    public var updateVersion: UpdateVersion?
    public var state: State
    public var errorMessage: ErrorMessage?
    public var pendingDeletion: PendingDeletion?

    public struct CreationDate: Codable {
        public var date: Date
        /// The timestamp of the Auto-Tune options creation date.
        public var anyJSON: AnyJSON

        public init(date: Date, anyJSON: AnyJSON) {
            self.date = date
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(Date.self, forKey: "date")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct UpdateDate: Codable {
        public var date: Date
        /// The timestamp of when the Auto-Tune options were last updated.
        public var anyJSON: AnyJSON

        public init(date: Date, anyJSON: AnyJSON) {
            self.date = date
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(Date.self, forKey: "date")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct UpdateVersion: Codable {
        public var int: Int
        /// The latest version of the Auto-Tune options.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct State: Codable {
        /// The Auto-Tune state for the domain. For valid states see <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service</a>.
        public var autoTuneState: AutoTuneState
        /// The <code>AutoTuneState</code> for the domain.
        public var anyJSON: AnyJSON

        public init(autoTuneState: AutoTuneState, anyJSON: AnyJSON) {
            self.autoTuneState = autoTuneState
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.autoTuneState = try AutoTuneState(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(autoTuneState, forKey: "autoTuneState")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ErrorMessage: Codable {
        public var string: String
        /// The error message while enabling or disabling Auto-Tune.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct PendingDeletion: Codable {
        public var isBool: Bool
        /// Indicates whether the domain is being deleted.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(creationDate: CreationDate, updateDate: UpdateDate, updateVersion: UpdateVersion? = nil, state: State, errorMessage: ErrorMessage? = nil, pendingDeletion: PendingDeletion? = nil) {
        self.creationDate = creationDate
        self.updateDate = updateDate
        self.updateVersion = updateVersion
        self.state = state
        self.errorMessage = errorMessage
        self.pendingDeletion = pendingDeletion
    }

    private enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case updateDate = "UpdateDate"
        case updateVersion = "UpdateVersion"
        case state = "State"
        case errorMessage = "ErrorMessage"
        case pendingDeletion = "PendingDeletion"
    }
}

/// The Auto-Tune status for the domain.
public struct AutoTuneOptionsStatus: Codable {
    public var options: Options?
    public var status: Status?

    public struct Options: Codable {
        /// The Auto-Tune options: the Auto-Tune desired state for the domain, rollback state when disabling Auto-Tune options and list of maintenance schedules.
        public var autoTuneOptions: AutoTuneOptions
        /// Specifies Auto-Tune options for the domain.
        public var anyJSON: AnyJSON

        public init(autoTuneOptions: AutoTuneOptions, anyJSON: AnyJSON) {
            self.autoTuneOptions = autoTuneOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.autoTuneOptions = try AutoTuneOptions(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(autoTuneOptions, forKey: "autoTuneOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        /// Provides the current Auto-Tune status for the domain.
        public var autoTuneStatus: AutoTuneStatus
        /// The status of the Auto-Tune options for the domain.
        public var anyJSON: AnyJSON

        public init(autoTuneStatus: AutoTuneStatus, anyJSON: AnyJSON) {
            self.autoTuneStatus = autoTuneStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.autoTuneStatus = try AutoTuneStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(autoTuneStatus, forKey: "autoTuneStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(options: Options? = nil, status: Status? = nil) {
        self.options = options
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }
}

/// Container for the parameters to the <code> <a>CancelServiceSoftwareUpdate</a> </code> operation. Specifies the name of the domain that you wish to cancel a service software update on.
public struct CancelServiceSoftwareUpdateRequest: Codable {
    public var domainName: DomainName

    public final class DomainName: Codable {
        /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
        public var domainName: AmazonOpenSearchAPI.DomainName
        /// The name of the domain that you want to stop the latest service software update on.
        public var anyJSON: AnyJSON

        public init(domainName: AmazonOpenSearchAPI.DomainName, anyJSON: AnyJSON) {
            self.domainName = domainName
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainName = try values.decode(AmazonOpenSearchAPI.DomainName.self, forKey: "domainName")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainName, forKey: "domainName")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(domainName: DomainName) {
        self.domainName = domainName
    }

    private enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }
}

/// The current options of an domain service software options.
public struct ServiceSoftwareOptions: Codable {
    public var currentVersion: CurrentVersion?
    public var newVersion: NewVersion?
    public var updateAvailable: UpdateAvailable?
    public var cancellable: Cancellable?
    public var updateStatus: UpdateStatus?
    public var description: Description?
    public var automatedUpdateDate: AutomatedUpdateDate?
    public var optionalDeployment: OptionalDeployment?

    public struct CurrentVersion: Codable {
        public var string: String
        /// The current service software version present on the domain.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NewVersion: Codable {
        public var string: String
        /// The new service software version if one is available.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct UpdateAvailable: Codable {
        public var isBool: Bool
        /// <code>True</code> if you're able to update your service software version. <code>False</code> if you can't update your service software version.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Cancellable: Codable {
        public var isBool: Bool
        /// <code>True</code> if you're able to cancel your service software version update. <code>False</code> if you can't cancel your service software update.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct UpdateStatus: Codable {
        public var deploymentStatus: DeploymentStatus
        /// The status of your service software update. This field can take the following values: <code> ELIGIBLE</code>, <code>PENDING_UPDATE</code>, <code>IN_PROGRESS</code>, <code>COMPLETED</code>, and <code> NOT_ELIGIBLE</code>.
        public var anyJSON: AnyJSON

        public init(deploymentStatus: DeploymentStatus, anyJSON: AnyJSON) {
            self.deploymentStatus = deploymentStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.deploymentStatus = try DeploymentStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(deploymentStatus, forKey: "deploymentStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Description: Codable {
        public var string: String
        /// The description of the <code>UpdateStatus</code>.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AutomatedUpdateDate: Codable {
        public var date: Date
        /// The timestamp, in Epoch time, until which you can manually request a service software update. After this date, we automatically update your service software.
        public var anyJSON: AnyJSON

        public init(date: Date, anyJSON: AnyJSON) {
            self.date = date
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(Date.self, forKey: "date")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct OptionalDeployment: Codable {
        public var isBool: Bool
        /// <code>True</code> if a service software is never automatically updated. <code>False</code> if a service software is automatically updated after <code>AutomatedUpdateDate</code>.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(currentVersion: CurrentVersion? = nil, newVersion: NewVersion? = nil, updateAvailable: UpdateAvailable? = nil, cancellable: Cancellable? = nil, updateStatus: UpdateStatus? = nil, description: Description? = nil, automatedUpdateDate: AutomatedUpdateDate? = nil, optionalDeployment: OptionalDeployment? = nil) {
        self.currentVersion = currentVersion
        self.newVersion = newVersion
        self.updateAvailable = updateAvailable
        self.cancellable = cancellable
        self.updateStatus = updateStatus
        self.description = description
        self.automatedUpdateDate = automatedUpdateDate
        self.optionalDeployment = optionalDeployment
    }

    private enum CodingKeys: String, CodingKey {
        case currentVersion = "CurrentVersion"
        case newVersion = "NewVersion"
        case updateAvailable = "UpdateAvailable"
        case cancellable = "Cancellable"
        case updateStatus = "UpdateStatus"
        case description = "Description"
        case automatedUpdateDate = "AutomatedUpdateDate"
        case optionalDeployment = "OptionalDeployment"
    }
}

/// The configuration for the domain cluster, such as the type and number of instances.
public struct ClusterConfig: Codable {
    public var instanceType: InstanceType?
    public var instanceCount: InstanceCount?
    public var dedicatedMasterEnabled: DedicatedMasterEnabled?
    public var zoneAwarenessEnabled: ZoneAwarenessEnabled?
    public var zoneAwarenessConfig: ZoneAwarenessConfig?
    public var dedicatedMasterType: DedicatedMasterType?
    public var dedicatedMasterCount: DedicatedMasterCount?
    public var warmEnabled: WarmEnabled?
    public var warmType: WarmType?
    public var warmCount: WarmCount?
    public var coldStorageOptions: ColdStorageOptions?

    public struct InstanceType: Codable {
        public var openSearchPartitionInstanceType: OpenSearchPartitionInstanceType
        /// The instance type for an OpenSearch cluster. UltraWarm instance types are not supported for data instances.
        public var anyJSON: AnyJSON

        public init(openSearchPartitionInstanceType: OpenSearchPartitionInstanceType, anyJSON: AnyJSON) {
            self.openSearchPartitionInstanceType = openSearchPartitionInstanceType
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.openSearchPartitionInstanceType = try OpenSearchPartitionInstanceType(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(openSearchPartitionInstanceType, forKey: "openSearchPartitionInstanceType")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct InstanceCount: Codable {
        public var int: Int
        /// The number of instances in the specified domain cluster.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct DedicatedMasterEnabled: Codable {
        public var isBool: Bool
        /// A boolean value to indicate whether a dedicated master node is enabled. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains.html#managedomains-dedicatedmasternodes" target="_blank">Dedicated master nodes in Amazon OpenSearch Service </a> for more information.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ZoneAwarenessEnabled: Codable {
        public var isBool: Bool
        /// A boolean value to indicate whether zone awareness is enabled. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html" target="_blank">Configuring a multi-AZ domain in Amazon OpenSearch Service </a> for more information.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class ZoneAwarenessConfig: Codable {
        /// The zone awareness configuration for the domain cluster, such as the number of availability zones.
        public var zoneAwarenessConfig: AmazonOpenSearchAPI.ZoneAwarenessConfig
        /// The zone awareness configuration for a domain when zone awareness is enabled.
        public var anyJSON: AnyJSON

        public init(zoneAwarenessConfig: AmazonOpenSearchAPI.ZoneAwarenessConfig, anyJSON: AnyJSON) {
            self.zoneAwarenessConfig = zoneAwarenessConfig
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.zoneAwarenessConfig = try values.decode(AmazonOpenSearchAPI.ZoneAwarenessConfig.self, forKey: "zoneAwarenessConfig")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(zoneAwarenessConfig, forKey: "zoneAwarenessConfig")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct DedicatedMasterType: Codable {
        public var openSearchPartitionInstanceType: OpenSearchPartitionInstanceType
        /// The instance type for a dedicated master node.
        public var anyJSON: AnyJSON

        public init(openSearchPartitionInstanceType: OpenSearchPartitionInstanceType, anyJSON: AnyJSON) {
            self.openSearchPartitionInstanceType = openSearchPartitionInstanceType
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.openSearchPartitionInstanceType = try OpenSearchPartitionInstanceType(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(openSearchPartitionInstanceType, forKey: "openSearchPartitionInstanceType")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct DedicatedMasterCount: Codable {
        public var int: Int
        /// Total number of dedicated master nodes, active and on standby, for the cluster.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct WarmEnabled: Codable {
        public var isBool: Bool
        /// True to enable UltraWarm storage.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct WarmType: Codable {
        public var openSearchWarmPartitionInstanceType: OpenSearchWarmPartitionInstanceType
        /// The instance type for the OpenSearch cluster's warm nodes.
        public var anyJSON: AnyJSON

        public init(openSearchWarmPartitionInstanceType: OpenSearchWarmPartitionInstanceType, anyJSON: AnyJSON) {
            self.openSearchWarmPartitionInstanceType = openSearchWarmPartitionInstanceType
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.openSearchWarmPartitionInstanceType = try OpenSearchWarmPartitionInstanceType(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(openSearchWarmPartitionInstanceType, forKey: "openSearchWarmPartitionInstanceType")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct WarmCount: Codable {
        public var int: Int
        /// The number of UltraWarm nodes in the cluster.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class ColdStorageOptions: Codable {
        /// Specifies the configuration for cold storage options such as enabled
        public var coldStorageOptions: AmazonOpenSearchAPI.ColdStorageOptions
        /// Specifies the <code>ColdStorageOptions</code> config for a Domain
        public var anyJSON: AnyJSON

        public init(coldStorageOptions: AmazonOpenSearchAPI.ColdStorageOptions, anyJSON: AnyJSON) {
            self.coldStorageOptions = coldStorageOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.coldStorageOptions = try values.decode(AmazonOpenSearchAPI.ColdStorageOptions.self, forKey: "coldStorageOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(coldStorageOptions, forKey: "coldStorageOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(instanceType: InstanceType? = nil, instanceCount: InstanceCount? = nil, dedicatedMasterEnabled: DedicatedMasterEnabled? = nil, zoneAwarenessEnabled: ZoneAwarenessEnabled? = nil, zoneAwarenessConfig: ZoneAwarenessConfig? = nil, dedicatedMasterType: DedicatedMasterType? = nil, dedicatedMasterCount: DedicatedMasterCount? = nil, warmEnabled: WarmEnabled? = nil, warmType: WarmType? = nil, warmCount: WarmCount? = nil, coldStorageOptions: ColdStorageOptions? = nil) {
        self.instanceType = instanceType
        self.instanceCount = instanceCount
        self.dedicatedMasterEnabled = dedicatedMasterEnabled
        self.zoneAwarenessEnabled = zoneAwarenessEnabled
        self.zoneAwarenessConfig = zoneAwarenessConfig
        self.dedicatedMasterType = dedicatedMasterType
        self.dedicatedMasterCount = dedicatedMasterCount
        self.warmEnabled = warmEnabled
        self.warmType = warmType
        self.warmCount = warmCount
        self.coldStorageOptions = coldStorageOptions
    }

    private enum CodingKeys: String, CodingKey {
        case instanceType = "InstanceType"
        case instanceCount = "InstanceCount"
        case dedicatedMasterEnabled = "DedicatedMasterEnabled"
        case zoneAwarenessEnabled = "ZoneAwarenessEnabled"
        case zoneAwarenessConfig = "ZoneAwarenessConfig"
        case dedicatedMasterType = "DedicatedMasterType"
        case dedicatedMasterCount = "DedicatedMasterCount"
        case warmEnabled = "WarmEnabled"
        case warmType = "WarmType"
        case warmCount = "WarmCount"
        case coldStorageOptions = "ColdStorageOptions"
    }
}

/// The configuration status for the specified domain.
public struct ClusterConfigStatus: Codable {
    public var options: Options
    public var status: Status

    public struct Options: Codable {
        /// The configuration for the domain cluster, such as the type and number of instances.
        public var clusterConfig: ClusterConfig
        /// The cluster configuration for the specified domain.
        public var anyJSON: AnyJSON

        public init(clusterConfig: ClusterConfig, anyJSON: AnyJSON) {
            self.clusterConfig = clusterConfig
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.clusterConfig = try ClusterConfig(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(clusterConfig, forKey: "clusterConfig")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        /// Provides the current status of the entity.
        public var optionStatus: OptionStatus
        /// The cluster configuration status for the specified domain.
        public var anyJSON: AnyJSON

        public init(optionStatus: OptionStatus, anyJSON: AnyJSON) {
            self.optionStatus = optionStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.optionStatus = try OptionStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(optionStatus, forKey: "optionStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(options: Options, status: Status) {
        self.options = options
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }
}

/// Options to specify the Cognito user and identity pools for OpenSearch Dashboards authentication. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>.
public struct CognitoOptions: Codable {
    public var enabled: Enabled?
    public var userPoolID: UserPoolID?
    public var identityPoolID: IdentityPoolId?
    public var roleArn: RoleArn?

    public struct Enabled: Codable {
        public var isBool: Bool
        /// The option to enable Cognito for OpenSearch Dashboards authentication.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class UserPoolID: Codable {
        public var userPoolID: AmazonOpenSearchAPI.UserPoolID
        /// The Cognito user pool ID for OpenSearch Dashboards authentication.
        public var anyJSON: AnyJSON

        public init(userPoolID: AmazonOpenSearchAPI.UserPoolID, anyJSON: AnyJSON) {
            self.userPoolID = userPoolID
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.userPoolID = try values.decode(AmazonOpenSearchAPI.UserPoolID.self, forKey: "userPoolID")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userPoolID, forKey: "userPoolID")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class IdentityPoolId: Codable {
        public var identityPoolID: AmazonOpenSearchAPI.IdentityPoolId
        /// The Cognito identity pool ID for OpenSearch Dashboards authentication.
        public var anyJSON: AnyJSON

        public init(identityPoolID: AmazonOpenSearchAPI.IdentityPoolId, anyJSON: AnyJSON) {
            self.identityPoolID = identityPoolID
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.identityPoolID = try values.decode(AmazonOpenSearchAPI.IdentityPoolId.self, forKey: "identityPoolID")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(identityPoolID, forKey: "identityPoolID")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class RoleArn: Codable {
        public var roleArn: AmazonOpenSearchAPI.RoleArn
        /// The role ARN that provides OpenSearch permissions for accessing Cognito resources.
        public var anyJSON: AnyJSON

        public init(roleArn: AmazonOpenSearchAPI.RoleArn, anyJSON: AnyJSON) {
            self.roleArn = roleArn
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.roleArn = try values.decode(AmazonOpenSearchAPI.RoleArn.self, forKey: "roleArn")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(roleArn, forKey: "roleArn")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(enabled: Enabled? = nil, userPoolID: UserPoolID? = nil, identityPoolID: IdentityPoolId? = nil, roleArn: RoleArn? = nil) {
        self.enabled = enabled
        self.userPoolID = userPoolID
        self.identityPoolID = identityPoolID
        self.roleArn = roleArn
    }

    private enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case userPoolID = "UserPoolId"
        case identityPoolID = "IdentityPoolId"
        case roleArn = "RoleArn"
    }
}

/// The status of the Cognito options for the specified domain.
public struct CognitoOptionsStatus: Codable {
    public var options: Options
    public var status: Status

    public struct Options: Codable {
        /// Options to specify the Cognito user and identity pools for OpenSearch Dashboards authentication. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>.
        public var cognitoOptions: CognitoOptions
        /// Cognito options for the specified domain.
        public var anyJSON: AnyJSON

        public init(cognitoOptions: CognitoOptions, anyJSON: AnyJSON) {
            self.cognitoOptions = cognitoOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.cognitoOptions = try CognitoOptions(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(cognitoOptions, forKey: "cognitoOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        /// Provides the current status of the entity.
        public var optionStatus: OptionStatus
        /// The status of the Cognito options for the specified domain.
        public var anyJSON: AnyJSON

        public init(optionStatus: OptionStatus, anyJSON: AnyJSON) {
            self.optionStatus = optionStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.optionStatus = try OptionStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(optionStatus, forKey: "optionStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(options: Options, status: Status) {
        self.options = options
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }
}

/// A map from an <code> <a>EngineVersion</a> </code> to a list of compatible <code> <a>EngineVersion</a> </code> s to which the domain can be upgraded.
public struct CompatibleVersionsMap: Codable {
    public var sourceVersion: SourceVersion?
    /// List of supported OpenSearch versions.
    public var targetVersions: [String]?

    public struct SourceVersion: Codable {
        public var string: String
        /// The current version of OpenSearch a domain is on.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(sourceVersion: SourceVersion? = nil, targetVersions: [String]? = nil) {
        self.sourceVersion = sourceVersion
        self.targetVersions = targetVersions
    }

    private enum CodingKeys: String, CodingKey {
        case sourceVersion = "SourceVersion"
        case targetVersions = "TargetVersions"
    }
}

/// Options to enable, disable, and specify the properties of EBS storage volumes.
public struct EBSOptions: Codable {
    public var eBSEnabled: EBSEnabled?
    public var volumeType: VolumeType?
    public var volumeSize: VolumeSize?
    public var iops: Iops?

    public struct EBSEnabled: Codable {
        public var isBool: Bool
        /// Whether EBS-based storage is enabled.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class VolumeType: Codable {
        /// The type of EBS volume, standard, gp2, or io1. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/opensearch-createupdatedomains.html#opensearch-createdomain-configure-ebs" target="_blank">Configuring EBS-based Storage</a> for more information.
        public var volumeType: AmazonOpenSearchAPI.VolumeType
        /// The volume type for EBS-based storage.
        public var anyJSON: AnyJSON

        public init(volumeType: AmazonOpenSearchAPI.VolumeType, anyJSON: AnyJSON) {
            self.volumeType = volumeType
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.volumeType = try values.decode(AmazonOpenSearchAPI.VolumeType.self, forKey: "volumeType")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(volumeType, forKey: "volumeType")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct VolumeSize: Codable {
        public var int: Int
        /// Integer to specify the size of an EBS volume.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Iops: Codable {
        public var int: Int
        /// The IOPD for a Provisioned IOPS EBS volume (SSD).
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(eBSEnabled: EBSEnabled? = nil, volumeType: VolumeType? = nil, volumeSize: VolumeSize? = nil, iops: Iops? = nil) {
        self.eBSEnabled = eBSEnabled
        self.volumeType = volumeType
        self.volumeSize = volumeSize
        self.iops = iops
    }

    private enum CodingKeys: String, CodingKey {
        case eBSEnabled = "EBSEnabled"
        case volumeType = "VolumeType"
        case volumeSize = "VolumeSize"
        case iops = "Iops"
    }
}

/// The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.
public struct SnapshotOptions: Codable {
    public var automatedSnapshotStartHour: AutomatedSnapshotStartHour?

    public struct AutomatedSnapshotStartHour: Codable {
        public var int: Int
        /// The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(automatedSnapshotStartHour: AutomatedSnapshotStartHour? = nil) {
        self.automatedSnapshotStartHour = automatedSnapshotStartHour
    }

    private enum CodingKeys: String, CodingKey {
        case automatedSnapshotStartHour = "AutomatedSnapshotStartHour"
    }
}

/// Options to specify the subnets and security groups for the VPC endpoint. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>.
public struct VPCOptions: Codable {
    public var subnetIDs: SubnetIDs?
    public var securityGroupIDs: SecurityGroupIDs?

    public struct SubnetIDs: Codable {
        public var strings: [String]
        /// The subnets for the VPC endpoint.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SecurityGroupIDs: Codable {
        public var strings: [String]
        /// The security groups for the VPC endpoint.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(subnetIDs: SubnetIDs? = nil, securityGroupIDs: SecurityGroupIDs? = nil) {
        self.subnetIDs = subnetIDs
        self.securityGroupIDs = securityGroupIDs
    }

    private enum CodingKeys: String, CodingKey {
        case subnetIDs = "SubnetIds"
        case securityGroupIDs = "SecurityGroupIds"
    }
}

/// Specifies encryption at rest options.
public struct EncryptionAtRestOptions: Codable {
    public var enabled: Enabled?
    public var kmsKeyID: KmsKeyID?

    public struct Enabled: Codable {
        public var isBool: Bool
        /// The option to enable encryption at rest.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class KmsKeyID: Codable {
        public var kmsKeyID: AmazonOpenSearchAPI.KmsKeyID
        /// The KMS key ID for encryption at rest options.
        public var anyJSON: AnyJSON

        public init(kmsKeyID: AmazonOpenSearchAPI.KmsKeyID, anyJSON: AnyJSON) {
            self.kmsKeyID = kmsKeyID
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.kmsKeyID = try values.decode(AmazonOpenSearchAPI.KmsKeyID.self, forKey: "kmsKeyID")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(kmsKeyID, forKey: "kmsKeyID")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(enabled: Enabled? = nil, kmsKeyID: KmsKeyID? = nil) {
        self.enabled = enabled
        self.kmsKeyID = kmsKeyID
    }

    private enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case kmsKeyID = "KmsKeyId"
    }
}

/// The node-to-node encryption options.
public struct NodeToNodeEncryptionOptions: Codable {
    public var enabled: Enabled?

    public struct Enabled: Codable {
        public var isBool: Bool
        /// True to enable node-to-node encryption.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(enabled: Enabled? = nil) {
        self.enabled = enabled
    }

    private enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }
}

/// Options to configure the endpoint for the domain.
public struct DomainEndpointOptions: Codable {
    public var enforceHTTPS: EnforceHTTPS?
    public var tlsSecurityPolicy: TLSSecurityPolicy?
    public var customEndpointEnabled: CustomEndpointEnabled?
    public var customEndpoint: CustomEndpoint?
    public var customEndpointCertificateArn: CustomEndpointCertificateArn?

    public struct EnforceHTTPS: Codable {
        public var isBool: Bool
        /// Whether only HTTPS endpoint should be enabled for the domain.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class TLSSecurityPolicy: Codable {
        public var tlsSecurityPolicy: AmazonOpenSearchAPI.TLSSecurityPolicy
        /// Specify the TLS security policy to apply to the HTTPS endpoint of the domain. <br/> Can be one of the following values: <ul> <li> <b>Policy-Min-TLS-1-0-2019-07:</b> TLS security policy which supports TLSv1.0 and higher. </li> <li> <b>Policy-Min-TLS-1-2-2019-07:</b> TLS security policy which supports only TLSv1.2 </li> </ul>
        public var anyJSON: AnyJSON

        public init(tlsSecurityPolicy: AmazonOpenSearchAPI.TLSSecurityPolicy, anyJSON: AnyJSON) {
            self.tlsSecurityPolicy = tlsSecurityPolicy
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.tlsSecurityPolicy = try values.decode(AmazonOpenSearchAPI.TLSSecurityPolicy.self, forKey: "tlsSecurityPolicy")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(tlsSecurityPolicy, forKey: "tlsSecurityPolicy")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct CustomEndpointEnabled: Codable {
        public var isBool: Bool
        /// Whether to enable a custom endpoint for the domain.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct CustomEndpoint: Codable {
        public var string: String
        /// The fully qualified domain for your custom endpoint.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct CustomEndpointCertificateArn: Codable {
        /// The Amazon Resource Name (ARN) of the domain. See <a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/index.html" target="_blank">Identifiers for IAM Entities </a> in <i>Using AWS Identity and Access Management</i> for more information.
        public var string: String
        /// The ACM certificate ARN for your custom endpoint.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(enforceHTTPS: EnforceHTTPS? = nil, tlsSecurityPolicy: TLSSecurityPolicy? = nil, customEndpointEnabled: CustomEndpointEnabled? = nil, customEndpoint: CustomEndpoint? = nil, customEndpointCertificateArn: CustomEndpointCertificateArn? = nil) {
        self.enforceHTTPS = enforceHTTPS
        self.tlsSecurityPolicy = tlsSecurityPolicy
        self.customEndpointEnabled = customEndpointEnabled
        self.customEndpoint = customEndpoint
        self.customEndpointCertificateArn = customEndpointCertificateArn
    }

    private enum CodingKeys: String, CodingKey {
        case enforceHTTPS = "EnforceHTTPS"
        case tlsSecurityPolicy = "TLSSecurityPolicy"
        case customEndpointEnabled = "CustomEndpointEnabled"
        case customEndpoint = "CustomEndpoint"
        case customEndpointCertificateArn = "CustomEndpointCertificateArn"
    }
}

public struct CreateDomainRequest: Codable {
    public var domainName: DomainName
    public var engineVersion: EngineVersion?
    public var clusterConfig: ClusterConfig?
    public var eBSOptions: EBSOptions?
    public var accessPolicies: AccessPolicies?
    public var snapshotOptions: SnapshotOptions?
    public var vPCOptions: VPCOptions?
    public var cognitoOptions: CognitoOptions?
    public var encryptionAtRestOptions: EncryptionAtRestOptions?
    public var nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions?
    public var advancedOptions: AdvancedOptions?
    public var logPublishingOptions: LogPublishingOptions?
    public var domainEndpointOptions: DomainEndpointOptions?
    public var advancedSecurityOptions: AdvancedSecurityOptions?
    public var tagList: TagList?
    public var autoTuneOptions: AutoTuneOptions?

    public final class DomainName: Codable {
        /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
        public var domainName: AmazonOpenSearchAPI.DomainName
        /// The name of the Amazon OpenSearch Service domain you're creating. Domain names are unique across the domains owned by an account within an AWS region. Domain names must start with a lowercase letter and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
        public var anyJSON: AnyJSON

        public init(domainName: AmazonOpenSearchAPI.DomainName, anyJSON: AnyJSON) {
            self.domainName = domainName
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainName = try values.decode(AmazonOpenSearchAPI.DomainName.self, forKey: "domainName")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainName, forKey: "domainName")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct EngineVersion: Codable {
        public var string: String
        /// String of format Elasticsearch_X.Y or OpenSearch_X.Y to specify the engine version for the Amazon OpenSearch Service domain. For example, "OpenSearch_1.0" or "Elasticsearch_7.9". For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomains" target="_blank">Creating and managing Amazon OpenSearch Service domains </a>.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class ClusterConfig: Codable {
        /// The configuration for the domain cluster, such as the type and number of instances.
        public var clusterConfig: AmazonOpenSearchAPI.ClusterConfig
        /// Configuration options for a domain. Specifies the instance type and number of instances in the domain.
        public var anyJSON: AnyJSON

        public init(clusterConfig: AmazonOpenSearchAPI.ClusterConfig, anyJSON: AnyJSON) {
            self.clusterConfig = clusterConfig
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.clusterConfig = try values.decode(AmazonOpenSearchAPI.ClusterConfig.self, forKey: "clusterConfig")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(clusterConfig, forKey: "clusterConfig")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class EBSOptions: Codable {
        /// Options to enable, disable, and specify the properties of EBS storage volumes.
        public var eBSOptions: AmazonOpenSearchAPI.EBSOptions
        /// Options to enable, disable, and specify the type and size of EBS storage volumes.
        public var anyJSON: AnyJSON

        public init(eBSOptions: AmazonOpenSearchAPI.EBSOptions, anyJSON: AnyJSON) {
            self.eBSOptions = eBSOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.eBSOptions = try values.decode(AmazonOpenSearchAPI.EBSOptions.self, forKey: "eBSOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(eBSOptions, forKey: "eBSOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AccessPolicies: Codable {
        /// Access policy rules for a domain service endpoints. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-access-policies" target="_blank">Configuring access policies </a>. The maximum size of a policy document is 100 KB.
        public var string: String
        /// IAM access policy as a JSON-formatted string.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class SnapshotOptions: Codable {
        /// The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.
        public var snapshotOptions: AmazonOpenSearchAPI.SnapshotOptions
        /// Option to set time, in UTC format, of the daily automated snapshot. Default value is 0 hours.
        public var anyJSON: AnyJSON

        public init(snapshotOptions: AmazonOpenSearchAPI.SnapshotOptions, anyJSON: AnyJSON) {
            self.snapshotOptions = snapshotOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.snapshotOptions = try values.decode(AmazonOpenSearchAPI.SnapshotOptions.self, forKey: "snapshotOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(snapshotOptions, forKey: "snapshotOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class VPCOptions: Codable {
        /// Options to specify the subnets and security groups for the VPC endpoint. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>.
        public var vPCOptions: AmazonOpenSearchAPI.VPCOptions
        /// Options to specify the subnets and security groups for a VPC endpoint. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank">Launching your Amazon OpenSearch Service domains using a VPC </a>.
        public var anyJSON: AnyJSON

        public init(vPCOptions: AmazonOpenSearchAPI.VPCOptions, anyJSON: AnyJSON) {
            self.vPCOptions = vPCOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.vPCOptions = try values.decode(AmazonOpenSearchAPI.VPCOptions.self, forKey: "vPCOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(vPCOptions, forKey: "vPCOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class CognitoOptions: Codable {
        /// Options to specify the Cognito user and identity pools for OpenSearch Dashboards authentication. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>.
        public var cognitoOptions: AmazonOpenSearchAPI.CognitoOptions
        /// Options to specify the Cognito user and identity pools for OpenSearch Dashboards authentication. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>.
        public var anyJSON: AnyJSON

        public init(cognitoOptions: AmazonOpenSearchAPI.CognitoOptions, anyJSON: AnyJSON) {
            self.cognitoOptions = cognitoOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.cognitoOptions = try values.decode(AmazonOpenSearchAPI.CognitoOptions.self, forKey: "cognitoOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(cognitoOptions, forKey: "cognitoOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class EncryptionAtRestOptions: Codable {
        /// Specifies encryption at rest options.
        public var encryptionAtRestOptions: AmazonOpenSearchAPI.EncryptionAtRestOptions
        /// Options for encryption of data at rest.
        public var anyJSON: AnyJSON

        public init(encryptionAtRestOptions: AmazonOpenSearchAPI.EncryptionAtRestOptions, anyJSON: AnyJSON) {
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.encryptionAtRestOptions = try values.decode(AmazonOpenSearchAPI.EncryptionAtRestOptions.self, forKey: "encryptionAtRestOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(encryptionAtRestOptions, forKey: "encryptionAtRestOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class NodeToNodeEncryptionOptions: Codable {
        /// The node-to-node encryption options.
        public var nodeToNodeEncryptionOptions: AmazonOpenSearchAPI.NodeToNodeEncryptionOptions
        /// Node-to-node encryption options.
        public var anyJSON: AnyJSON

        public init(nodeToNodeEncryptionOptions: AmazonOpenSearchAPI.NodeToNodeEncryptionOptions, anyJSON: AnyJSON) {
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.nodeToNodeEncryptionOptions = try values.decode(AmazonOpenSearchAPI.NodeToNodeEncryptionOptions.self, forKey: "nodeToNodeEncryptionOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(nodeToNodeEncryptionOptions, forKey: "nodeToNodeEncryptionOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class AdvancedOptions: Codable {
        /// <p>Exposes select native OpenSearch configuration values from <code>opensearch.yml</code>. Currently, the following advanced options are available: </p> <ul> <li>Option to allow references to indices in an HTTP request body. Must be <code>false</code> when configuring access to individual sub-resources. By default, the value is <code>true</code>. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced cluster parameters </a> for more information. </li> <li>Option to specify the percentage of heap space allocated to field data. By default, this setting is unbounded. </li> </ul> <p>For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options"> Advanced cluster parameters</a>. </p>
        public var advancedOptions: AmazonOpenSearchAPI.AdvancedOptions
        /// Option to allow references to indices in an HTTP request body. Must be <code>false</code> when configuring access to individual sub-resources. By default, the value is <code>true</code>. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced cluster parameters </a> for more information.
        public var anyJSON: AnyJSON

        public init(advancedOptions: AmazonOpenSearchAPI.AdvancedOptions, anyJSON: AnyJSON) {
            self.advancedOptions = advancedOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.advancedOptions = try values.decode(AmazonOpenSearchAPI.AdvancedOptions.self, forKey: "advancedOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(advancedOptions, forKey: "advancedOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class LogPublishingOptions: Codable {
        public var logPublishingOptions: AmazonOpenSearchAPI.LogPublishingOptions
        /// Map of <code>LogType</code> and <code>LogPublishingOption</code>, each containing options to publish a given type of OpenSearch log.
        public var anyJSON: AnyJSON

        public init(logPublishingOptions: AmazonOpenSearchAPI.LogPublishingOptions, anyJSON: AnyJSON) {
            self.logPublishingOptions = logPublishingOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.logPublishingOptions = try values.decode(AmazonOpenSearchAPI.LogPublishingOptions.self, forKey: "logPublishingOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(logPublishingOptions, forKey: "logPublishingOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class DomainEndpointOptions: Codable {
        /// Options to configure the endpoint for the domain.
        public var domainEndpointOptions: AmazonOpenSearchAPI.DomainEndpointOptions
        /// Options to specify configurations that will be applied to the domain endpoint.
        public var anyJSON: AnyJSON

        public init(domainEndpointOptions: AmazonOpenSearchAPI.DomainEndpointOptions, anyJSON: AnyJSON) {
            self.domainEndpointOptions = domainEndpointOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainEndpointOptions = try values.decode(AmazonOpenSearchAPI.DomainEndpointOptions.self, forKey: "domainEndpointOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainEndpointOptions, forKey: "domainEndpointOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AdvancedSecurityOptions: Codable {
        /// The advanced security configuration: whether advanced security is enabled, whether the internal database option is enabled, master username and password (if internal database is enabled), and master user ARN (if IAM is enabled).
        public var advancedSecurityOptionsInput: AdvancedSecurityOptionsInput
        /// Specifies advanced security options.
        public var anyJSON: AnyJSON

        public init(advancedSecurityOptionsInput: AdvancedSecurityOptionsInput, anyJSON: AnyJSON) {
            self.advancedSecurityOptionsInput = advancedSecurityOptionsInput
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.advancedSecurityOptionsInput = try AdvancedSecurityOptionsInput(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(advancedSecurityOptionsInput, forKey: "advancedSecurityOptionsInput")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class TagList: Codable {
        /// A list of <code>Tag</code>.
        public var tagList: AmazonOpenSearchAPI.TagList
        /// A list of <code>Tag</code> added during domain creation.
        public var anyJSON: AnyJSON

        public init(tagList: AmazonOpenSearchAPI.TagList, anyJSON: AnyJSON) {
            self.tagList = tagList
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.tagList = try values.decode(AmazonOpenSearchAPI.TagList.self, forKey: "tagList")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(tagList, forKey: "tagList")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AutoTuneOptions: Codable {
        /// The Auto-Tune options: the Auto-Tune desired state for the domain and list of maintenance schedules.
        public var autoTuneOptionsInput: AutoTuneOptionsInput
        /// Specifies Auto-Tune options.
        public var anyJSON: AnyJSON

        public init(autoTuneOptionsInput: AutoTuneOptionsInput, anyJSON: AnyJSON) {
            self.autoTuneOptionsInput = autoTuneOptionsInput
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.autoTuneOptionsInput = try AutoTuneOptionsInput(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(autoTuneOptionsInput, forKey: "autoTuneOptionsInput")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(domainName: DomainName, engineVersion: EngineVersion? = nil, clusterConfig: ClusterConfig? = nil, eBSOptions: EBSOptions? = nil, accessPolicies: AccessPolicies? = nil, snapshotOptions: SnapshotOptions? = nil, vPCOptions: VPCOptions? = nil, cognitoOptions: CognitoOptions? = nil, encryptionAtRestOptions: EncryptionAtRestOptions? = nil, nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions? = nil, advancedOptions: AdvancedOptions? = nil, logPublishingOptions: LogPublishingOptions? = nil, domainEndpointOptions: DomainEndpointOptions? = nil, advancedSecurityOptions: AdvancedSecurityOptions? = nil, tagList: TagList? = nil, autoTuneOptions: AutoTuneOptions? = nil) {
        self.domainName = domainName
        self.engineVersion = engineVersion
        self.clusterConfig = clusterConfig
        self.eBSOptions = eBSOptions
        self.accessPolicies = accessPolicies
        self.snapshotOptions = snapshotOptions
        self.vPCOptions = vPCOptions
        self.cognitoOptions = cognitoOptions
        self.encryptionAtRestOptions = encryptionAtRestOptions
        self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
        self.advancedOptions = advancedOptions
        self.logPublishingOptions = logPublishingOptions
        self.domainEndpointOptions = domainEndpointOptions
        self.advancedSecurityOptions = advancedSecurityOptions
        self.tagList = tagList
        self.autoTuneOptions = autoTuneOptions
    }

    private enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case engineVersion = "EngineVersion"
        case clusterConfig = "ClusterConfig"
        case eBSOptions = "EBSOptions"
        case accessPolicies = "AccessPolicies"
        case snapshotOptions = "SnapshotOptions"
        case vPCOptions = "VPCOptions"
        case cognitoOptions = "CognitoOptions"
        case encryptionAtRestOptions = "EncryptionAtRestOptions"
        case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
        case advancedOptions = "AdvancedOptions"
        case logPublishingOptions = "LogPublishingOptions"
        case domainEndpointOptions = "DomainEndpointOptions"
        case advancedSecurityOptions = "AdvancedSecurityOptions"
        case tagList = "TagList"
        case autoTuneOptions = "AutoTuneOptions"
    }
}

/// The current status of a domain.
public struct DomainStatus: Codable {
    public var domainID: DomainID
    public var domainName: DomainName
    public var arn: Arn
    public var created: Created?
    public var deleted: Deleted?
    public var endpoint: Endpoint?
    public var endpoints: Endpoints?
    public var processing: Processing?
    public var upgradeProcessing: UpgradeProcessing?
    public var engineVersion: String?
    public var clusterConfig: ClusterConfig
    public var eBSOptions: EBSOptions?
    public var accessPolicies: AccessPolicies?
    public var snapshotOptions: SnapshotOptions?
    public var vPCOptions: VPCOptions?
    public var cognitoOptions: CognitoOptions?
    public var encryptionAtRestOptions: EncryptionAtRestOptions?
    public var nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions?
    public var advancedOptions: AdvancedOptions?
    public var logPublishingOptions: LogPublishingOptions?
    public var serviceSoftwareOptions: ServiceSoftwareOptions?
    public var domainEndpointOptions: DomainEndpointOptions?
    public var advancedSecurityOptions: AdvancedSecurityOptions?
    public var autoTuneOptions: AutoTuneOptions?

    public final class DomainID: Codable {
        /// Unique identifier for the domain.
        public var domainID: AmazonOpenSearchAPI.DomainID
        /// The unique identifier for the specified domain.
        public var anyJSON: AnyJSON

        public init(domainID: AmazonOpenSearchAPI.DomainID, anyJSON: AnyJSON) {
            self.domainID = domainID
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainID = try values.decode(AmazonOpenSearchAPI.DomainID.self, forKey: "domainID")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainID, forKey: "domainID")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class DomainName: Codable {
        /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
        public var domainName: AmazonOpenSearchAPI.DomainName
        /// The name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
        public var anyJSON: AnyJSON

        public init(domainName: AmazonOpenSearchAPI.DomainName, anyJSON: AnyJSON) {
            self.domainName = domainName
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainName = try values.decode(AmazonOpenSearchAPI.DomainName.self, forKey: "domainName")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainName, forKey: "domainName")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class Arn: Codable {
        /// The Amazon Resource Name (ARN) of the domain. See <a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/index.html" target="_blank">Identifiers for IAM Entities </a> in <i>Using AWS Identity and Access Management</i> for more information.
        public var arn: AmazonOpenSearchAPI.Arn
        /// The Amazon Resource Name (ARN) of a domain. See <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html" target="_blank">IAM identifiers </a> in the <i>AWS Identity and Access Management User Guide</i> for more information.
        public var anyJSON: AnyJSON

        public init(arn: AmazonOpenSearchAPI.Arn, anyJSON: AnyJSON) {
            self.arn = arn
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.arn = try values.decode(AmazonOpenSearchAPI.Arn.self, forKey: "arn")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(arn, forKey: "arn")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Created: Codable {
        public var isBool: Bool
        /// The domain creation status. <code>True</code> if the creation of a domain is complete. <code> False </code> if domain creation is still in progress.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Deleted: Codable {
        public var isBool: Bool
        /// The domain deletion status. <code>True</code> if a delete request has been received for the domain but resource cleanup is still in progress. <code>False</code> if the domain has not been deleted. Once domain deletion is complete, the status of the domain is no longer returned.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Endpoint: Codable {
        /// The endpoint to which service requests are submitted. For example, <code> search-imdb-movies-oopcnjfn6ugofer3zx5iadxxca.eu-west-1.es.amazonaws.com </code> or <code>doc-imdb-movies-oopcnjfn6ugofer3zx5iadxxca.eu-west-1.es.amazonaws.com</code>.
        public var string: String
        /// The domain endpoint that you use to submit index and search requests.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Endpoints: Codable {
        public var stringString: [String: String]
        /// Map containing the domain endpoints used to submit index and search requests. Example <code>key, value</code>: <code>'vpc','vpc-endpoint-h2dsd34efgyghrtguk5gt6j2foh4.us-east-1.es.amazonaws.com'</code>.
        public var anyJSON: AnyJSON

        public init(stringString: [String: String], anyJSON: AnyJSON) {
            self.stringString = stringString
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.stringString = try values.decode([String: String].self, forKey: "stringString")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(stringString, forKey: "stringString")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Processing: Codable {
        public var isBool: Bool
        /// The status of the domain configuration. <code>True</code> if Amazon OpenSearch Service is processing configuration changes. <code>False</code> if the configuration is active.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct UpgradeProcessing: Codable {
        public var isBool: Bool
        /// The status of a domain version upgrade. <code>True</code> if Amazon OpenSearch Service is undergoing a version upgrade. <code>False</code> if the configuration is active.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class ClusterConfig: Codable {
        /// The configuration for the domain cluster, such as the type and number of instances.
        public var clusterConfig: AmazonOpenSearchAPI.ClusterConfig
        /// The type and number of instances in the domain.
        public var anyJSON: AnyJSON

        public init(clusterConfig: AmazonOpenSearchAPI.ClusterConfig, anyJSON: AnyJSON) {
            self.clusterConfig = clusterConfig
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.clusterConfig = try values.decode(AmazonOpenSearchAPI.ClusterConfig.self, forKey: "clusterConfig")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(clusterConfig, forKey: "clusterConfig")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class EBSOptions: Codable {
        /// Options to enable, disable, and specify the properties of EBS storage volumes.
        public var eBSOptions: AmazonOpenSearchAPI.EBSOptions
        /// The <code>EBSOptions</code> for the specified domain.
        public var anyJSON: AnyJSON

        public init(eBSOptions: AmazonOpenSearchAPI.EBSOptions, anyJSON: AnyJSON) {
            self.eBSOptions = eBSOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.eBSOptions = try values.decode(AmazonOpenSearchAPI.EBSOptions.self, forKey: "eBSOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(eBSOptions, forKey: "eBSOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AccessPolicies: Codable {
        /// Access policy rules for a domain service endpoints. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-access-policies" target="_blank">Configuring access policies </a>. The maximum size of a policy document is 100 KB.
        public var string: String
        /// IAM access policy as a JSON-formatted string.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class SnapshotOptions: Codable {
        /// The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.
        public var snapshotOptions: AmazonOpenSearchAPI.SnapshotOptions
        /// The status of the <code>SnapshotOptions</code>.
        public var anyJSON: AnyJSON

        public init(snapshotOptions: AmazonOpenSearchAPI.SnapshotOptions, anyJSON: AnyJSON) {
            self.snapshotOptions = snapshotOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.snapshotOptions = try values.decode(AmazonOpenSearchAPI.SnapshotOptions.self, forKey: "snapshotOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(snapshotOptions, forKey: "snapshotOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct VPCOptions: Codable {
        /// Options to specify the subnets and security groups for the VPC endpoint. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>.
        public var vPCDerivedInfo: VPCDerivedInfo
        /// The <code>VPCOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>.
        public var anyJSON: AnyJSON

        public init(vPCDerivedInfo: VPCDerivedInfo, anyJSON: AnyJSON) {
            self.vPCDerivedInfo = vPCDerivedInfo
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.vPCDerivedInfo = try VPCDerivedInfo(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(vPCDerivedInfo, forKey: "vPCDerivedInfo")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class CognitoOptions: Codable {
        /// Options to specify the Cognito user and identity pools for OpenSearch Dashboards authentication. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>.
        public var cognitoOptions: AmazonOpenSearchAPI.CognitoOptions
        /// The <code>CognitoOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>.
        public var anyJSON: AnyJSON

        public init(cognitoOptions: AmazonOpenSearchAPI.CognitoOptions, anyJSON: AnyJSON) {
            self.cognitoOptions = cognitoOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.cognitoOptions = try values.decode(AmazonOpenSearchAPI.CognitoOptions.self, forKey: "cognitoOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(cognitoOptions, forKey: "cognitoOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class EncryptionAtRestOptions: Codable {
        /// Specifies encryption at rest options.
        public var encryptionAtRestOptions: AmazonOpenSearchAPI.EncryptionAtRestOptions
        /// The status of the <code>EncryptionAtRestOptions</code>.
        public var anyJSON: AnyJSON

        public init(encryptionAtRestOptions: AmazonOpenSearchAPI.EncryptionAtRestOptions, anyJSON: AnyJSON) {
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.encryptionAtRestOptions = try values.decode(AmazonOpenSearchAPI.EncryptionAtRestOptions.self, forKey: "encryptionAtRestOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(encryptionAtRestOptions, forKey: "encryptionAtRestOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class NodeToNodeEncryptionOptions: Codable {
        /// The node-to-node encryption options.
        public var nodeToNodeEncryptionOptions: AmazonOpenSearchAPI.NodeToNodeEncryptionOptions
        /// The status of the <code>NodeToNodeEncryptionOptions</code>.
        public var anyJSON: AnyJSON

        public init(nodeToNodeEncryptionOptions: AmazonOpenSearchAPI.NodeToNodeEncryptionOptions, anyJSON: AnyJSON) {
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.nodeToNodeEncryptionOptions = try values.decode(AmazonOpenSearchAPI.NodeToNodeEncryptionOptions.self, forKey: "nodeToNodeEncryptionOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(nodeToNodeEncryptionOptions, forKey: "nodeToNodeEncryptionOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class AdvancedOptions: Codable {
        /// <p>Exposes select native OpenSearch configuration values from <code>opensearch.yml</code>. Currently, the following advanced options are available: </p> <ul> <li>Option to allow references to indices in an HTTP request body. Must be <code>false</code> when configuring access to individual sub-resources. By default, the value is <code>true</code>. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced cluster parameters </a> for more information. </li> <li>Option to specify the percentage of heap space allocated to field data. By default, this setting is unbounded. </li> </ul> <p>For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options"> Advanced cluster parameters</a>. </p>
        public var advancedOptions: AmazonOpenSearchAPI.AdvancedOptions
        /// The status of the <code>AdvancedOptions</code>.
        public var anyJSON: AnyJSON

        public init(advancedOptions: AmazonOpenSearchAPI.AdvancedOptions, anyJSON: AnyJSON) {
            self.advancedOptions = advancedOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.advancedOptions = try values.decode(AmazonOpenSearchAPI.AdvancedOptions.self, forKey: "advancedOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(advancedOptions, forKey: "advancedOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class LogPublishingOptions: Codable {
        public var logPublishingOptions: AmazonOpenSearchAPI.LogPublishingOptions
        /// Log publishing options for the given domain.
        public var anyJSON: AnyJSON

        public init(logPublishingOptions: AmazonOpenSearchAPI.LogPublishingOptions, anyJSON: AnyJSON) {
            self.logPublishingOptions = logPublishingOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.logPublishingOptions = try values.decode(AmazonOpenSearchAPI.LogPublishingOptions.self, forKey: "logPublishingOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(logPublishingOptions, forKey: "logPublishingOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class ServiceSoftwareOptions: Codable {
        /// The current options of an domain service software options.
        public var serviceSoftwareOptions: AmazonOpenSearchAPI.ServiceSoftwareOptions
        /// The current status of the domain's service software.
        public var anyJSON: AnyJSON

        public init(serviceSoftwareOptions: AmazonOpenSearchAPI.ServiceSoftwareOptions, anyJSON: AnyJSON) {
            self.serviceSoftwareOptions = serviceSoftwareOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.serviceSoftwareOptions = try values.decode(AmazonOpenSearchAPI.ServiceSoftwareOptions.self, forKey: "serviceSoftwareOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(serviceSoftwareOptions, forKey: "serviceSoftwareOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class DomainEndpointOptions: Codable {
        /// Options to configure the endpoint for the domain.
        public var domainEndpointOptions: AmazonOpenSearchAPI.DomainEndpointOptions
        /// The current status of the domain's endpoint options.
        public var anyJSON: AnyJSON

        public init(domainEndpointOptions: AmazonOpenSearchAPI.DomainEndpointOptions, anyJSON: AnyJSON) {
            self.domainEndpointOptions = domainEndpointOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainEndpointOptions = try values.decode(AmazonOpenSearchAPI.DomainEndpointOptions.self, forKey: "domainEndpointOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainEndpointOptions, forKey: "domainEndpointOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class AdvancedSecurityOptions: Codable {
        /// The advanced security configuration: whether advanced security is enabled, whether the internal database option is enabled.
        public var advancedSecurityOptions: AmazonOpenSearchAPI.AdvancedSecurityOptions
        /// The current status of the domain's advanced security options.
        public var anyJSON: AnyJSON

        public init(advancedSecurityOptions: AmazonOpenSearchAPI.AdvancedSecurityOptions, anyJSON: AnyJSON) {
            self.advancedSecurityOptions = advancedSecurityOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.advancedSecurityOptions = try values.decode(AmazonOpenSearchAPI.AdvancedSecurityOptions.self, forKey: "advancedSecurityOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(advancedSecurityOptions, forKey: "advancedSecurityOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AutoTuneOptions: Codable {
        /// The Auto-Tune options: the Auto-Tune desired state for the domain and list of maintenance schedules.
        public var autoTuneOptionsOutput: AutoTuneOptionsOutput
        /// The current status of the domain's Auto-Tune options.
        public var anyJSON: AnyJSON

        public init(autoTuneOptionsOutput: AutoTuneOptionsOutput, anyJSON: AnyJSON) {
            self.autoTuneOptionsOutput = autoTuneOptionsOutput
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.autoTuneOptionsOutput = try AutoTuneOptionsOutput(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(autoTuneOptionsOutput, forKey: "autoTuneOptionsOutput")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(domainID: DomainID, domainName: DomainName, arn: Arn, created: Created? = nil, deleted: Deleted? = nil, endpoint: Endpoint? = nil, endpoints: Endpoints? = nil, processing: Processing? = nil, upgradeProcessing: UpgradeProcessing? = nil, engineVersion: String? = nil, clusterConfig: ClusterConfig, eBSOptions: EBSOptions? = nil, accessPolicies: AccessPolicies? = nil, snapshotOptions: SnapshotOptions? = nil, vPCOptions: VPCOptions? = nil, cognitoOptions: CognitoOptions? = nil, encryptionAtRestOptions: EncryptionAtRestOptions? = nil, nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions? = nil, advancedOptions: AdvancedOptions? = nil, logPublishingOptions: LogPublishingOptions? = nil, serviceSoftwareOptions: ServiceSoftwareOptions? = nil, domainEndpointOptions: DomainEndpointOptions? = nil, advancedSecurityOptions: AdvancedSecurityOptions? = nil, autoTuneOptions: AutoTuneOptions? = nil) {
        self.domainID = domainID
        self.domainName = domainName
        self.arn = arn
        self.created = created
        self.deleted = deleted
        self.endpoint = endpoint
        self.endpoints = endpoints
        self.processing = processing
        self.upgradeProcessing = upgradeProcessing
        self.engineVersion = engineVersion
        self.clusterConfig = clusterConfig
        self.eBSOptions = eBSOptions
        self.accessPolicies = accessPolicies
        self.snapshotOptions = snapshotOptions
        self.vPCOptions = vPCOptions
        self.cognitoOptions = cognitoOptions
        self.encryptionAtRestOptions = encryptionAtRestOptions
        self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
        self.advancedOptions = advancedOptions
        self.logPublishingOptions = logPublishingOptions
        self.serviceSoftwareOptions = serviceSoftwareOptions
        self.domainEndpointOptions = domainEndpointOptions
        self.advancedSecurityOptions = advancedSecurityOptions
        self.autoTuneOptions = autoTuneOptions
    }

    private enum CodingKeys: String, CodingKey {
        case domainID = "DomainId"
        case domainName = "DomainName"
        case arn = "ARN"
        case created = "Created"
        case deleted = "Deleted"
        case endpoint = "Endpoint"
        case endpoints = "Endpoints"
        case processing = "Processing"
        case upgradeProcessing = "UpgradeProcessing"
        case engineVersion = "EngineVersion"
        case clusterConfig = "ClusterConfig"
        case eBSOptions = "EBSOptions"
        case accessPolicies = "AccessPolicies"
        case snapshotOptions = "SnapshotOptions"
        case vPCOptions = "VPCOptions"
        case cognitoOptions = "CognitoOptions"
        case encryptionAtRestOptions = "EncryptionAtRestOptions"
        case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
        case advancedOptions = "AdvancedOptions"
        case logPublishingOptions = "LogPublishingOptions"
        case serviceSoftwareOptions = "ServiceSoftwareOptions"
        case domainEndpointOptions = "DomainEndpointOptions"
        case advancedSecurityOptions = "AdvancedSecurityOptions"
        case autoTuneOptions = "AutoTuneOptions"
    }
}

public struct DomainInformationContainer: Codable {
    public var aWSDomainInformation: AWSDomainInformation?

    public init(aWSDomainInformation: AWSDomainInformation? = nil) {
        self.aWSDomainInformation = aWSDomainInformation
    }

    private enum CodingKeys: String, CodingKey {
        case aWSDomainInformation = "AWSDomainInformation"
    }
}

/// Container for the parameters to the <code> <a>CreateOutboundConnection</a> </code> operation.
public struct CreateOutboundConnectionRequest: Codable {
    public var localDomainInfo: LocalDomainInfo
    public var remoteDomainInfo: RemoteDomainInfo
    public var connectionAlias: ConnectionAlias

    public struct LocalDomainInfo: Codable {
        public var domainInformationContainer: DomainInformationContainer
        /// The <code> <a>AWSDomainInformation</a> </code> for the local OpenSearch domain.
        public var anyJSON: AnyJSON

        public init(domainInformationContainer: DomainInformationContainer, anyJSON: AnyJSON) {
            self.domainInformationContainer = domainInformationContainer
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.domainInformationContainer = try DomainInformationContainer(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainInformationContainer, forKey: "domainInformationContainer")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct RemoteDomainInfo: Codable {
        public var domainInformationContainer: DomainInformationContainer
        /// The <code> <a>AWSDomainInformation</a> </code> for the remote OpenSearch domain.
        public var anyJSON: AnyJSON

        public init(domainInformationContainer: DomainInformationContainer, anyJSON: AnyJSON) {
            self.domainInformationContainer = domainInformationContainer
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.domainInformationContainer = try DomainInformationContainer(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainInformationContainer, forKey: "domainInformationContainer")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class ConnectionAlias: Codable {
        public var connectionAlias: AmazonOpenSearchAPI.ConnectionAlias
        /// The connection alias used used by the customer for this cross-cluster connection.
        public var anyJSON: AnyJSON

        public init(connectionAlias: AmazonOpenSearchAPI.ConnectionAlias, anyJSON: AnyJSON) {
            self.connectionAlias = connectionAlias
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.connectionAlias = try values.decode(AmazonOpenSearchAPI.ConnectionAlias.self, forKey: "connectionAlias")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(connectionAlias, forKey: "connectionAlias")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(localDomainInfo: LocalDomainInfo, remoteDomainInfo: RemoteDomainInfo, connectionAlias: ConnectionAlias) {
        self.localDomainInfo = localDomainInfo
        self.remoteDomainInfo = remoteDomainInfo
        self.connectionAlias = connectionAlias
    }

    private enum CodingKeys: String, CodingKey {
        case localDomainInfo = "LocalDomainInfo"
        case remoteDomainInfo = "RemoteDomainInfo"
        case connectionAlias = "ConnectionAlias"
    }
}

/// The connection status of an outbound cross-cluster connection.
public struct OutboundConnectionStatus: Codable {
    public var statusCode: StatusCode?
    public var message: Message?

    public struct StatusCode: Codable {
        public var outboundConnectionStatusCode: OutboundConnectionStatusCode
        /// <p>The state code for the outbound connection. Can be one of the following:</p> <ul> <li>VALIDATING: The outbound connection request is being validated.</li> <li>VALIDATION_FAILED: Validation failed for the connection request.</li> <li>PENDING_ACCEPTANCE: Outbound connection request is validated and is not yet accepted by the remote domain owner. </li> <li>APPROVED: Outbound connection has been approved by the remote domain owner for getting provisioned.</li> <li>PROVISIONING: Outbound connection request is in process.</li> <li>ACTIVE: Outbound connection is active and ready to use.</li> <li>REJECTING: Outbound connection rejection by remote domain owner is in progress.</li> <li>REJECTED: Outbound connection request is rejected by remote domain owner.</li> <li>DELETING: Outbound connection deletion is in progress.</li> <li>DELETED: Outbound connection is deleted and can no longer be used.</li> </ul>
        public var anyJSON: AnyJSON

        public init(outboundConnectionStatusCode: OutboundConnectionStatusCode, anyJSON: AnyJSON) {
            self.outboundConnectionStatusCode = outboundConnectionStatusCode
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.outboundConnectionStatusCode = try OutboundConnectionStatusCode(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(outboundConnectionStatusCode, forKey: "outboundConnectionStatusCode")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Message: Codable {
        public var string: String
        /// Verbose information for the outbound connection status.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(statusCode: StatusCode? = nil, message: Message? = nil) {
        self.statusCode = statusCode
        self.message = message
    }

    private enum CodingKeys: String, CodingKey {
        case statusCode = "StatusCode"
        case message = "Message"
    }
}

public enum PackageType: String, Codable, CaseIterable {
    case txtDictionary = "TXT-DICTIONARY"
}

/// The Amazon S3 location for importing the package specified as <code>S3BucketName</code> and <code>S3Key</code>
public struct PackageSource: Codable {
    public var s3BucketName: S3BucketName?
    public var s3Key: S3Key?

    public final class S3BucketName: Codable {
        public var s3BucketName: AmazonOpenSearchAPI.S3BucketName
        /// The name of the Amazon S3 bucket containing the package.
        public var anyJSON: AnyJSON

        public init(s3BucketName: AmazonOpenSearchAPI.S3BucketName, anyJSON: AnyJSON) {
            self.s3BucketName = s3BucketName
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.s3BucketName = try values.decode(AmazonOpenSearchAPI.S3BucketName.self, forKey: "s3BucketName")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(s3BucketName, forKey: "s3BucketName")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class S3Key: Codable {
        public var s3Key: AmazonOpenSearchAPI.S3Key
        /// Key (file name) of the package.
        public var anyJSON: AnyJSON

        public init(s3Key: AmazonOpenSearchAPI.S3Key, anyJSON: AnyJSON) {
            self.s3Key = s3Key
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.s3Key = try values.decode(AmazonOpenSearchAPI.S3Key.self, forKey: "s3Key")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(s3Key, forKey: "s3Key")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(s3BucketName: S3BucketName? = nil, s3Key: S3Key? = nil) {
        self.s3BucketName = s3BucketName
        self.s3Key = s3Key
    }

    private enum CodingKeys: String, CodingKey {
        case s3BucketName = "S3BucketName"
        case s3Key = "S3Key"
    }
}

/// Container for request parameters to the <code> <a>CreatePackage</a> </code> operation.
public struct CreatePackageRequest: Codable {
    public var packageName: PackageName
    public var packageType: PackageType
    public var packageDescription: PackageDescription?
    public var packageSource: PackageSource

    public final class PackageName: Codable {
        public var packageName: AmazonOpenSearchAPI.PackageName
        /// Unique identifier for the package.
        public var anyJSON: AnyJSON

        public init(packageName: AmazonOpenSearchAPI.PackageName, anyJSON: AnyJSON) {
            self.packageName = packageName
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageName = try values.decode(AmazonOpenSearchAPI.PackageName.self, forKey: "packageName")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageName, forKey: "packageName")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class PackageType: Codable {
        public var packageType: AmazonOpenSearchAPI.PackageType
        /// Type of package. Currently supports only TXT-DICTIONARY.
        public var anyJSON: AnyJSON

        public init(packageType: AmazonOpenSearchAPI.PackageType, anyJSON: AnyJSON) {
            self.packageType = packageType
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageType = try values.decode(AmazonOpenSearchAPI.PackageType.self, forKey: "packageType")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageType, forKey: "packageType")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class PackageDescription: Codable {
        public var packageDescription: AmazonOpenSearchAPI.PackageDescription
        /// Description of the package.
        public var anyJSON: AnyJSON

        public init(packageDescription: AmazonOpenSearchAPI.PackageDescription, anyJSON: AnyJSON) {
            self.packageDescription = packageDescription
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageDescription = try values.decode(AmazonOpenSearchAPI.PackageDescription.self, forKey: "packageDescription")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageDescription, forKey: "packageDescription")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class PackageSource: Codable {
        /// The Amazon S3 location for importing the package specified as <code>S3BucketName</code> and <code>S3Key</code>
        public var packageSource: AmazonOpenSearchAPI.PackageSource
        /// The Amazon S3 location from which to import the package.
        public var anyJSON: AnyJSON

        public init(packageSource: AmazonOpenSearchAPI.PackageSource, anyJSON: AnyJSON) {
            self.packageSource = packageSource
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageSource = try values.decode(AmazonOpenSearchAPI.PackageSource.self, forKey: "packageSource")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageSource, forKey: "packageSource")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(packageName: PackageName, packageType: PackageType, packageDescription: PackageDescription? = nil, packageSource: PackageSource) {
        self.packageName = packageName
        self.packageType = packageType
        self.packageDescription = packageDescription
        self.packageSource = packageSource
    }

    private enum CodingKeys: String, CodingKey {
        case packageName = "PackageName"
        case packageType = "PackageType"
        case packageDescription = "PackageDescription"
        case packageSource = "PackageSource"
    }
}

/// Basic information about a package.
public struct PackageDetails: Codable {
    public var packageID: PackageID?
    public var packageName: PackageName?
    public var packageType: PackageType?
    public var packageDescription: PackageDescription?
    public var packageStatus: PackageStatus?
    public var createdAt: CreatedAt?
    public var lastUpdatedAt: Date?
    public var availablePackageVersion: String?
    public var errorDetails: ErrorDetails?

    public final class PackageID: Codable {
        public var packageID: AmazonOpenSearchAPI.PackageID
        /// Internal ID of the package.
        public var anyJSON: AnyJSON

        public init(packageID: AmazonOpenSearchAPI.PackageID, anyJSON: AnyJSON) {
            self.packageID = packageID
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageID = try values.decode(AmazonOpenSearchAPI.PackageID.self, forKey: "packageID")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageID, forKey: "packageID")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class PackageName: Codable {
        public var packageName: AmazonOpenSearchAPI.PackageName
        /// User-specified name of the package.
        public var anyJSON: AnyJSON

        public init(packageName: AmazonOpenSearchAPI.PackageName, anyJSON: AnyJSON) {
            self.packageName = packageName
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageName = try values.decode(AmazonOpenSearchAPI.PackageName.self, forKey: "packageName")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageName, forKey: "packageName")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class PackageType: Codable {
        public var packageType: AmazonOpenSearchAPI.PackageType
        /// Currently supports only TXT-DICTIONARY.
        public var anyJSON: AnyJSON

        public init(packageType: AmazonOpenSearchAPI.PackageType, anyJSON: AnyJSON) {
            self.packageType = packageType
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageType = try values.decode(AmazonOpenSearchAPI.PackageType.self, forKey: "packageType")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageType, forKey: "packageType")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class PackageDescription: Codable {
        public var packageDescription: AmazonOpenSearchAPI.PackageDescription
        /// User-specified description of the package.
        public var anyJSON: AnyJSON

        public init(packageDescription: AmazonOpenSearchAPI.PackageDescription, anyJSON: AnyJSON) {
            self.packageDescription = packageDescription
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageDescription = try values.decode(AmazonOpenSearchAPI.PackageDescription.self, forKey: "packageDescription")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageDescription, forKey: "packageDescription")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class PackageStatus: Codable {
        public var packageStatus: AmazonOpenSearchAPI.PackageStatus
        /// Current state of the package. Values are COPYING, COPY_FAILED, AVAILABLE, DELETING, and DELETE_FAILED.
        public var anyJSON: AnyJSON

        public init(packageStatus: AmazonOpenSearchAPI.PackageStatus, anyJSON: AnyJSON) {
            self.packageStatus = packageStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageStatus = try values.decode(AmazonOpenSearchAPI.PackageStatus.self, forKey: "packageStatus")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageStatus, forKey: "packageStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class CreatedAt: Codable {
        public var createdAt: AmazonOpenSearchAPI.CreatedAt
        /// The timestamp of when the package was created.
        public var anyJSON: AnyJSON

        public init(createdAt: AmazonOpenSearchAPI.CreatedAt, anyJSON: AnyJSON) {
            self.createdAt = createdAt
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.createdAt = try values.decode(AmazonOpenSearchAPI.CreatedAt.self, forKey: "createdAt")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(createdAt, forKey: "createdAt")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class ErrorDetails: Codable {
        public var errorDetails: AmazonOpenSearchAPI.ErrorDetails
        /// Additional information if the package is in an error state. Null otherwise.
        public var anyJSON: AnyJSON

        public init(errorDetails: AmazonOpenSearchAPI.ErrorDetails, anyJSON: AnyJSON) {
            self.errorDetails = errorDetails
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.errorDetails = try values.decode(AmazonOpenSearchAPI.ErrorDetails.self, forKey: "errorDetails")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(errorDetails, forKey: "errorDetails")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(packageID: PackageID? = nil, packageName: PackageName? = nil, packageType: PackageType? = nil, packageDescription: PackageDescription? = nil, packageStatus: PackageStatus? = nil, createdAt: CreatedAt? = nil, lastUpdatedAt: Date? = nil, availablePackageVersion: String? = nil, errorDetails: ErrorDetails? = nil) {
        self.packageID = packageID
        self.packageName = packageName
        self.packageType = packageType
        self.packageDescription = packageDescription
        self.packageStatus = packageStatus
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.availablePackageVersion = availablePackageVersion
        self.errorDetails = errorDetails
    }

    private enum CodingKeys: String, CodingKey {
        case packageID = "PackageID"
        case packageName = "PackageName"
        case packageType = "PackageType"
        case packageDescription = "PackageDescription"
        case packageStatus = "PackageStatus"
        case createdAt = "CreatedAt"
        case lastUpdatedAt = "LastUpdatedAt"
        case availablePackageVersion = "AvailablePackageVersion"
        case errorDetails = "ErrorDetails"
    }
}

/// Specifies details about an outbound connection.
public struct OutboundConnection: Codable {
    public var localDomainInfo: LocalDomainInfo?
    public var remoteDomainInfo: RemoteDomainInfo?
    public var connectionID: ConnectionID?
    public var connectionAlias: ConnectionAlias?
    public var connectionStatus: ConnectionStatus?

    public struct LocalDomainInfo: Codable {
        public var domainInformationContainer: DomainInformationContainer
        /// The <code> <a>DomainInformation</a> </code> for the local OpenSearch domain.
        public var anyJSON: AnyJSON

        public init(domainInformationContainer: DomainInformationContainer, anyJSON: AnyJSON) {
            self.domainInformationContainer = domainInformationContainer
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.domainInformationContainer = try DomainInformationContainer(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainInformationContainer, forKey: "domainInformationContainer")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct RemoteDomainInfo: Codable {
        public var domainInformationContainer: DomainInformationContainer
        /// The <code> <a>DomainInformation</a> </code> for the remote OpenSearch domain.
        public var anyJSON: AnyJSON

        public init(domainInformationContainer: DomainInformationContainer, anyJSON: AnyJSON) {
            self.domainInformationContainer = domainInformationContainer
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.domainInformationContainer = try DomainInformationContainer(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainInformationContainer, forKey: "domainInformationContainer")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class ConnectionID: Codable {
        public var connectionID: AmazonOpenSearchAPI.ConnectionID
        /// The connection ID for the outbound cross-cluster connection.
        public var anyJSON: AnyJSON

        public init(connectionID: AmazonOpenSearchAPI.ConnectionID, anyJSON: AnyJSON) {
            self.connectionID = connectionID
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.connectionID = try values.decode(AmazonOpenSearchAPI.ConnectionID.self, forKey: "connectionID")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(connectionID, forKey: "connectionID")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class ConnectionAlias: Codable {
        public var connectionAlias: AmazonOpenSearchAPI.ConnectionAlias
        /// The connection alias for the outbound cross-cluster connection.
        public var anyJSON: AnyJSON

        public init(connectionAlias: AmazonOpenSearchAPI.ConnectionAlias, anyJSON: AnyJSON) {
            self.connectionAlias = connectionAlias
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.connectionAlias = try values.decode(AmazonOpenSearchAPI.ConnectionAlias.self, forKey: "connectionAlias")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(connectionAlias, forKey: "connectionAlias")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ConnectionStatus: Codable {
        /// The connection status of an outbound cross-cluster connection.
        public var outboundConnectionStatus: OutboundConnectionStatus
        /// The <code> <a>OutboundConnectionStatus</a> </code> for the outbound connection.
        public var anyJSON: AnyJSON

        public init(outboundConnectionStatus: OutboundConnectionStatus, anyJSON: AnyJSON) {
            self.outboundConnectionStatus = outboundConnectionStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.outboundConnectionStatus = try OutboundConnectionStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(outboundConnectionStatus, forKey: "outboundConnectionStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(localDomainInfo: LocalDomainInfo? = nil, remoteDomainInfo: RemoteDomainInfo? = nil, connectionID: ConnectionID? = nil, connectionAlias: ConnectionAlias? = nil, connectionStatus: ConnectionStatus? = nil) {
        self.localDomainInfo = localDomainInfo
        self.remoteDomainInfo = remoteDomainInfo
        self.connectionID = connectionID
        self.connectionAlias = connectionAlias
        self.connectionStatus = connectionStatus
    }

    private enum CodingKeys: String, CodingKey {
        case localDomainInfo = "LocalDomainInfo"
        case remoteDomainInfo = "RemoteDomainInfo"
        case connectionID = "ConnectionId"
        case connectionAlias = "ConnectionAlias"
        case connectionStatus = "ConnectionStatus"
    }
}

public enum DeploymentStatus: String, Codable, CaseIterable {
    case pendingUpdate = "PENDING_UPDATE"
    case inProgress = "IN_PROGRESS"
    case completed = "COMPLETED"
    case notEligible = "NOT_ELIGIBLE"
    case eligible = "ELIGIBLE"
}

/// Container for the parameters to the <code>DescribeDomainAutoTunes</code> operation.
public struct DescribeDomainAutoTunesRequest: Codable {
    public var maxResults: MaxResults?
    public var nextToken: NextToken?

    public final class MaxResults: Codable {
        /// Set this value to limit the number of results returned.
        public var maxResults: AmazonOpenSearchAPI.MaxResults
        /// Set this value to limit the number of results returned. If not specified, defaults to 100.
        public var anyJSON: AnyJSON

        public init(maxResults: AmazonOpenSearchAPI.MaxResults, anyJSON: AnyJSON) {
            self.maxResults = maxResults
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.maxResults = try values.decode(AmazonOpenSearchAPI.MaxResults.self, forKey: "maxResults")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(maxResults, forKey: "maxResults")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class NextToken: Codable {
        /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
        public var nextToken: AmazonOpenSearchAPI.NextToken
        /// NextToken is sent in case the earlier API call results contain the NextToken. Used for pagination.
        public var anyJSON: AnyJSON

        public init(nextToken: AmazonOpenSearchAPI.NextToken, anyJSON: AnyJSON) {
            self.nextToken = nextToken
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.nextToken = try values.decode(AmazonOpenSearchAPI.NextToken.self, forKey: "nextToken")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(nextToken, forKey: "nextToken")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(maxResults: MaxResults? = nil, nextToken: NextToken? = nil) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }
}

/// The configuration of a domain.
public struct DomainConfig: Codable {
    public var engineVersion: EngineVersion?
    public var clusterConfig: ClusterConfig?
    public var eBSOptions: EBSOptions?
    public var accessPolicies: AccessPolicies?
    public var snapshotOptions: SnapshotOptions?
    public var vPCOptions: VPCOptions?
    public var cognitoOptions: CognitoOptions?
    public var encryptionAtRestOptions: EncryptionAtRestOptions?
    public var nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions?
    public var advancedOptions: AdvancedOptions?
    public var logPublishingOptions: LogPublishingOptions?
    public var domainEndpointOptions: DomainEndpointOptions?
    public var advancedSecurityOptions: AdvancedSecurityOptions?
    public var autoTuneOptions: AutoTuneOptions?

    public struct EngineVersion: Codable {
        /// The status of the OpenSearch version options for the specified OpenSearch domain.
        public var versionStatus: VersionStatus
        /// String of format Elasticsearch_X.Y or OpenSearch_X.Y to specify the engine version for the OpenSearch or Elasticsearch domain.
        public var anyJSON: AnyJSON

        public init(versionStatus: VersionStatus, anyJSON: AnyJSON) {
            self.versionStatus = versionStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.versionStatus = try VersionStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(versionStatus, forKey: "versionStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class ClusterConfig: Codable {
        /// The configuration status for the specified domain.
        public var clusterConfigStatus: ClusterConfigStatus
        /// The <code>ClusterConfig</code> for the domain.
        public var anyJSON: AnyJSON

        public init(clusterConfigStatus: ClusterConfigStatus, anyJSON: AnyJSON) {
            self.clusterConfigStatus = clusterConfigStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.clusterConfigStatus = try ClusterConfigStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(clusterConfigStatus, forKey: "clusterConfigStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class EBSOptions: Codable {
        /// Status of the EBS options for the specified domain.
        public var eBSOptionsStatus: EBSOptionsStatus
        /// The <code>EBSOptions</code> for the domain.
        public var anyJSON: AnyJSON

        public init(eBSOptionsStatus: EBSOptionsStatus, anyJSON: AnyJSON) {
            self.eBSOptionsStatus = eBSOptionsStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.eBSOptionsStatus = try EBSOptionsStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(eBSOptionsStatus, forKey: "eBSOptionsStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AccessPolicies: Codable {
        /// The configured access rules for the domain's document and search endpoints, and the current status of those rules.
        public var accessPoliciesStatus: AccessPoliciesStatus
        /// IAM access policy as a JSON-formatted string.
        public var anyJSON: AnyJSON

        public init(accessPoliciesStatus: AccessPoliciesStatus, anyJSON: AnyJSON) {
            self.accessPoliciesStatus = accessPoliciesStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.accessPoliciesStatus = try AccessPoliciesStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(accessPoliciesStatus, forKey: "accessPoliciesStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class SnapshotOptions: Codable {
        /// Status of a daily automated snapshot.
        public var snapshotOptionsStatus: SnapshotOptionsStatus
        /// The <code>SnapshotOptions</code> for the domain.
        public var anyJSON: AnyJSON

        public init(snapshotOptionsStatus: SnapshotOptionsStatus, anyJSON: AnyJSON) {
            self.snapshotOptionsStatus = snapshotOptionsStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.snapshotOptionsStatus = try SnapshotOptionsStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(snapshotOptionsStatus, forKey: "snapshotOptionsStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct VPCOptions: Codable {
        /// Status of the VPC options for the specified domain.
        public var vPCDerivedInfoStatus: VPCDerivedInfoStatus
        /// The <code>VPCOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>.
        public var anyJSON: AnyJSON

        public init(vPCDerivedInfoStatus: VPCDerivedInfoStatus, anyJSON: AnyJSON) {
            self.vPCDerivedInfoStatus = vPCDerivedInfoStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.vPCDerivedInfoStatus = try VPCDerivedInfoStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(vPCDerivedInfoStatus, forKey: "vPCDerivedInfoStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class CognitoOptions: Codable {
        /// The status of the Cognito options for the specified domain.
        public var cognitoOptionsStatus: CognitoOptionsStatus
        /// The <code>CognitoOptions</code> for the specified domain. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>.
        public var anyJSON: AnyJSON

        public init(cognitoOptionsStatus: CognitoOptionsStatus, anyJSON: AnyJSON) {
            self.cognitoOptionsStatus = cognitoOptionsStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.cognitoOptionsStatus = try CognitoOptionsStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(cognitoOptionsStatus, forKey: "cognitoOptionsStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class EncryptionAtRestOptions: Codable {
        /// Status of the encryption At Rest options for the specified domain.
        public var encryptionAtRestOptionsStatus: EncryptionAtRestOptionsStatus
        /// The <code>EncryptionAtRestOptions</code> for the domain.
        public var anyJSON: AnyJSON

        public init(encryptionAtRestOptionsStatus: EncryptionAtRestOptionsStatus, anyJSON: AnyJSON) {
            self.encryptionAtRestOptionsStatus = encryptionAtRestOptionsStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.encryptionAtRestOptionsStatus = try EncryptionAtRestOptionsStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(encryptionAtRestOptionsStatus, forKey: "encryptionAtRestOptionsStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class NodeToNodeEncryptionOptions: Codable {
        /// Status of the node-to-node encryption options for the specified domain.
        public var nodeToNodeEncryptionOptionsStatus: NodeToNodeEncryptionOptionsStatus
        /// The <code>NodeToNodeEncryptionOptions</code> for the domain.
        public var anyJSON: AnyJSON

        public init(nodeToNodeEncryptionOptionsStatus: NodeToNodeEncryptionOptionsStatus, anyJSON: AnyJSON) {
            self.nodeToNodeEncryptionOptionsStatus = nodeToNodeEncryptionOptionsStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.nodeToNodeEncryptionOptionsStatus = try NodeToNodeEncryptionOptionsStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(nodeToNodeEncryptionOptionsStatus, forKey: "nodeToNodeEncryptionOptionsStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AdvancedOptions: Codable {
        /// <p>Status of the advanced options for the specified domain. Currently, the following advanced options are available: </p> <ul> <li>Option to allow references to indices in an HTTP request body. Must be <code>false</code> when configuring access to individual sub-resources. By default, the value is <code>true</code>. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced cluster parameters </a> for more information. </li> <li>Option to specify the percentage of heap space allocated to field data. By default, this setting is unbounded. </li> </ul> <p>For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options"> Advanced cluster parameters</a>. </p>
        public var advancedOptionsStatus: AdvancedOptionsStatus
        /// The <code>AdvancedOptions</code> for the domain. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced options </a> for more information.
        public var anyJSON: AnyJSON

        public init(advancedOptionsStatus: AdvancedOptionsStatus, anyJSON: AnyJSON) {
            self.advancedOptionsStatus = advancedOptionsStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.advancedOptionsStatus = try AdvancedOptionsStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(advancedOptionsStatus, forKey: "advancedOptionsStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct LogPublishingOptions: Codable {
        /// The configured log publishing options for the domain and their current status.
        public var logPublishingOptionsStatus: LogPublishingOptionsStatus
        /// Log publishing options for the given domain.
        public var anyJSON: AnyJSON

        public init(logPublishingOptionsStatus: LogPublishingOptionsStatus, anyJSON: AnyJSON) {
            self.logPublishingOptionsStatus = logPublishingOptionsStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.logPublishingOptionsStatus = try LogPublishingOptionsStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(logPublishingOptionsStatus, forKey: "logPublishingOptionsStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class DomainEndpointOptions: Codable {
        /// The configured endpoint options for the domain and their current status.
        public var domainEndpointOptionsStatus: DomainEndpointOptionsStatus
        /// The <code>DomainEndpointOptions</code> for the domain.
        public var anyJSON: AnyJSON

        public init(domainEndpointOptionsStatus: DomainEndpointOptionsStatus, anyJSON: AnyJSON) {
            self.domainEndpointOptionsStatus = domainEndpointOptionsStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.domainEndpointOptionsStatus = try DomainEndpointOptionsStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainEndpointOptionsStatus, forKey: "domainEndpointOptionsStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class AdvancedSecurityOptions: Codable {
        /// The status of advanced security options for the specified domain.
        public var advancedSecurityOptionsStatus: AdvancedSecurityOptionsStatus
        /// Specifies <code>AdvancedSecurityOptions</code> for the domain.
        public var anyJSON: AnyJSON

        public init(advancedSecurityOptionsStatus: AdvancedSecurityOptionsStatus, anyJSON: AnyJSON) {
            self.advancedSecurityOptionsStatus = advancedSecurityOptionsStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.advancedSecurityOptionsStatus = try AdvancedSecurityOptionsStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(advancedSecurityOptionsStatus, forKey: "advancedSecurityOptionsStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class AutoTuneOptions: Codable {
        /// The Auto-Tune status for the domain.
        public var autoTuneOptionsStatus: AutoTuneOptionsStatus
        /// Specifies <code>AutoTuneOptions</code> for the domain.
        public var anyJSON: AnyJSON

        public init(autoTuneOptionsStatus: AutoTuneOptionsStatus, anyJSON: AnyJSON) {
            self.autoTuneOptionsStatus = autoTuneOptionsStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.autoTuneOptionsStatus = try AutoTuneOptionsStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(autoTuneOptionsStatus, forKey: "autoTuneOptionsStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(engineVersion: EngineVersion? = nil, clusterConfig: ClusterConfig? = nil, eBSOptions: EBSOptions? = nil, accessPolicies: AccessPolicies? = nil, snapshotOptions: SnapshotOptions? = nil, vPCOptions: VPCOptions? = nil, cognitoOptions: CognitoOptions? = nil, encryptionAtRestOptions: EncryptionAtRestOptions? = nil, nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions? = nil, advancedOptions: AdvancedOptions? = nil, logPublishingOptions: LogPublishingOptions? = nil, domainEndpointOptions: DomainEndpointOptions? = nil, advancedSecurityOptions: AdvancedSecurityOptions? = nil, autoTuneOptions: AutoTuneOptions? = nil) {
        self.engineVersion = engineVersion
        self.clusterConfig = clusterConfig
        self.eBSOptions = eBSOptions
        self.accessPolicies = accessPolicies
        self.snapshotOptions = snapshotOptions
        self.vPCOptions = vPCOptions
        self.cognitoOptions = cognitoOptions
        self.encryptionAtRestOptions = encryptionAtRestOptions
        self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
        self.advancedOptions = advancedOptions
        self.logPublishingOptions = logPublishingOptions
        self.domainEndpointOptions = domainEndpointOptions
        self.advancedSecurityOptions = advancedSecurityOptions
        self.autoTuneOptions = autoTuneOptions
    }

    private enum CodingKeys: String, CodingKey {
        case engineVersion = "EngineVersion"
        case clusterConfig = "ClusterConfig"
        case eBSOptions = "EBSOptions"
        case accessPolicies = "AccessPolicies"
        case snapshotOptions = "SnapshotOptions"
        case vPCOptions = "VPCOptions"
        case cognitoOptions = "CognitoOptions"
        case encryptionAtRestOptions = "EncryptionAtRestOptions"
        case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
        case advancedOptions = "AdvancedOptions"
        case logPublishingOptions = "LogPublishingOptions"
        case domainEndpointOptions = "DomainEndpointOptions"
        case advancedSecurityOptions = "AdvancedSecurityOptions"
        case autoTuneOptions = "AutoTuneOptions"
    }
}

/// Container for the parameters to the <code> <a>DescribeDomains</a> </code> operation. By default, the API returns the status of all domains.
public struct DescribeDomainsRequest: Codable {
    public var domainNames: DomainNames

    public struct DomainNames: Codable {
        /// A list of domain names.
        public var strings: [String]
        /// The domains for which you want information.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(domainNames: DomainNames) {
        self.domainNames = domainNames
    }

    private enum CodingKeys: String, CodingKey {
        case domainNames = "DomainNames"
    }
}

/// Container for the parameters to the <code> <a>DescribeInboundConnections</a> </code> operation.
public struct DescribeInboundConnectionsRequest: Codable {
    public var filters: Filters?
    public var maxResults: MaxResults?
    public var nextToken: NextToken?

    public struct Filters: Codable {
        public var filters: [Filter]
        /// A list of filters used to match properties for inbound cross-cluster connections. Available <code> <a>Filter</a> </code> values are: <ul> <li>connection-id</li> <li>local-domain-info.domain-name</li> <li>local-domain-info.owner-id</li> <li>local-domain-info.region</li> <li>remote-domain-info.domain-name</li> </ul>
        public var anyJSON: AnyJSON

        public init(filters: [Filter], anyJSON: AnyJSON) {
            self.filters = filters
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.filters = try values.decode([Filter].self, forKey: "filters")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(filters, forKey: "filters")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class MaxResults: Codable {
        /// Set this value to limit the number of results returned.
        public var maxResults: AmazonOpenSearchAPI.MaxResults
        /// Set this value to limit the number of results returned. If not specified, defaults to 100.
        public var anyJSON: AnyJSON

        public init(maxResults: AmazonOpenSearchAPI.MaxResults, anyJSON: AnyJSON) {
            self.maxResults = maxResults
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.maxResults = try values.decode(AmazonOpenSearchAPI.MaxResults.self, forKey: "maxResults")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(maxResults, forKey: "maxResults")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class NextToken: Codable {
        /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
        public var nextToken: AmazonOpenSearchAPI.NextToken
        /// If more results are available and NextToken is present, make the next request to the same API with the received NextToken to paginate the remaining results.
        public var anyJSON: AnyJSON

        public init(nextToken: AmazonOpenSearchAPI.NextToken, anyJSON: AnyJSON) {
            self.nextToken = nextToken
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.nextToken = try values.decode(AmazonOpenSearchAPI.NextToken.self, forKey: "nextToken")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(nextToken, forKey: "nextToken")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(filters: Filters? = nil, maxResults: MaxResults? = nil, nextToken: NextToken? = nil) {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }
}

/// Container for the parameters to the <code> <a>DescribeOutboundConnections</a> </code> operation.
public struct DescribeOutboundConnectionsRequest: Codable {
    public var filters: Filters?
    public var maxResults: MaxResults?
    public var nextToken: NextToken?

    public struct Filters: Codable {
        public var filters: [Filter]
        /// A list of filters used to match properties for outbound cross-cluster connections. Available <code> <a>Filter</a> </code> names for this operation are: <ul> <li>connection-id</li> <li>remote-domain-info.domain-name</li> <li>remote-domain-info.owner-id</li> <li>remote-domain-info.region</li> <li>local-domain-info.domain-name</li> </ul>
        public var anyJSON: AnyJSON

        public init(filters: [Filter], anyJSON: AnyJSON) {
            self.filters = filters
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.filters = try values.decode([Filter].self, forKey: "filters")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(filters, forKey: "filters")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class MaxResults: Codable {
        /// Set this value to limit the number of results returned.
        public var maxResults: AmazonOpenSearchAPI.MaxResults
        /// Set this value to limit the number of results returned. If not specified, defaults to 100.
        public var anyJSON: AnyJSON

        public init(maxResults: AmazonOpenSearchAPI.MaxResults, anyJSON: AnyJSON) {
            self.maxResults = maxResults
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.maxResults = try values.decode(AmazonOpenSearchAPI.MaxResults.self, forKey: "maxResults")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(maxResults, forKey: "maxResults")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class NextToken: Codable {
        /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
        public var nextToken: AmazonOpenSearchAPI.NextToken
        /// NextToken is sent in case the earlier API call results contain the NextToken parameter. Used for pagination.
        public var anyJSON: AnyJSON

        public init(nextToken: AmazonOpenSearchAPI.NextToken, anyJSON: AnyJSON) {
            self.nextToken = nextToken
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.nextToken = try values.decode(AmazonOpenSearchAPI.NextToken.self, forKey: "nextToken")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(nextToken, forKey: "nextToken")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(filters: Filters? = nil, maxResults: MaxResults? = nil, nextToken: NextToken? = nil) {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }
}

public enum DescribePackagesFilterName: String, Codable, CaseIterable {
    case packageID = "PackageID"
    case packageName = "PackageName"
    case packageStatus = "PackageStatus"
}

/// Container for the request parameters to the <code> <a>DescribePackage</a> </code> operation.
public struct DescribePackagesRequest: Codable {
    public var filters: Filters?
    public var maxResults: MaxResults?
    public var nextToken: NextToken?

    public struct Filters: Codable {
        /// A list of <code>DescribePackagesFilter</code> to filter the packages included in a <code>DescribePackages</code> response.
        public var describePackagesFilters: [DescribePackagesFilter]
        /// Only returns packages that match the <code>DescribePackagesFilterList</code> values.
        public var anyJSON: AnyJSON

        public init(describePackagesFilters: [DescribePackagesFilter], anyJSON: AnyJSON) {
            self.describePackagesFilters = describePackagesFilters
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.describePackagesFilters = try values.decode([DescribePackagesFilter].self, forKey: "describePackagesFilters")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(describePackagesFilters, forKey: "describePackagesFilters")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class MaxResults: Codable {
        /// Set this value to limit the number of results returned.
        public var maxResults: AmazonOpenSearchAPI.MaxResults
        /// Limits results to a maximum number of packages.
        public var anyJSON: AnyJSON

        public init(maxResults: AmazonOpenSearchAPI.MaxResults, anyJSON: AnyJSON) {
            self.maxResults = maxResults
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.maxResults = try values.decode(AmazonOpenSearchAPI.MaxResults.self, forKey: "maxResults")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(maxResults, forKey: "maxResults")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class NextToken: Codable {
        /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
        public var nextToken: AmazonOpenSearchAPI.NextToken
        /// Used for pagination. Only necessary if a previous API call includes a non-null NextToken value. If provided, returns results for the next page.
        public var anyJSON: AnyJSON

        public init(nextToken: AmazonOpenSearchAPI.NextToken, anyJSON: AnyJSON) {
            self.nextToken = nextToken
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.nextToken = try values.decode(AmazonOpenSearchAPI.NextToken.self, forKey: "nextToken")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(nextToken, forKey: "nextToken")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(filters: Filters? = nil, maxResults: MaxResults? = nil, nextToken: NextToken? = nil) {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }
}

/// The status of the OpenSearch version options for the specified OpenSearch domain.
public struct VersionStatus: Codable {
    public var options: Options
    public var status: Status

    public struct Options: Codable {
        public var string: String
        /// The OpenSearch version for the specified OpenSearch domain.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        /// Provides the current status of the entity.
        public var optionStatus: OptionStatus
        /// The status of the OpenSearch version options for the specified OpenSearch domain.
        public var anyJSON: AnyJSON

        public init(optionStatus: OptionStatus, anyJSON: AnyJSON) {
            self.optionStatus = optionStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.optionStatus = try OptionStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(optionStatus, forKey: "optionStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(options: Options, status: Status) {
        self.options = options
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }
}

/// Status of the EBS options for the specified domain.
public struct EBSOptionsStatus: Codable {
    public var options: Options
    public var status: Status

    public struct Options: Codable {
        /// Options to enable, disable, and specify the properties of EBS storage volumes.
        public var eBSOptions: EBSOptions
        /// The EBS options for the specified domain.
        public var anyJSON: AnyJSON

        public init(eBSOptions: EBSOptions, anyJSON: AnyJSON) {
            self.eBSOptions = eBSOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.eBSOptions = try EBSOptions(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(eBSOptions, forKey: "eBSOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        /// Provides the current status of the entity.
        public var optionStatus: OptionStatus
        /// The status of the EBS options for the specified domain.
        public var anyJSON: AnyJSON

        public init(optionStatus: OptionStatus, anyJSON: AnyJSON) {
            self.optionStatus = optionStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.optionStatus = try OptionStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(optionStatus, forKey: "optionStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(options: Options, status: Status) {
        self.options = options
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }
}

/// Status of a daily automated snapshot.
public struct SnapshotOptionsStatus: Codable {
    public var options: Options
    public var status: Status

    public struct Options: Codable {
        /// The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.
        public var snapshotOptions: SnapshotOptions
        /// The daily snapshot options specified for the domain.
        public var anyJSON: AnyJSON

        public init(snapshotOptions: SnapshotOptions, anyJSON: AnyJSON) {
            self.snapshotOptions = snapshotOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.snapshotOptions = try SnapshotOptions(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(snapshotOptions, forKey: "snapshotOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        /// Provides the current status of the entity.
        public var optionStatus: OptionStatus
        /// The status of a daily automated snapshot.
        public var anyJSON: AnyJSON

        public init(optionStatus: OptionStatus, anyJSON: AnyJSON) {
            self.optionStatus = optionStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.optionStatus = try OptionStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(optionStatus, forKey: "optionStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(options: Options, status: Status) {
        self.options = options
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }
}

/// Status of the VPC options for the specified domain.
public struct VPCDerivedInfoStatus: Codable {
    public var options: Options
    public var status: Status

    public struct Options: Codable {
        /// Options to specify the subnets and security groups for the VPC endpoint. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>.
        public var vPCDerivedInfo: VPCDerivedInfo
        /// The VPC options for the specified domain.
        public var anyJSON: AnyJSON

        public init(vPCDerivedInfo: VPCDerivedInfo, anyJSON: AnyJSON) {
            self.vPCDerivedInfo = vPCDerivedInfo
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.vPCDerivedInfo = try VPCDerivedInfo(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(vPCDerivedInfo, forKey: "vPCDerivedInfo")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        /// Provides the current status of the entity.
        public var optionStatus: OptionStatus
        /// The status of the VPC options for the specified domain.
        public var anyJSON: AnyJSON

        public init(optionStatus: OptionStatus, anyJSON: AnyJSON) {
            self.optionStatus = optionStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.optionStatus = try OptionStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(optionStatus, forKey: "optionStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(options: Options, status: Status) {
        self.options = options
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }
}

/// Status of the encryption At Rest options for the specified domain.
public struct EncryptionAtRestOptionsStatus: Codable {
    public var options: Options
    public var status: Status

    public struct Options: Codable {
        /// Specifies encryption at rest options.
        public var encryptionAtRestOptions: EncryptionAtRestOptions
        /// The Encryption At Rest options for the specified domain.
        public var anyJSON: AnyJSON

        public init(encryptionAtRestOptions: EncryptionAtRestOptions, anyJSON: AnyJSON) {
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.encryptionAtRestOptions = try EncryptionAtRestOptions(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(encryptionAtRestOptions, forKey: "encryptionAtRestOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        /// Provides the current status of the entity.
        public var optionStatus: OptionStatus
        /// The status of the Encryption At Rest options for the specified domain.
        public var anyJSON: AnyJSON

        public init(optionStatus: OptionStatus, anyJSON: AnyJSON) {
            self.optionStatus = optionStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.optionStatus = try OptionStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(optionStatus, forKey: "optionStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(options: Options, status: Status) {
        self.options = options
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }
}

/// Status of the node-to-node encryption options for the specified domain.
public struct NodeToNodeEncryptionOptionsStatus: Codable {
    public var options: Options
    public var status: Status

    public struct Options: Codable {
        /// The node-to-node encryption options.
        public var nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions
        /// The node-to-node encryption options for the specified domain.
        public var anyJSON: AnyJSON

        public init(nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions, anyJSON: AnyJSON) {
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.nodeToNodeEncryptionOptions = try NodeToNodeEncryptionOptions(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(nodeToNodeEncryptionOptions, forKey: "nodeToNodeEncryptionOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        /// Provides the current status of the entity.
        public var optionStatus: OptionStatus
        /// The status of the node-to-node encryption options for the specified domain.
        public var anyJSON: AnyJSON

        public init(optionStatus: OptionStatus, anyJSON: AnyJSON) {
            self.optionStatus = optionStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.optionStatus = try OptionStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(optionStatus, forKey: "optionStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(options: Options, status: Status) {
        self.options = options
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }
}

/// The configured log publishing options for the domain and their current status.
public struct LogPublishingOptionsStatus: Codable {
    public var options: Options?
    public var status: Status?

    public struct Options: Codable {
        public var stringLogPublishingOption: [String: LogPublishingOption]
        /// The log publishing options configured for the domain.
        public var anyJSON: AnyJSON

        public init(stringLogPublishingOption: [String: LogPublishingOption], anyJSON: AnyJSON) {
            self.stringLogPublishingOption = stringLogPublishingOption
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.stringLogPublishingOption = try values.decode([String: LogPublishingOption].self, forKey: "stringLogPublishingOption")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(stringLogPublishingOption, forKey: "stringLogPublishingOption")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        /// Provides the current status of the entity.
        public var optionStatus: OptionStatus
        /// The status of the log publishing options for the domain. See <code>OptionStatus</code> for the status information that's included.
        public var anyJSON: AnyJSON

        public init(optionStatus: OptionStatus, anyJSON: AnyJSON) {
            self.optionStatus = optionStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.optionStatus = try OptionStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(optionStatus, forKey: "optionStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(options: Options? = nil, status: Status? = nil) {
        self.options = options
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }
}

/// The configured endpoint options for the domain and their current status.
public struct DomainEndpointOptionsStatus: Codable {
    public var options: Options
    public var status: Status

    public struct Options: Codable {
        /// Options to configure the endpoint for the domain.
        public var domainEndpointOptions: DomainEndpointOptions
        /// Options to configure the endpoint for the domain.
        public var anyJSON: AnyJSON

        public init(domainEndpointOptions: DomainEndpointOptions, anyJSON: AnyJSON) {
            self.domainEndpointOptions = domainEndpointOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.domainEndpointOptions = try DomainEndpointOptions(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainEndpointOptions, forKey: "domainEndpointOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        /// Provides the current status of the entity.
        public var optionStatus: OptionStatus
        /// The status of the endpoint options for the domain. See <code>OptionStatus</code> for the status information that's included.
        public var anyJSON: AnyJSON

        public init(optionStatus: OptionStatus, anyJSON: AnyJSON) {
            self.optionStatus = optionStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.optionStatus = try OptionStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(optionStatus, forKey: "optionStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(options: Options, status: Status) {
        self.options = options
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case options = "Options"
        case status = "Status"
    }
}

public enum EngineType: String, Codable, CaseIterable {
    case openSearch = "OpenSearch"
    case elasticsearch = "Elasticsearch"
}

public struct DomainInfo: Codable {
    public var domainName: DomainName?
    public var engineType: EngineType?

    public final class DomainName: Codable {
        /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
        public var domainName: AmazonOpenSearchAPI.DomainName
        /// The <code>DomainName</code>.
        public var anyJSON: AnyJSON

        public init(domainName: AmazonOpenSearchAPI.DomainName, anyJSON: AnyJSON) {
            self.domainName = domainName
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainName = try values.decode(AmazonOpenSearchAPI.DomainName.self, forKey: "domainName")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainName, forKey: "domainName")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class EngineType: Codable {
        public var engineType: AmazonOpenSearchAPI.EngineType
        /// Specifies the <code>EngineType</code> of the domain.
        public var anyJSON: AnyJSON

        public init(engineType: AmazonOpenSearchAPI.EngineType, anyJSON: AnyJSON) {
            self.engineType = engineType
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.engineType = try values.decode(AmazonOpenSearchAPI.EngineType.self, forKey: "engineType")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(engineType, forKey: "engineType")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(domainName: DomainName? = nil, engineType: EngineType? = nil) {
        self.domainName = domainName
        self.engineType = engineType
    }

    private enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case engineType = "EngineType"
    }
}

public enum DomainPackageStatus: String, Codable, CaseIterable {
    case associating = "ASSOCIATING"
    case associationFailed = "ASSOCIATION_FAILED"
    case active = "ACTIVE"
    case dissociating = "DISSOCIATING"
    case dissociationFailed = "DISSOCIATION_FAILED"
}

public struct ErrorDetails: Codable {
    public var errorType: String?
    public var errorMessage: String?

    public init(errorType: String? = nil, errorMessage: String? = nil) {
        self.errorType = errorType
        self.errorMessage = errorMessage
    }

    private enum CodingKeys: String, CodingKey {
        case errorType = "ErrorType"
        case errorMessage = "ErrorMessage"
    }
}

/// Options to specify the subnets and security groups for the VPC endpoint. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>.
public struct VPCDerivedInfo: Codable {
    public var vPCID: VPCID?
    public var subnetIDs: SubnetIDs?
    public var availabilityZones: AvailabilityZones?
    public var securityGroupIDs: SecurityGroupIDs?

    public struct VPCID: Codable {
        public var string: String
        /// The VPC ID for the domain. Exists only if the domain was created with <code>VPCOptions</code>.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SubnetIDs: Codable {
        public var strings: [String]
        /// The subnets for the VPC endpoint.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AvailabilityZones: Codable {
        public var strings: [String]
        /// The Availability Zones for the domain. Exists only if the domain was created with <code>VPCOptions</code>.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SecurityGroupIDs: Codable {
        public var strings: [String]
        /// The security groups for the VPC endpoint.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(vPCID: VPCID? = nil, subnetIDs: SubnetIDs? = nil, availabilityZones: AvailabilityZones? = nil, securityGroupIDs: SecurityGroupIDs? = nil) {
        self.vPCID = vPCID
        self.subnetIDs = subnetIDs
        self.availabilityZones = availabilityZones
        self.securityGroupIDs = securityGroupIDs
    }

    private enum CodingKeys: String, CodingKey {
        case vPCID = "VPCId"
        case subnetIDs = "SubnetIds"
        case availabilityZones = "AvailabilityZones"
        case securityGroupIDs = "SecurityGroupIds"
    }
}

/// The unit of a maintenance schedule duration. Valid value is HOUR. See <a href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html" target="_blank"> Auto-Tune for Amazon OpenSearch Service </a> for more information.
public enum TimeUnit: String, Codable, CaseIterable {
    case hours = "HOURS"
}

public enum UpgradeStep: String, Codable, CaseIterable {
    case preUpgradeCheck = "PRE_UPGRADE_CHECK"
    case snapshot = "SNAPSHOT"
    case upgrade = "UPGRADE"
}

public enum UpgradeStatus: String, Codable, CaseIterable {
    case inProgress = "IN_PROGRESS"
    case succeeded = "SUCCEEDED"
    case succeededWithIssues = "SUCCEEDED_WITH_ISSUES"
    case failed = "FAILED"
}

/// The connection status of an inbound cross-cluster connection.
public struct InboundConnectionStatus: Codable {
    public var statusCode: StatusCode?
    public var message: Message?

    public struct StatusCode: Codable {
        public var inboundConnectionStatusCode: InboundConnectionStatusCode
        /// <p>The state code for the inbound connection. Can be one of the following:</p> <ul> <li>PENDING_ACCEPTANCE: Inbound connection is not yet accepted by the remote domain owner.</li> <li>APPROVED: Inbound connection is pending acceptance by the remote domain owner.</li> <li>PROVISIONING: Inbound connection provisioning is in progress.</li> <li>ACTIVE: Inbound connection is active and ready to use.</li> <li>REJECTING: Inbound connection rejection is in process.</li> <li>REJECTED: Inbound connection is rejected.</li> <li>DELETING: Inbound connection deletion is in progress.</li> <li>DELETED: Inbound connection is deleted and can no longer be used.</li> </ul>
        public var anyJSON: AnyJSON

        public init(inboundConnectionStatusCode: InboundConnectionStatusCode, anyJSON: AnyJSON) {
            self.inboundConnectionStatusCode = inboundConnectionStatusCode
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.inboundConnectionStatusCode = try InboundConnectionStatusCode(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(inboundConnectionStatusCode, forKey: "inboundConnectionStatusCode")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Message: Codable {
        public var string: String
        /// Verbose information for the inbound connection status.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(statusCode: StatusCode? = nil, message: Message? = nil) {
        self.statusCode = statusCode
        self.message = message
    }

    private enum CodingKeys: String, CodingKey {
        case statusCode = "StatusCode"
        case message = "Message"
    }
}

public enum InboundConnectionStatusCode: String, Codable, CaseIterable {
    case pendingAcceptance = "PENDING_ACCEPTANCE"
    case approved = "APPROVED"
    case provisioning = "PROVISIONING"
    case active = "ACTIVE"
    case rejecting = "REJECTING"
    case rejected = "REJECTED"
    case deleting = "DELETING"
    case deleted = "DELETED"
}

/// InstanceCountLimits represents the limits on the number of instances that can be created in Amazon OpenSearch Service for a given InstanceType.
public struct InstanceCountLimits: Codable {
    /// Minimum number of instances that can be instantiated for a given InstanceType.
    public var minimumInstanceCount: Int?
    /// Maximum number of instances that can be instantiated for a given InstanceType.
    public var maximumInstanceCount: Int?

    public init(minimumInstanceCount: Int? = nil, maximumInstanceCount: Int? = nil) {
        self.minimumInstanceCount = minimumInstanceCount
        self.maximumInstanceCount = maximumInstanceCount
    }

    private enum CodingKeys: String, CodingKey {
        case minimumInstanceCount = "MinimumInstanceCount"
        case maximumInstanceCount = "MaximumInstanceCount"
    }
}

/// InstanceLimits represents the list of instance-related attributes that are available for a given InstanceType.
public struct InstanceLimits: Codable {
    /// InstanceCountLimits represents the limits on the number of instances that can be created in Amazon OpenSearch Service for a given InstanceType.
    public var instanceCountLimits: InstanceCountLimits?

    public init(instanceCountLimits: InstanceCountLimits? = nil) {
        self.instanceCountLimits = instanceCountLimits
    }

    private enum CodingKeys: String, CodingKey {
        case instanceCountLimits = "InstanceCountLimits"
    }
}

public struct InstanceTypeDetails: Codable {
    public var instanceType: OpenSearchPartitionInstanceType?
    public var isEncryptionEnabled: Bool?
    public var isCognitoEnabled: Bool?
    public var isAppLogsEnabled: Bool?
    public var isAdvancedSecurityEnabled: Bool?
    public var isWarmEnabled: Bool?
    public var instanceRole: [String]?

    public init(instanceType: OpenSearchPartitionInstanceType? = nil, isEncryptionEnabled: Bool? = nil, isCognitoEnabled: Bool? = nil, isAppLogsEnabled: Bool? = nil, isAdvancedSecurityEnabled: Bool? = nil, isWarmEnabled: Bool? = nil, instanceRole: [String]? = nil) {
        self.instanceType = instanceType
        self.isEncryptionEnabled = isEncryptionEnabled
        self.isCognitoEnabled = isCognitoEnabled
        self.isAppLogsEnabled = isAppLogsEnabled
        self.isAdvancedSecurityEnabled = isAdvancedSecurityEnabled
        self.isWarmEnabled = isWarmEnabled
        self.instanceRole = instanceRole
    }

    private enum CodingKeys: String, CodingKey {
        case instanceType = "InstanceType"
        case isEncryptionEnabled = "EncryptionEnabled"
        case isCognitoEnabled = "CognitoEnabled"
        case isAppLogsEnabled = "AppLogsEnabled"
        case isAdvancedSecurityEnabled = "AdvancedSecurityEnabled"
        case isWarmEnabled = "WarmEnabled"
        case instanceRole = "InstanceRole"
    }
}

/// Limits for a given InstanceType and for each of its roles. <br/> Limits contains the following: <code> <a>StorageTypes</a> </code>, <code> <a>InstanceLimits</a> </code>, and <code> <a>AdditionalLimits</a> </code>
public struct Limits: Codable {
    public var storageTypes: StorageTypes?
    /// InstanceLimits represents the list of instance-related attributes that are available for a given InstanceType.
    public var instanceLimits: InstanceLimits?
    public var additionalLimits: AdditionalLimits?

    public struct StorageTypes: Codable {
        public var storageTypes: [StorageType]
        /// Storage-related types and attributes that are available for a given InstanceType.
        public var anyJSON: AnyJSON

        public init(storageTypes: [StorageType], anyJSON: AnyJSON) {
            self.storageTypes = storageTypes
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.storageTypes = try values.decode([StorageType].self, forKey: "storageTypes")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(storageTypes, forKey: "storageTypes")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AdditionalLimits: Codable {
        public var additionalLimits: [AdditionalLimit]
        /// List of additional limits that are specific to a given InstanceType and for each of its <code> <a>InstanceRole</a> </code> .
        public var anyJSON: AnyJSON

        public init(additionalLimits: [AdditionalLimit], anyJSON: AnyJSON) {
            self.additionalLimits = additionalLimits
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.additionalLimits = try values.decode([AdditionalLimit].self, forKey: "additionalLimits")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(additionalLimits, forKey: "additionalLimits")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(storageTypes: StorageTypes? = nil, instanceLimits: InstanceLimits? = nil, additionalLimits: AdditionalLimits? = nil) {
        self.storageTypes = storageTypes
        self.instanceLimits = instanceLimits
        self.additionalLimits = additionalLimits
    }

    private enum CodingKeys: String, CodingKey {
        case storageTypes = "StorageTypes"
        case instanceLimits = "InstanceLimits"
        case additionalLimits = "AdditionalLimits"
    }
}

/// Type of log file. Can be one of the following: <ul> <li>INDEX_SLOW_LOGS: Index slow logs contain insert requests that took more time than configured index query log threshold to execute. </li> <li>SEARCH_SLOW_LOGS: Search slow logs contain search queries that took more time than configured search query log threshold to execute. </li> <li>ES_APPLICATION_LOGS: OpenSearch application logs contain information about errors and warnings raised during the operation of the service and can be useful for troubleshooting. </li> <li>AUDIT_LOGS: Audit logs contain records of user requests for access from the domain.</li> </ul>
public enum LogType: String, Codable, CaseIterable {
    case indexSlowLogs = "INDEX_SLOW_LOGS"
    case searchSlowLogs = "SEARCH_SLOW_LOGS"
    case esApplicationLogs = "ES_APPLICATION_LOGS"
    case auditLogs = "AUDIT_LOGS"
}

/// <p>The state of a requested change. One of the following:</p> <ul> <li>Processing: The request change is still in progress.</li> <li>Active: The request change is processed and deployed to the domain.</li> </ul>
public enum OptionState: String, Codable, CaseIterable {
    case requiresIndexDocuments = "RequiresIndexDocuments"
    case processing = "Processing"
    case active = "Active"
}

public enum OutboundConnectionStatusCode: String, Codable, CaseIterable {
    case validating = "VALIDATING"
    case validationFailed = "VALIDATION_FAILED"
    case pendingAcceptance = "PENDING_ACCEPTANCE"
    case approved = "APPROVED"
    case provisioning = "PROVISIONING"
    case active = "ACTIVE"
    case rejecting = "REJECTING"
    case rejected = "REJECTED"
    case deleting = "DELETING"
    case deleted = "DELETED"
}

public enum PackageStatus: String, Codable, CaseIterable {
    case copying = "COPYING"
    case copyFailed = "COPY_FAILED"
    case validating = "VALIDATING"
    case validationFailed = "VALIDATION_FAILED"
    case available = "AVAILABLE"
    case deleting = "DELETING"
    case deleted = "DELETED"
    case deleteFailed = "DELETE_FAILED"
}

/// Details of a package version.
public struct PackageVersionHistory: Codable {
    public var packageVersion: PackageVersion?
    public var commitMessage: CommitMessage?
    public var createdAt: CreatedAt?

    public final class PackageVersion: Codable {
        public var packageVersion: AmazonOpenSearchAPI.PackageVersion
        /// The package version.
        public var anyJSON: AnyJSON

        public init(packageVersion: AmazonOpenSearchAPI.PackageVersion, anyJSON: AnyJSON) {
            self.packageVersion = packageVersion
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageVersion = try values.decode(AmazonOpenSearchAPI.PackageVersion.self, forKey: "packageVersion")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageVersion, forKey: "packageVersion")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class CommitMessage: Codable {
        public var commitMessage: AmazonOpenSearchAPI.CommitMessage
        /// A message associated with the package version.
        public var anyJSON: AnyJSON

        public init(commitMessage: AmazonOpenSearchAPI.CommitMessage, anyJSON: AnyJSON) {
            self.commitMessage = commitMessage
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.commitMessage = try values.decode(AmazonOpenSearchAPI.CommitMessage.self, forKey: "commitMessage")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(commitMessage, forKey: "commitMessage")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class CreatedAt: Codable {
        public var createdAt: AmazonOpenSearchAPI.CreatedAt
        /// The timestamp of when the package was created.
        public var anyJSON: AnyJSON

        public init(createdAt: AmazonOpenSearchAPI.CreatedAt, anyJSON: AnyJSON) {
            self.createdAt = createdAt
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.createdAt = try values.decode(AmazonOpenSearchAPI.CreatedAt.self, forKey: "createdAt")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(createdAt, forKey: "createdAt")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(packageVersion: PackageVersion? = nil, commitMessage: CommitMessage? = nil, createdAt: CreatedAt? = nil) {
        self.packageVersion = packageVersion
        self.commitMessage = commitMessage
        self.createdAt = createdAt
    }

    private enum CodingKeys: String, CodingKey {
        case packageVersion = "PackageVersion"
        case commitMessage = "CommitMessage"
        case createdAt = "CreatedAt"
    }
}

/// Container for parameters to <code>PurchaseReservedInstanceOffering</code>
public struct PurchaseReservedInstanceOfferingRequest: Codable {
    public var reservedInstanceOfferingID: ReservedInstanceOfferingID
    public var reservationName: ReservationName
    public var instanceCount: InstanceCount?

    public struct ReservedInstanceOfferingID: Codable {
        public var string: String
        /// The ID of the reserved OpenSearch instance offering to purchase.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ReservationName: Codable {
        public var string: String
        /// A customer-specified identifier to track this reservation.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class InstanceCount: Codable {
        /// The number of EC2 instances in the domain.
        public var instanceCount: AmazonOpenSearchAPI.InstanceCount
        /// The number of OpenSearch instances to reserve.
        public var anyJSON: AnyJSON

        public init(instanceCount: AmazonOpenSearchAPI.InstanceCount, anyJSON: AnyJSON) {
            self.instanceCount = instanceCount
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.instanceCount = try values.decode(AmazonOpenSearchAPI.InstanceCount.self, forKey: "instanceCount")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(instanceCount, forKey: "instanceCount")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(reservedInstanceOfferingID: ReservedInstanceOfferingID, reservationName: ReservationName, instanceCount: InstanceCount? = nil) {
        self.reservedInstanceOfferingID = reservedInstanceOfferingID
        self.reservationName = reservationName
        self.instanceCount = instanceCount
    }

    private enum CodingKeys: String, CodingKey {
        case reservedInstanceOfferingID = "ReservedInstanceOfferingId"
        case reservationName = "ReservationName"
        case instanceCount = "InstanceCount"
    }
}

/// Contains the specific price and frequency of a recurring charges for a reserved OpenSearch instance, or for a reserved OpenSearch instance offering.
public struct RecurringCharge: Codable {
    public var recurringChargeAmount: RecurringChargeAmount?
    public var recurringChargeFrequency: RecurringChargeFrequency?

    public struct RecurringChargeAmount: Codable {
        public var double: Double
        /// The monetary amount of the recurring charge.
        public var anyJSON: AnyJSON

        public init(double: Double, anyJSON: AnyJSON) {
            self.double = double
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.double = try values.decode(Double.self, forKey: "double")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(double, forKey: "double")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct RecurringChargeFrequency: Codable {
        public var string: String
        /// The frequency of the recurring charge.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(recurringChargeAmount: RecurringChargeAmount? = nil, recurringChargeFrequency: RecurringChargeFrequency? = nil) {
        self.recurringChargeAmount = recurringChargeAmount
        self.recurringChargeFrequency = recurringChargeFrequency
    }

    private enum CodingKeys: String, CodingKey {
        case recurringChargeAmount = "RecurringChargeAmount"
        case recurringChargeFrequency = "RecurringChargeFrequency"
    }
}

/// Container for the parameters to the <code> <a>RemoveTags</a> </code> operation. Specify the <code>ARN</code> for the domain from which you want to remove the specified <code>TagKey</code>.
public struct RemoveTagsRequest: Codable {
    public var arn: Arn
    public var tagKeys: TagKeys

    public final class Arn: Codable {
        /// The Amazon Resource Name (ARN) of the domain. See <a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/index.html" target="_blank">Identifiers for IAM Entities </a> in <i>Using AWS Identity and Access Management</i> for more information.
        public var arn: AmazonOpenSearchAPI.Arn
        /// The <code>ARN</code> of the domain from which you want to delete the specified tags.
        public var anyJSON: AnyJSON

        public init(arn: AmazonOpenSearchAPI.Arn, anyJSON: AnyJSON) {
            self.arn = arn
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.arn = try values.decode(AmazonOpenSearchAPI.Arn.self, forKey: "arn")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(arn, forKey: "arn")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct TagKeys: Codable {
        public var strings: [String]
        /// The <code>TagKey</code> list you want to remove from the domain.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(arn: Arn, tagKeys: TagKeys) {
        self.arn = arn
        self.tagKeys = tagKeys
    }

    private enum CodingKeys: String, CodingKey {
        case arn = "ARN"
        case tagKeys = "TagKeys"
    }
}

public enum ReservedInstancePaymentOption: String, Codable, CaseIterable {
    case allUpfront = "ALL_UPFRONT"
    case partialUpfront = "PARTIAL_UPFRONT"
    case noUpfront = "NO_UPFRONT"
}

/// Details of a reserved OpenSearch instance.
public struct ReservedInstance: Codable {
    public var reservationName: ReservationName?
    public var reservedInstanceID: ReservedInstanceID?
    public var billingSubscriptionID: Int?
    public var reservedInstanceOfferingID: ReservedInstanceOfferingID?
    public var instanceType: InstanceType?
    public var startTime: StartTime?
    public var duration: Duration?
    public var fixedPrice: FixedPrice?
    public var usagePrice: UsagePrice?
    public var currencyCode: CurrencyCode?
    public var instanceCount: InstanceCount?
    public var state: State?
    public var paymentOption: PaymentOption?
    public var recurringCharges: RecurringCharges?

    public struct ReservationName: Codable {
        public var string: String
        /// The customer-specified identifier to track this reservation.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ReservedInstanceID: Codable {
        public var string: String
        /// The unique identifier for the reservation.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ReservedInstanceOfferingID: Codable {
        public var string: String
        /// The offering identifier.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct InstanceType: Codable {
        public var openSearchPartitionInstanceType: OpenSearchPartitionInstanceType
        /// The OpenSearch instance type offered by the reserved instance offering.
        public var anyJSON: AnyJSON

        public init(openSearchPartitionInstanceType: OpenSearchPartitionInstanceType, anyJSON: AnyJSON) {
            self.openSearchPartitionInstanceType = openSearchPartitionInstanceType
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.openSearchPartitionInstanceType = try OpenSearchPartitionInstanceType(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(openSearchPartitionInstanceType, forKey: "openSearchPartitionInstanceType")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct StartTime: Codable {
        public var date: Date
        /// The time the reservation started.
        public var anyJSON: AnyJSON

        public init(date: Date, anyJSON: AnyJSON) {
            self.date = date
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(Date.self, forKey: "date")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Duration: Codable {
        public var int: Int
        /// The duration, in seconds, for which the OpenSearch instance is reserved.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct FixedPrice: Codable {
        public var double: Double
        /// The upfront fixed charge you will paid to purchase the specific reserved OpenSearch instance offering.
        public var anyJSON: AnyJSON

        public init(double: Double, anyJSON: AnyJSON) {
            self.double = double
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.double = try values.decode(Double.self, forKey: "double")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(double, forKey: "double")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct UsagePrice: Codable {
        public var double: Double
        /// The rate you are charged for each hour for the domain that is using this reserved instance.
        public var anyJSON: AnyJSON

        public init(double: Double, anyJSON: AnyJSON) {
            self.double = double
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.double = try values.decode(Double.self, forKey: "double")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(double, forKey: "double")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct CurrencyCode: Codable {
        public var string: String
        /// The currency code for the reserved OpenSearch instance offering.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct InstanceCount: Codable {
        public var int: Int
        /// The number of OpenSearch instances that have been reserved.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct State: Codable {
        public var string: String
        /// The state of the reserved OpenSearch instance.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct PaymentOption: Codable {
        public var reservedInstancePaymentOption: ReservedInstancePaymentOption
        /// The payment option as defined in the reserved OpenSearch instance offering.
        public var anyJSON: AnyJSON

        public init(reservedInstancePaymentOption: ReservedInstancePaymentOption, anyJSON: AnyJSON) {
            self.reservedInstancePaymentOption = reservedInstancePaymentOption
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.reservedInstancePaymentOption = try ReservedInstancePaymentOption(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(reservedInstancePaymentOption, forKey: "reservedInstancePaymentOption")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct RecurringCharges: Codable {
        public var recurringCharges: [RecurringCharge]
        /// The charge to your account regardless of whether you are creating any domains using the instance offering.
        public var anyJSON: AnyJSON

        public init(recurringCharges: [RecurringCharge], anyJSON: AnyJSON) {
            self.recurringCharges = recurringCharges
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.recurringCharges = try values.decode([RecurringCharge].self, forKey: "recurringCharges")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(recurringCharges, forKey: "recurringCharges")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(reservationName: ReservationName? = nil, reservedInstanceID: ReservedInstanceID? = nil, billingSubscriptionID: Int? = nil, reservedInstanceOfferingID: ReservedInstanceOfferingID? = nil, instanceType: InstanceType? = nil, startTime: StartTime? = nil, duration: Duration? = nil, fixedPrice: FixedPrice? = nil, usagePrice: UsagePrice? = nil, currencyCode: CurrencyCode? = nil, instanceCount: InstanceCount? = nil, state: State? = nil, paymentOption: PaymentOption? = nil, recurringCharges: RecurringCharges? = nil) {
        self.reservationName = reservationName
        self.reservedInstanceID = reservedInstanceID
        self.billingSubscriptionID = billingSubscriptionID
        self.reservedInstanceOfferingID = reservedInstanceOfferingID
        self.instanceType = instanceType
        self.startTime = startTime
        self.duration = duration
        self.fixedPrice = fixedPrice
        self.usagePrice = usagePrice
        self.currencyCode = currencyCode
        self.instanceCount = instanceCount
        self.state = state
        self.paymentOption = paymentOption
        self.recurringCharges = recurringCharges
    }

    private enum CodingKeys: String, CodingKey {
        case reservationName = "ReservationName"
        case reservedInstanceID = "ReservedInstanceId"
        case billingSubscriptionID = "BillingSubscriptionId"
        case reservedInstanceOfferingID = "ReservedInstanceOfferingId"
        case instanceType = "InstanceType"
        case startTime = "StartTime"
        case duration = "Duration"
        case fixedPrice = "FixedPrice"
        case usagePrice = "UsagePrice"
        case currencyCode = "CurrencyCode"
        case instanceCount = "InstanceCount"
        case state = "State"
        case paymentOption = "PaymentOption"
        case recurringCharges = "RecurringCharges"
    }
}

/// Details of a reserved OpenSearch instance offering.
public struct ReservedInstanceOffering: Codable {
    public var reservedInstanceOfferingID: ReservedInstanceOfferingID?
    public var instanceType: InstanceType?
    public var duration: Duration?
    public var fixedPrice: FixedPrice?
    public var usagePrice: UsagePrice?
    public var currencyCode: CurrencyCode?
    public var paymentOption: PaymentOption?
    public var recurringCharges: RecurringCharges?

    public struct ReservedInstanceOfferingID: Codable {
        public var string: String
        /// The OpenSearch reserved instance offering identifier.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct InstanceType: Codable {
        public var openSearchPartitionInstanceType: OpenSearchPartitionInstanceType
        /// The OpenSearch instance type offered by the reserved instance offering.
        public var anyJSON: AnyJSON

        public init(openSearchPartitionInstanceType: OpenSearchPartitionInstanceType, anyJSON: AnyJSON) {
            self.openSearchPartitionInstanceType = openSearchPartitionInstanceType
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.openSearchPartitionInstanceType = try OpenSearchPartitionInstanceType(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(openSearchPartitionInstanceType, forKey: "openSearchPartitionInstanceType")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Duration: Codable {
        public var int: Int
        /// The duration, in seconds, for which the offering will reserve the OpenSearch instance.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct FixedPrice: Codable {
        public var double: Double
        /// The upfront fixed charge you will pay to purchase the specific reserved OpenSearch instance offering.
        public var anyJSON: AnyJSON

        public init(double: Double, anyJSON: AnyJSON) {
            self.double = double
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.double = try values.decode(Double.self, forKey: "double")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(double, forKey: "double")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct UsagePrice: Codable {
        public var double: Double
        /// The rate you are charged for each hour the domain that is using the offering is running.
        public var anyJSON: AnyJSON

        public init(double: Double, anyJSON: AnyJSON) {
            self.double = double
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.double = try values.decode(Double.self, forKey: "double")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(double, forKey: "double")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct CurrencyCode: Codable {
        public var string: String
        /// The currency code for the reserved OpenSearch instance offering.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct PaymentOption: Codable {
        public var reservedInstancePaymentOption: ReservedInstancePaymentOption
        /// Payment option for the reserved OpenSearch instance offering
        public var anyJSON: AnyJSON

        public init(reservedInstancePaymentOption: ReservedInstancePaymentOption, anyJSON: AnyJSON) {
            self.reservedInstancePaymentOption = reservedInstancePaymentOption
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.reservedInstancePaymentOption = try ReservedInstancePaymentOption(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(reservedInstancePaymentOption, forKey: "reservedInstancePaymentOption")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct RecurringCharges: Codable {
        public var recurringCharges: [RecurringCharge]
        /// The charge to your account regardless of whether you are creating any domains using the instance offering.
        public var anyJSON: AnyJSON

        public init(recurringCharges: [RecurringCharge], anyJSON: AnyJSON) {
            self.recurringCharges = recurringCharges
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.recurringCharges = try values.decode([RecurringCharge].self, forKey: "recurringCharges")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(recurringCharges, forKey: "recurringCharges")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(reservedInstanceOfferingID: ReservedInstanceOfferingID? = nil, instanceType: InstanceType? = nil, duration: Duration? = nil, fixedPrice: FixedPrice? = nil, usagePrice: UsagePrice? = nil, currencyCode: CurrencyCode? = nil, paymentOption: PaymentOption? = nil, recurringCharges: RecurringCharges? = nil) {
        self.reservedInstanceOfferingID = reservedInstanceOfferingID
        self.instanceType = instanceType
        self.duration = duration
        self.fixedPrice = fixedPrice
        self.usagePrice = usagePrice
        self.currencyCode = currencyCode
        self.paymentOption = paymentOption
        self.recurringCharges = recurringCharges
    }

    private enum CodingKeys: String, CodingKey {
        case reservedInstanceOfferingID = "ReservedInstanceOfferingId"
        case instanceType = "InstanceType"
        case duration = "Duration"
        case fixedPrice = "FixedPrice"
        case usagePrice = "UsagePrice"
        case currencyCode = "CurrencyCode"
        case paymentOption = "PaymentOption"
        case recurringCharges = "RecurringCharges"
    }
}

/// The SAML identity povider's information.
public struct SAMLIdp: Codable {
    public var metadataContent: MetadataContent
    public var entityID: EntityID

    public struct MetadataContent: Codable {
        public var string: String
        /// The metadata of the SAML application in XML format.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct EntityID: Codable {
        public var string: String
        /// The unique entity ID of the application in SAML identity provider.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(metadataContent: MetadataContent, entityID: EntityID) {
        self.metadataContent = metadataContent
        self.entityID = entityID
    }

    private enum CodingKeys: String, CodingKey {
        case metadataContent = "MetadataContent"
        case entityID = "EntityId"
    }
}

/// The Auto-Tune action type. Valid values are JVM_HEAP_SIZE_TUNING, and JVM_YOUNG_GEN_TUNING.
public enum ScheduledAutoTuneActionType: String, Codable, CaseIterable {
    case jvmHeapSizeTuning = "JVM_HEAP_SIZE_TUNING"
    case jvmYoungGenTuning = "JVM_YOUNG_GEN_TUNING"
}

/// The Auto-Tune action severity. Valid values are LOW, MEDIUM, and HIGH.
public enum ScheduledAutoTuneSeverityType: String, Codable, CaseIterable {
    case low = "LOW"
    case medium = "MEDIUM"
    case high = "HIGH"
}

/// Container for the parameters to the <code> <a>StartServiceSoftwareUpdate</a> </code> operation. Specifies the name of the domain to schedule a service software update for.
public struct StartServiceSoftwareUpdateRequest: Codable {
    public var domainName: DomainName

    public final class DomainName: Codable {
        /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
        public var domainName: AmazonOpenSearchAPI.DomainName
        /// The name of the domain that you want to update to the latest service software.
        public var anyJSON: AnyJSON

        public init(domainName: AmazonOpenSearchAPI.DomainName, anyJSON: AnyJSON) {
            self.domainName = domainName
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainName = try values.decode(AmazonOpenSearchAPI.DomainName.self, forKey: "domainName")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainName, forKey: "domainName")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(domainName: DomainName) {
        self.domainName = domainName
    }

    private enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
    }
}

/// StorageTypes represents the list of storage-related types and their attributes that are available for a given InstanceType.
public struct StorageType: Codable {
    /// Type of storage. List of available storage options: <ol> <li>instance</li> Built-in storage available for the instance <li>ebs</li> Elastic block storage attached to the instance </ol>
    public var storageTypeName: String?
    /// Sub-type of the given storage type. List of available sub-storage options: "instance" storageType has no storageSubType. "ebs" storageType has the following valid storageSubTypes: <ol> <li>standard</li> <li>gp2</li> <li>io1</li> </ol> See <code> <a>VolumeType</a> </code> for more information regarding each EBS storage option.
    public var storageSubTypeName: String?
    public var storageTypeLimits: StorageTypeLimits?

    public struct StorageTypeLimits: Codable {
        public var storageTypeLimits: [StorageTypeLimit]
        /// Limits that are applicable for the given storage type.
        public var anyJSON: AnyJSON

        public init(storageTypeLimits: [StorageTypeLimit], anyJSON: AnyJSON) {
            self.storageTypeLimits = storageTypeLimits
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.storageTypeLimits = try values.decode([StorageTypeLimit].self, forKey: "storageTypeLimits")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(storageTypeLimits, forKey: "storageTypeLimits")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(storageTypeName: String? = nil, storageSubTypeName: String? = nil, storageTypeLimits: StorageTypeLimits? = nil) {
        self.storageTypeName = storageTypeName
        self.storageSubTypeName = storageSubTypeName
        self.storageTypeLimits = storageTypeLimits
    }

    private enum CodingKeys: String, CodingKey {
        case storageTypeName = "StorageTypeName"
        case storageSubTypeName = "StorageSubTypeName"
        case storageTypeLimits = "StorageTypeLimits"
    }
}

/// Limits that are applicable for the given storage type.
public struct StorageTypeLimit: Codable {
    public var limitName: LimitName?
    public var limitValues: LimitValues?

    public final class LimitName: Codable {
        public var limitName: AmazonOpenSearchAPI.LimitName
        /// Name of storage limits that are applicable for the given storage type. If <code> <a>StorageType</a> </code> is "ebs", the following storage options are applicable: <ol> <li>MinimumVolumeSize</li> Minimum amount of volume size that is applicable for the given storage type. Can be empty if not applicable. <li>MaximumVolumeSize</li> Maximum amount of volume size that is applicable for the given storage type. Can be empty if not applicable. <li>MaximumIops</li> Maximum amount of Iops that is applicable for given the storage type. Can be empty if not applicable. <li>MinimumIops</li> Minimum amount of Iops that is applicable for given the storage type. Can be empty if not applicable. </ol>
        public var anyJSON: AnyJSON

        public init(limitName: AmazonOpenSearchAPI.LimitName, anyJSON: AnyJSON) {
            self.limitName = limitName
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.limitName = try values.decode(AmazonOpenSearchAPI.LimitName.self, forKey: "limitName")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(limitName, forKey: "limitName")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct LimitValues: Codable {
        public var strings: [String]
        /// Values for the <code> <a>StorageTypeLimit$LimitName</a> </code> .
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(limitName: LimitName? = nil, limitValues: LimitValues? = nil) {
        self.limitName = limitName
        self.limitValues = limitValues
    }

    private enum CodingKeys: String, CodingKey {
        case limitName = "LimitName"
        case limitValues = "LimitValues"
    }
}

/// Container for the parameters to the <code> <a>UpdateDomain</a> </code> operation. Specifies the type and number of instances in the domain cluster.
public struct UpdateDomainConfigRequest: Codable {
    public var clusterConfig: ClusterConfig?
    public var eBSOptions: EBSOptions?
    public var snapshotOptions: SnapshotOptions?
    public var vPCOptions: VPCOptions?
    public var cognitoOptions: CognitoOptions?
    public var advancedOptions: AdvancedOptions?
    public var accessPolicies: AccessPolicies?
    public var logPublishingOptions: LogPublishingOptions?
    public var encryptionAtRestOptions: EncryptionAtRestOptions?
    public var domainEndpointOptions: DomainEndpointOptions?
    public var nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions?
    public var advancedSecurityOptions: AdvancedSecurityOptions?
    public var autoTuneOptions: AutoTuneOptions?

    public final class ClusterConfig: Codable {
        /// The configuration for the domain cluster, such as the type and number of instances.
        public var clusterConfig: AmazonOpenSearchAPI.ClusterConfig
        /// The type and number of instances to instantiate for the domain cluster.
        public var anyJSON: AnyJSON

        public init(clusterConfig: AmazonOpenSearchAPI.ClusterConfig, anyJSON: AnyJSON) {
            self.clusterConfig = clusterConfig
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.clusterConfig = try values.decode(AmazonOpenSearchAPI.ClusterConfig.self, forKey: "clusterConfig")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(clusterConfig, forKey: "clusterConfig")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class EBSOptions: Codable {
        /// Options to enable, disable, and specify the properties of EBS storage volumes.
        public var eBSOptions: AmazonOpenSearchAPI.EBSOptions
        /// Specify the type and size of the EBS volume to use.
        public var anyJSON: AnyJSON

        public init(eBSOptions: AmazonOpenSearchAPI.EBSOptions, anyJSON: AnyJSON) {
            self.eBSOptions = eBSOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.eBSOptions = try values.decode(AmazonOpenSearchAPI.EBSOptions.self, forKey: "eBSOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(eBSOptions, forKey: "eBSOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class SnapshotOptions: Codable {
        /// The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.
        public var snapshotOptions: AmazonOpenSearchAPI.SnapshotOptions
        /// Option to set the time, in UTC format, for the daily automated snapshot. Default value is <code>0</code> hours.
        public var anyJSON: AnyJSON

        public init(snapshotOptions: AmazonOpenSearchAPI.SnapshotOptions, anyJSON: AnyJSON) {
            self.snapshotOptions = snapshotOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.snapshotOptions = try values.decode(AmazonOpenSearchAPI.SnapshotOptions.self, forKey: "snapshotOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(snapshotOptions, forKey: "snapshotOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class VPCOptions: Codable {
        /// Options to specify the subnets and security groups for the VPC endpoint. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank"> Launching your Amazon OpenSearch Service domains using a VPC</a>.
        public var vPCOptions: AmazonOpenSearchAPI.VPCOptions
        /// Options to specify the subnets and security groups for the VPC endpoint. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html" target="_blank">Launching your Amazon OpenSearch Service domains using a VPC </a>.
        public var anyJSON: AnyJSON

        public init(vPCOptions: AmazonOpenSearchAPI.VPCOptions, anyJSON: AnyJSON) {
            self.vPCOptions = vPCOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.vPCOptions = try values.decode(AmazonOpenSearchAPI.VPCOptions.self, forKey: "vPCOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(vPCOptions, forKey: "vPCOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class CognitoOptions: Codable {
        /// Options to specify the Cognito user and identity pools for OpenSearch Dashboards authentication. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>.
        public var cognitoOptions: AmazonOpenSearchAPI.CognitoOptions
        /// Options to specify the Cognito user and identity pools for OpenSearch Dashboards authentication. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html" target="_blank">Configuring Amazon Cognito authentication for OpenSearch Dashboards</a>.
        public var anyJSON: AnyJSON

        public init(cognitoOptions: AmazonOpenSearchAPI.CognitoOptions, anyJSON: AnyJSON) {
            self.cognitoOptions = cognitoOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.cognitoOptions = try values.decode(AmazonOpenSearchAPI.CognitoOptions.self, forKey: "cognitoOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(cognitoOptions, forKey: "cognitoOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class AdvancedOptions: Codable {
        /// <p>Exposes select native OpenSearch configuration values from <code>opensearch.yml</code>. Currently, the following advanced options are available: </p> <ul> <li>Option to allow references to indices in an HTTP request body. Must be <code>false</code> when configuring access to individual sub-resources. By default, the value is <code>true</code>. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced cluster parameters </a> for more information. </li> <li>Option to specify the percentage of heap space allocated to field data. By default, this setting is unbounded. </li> </ul> <p>For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options"> Advanced cluster parameters</a>. </p>
        public var advancedOptions: AmazonOpenSearchAPI.AdvancedOptions
        /// Modifies the advanced option to allow references to indices in an HTTP request body. Must be <code>false</code> when configuring access to individual sub-resources. By default, the value is <code>true</code>. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced options </a> for more information.
        public var anyJSON: AnyJSON

        public init(advancedOptions: AmazonOpenSearchAPI.AdvancedOptions, anyJSON: AnyJSON) {
            self.advancedOptions = advancedOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.advancedOptions = try values.decode(AmazonOpenSearchAPI.AdvancedOptions.self, forKey: "advancedOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(advancedOptions, forKey: "advancedOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AccessPolicies: Codable {
        /// Access policy rules for a domain service endpoints. For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-access-policies" target="_blank">Configuring access policies </a>. The maximum size of a policy document is 100 KB.
        public var string: String
        /// IAM access policy as a JSON-formatted string.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class LogPublishingOptions: Codable {
        public var logPublishingOptions: AmazonOpenSearchAPI.LogPublishingOptions
        /// Map of <code>LogType</code> and <code>LogPublishingOption</code>, each containing options to publish a given type of OpenSearch log.
        public var anyJSON: AnyJSON

        public init(logPublishingOptions: AmazonOpenSearchAPI.LogPublishingOptions, anyJSON: AnyJSON) {
            self.logPublishingOptions = logPublishingOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.logPublishingOptions = try values.decode(AmazonOpenSearchAPI.LogPublishingOptions.self, forKey: "logPublishingOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(logPublishingOptions, forKey: "logPublishingOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class EncryptionAtRestOptions: Codable {
        /// Specifies encryption at rest options.
        public var encryptionAtRestOptions: AmazonOpenSearchAPI.EncryptionAtRestOptions
        /// Specifies encryption of data at rest options.
        public var anyJSON: AnyJSON

        public init(encryptionAtRestOptions: AmazonOpenSearchAPI.EncryptionAtRestOptions, anyJSON: AnyJSON) {
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.encryptionAtRestOptions = try values.decode(AmazonOpenSearchAPI.EncryptionAtRestOptions.self, forKey: "encryptionAtRestOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(encryptionAtRestOptions, forKey: "encryptionAtRestOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class DomainEndpointOptions: Codable {
        /// Options to configure the endpoint for the domain.
        public var domainEndpointOptions: AmazonOpenSearchAPI.DomainEndpointOptions
        /// Options to specify configuration that will be applied to the domain endpoint.
        public var anyJSON: AnyJSON

        public init(domainEndpointOptions: AmazonOpenSearchAPI.DomainEndpointOptions, anyJSON: AnyJSON) {
            self.domainEndpointOptions = domainEndpointOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domainEndpointOptions = try values.decode(AmazonOpenSearchAPI.DomainEndpointOptions.self, forKey: "domainEndpointOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(domainEndpointOptions, forKey: "domainEndpointOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class NodeToNodeEncryptionOptions: Codable {
        /// The node-to-node encryption options.
        public var nodeToNodeEncryptionOptions: AmazonOpenSearchAPI.NodeToNodeEncryptionOptions
        /// Specifies node-to-node encryption options.
        public var anyJSON: AnyJSON

        public init(nodeToNodeEncryptionOptions: AmazonOpenSearchAPI.NodeToNodeEncryptionOptions, anyJSON: AnyJSON) {
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.nodeToNodeEncryptionOptions = try values.decode(AmazonOpenSearchAPI.NodeToNodeEncryptionOptions.self, forKey: "nodeToNodeEncryptionOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(nodeToNodeEncryptionOptions, forKey: "nodeToNodeEncryptionOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AdvancedSecurityOptions: Codable {
        /// The advanced security configuration: whether advanced security is enabled, whether the internal database option is enabled, master username and password (if internal database is enabled), and master user ARN (if IAM is enabled).
        public var advancedSecurityOptionsInput: AdvancedSecurityOptionsInput
        /// Specifies advanced security options.
        public var anyJSON: AnyJSON

        public init(advancedSecurityOptionsInput: AdvancedSecurityOptionsInput, anyJSON: AnyJSON) {
            self.advancedSecurityOptionsInput = advancedSecurityOptionsInput
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.advancedSecurityOptionsInput = try AdvancedSecurityOptionsInput(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(advancedSecurityOptionsInput, forKey: "advancedSecurityOptionsInput")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class AutoTuneOptions: Codable {
        /// The Auto-Tune options: the Auto-Tune desired state for the domain, rollback state when disabling Auto-Tune options and list of maintenance schedules.
        public var autoTuneOptions: AmazonOpenSearchAPI.AutoTuneOptions
        /// Specifies Auto-Tune options.
        public var anyJSON: AnyJSON

        public init(autoTuneOptions: AmazonOpenSearchAPI.AutoTuneOptions, anyJSON: AnyJSON) {
            self.autoTuneOptions = autoTuneOptions
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.autoTuneOptions = try values.decode(AmazonOpenSearchAPI.AutoTuneOptions.self, forKey: "autoTuneOptions")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(autoTuneOptions, forKey: "autoTuneOptions")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(clusterConfig: ClusterConfig? = nil, eBSOptions: EBSOptions? = nil, snapshotOptions: SnapshotOptions? = nil, vPCOptions: VPCOptions? = nil, cognitoOptions: CognitoOptions? = nil, advancedOptions: AdvancedOptions? = nil, accessPolicies: AccessPolicies? = nil, logPublishingOptions: LogPublishingOptions? = nil, encryptionAtRestOptions: EncryptionAtRestOptions? = nil, domainEndpointOptions: DomainEndpointOptions? = nil, nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions? = nil, advancedSecurityOptions: AdvancedSecurityOptions? = nil, autoTuneOptions: AutoTuneOptions? = nil) {
        self.clusterConfig = clusterConfig
        self.eBSOptions = eBSOptions
        self.snapshotOptions = snapshotOptions
        self.vPCOptions = vPCOptions
        self.cognitoOptions = cognitoOptions
        self.advancedOptions = advancedOptions
        self.accessPolicies = accessPolicies
        self.logPublishingOptions = logPublishingOptions
        self.encryptionAtRestOptions = encryptionAtRestOptions
        self.domainEndpointOptions = domainEndpointOptions
        self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
        self.advancedSecurityOptions = advancedSecurityOptions
        self.autoTuneOptions = autoTuneOptions
    }

    private enum CodingKeys: String, CodingKey {
        case clusterConfig = "ClusterConfig"
        case eBSOptions = "EBSOptions"
        case snapshotOptions = "SnapshotOptions"
        case vPCOptions = "VPCOptions"
        case cognitoOptions = "CognitoOptions"
        case advancedOptions = "AdvancedOptions"
        case accessPolicies = "AccessPolicies"
        case logPublishingOptions = "LogPublishingOptions"
        case encryptionAtRestOptions = "EncryptionAtRestOptions"
        case domainEndpointOptions = "DomainEndpointOptions"
        case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
        case advancedSecurityOptions = "AdvancedSecurityOptions"
        case autoTuneOptions = "AutoTuneOptions"
    }
}

/// Container for request parameters to the <code> <a>UpdatePackage</a> </code> operation.
public struct UpdatePackageRequest: Codable {
    public var packageID: PackageID
    /// The Amazon S3 location for importing the package specified as <code>S3BucketName</code> and <code>S3Key</code>
    public var packageSource: PackageSource
    public var packageDescription: PackageDescription?
    public var commitMessage: CommitMessage?

    public final class PackageID: Codable {
        public var packageID: AmazonOpenSearchAPI.PackageID
        /// The unique identifier for the package.
        public var anyJSON: AnyJSON

        public init(packageID: AmazonOpenSearchAPI.PackageID, anyJSON: AnyJSON) {
            self.packageID = packageID
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageID = try values.decode(AmazonOpenSearchAPI.PackageID.self, forKey: "packageID")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageID, forKey: "packageID")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class PackageDescription: Codable {
        public var packageDescription: AmazonOpenSearchAPI.PackageDescription
        /// A new description of the package.
        public var anyJSON: AnyJSON

        public init(packageDescription: AmazonOpenSearchAPI.PackageDescription, anyJSON: AnyJSON) {
            self.packageDescription = packageDescription
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageDescription = try values.decode(AmazonOpenSearchAPI.PackageDescription.self, forKey: "packageDescription")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageDescription, forKey: "packageDescription")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class CommitMessage: Codable {
        public var commitMessage: AmazonOpenSearchAPI.CommitMessage
        /// A commit message for the new version which is shown as part of <code>GetPackageVersionHistoryResponse</code>.
        public var anyJSON: AnyJSON

        public init(commitMessage: AmazonOpenSearchAPI.CommitMessage, anyJSON: AnyJSON) {
            self.commitMessage = commitMessage
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.commitMessage = try values.decode(AmazonOpenSearchAPI.CommitMessage.self, forKey: "commitMessage")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(commitMessage, forKey: "commitMessage")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(packageID: PackageID, packageSource: PackageSource, packageDescription: PackageDescription? = nil, commitMessage: CommitMessage? = nil) {
        self.packageID = packageID
        self.packageSource = packageSource
        self.packageDescription = packageDescription
        self.commitMessage = commitMessage
    }

    private enum CodingKeys: String, CodingKey {
        case packageID = "PackageID"
        case packageSource = "PackageSource"
        case packageDescription = "PackageDescription"
        case commitMessage = "CommitMessage"
    }
}

/// Container for the request parameters to <code> <a>UpgradeDomain</a> </code> operation.
public struct UpgradeDomainRequest: Codable {
    /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    public var domainName: String
    public var targetVersion: TargetVersion
    public var performCheckOnly: PerformCheckOnly?
    /// <p>Exposes select native OpenSearch configuration values from <code>opensearch.yml</code>. Currently, the following advanced options are available: </p> <ul> <li>Option to allow references to indices in an HTTP request body. Must be <code>false</code> when configuring access to individual sub-resources. By default, the value is <code>true</code>. See <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options" target="_blank">Advanced cluster parameters </a> for more information. </li> <li>Option to specify the percentage of heap space allocated to field data. By default, this setting is unbounded. </li> </ul> <p>For more information, see <a href="http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options"> Advanced cluster parameters</a>. </p>
    public var advancedOptions: [String: String]?

    public struct TargetVersion: Codable {
        public var string: String
        /// The version of OpenSearch you intend to upgrade the domain to.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct PerformCheckOnly: Codable {
        public var isBool: Bool
        /// When true, indicates that an upgrade eligibility check needs to be performed. Does not actually perform the upgrade.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(domainName: String, targetVersion: TargetVersion, performCheckOnly: PerformCheckOnly? = nil, advancedOptions: [String: String]? = nil) {
        self.domainName = domainName
        self.targetVersion = targetVersion
        self.performCheckOnly = performCheckOnly
        self.advancedOptions = advancedOptions
    }

    private enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case targetVersion = "TargetVersion"
        case performCheckOnly = "PerformCheckOnly"
        case advancedOptions = "AdvancedOptions"
    }
}

/// History of the last 10 upgrades and upgrade eligibility checks.
public struct UpgradeHistory: Codable {
    public var upgradeName: UpgradeName?
    public var startTimestamp: StartTimestamp?
    public var upgradeStatus: UpgradeStatus?
    public var stepsList: StepsList?

    public final class UpgradeName: Codable {
        public var upgradeName: AmazonOpenSearchAPI.UpgradeName
        /// A string that briefly describes the upgrade.
        public var anyJSON: AnyJSON

        public init(upgradeName: AmazonOpenSearchAPI.UpgradeName, anyJSON: AnyJSON) {
            self.upgradeName = upgradeName
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.upgradeName = try values.decode(AmazonOpenSearchAPI.UpgradeName.self, forKey: "upgradeName")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(upgradeName, forKey: "upgradeName")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class StartTimestamp: Codable {
        public var startTimestamp: AmazonOpenSearchAPI.StartTimestamp
        /// UTC timestamp at which the upgrade API call was made in "yyyy-MM-ddTHH:mm:ssZ" format.
        public var anyJSON: AnyJSON

        public init(startTimestamp: AmazonOpenSearchAPI.StartTimestamp, anyJSON: AnyJSON) {
            self.startTimestamp = startTimestamp
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.startTimestamp = try values.decode(AmazonOpenSearchAPI.StartTimestamp.self, forKey: "startTimestamp")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(startTimestamp, forKey: "startTimestamp")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class UpgradeStatus: Codable {
        public var upgradeStatus: AmazonOpenSearchAPI.UpgradeStatus
        /// The current status of the upgrade. The status can take one of the following values: <ul> <li>In Progress</li> <li>Succeeded</li> <li>Succeeded with Issues</li> <li>Failed</li> </ul>
        public var anyJSON: AnyJSON

        public init(upgradeStatus: AmazonOpenSearchAPI.UpgradeStatus, anyJSON: AnyJSON) {
            self.upgradeStatus = upgradeStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.upgradeStatus = try values.decode(AmazonOpenSearchAPI.UpgradeStatus.self, forKey: "upgradeStatus")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(upgradeStatus, forKey: "upgradeStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct StepsList: Codable {
        public var upgradeStepItems: [UpgradeStepItem]
        /// A list of <code> <a>UpgradeStepItem</a> </code> s representing information about each step performed as part of a specific upgrade or upgrade eligibility check.
        public var anyJSON: AnyJSON

        public init(upgradeStepItems: [UpgradeStepItem], anyJSON: AnyJSON) {
            self.upgradeStepItems = upgradeStepItems
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.upgradeStepItems = try values.decode([UpgradeStepItem].self, forKey: "upgradeStepItems")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(upgradeStepItems, forKey: "upgradeStepItems")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(upgradeName: UpgradeName? = nil, startTimestamp: StartTimestamp? = nil, upgradeStatus: UpgradeStatus? = nil, stepsList: StepsList? = nil) {
        self.upgradeName = upgradeName
        self.startTimestamp = startTimestamp
        self.upgradeStatus = upgradeStatus
        self.stepsList = stepsList
    }

    private enum CodingKeys: String, CodingKey {
        case upgradeName = "UpgradeName"
        case startTimestamp = "StartTimestamp"
        case upgradeStatus = "UpgradeStatus"
        case stepsList = "StepsList"
    }
}

/// Represents a single step of the upgrade or upgrade eligibility check workflow.
public struct UpgradeStepItem: Codable {
    public var upgradeStep: UpgradeStep?
    public var upgradeStepStatus: UpgradeStepStatus?
    public var issues: Issues?
    public var progressPercent: ProgressPercent?

    public final class UpgradeStep: Codable {
        public var upgradeStep: AmazonOpenSearchAPI.UpgradeStep
        /// One of three steps an upgrade or upgrade eligibility check goes through: <ul> <li>PreUpgradeCheck</li> <li>Snapshot</li> <li>Upgrade</li> </ul>
        public var anyJSON: AnyJSON

        public init(upgradeStep: AmazonOpenSearchAPI.UpgradeStep, anyJSON: AnyJSON) {
            self.upgradeStep = upgradeStep
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.upgradeStep = try values.decode(AmazonOpenSearchAPI.UpgradeStep.self, forKey: "upgradeStep")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(upgradeStep, forKey: "upgradeStep")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct UpgradeStepStatus: Codable {
        public var upgradeStatus: UpgradeStatus
        /// The current status of the upgrade. The status can take one of the following values: <ul> <li>In Progress</li> <li>Succeeded</li> <li>Succeeded with Issues</li> <li>Failed</li> </ul>
        public var anyJSON: AnyJSON

        public init(upgradeStatus: UpgradeStatus, anyJSON: AnyJSON) {
            self.upgradeStatus = upgradeStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.upgradeStatus = try UpgradeStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(upgradeStatus, forKey: "upgradeStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class Issues: Codable {
        public var issues: AmazonOpenSearchAPI.Issues
        /// A list of strings containing detailed information about the errors encountered in a particular step.
        public var anyJSON: AnyJSON

        public init(issues: AmazonOpenSearchAPI.Issues, anyJSON: AnyJSON) {
            self.issues = issues
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.issues = try values.decode(AmazonOpenSearchAPI.Issues.self, forKey: "issues")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(issues, forKey: "issues")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ProgressPercent: Codable {
        public var double: Double
        /// The floating point value representing the progress percentage of a particular step.
        public var anyJSON: AnyJSON

        public init(double: Double, anyJSON: AnyJSON) {
            self.double = double
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.double = try values.decode(Double.self, forKey: "double")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(double, forKey: "double")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(upgradeStep: UpgradeStep? = nil, upgradeStepStatus: UpgradeStepStatus? = nil, issues: Issues? = nil, progressPercent: ProgressPercent? = nil) {
        self.upgradeStep = upgradeStep
        self.upgradeStepStatus = upgradeStepStatus
        self.issues = issues
        self.progressPercent = progressPercent
    }

    private enum CodingKeys: String, CodingKey {
        case upgradeStep = "UpgradeStep"
        case upgradeStepStatus = "UpgradeStepStatus"
        case issues = "Issues"
        case progressPercent = "ProgressPercent"
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
