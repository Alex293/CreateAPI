// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

/// Properties for common pagination handling to be included in any wrapping object that needs pagination elements
public struct PaginationProperties: Codable {
    /// The page number returned (should match the requested page query string param)
    public var page: String?
    /// True if additional pages exist (page + 1) or False if this is the last page
    public var nextPage: String?
    /// The number of items sent in this response
    public var returnedCount: Int?

    public init(page: String? = nil, nextPage: String? = nil, returnedCount: Int? = nil) {
        self.page = page
        self.nextPage = nextPage
        self.returnedCount = returnedCount
    }

    private enum CodingKeys: String, CodingKey {
        case page
        case nextPage = "next_page"
        case returnedCount = "returned_count"
    }
}

/// A record of a software item which is vulnerable or carries a fix for a vulnerability
public struct PackageReference: Codable {
    /// Package name
    public var name: String?
    /// A version for the package. If null, then references all versions
    public var version: String?
    /// Package type (e.g. package, rpm, deb, apk, jar, npm, gem, ...)
    public var type: String?
    /// Whether a vendor will or will not fix a vulnerabitlity
    public var isWillNotFix: Bool?

    public init(name: String? = nil, version: String? = nil, type: String? = nil, isWillNotFix: Bool? = nil) {
        self.name = name
        self.version = version
        self.type = type
        self.isWillNotFix = isWillNotFix
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case version
        case type
        case isWillNotFix = "will_not_fix"
    }
}

/// A record of a software item which is vulnerable or carries a fix for a vulnerability
public struct VulnerablePackageReference: Codable {
    /// Package name
    public var name: String?
    /// A version for the package. If null, then references all versions
    public var version: String?
    /// Package type (e.g. package, rpm, deb, apk, jar, npm, gem, ...)
    public var type: String?
    /// Severity of vulnerability affecting package
    public var severity: String?
    /// Vulnerability namespace of affected package
    public var namespace: String?

    public init(name: String? = nil, version: String? = nil, type: String? = nil, severity: String? = nil, namespace: String? = nil) {
        self.name = name
        self.version = version
        self.type = type
        self.severity = severity
        self.namespace = namespace
    }
}

/// A single vulnerability record in a single namespace, the unique key is the combination of the id and namespace
public struct StandaloneVulnerability: Codable {
    /// Vulnerability identifier. May be CVE-X, RHSA-X, etc. Not necessarily unique across namespaces
    public var id: String?
    /// The namespace for the vulnerability record to avoid conflicts for the same id in different distros or sources (e.g. deb vs ubuntu for same CVE)
    public var namespace: String?
    /// The array of packages (typically packages) that are vulnerable-to or provide fixes-for this vulnerability
    public var affectedPackages: [PackageReference]?
    /// Severity label specific to the namepsace
    public var severity: Severity?
    /// URL for the upstream CVE record in the reporting source (e.g. ubuntu security tracker)
    public var link: String?
    /// List of Nvd Data objects
    public var nvdData: [NvdDataObject]?
    /// List of Vendor Data objects
    public var vendorData: [VendorDataObject]?
    /// Description of the vulnerability if available
    public var description: String?
    /// List of references including
    public var references: [VulnerabilityReference]?

    /// Severity label specific to the namepsace
    public enum Severity: String, Codable, CaseIterable {
        case unknown = "Unknown"
        case negligible = "Negligible"
        case low = "Low"
        case medium = "Medium"
        case high = "High"
        case critical = "Critical"
    }

    public init(id: String? = nil, namespace: String? = nil, affectedPackages: [PackageReference]? = nil, severity: Severity? = nil, link: String? = nil, nvdData: [NvdDataObject]? = nil, vendorData: [VendorDataObject]? = nil, description: String? = nil, references: [VulnerabilityReference]? = nil) {
        self.id = id
        self.namespace = namespace
        self.affectedPackages = affectedPackages
        self.severity = severity
        self.link = link
        self.nvdData = nvdData
        self.vendorData = vendorData
        self.description = description
        self.references = references
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case namespace
        case affectedPackages = "affected_packages"
        case severity
        case link
        case nvdData = "nvd_data"
        case vendorData = "vendor_data"
        case description
        case references
    }
}

/// An external link/reference
public struct VulnerabilityReference: Codable {
    /// The reference source
    public var source: String?
    public var tags: [String]?
    /// The reference url
    public var url: String?

    public init(source: String? = nil, tags: [String]? = nil, url: String? = nil) {
        self.source = source
        self.tags = tags
        self.url = url
    }
}

/// A summary of an image identity, including digest, id (if available), and any tags known to have ever been mapped to the digest
public struct ImageReference: Codable {
    /// The image digest
    public var digest: String?
    /// The image id if available
    public var id: String?
    /// Timestamp, in rfc3339 format, indicating when the image state became 'analyzed' in Anchore Engine.
    public var analyzedAt: String?
    public var tagHistory: [TagEntry]?

    public init(digest: String? = nil, id: String? = nil, analyzedAt: String? = nil, tagHistory: [TagEntry]? = nil) {
        self.digest = digest
        self.id = id
        self.analyzedAt = analyzedAt
        self.tagHistory = tagHistory
    }

    private enum CodingKeys: String, CodingKey {
        case digest
        case id
        case analyzedAt = "analyzed_at"
        case tagHistory = "tag_history"
    }
}

/// A docker-pullable tag value as well as deconstructed components
public struct TagEntry: Codable {
    /// The pullable string for the tag. E.g. "docker.io/library/node:latest"
    public var pullstring: String?
    /// The registry hostname:port section of the pull string
    public var registry: String?
    /// The repository section of the pull string
    public var repository: String?
    /// The tag-only section of the pull string
    public var tag: String?
    /// The timestamp at which the Anchore Engine detected this tag was mapped to the image digest. Does not necessarily indicate when the tag was actually pushed to the registry.
    public var detectedAt: Date?

    public init(pullstring: String? = nil, registry: String? = nil, repository: String? = nil, tag: String? = nil, detectedAt: Date? = nil) {
        self.pullstring = pullstring
        self.registry = registry
        self.repository = repository
        self.tag = tag
        self.detectedAt = detectedAt
    }

    private enum CodingKeys: String, CodingKey {
        case pullstring
        case registry
        case repository
        case tag
        case detectedAt = "detected_at"
    }
}

/// A record of an image vulnerable to some known vulnerability. Includes vulnerable package information
public struct VulnerableImage: Codable {
    /// A summary of an image identity, including digest, id (if available), and any tags known to have ever been mapped to the digest
    public var image: ImageReference?
    public var affectedPackages: [VulnerablePackageReference]?

    public init(image: ImageReference? = nil, affectedPackages: [VulnerablePackageReference]? = nil) {
        self.image = image
        self.affectedPackages = affectedPackages
    }

    private enum CodingKeys: String, CodingKey {
        case image
        case affectedPackages = "affected_packages"
    }
}

/// An image record that contains packages
public struct ImageWithPackages: Codable {
    /// A summary of an image identity, including digest, id (if available), and any tags known to have ever been mapped to the digest
    public var image: ImageReference?
    public var packages: [PackageReference]?

    public init(image: ImageReference? = nil, packages: [PackageReference]? = nil) {
        self.image = image
        self.packages = packages
    }
}

/// Pagination wrapped list of images with vulnerabilties that match some filter
public struct PaginatedVulnerableImageList: Codable {
    /// Properties for common pagination handling to be included in any wrapping object that needs pagination elements
    public var paginationProperties: PaginationProperties
    public var images: [VulnerableImage]?

    public init(paginationProperties: PaginationProperties, images: [VulnerableImage]? = nil) {
        self.paginationProperties = paginationProperties
        self.images = images
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.paginationProperties = try PaginationProperties(from: decoder)
        self.images = try values.decodeIfPresent([VulnerableImage].self, forKey: "images")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(paginationProperties, forKey: "paginationProperties")
        try values.encodeIfPresent(images, forKey: "images")
    }
}

/// A paginated listing of vulnerability records sorted by ID in descending order
public struct PaginatedVulnerabilityList: Codable {
    /// Properties for common pagination handling to be included in any wrapping object that needs pagination elements
    public var paginationProperties: PaginationProperties
    /// The listing of matching vulnerabilities for the query subject to pagination
    public var vulnerabilities: [StandaloneVulnerability]?

    public init(paginationProperties: PaginationProperties, vulnerabilities: [StandaloneVulnerability]? = nil) {
        self.paginationProperties = paginationProperties
        self.vulnerabilities = vulnerabilities
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.paginationProperties = try PaginationProperties(from: decoder)
        self.vulnerabilities = try values.decodeIfPresent([StandaloneVulnerability].self, forKey: "vulnerabilities")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(paginationProperties, forKey: "paginationProperties")
        try values.encodeIfPresent(vulnerabilities, forKey: "vulnerabilities")
    }
}

/// Pagination wrapped list of images that match some filter
public struct PaginatedImageList: Codable {
    /// Properties for common pagination handling to be included in any wrapping object that needs pagination elements
    public var paginationProperties: PaginationProperties
    public var images: [ImageWithPackages]?

    public init(paginationProperties: PaginationProperties, images: [ImageWithPackages]? = nil) {
        self.paginationProperties = paginationProperties
        self.images = images
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.paginationProperties = try PaginationProperties(from: decoder)
        self.images = try values.decodeIfPresent([ImageWithPackages].self, forKey: "images")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(paginationProperties, forKey: "paginationProperties")
        try values.encodeIfPresent(images, forKey: "images")
    }
}

/// A request to add an image to be watched and analyzed by the engine. Optionally include the dockerfile content. Either source, digest or tag must be present.
public struct ImageAnalysisRequest: Codable {
    /// Base64 encoded content of the dockerfile for the image, if available. Deprecated in favor of the 'source' field.
    public var dockerfile: String?
    /// A digest string for an image, maybe a pull string or just a digest. e.g. nginx@sha256:123 or sha256:abc123. If a pull string, it must have same regisry/repo as the tag field. Deprecated in favor of the 'source' field
    public var digest: String?
    /// Full pullable tag reference for image. e.g. docker.io/nginx:latest. Deprecated in favor of the 'source' field
    public var tag: String?
    /// Optional override of the image creation time, only honored when both tag and digest are also supplied  e.g. 2018-10-17T18:14:00Z. Deprecated in favor of the 'source' field
    public var createdAt: Date?
    /// Optional. The type of image this is adding, defaults to "docker". This can be ommitted until multiple image types are supported.
    public var imageType: String?
    /// Annotations to be associated with the added image in key/value form
    public var annotations: [String: AnyJSON]?
    /// A set of analysis source types. Only one may be set in any given request.
    public var source: ImageSource?

    public init(dockerfile: String? = nil, digest: String? = nil, tag: String? = nil, createdAt: Date? = nil, imageType: String? = nil, annotations: [String: AnyJSON]? = nil, source: ImageSource? = nil) {
        self.dockerfile = dockerfile
        self.digest = digest
        self.tag = tag
        self.createdAt = createdAt
        self.imageType = imageType
        self.annotations = annotations
        self.source = source
    }

    private enum CodingKeys: String, CodingKey {
        case dockerfile
        case digest
        case tag
        case createdAt = "created_at"
        case imageType = "image_type"
        case annotations
        case source
    }
}

/// A set of analysis source types. Only one may be set in any given request.
public struct ImageSource: Codable {
    /// An image reference using a tag in a registry, this is the most common source type.
    public var tag: RegistryTagSource?
    /// An image reference using a digest in a registry, includes some extra tag and timestamp info in addition to the pull string to allow proper tag history reconstruction.
    public var digest: RegistryDigestSource?
    /// An image reference in the analysis archive for the purposes of loading analysis from the archive into th working set
    public var archive: AnalysisArchiveSource?
    public var `import`: ImageImportManifest?

    public init(tag: RegistryTagSource? = nil, digest: RegistryDigestSource? = nil, archive: AnalysisArchiveSource? = nil, `import`: ImageImportManifest? = nil) {
        self.tag = tag
        self.digest = digest
        self.archive = archive
        self.import = `import`
    }

    private enum CodingKeys: String, CodingKey {
        case tag
        case digest
        case archive
        case `import` = "import"
    }
}

/// An image reference using a tag in a registry, this is the most common source type.
public struct RegistryTagSource: Codable {
    /// A docker pull string (e.g. docker.io/nginx:latest, or docker.io/nginx@sha256:abd) to retrieve the image
    public var pullstring: String
    /// Base64 encoded content of the dockerfile used to build the image, if available.
    public var dockerfile: String?

    public init(pullstring: String, dockerfile: String? = nil) {
        self.pullstring = pullstring
        self.dockerfile = dockerfile
    }
}

/// An image reference using a digest in a registry, includes some extra tag and timestamp info in addition to the pull string to allow proper tag history reconstruction.
public struct RegistryDigestSource: Codable {
    /// A digest-based pullstring (e.g. docker.io/nginx@sha256:123abc)
    public var pullstring: String
    /// A valid docker tag reference (e.g. docker.io/nginx:latest) that will be associated with the image but not used to pull the image.
    public var tag: String
    /// Optional override of the image creation time to support proper tag history construction in cases of out-of-order analysis compared to registry history for the tag
    public var creationTimestampOverride: Date?
    /// Base64 encoded content of the dockerfile used to build the image, if available.
    public var dockerfile: String?

    public init(pullstring: String, tag: String, creationTimestampOverride: Date? = nil, dockerfile: String? = nil) {
        self.pullstring = pullstring
        self.tag = tag
        self.creationTimestampOverride = creationTimestampOverride
        self.dockerfile = dockerfile
    }

    private enum CodingKeys: String, CodingKey {
        case pullstring
        case tag
        case creationTimestampOverride = "creation_timestamp_override"
        case dockerfile
    }
}

/// An image reference in the analysis archive for the purposes of loading analysis from the archive into th working set
public struct AnalysisArchiveSource: Codable {
    /// The image digest identify the analysis. Archived analyses are based on digest, tag records are restored as analysis is restored.
    public var digest: String

    public init(digest: String) {
        self.digest = digest
    }
}

public struct LocalAnalysisSource: Codable {
    public var digest: String?

    public init(digest: String? = nil) {
        self.digest = digest
    }
}

/// A bundle containing a set of policies, whitelists, and rules for mapping them to specific images
public struct PolicyBundle: Codable {
    /// Id of the bundle
    public var id: String
    /// Human readable name for the bundle
    public var name: String?
    /// Description of the bundle, human readable
    public var comment: String?
    /// Version id for this bundle format
    public var version: String
    /// Whitelists which define which policy matches to disregard explicitly in the final policy decision
    public var whitelists: [Whitelist]?
    /// Policies which define the go/stop/warn status of an image using rule matches on image properties
    public var policies: [Policy]
    /// Mapping rules for defining which policy and whitelist(s) to apply to an image based on a match of the image tag or id. Evaluated in order.
    public var mappings: [MappingRule]
    /// List of mapping rules that define which images should always be passed (unless also on the blacklist), regardless of policy result.
    public var whitelistedImages: [ImageSelectionRule]?
    /// List of mapping rules that define which images should always result in a STOP/FAIL policy result regardless of policy content or presence in whitelisted_images
    public var blacklistedImages: [ImageSelectionRule]?

    public init(id: String, name: String? = nil, comment: String? = nil, version: String, whitelists: [Whitelist]? = nil, policies: [Policy], mappings: [MappingRule], whitelistedImages: [ImageSelectionRule]? = nil, blacklistedImages: [ImageSelectionRule]? = nil) {
        self.id = id
        self.name = name
        self.comment = comment
        self.version = version
        self.whitelists = whitelists
        self.policies = policies
        self.mappings = mappings
        self.whitelistedImages = whitelistedImages
        self.blacklistedImages = blacklistedImages
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case comment
        case version
        case whitelists
        case policies
        case mappings
        case whitelistedImages = "whitelisted_images"
        case blacklistedImages = "blacklisted_images"
    }
}

/// Identifies a specific gate and trigger match from a policy against an image and indicates it should be ignored in final policy decisions
public struct WhitelistItem: Codable {
    public var id: String?
    public var gate: String
    public var triggerID: String
    public var expiresOn: Date?

    public init(id: String? = nil, gate: String, triggerID: String, expiresOn: Date? = nil) {
        self.id = id
        self.gate = gate
        self.triggerID = triggerID
        self.expiresOn = expiresOn
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case gate
        case triggerID = "trigger_id"
        case expiresOn = "expires_on"
    }
}

/// A rule that defines and decision value if the match is found true for a given image.
public struct PolicyRule: Codable {
    public var id: String?
    public var gate: String
    public var trigger: String
    public var action: Action
    public var params: [Param]?

    public enum Action: String, Codable, CaseIterable {
        case go = "GO"
        case stop = "STOP"
        case warn = "WARN"
    }

    public struct Param: Codable {
        public var name: String
        public var value: String

        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }
    }

    public init(id: String? = nil, gate: String, trigger: String, action: Action, params: [Param]? = nil) {
        self.id = id
        self.gate = gate
        self.trigger = trigger
        self.action = action
        self.params = params
    }
}

/// A collection of whitelist items to match a policy evaluation against.
public struct Whitelist: Codable {
    public var id: String
    public var name: String?
    public var version: String
    public var comment: String?
    public var items: [WhitelistItem]?

    public init(id: String, name: String? = nil, version: String, comment: String? = nil, items: [WhitelistItem]? = nil) {
        self.id = id
        self.name = name
        self.version = version
        self.comment = comment
        self.items = items
    }
}

/// A reference to an image
public struct ImageRef: Codable {
    public var type: `Type`
    public var value: String

    public enum `Type`: String, Codable, CaseIterable {
        case tag
        case digest
        case id
    }

    public init(type: `Type`, value: String) {
        self.type = type
        self.value = value
    }
}

/// Image deletion response containing status and details
public struct DeleteImageResponse: Codable {
    public var digest: String
    /// Current status of the image deletion
    public var status: Status
    public var detail: String?

    /// Current status of the image deletion
    public enum Status: String, Codable, CaseIterable {
        case notFound = "not_found"
        case deleting
        case deleteFailed = "delete_failed"
    }

    public init(digest: String, status: Status, detail: String? = nil) {
        self.digest = digest
        self.status = status
        self.detail = detail
    }
}

public struct Policy: Codable {
    public var id: String
    public var name: String?
    public var comment: String?
    public var version: String
    public var rules: [PolicyRule]?

    public init(id: String, name: String? = nil, comment: String? = nil, version: String, rules: [PolicyRule]? = nil) {
        self.id = id
        self.name = name
        self.comment = comment
        self.version = version
        self.rules = rules
    }
}

public struct ImageSelectionRule: Codable {
    public var id: String?
    public var name: String
    public var registry: String
    public var repository: String
    /// A reference to an image
    public var image: ImageRef

    public init(id: String? = nil, name: String, registry: String, repository: String, image: ImageRef) {
        self.id = id
        self.name = name
        self.registry = registry
        self.repository = repository
        self.image = image
    }
}

public struct MappingRule: Codable {
    public var id: String?
    public var name: String
    public var whitelistIDs: [String]?
    /// Optional single policy to evalute, if set will override any value in policy_ids, for backwards compatibility. Generally, policy_ids should be used even with a array of length 1.
    public var policyID: String?
    /// List of policyIds to evaluate in order, to completion
    public var policyIDs: [String]?
    public var registry: String
    public var repository: String
    /// A reference to an image
    public var image: ImageRef

    public init(id: String? = nil, name: String, whitelistIDs: [String]? = nil, policyID: String? = nil, policyIDs: [String]? = nil, registry: String, repository: String, image: ImageRef) {
        self.id = id
        self.name = name
        self.whitelistIDs = whitelistIDs
        self.policyID = policyID
        self.policyIDs = policyIDs
        self.registry = registry
        self.repository = repository
        self.image = image
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case whitelistIDs = "whitelist_ids"
        case policyID = "policy_id"
        case policyIDs = "policy_ids"
        case registry
        case repository
        case image
    }
}

/// A policy bundle plus some metadata
public struct PolicyBundleRecord: Codable {
    public var createdAt: Date?
    public var lastUpdated: Date?
    /// The bundle's identifier
    public var policyID: String?
    /// True if the bundle is currently defined to be used automatically
    public var isActive: Bool?
    /// UserId of the user that owns the bundle
    public var userID: String?
    /// Source location of where the policy bundle originated
    public var policySource: String?
    /// A bundle containing a set of policies, whitelists, and rules for mapping them to specific images
    public var policybundle: PolicyBundle?

    public init(createdAt: Date? = nil, lastUpdated: Date? = nil, policyID: String? = nil, isActive: Bool? = nil, userID: String? = nil, policySource: String? = nil, policybundle: PolicyBundle? = nil) {
        self.createdAt = createdAt
        self.lastUpdated = lastUpdated
        self.policyID = policyID
        self.isActive = isActive
        self.userID = userID
        self.policySource = policySource
        self.policybundle = policybundle
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case lastUpdated = "last_updated"
        case policyID = "policyId"
        case isActive = "active"
        case userID = "userId"
        case policySource = "policy_source"
        case policybundle
    }
}

/// A metadata detail record for a specific image. Multiple detail records may map a single catalog image.
public struct ImageDetail: Codable {
    public var createdAt: Date?
    public var lastUpdated: Date?
    /// Full docker-pullable tag string referencing the image
    public var fulltag: String?
    /// Full docker-pullable digest string including the registry url and repository necessary get the image
    public var fulldigest: String?
    public var userID: String?
    public var imageID: String?
    public var registry: String?
    public var repo: String?
    public var dockerfile: String?
    /// The parent Anchore Image record to which this detail maps
    public var imageDigest: String?

    public init(createdAt: Date? = nil, lastUpdated: Date? = nil, fulltag: String? = nil, fulldigest: String? = nil, userID: String? = nil, imageID: String? = nil, registry: String? = nil, repo: String? = nil, dockerfile: String? = nil, imageDigest: String? = nil) {
        self.createdAt = createdAt
        self.lastUpdated = lastUpdated
        self.fulltag = fulltag
        self.fulldigest = fulldigest
        self.userID = userID
        self.imageID = imageID
        self.registry = registry
        self.repo = repo
        self.dockerfile = dockerfile
        self.imageDigest = imageDigest
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case lastUpdated = "last_updated"
        case fulltag
        case fulldigest
        case userID = "userId"
        case imageID = "imageId"
        case registry
        case repo
        case dockerfile
        case imageDigest
    }
}

/// A unique image in the engine.
public struct AnchoreImageTagSummary: Codable {
    public var imageDigest: String?
    public var parentDigest: String?
    public var imageID: String?
    public var analysisStatus: String?
    public var fulltag: String?
    public var createdAt: Int?
    public var analyzedAt: Int?
    public var tagDetectedAt: Int?
    public var imageStatus: String?

    public init(imageDigest: String? = nil, parentDigest: String? = nil, imageID: String? = nil, analysisStatus: String? = nil, fulltag: String? = nil, createdAt: Int? = nil, analyzedAt: Int? = nil, tagDetectedAt: Int? = nil, imageStatus: String? = nil) {
        self.imageDigest = imageDigest
        self.parentDigest = parentDigest
        self.imageID = imageID
        self.analysisStatus = analysisStatus
        self.fulltag = fulltag
        self.createdAt = createdAt
        self.analyzedAt = analyzedAt
        self.tagDetectedAt = tagDetectedAt
        self.imageStatus = imageStatus
    }

    private enum CodingKeys: String, CodingKey {
        case imageDigest
        case parentDigest
        case imageID = "imageId"
        case analysisStatus = "analysis_status"
        case fulltag
        case createdAt = "created_at"
        case analyzedAt = "analyzed_at"
        case tagDetectedAt = "tag_detected_at"
        case imageStatus = "image_status"
    }
}

/// A unique image in the engine. May have multiple tags or references. Unique to an image content across registries or repositories.
public struct AnchoreImage: Codable {
    /// A metadata content record for a specific image, containing different content type entries
    public var imageContent: [String: AnyJSON]?
    /// Details specific to an image reference and type such as tag and image source
    public var imageDetail: [ImageDetail]?
    public var lastUpdated: Date?
    public var createdAt: Date?
    public var imageDigest: String?
    public var userID: String?
    public var annotations: [String: AnyJSON]?
    /// State of the image
    public var imageStatus: ImageStatus?
    /// A state value for the current status of the analysis progress of the image
    public var analysisStatus: AnalysisStatus?
    /// The version of the record, used for internal schema updates and data migrations.
    public var recordVersion: String?

    /// State of the image
    public enum ImageStatus: String, Codable, CaseIterable {
        case active
        case inactive
        case disabled
    }

    /// A state value for the current status of the analysis progress of the image
    public enum AnalysisStatus: String, Codable, CaseIterable {
        case notAnalyzed = "not_analyzed"
        case analyzing
        case analyzed
        case analysisFailed = "analysis_failed"
    }

    public init(imageContent: [String: AnyJSON]? = nil, imageDetail: [ImageDetail]? = nil, lastUpdated: Date? = nil, createdAt: Date? = nil, imageDigest: String? = nil, userID: String? = nil, annotations: [String: AnyJSON]? = nil, imageStatus: ImageStatus? = nil, analysisStatus: AnalysisStatus? = nil, recordVersion: String? = nil) {
        self.imageContent = imageContent
        self.imageDetail = imageDetail
        self.lastUpdated = lastUpdated
        self.createdAt = createdAt
        self.imageDigest = imageDigest
        self.userID = userID
        self.annotations = annotations
        self.imageStatus = imageStatus
        self.analysisStatus = analysisStatus
        self.recordVersion = recordVersion
    }

    private enum CodingKeys: String, CodingKey {
        case imageContent = "image_content"
        case imageDetail = "image_detail"
        case lastUpdated = "last_updated"
        case createdAt = "created_at"
        case imageDigest
        case userID = "userId"
        case annotations
        case imageStatus = "image_status"
        case analysisStatus = "analysis_status"
        case recordVersion = "record_version"
    }
}

/// System status response
public struct SystemStatusResponse: Codable {
    /// A list of service objects
    public var serviceStates: [Service]?

    public init(serviceStates: [Service]? = nil) {
        self.serviceStates = serviceStates
    }

    private enum CodingKeys: String, CodingKey {
        case serviceStates = "service_states"
    }
}

/// System status response
public struct StatusResponse: Codable {
    public var isAvailable: Bool?
    public var isBusy: Bool?
    public var isUp: Bool?
    public var message: String?
    public var version: String?
    public var dbVersion: String?
    public var detail: [String: AnyJSON]?

    public init(isAvailable: Bool? = nil, isBusy: Bool? = nil, isUp: Bool? = nil, message: String? = nil, version: String? = nil, dbVersion: String? = nil, detail: [String: AnyJSON]? = nil) {
        self.isAvailable = isAvailable
        self.isBusy = isBusy
        self.isUp = isUp
        self.message = message
        self.version = version
        self.dbVersion = dbVersion
        self.detail = detail
    }

    private enum CodingKeys: String, CodingKey {
        case isAvailable = "available"
        case isBusy = "busy"
        case isUp = "up"
        case message
        case version
        case dbVersion = "db_version"
        case detail
    }
}

/// Generic HTTP API error response
public struct APIErrorResponse: Codable {
    public var code: Int?
    public var errorType: String?
    public var message: String?
    /// Details structure for additional information about the error if available. Content and structure will be error specific.
    public var detail: [String: AnyJSON]?

    public init(code: Int? = nil, errorType: String? = nil, message: String? = nil, detail: [String: AnyJSON]? = nil) {
        self.code = code
        self.errorType = errorType
        self.message = message
        self.detail = detail
    }

    private enum CodingKeys: String, CodingKey {
        case code
        case errorType = "error_type"
        case message
        case detail
    }
}

/// A service status record
public struct Service: Codable {
    /// The unique id of the host on which the service is executing
    public var hostid: String?
    /// Registered service name
    public var servicename: String?
    /// The url to reach the service, including port as needed
    public var baseURL: String?
    /// A state indicating the condition of the service. Normal operation is 'registered'
    public var statusMessage: String?
    /// System status response
    public var serviceDetail: StatusResponse?
    public var isStatus: Bool?
    /// The version of the service as reported by the service implementation on registration
    public var version: String?

    public init(hostid: String? = nil, servicename: String? = nil, baseURL: String? = nil, statusMessage: String? = nil, serviceDetail: StatusResponse? = nil, isStatus: Bool? = nil, version: String? = nil) {
        self.hostid = hostid
        self.servicename = servicename
        self.baseURL = baseURL
        self.statusMessage = statusMessage
        self.serviceDetail = serviceDetail
        self.isStatus = isStatus
        self.version = version
    }

    private enum CodingKeys: String, CodingKey {
        case hostid
        case servicename
        case baseURL = "base_url"
        case statusMessage = "status_message"
        case serviceDetail = "service_detail"
        case isStatus = "status"
        case version
    }
}

/// Generic wrapper for content listings from images
public struct ContentResponse: Codable {
    public var imageDigest: String?
    public var contentType: String?
    public var content: [[String: AnyJSON]]?

    public init(imageDigest: String? = nil, contentType: String? = nil, content: [[String: AnyJSON]]? = nil) {
        self.imageDigest = imageDigest
        self.contentType = contentType
        self.content = content
    }

    private enum CodingKeys: String, CodingKey {
        case imageDigest
        case contentType = "content_type"
        case content
    }
}

/// File content listings from images
public struct ContentFilesResponse: Codable {
    public var imageDigest: String?
    public var contentType: String?
    public var content: [ContentItem]?

    public struct ContentItem: Codable {
        public var filename: String?
        public var gid: Int?
        public var linkdest: String?
        public var mode: String?
        public var sha256: String?
        public var size: Int?
        public var type: String?
        public var uid: Int?

        public init(filename: String? = nil, gid: Int? = nil, linkdest: String? = nil, mode: String? = nil, sha256: String? = nil, size: Int? = nil, type: String? = nil, uid: Int? = nil) {
            self.filename = filename
            self.gid = gid
            self.linkdest = linkdest
            self.mode = mode
            self.sha256 = sha256
            self.size = size
            self.type = type
            self.uid = uid
        }
    }

    public init(imageDigest: String? = nil, contentType: String? = nil, content: [ContentItem]? = nil) {
        self.imageDigest = imageDigest
        self.contentType = contentType
        self.content = content
    }

    private enum CodingKeys: String, CodingKey {
        case imageDigest
        case contentType = "content_type"
        case content
    }
}

/// Package content listings from images
public struct ContentPackageResponse: Codable {
    public var imageDigest: String?
    public var contentType: String?
    public var content: [ContentItem]?

    public struct ContentItem: Codable {
        public var package: String?
        public var version: String?
        public var size: String?
        public var type: String?
        public var origin: String?
        /// Deprecated in favor of the 'licenses' field"
        public var license: String?
        public var licenses: [String]?
        public var location: String?
        /// A list of Common Platform Enumerations that may uniquely identify the package
        public var cpes: [String]?

        public init(package: String? = nil, version: String? = nil, size: String? = nil, type: String? = nil, origin: String? = nil, license: String? = nil, licenses: [String]? = nil, location: String? = nil, cpes: [String]? = nil) {
            self.package = package
            self.version = version
            self.size = size
            self.type = type
            self.origin = origin
            self.license = license
            self.licenses = licenses
            self.location = location
            self.cpes = cpes
        }
    }

    public init(imageDigest: String? = nil, contentType: String? = nil, content: [ContentItem]? = nil) {
        self.imageDigest = imageDigest
        self.contentType = contentType
        self.content = content
    }

    private enum CodingKeys: String, CodingKey {
        case imageDigest
        case contentType = "content_type"
        case content
    }
}

/// Malware listing response
public struct ContentMalwareResponse: Codable {
    public var imageDigest: String?
    public var contentType: String?
    /// List of malware scan results, one per scanner configured to run
    public var content: [MalwareScan]?

    public init(imageDigest: String? = nil, contentType: String? = nil, content: [MalwareScan]? = nil) {
        self.imageDigest = imageDigest
        self.contentType = contentType
        self.content = content
    }

    private enum CodingKeys: String, CodingKey {
        case imageDigest
        case contentType = "content_type"
        case content
    }
}

/// A single scan from a scanner
public struct MalwareScan: Codable {
    /// Indicates if the scanner is enabled
    public var isEnabled: Bool?
    /// The name of the scanner that produced the finding
    public var scanner: String?
    /// Open schema for scanner-specific metadata related to the scan result
    public var metadata: [String: AnyJSON]?
    public var findings: [Finding]?

    public struct Finding: Codable {
        /// A path for a file in the image's rootfs
        public var path: String?
        /// The malware signature found at the path
        public var signature: String?

        public init(path: String? = nil, signature: String? = nil) {
            self.path = path
            self.signature = signature
        }
    }

    public init(isEnabled: Bool? = nil, scanner: String? = nil, metadata: [String: AnyJSON]? = nil, findings: [Finding]? = nil) {
        self.isEnabled = isEnabled
        self.scanner = scanner
        self.metadata = metadata
        self.findings = findings
    }

    private enum CodingKeys: String, CodingKey {
        case isEnabled = "enabled"
        case scanner
        case metadata
        case findings
    }
}

/// Java package content listings from images
public struct ContentJAVAPackageResponse: Codable {
    public var imageDigest: String?
    public var contentType: String?
    public var content: [ContentItem]?

    public struct ContentItem: Codable {
        public var package: String?
        public var implementationVersion: String?
        public var specificationVersion: String?
        public var mavenVersion: String?
        public var location: String?
        public var type: String?
        public var origin: String?
        /// A list of Common Platform Enumerations that may uniquely identify the package
        public var cpes: [String]?

        public init(package: String? = nil, implementationVersion: String? = nil, specificationVersion: String? = nil, mavenVersion: String? = nil, location: String? = nil, type: String? = nil, origin: String? = nil, cpes: [String]? = nil) {
            self.package = package
            self.implementationVersion = implementationVersion
            self.specificationVersion = specificationVersion
            self.mavenVersion = mavenVersion
            self.location = location
            self.type = type
            self.origin = origin
            self.cpes = cpes
        }

        private enum CodingKeys: String, CodingKey {
            case package
            case implementationVersion = "implementation-version"
            case specificationVersion = "specification-version"
            case mavenVersion = "maven-version"
            case location
            case type
            case origin
            case cpes
        }
    }

    public init(imageDigest: String? = nil, contentType: String? = nil, content: [ContentItem]? = nil) {
        self.imageDigest = imageDigest
        self.contentType = contentType
        self.content = content
    }

    private enum CodingKeys: String, CodingKey {
        case imageDigest
        case contentType = "content_type"
        case content
    }
}

/// Generic wrapper for metadata listings from images
public struct MetadataResponse: Codable {
    public var imageDigest: String?
    public var metadataType: String?
    public var metadata: [String: AnyJSON]?

    public init(imageDigest: String? = nil, metadataType: String? = nil, metadata: [String: AnyJSON]? = nil) {
        self.imageDigest = imageDigest
        self.metadataType = metadataType
        self.metadata = metadata
    }

    private enum CodingKeys: String, CodingKey {
        case imageDigest
        case metadataType = "metadata_type"
        case metadata
    }
}

/// A modification to a subscription entry to change its status or value
public struct SubscriptionUpdate: Codable {
    /// The new subscription value, e.g. the new tag to be subscribed to
    public var subscriptionValue: String?
    /// Toggle the subscription processing on or off
    public var isActive: Bool?

    public init(subscriptionValue: String? = nil, isActive: Bool? = nil) {
        self.subscriptionValue = subscriptionValue
        self.isActive = isActive
    }

    private enum CodingKeys: String, CodingKey {
        case subscriptionValue = "subscription_value"
        case isActive = "active"
    }
}

/// A subscription entry to add to the system
public struct SubscriptionRequest: Codable {
    public var subscriptionKey: String?
    public var subscriptionValue: String?
    public var subscriptionType: String?

    public init(subscriptionKey: String? = nil, subscriptionValue: String? = nil, subscriptionType: String? = nil) {
        self.subscriptionKey = subscriptionKey
        self.subscriptionValue = subscriptionValue
        self.subscriptionType = subscriptionType
    }

    private enum CodingKeys: String, CodingKey {
        case subscriptionKey = "subscription_key"
        case subscriptionValue = "subscription_value"
        case subscriptionType = "subscription_type"
    }
}

/// Subscription entry
public struct Subscription: Codable {
    /// The key value that the subscription references. E.g. a tag value or a repo name.
    public var subscriptionKey: String?
    /// The type of the subscription
    public var subscriptionType: String?
    /// The value of the subscription target
    public var subscriptionValue: String?
    /// The userId of the subscribed user
    public var userID: String?
    /// Is the subscription currently active
    public var isActive: Bool?
    /// The unique id for this subscription record
    public var subscriptionID: String?

    public init(subscriptionKey: String? = nil, subscriptionType: String? = nil, subscriptionValue: String? = nil, userID: String? = nil, isActive: Bool? = nil, subscriptionID: String? = nil) {
        self.subscriptionKey = subscriptionKey
        self.subscriptionType = subscriptionType
        self.subscriptionValue = subscriptionValue
        self.userID = userID
        self.isActive = isActive
        self.subscriptionID = subscriptionID
    }

    private enum CodingKeys: String, CodingKey {
        case subscriptionKey = "subscription_key"
        case subscriptionType = "subscription_type"
        case subscriptionValue = "subscription_value"
        case userID = "userId"
        case isActive = "active"
        case subscriptionID = "subscription_id"
    }
}

/// A registry record describing the endpoint and credentials for a registry
public struct RegistryConfigurationRequest: Codable {
    /// Username portion of credential to use for this registry
    public var registryUser: String?
    /// Password portion of credential to use for this registry
    public var registryPass: String?
    /// Type of registry
    public var registryType: String?
    /// Hostname:port string for accessing the registry, as would be used in a docker pull operation. May include some or all of a repository and wildcards (e.g. docker.io/library/* or gcr.io/myproject/myrepository)
    public var registry: String?
    /// Human readable name associated with registry record
    public var registryName: String?
    /// Use TLS/SSL verification for the registry URL
    public var isRegistryVerify: Bool?

    public init(registryUser: String? = nil, registryPass: String? = nil, registryType: String? = nil, registry: String? = nil, registryName: String? = nil, isRegistryVerify: Bool? = nil) {
        self.registryUser = registryUser
        self.registryPass = registryPass
        self.registryType = registryType
        self.registry = registry
        self.registryName = registryName
        self.isRegistryVerify = isRegistryVerify
    }

    private enum CodingKeys: String, CodingKey {
        case registryUser = "registry_user"
        case registryPass = "registry_pass"
        case registryType = "registry_type"
        case registry
        case registryName = "registry_name"
        case isRegistryVerify = "registry_verify"
    }
}

/// A registry entry describing the endpoint and credentials for a registry to pull images from
public struct RegistryConfiguration: Codable {
    public var createdAt: Date?
    public var lastUpated: Date?
    /// Username portion of credential to use for this registry
    public var registryUser: String?
    /// Type of registry
    public var registryType: String?
    /// Engine user that owns this registry entry
    public var userID: String?
    /// Hostname:port string for accessing the registry, as would be used in a docker pull operation
    public var registry: String?
    /// Human readable name associated with registry record
    public var registryName: String?
    /// Use TLS/SSL verification for the registry URL
    public var isRegistryVerify: Bool?

    public init(createdAt: Date? = nil, lastUpated: Date? = nil, registryUser: String? = nil, registryType: String? = nil, userID: String? = nil, registry: String? = nil, registryName: String? = nil, isRegistryVerify: Bool? = nil) {
        self.createdAt = createdAt
        self.lastUpated = lastUpated
        self.registryUser = registryUser
        self.registryType = registryType
        self.userID = userID
        self.registry = registry
        self.registryName = registryName
        self.isRegistryVerify = isRegistryVerify
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case lastUpated = "last_upated"
        case registryUser = "registry_user"
        case registryType = "registry_type"
        case userID = "userId"
        case registry
        case registryName = "registry_name"
        case isRegistryVerify = "registry_verify"
    }
}

public struct Vulnerability: Codable {
    /// The vulnerability identifier, such as CVE-2017-100, or RHSA-2017123
    public var vuln: String?
    /// The package containing a fix, if available
    public var fix: String?
    /// The severity of the vulnerability
    public var severity: String?
    /// The package name and version that are vulnerable in the image
    public var package: String?
    /// The url for more information about the vulnerability
    public var url: String?
    /// The name of the feed where vulnerability match was made
    public var feed: String?
    /// The name of the feed group where vulnerability match was made
    public var feedGroup: String?
    /// The name of the vulnerable package artifact
    public var packageName: String?
    /// The version of the vulnerable package artifact
    public var packageVersion: String?
    /// The type of vulnerable package
    public var packageType: String?
    /// The CPE string (if applicable) describing the package to vulnerability match
    public var packageCpe: String?
    /// The location (if applicable) of the vulnerable package in the container filesystem
    public var packagePath: String?
    /// Whether a vendor will fix or not fix the vulnerability
    public var isWillNotFix: Bool?
    /// List of Nvd Data objects
    public var nvdData: [NvdDataObject]?
    /// List of Vendor Data objects
    public var vendorData: [VendorDataObject]?

    public init(vuln: String? = nil, fix: String? = nil, severity: String? = nil, package: String? = nil, url: String? = nil, feed: String? = nil, feedGroup: String? = nil, packageName: String? = nil, packageVersion: String? = nil, packageType: String? = nil, packageCpe: String? = nil, packagePath: String? = nil, isWillNotFix: Bool? = nil, nvdData: [NvdDataObject]? = nil, vendorData: [VendorDataObject]? = nil) {
        self.vuln = vuln
        self.fix = fix
        self.severity = severity
        self.package = package
        self.url = url
        self.feed = feed
        self.feedGroup = feedGroup
        self.packageName = packageName
        self.packageVersion = packageVersion
        self.packageType = packageType
        self.packageCpe = packageCpe
        self.packagePath = packagePath
        self.isWillNotFix = isWillNotFix
        self.nvdData = nvdData
        self.vendorData = vendorData
    }

    private enum CodingKeys: String, CodingKey {
        case vuln
        case fix
        case severity
        case package
        case url
        case feed
        case feedGroup = "feed_group"
        case packageName = "package_name"
        case packageVersion = "package_version"
        case packageType = "package_type"
        case packageCpe = "package_cpe"
        case packagePath = "package_path"
        case isWillNotFix = "will_not_fix"
        case nvdData = "nvd_data"
        case vendorData = "vendor_data"
    }
}

public struct NvdDataObject: Codable {
    /// NVD Vulnerability ID
    public var id: String?
    public var cvssV2: CVSSV2Scores?
    public var cvssV3: CVSSV3Scores?

    public init(id: String? = nil, cvssV2: CVSSV2Scores? = nil, cvssV3: CVSSV3Scores? = nil) {
        self.id = id
        self.cvssV2 = cvssV2
        self.cvssV3 = cvssV3
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case cvssV2 = "cvss_v2"
        case cvssV3 = "cvss_v3"
    }
}

public struct VendorDataObject: Codable {
    /// Vendor Vulnerability ID
    public var id: String?
    public var cvssV2: CVSSV2Scores?
    public var cvssV3: CVSSV3Scores?

    public init(id: String? = nil, cvssV2: CVSSV2Scores? = nil, cvssV3: CVSSV3Scores? = nil) {
        self.id = id
        self.cvssV2 = cvssV2
        self.cvssV3 = cvssV3
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case cvssV2 = "cvss_v2"
        case cvssV3 = "cvss_v3"
    }
}

public struct CVSSV2Scores: Codable {
    public var baseScore: Double?
    public var exploitabilityScore: Double?
    public var impactScore: Double?

    public init(baseScore: Double? = nil, exploitabilityScore: Double? = nil, impactScore: Double? = nil) {
        self.baseScore = baseScore
        self.exploitabilityScore = exploitabilityScore
        self.impactScore = impactScore
    }

    private enum CodingKeys: String, CodingKey {
        case baseScore = "base_score"
        case exploitabilityScore = "exploitability_score"
        case impactScore = "impact_score"
    }
}

public struct CVSSV3Scores: Codable {
    public var baseScore: Double?
    public var exploitabilityScore: Double?
    public var impactScore: Double?

    public init(baseScore: Double? = nil, exploitabilityScore: Double? = nil, impactScore: Double? = nil) {
        self.baseScore = baseScore
        self.exploitabilityScore = exploitabilityScore
        self.impactScore = impactScore
    }

    private enum CodingKeys: String, CodingKey {
        case baseScore = "base_score"
        case exploitabilityScore = "exploitability_score"
        case impactScore = "impact_score"
    }
}

/// Envelope containing list of vulnerabilities
public struct VulnerabilityResponse: Codable {
    public var imageDigest: String?
    public var vulnerabilityType: String?
    /// List of Vulnerability objects
    public var vulnerabilities: [Vulnerability]?

    public init(imageDigest: String? = nil, vulnerabilityType: String? = nil, vulnerabilities: [Vulnerability]? = nil) {
        self.imageDigest = imageDigest
        self.vulnerabilityType = vulnerabilityType
        self.vulnerabilities = vulnerabilities
    }

    private enum CodingKeys: String, CodingKey {
        case imageDigest
        case vulnerabilityType = "vulnerability_type"
        case vulnerabilities
    }
}

/// Filter for an image list by id, tag, or digest, but not both
public struct ImageFilter: Codable {
    public var tag: String?
    public var digest: String?

    public init(tag: String? = nil, digest: String? = nil) {
        self.tag = tag
        self.digest = digest
    }
}

/// A description of an anchore error code (name, description)
public struct AnchoreErrorCode: Codable {
    /// Error code name
    public var name: String?
    /// Description of the error code
    public var description: String?

    public init(name: String? = nil, description: String? = nil) {
        self.name = name
        self.description = description
    }
}

/// A description of the set of gates available in this engine and the triggers and parameters supported
public struct GateSpec: Codable {
    /// Gate name, as it would appear in a policy document
    public var name: String?
    /// Description of the gate
    public var description: String?
    /// State of the gate and transitively all triggers it contains if not 'active'
    public var state: State?
    /// The name of another trigger that supercedes this on functionally if this is deprecated
    public var supercededBy: String?
    /// List of the triggers that can fire for this Gate
    public var triggers: [TriggerSpec]?

    /// State of the gate and transitively all triggers it contains if not 'active'
    public enum State: String, Codable, CaseIterable {
        case active
        case deprecated
        case eol
    }

    public init(name: String? = nil, description: String? = nil, state: State? = nil, supercededBy: String? = nil, triggers: [TriggerSpec]? = nil) {
        self.name = name
        self.description = description
        self.state = state
        self.supercededBy = supercededBy
        self.triggers = triggers
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case description
        case state
        case supercededBy = "superceded_by"
        case triggers
    }
}

/// Definition of a trigger and its parameters
public struct TriggerSpec: Codable {
    /// Name of the trigger as it would appear in a policy document
    public var name: String?
    /// Trigger description for what it tests and when it will fire during evaluation
    public var description: String?
    /// State of the trigger
    public var state: State?
    /// The name of another trigger that supercedes this on functionally if this is deprecated
    public var supercededBy: String?
    /// The list of parameters that are valid for this trigger
    public var parameters: [TriggerParamSpec]?

    /// State of the trigger
    public enum State: String, Codable, CaseIterable {
        case active
        case deprecated
        case eol
    }

    public init(name: String? = nil, description: String? = nil, state: State? = nil, supercededBy: String? = nil, parameters: [TriggerParamSpec]? = nil) {
        self.name = name
        self.description = description
        self.state = state
        self.supercededBy = supercededBy
        self.parameters = parameters
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case description
        case state
        case supercededBy = "superceded_by"
        case parameters
    }
}

public struct TriggerParamSpec: Codable {
    /// Parameter name as it appears in policy document
    public var name: String?
    public var description: String?
    /// An example value for the parameter (encoded as a string if the parameter is an object or list type)
    public var example: String?
    /// State of the trigger parameter
    public var state: State?
    /// The name of another trigger that supercedes this on functionally if this is deprecated
    public var supercededBy: String?
    /// Is this a required parameter or optional
    public var isRequired: Bool?
    /// If present, a definition for validation of input. Typically a jsonschema object that can be used to validate an input against.
    public var validator: [String: AnyJSON]?

    /// State of the trigger parameter
    public enum State: String, Codable, CaseIterable {
        case active
        case deprecated
        case eol
    }

    public init(name: String? = nil, description: String? = nil, example: String? = nil, state: State? = nil, supercededBy: String? = nil, isRequired: Bool? = nil, validator: [String: AnyJSON]? = nil) {
        self.name = name
        self.description = description
        self.example = example
        self.state = state
        self.supercededBy = supercededBy
        self.isRequired = isRequired
        self.validator = validator
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case description
        case example
        case state
        case supercededBy = "superceded_by"
        case isRequired = "required"
        case validator
    }
}

/// Metadata on a single feed based on what the engine finds from querying the endpoints
public struct FeedMetadata: Codable {
    /// Name of the feed
    public var name: String?
    /// Date the metadata record was created in engine (first seen on source)
    public var createdAt: Date?
    /// Date the metadata was last updated
    public var updatedAt: Date?
    public var groups: [FeedGroupMetadata]?
    public var lastFullSync: Date?

    public init(name: String? = nil, createdAt: Date? = nil, updatedAt: Date? = nil, groups: [FeedGroupMetadata]? = nil, lastFullSync: Date? = nil) {
        self.name = name
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.groups = groups
        self.lastFullSync = lastFullSync
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case createdAt = "created_at"
        case updatedAt = "updated_at"
        case groups
        case lastFullSync = "last_full_sync"
    }
}

public struct FeedGroupMetadata: Codable {
    public var name: String?
    public var createdAt: Date?
    public var lastSync: Date?
    public var recordCount: Int?

    public init(name: String? = nil, createdAt: Date? = nil, lastSync: Date? = nil, recordCount: Int? = nil) {
        self.name = name
        self.createdAt = createdAt
        self.lastSync = lastSync
        self.recordCount = recordCount
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case createdAt = "created_at"
        case lastSync = "last_sync"
        case recordCount = "record_count"
    }
}

/// A record of occurance of an asynchronous event triggered either by system or by user activity
public struct EventResponse: Codable {
    public var generatedUUID: String?
    public var createdAt: Date?
    public var event: Event?

    public struct Event: Codable {
        public var source: Source?
        public var resource: Resource?
        public var type: String?
        public var category: String?
        public var level: String?
        public var message: String?
        public var details: [String: AnyJSON]?
        public var timestamp: Date?

        public struct Source: Codable {
            public var servicename: String?
            public var hostid: String?
            public var baseURL: String?
            public var requestID: String?

            public init(servicename: String? = nil, hostid: String? = nil, baseURL: String? = nil, requestID: String? = nil) {
                self.servicename = servicename
                self.hostid = hostid
                self.baseURL = baseURL
                self.requestID = requestID
            }

            private enum CodingKeys: String, CodingKey {
                case servicename
                case hostid
                case baseURL = "base_url"
                case requestID = "request_id"
            }
        }

        public struct Resource: Codable {
            public var userID: String?
            public var id: String?
            public var type: String?

            public init(userID: String? = nil, id: String? = nil, type: String? = nil) {
                self.userID = userID
                self.id = id
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case userID = "user_id"
                case id
                case type
            }
        }

        public init(source: Source? = nil, resource: Resource? = nil, type: String? = nil, category: String? = nil, level: String? = nil, message: String? = nil, details: [String: AnyJSON]? = nil, timestamp: Date? = nil) {
            self.source = source
            self.resource = resource
            self.type = type
            self.category = category
            self.level = level
            self.message = message
            self.details = details
            self.timestamp = timestamp
        }
    }

    public init(generatedUUID: String? = nil, createdAt: Date? = nil, event: Event? = nil) {
        self.generatedUUID = generatedUUID
        self.createdAt = createdAt
        self.event = event
    }

    private enum CodingKeys: String, CodingKey {
        case generatedUUID = "generated_uuid"
        case createdAt = "created_at"
        case event
    }
}

/// Response envelope for paginated listing of events
public struct EventsList: Codable {
    /// List of events
    public var results: [EventResponse]?
    /// Boolean flag, True indicates there are more events and False otherwise
    public var isNextPage: Bool?
    /// Number of events in this page
    public var itemCount: Int?
    /// Page number of this result set
    public var page: Int?

    public init(results: [EventResponse]? = nil, isNextPage: Bool? = nil, itemCount: Int? = nil, page: Int? = nil) {
        self.results = results
        self.isNextPage = isNextPage
        self.itemCount = itemCount
        self.page = page
    }

    private enum CodingKeys: String, CodingKey {
        case results
        case isNextPage = "next_page"
        case itemCount = "item_count"
        case page
    }
}

/// An account to create/add to the system. If already exists will return 400.
public struct AccountCreationRequest: Codable {
    /// The account name to use. This will identify the account and must be globally unique in the system.
    public var name: String
    /// An optional email to associate with the account for contact purposes
    public var email: String?

    public init(name: String, email: String? = nil) {
        self.name = name
        self.email = email
    }
}

/// Account information
public struct Account: Codable {
    /// The account identifier, not updatable after creation
    public var name: String
    /// The user type (admin vs user). If not specified in a POST request, 'user' is default
    public var type: `Type`?
    /// State of the account. Disabled accounts prevent member users from logging in, deleting accounts are disabled and pending deletion and will be removed once all owned resources are garbage collected by the system
    public var state: State?
    /// Optional email address associated with the account
    public var email: String?
    /// The timestamp when the account was created
    public var createdAt: Date?
    /// The timestamp of the last update to the account metadata itself (not users or creds)
    public var lastUpdated: Date?

    /// The user type (admin vs user). If not specified in a POST request, 'user' is default
    public enum `Type`: String, Codable, CaseIterable {
        case user
        case admin
        case service
    }

    /// State of the account. Disabled accounts prevent member users from logging in, deleting accounts are disabled and pending deletion and will be removed once all owned resources are garbage collected by the system
    public enum State: String, Codable, CaseIterable {
        case enabled
        case disabled
        case deleting
    }

    public init(name: String, type: `Type`? = nil, state: State? = nil, email: String? = nil, createdAt: Date? = nil, lastUpdated: Date? = nil) {
        self.name = name
        self.type = type
        self.state = state
        self.email = email
        self.createdAt = createdAt
        self.lastUpdated = lastUpdated
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case type
        case state
        case email
        case createdAt = "created_at"
        case lastUpdated = "last_updated"
    }
}

/// A summary of account status
public struct AccountStatus: Codable {
    /// The status of the account
    public var state: State?

    /// The status of the account
    public enum State: String, Codable, CaseIterable {
        case enabled
        case disabled
    }

    public init(state: State? = nil) {
        self.state = state
    }
}

/// A username for authenticating with one or more types of credentials. User type defines the expected credentials allowed for the user. Native users have passwords, External users have no credential internally. Internal users are service/system users for inter-service communication.
public struct User: Codable {
    /// The username to authenticate with
    public var username: String
    /// The user's type
    public var type: `Type`?
    /// If the user is external, this is the source that the user was initialized from. All other user types have this set to null
    public var source: String?
    /// The timestampt the user record was created
    public var createdAt: Date?
    /// The timestamp of the last update to this record
    public var lastUpdated: Date?

    /// The user's type
    public enum `Type`: String, Codable, CaseIterable {
        case native
        case `internal`
        case external
    }

    public init(username: String, type: `Type`? = nil, source: String? = nil, createdAt: Date? = nil, lastUpdated: Date? = nil) {
        self.username = username
        self.type = type
        self.source = source
        self.createdAt = createdAt
        self.lastUpdated = lastUpdated
    }

    private enum CodingKeys: String, CodingKey {
        case username
        case type
        case source
        case createdAt = "created_at"
        case lastUpdated = "last_updated"
    }
}

/// A payload for creating a new user, includes the username and password in a single request
public struct UserCreationRequest: Codable {
    /// The username to create
    public var username: String
    /// The initial password for the user, must be at least 6 characters, up to 128
    public var password: String

    public init(username: String, password: String) {
        self.username = username
        self.password = password
    }
}

/// A login credential mapped to a user identity. For password credentials, the username to present for Basic auth is the user's username from the user record
public struct AccessCredential: Codable {
    /// The type of credential
    public var type: `Type`
    /// The credential value (e.g. the password)
    public var value: String
    /// The timestamp of creation of the credential
    public var createdAt: String?

    /// The type of credential
    public enum `Type`: String, Codable, CaseIterable {
        case password
    }

    public init(type: `Type`, value: String, createdAt: String? = nil) {
        self.type = type
        self.value = value
        self.createdAt = createdAt
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case value
        case createdAt = "created_at"
    }
}

/// Version information for a service
public struct ServiceVersion: Codable {
    public var service: Service?
    /// Api Version string
    public var api: API?
    public var db: Db?

    public struct Service: Codable {
        /// Semantic Version string of the service implementation
        public var version: String?

        public init(version: String? = nil) {
            self.version = version
        }
    }

    /// Api Version string
    public struct API: Codable {
        /// Semantic version of the api
        public var version: String?

        public init(version: String? = nil) {
            self.version = version
        }
    }

    public struct Db: Codable {
        /// Semantic version of the db schema
        public var schemaVersion: String?

        public init(schemaVersion: String? = nil) {
            self.schemaVersion = schemaVersion
        }

        private enum CodingKeys: String, CodingKey {
            case schemaVersion = "schema_version"
        }
    }

    public init(service: Service? = nil, api: API? = nil, db: Db? = nil) {
        self.service = service
        self.api = api
        self.db = db
    }
}

/// A summarization of the available archives, a place to for long-term storage of audit, analysis, or other data to remove it from the system's working set but keep it available.
public struct ArchiveSummary: Codable {
    /// A summarization of the analysis archive, including size, counts, etc. This archive stores image analysis only, never the actual image content or layers.
    public var images: AnalysisArchiveSummary?
    /// Summary of the transition rule set
    public var rules: AnalysisArchiveRulesSummary?

    public init(images: AnalysisArchiveSummary? = nil, rules: AnalysisArchiveRulesSummary? = nil) {
        self.images = images
        self.rules = rules
    }
}

/// A summarization of the analysis archive, including size, counts, etc. This archive stores image analysis only, never the actual image content or layers.
public struct AnalysisArchiveSummary: Codable {
    /// The number of unique images (digests) in the archive
    public var totalImageCount: Int?
    /// The number of tag records (registry/repo:tag pull strings) in the archive. This may include repeated tags but will always have a unique tag->digest mapping per record.
    public var totalTagCount: Int?
    /// The total sum of all the bytes stored to the backing storage. Accounts for anchore-applied compression, but not compression by the underlying storage system.
    public var totalDataBytes: Int?
    /// The timestamp of the most recent archived image
    public var lastUpdated: Date?

    public init(totalImageCount: Int? = nil, totalTagCount: Int? = nil, totalDataBytes: Int? = nil, lastUpdated: Date? = nil) {
        self.totalImageCount = totalImageCount
        self.totalTagCount = totalTagCount
        self.totalDataBytes = totalDataBytes
        self.lastUpdated = lastUpdated
    }

    private enum CodingKeys: String, CodingKey {
        case totalImageCount = "total_image_count"
        case totalTagCount = "total_tag_count"
        case totalDataBytes = "total_data_bytes"
        case lastUpdated = "last_updated"
    }
}

/// Summary of the transition rule set
public struct AnalysisArchiveRulesSummary: Codable {
    /// The number of rules for this account
    public var count: Int?
    /// The newest last_updated timestamp from the set of rules
    public var lastUpdated: Date?

    public init(count: Int? = nil, lastUpdated: Date? = nil) {
        self.count = count
        self.lastUpdated = lastUpdated
    }

    private enum CodingKeys: String, CodingKey {
        case count
        case lastUpdated = "last_updated"
    }
}

/// The result of adding a single digest to the archive
public struct AnalysisArchiveAddResult: Codable {
    /// The image digest requested to be added
    public var digest: String?
    /// The status of the archive add operation. Typically either 'archived' or 'error'
    public var status: Status?
    /// Details on the status, e.g. the error message
    public var detail: String?

    /// The status of the archive add operation. Typically either 'archived' or 'error'
    public enum Status: String, Codable, CaseIterable {
        case archived
        case archiving
        case error
    }

    public init(digest: String? = nil, status: Status? = nil, detail: String? = nil) {
        self.digest = digest
        self.status = status
        self.detail = detail
    }
}

public struct ArchivedAnalysis: Codable {
    /// The image digest (digest of the manifest describing the image, per docker spec)
    public var imageDigest: String?
    /// The digest of a parent manifest (for manifest-list images)
    public var parentDigest: String?
    /// User provided annotations as key-value pairs
    public var annotations: [String: AnyJSON]?
    /// The archival status
    public var status: Status?
    /// List of tags associated with the image digest
    public var imageDetail: [TagEntry]?
    public var createdAt: Date?
    public var lastUpdated: Date?
    public var analyzedAt: Date?
    /// The size, in bytes, of the analysis archive file
    public var archiveSizeBytes: Int?

    /// The archival status
    public enum Status: String, Codable, CaseIterable {
        case archiving
        case archived
        case deleting
        case deleted
    }

    public init(imageDigest: String? = nil, parentDigest: String? = nil, annotations: [String: AnyJSON]? = nil, status: Status? = nil, imageDetail: [TagEntry]? = nil, createdAt: Date? = nil, lastUpdated: Date? = nil, analyzedAt: Date? = nil, archiveSizeBytes: Int? = nil) {
        self.imageDigest = imageDigest
        self.parentDigest = parentDigest
        self.annotations = annotations
        self.status = status
        self.imageDetail = imageDetail
        self.createdAt = createdAt
        self.lastUpdated = lastUpdated
        self.analyzedAt = analyzedAt
        self.archiveSizeBytes = archiveSizeBytes
    }

    private enum CodingKeys: String, CodingKey {
        case imageDigest
        case parentDigest
        case annotations
        case status
        case imageDetail = "image_detail"
        case createdAt = "created_at"
        case lastUpdated = "last_updated"
        case analyzedAt = "analyzed_at"
        case archiveSizeBytes = "archive_size_bytes"
    }
}

/// A rule for auto-archiving image analysis by time and/or tag-history
public struct AnalysisArchiveTransitionRule: Codable {
    /// A set of selection criteria to match an image by a tagged pullstring based on its components, with regex support in each field
    public var selector: ImageSelector?
    /// Unique identifier for archive rule
    public var ruleID: String?
    /// Number of images mapped to the tag that are newer
    public var tagVersionsNewer: Int?
    /// Matches if the analysis is strictly older than this number of days
    public var analysisAgeDays: Int?
    /// The type of transition to make. If "archive", then archive an image from the working set and remove it from the working set. If "delete", then match against archived images and delete from the archive if match.
    public var transition: Transition
    /// True if the rule applies to all accounts in the system. This is only available to admin users to update/modify, but all users with permission to list rules can see them
    public var isSystemGlobal: Bool?
    public var createdAt: Date?
    public var lastUpdated: Date?
    /// Which Images to exclude from auto-archiving logic
    public var exclude: AnalysisArchiveTransitionRuleExclude?
    /// This is the maximum number of image analyses an account can have. Can only be set on system_global rules
    public var maxImagesPerAccount: Int?

    /// The type of transition to make. If "archive", then archive an image from the working set and remove it from the working set. If "delete", then match against archived images and delete from the archive if match.
    public enum Transition: String, Codable, CaseIterable {
        case archive
        case delete
    }

    public init(selector: ImageSelector? = nil, ruleID: String? = nil, tagVersionsNewer: Int? = nil, analysisAgeDays: Int? = nil, transition: Transition, isSystemGlobal: Bool? = nil, createdAt: Date? = nil, lastUpdated: Date? = nil, exclude: AnalysisArchiveTransitionRuleExclude? = nil, maxImagesPerAccount: Int? = nil) {
        self.selector = selector
        self.ruleID = ruleID
        self.tagVersionsNewer = tagVersionsNewer
        self.analysisAgeDays = analysisAgeDays
        self.transition = transition
        self.isSystemGlobal = isSystemGlobal
        self.createdAt = createdAt
        self.lastUpdated = lastUpdated
        self.exclude = exclude
        self.maxImagesPerAccount = maxImagesPerAccount
    }

    private enum CodingKeys: String, CodingKey {
        case selector
        case ruleID = "rule_id"
        case tagVersionsNewer = "tag_versions_newer"
        case analysisAgeDays = "analysis_age_days"
        case transition
        case isSystemGlobal = "system_global"
        case createdAt = "created_at"
        case lastUpdated = "last_updated"
        case exclude
        case maxImagesPerAccount = "max_images_per_account"
    }
}

/// Which Images to exclude from auto-archiving logic
public struct AnalysisArchiveTransitionRuleExclude: Codable {
    /// A set of selection criteria to match an image by a tagged pullstring based on its components, with regex support in each field
    public var selector: ImageSelector?
    /// How long the image selected will be excluded from the archive transition
    public var expirationDays: Int?

    public init(selector: ImageSelector? = nil, expirationDays: Int? = nil) {
        self.selector = selector
        self.expirationDays = expirationDays
    }

    private enum CodingKeys: String, CodingKey {
        case selector
        case expirationDays = "expiration_days"
    }
}

/// A rule for auto-archiving image analysis by time and/or tag-history
public struct AnalysisArchiveTransitionHistory: Codable {
    /// The task that created & updated this entry
    public var transitionTaskID: String?
    public var ruleID: String?
    public var imageDigest: String?
    public var transition: Transition?
    public var createdAt: Date?
    public var lastUpdated: Date?

    public enum Transition: String, Codable, CaseIterable {
        case archive
        case delete
    }

    public init(transitionTaskID: String? = nil, ruleID: String? = nil, imageDigest: String? = nil, transition: Transition? = nil, createdAt: Date? = nil, lastUpdated: Date? = nil) {
        self.transitionTaskID = transitionTaskID
        self.ruleID = ruleID
        self.imageDigest = imageDigest
        self.transition = transition
        self.createdAt = createdAt
        self.lastUpdated = lastUpdated
    }

    private enum CodingKeys: String, CodingKey {
        case transitionTaskID = "transition_task_id"
        case ruleID = "rule_id"
        case imageDigest
        case transition
        case createdAt = "created_at"
        case lastUpdated = "last_updated"
    }
}

/// A set of selection criteria to match an image by a tagged pullstring based on its components, with regex support in each field
public struct ImageSelector: Codable {
    /// The registry section of a pull string. e.g. with "docker.io/anchore/anchore-engine:latest", this is "docker.io"
    public var registry: String?
    /// The repository section of a pull string. e.g. with "docker.io/anchore/anchore-engine:latest", this is "anchore/anchore-engine"
    public var repository: String?
    /// The tag-only section of a pull string. e.g. with "docker.io/anchore/anchore-engine:latest", this is "latest"
    public var tag: String?

    public init(registry: String? = nil, repository: String? = nil, tag: String? = nil) {
        self.registry = registry
        self.repository = repository
        self.tag = tag
    }
}

/// The result of a sync of a single feed
public struct FeedSyncResult: Codable {
    /// The name of the feed synced
    public var feed: String?
    /// The result of the sync operations, either co
    public var status: Status?
    /// The duratin, in seconds, of the sync of the feed, the sum of all the group syncs
    public var totalTimeSeconds: Double?
    /// Array of group sync results
    public var groups: [GroupSyncResult]?

    /// The result of the sync operations, either co
    public enum Status: String, Codable, CaseIterable {
        case success
        case failure
    }

    public init(feed: String? = nil, status: Status? = nil, totalTimeSeconds: Double? = nil, groups: [GroupSyncResult]? = nil) {
        self.feed = feed
        self.status = status
        self.totalTimeSeconds = totalTimeSeconds
        self.groups = groups
    }

    private enum CodingKeys: String, CodingKey {
        case feed
        case status
        case totalTimeSeconds = "total_time_seconds"
        case groups
    }
}

public struct GroupSyncResult: Codable {
    /// The name of the group
    public var group: String?
    public var status: Status?
    /// The number of images updated by the this group sync, across all accounts. This is typically only non-zero for vulnerability feeds which update images' vulnerability results during the sync.
    public var updatedImageCount: Int?
    /// The number of feed data records synced down as either updates or new records
    public var updatedRecordCount: Int?
    /// The duration of the group sync in seconds
    public var totalTimeSeconds: Double?

    public enum Status: String, Codable, CaseIterable {
        case success
        case failure
    }

    public init(group: String? = nil, status: Status? = nil, updatedImageCount: Int? = nil, updatedRecordCount: Int? = nil, totalTimeSeconds: Double? = nil) {
        self.group = group
        self.status = status
        self.updatedImageCount = updatedImageCount
        self.updatedRecordCount = updatedRecordCount
        self.totalTimeSeconds = totalTimeSeconds
    }

    private enum CodingKeys: String, CodingKey {
        case group
        case status
        case updatedImageCount = "updated_image_count"
        case updatedRecordCount = "updated_record_count"
        case totalTimeSeconds = "total_time_seconds"
    }
}

public struct TokenResponse: Codable {
    /// The token content
    public var token: String

    public init(token: String) {
        self.token = token
    }
}

/// The retrieved file entry including content (b64 encoded)
public struct RetrievedFile: Codable {
    public var path: String?
    public var b64Content: String?

    public init(path: String? = nil, b64Content: String? = nil) {
        self.path = path
        self.b64Content = b64Content
    }

    private enum CodingKeys: String, CodingKey {
        case path
        case b64Content = "b64_content"
    }
}

/// The retrieved file entry including content (b64 encoded)
public struct SecretSearchResult: Codable {
    public var path: String?
    public var matches: [RegexContentMatch]?

    public init(path: String? = nil, matches: [RegexContentMatch]? = nil) {
        self.path = path
        self.matches = matches
    }
}

/// The retrieved file entry including content (b64 encoded)
public struct FileContentSearchResult: Codable {
    public var path: String?
    public var matches: [RegexContentMatch]?

    public init(path: String? = nil, matches: [RegexContentMatch]? = nil) {
        self.path = path
        self.matches = matches
    }
}

/// Match of a named regex on a file
public struct RegexContentMatch: Codable {
    /// The name associated with the regular expression
    public var name: String?
    /// The regular expression used for the match
    public var regex: String?
    /// A list of line numbers in the file that matched the regex
    public var lines: [Int]?

    public init(name: String? = nil, regex: String? = nil, lines: [Int]? = nil) {
        self.name = name
        self.regex = regex
        self.lines = lines
    }
}

/// A collection of event subcategories
public struct EventCategory: Codable {
    public var category: String?
    public var description: String?
    public var subcategories: [EventSubcategory]?

    public init(category: String? = nil, description: String? = nil, subcategories: [EventSubcategory]? = nil) {
        self.category = category
        self.description = description
        self.subcategories = subcategories
    }
}

/// A collection of events related to each other
public struct EventSubcategory: Codable {
    public var name: String?
    public var description: String?
    public var events: [EventDescription]?

    public init(name: String? = nil, description: String? = nil, events: [EventDescription]? = nil) {
        self.name = name
        self.description = description
        self.events = events
    }
}

/// A description of an event type
public struct EventDescription: Codable {
    /// The event type. The last component of the fully-qualified event_type (category.subcategory.event)
    public var name: String?
    /// The fully qualified event type as would be seen in the event payload
    public var type: String?
    /// The message associated with the event type
    public var message: String?
    /// The type of resource this event is generated from
    public var resourceType: String?

    public init(name: String? = nil, type: String? = nil, message: String? = nil, resourceType: String? = nil) {
        self.name = name
        self.type = type
        self.message = message
        self.resourceType = resourceType
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case type
        case message
        case resourceType = "resource_type"
    }
}

/// Base object for Notifications (every notification has this basic structure)
public struct NotificationBase: Codable {
    public var queueID: String?
    public var userID: String?
    public var dataID: String?
    public var createdAt: Int?
    public var lastUpdated: Int?
    public var recordStateKey: String?
    public var recordStateVal: String?
    public var tries: Int?
    public var maxTries: Int?

    public init(queueID: String? = nil, userID: String? = nil, dataID: String? = nil, createdAt: Int? = nil, lastUpdated: Int? = nil, recordStateKey: String? = nil, recordStateVal: String? = nil, tries: Int? = nil, maxTries: Int? = nil) {
        self.queueID = queueID
        self.userID = userID
        self.dataID = dataID
        self.createdAt = createdAt
        self.lastUpdated = lastUpdated
        self.recordStateKey = recordStateKey
        self.recordStateVal = recordStateVal
        self.tries = tries
        self.maxTries = maxTries
    }

    private enum CodingKeys: String, CodingKey {
        case queueID = "queueId"
        case userID = "userId"
        case dataID = "dataId"
        case createdAt = "created_at"
        case lastUpdated = "last_updated"
        case recordStateKey = "record_state_key"
        case recordStateVal = "record_state_val"
        case tries
        case maxTries = "max_tries"
    }
}

public struct PolicyEvalNotification: Codable {
    /// Base object for Notifications (every notification has this basic structure)
    public var notificationBase: NotificationBase
    public var data: PolicyEvalNotificationData?

    public init(notificationBase: NotificationBase, data: PolicyEvalNotificationData? = nil) {
        self.notificationBase = notificationBase
        self.data = data
    }

    public init(from decoder: Decoder) throws {
        self.notificationBase = try NotificationBase(from: decoder)
        self.data = try PolicyEvalNotificationData(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(notificationBase, forKey: "notificationBase")
        try values.encodeIfPresent(data, forKey: "data")
    }
}

public struct TagUpdateNotification: Codable {
    /// Base object for Notifications (every notification has this basic structure)
    public var notificationBase: NotificationBase
    public var data: TagUpdateNotificationData?

    public init(notificationBase: NotificationBase, data: TagUpdateNotificationData? = nil) {
        self.notificationBase = notificationBase
        self.data = data
    }

    public init(from decoder: Decoder) throws {
        self.notificationBase = try NotificationBase(from: decoder)
        self.data = try TagUpdateNotificationData(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(notificationBase, forKey: "notificationBase")
        try values.encodeIfPresent(data, forKey: "data")
    }
}

public struct VulnUpdateNotification: Codable {
    /// Base object for Notifications (every notification has this basic structure)
    public var notificationBase: NotificationBase
    public var data: VulnUpdateNotificationData?

    public init(notificationBase: NotificationBase, data: VulnUpdateNotificationData? = nil) {
        self.notificationBase = notificationBase
        self.data = data
    }

    public init(from decoder: Decoder) throws {
        self.notificationBase = try NotificationBase(from: decoder)
        self.data = try VulnUpdateNotificationData(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(notificationBase, forKey: "notificationBase")
        try values.encodeIfPresent(data, forKey: "data")
    }
}

public struct AnalysisUpdateNotification: Codable {
    /// Base object for Notifications (every notification has this basic structure)
    public var notificationBase: NotificationBase
    public var data: AnalysisUpdateNotificationData?

    public init(notificationBase: NotificationBase, data: AnalysisUpdateNotificationData? = nil) {
        self.notificationBase = notificationBase
        self.data = data
    }

    public init(from decoder: Decoder) throws {
        self.notificationBase = try NotificationBase(from: decoder)
        self.data = try AnalysisUpdateNotificationData(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(notificationBase, forKey: "notificationBase")
        try values.encodeIfPresent(data, forKey: "data")
    }
}

/// Every notification has a payload, which follows this basic structure
public struct BaseNotificationData: Codable {
    public var notificationUser: String?
    public var notificationUserEmail: String?
    public var notificationType: String?

    public init(notificationUser: String? = nil, notificationUserEmail: String? = nil, notificationType: String? = nil) {
        self.notificationUser = notificationUser
        self.notificationUserEmail = notificationUserEmail
        self.notificationType = notificationType
    }

    private enum CodingKeys: String, CodingKey {
        case notificationUser = "notification_user"
        case notificationUserEmail = "notification_user_email"
        case notificationType = "notification_type"
    }
}

public struct PolicyEvalNotificationData: Codable {
    /// Every notification has a payload, which follows this basic structure
    public var baseNotificationData: BaseNotificationData
    public var notificationPayload: PolicyEvalNotificationPayload?

    public init(baseNotificationData: BaseNotificationData, notificationPayload: PolicyEvalNotificationPayload? = nil) {
        self.baseNotificationData = baseNotificationData
        self.notificationPayload = notificationPayload
    }

    public init(from decoder: Decoder) throws {
        self.baseNotificationData = try BaseNotificationData(from: decoder)
        self.notificationPayload = try PolicyEvalNotificationPayload(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(baseNotificationData, forKey: "baseNotificationData")
        try values.encodeIfPresent(notificationPayload, forKey: "notification_payload")
    }
}

public struct TagUpdateNotificationData: Codable {
    /// Every notification has a payload, which follows this basic structure
    public var baseNotificationData: BaseNotificationData
    public var notificationPayload: TagUpdateNotificationPayload?

    public init(baseNotificationData: BaseNotificationData, notificationPayload: TagUpdateNotificationPayload? = nil) {
        self.baseNotificationData = baseNotificationData
        self.notificationPayload = notificationPayload
    }

    public init(from decoder: Decoder) throws {
        self.baseNotificationData = try BaseNotificationData(from: decoder)
        self.notificationPayload = try TagUpdateNotificationPayload(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(baseNotificationData, forKey: "baseNotificationData")
        try values.encodeIfPresent(notificationPayload, forKey: "notification_payload")
    }
}

public struct VulnUpdateNotificationData: Codable {
    /// Every notification has a payload, which follows this basic structure
    public var baseNotificationData: BaseNotificationData
    public var notificationPayload: VulnUpdateNotificationPayload?

    public init(baseNotificationData: BaseNotificationData, notificationPayload: VulnUpdateNotificationPayload? = nil) {
        self.baseNotificationData = baseNotificationData
        self.notificationPayload = notificationPayload
    }

    public init(from decoder: Decoder) throws {
        self.baseNotificationData = try BaseNotificationData(from: decoder)
        self.notificationPayload = try VulnUpdateNotificationPayload(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(baseNotificationData, forKey: "baseNotificationData")
        try values.encodeIfPresent(notificationPayload, forKey: "notification_payload")
    }
}

public struct AnalysisUpdateNotificationData: Codable {
    /// Every notification has a payload, which follows this basic structure
    public var baseNotificationData: BaseNotificationData
    public var notificationPayload: AnalysisUpdateNotificationPayload?

    public init(baseNotificationData: BaseNotificationData, notificationPayload: AnalysisUpdateNotificationPayload? = nil) {
        self.baseNotificationData = baseNotificationData
        self.notificationPayload = notificationPayload
    }

    public init(from decoder: Decoder) throws {
        self.baseNotificationData = try BaseNotificationData(from: decoder)
        self.notificationPayload = try AnalysisUpdateNotificationPayload(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(baseNotificationData, forKey: "baseNotificationData")
        try values.encodeIfPresent(notificationPayload, forKey: "notification_payload")
    }
}

/// Parent class for Notification Payloads
public struct GenericNotificationPayload: Codable {
    public var userID: String?
    public var subscriptionKey: String?
    public var subscriptionType: String?
    public var notificationID: String?

    public init(userID: String? = nil, subscriptionKey: String? = nil, subscriptionType: String? = nil, notificationID: String? = nil) {
        self.userID = userID
        self.subscriptionKey = subscriptionKey
        self.subscriptionType = subscriptionType
        self.notificationID = notificationID
    }

    private enum CodingKeys: String, CodingKey {
        case userID = "userId"
        case subscriptionKey = "subscription_key"
        case subscriptionType = "subscription_type"
        case notificationID = "notificationId"
    }
}

public struct PolicyEvalNotificationPayload: Codable {
    /// Parent class for Notification Payloads
    public var genericNotificationPayload: GenericNotificationPayload
    /// The Current Policy Evaluation result
    public var currEval: [String: AnyJSON]?
    /// The Previous Policy Evaluation result
    public var lastEval: [String: AnyJSON]?
    /// List of Corresponding Image Annotations
    public var annotations: [String: AnyJSON]?

    public init(genericNotificationPayload: GenericNotificationPayload, currEval: [String: AnyJSON]? = nil, lastEval: [String: AnyJSON]? = nil, annotations: [String: AnyJSON]? = nil) {
        self.genericNotificationPayload = genericNotificationPayload
        self.currEval = currEval
        self.lastEval = lastEval
        self.annotations = annotations
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.genericNotificationPayload = try GenericNotificationPayload(from: decoder)
        self.currEval = try values.decodeIfPresent([String: AnyJSON].self, forKey: "curr_eval")
        self.lastEval = try values.decodeIfPresent([String: AnyJSON].self, forKey: "last_eval")
        self.annotations = try values.decodeIfPresent([String: AnyJSON].self, forKey: "annotations")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(genericNotificationPayload, forKey: "genericNotificationPayload")
        try values.encodeIfPresent(currEval, forKey: "curr_eval")
        try values.encodeIfPresent(lastEval, forKey: "last_eval")
        try values.encodeIfPresent(annotations, forKey: "annotations")
    }
}

public struct TagUpdateNotificationPayload: Codable {
    /// Parent class for Notification Payloads
    public var genericNotificationPayload: GenericNotificationPayload
    /// A list containing the current image digest
    public var currEval: [[String: AnyJSON]]?
    /// A list containing the previous image digests
    public var lastEval: [[String: AnyJSON]]?
    /// List of Corresponding Image Annotations
    public var annotations: [String: AnyJSON]?

    public init(genericNotificationPayload: GenericNotificationPayload, currEval: [[String: AnyJSON]]? = nil, lastEval: [[String: AnyJSON]]? = nil, annotations: [String: AnyJSON]? = nil) {
        self.genericNotificationPayload = genericNotificationPayload
        self.currEval = currEval
        self.lastEval = lastEval
        self.annotations = annotations
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.genericNotificationPayload = try GenericNotificationPayload(from: decoder)
        self.currEval = try values.decodeIfPresent([[String: AnyJSON]].self, forKey: "curr_eval")
        self.lastEval = try values.decodeIfPresent([[String: AnyJSON]].self, forKey: "last_eval")
        self.annotations = try values.decodeIfPresent([String: AnyJSON].self, forKey: "annotations")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(genericNotificationPayload, forKey: "genericNotificationPayload")
        try values.encodeIfPresent(currEval, forKey: "curr_eval")
        try values.encodeIfPresent(lastEval, forKey: "last_eval")
        try values.encodeIfPresent(annotations, forKey: "annotations")
    }
}

public struct VulnUpdateNotificationPayload: Codable {
    /// Parent class for Notification Payloads
    public var genericNotificationPayload: GenericNotificationPayload
    /// The results of the comparing two vulnerability records during an update
    public var diffVulnerabilityResult: VulnDiffResult?
    public var imageDigest: String?
    /// List of Corresponding Image Annotations
    public var annotations: [String: AnyJSON]?

    public init(genericNotificationPayload: GenericNotificationPayload, diffVulnerabilityResult: VulnDiffResult? = nil, imageDigest: String? = nil, annotations: [String: AnyJSON]? = nil) {
        self.genericNotificationPayload = genericNotificationPayload
        self.diffVulnerabilityResult = diffVulnerabilityResult
        self.imageDigest = imageDigest
        self.annotations = annotations
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.genericNotificationPayload = try GenericNotificationPayload(from: decoder)
        self.diffVulnerabilityResult = try VulnDiffResult(from: decoder)
        self.imageDigest = try values.decodeIfPresent(String.self, forKey: "imageDigest")
        self.annotations = try values.decodeIfPresent([String: AnyJSON].self, forKey: "annotations")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(genericNotificationPayload, forKey: "genericNotificationPayload")
        try values.encodeIfPresent(diffVulnerabilityResult, forKey: "diff_vulnerability_result")
        try values.encodeIfPresent(imageDigest, forKey: "imageDigest")
        try values.encodeIfPresent(annotations, forKey: "annotations")
    }
}

public struct AnalysisUpdateNotificationPayload: Codable {
    /// Parent class for Notification Payloads
    public var genericNotificationPayload: GenericNotificationPayload
    /// Evaluation Results for an entity (current or last)
    public var currEval: AnalysisUpdateEval?
    /// Evaluation Results for an entity (current or last)
    public var lastEval: AnalysisUpdateEval?
    /// List of Corresponding Image Annotations
    public var annotations: [String: AnyJSON]?

    public init(genericNotificationPayload: GenericNotificationPayload, currEval: AnalysisUpdateEval? = nil, lastEval: AnalysisUpdateEval? = nil, annotations: [String: AnyJSON]? = nil) {
        self.genericNotificationPayload = genericNotificationPayload
        self.currEval = currEval
        self.lastEval = lastEval
        self.annotations = annotations
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.genericNotificationPayload = try GenericNotificationPayload(from: decoder)
        self.currEval = try AnalysisUpdateEval(from: decoder)
        self.lastEval = try AnalysisUpdateEval(from: decoder)
        self.annotations = try values.decodeIfPresent([String: AnyJSON].self, forKey: "annotations")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(genericNotificationPayload, forKey: "genericNotificationPayload")
        try values.encodeIfPresent(currEval, forKey: "curr_eval")
        try values.encodeIfPresent(lastEval, forKey: "last_eval")
        try values.encodeIfPresent(annotations, forKey: "annotations")
    }
}

/// The results of the comparing two vulnerability records during an update
public struct VulnDiffResult: Codable {
    public var added: [[String: AnyJSON]]?
    public var updated: [[String: AnyJSON]]?
    public var removed: [[String: AnyJSON]]?

    public init(added: [[String: AnyJSON]]? = nil, updated: [[String: AnyJSON]]? = nil, removed: [[String: AnyJSON]]? = nil) {
        self.added = added
        self.updated = updated
        self.removed = removed
    }
}

/// Evaluation Results for an entity (current or last)
public struct AnalysisUpdateEval: Codable {
    public var analysisStatus: String?
    public var annotations: [String: AnyJSON]?
    public var imageDigest: String?

    public init(analysisStatus: String? = nil, annotations: [String: AnyJSON]? = nil, imageDigest: String? = nil) {
        self.analysisStatus = analysisStatus
        self.annotations = annotations
        self.imageDigest = imageDigest
    }

    private enum CodingKeys: String, CodingKey {
        case analysisStatus = "analysis_status"
        case annotations
        case imageDigest = "image_digest"
    }
}

/// An import record, creating a unique identifier for referencing the operation as well as its state
public struct ImageImportOperation: Codable {
    public var uuid: String?
    public var status: Status?
    public var expiresAt: Date?
    public var createdAt: Date?

    public enum Status: String, Codable, CaseIterable {
        case pending
        case queued
        case processing
        case complete
        case failed
        case expired
    }

    public init(uuid: String? = nil, status: Status? = nil, expiresAt: Date? = nil, createdAt: Date? = nil) {
        self.uuid = uuid
        self.status = status
        self.expiresAt = expiresAt
        self.createdAt = createdAt
    }

    private enum CodingKeys: String, CodingKey {
        case uuid
        case status
        case expiresAt = "expires_at"
        case createdAt = "created_at"
    }
}

public struct ImageImportContentResponse: Codable {
    public var digest: String?
    public var createdAt: Date?

    public init(digest: String? = nil, createdAt: Date? = nil) {
        self.digest = digest
        self.createdAt = createdAt
    }

    private enum CodingKeys: String, CodingKey {
        case digest
        case createdAt = "created_at"
    }
}

public struct ImageImportManifest: Codable {
    /// Digest of content to use in the final import
    public var contents: ImportContentDigests
    public var tags: [String]
    public var digest: String
    /// The digest of the images's manifest-list parent if it was accessed from a multi-arch tag where the tag pointed to a manifest-list. This allows preservation of that relationship in the data
    public var parentDigest: String?
    /// An "imageId" as used by Docker if available
    public var localImageID: String?
    public var operationUUID: String

    public init(contents: ImportContentDigests, tags: [String], digest: String, parentDigest: String? = nil, localImageID: String? = nil, operationUUID: String) {
        self.contents = contents
        self.tags = tags
        self.digest = digest
        self.parentDigest = parentDigest
        self.localImageID = localImageID
        self.operationUUID = operationUUID
    }

    private enum CodingKeys: String, CodingKey {
        case contents
        case tags
        case digest
        case parentDigest = "parent_digest"
        case localImageID = "local_image_id"
        case operationUUID = "operation_uuid"
    }
}

/// Digest of content to use in the final import
public struct ImportContentDigests: Codable {
    /// Digest to use for the packages content
    public var packages: String
    /// Digest for reference content for image config
    public var imageConfig: String
    /// Digest to reference content for the image manifest
    public var manifest: String
    /// Digest for reference content for parent manifest
    public var parentManifest: String?
    /// Digest for reference content for dockerfile
    public var dockerfile: String?

    public init(packages: String, imageConfig: String, manifest: String, parentManifest: String? = nil, dockerfile: String? = nil) {
        self.packages = packages
        self.imageConfig = imageConfig
        self.manifest = manifest
        self.parentManifest = parentManifest
        self.dockerfile = dockerfile
    }

    private enum CodingKeys: String, CodingKey {
        case packages
        case imageConfig = "image_config"
        case manifest
        case parentManifest = "parent_manifest"
        case dockerfile
    }
}

public struct ImagePackageManifest: Codable {
    public var artifacts: [ImportPackage]
    public var source: ImportSource
    public var distro: ImportDistribution
    public var descriptor: ImportDescriptor?
    public var schema: ImportSchema?
    public var artifactRelationships: [ImportPackageRelationship]?

    public init(artifacts: [ImportPackage], source: ImportSource, distro: ImportDistribution, descriptor: ImportDescriptor? = nil, schema: ImportSchema? = nil, artifactRelationships: [ImportPackageRelationship]? = nil) {
        self.artifacts = artifacts
        self.source = source
        self.distro = distro
        self.descriptor = descriptor
        self.schema = schema
        self.artifactRelationships = artifactRelationships
    }
}

public struct ImportDescriptor: Codable {
    public var name: String
    public var version: String

    public init(name: String, version: String) {
        self.name = name
        self.version = version
    }
}

public struct ImportDistribution: Codable {
    public var name: String
    public var version: String
    public var idLike: String

    public init(name: String, version: String, idLike: String) {
        self.name = name
        self.version = version
        self.idLike = idLike
    }
}

public struct ImportPackageLocation: Codable {
    public var path: String
    public var layerID: String?

    public init(path: String, layerID: String? = nil) {
        self.path = path
        self.layerID = layerID
    }
}

public struct ImportPackage: Codable {
    public var id: String?
    public var name: String
    public var version: String
    public var type: String
    public var foundBy: String?
    public var locations: [ImportPackageLocation]
    public var licenses: [String]
    public var language: String
    public var cpes: [String]
    public var purl: String?
    public var metadataType: String
    public var metadata: [String: AnyJSON]?

    public init(id: String? = nil, name: String, version: String, type: String, foundBy: String? = nil, locations: [ImportPackageLocation], licenses: [String], language: String, cpes: [String], purl: String? = nil, metadataType: String, metadata: [String: AnyJSON]? = nil) {
        self.id = id
        self.name = name
        self.version = version
        self.type = type
        self.foundBy = foundBy
        self.locations = locations
        self.licenses = licenses
        self.language = language
        self.cpes = cpes
        self.purl = purl
        self.metadataType = metadataType
        self.metadata = metadata
    }
}

public struct ImportSchema: Codable {
    public var version: String
    public var url: String

    public init(version: String, url: String) {
        self.version = version
        self.url = url
    }
}

public struct ImportSource: Codable {
    public var type: String
    public var target: [String: AnyJSON]

    public init(type: String, target: [String: AnyJSON]) {
        self.type = type
        self.target = target
    }
}

public struct ImportPackageRelationship: Codable {
    public var parent: String
    public var child: String
    public var type: String
    public var metadata: [String: AnyJSON]?

    public init(parent: String, child: String, type: String, metadata: [String: AnyJSON]? = nil) {
        self.parent = parent
        self.child = child
        self.type = type
        self.metadata = metadata
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
