// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var root: Root {
        Root(path: "/")
    }

    public struct Root {
        /// Path: `/`
        public let path: String

        /// Simple status check
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths {
    public static var health: Health {
        Health(path: "/health")
    }

    public struct Health {
        /// Path: `/health`
        public let path: String

        /// Health check, returns 200 and no body if service is running
        public var get: Request<Void> {
            .get(path)
        }
    }
}

extension Paths {
    public static var version: Version {
        Version(path: "/version")
    }

    public struct Version {
        /// Path: `/version`
        public let path: String

        /// Returns the version object for the service, including db schema version info
        public var get: Request<AnchoreAPI.ServiceVersion> {
            .get(path)
        }
    }
}

extension Paths {
    public static var policies: Policies {
        Policies(path: "/policies")
    }

    public struct Policies {
        /// Path: `/policies`
        public let path: String

        /// List policies
        ///
        /// List all saved policy bundles
        public func get(isDetail: Bool? = nil) -> Request<[AnchoreAPI.PolicyBundleRecord]> {
            .get(path, query: makeGetQuery(isDetail))
        }

        private func makeGetQuery(_ isDetail: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isDetail, forKey: "detail")
            return encoder.items
        }

        /// Add a new policy
        ///
        /// Adds a new policy bundle to the system
        public func post(_ body: AnchoreAPI.PolicyBundle) -> Request<AnchoreAPI.PolicyBundleRecord> {
            .post(path, body: body)
        }
    }
}

extension Paths.Policies {
    public func policyID(_ policyID: String) -> WithPolicyID {
        WithPolicyID(path: "\(path)/\(policyID)")
    }

    public struct WithPolicyID {
        /// Path: `/policies/{policyId}`
        public let path: String

        /// Get specific policy
        ///
        /// Get the policy bundle content
        public func get(isDetail: Bool? = nil) -> Request<[AnchoreAPI.PolicyBundleRecord]> {
            .get(path, query: makeGetQuery(isDetail))
        }

        private func makeGetQuery(_ isDetail: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isDetail, forKey: "detail")
            return encoder.items
        }

        /// Update policy
        ///
        /// Update/replace and existing policy
        public func put(isActive: Bool? = nil, _ body: AnchoreAPI.PolicyBundleRecord) -> Request<[AnchoreAPI.PolicyBundleRecord]> {
            .put(path, query: makePutQuery(isActive), body: body)
        }

        private func makePutQuery(_ isActive: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isActive, forKey: "active")
            return encoder.items
        }

        /// Delete policy
        ///
        /// Delete the specified policy
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var subscriptions: Subscriptions {
        Subscriptions(path: "/subscriptions")
    }

    public struct Subscriptions {
        /// Path: `/subscriptions`
        public let path: String

        /// List all subscriptions
        public func get(subscriptionKey: String? = nil, subscriptionType: String? = nil) -> Request<[AnchoreAPI.Subscription]> {
            .get(path, query: makeGetQuery(subscriptionKey, subscriptionType))
        }

        private func makeGetQuery(_ subscriptionKey: String?, _ subscriptionType: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(subscriptionKey, forKey: "subscription_key")
            encoder.encode(subscriptionType, forKey: "subscription_type")
            return encoder.items
        }

        /// Add a subscription of a specific type
        ///
        /// Create a new subscription to watch a tag and get notifications of changes
        public func post(_ body: AnchoreAPI.SubscriptionRequest) -> Request<[AnchoreAPI.Subscription]> {
            .post(path, body: body)
        }
    }
}

extension Paths.Subscriptions {
    public func subscriptionID(_ subscriptionID: String) -> WithSubscriptionID {
        WithSubscriptionID(path: "\(path)/\(subscriptionID)")
    }

    public struct WithSubscriptionID {
        /// Path: `/subscriptions/{subscriptionId}`
        public let path: String

        /// Get a specific subscription set
        public var get: Request<[AnchoreAPI.Subscription]> {
            .get(path)
        }

        /// Update an existing and specific subscription
        public func put(_ body: AnchoreAPI.SubscriptionUpdate) -> Request<[AnchoreAPI.Subscription]> {
            .put(path, body: body)
        }

        /// Delete subscriptions of a specific type
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var summaries: Summaries {
        Summaries(path: "/summaries")
    }

    public struct Summaries {
        /// Path: `/summaries`
        public let path: String
    }
}

extension Paths.Summaries {
    public var imagetags: Imagetags {
        Imagetags(path: path + "/imagetags")
    }

    public struct Imagetags {
        /// Path: `/summaries/imagetags`
        public let path: String

        /// List all visible image digests and tags
        ///
        /// List all image tags visible to the user
        public func get(imageStatus: [ImageStatus]? = nil) -> Request<[AnchoreAPI.AnchoreImageTagSummary]> {
            .get(path, query: makeGetQuery(imageStatus))
        }

        private func makeGetQuery(_ imageStatus: [ImageStatus]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(imageStatus, forKey: "image_status", explode: false)
            return encoder.items
        }

        public enum ImageStatus: String, Codable, CaseIterable {
            case all
            case active
            case deleting
        }
    }
}

extension Paths {
    public static var images: Images {
        Images(path: "/images")
    }

    public struct Images {
        /// Path: `/images`
        public let path: String

        /// List all visible images
        ///
        /// List all images visible to the user
        public func get(parameters: GetParameters? = nil) -> Request<[AnchoreAPI.AnchoreImage]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isHistory: Bool?
            public var fulltag: String?
            public var imageStatus: ImageStatus?
            public var analysisStatus: AnalysisStatus?

            public enum ImageStatus: String, Codable, CaseIterable {
                case all
                case active
                case deleting
            }

            public enum AnalysisStatus: String, Codable, CaseIterable {
                case notAnalyzed = "not_analyzed"
                case analyzed
                case analyzing
                case analysisFailed = "analysis_failed"
            }

            public init(isHistory: Bool? = nil, fulltag: String? = nil, imageStatus: ImageStatus? = nil, analysisStatus: AnalysisStatus? = nil) {
                self.isHistory = isHistory
                self.fulltag = fulltag
                self.imageStatus = imageStatus
                self.analysisStatus = analysisStatus
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isHistory, forKey: "history")
                encoder.encode(fulltag, forKey: "fulltag")
                encoder.encode(imageStatus, forKey: "image_status")
                encoder.encode(analysisStatus, forKey: "analysis_status")
                return encoder.items
            }
        }

        /// Submit a new image for analysis by the engine
        ///
        /// Creates a new analysis task that is executed asynchronously
        public func post(isForce: Bool? = nil, isAutosubscribe: Bool? = nil, _ body: AnchoreAPI.ImageAnalysisRequest) -> Request<[AnchoreAPI.AnchoreImage]> {
            .post(path, query: makePostQuery(isForce, isAutosubscribe), body: body)
        }

        private func makePostQuery(_ isForce: Bool?, _ isAutosubscribe: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isForce, forKey: "force")
            encoder.encode(isAutosubscribe, forKey: "autosubscribe")
            return encoder.items
        }

        /// Bulk mark images for deletion
        ///
        /// Delete analysis for image digests in the list asynchronously
        public func delete(imageDigests: [String], isForce: Bool? = nil) -> Request<[AnchoreAPI.DeleteImageResponse]> {
            .delete(path, query: makeDeleteQuery(imageDigests, isForce))
        }

        private func makeDeleteQuery(_ imageDigests: [String], _ isForce: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(imageDigests, forKey: "imageDigests", explode: false)
            encoder.encode(isForce, forKey: "force")
            return encoder.items
        }
    }
}

extension Paths {
    public static var `import`: Import {
        Import(path: "/import")
    }

    public struct Import {
        /// Path: `/import`
        public let path: String
    }
}

extension Paths.Import {
    public var images: Images {
        Images(path: path + "/images")
    }

    public struct Images {
        /// Path: `/import/images`
        public let path: String

        /// Import an anchore image tar.gz archive file. This is a deprecated API replaced by the "/imports/images" route
        public func post(_ body: Data) -> Request<[AnchoreAPI.AnchoreImage]> {
            .post(path, body: body)
        }
    }
}

extension Paths.Images {
    public func imageDigest(_ imageDigest: String) -> WithImageDigest {
        WithImageDigest(path: "\(path)/\(imageDigest)")
    }

    public struct WithImageDigest {
        /// Path: `/images/{imageDigest}`
        public let path: String

        /// Get image metadata
        public var get: Request<[AnchoreAPI.AnchoreImage]> {
            .get(path)
        }

        /// Delete an image analysis
        public func delete(isForce: Bool? = nil) -> Request<AnchoreAPI.DeleteImageResponse> {
            .delete(path, query: makeDeleteQuery(isForce))
        }

        private func makeDeleteQuery(_ isForce: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isForce, forKey: "force")
            return encoder.items
        }
    }
}

extension Paths.Images {
    public var byID: ByID {
        ByID(path: path + "/by_id")
    }

    public struct ByID {
        /// Path: `/images/by_id`
        public let path: String
    }
}

extension Paths.Images.ByID {
    public func imageID(_ imageID: String) -> WithImageID {
        WithImageID(path: "\(path)/\(imageID)")
    }

    public struct WithImageID {
        /// Path: `/images/by_id/{imageId}`
        public let path: String

        /// Lookup image by docker imageId
        public var get: Request<[AnchoreAPI.AnchoreImage]> {
            .get(path)
        }

        /// Delete image by docker imageId
        public func delete(isForce: Bool? = nil) -> Request<AnchoreAPI.DeleteImageResponse> {
            .delete(path, query: makeDeleteQuery(isForce))
        }

        private func makeDeleteQuery(_ isForce: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isForce, forKey: "force")
            return encoder.items
        }
    }
}

extension Paths.Images.WithImageDigest {
    public var check: Check {
        Check(path: path + "/check")
    }

    public struct Check {
        /// Path: `/images/{imageDigest}/check`
        public let path: String

        /// Check policy evaluation status for image
        ///
        /// Get the policy evaluation for the given image
        public func get(parameters: GetParameters) -> Request<[[String: AnyJSON]]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var policyID: String?
            public var tag: String
            public var isDetail: Bool?
            public var isHistory: Bool?
            public var isInteractive: Bool?

            public init(policyID: String? = nil, tag: String, isDetail: Bool? = nil, isHistory: Bool? = nil, isInteractive: Bool? = nil) {
                self.policyID = policyID
                self.tag = tag
                self.isDetail = isDetail
                self.isHistory = isHistory
                self.isInteractive = isInteractive
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(policyID, forKey: "policyId")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(isDetail, forKey: "detail")
                encoder.encode(isHistory, forKey: "history")
                encoder.encode(isInteractive, forKey: "interactive")
                return encoder.items
            }
        }
    }
}

extension Paths.Images.ByID.WithImageID {
    public var check: Check {
        Check(path: path + "/check")
    }

    public struct Check {
        /// Path: `/images/by_id/{imageId}/check`
        public let path: String

        /// Check policy evaluation status for image
        ///
        /// Get the policy evaluation for the given image
        public func get(parameters: GetParameters) -> Request<[[String: AnyJSON]]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var policyID: String?
            public var tag: String
            public var isDetail: Bool?
            public var isHistory: Bool?

            public init(policyID: String? = nil, tag: String, isDetail: Bool? = nil, isHistory: Bool? = nil) {
                self.policyID = policyID
                self.tag = tag
                self.isDetail = isDetail
                self.isHistory = isHistory
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(policyID, forKey: "policyId")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(isDetail, forKey: "detail")
                encoder.encode(isHistory, forKey: "history")
                return encoder.items
            }
        }
    }
}

extension Paths.Images.WithImageDigest {
    public var vuln: Vuln {
        Vuln(path: path + "/vuln")
    }

    public struct Vuln {
        /// Path: `/images/{imageDigest}/vuln`
        public let path: String

        /// Get vulnerability types
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public enum GetResponseItem: String, Codable, CaseIterable {
            case all
            case os
            case nonOs = "non-os"
        }
    }
}

extension Paths.Images.WithImageDigest.Vuln {
    public func vtype(_ vtype: String) -> WithVtype {
        WithVtype(path: "\(path)/\(vtype)")
    }

    public struct WithVtype {
        /// Path: `/images/{imageDigest}/vuln/{vtype}`
        public let path: String

        /// Get vulnerabilities by type
        public func get(isForceRefresh: Bool? = nil, isVendorOnly: Bool? = nil) -> Request<AnchoreAPI.VulnerabilityResponse> {
            .get(path, query: makeGetQuery(isForceRefresh, isVendorOnly))
        }

        private func makeGetQuery(_ isForceRefresh: Bool?, _ isVendorOnly: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isForceRefresh, forKey: "force_refresh")
            encoder.encode(isVendorOnly, forKey: "vendor_only")
            return encoder.items
        }
    }
}

extension Paths.Images.ByID.WithImageID {
    public var vuln: Vuln {
        Vuln(path: path + "/vuln")
    }

    public struct Vuln {
        /// Path: `/images/by_id/{imageId}/vuln`
        public let path: String

        /// Get vulnerability types
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public enum GetResponseItem: String, Codable, CaseIterable {
            case all
            case os
            case nonOs = "non-os"
        }
    }
}

extension Paths.Images.ByID.WithImageID.Vuln {
    public func vtype(_ vtype: String) -> WithVtype {
        WithVtype(path: "\(path)/\(vtype)")
    }

    public struct WithVtype {
        /// Path: `/images/by_id/{imageId}/vuln/{vtype}`
        public let path: String

        /// Get vulnerabilities by type
        public var get: Request<AnchoreAPI.VulnerabilityResponse> {
            .get(path)
        }
    }
}

extension Paths.Images.WithImageDigest {
    public var content: Content {
        Content(path: path + "/content")
    }

    public struct Content {
        /// Path: `/images/{imageDigest}/content`
        public let path: String

        /// List image content types
        public var get: Request<[String]> {
            .get(path)
        }
    }
}

extension Paths.Images.ByID.WithImageID {
    public var content: Content {
        Content(path: path + "/content")
    }

    public struct Content {
        /// Path: `/images/by_id/{imageId}/content`
        public let path: String

        /// List image content types
        public var get: Request<[String]> {
            .get(path)
        }
    }
}

extension Paths.Images.WithImageDigest.Content {
    public func ctype(_ ctype: String) -> WithCtype {
        WithCtype(path: "\(path)/\(ctype)")
    }

    public struct WithCtype {
        /// Path: `/images/{imageDigest}/content/{ctype}`
        public let path: String

        /// Get the content of an image by type
        public var get: Request<AnchoreAPI.ContentPackageResponse> {
            .get(path)
        }
    }
}

extension Paths.Images.WithImageDigest.Content {
    public var files: Files {
        Files(path: path + "/files")
    }

    public struct Files {
        /// Path: `/images/{imageDigest}/content/files`
        public let path: String

        /// Get the content of an image by type files
        public var get: Request<AnchoreAPI.ContentFilesResponse> {
            .get(path)
        }
    }
}

extension Paths.Images.WithImageDigest.Content {
    public var java: Java {
        Java(path: path + "/java")
    }

    public struct Java {
        /// Path: `/images/{imageDigest}/content/java`
        public let path: String

        /// Get the content of an image by type java
        public var get: Request<AnchoreAPI.ContentJAVAPackageResponse> {
            .get(path)
        }
    }
}

extension Paths.Images.WithImageDigest.Content {
    public var malware: Malware {
        Malware(path: path + "/malware")
    }

    public struct Malware {
        /// Path: `/images/{imageDigest}/content/malware`
        public let path: String

        /// Get the content of an image by type malware
        public var get: Request<AnchoreAPI.ContentMalwareResponse> {
            .get(path)
        }
    }
}

extension Paths.Images.ByID.WithImageID.Content {
    public func ctype(_ ctype: String) -> WithCtype {
        WithCtype(path: "\(path)/\(ctype)")
    }

    public struct WithCtype {
        /// Path: `/images/by_id/{imageId}/content/{ctype}`
        public let path: String

        /// Get the content of an image by type
        public var get: Request<AnchoreAPI.ContentPackageResponse> {
            .get(path)
        }
    }
}

extension Paths.Images.ByID.WithImageID.Content {
    public var files: Files {
        Files(path: path + "/files")
    }

    public struct Files {
        /// Path: `/images/by_id/{imageId}/content/files`
        public let path: String

        /// Get the content of an image by type files
        public var get: Request<AnchoreAPI.ContentFilesResponse> {
            .get(path)
        }
    }
}

extension Paths.Images.ByID.WithImageID.Content {
    public var java: Java {
        Java(path: path + "/java")
    }

    public struct Java {
        /// Path: `/images/by_id/{imageId}/content/java`
        public let path: String

        /// Get the content of an image by type java
        public var get: Request<AnchoreAPI.ContentJAVAPackageResponse> {
            .get(path)
        }
    }
}

extension Paths.Images.WithImageDigest {
    public var artifacts: Artifacts {
        Artifacts(path: path + "/artifacts")
    }

    public struct Artifacts {
        /// Path: `/images/{imageDigest}/artifacts`
        public let path: String
    }
}

extension Paths.Images.WithImageDigest.Artifacts {
    public var retrievedFiles: RetrievedFiles {
        RetrievedFiles(path: path + "/retrieved_files")
    }

    public struct RetrievedFiles {
        /// Path: `/images/{imageDigest}/artifacts/retrieved_files`
        public let path: String

        /// Return a list of analyzer artifacts of the specified type
        public var get: Request<[AnchoreAPI.RetrievedFile]> {
            .get(path)
        }
    }
}

extension Paths.Images.WithImageDigest.Artifacts {
    public var fileContentSearch: FileContentSearch {
        FileContentSearch(path: path + "/file_content_search")
    }

    public struct FileContentSearch {
        /// Path: `/images/{imageDigest}/artifacts/file_content_search`
        public let path: String

        /// Return a list of analyzer artifacts of the specified type
        public var get: Request<[AnchoreAPI.FileContentSearchResult]> {
            .get(path)
        }
    }
}

extension Paths.Images.WithImageDigest.Artifacts {
    public var secretSearch: SecretSearch {
        SecretSearch(path: path + "/secret_search")
    }

    public struct SecretSearch {
        /// Path: `/images/{imageDigest}/artifacts/secret_search`
        public let path: String

        /// Return a list of analyzer artifacts of the specified type
        public var get: Request<[AnchoreAPI.SecretSearchResult]> {
            .get(path)
        }
    }
}

extension Paths.Images.WithImageDigest {
    public var metadata: Metadata {
        Metadata(path: path + "/metadata")
    }

    public struct Metadata {
        /// Path: `/images/{imageDigest}/metadata`
        public let path: String

        /// List image metadata types
        public var get: Request<[String]> {
            .get(path)
        }
    }
}

extension Paths.Images.WithImageDigest {
    public var sboms: Sboms {
        Sboms(path: path + "/sboms")
    }

    public struct Sboms {
        /// Path: `/images/{imageDigest}/sboms`
        public let path: String
    }
}

extension Paths.Images.WithImageDigest.Sboms {
    public var native: Native {
        Native(path: path + "/native")
    }

    public struct Native {
        /// Path: `/images/{imageDigest}/sboms/native`
        public let path: String

        /// Get image sbom in the native Anchore format
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Images.WithImageDigest.Metadata {
    public func mtype(_ mtype: String) -> WithMtype {
        WithMtype(path: "\(path)/\(mtype)")
    }

    public struct WithMtype {
        /// Path: `/images/{imageDigest}/metadata/{mtype}`
        public let path: String

        /// Get the metadata of an image by type
        public var get: Request<AnchoreAPI.MetadataResponse> {
            .get(path)
        }
    }
}

extension Paths {
    public static var repositories: Repositories {
        Repositories(path: "/repositories")
    }

    public struct Repositories {
        /// Path: `/repositories`
        public let path: String

        /// Add repository to watch
        public func post(parameters: PostParameters) -> Request<[AnchoreAPI.Subscription]> {
            .post(path, query: parameters.asQuery)
        }

        public struct PostParameters {
            public var repository: String
            public var isAutosubscribe: Bool?
            public var isDryrun: Bool?

            public init(repository: String, isAutosubscribe: Bool? = nil, isDryrun: Bool? = nil) {
                self.repository = repository
                self.isAutosubscribe = isAutosubscribe
                self.isDryrun = isDryrun
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(repository, forKey: "repository")
                encoder.encode(isAutosubscribe, forKey: "autosubscribe")
                encoder.encode(isDryrun, forKey: "dryrun")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var registries: Registries {
        Registries(path: "/registries")
    }

    public struct Registries {
        /// Path: `/registries`
        public let path: String

        /// List configured registries
        ///
        /// List all configured registries the system can/will watch
        public var get: Request<[AnchoreAPI.RegistryConfiguration]> {
            .get(path)
        }

        /// Add a new registry
        ///
        /// Adds a new registry to the system
        public func post(isValidate: Bool? = nil, _ body: AnchoreAPI.RegistryConfigurationRequest) -> Request<[AnchoreAPI.RegistryConfiguration]> {
            .post(path, query: makePostQuery(isValidate), body: body)
        }

        private func makePostQuery(_ isValidate: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isValidate, forKey: "validate")
            return encoder.items
        }
    }
}

extension Paths.Registries {
    public func registry(_ registry: String) -> WithRegistry {
        WithRegistry(path: "\(path)/\(registry)")
    }

    public struct WithRegistry {
        /// Path: `/registries/{registry}`
        public let path: String

        /// Get a specific registry configuration
        ///
        /// Get information on a specific registry
        public var get: Request<[AnchoreAPI.RegistryConfiguration]> {
            .get(path)
        }

        /// Update/replace a registry configuration
        ///
        /// Replaces an existing registry record with the given record
        public func put(isValidate: Bool? = nil, _ body: AnchoreAPI.RegistryConfigurationRequest) -> Request<[AnchoreAPI.RegistryConfiguration]> {
            .put(path, query: makePutQuery(isValidate), body: body)
        }

        private func makePutQuery(_ isValidate: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isValidate, forKey: "validate")
            return encoder.items
        }

        /// Delete a registry configuration
        ///
        /// Delete a registry configuration record from the system. Does not remove any images.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var status: Status {
        Status(path: "/status")
    }

    public struct Status {
        /// Path: `/status`
        public let path: String

        /// Service status
        ///
        /// Get the API service status
        public var get: Request<AnchoreAPI.StatusResponse> {
            .get(path)
        }
    }
}

extension Paths {
    public static var system: System {
        System(path: "/system")
    }

    public struct System {
        /// Path: `/system`
        public let path: String

        /// System status
        ///
        /// Get the system status including queue lengths
        public var get: Request<AnchoreAPI.SystemStatusResponse> {
            .get(path)
        }
    }
}

extension Paths.System {
    public var feeds: Feeds {
        Feeds(path: path + "/feeds")
    }

    public struct Feeds {
        /// Path: `/system/feeds`
        public let path: String

        /// List feeds operations and information
        ///
        /// Return a list of feed and their groups along with update and record count information. This data reflects the state of the policy engine, not the upstream feed service itself.
        public var get: Request<[AnchoreAPI.FeedMetadata]> {
            .get(path)
        }

        /// Trigger feeds operations
        ///
        /// Execute a synchronous feed sync operation. The response will block until complete, then return the result summary.
        public func post(isFlush: Bool? = nil, isSync: Bool? = nil) -> Request<[AnchoreAPI.FeedSyncResult]> {
            .post(path, query: makePostQuery(isFlush, isSync))
        }

        private func makePostQuery(_ isFlush: Bool?, _ isSync: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isFlush, forKey: "flush")
            encoder.encode(isSync, forKey: "sync")
            return encoder.items
        }
    }
}

extension Paths.System.Feeds {
    public func feed(_ feed: String) -> WithFeed {
        WithFeed(path: "\(path)/\(feed)")
    }

    public struct WithFeed {
        /// Path: `/system/feeds/{feed}`
        public let path: String

        /// Disable the feed so that it does not sync on subsequent sync operations
        public func put(isEnabled: Bool) -> Request<AnchoreAPI.FeedMetadata> {
            .put(path, query: makePutQuery(isEnabled))
        }

        private func makePutQuery(_ isEnabled: Bool) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isEnabled, forKey: "enabled")
            return encoder.items
        }

        /// Delete the groups and data for the feed and disable the feed itself
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.System.Feeds.WithFeed {
    public func group(_ group: String) -> WithGroup {
        WithGroup(path: "\(path)/\(group)")
    }

    public struct WithGroup {
        /// Path: `/system/feeds/{feed}/{group}`
        public let path: String

        /// Disable a specific group within a feed to not sync
        public func put(isEnabled: Bool) -> Request<[AnchoreAPI.FeedMetadata]> {
            .put(path, query: makePutQuery(isEnabled))
        }

        private func makePutQuery(_ isEnabled: Bool) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isEnabled, forKey: "enabled")
            return encoder.items
        }

        /// Delete the group data and disable the group itself
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.System {
    public var services: Services {
        Services(path: path + "/services")
    }

    public struct Services {
        /// Path: `/system/services`
        public let path: String

        /// List system services
        public var get: Request<[AnchoreAPI.Service]> {
            .get(path)
        }
    }
}

extension Paths.System.Services {
    public func servicename(_ servicename: String) -> WithServicename {
        WithServicename(path: "\(path)/\(servicename)")
    }

    public struct WithServicename {
        /// Path: `/system/services/{servicename}`
        public let path: String

        /// Get a service configuration and state
        public var get: Request<[AnchoreAPI.Service]> {
            .get(path)
        }
    }
}

extension Paths.System.Services.WithServicename {
    public func hostid(_ hostid: String) -> WithHostid {
        WithHostid(path: "\(path)/\(hostid)")
    }

    public struct WithHostid {
        /// Path: `/system/services/{servicename}/{hostid}`
        public let path: String

        /// Get service config for a specific host
        public var get: Request<[AnchoreAPI.Service]> {
            .get(path)
        }

        /// Delete the service config
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.System {
    public var policySpec: PolicySpec {
        PolicySpec(path: path + "/policy_spec")
    }

    public struct PolicySpec {
        /// Path: `/system/policy_spec`
        public let path: String

        /// Describe the policy language spec implemented by this service.
        ///
        /// Get the policy language spec for this service
        public var get: Request<[AnchoreAPI.GateSpec]> {
            .get(path)
        }
    }
}

extension Paths.System {
    public var errorCodes: ErrorCodes {
        ErrorCodes(path: path + "/error_codes")
    }

    public struct ErrorCodes {
        /// Path: `/system/error_codes`
        public let path: String

        /// Describe anchore engine error codes.
        public var get: Request<[AnchoreAPI.AnchoreErrorCode]> {
            .get(path)
        }
    }
}

extension Paths {
    public static var eventTypes: EventTypes {
        EventTypes(path: "/event_types")
    }

    public struct EventTypes {
        /// Path: `/event_types`
        public let path: String

        /// List Event Types
        ///
        /// Returns list of event types in the category hierarchy
        public var get: Request<[AnchoreAPI.EventCategory]> {
            .get(path)
        }
    }
}

extension Paths {
    public static var events: Events {
        Events(path: "/events")
    }

    public struct Events {
        /// Path: `/events`
        public let path: String

        /// List Events
        ///
        /// Returns a paginated list of events in the descending order of their occurrence. Optional query parameters may be used for filtering results
        public func get(parameters: GetParameters? = nil) -> Request<AnchoreAPI.EventsList> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var sourceServicename: String?
            public var sourceHostid: String?
            public var eventType: String?
            public var resourceType: String?
            public var resourceID: String?
            public var level: String?
            public var since: String?
            public var before: String?
            public var page: Int?
            public var limit: Int?

            public init(sourceServicename: String? = nil, sourceHostid: String? = nil, eventType: String? = nil, resourceType: String? = nil, resourceID: String? = nil, level: String? = nil, since: String? = nil, before: String? = nil, page: Int? = nil, limit: Int? = nil) {
                self.sourceServicename = sourceServicename
                self.sourceHostid = sourceHostid
                self.eventType = eventType
                self.resourceType = resourceType
                self.resourceID = resourceID
                self.level = level
                self.since = since
                self.before = before
                self.page = page
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(sourceServicename, forKey: "source_servicename")
                encoder.encode(sourceHostid, forKey: "source_hostid")
                encoder.encode(eventType, forKey: "event_type")
                encoder.encode(resourceType, forKey: "resource_type")
                encoder.encode(resourceID, forKey: "resource_id")
                encoder.encode(level, forKey: "level")
                encoder.encode(since, forKey: "since")
                encoder.encode(before, forKey: "before")
                encoder.encode(page, forKey: "page")
                encoder.encode(limit, forKey: "limit")
                return encoder.items
            }
        }

        /// Delete Events
        ///
        /// Delete all or a subset of events filtered using the optional query parameters
        public func delete(parameters: DeleteParameters? = nil) -> Request<[String]> {
            .delete(path, query: parameters?.asQuery)
        }

        public struct DeleteParameters {
            public var before: String?
            public var since: String?
            public var level: String?

            public init(before: String? = nil, since: String? = nil, level: String? = nil) {
                self.before = before
                self.since = since
                self.level = level
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(before, forKey: "before")
                encoder.encode(since, forKey: "since")
                encoder.encode(level, forKey: "level")
                return encoder.items
            }
        }
    }
}

extension Paths.Events {
    public func eventID(_ eventID: String) -> WithEventID {
        WithEventID(path: "\(path)/\(eventID)")
    }

    public struct WithEventID {
        /// Path: `/events/{eventId}`
        public let path: String

        /// Get Event
        ///
        /// Lookup an event by its event ID
        public var get: Request<AnchoreAPI.EventResponse> {
            .get(path)
        }

        /// Delete Event
        ///
        /// Delete an event by its event ID
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var query: Query {
        Query(path: "/query")
    }

    public struct Query {
        /// Path: `/query`
        public let path: String
    }
}

extension Paths.Query {
    public var images: Images {
        Images(path: path + "/images")
    }

    public struct Images {
        /// Path: `/query/images`
        public let path: String
    }
}

extension Paths.Query.Images {
    public var byVulnerability: ByVulnerability {
        ByVulnerability(path: path + "/by_vulnerability")
    }

    public struct ByVulnerability {
        /// Path: `/query/images/by_vulnerability`
        public let path: String

        /// List images vulnerable to the specific vulnerability ID.
        ///
        /// Returns a listing of images and their respective packages vulnerable to the given vulnerability ID
        public func get(parameters: GetParameters) -> Request<AnchoreAPI.PaginatedVulnerableImageList> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var vulnerabilityID: String
            public var namespace: String?
            public var affectedPackage: String?
            public var severity: Severity?
            public var isVendorOnly: Bool?
            public var page: Int?
            public var limit: Int?

            public enum Severity: String, Codable, CaseIterable {
                case unknown = "Unknown"
                case negligible = "Negligible"
                case low = "Low"
                case medium = "Medium"
                case high = "High"
                case critical = "Critical"
            }

            public init(vulnerabilityID: String, namespace: String? = nil, affectedPackage: String? = nil, severity: Severity? = nil, isVendorOnly: Bool? = nil, page: Int? = nil, limit: Int? = nil) {
                self.vulnerabilityID = vulnerabilityID
                self.namespace = namespace
                self.affectedPackage = affectedPackage
                self.severity = severity
                self.isVendorOnly = isVendorOnly
                self.page = page
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(vulnerabilityID, forKey: "vulnerability_id")
                encoder.encode(namespace, forKey: "namespace")
                encoder.encode(affectedPackage, forKey: "affected_package")
                encoder.encode(severity, forKey: "severity")
                encoder.encode(isVendorOnly, forKey: "vendor_only")
                encoder.encode(page, forKey: "page")
                encoder.encode(limit, forKey: "limit")
                return encoder.items
            }
        }
    }
}

extension Paths.Query.Images {
    public var byPackage: ByPackage {
        ByPackage(path: path + "/by_package")
    }

    public struct ByPackage {
        /// Path: `/query/images/by_package`
        public let path: String

        /// List of images containing given package
        ///
        /// Filterable query interface to search for images containing specified package
        public func get(parameters: GetParameters) -> Request<AnchoreAPI.PaginatedImageList> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var name: String
            public var packageType: String?
            public var version: String?
            public var page: String?
            public var limit: Int?

            public init(name: String, packageType: String? = nil, version: String? = nil, page: String? = nil, limit: Int? = nil) {
                self.name = name
                self.packageType = packageType
                self.version = version
                self.page = page
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(name, forKey: "name")
                encoder.encode(packageType, forKey: "package_type")
                encoder.encode(version, forKey: "version")
                encoder.encode(page, forKey: "page")
                encoder.encode(limit, forKey: "limit")
                return encoder.items
            }
        }
    }
}

extension Paths.Query {
    public var vulnerabilities: Vulnerabilities {
        Vulnerabilities(path: path + "/vulnerabilities")
    }

    public struct Vulnerabilities {
        /// Path: `/query/vulnerabilities`
        public let path: String

        /// Listing information about given vulnerability
        ///
        /// List (w/filters) vulnerability records known by the system, with affected packages information if present
        public func get(parameters: GetParameters) -> Request<AnchoreAPI.PaginatedVulnerabilityList> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var id: [String]
            public var affectedPackage: String?
            public var affectedPackageVersion: String?
            public var page: String?
            public var limit: Int?
            public var namespace: [String]?

            public init(id: [String], affectedPackage: String? = nil, affectedPackageVersion: String? = nil, page: String? = nil, limit: Int? = nil, namespace: [String]? = nil) {
                self.id = id
                self.affectedPackage = affectedPackage
                self.affectedPackageVersion = affectedPackageVersion
                self.page = page
                self.limit = limit
                self.namespace = namespace
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(id, forKey: "id")
                encoder.encode(affectedPackage, forKey: "affected_package")
                encoder.encode(affectedPackageVersion, forKey: "affected_package_version")
                encoder.encode(page, forKey: "page")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(namespace, forKey: "namespace")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var accounts: Accounts {
        Accounts(path: "/accounts")
    }

    public struct Accounts {
        /// Path: `/accounts`
        public let path: String

        /// List user summaries. Only available to the system admin user.
        public func get(state: State? = nil) -> Request<[AnchoreAPI.Account]> {
            .get(path, query: makeGetQuery(state))
        }

        private func makeGetQuery(_ state: State?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(state, forKey: "state")
            return encoder.items
        }

        public enum State: String, Codable, CaseIterable {
            case enabled
            case disabled
            case deleting
        }

        /// Create a new user. Only avaialble to admin user.
        public func post(_ body: AnchoreAPI.AccountCreationRequest) -> Request<AnchoreAPI.Account> {
            .post(path, body: body)
        }
    }
}

extension Paths.Accounts {
    public func accountname(_ accountname: String) -> WithAccountname {
        WithAccountname(path: "\(path)/\(accountname)")
    }

    public struct WithAccountname {
        /// Path: `/accounts/{accountname}`
        public let path: String

        /// Get info about an user. Only available to admin user. Uses the main user Id, not a username.
        public var get: Request<AnchoreAPI.Account> {
            .get(path)
        }

        /// Delete the specified account, only allowed if the account is in the disabled state. All users will be deleted along with the account and all resources will be garbage collected
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountname {
    public var state: State {
        State(path: path + "/state")
    }

    public struct State {
        /// Path: `/accounts/{accountname}/state`
        public let path: String

        /// Update the state of an account to either enabled or disabled. For deletion use the DELETE route
        public func put(_ body: AnchoreAPI.AccountStatus) -> Request<AnchoreAPI.AccountStatus> {
            .put(path, body: body)
        }
    }
}

extension Paths.Accounts.WithAccountname {
    public var users: Users {
        Users(path: path + "/users")
    }

    public struct Users {
        /// Path: `/accounts/{accountname}/users`
        public let path: String

        /// List accounts for the user
        public var get: Request<[AnchoreAPI.User]> {
            .get(path)
        }

        /// Create a new user
        public func post(_ body: AnchoreAPI.UserCreationRequest) -> Request<AnchoreAPI.User> {
            .post(path, body: body)
        }
    }
}

extension Paths.Accounts.WithAccountname.Users {
    public func username(_ username: String) -> WithUsername {
        WithUsername(path: "\(path)/\(username)")
    }

    public struct WithUsername {
        /// Path: `/accounts/{accountname}/users/{username}`
        public let path: String

        /// Get a specific user in the specified account
        public var get: Request<AnchoreAPI.User> {
            .get(path)
        }

        /// Delete a specific user credential by username of the credential. Cannot be the credential used to authenticate the request.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountname.Users.WithUsername {
    public var credentials: Credentials {
        Credentials(path: path + "/credentials")
    }

    public struct Credentials {
        /// Path: `/accounts/{accountname}/users/{username}/credentials`
        public let path: String

        /// Get current credential summary
        public var get: Request<[AnchoreAPI.AccessCredential]> {
            .get(path)
        }

        /// Add/replace credential
        public func post(_ body: AnchoreAPI.AccessCredential) -> Request<AnchoreAPI.User> {
            .post(path, body: body)
        }

        /// Delete a credential by type
        public func delete(credentialType: CredentialType) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(credentialType))
        }

        private func makeDeleteQuery(_ credentialType: CredentialType) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(credentialType, forKey: "credential_type")
            return encoder.items
        }

        public enum CredentialType: String, Codable, CaseIterable {
            case password
        }
    }
}

extension Paths {
    public static var account: Account {
        Account(path: "/account")
    }

    public struct Account {
        /// Path: `/account`
        public let path: String

        /// List the account for the authenticated user
        public var get: Request<AnchoreAPI.Account> {
            .get(path)
        }
    }
}

extension Paths {
    public static var user: User {
        User(path: "/user")
    }

    public struct User {
        /// Path: `/user`
        public let path: String

        /// List authenticated user info
        public var get: Request<AnchoreAPI.User> {
            .get(path)
        }
    }
}

extension Paths.User {
    public var credentials: Credentials {
        Credentials(path: path + "/credentials")
    }

    public struct Credentials {
        /// Path: `/user/credentials`
        public let path: String

        /// Get current credential summary
        public var get: Request<[AnchoreAPI.AccessCredential]> {
            .get(path)
        }

        /// Add/replace credential
        public func post(_ body: AnchoreAPI.AccessCredential) -> Request<AnchoreAPI.User> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var archives: Archives {
        Archives(path: "/archives")
    }

    public struct Archives {
        /// Path: `/archives`
        public let path: String

        public var get: Request<AnchoreAPI.ArchiveSummary> {
            .get(path)
        }
    }
}

extension Paths.Archives {
    public var rules: Rules {
        Rules(path: path + "/rules")
    }

    public struct Rules {
        /// Path: `/archives/rules`
        public let path: String

        public func get(isSystemGlobal: Bool? = nil) -> Request<[AnchoreAPI.AnalysisArchiveTransitionRule]> {
            .get(path, query: makeGetQuery(isSystemGlobal))
        }

        private func makeGetQuery(_ isSystemGlobal: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isSystemGlobal, forKey: "system_global")
            return encoder.items
        }

        public func post(_ body: AnchoreAPI.AnalysisArchiveTransitionRule) -> Request<AnchoreAPI.AnalysisArchiveTransitionRule> {
            .post(path, body: body)
        }
    }
}

extension Paths.Archives.Rules {
    public func ruleID(_ ruleID: String) -> WithRuleID {
        WithRuleID(path: "\(path)/\(ruleID)")
    }

    public struct WithRuleID {
        /// Path: `/archives/rules/{ruleId}`
        public let path: String

        public var get: Request<AnchoreAPI.AnalysisArchiveTransitionRule> {
            .get(path)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Archives {
    public var images: Images {
        Images(path: path + "/images")
    }

    public struct Images {
        /// Path: `/archives/images`
        public let path: String

        public var get: Request<[AnchoreAPI.ArchivedAnalysis]> {
            .get(path)
        }

        public func post(_ body: [String]) -> Request<[AnchoreAPI.AnalysisArchiveAddResult]> {
            .post(path, body: body)
        }
    }
}

extension Paths.Archives.Images {
    public func imageDigest(_ imageDigest: String) -> WithImageDigest {
        WithImageDigest(path: "\(path)/\(imageDigest)")
    }

    public struct WithImageDigest {
        /// Path: `/archives/images/{imageDigest}`
        public let path: String

        /// Returns the archive metadata record identifying the image and tags for the analysis in the archive.
        public var get: Request<AnchoreAPI.ArchivedAnalysis> {
            .get(path)
        }

        /// Performs a synchronous archive deletion
        public func delete(isForce: Bool? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(isForce))
        }

        private func makeDeleteQuery(_ isForce: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isForce, forKey: "force")
            return encoder.items
        }
    }
}

extension Paths {
    public static var oauth: Oauth {
        Oauth(path: "/oauth")
    }

    public struct Oauth {
        /// Path: `/oauth`
        public let path: String
    }
}

extension Paths.Oauth {
    public var token: Token {
        Token(path: path + "/token")
    }

    public struct Token {
        /// Path: `/oauth/token`
        public let path: String

        /// Request a jwt token for subsequent operations, this request is authenticated with normal HTTP auth
        public func post(_ body: PostRequest? = nil) -> Request<AnchoreAPI.TokenResponse> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// OAuth Grant type for token
            public var grantType: String?
            /// User to assign OAuth token to
            public var username: String?
            /// Password for corresponding user
            public var password: String?
            /// The type of client used for the OAuth token
            public var clientID: String?

            public init(grantType: String? = nil, username: String? = nil, password: String? = nil, clientID: String? = nil) {
                self.grantType = grantType
                self.username = username
                self.password = password
                self.clientID = clientID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(grantType, forKey: "grant_type")
                encoder.encode(username, forKey: "username")
                encoder.encode(password, forKey: "password")
                encoder.encode(clientID, forKey: "client_id")
                return encoder.items
            }
        }
    }
}

extension Paths.System {
    public var webhooks: Webhooks {
        Webhooks(path: path + "/webhooks")
    }

    public struct Webhooks {
        /// Path: `/system/webhooks`
        public let path: String
    }
}

extension Paths.System.Webhooks {
    public func webhookType(_ webhookType: String) -> WithWebhookType {
        WithWebhookType(path: "\(path)/\(webhookType)")
    }

    public struct WithWebhookType {
        /// Path: `/system/webhooks/{webhook_type}`
        public let path: String
    }
}

extension Paths.System.Webhooks.WithWebhookType {
    public var test: Test {
        Test(path: path + "/test")
    }

    public struct Test {
        /// Path: `/system/webhooks/{webhook_type}/test`
        public let path: String

        /// Adds the capabilities to test a webhook delivery for the given notification type
        ///
        /// Loads the Webhook configuration for webhook_type, and sends the notification out as a test
        public func post(notificationType: NotificationType? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(notificationType))
        }

        private func makePostQuery(_ notificationType: NotificationType?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(notificationType, forKey: "notification_type")
            return encoder.items
        }

        public enum NotificationType: String, Codable, CaseIterable {
            case tagUpdate = "tag_update"
            case analysisUpdate = "analysis_update"
            case vulnUpdate = "vuln_update"
            case policyEval = "policy_eval"
        }
    }
}

extension Paths {
    public static var imports: Imports {
        Imports(path: "/imports")
    }

    public struct Imports {
        /// Path: `/imports`
        public let path: String
    }
}

extension Paths.Imports {
    public var images: Images {
        Images(path: path + "/images")
    }

    public struct Images {
        /// Path: `/imports/images`
        public let path: String

        /// Lists in-progress imports
        public var get: Request<[AnchoreAPI.ImageImportOperation]> {
            .get(path)
        }

        /// Begin the import of an image analyzed by Syft into the system
        public var post: Request<AnchoreAPI.ImageImportOperation> {
            .post(path)
        }
    }
}

extension Paths.Imports.Images {
    public func operationID(_ operationID: String) -> WithOperationID {
        WithOperationID(path: "\(path)/\(operationID)")
    }

    public struct WithOperationID {
        /// Path: `/imports/images/{operation_id}`
        public let path: String

        /// Get detail on a single import
        public var get: Request<AnchoreAPI.ImageImportOperation> {
            .get(path)
        }

        /// Invalidate operation ID so it can be garbage collected
        public var delete: Request<AnchoreAPI.ImageImportOperation> {
            .delete(path)
        }
    }
}

extension Paths.Imports.Images.WithOperationID {
    public var packages: Packages {
        Packages(path: path + "/packages")
    }

    public struct Packages {
        /// Path: `/imports/images/{operation_id}/packages`
        public let path: String

        /// List uploaded package manifests
        public var get: Request<[String]> {
            .get(path)
        }

        /// Begin the import of an image analyzed by Syft into the system
        public func post(_ body: AnchoreAPI.ImagePackageManifest) -> Request<AnchoreAPI.ImageImportContentResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Imports.Images.WithOperationID {
    public var dockerfile: Dockerfile {
        Dockerfile(path: path + "/dockerfile")
    }

    public struct Dockerfile {
        /// Path: `/imports/images/{operation_id}/dockerfile`
        public let path: String

        /// List uploaded dockerfiles
        public var get: Request<[String]> {
            .get(path)
        }

        /// Begin the import of an image analyzed by Syft into the system
        public func post(_ body: String) -> Request<AnchoreAPI.ImageImportContentResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Imports.Images.WithOperationID {
    public var manifest: Manifest {
        Manifest(path: path + "/manifest")
    }

    public struct Manifest {
        /// Path: `/imports/images/{operation_id}/manifest`
        public let path: String

        /// List uploaded image manifests
        public var get: Request<[String]> {
            .get(path)
        }

        /// Import a docker or OCI distribution manifest to associate with the image
        public func post(_ body: Data) -> Request<AnchoreAPI.ImageImportContentResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Imports.Images.WithOperationID {
    public var parentManifest: ParentManifest {
        ParentManifest(path: path + "/parent_manifest")
    }

    public struct ParentManifest {
        /// Path: `/imports/images/{operation_id}/parent_manifest`
        public let path: String

        /// List uploaded parent manifests (manifest lists for a tag)
        public var get: Request<[String]> {
            .get(path)
        }

        /// Import a docker or OCI distribution manifest list to associate with the image
        public func post(_ body: Data) -> Request<AnchoreAPI.ImageImportContentResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Imports.Images.WithOperationID {
    public var imageConfig: ImageConfig {
        ImageConfig(path: path + "/image_config")
    }

    public struct ImageConfig {
        /// Path: `/imports/images/{operation_id}/image_config`
        public let path: String

        /// List uploaded image configs
        public var get: Request<[String]> {
            .get(path)
        }

        /// Import a docker or OCI image config to associate with the image
        public func post(_ body: [String: AnyJSON]) -> Request<AnchoreAPI.ImageImportContentResponse> {
            .post(path, body: body)
        }
    }
}

public enum Paths {}
