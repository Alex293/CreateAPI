// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

public struct PreSignRequest: Codable {
    /// The extension of the file.  Usually related to the media type.
    ///
    /// Example: "pdf"
    public var fileExtension: String?
    /// The media type of the file you would like to upload.  If you are not sure what value to use here, check out the standard [list of media types](https://www.iana.org/assignments/media-types/media-types.xhtml).
    ///
    /// Example: "application/pdf"
    public var mediaType: String?

    public init(fileExtension: String? = nil, mediaType: String? = nil) {
        self.fileExtension = fileExtension
        self.mediaType = mediaType
    }
}

public struct PreSignInfo: Codable {
    /// The address of the PUT request to upload the file.
    ///
    /// Example: "https://some.place/aethzd.pdf?Token=IQoJb3JpZ2luX2EP3"
    public var putURL: String?
    /// The URL you use in your SMS text.  It is the file location.
    ///
    /// Example: "https://smsattach.it/bedhkd.pdf"
    public var fetchURL: String?
    /// Name value objects to add to the headers of the PUT request.
    public var fields: [Field]?

    public struct Field: Codable {
        /// The header name
        ///
        /// Example: "x-amz-acl"
        public var name: String?
        /// The header value
        ///
        /// Example: "public-read"
        public var value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }
    }

    public init(putURL: String? = nil, fetchURL: String? = nil, fields: [Field]? = nil) {
        self.putURL = putURL
        self.fetchURL = fetchURL
        self.fields = fields
    }

    private enum CodingKeys: String, CodingKey {
        case putURL = "putUrl"
        case fetchURL = "fetchUrl"
        case fields
    }
}

public struct Profile: Codable {
    public var id: String
    public var username: String
    public var created: Date
    public var credits: Credits
    public var quota: Quota
    public var originAddresses: OriginAddresses?
    public var company: Company?
    public var commerce: Commerce?

    public struct Credits: Codable {
        public var balance: Double?
        public var limit: Int?
        public var isTransferAllowed: Bool?

        public init(balance: Double? = nil, limit: Int? = nil, isTransferAllowed: Bool? = nil) {
            self.balance = balance
            self.limit = limit
            self.isTransferAllowed = isTransferAllowed
        }
    }

    public struct Quota: Codable {
        /// The setting that limits the number of messages you can send in a day.
        public var size: Int
        /// The number of messages you can still send today.
        public var remaining: Int

        public init(size: Int, remaining: Int) {
            self.size = size
            self.remaining = remaining
        }
    }

    public struct OriginAddresses: Codable {
        public var isFullControlAllowed: Bool?
        public var allowed: [String]?

        public init(isFullControlAllowed: Bool? = nil, allowed: [String]? = nil) {
            self.isFullControlAllowed = isFullControlAllowed
            self.allowed = allowed
        }
    }

    public struct Company: Codable {
        public var name: String?
        public var taxReference: String?

        public init(name: String? = nil, taxReference: String? = nil) {
            self.name = name
            self.taxReference = taxReference
        }
    }

    public struct Commerce: Codable {
        public var bankPaymentReference: String?
        public var address: Address?

        public struct Address: Codable {
            public var street: [String]?
            public var city: String?
            public var region: String?
            public var country: String?
            public var postalCode: String?

            public init(street: [String]? = nil, city: String? = nil, region: String? = nil, country: String? = nil, postalCode: String? = nil) {
                self.street = street
                self.city = city
                self.region = region
                self.country = country
                self.postalCode = postalCode
            }
        }

        public init(bankPaymentReference: String? = nil, address: Address? = nil) {
            self.bankPaymentReference = bankPaymentReference
            self.address = address
        }
    }

    public init(id: String, username: String, created: Date, credits: Credits, quota: Quota, originAddresses: OriginAddresses? = nil, company: Company? = nil, commerce: Commerce? = nil) {
        self.id = id
        self.username = username
        self.created = created
        self.credits = credits
        self.quota = quota
        self.originAddresses = originAddresses
        self.company = company
        self.commerce = commerce
    }
}

/// An object that you use when posting messages.
public struct SubmissionEntry: Codable {
    /// Identifies the sender.
    /// 
    /// Instead of a structured object, you can supply a string value here. 
    /// If you do this, the `type` of the sender is derived to be either INTERNATIONAL or ALPHANUMERIC.  If the value does not begin with a `+` and it contains at least one character that is not a digit, the type is detected as ALPHANUMERIC. Otherwise, the type is detected as INTERNATIONAL.
    public var from: From?
    /// Identifies the recipients
    /// 
    /// Instead of an array of structured objects, you can also provide a single object, a simple string or an array of strings.
    /// If you supply a string, the `type` is taken as INTERNATIONAL.
    public var to: [ToItem]
    /// Allows you to choose routing. The default is STANDARD.
    public var routingGroup: RoutingGroup?
    /// Describes the content of the message body.
    /// 
    /// Typically this is TEXT, which is the default if no value is provided.
    /// 
    /// If you need to send characters that are not covered by the [GSM 03.38](https://en.wikipedia.org/wiki/GSM_03.38) character set you will need to specify UNICODE.
    /// 
    /// If you want to send a sequence of bytes, you must use BINARY.
    /// 
    /// You can also or use the `auto-unicode` parameter of the Send Messages Operation.   
    /// 
    /// If you supply the value of `TEXT` while `auto-unicode` is `true` then your message may be converted to `UNICODE`.
    /// 
    /// If you supply a value other than `TEXT` for this property while `auto-unicode` is `true` then no automatic conversion will take place.
    public var encoding: Encoding?
    /// The maximum number of message parts that can be used for a [concatenated message](https://en.wikipedia.org/wiki/Concatenated_SMS).
    /// The default is `3`.
    ///
    /// Example: 99
    public var longMessageMaxParts: Int?
    /// The message content as described in the `encoding`. If the `encoding` is BINARY, the body must contain only hexadecimal digits where one byte is represented as two digits. For example, if you want to send two bytes '0x05' and '0x1F', the message body must contain the text '051F'.
    /// 
    /// The message content can also contain templates, read the [body templates section](#tag/Message) for more information.
    ///
    /// Example: "Hi there!"
    public var body: String
    /// Correlate the messages created from this submission to your data.
    /// 
    /// The value can contain no more than 20 characters.
    ///
    /// Example: "submission-12765"
    public var userSuppliedID: String?
    /// The TP-PID value from GSM 03.40[.750] ยง9.2.3.9.
    /// 
    /// You can provide either an integer value, or a mnemonic string.
    /// 
    /// If unspecified, this property defaults to `0`, representing the IMPLICIT value.
    /// Numeric values are listed below
    /// | Name | Value|
    /// |----- |------|
    /// | IMPLICIT              | 00 |
    /// | SHORT_MESSAGE_TYPE_0  | 64 |
    /// | REPLACE_MESSAGE_1     | 65 |
    /// | REPLACE_MESSAGE_2     | 66 |
    /// | REPLACE_MESSAGE_3     | 67 |
    /// | REPLACE_MESSAGE_4     | 68 |
    /// | REPLACE_MESSAGE_5     | 69 |
    /// | REPLACE_MESSAGE_6     | 70 |
    /// | REPLACE_MESSAGE_7     | 71 |
    /// | RETURN_CALL           | 95 |
    /// | ME_DOWNLOAD           | 125 |
    /// | ME_DEPERSONALIZE      | 126 |
    /// | SIM_DOWNLOAD          | 127 |
    public var protocolID: ProtocolID?
    /// The class of the message, as specified by ยง4 of the GSM 03.38 specification.
    /// 
    /// You can provide either an integer value, or a mnemonic string.
    /// 
    /// The default value is SIM_SPECIFIC.
    /// Numeric values are
    /// | Name | Value|
    /// |------|------|
    /// | FLASH_SMS | 0      |
    /// | ME_SPECIFIC | 1    |
    /// | SIM_SPECIFIC | 2   |
    /// | TE_SPECIFIC | 3   |
    public var messageClass: MessageClass?
    /// The type of delivery reports to request from the delivering network.
    /// The default value  is `ALL`. Please note that not all networks support delivery reports.
    /// ALL. All possible delivery reports
    /// ERRORS. Only error delivery reports
    /// NONE. No delivery reports
    public var deliveryReports: DeliveryReports?

    /// Identifies the sender.
    /// 
    /// Instead of a structured object, you can supply a string value here. 
    /// If you do this, the `type` of the sender is derived to be either INTERNATIONAL or ALPHANUMERIC.  If the value does not begin with a `+` and it contains at least one character that is not a digit, the type is detected as ALPHANUMERIC. Otherwise, the type is detected as INTERNATIONAL.
    public struct From: Codable {
        /// The type of the sender id.
        /// 
        /// If you want BulkSMS to collect replies to this message on your behalf, specify the type as REPLIABLE.  If the recipient is in a country where BulkSMS does not have a local reply number, the reply may incur costs that are more expensive than sending a local SMS in that country.
        /// If you operate a service from a shortcode in a locale that allows messaging from such a shortcode, you can specify SHORTCODE for the type.
        public var type: `Type`
        /// The address of the sender id.
        /// 
        /// The validation for this field depends on the value of the `type`.
        /// INTERNATIONAL can start with `+`. It has a maximum length of 15 digits, and has to be longer than 6 digits.
        /// ALPHANUMERIC has a maximum length of 11 characters.
        /// SHORTCODE has a maximum length of 6 digits.
        /// REPLIABLE should not specify a value here.
        ///
        /// Example: "1111111"
        public var address: String?

        /// The type of the sender id.
        /// 
        /// If you want BulkSMS to collect replies to this message on your behalf, specify the type as REPLIABLE.  If the recipient is in a country where BulkSMS does not have a local reply number, the reply may incur costs that are more expensive than sending a local SMS in that country.
        /// If you operate a service from a shortcode in a locale that allows messaging from such a shortcode, you can specify SHORTCODE for the type.
        public enum `Type`: String, Codable, CaseIterable {
            case international = "INTERNATIONAL"
            case alphanumeric = "ALPHANUMERIC"
            case shortcode = "SHORTCODE"
            case repliable = "REPLIABLE"
        }

        public init(type: `Type`, address: String? = nil) {
            self.type = type
            self.address = address
        }
    }

    /// Example:
    ///
    /// {
    ///   "address" : "1111111",
    ///   "fields" : [
    ///     "Jack",
    ///     "$200.00"
    ///   ],
    ///   "type" : "INTERNATIONAL"
    /// }
    public struct ToItem: Codable {
        /// Type of the recipient. The default value is INTERNATIONAL.
        public var type: `Type`?
        /// The phone number of the recipient.  It must be supplied if the `type` is INTERNATIONAL
        public var address: String?
        /// The name of a group in your phonebook. A value can be given if the `type` is GROUP.
        public var name: String?
        /// The id of a group in your phonebook.  A value can be given if the `type` is GROUP.
        public var id: String?
        /// Custom fields that can be used in the message body. A value can be given if the `type` is INTERNATIONAL
        /// 
        /// Read the [body templates section](#tag/Message) for more information.
        public var fields: [String]?

        /// Type of the recipient. The default value is INTERNATIONAL.
        public enum `Type`: String, Codable, CaseIterable {
            case international = "INTERNATIONAL"
            case group = "GROUP"
        }

        public init(type: `Type`? = nil, address: String? = nil, name: String? = nil, id: String? = nil, fields: [String]? = nil) {
            self.type = type
            self.address = address
            self.name = name
            self.id = id
            self.fields = fields
        }
    }

    /// Allows you to choose routing. The default is STANDARD.
    public enum RoutingGroup: String, Codable, CaseIterable {
        case economy = "ECONOMY"
        case standard = "STANDARD"
        case premium = "PREMIUM"
    }

    /// Describes the content of the message body.
    /// 
    /// Typically this is TEXT, which is the default if no value is provided.
    /// 
    /// If you need to send characters that are not covered by the [GSM 03.38](https://en.wikipedia.org/wiki/GSM_03.38) character set you will need to specify UNICODE.
    /// 
    /// If you want to send a sequence of bytes, you must use BINARY.
    /// 
    /// You can also or use the `auto-unicode` parameter of the Send Messages Operation.   
    /// 
    /// If you supply the value of `TEXT` while `auto-unicode` is `true` then your message may be converted to `UNICODE`.
    /// 
    /// If you supply a value other than `TEXT` for this property while `auto-unicode` is `true` then no automatic conversion will take place.
    public enum Encoding: String, Codable, CaseIterable {
        case text = "TEXT"
        case unicode = "UNICODE"
        case binary = "BINARY"
    }

    /// The TP-PID value from GSM 03.40[.750] ยง9.2.3.9.
    /// 
    /// You can provide either an integer value, or a mnemonic string.
    /// 
    /// If unspecified, this property defaults to `0`, representing the IMPLICIT value.
    /// Numeric values are listed below
    /// | Name | Value|
    /// |----- |------|
    /// | IMPLICIT              | 00 |
    /// | SHORT_MESSAGE_TYPE_0  | 64 |
    /// | REPLACE_MESSAGE_1     | 65 |
    /// | REPLACE_MESSAGE_2     | 66 |
    /// | REPLACE_MESSAGE_3     | 67 |
    /// | REPLACE_MESSAGE_4     | 68 |
    /// | REPLACE_MESSAGE_5     | 69 |
    /// | REPLACE_MESSAGE_6     | 70 |
    /// | REPLACE_MESSAGE_7     | 71 |
    /// | RETURN_CALL           | 95 |
    /// | ME_DOWNLOAD           | 125 |
    /// | ME_DEPERSONALIZE      | 126 |
    /// | SIM_DOWNLOAD          | 127 |
    public enum ProtocolID: String, Codable, CaseIterable {
        case implicit = "IMPLICIT"
        case shortMessageType0 = "SHORT_MESSAGE_TYPE_0"
        case replaceMessage1 = "REPLACE_MESSAGE_1"
        case replaceMessage2 = "REPLACE_MESSAGE_2"
        case replaceMessage3 = "REPLACE_MESSAGE_3"
        case replaceMessage4 = "REPLACE_MESSAGE_4"
        case replaceMessage5 = "REPLACE_MESSAGE_5"
        case replaceMessage6 = "REPLACE_MESSAGE_6"
        case replaceMessage7 = "REPLACE_MESSAGE_7"
        case returnCall = "RETURN_CALL"
        case meDownload = "ME_DOWNLOAD"
        case meDepersonalize = "ME_DEPERSONALIZE"
        case simDownload = "SIM_DOWNLOAD"
    }

    /// The class of the message, as specified by ยง4 of the GSM 03.38 specification.
    /// 
    /// You can provide either an integer value, or a mnemonic string.
    /// 
    /// The default value is SIM_SPECIFIC.
    /// Numeric values are
    /// | Name | Value|
    /// |------|------|
    /// | FLASH_SMS | 0      |
    /// | ME_SPECIFIC | 1    |
    /// | SIM_SPECIFIC | 2   |
    /// | TE_SPECIFIC | 3   |
    public enum MessageClass: String, Codable, CaseIterable {
        case flashSms = "FLASH_SMS"
        case meSpecific = "ME_SPECIFIC"
        case simSpecific = "SIM_SPECIFIC"
        case teSpecific = "TE_SPECIFIC"
    }

    /// The type of delivery reports to request from the delivering network.
    /// The default value  is `ALL`. Please note that not all networks support delivery reports.
    /// ALL. All possible delivery reports
    /// ERRORS. Only error delivery reports
    /// NONE. No delivery reports
    public enum DeliveryReports: String, Codable, CaseIterable {
        case all = "ALL"
        case errors = "ERRORS"
        case `none` = "NONE"
    }

    public init(from: From? = nil, to: [ToItem], routingGroup: RoutingGroup? = nil, encoding: Encoding? = nil, longMessageMaxParts: Int? = nil, body: String, userSuppliedID: String? = nil, protocolID: ProtocolID? = nil, messageClass: MessageClass? = nil, deliveryReports: DeliveryReports? = nil) {
        self.from = from
        self.to = to
        self.routingGroup = routingGroup
        self.encoding = encoding
        self.longMessageMaxParts = longMessageMaxParts
        self.body = body
        self.userSuppliedID = userSuppliedID
        self.protocolID = protocolID
        self.messageClass = messageClass
        self.deliveryReports = deliveryReports
    }

    private enum CodingKeys: String, CodingKey {
        case from
        case to
        case routingGroup
        case encoding
        case longMessageMaxParts
        case body
        case userSuppliedID = "userSuppliedId"
        case protocolID = "protocolId"
        case messageClass
        case deliveryReports
    }
}

public struct WebhookEntry: Codable {
    /// A text identifier for the webhook.
    /// More than one webhook cannot have the same name.
    ///
    /// Example: "My MT Webhook"
    public var name: String
    /// The location of the webhook.
    /// 
    /// In addition to being a [valid URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax), the url must also start with `http` or `https`.
    ///
    /// Example: "https://www.example.com"
    public var url: String
    /// The email address to which emails will be sent if there are problem with invoking the webhook.
    /// 
    /// The value must be a valid email address.
    /// If this value is `null`, no email will be sent.
    /// 
    /// It is `null` by default.
    ///
    /// Example: "tech_team@example.com"
    public var contactEmailAddress: String?
    /// Specifies when the webhook will be triggered.  
    /// 
    /// Please note the values are case sensitive.
    /// 
    /// If the value is `SENT`, the webhook will be called when a status update becomes available for a message you sent (i.e. a mobile terminating (MT) message).
    /// 
    /// If the value is `RECEIVED`, the webhook will be called when a message is received (i.e. a mobile originating (MO) message).
    /// 
    /// Note that this field forces you to create two separate webhook entries if you want to collect all messages.  However,  you can use the same `url` for both webhooks if you want.
    ///
    /// Example: "SENT"
    public var triggerScope: TriggerScope
    /// Specifies how to invoke your webhook.
    /// 
    /// If the value is `ONE` the array POSTed to your webhook will contain no more than a single message.  Use this option if your webhook logic is unable to handle more than one messages at a time.
    /// 
    /// If the value is `MANY` the array POSTed to your webhook can contain up to 10 messages.  This is the recommended option.  The number of calls made to your webhook would be less and this will speed up your total processing time.
    /// If your webhook fails for an invoke that has more than one message, each message in the array will automatically be retried one at a time. 
    /// 
    /// This value defaults to `ONE` - but it is recommended that you set this property to `MANY`.
    ///
    /// Example: "MANY"
    public var invokeOption: InvokeOption?
    /// Indicates whether you want the webhook activated.
    /// 
    /// If the value is `true`, the webhook at the given `url` will be invoked with an empty array (`[]`) as part of the validation process.
    /// If the webhook responds with a `2xx` status code, the submission is accepted; if not the webhook is not created (or updated).
    /// 
    /// If the value is `false` the webhook will be inactive, and it will not be invoked when messages are `SENT` or `RECEIVED`.
    /// 
    /// The default value is `true`.
    ///
    /// Example: true
    public var isActive: Bool?
    /// Indicates whether you want to show this webhook on the Web App.
    /// 
    /// Webhooks shown there can be updated by the user that use the public Web site.
    /// 
    /// The default value is `true`.
    ///
    /// Example: true
    public var isOnWebApp: Bool?

    /// Specifies when the webhook will be triggered.  
    /// 
    /// Please note the values are case sensitive.
    /// 
    /// If the value is `SENT`, the webhook will be called when a status update becomes available for a message you sent (i.e. a mobile terminating (MT) message).
    /// 
    /// If the value is `RECEIVED`, the webhook will be called when a message is received (i.e. a mobile originating (MO) message).
    /// 
    /// Note that this field forces you to create two separate webhook entries if you want to collect all messages.  However,  you can use the same `url` for both webhooks if you want.
    ///
    /// Example: "SENT"
    public enum TriggerScope: String, Codable, CaseIterable {
        case sent = "SENT"
        case received = "RECEIVED"
    }

    /// Specifies how to invoke your webhook.
    /// 
    /// If the value is `ONE` the array POSTed to your webhook will contain no more than a single message.  Use this option if your webhook logic is unable to handle more than one messages at a time.
    /// 
    /// If the value is `MANY` the array POSTed to your webhook can contain up to 10 messages.  This is the recommended option.  The number of calls made to your webhook would be less and this will speed up your total processing time.
    /// If your webhook fails for an invoke that has more than one message, each message in the array will automatically be retried one at a time. 
    /// 
    /// This value defaults to `ONE` - but it is recommended that you set this property to `MANY`.
    ///
    /// Example: "MANY"
    public enum InvokeOption: String, Codable, CaseIterable {
        case one = "ONE"
        case many = "MANY"
    }

    public init(name: String, url: String, contactEmailAddress: String? = nil, triggerScope: TriggerScope, invokeOption: InvokeOption? = nil, isActive: Bool? = nil, isOnWebApp: Bool? = nil) {
        self.name = name
        self.url = url
        self.contactEmailAddress = contactEmailAddress
        self.triggerScope = triggerScope
        self.invokeOption = invokeOption
        self.isActive = isActive
        self.isOnWebApp = isOnWebApp
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case url
        case contactEmailAddress
        case triggerScope
        case invokeOption
        case isActive = "active"
        case isOnWebApp = "onWebApp"
    }
}

public struct Webhook: Codable {
    /// Example: 234.0
    public var id: Double?
    /// Example: "My MT Webhook"
    public var name: String?
    /// Example: "https://www.example.com"
    public var url: String?
    /// Example: "tech_team@example.com"
    public var contactEmailAddress: String?
    /// Example: "SENT"
    public var triggerScope: String?
    /// Example: true
    public var isActive: Bool?
    /// Example: true
    public var isOnWebApp: Bool?

    public init(id: Double? = nil, name: String? = nil, url: String? = nil, contactEmailAddress: String? = nil, triggerScope: String? = nil, isActive: Bool? = nil, isOnWebApp: Bool? = nil) {
        self.id = id
        self.name = name
        self.url = url
        self.contactEmailAddress = contactEmailAddress
        self.triggerScope = triggerScope
        self.isActive = isActive
        self.isOnWebApp = isOnWebApp
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case url
        case contactEmailAddress
        case triggerScope
        case isActive = "active"
        case isOnWebApp = "onWebApp"
    }
}

public struct Message: Codable {
    /// A unique identifier that is assigned when the message is created.
    public var id: String
    /// The message direction
    public var type: `Type`
    /// The address part of the sender id
    public var from: String?
    /// The phone number of the recipient
    public var to: String
    /// The content of the message
    public var body: [String: AnyJSON]
    /// The type of the content.  See the `encoding` field for more information.
    public var encoding: Encoding?
    /// See the `protocolId` field for more information.
    public var protocolID: Int?
    /// See the `messageClass` field for more information.
    public var messageClass: Int?
    /// The number of parts.  If this is a concatenated message, the number of parts will be more than 1.  Note that this field does not have a value in the submission response.
    public var numberOfParts: Int?
    /// The cost of the message (in credits).   Note that this field does not have a value in the submission response.
    public var creditCost: Double?
    /// Identifies the submission.
    public var submission: Submission?
    /// The status of the message
    public var status: Status
    /// This field has a value only if the type is RECEIVED.
    /// With SMS messages, it is not possible to link a reply directly with a specific sent message.  However, if you specified `REPLIABLE` in the `from` property, BulkSMS will link any reply to the most recent message sent to a given phone number.
    /// 
    /// The `relatedSentMessageId` property keeps the information about this link.
    /// 
    /// You can use this property to derive an implicit conversation from a set of messages.
    ///   - If a received reply message has a `relatedSentMessageId`, you can use it to retrieve the last message that was sent before the reply was received.
    ///   - If you have the `id` of the sent message and you want all the received messages that relate to it, you can use the List Related Messages Operation.
    public var relatedSentMessageID: String?
    /// This is the value you supplied in the `userSuppliedId` field.
    /// Has a value only if the `type` is SENT.
    public var userSuppliedID: String?

    /// The message direction
    public enum `Type`: String, Codable, CaseIterable {
        case sent = "SENT"
        case received = "RECEIVED"
    }

    /// The type of the content.  See the `encoding` field for more information.
    public enum Encoding: String, Codable, CaseIterable {
        case text = "TEXT"
        case unicode = "UNICODE"
        case binary = "BINARY"
    }

    /// Identifies the submission.
    public struct Submission: Codable {
        /// A unique identity shared by all messages that were created from the same submission. This field should be ignored if the `type` is not SENT.
        public var id: String
        /// The date and time the submission was processed. If the `type` is RECEIVED, this field reflects the date and time the received message was processed.
        public var date: Date

        public init(id: String, date: Date) {
            self.id = id
            self.date = date
        }
    }

    /// The status of the message
    public struct Status: Codable {
        /// A concatenated value A.B where A is the `status.type` and B is the `status.subtype`.  
        /// It there is no value for `subtype` then B takes string value `"null"` (e.g. `"SENT.null"`).
        public var id: String
        /// ACCEPTED  Message accepted for delivery. Only returned for initial message submissions.
        /// 
        /// SCHEDULED  Message accepted for delivery at a later date. Only returned for initial message  submissions.
        /// 
        /// SENT  Message has been relayed away from our systems.
        /// 
        /// DELIVERED  Successfully delivered to phone.
        /// 
        /// UNKNOWN  Message is in an unknown state.
        /// 
        /// FAILED  Delivery failed.
        public var type: `Type`
        /// Has a value only if the `type` is FAILED.
        /// 
        /// EXPIRED  Delivery failed because message expired before delivery was possible.
        /// 
        /// HANDSET_ERROR  Delivery failed because of a problem related to the phone (e.g. message storage area full).
        /// 
        /// BLOCKED  Your account has been blocked from sending to this phone (e.g. recipient replied STOP to block communication).
        /// 
        /// NOT_SENT  Message delivery was not attempted (e.g. because we were not able to find a route for the supplied phone number).
        public var subtype: Subtype?

        /// ACCEPTED  Message accepted for delivery. Only returned for initial message submissions.
        /// 
        /// SCHEDULED  Message accepted for delivery at a later date. Only returned for initial message  submissions.
        /// 
        /// SENT  Message has been relayed away from our systems.
        /// 
        /// DELIVERED  Successfully delivered to phone.
        /// 
        /// UNKNOWN  Message is in an unknown state.
        /// 
        /// FAILED  Delivery failed.
        public enum `Type`: String, Codable, CaseIterable {
            case accepted = "ACCEPTED"
            case scheduled = "SCHEDULED"
            case sent = "SENT"
            case delivered = "DELIVERED"
            case unknown = "UNKNOWN"
            case failed = "FAILED"
        }

        /// Has a value only if the `type` is FAILED.
        /// 
        /// EXPIRED  Delivery failed because message expired before delivery was possible.
        /// 
        /// HANDSET_ERROR  Delivery failed because of a problem related to the phone (e.g. message storage area full).
        /// 
        /// BLOCKED  Your account has been blocked from sending to this phone (e.g. recipient replied STOP to block communication).
        /// 
        /// NOT_SENT  Message delivery was not attempted (e.g. because we were not able to find a route for the supplied phone number).
        public enum Subtype: String, Codable, CaseIterable {
            case expired = "EXPIRED"
            case handsetError = "HANDSET_ERROR"
            case blocked = "BLOCKED"
            case notSent = "NOT_SENT"
        }

        public init(id: String, type: `Type`, subtype: Subtype? = nil) {
            self.id = id
            self.type = type
            self.subtype = subtype
        }
    }

    public init(id: String, type: `Type`, from: String? = nil, to: String, body: [String: AnyJSON], encoding: Encoding? = nil, protocolID: Int? = nil, messageClass: Int? = nil, numberOfParts: Int? = nil, creditCost: Double? = nil, submission: Submission? = nil, status: Status, relatedSentMessageID: String? = nil, userSuppliedID: String? = nil) {
        self.id = id
        self.type = type
        self.from = from
        self.to = to
        self.body = body
        self.encoding = encoding
        self.protocolID = protocolID
        self.messageClass = messageClass
        self.numberOfParts = numberOfParts
        self.creditCost = creditCost
        self.submission = submission
        self.status = status
        self.relatedSentMessageID = relatedSentMessageID
        self.userSuppliedID = userSuppliedID
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case type
        case from
        case to
        case body
        case encoding
        case protocolID = "protocolId"
        case messageClass
        case numberOfParts
        case creditCost
        case submission
        case status
        case relatedSentMessageID = "relatedSentMessageId"
        case userSuppliedID = "userSuppliedId"
    }
}

/// See the [errors page](errors/) for more detail on what kind of errors you can get.
public struct Error: Codable {
    /// A URL to one of the [error types](errors/).
    public var type: String
    /// A short description of the type
    public var title: String
    /// The HTTP status code
    public var status: Int
    /// More information about why the error occurred.
    public var detail: String?

    public init(type: String, title: String, status: Int, detail: String? = nil) {
        self.type = type
        self.title = title
        self.status = status
        self.detail = detail
    }
}

public struct BlockedNumber: Codable {
    /// A unique identifier that is assigned when the BlockedNumber is created.
    ///
    /// Example: 234.0
    public var id: Double
    public var phoneNumber: String

    public init(id: Double, phoneNumber: String) {
        self.id = id
        self.phoneNumber = phoneNumber
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
