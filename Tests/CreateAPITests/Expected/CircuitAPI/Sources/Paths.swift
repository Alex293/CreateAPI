// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var conversations: Conversations {
        Conversations(path: "/conversations")
    }

    public struct Conversations {
        /// Path: `/conversations`
        public let path: String

        /// Gets a list of conversations
        ///
        /// Gets a list of conversations and communities the authenticated user participates in.
        /// OauthScopes: READ_CONVERSATIONS
        public func get(parameters: GetParameters? = nil) -> Request<[CircuitAPI.Conversation]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var modTime: Date?
            public var direction: Direction?
            public var results: Double?

            public enum Direction: String, Codable, CaseIterable {
                case before = "BEFORE"
                case after = "AFTER"
            }

            public init(modTime: Date? = nil, direction: Direction? = nil, results: Double? = nil) {
                self.modTime = modTime
                self.direction = direction
                self.results = results
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(modTime, forKey: "modTime")
                encoder.encode(direction, forKey: "direction")
                encoder.encode(results, forKey: "results")
                return encoder.items
            }
        }
    }
}

extension Paths.Conversations {
    public var byIDs: ByIDs {
        ByIDs(path: path + "/byIds")
    }

    public struct ByIDs {
        /// Path: `/conversations/byIds`
        public let path: String

        /// Gets conversations
        ///
        /// Gets conversation based on the given IDs.
        /// OauthScopes: READ_CONVERSATIONS
        public func get(convIDs: [String]) -> Request<[CircuitAPI.Conversation]> {
            .get(path, query: makeGetQuery(convIDs))
        }

        private func makeGetQuery(_ convIDs: [String]) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(convIDs, forKey: "convIds")
            return encoder.items
        }
    }
}

extension Paths.Conversations {
    public var community: Community {
        Community(path: path + "/community")
    }

    public struct Community {
        /// Path: `/conversations/community`
        public let path: String

        /// Gets a list of communities
        ///
        /// Gets a list of communities. This endpoint can be used to explore the communities the authenticated user could join.
        /// OauthScopes: READ_CONVERSATIONS
        public func get(parameters: GetParameters? = nil) -> Request<[CircuitAPI.Conversation]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var sort: Sort?
            public var order: Order?
            public var isIncludeOwn: Bool?
            public var startIndex: Double?
            public var results: Double?

            public enum Sort: String, Codable, CaseIterable {
                case alphabetically = "ALPHABETICALLY"
                case recentActivity = "RECENT_ACTIVITY"
                case popularity = "POPULARITY"
            }

            public enum Order: String, Codable, CaseIterable {
                case ascending = "ASCENDING"
                case descending = "DESCENDING"
            }

            public init(sort: Sort? = nil, order: Order? = nil, isIncludeOwn: Bool? = nil, startIndex: Double? = nil, results: Double? = nil) {
                self.sort = sort
                self.order = order
                self.isIncludeOwn = isIncludeOwn
                self.startIndex = startIndex
                self.results = results
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(sort, forKey: "sort")
                encoder.encode(order, forKey: "order")
                encoder.encode(isIncludeOwn, forKey: "includeOwn")
                encoder.encode(startIndex, forKey: "startIndex")
                encoder.encode(results, forKey: "results")
                return encoder.items
            }
        }

        /// Creates a community conversation
        ///
        /// Creates a community. Communities are open conversations that anyone in a Circuit domain (tenant) can join without having to be added by another user.
        /// OauthScopes: WRITE_CONVERSATIONS, MANAGE_CONVERSATIONS
        public func post(_ body: PostRequest? = nil) -> Request<CircuitAPI.Conversation> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// An optional description for the community conversation
            public var description: String?
            /// List of participants that will be part of this conversation, specified by the Circuit user ID or the unique email address. At least one participant needs to be added
            public var participants: [String]?
            /// An optional topic of the conversation. If not set the Circuit client will render the names of the participants as topic of the conversation (the first 4 names will be used)
            public var topic: String

            public init(description: String? = nil, participants: [String]? = nil, topic: String) {
                self.description = description
                self.participants = participants
                self.topic = topic
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(description, forKey: "description")
                encoder.encode(participants, forKey: "participants")
                encoder.encode(topic, forKey: "topic")
                return encoder.items
            }
        }
    }
}

extension Paths.Conversations.Community {
    public func convID(_ convID: String) -> WithConvID {
        WithConvID(path: "\(path)/\(convID)")
    }

    public struct WithConvID {
        /// Path: `/conversations/community/{convId}`
        public let path: String

        /// Updates the information of a community
        ///
        /// Updates the information of the given community.
        /// OauthScopes: WRITE_CONVERSATIONS, MANAGE_CONVERSATIONS
        public func put(_ body: PutRequest? = nil) -> Request<CircuitAPI.Conversation> {
            .put(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PutRequest: Encodable {
            /// An optional description for the community conversation
            public var description: String?
            /// An optional topic of the conversation. If not set the Circuit client will render the names of the participants as topic of the conversation (the first 4 names will be used)
            public var topic: String?

            public init(description: String? = nil, topic: String? = nil) {
                self.description = description
                self.topic = topic
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(description, forKey: "description")
                encoder.encode(topic, forKey: "topic")
                return encoder.items
            }
        }
    }
}

extension Paths.Conversations.Community.WithConvID {
    public var join: Join {
        Join(path: path + "/join")
    }

    public struct Join {
        /// Path: `/conversations/community/{convId}/join`
        public let path: String

        /// Adds the authenticated user to a community
        ///
        /// Adds the authenticated user to the given community (i.e., allows the user to join this community). Contrary to the operation of adding a new participant, this operation can only be performed by a user who is not yet a member of the community.
        /// OauthScopes: WRITE_CONVERSATIONS, MANAGE_CONVERSATIONS
        public var post: Request<CircuitAPI.Conversation> {
            .post(path)
        }
    }
}

extension Paths.Conversations.Community.WithConvID {
    public var participants: Participants {
        Participants(path: path + "/participants")
    }

    public struct Participants {
        /// Path: `/conversations/community/{convId}/participants`
        public let path: String

        /// Adds participants to a community
        ///
        /// Adds one or more participants to the given community. This operation can only be performed by a user who is already a member of the community.
        /// OauthScopes: WRITE_CONVERSATIONS, MANAGE_CONVERSATIONS
        public func post(_ body: PostRequest) -> Request<CircuitAPI.Conversation> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The IDs or the unique email addresses of the Circuit users that should to be added.
            public var participants: [String]

            public init(participants: [String]) {
                self.participants = participants
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(participants, forKey: "participants")
                return encoder.items
            }
        }

        /// Removes participants from a community
        ///
        /// Removes one or more participants from the given community. The last participant of a community cannot be removed. This operation can only be performed by a user who is already a member of the community.
        /// OauthScopes: WRITE_CONVERSATIONS, MANAGE_CONVERSATIONS
        public func delete(participants: [String]) -> Request<CircuitAPI.Conversation> {
            .delete(path, query: makeDeleteQuery(participants))
        }

        private func makeDeleteQuery(_ participants: [String]) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(participants, forKey: "participants")
            return encoder.items
        }
    }
}

extension Paths.Conversations {
    public var conversationdetails: Conversationdetails {
        Conversationdetails(path: path + "/conversationdetails")
    }

    public struct Conversationdetails {
        /// Path: `/conversations/conversationdetails`
        public let path: String

        /// Gets the conference details for multiple conversations
        ///
        /// Gets the conference details of the given conversations. Conference details include the URL, which is used to join the conference through a web or mobile application, as well as the dial-in phone numbers and conference PIN, which are used to join the conference by phone.
        /// OauthScopes: READ_CONVERSATIONS
        public func get(convIDs: [String]) -> Request<[CircuitAPI.ConversationDetails]> {
            .get(path, query: makeGetQuery(convIDs))
        }

        private func makeGetQuery(_ convIDs: [String]) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(convIDs, forKey: "convIds")
            return encoder.items
        }
    }
}

extension Paths.Conversations {
    public var direct: Direct {
        Direct(path: path + "/direct")
    }

    public struct Direct {
        /// Path: `/conversations/direct`
        public let path: String

        /// Checks for a 1-to-1 conversation
        ///
        /// Checks if a 1-to-1 conversation between the authenticated user and the user with the provided userId exists.
        /// OauthScopes: READ_CONVERSATIONS
        public func get(participant: String) -> Request<CircuitAPI.Conversation> {
            .get(path, query: [("participant", participant)])
        }

        /// Creates a 1-to-1 conversation
        ///
        /// Creates a 1-to-1 conversation between the authenticated user and the user with the provided userId. In case there is already an existing 1-to-1 conversation between these users, the endpoint returns the existing conversation.
        /// OauthScopes: WRITE_CONVERSATIONS, MANAGE_CONVERSATIONS
        public func post(_ body: PostRequest) -> Request<CircuitAPI.Conversation> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The participant that will be part of this conversation together with the creator, specified by the Circuit user ID or the unique email address
            public var participant: String

            public init(participant: String) {
                self.participant = participant
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(participant, forKey: "participant")
                return encoder.items
            }
        }
    }
}

extension Paths.Conversations {
    public var favorite: Favorite {
        Favorite(path: path + "/favorite")
    }

    public struct Favorite {
        /// Path: `/conversations/favorite`
        public let path: String

        /// Gets favorite conversations
        ///
        /// Gets the conversationIds which are marked as favorites.
        /// OauthScopes: READ_CONVERSATIONS
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Conversations {
    public var group: Group {
        Group(path: path + "/group")
    }

    public struct Group {
        /// Path: `/conversations/group`
        public let path: String

        /// Creates a group conversation
        ///
        /// Creates a group conversation between three or more users. The authenticated user is directly added to this conversation.
        /// OauthScopes: WRITE_CONVERSATIONS, MANAGE_CONVERSATIONS
        public func post(_ body: PostRequest) -> Request<CircuitAPI.Conversation> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A list of participants that will be part of this conversation, specified by the Circuit user ID or the unique email address. At least one participant needs to be added
            public var participants: [String]
            /// An optional topic of the conversation. If not set the Circuit client will render the names of the participants as topic of the conversation (the first 4 names will be used)
            public var topic: String?

            public init(participants: [String], topic: String? = nil) {
                self.participants = participants
                self.topic = topic
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(participants, forKey: "participants")
                encoder.encode(topic, forKey: "topic")
                return encoder.items
            }
        }
    }
}

extension Paths.Conversations.Group {
    public func convID(_ convID: String) -> WithConvID {
        WithConvID(path: "\(path)/\(convID)")
    }

    public struct WithConvID {
        /// Path: `/conversations/group/{convId}`
        public let path: String

        /// Updates the information of a group conversation
        ///
        /// Updates the information of the given group conversation.
        /// OauthScopes: WRITE_CONVERSATIONS, MANAGE_CONVERSATIONS
        public func put(_ body: PutRequest? = nil) -> Request<CircuitAPI.Conversation> {
            .put(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PutRequest: Encodable {
            /// An optional topic of the conversation. If not set the Circuit client will render the names of the participants as topic of the conversation (the first 4 names will be used)
            public var topic: String?

            public init(topic: String? = nil) {
                self.topic = topic
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(topic, forKey: "topic")
                return encoder.items
            }
        }
    }
}

extension Paths.Conversations.Group.WithConvID {
    public var participants: Participants {
        Participants(path: path + "/participants")
    }

    public struct Participants {
        /// Path: `/conversations/group/{convId}/participants`
        public let path: String

        /// Adds participants to a group conversation
        ///
        /// Adds one or more participants to the given group conversation. This operation can only be performed by a user who is already a member of the conversation.
        /// OauthScopes: WRITE_CONVERSATIONS, MANAGE_CONVERSATIONS
        public func post(_ body: PostRequest) -> Request<CircuitAPI.Conversation> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The IDs or the unique email addresses of the Circuit users that should to be added.
            public var participants: [String]

            public init(participants: [String]) {
                self.participants = participants
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(participants, forKey: "participants")
                return encoder.items
            }
        }

        /// Removes participants from a group conversation
        ///
        /// Removes one or more participants from the given group conversation. The last participant of a group conversation cannot be removed. This operation can only be performed on behalf of a user who is already a member of the conversation.
        /// OauthScopes: WRITE_CONVERSATIONS, MANAGE_CONVERSATIONS
        public func delete(participants: [String]) -> Request<CircuitAPI.Conversation> {
            .delete(path, query: makeDeleteQuery(participants))
        }

        private func makeDeleteQuery(_ participants: [String]) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(participants, forKey: "participants")
            return encoder.items
        }
    }
}

extension Paths.Conversations {
    public var label: Label {
        Label(path: path + "/label")
    }

    public struct Label {
        /// Path: `/conversations/label`
        public let path: String
    }
}

extension Paths.Conversations.Label {
    public func labelID(_ labelID: String) -> WithLabelID {
        WithLabelID(path: "\(path)/\(labelID)")
    }

    public struct WithLabelID {
        /// Path: `/conversations/label/{labelId}`
        public let path: String

        /// Returns conversations with a certain label
        ///
        /// Returns conversations with matching labels and paginated 
        /// OauthScopes: READ_CONVERSATIONS
        public func get(nextPagePointer: String? = nil, pageSize: Double? = nil) -> Request<CircuitAPI.ConversationsPage> {
            .get(path, query: makeGetQuery(nextPagePointer, pageSize))
        }

        private func makeGetQuery(_ nextPagePointer: String?, _ pageSize: Double?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(nextPagePointer, forKey: "nextPagePointer")
            encoder.encode(pageSize, forKey: "pageSize")
            return encoder.items
        }
    }
}

extension Paths.Conversations {
    public var messages: Messages {
        Messages(path: path + "/messages")
    }

    public struct Messages {
        /// Path: `/conversations/messages`
        public let path: String
    }
}

extension Paths.Conversations.Messages {
    public var flag: Flag {
        Flag(path: path + "/flag")
    }

    public struct Flag {
        /// Path: `/conversations/messages/flag`
        public let path: String

        /// Gets a list of the flagged messages
        ///
        /// Gets a list of all the messages the authenticated user has flagged. This endpoint should be used carefully in case where the authenticated user has a lot of flagged messages.
        /// OauthScopes: READ_CONVERSATIONS
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Conversations.Messages {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/conversations/messages/{itemId}`
        public let path: String

        /// Returns a text item
        ///
        /// Returns a text item for a given item id
        /// OauthScopes: READ_CONVERSATIONS
        public var get: Request<CircuitAPI.ConversationItem> {
            .get(path)
        }
    }
}

extension Paths.Conversations {
    public var moderate: Moderate {
        Moderate(path: path + "/moderate")
    }

    public struct Moderate {
        /// Path: `/conversations/moderate`
        public let path: String
    }
}

extension Paths.Conversations.Moderate {
    public func convID(_ convID: String) -> WithConvID {
        WithConvID(path: "\(path)/\(convID)")
    }

    public struct WithConvID {
        /// Path: `/conversations/moderate/{convId}`
        public let path: String

        /// Set conversation moderated
        ///
        /// Set a conversation in moderatd mode. Moderators can be added and removed
        /// OauthScopes: WRITE_CONVERSATIONS, MODERATE_CONVERSATIONS
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Conversations {
    public var resolveinvitetoken: Resolveinvitetoken {
        Resolveinvitetoken(path: path + "/resolveinvitetoken")
    }

    public struct Resolveinvitetoken {
        /// Path: `/conversations/resolveinvitetoken`
        public let path: String

        /// Resolves an invite token to a conversation
        ///
        /// Resolves an invite token to a conversation
        /// OauthScopes: READ_CONVERSATIONS
        public func get(token: String) -> Request<CircuitAPI.Conversation> {
            .get(path, query: [("token", token)])
        }
    }
}

extension Paths.Conversations {
    public var search: Search {
        Search(path: path + "/search")
    }

    public struct Search {
        /// Path: `/conversations/search`
        public let path: String

        /// Performs a conversation search
        ///
        /// Performs a search for conversation content. A maximum of 100 conversations is returned. If you hit this limit you should refine the search term.
        /// OauthScopes: READ_CONVERSATIONS
        public func get(parameters: GetParameters) -> Request<CircuitAPI.ConversationSearchResult> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var term: String
            public var isIncludeItemIDs: Bool?
            public var scope: Scope?

            public enum Scope: String, Codable, CaseIterable {
                case files = "FILES"
                case people = "PEOPLE"
                case members = "MEMBERS"
                case messages = "MESSAGES"
                case sentby = "SENTBY"
                case all = "ALL"
                case conversations = "CONVERSATIONS"
                case label = "LABEL"
                case filter = "FILTER"
            }

            public init(term: String, isIncludeItemIDs: Bool? = nil, scope: Scope? = nil) {
                self.term = term
                self.isIncludeItemIDs = isIncludeItemIDs
                self.scope = scope
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(term, forKey: "term")
                encoder.encode(isIncludeItemIDs, forKey: "includeItemIds")
                encoder.encode(scope, forKey: "scope")
                return encoder.items
            }
        }
    }
}

extension Paths.Conversations {
    public var unmoderate: Unmoderate {
        Unmoderate(path: path + "/unmoderate")
    }

    public struct Unmoderate {
        /// Path: `/conversations/unmoderate`
        public let path: String
    }
}

extension Paths.Conversations.Unmoderate {
    public func convID(_ convID: String) -> WithConvID {
        WithConvID(path: "\(path)/\(convID)")
    }

    public struct WithConvID {
        /// Path: `/conversations/unmoderate/{convId}`
        public let path: String

        /// Set conversation unmoderated
        ///
        /// Set a conversation to unmoderatd mode
        /// OauthScopes: WRITE_CONVERSATIONS, MODERATE_CONVERSATIONS
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Conversations {
    public func convID(_ convID: String) -> WithConvID {
        WithConvID(path: "\(path)/\(convID)")
    }

    public struct WithConvID {
        /// Path: `/conversations/{convId}`
        public let path: String

        /// Gets a conversation
        ///
        /// Gets a conversation based on the given ID.
        /// OauthScopes: READ_CONVERSATIONS
        public var get: Request<CircuitAPI.Conversation> {
            .get(path)
        }
    }
}

extension Paths.Conversations.WithConvID {
    public var archive: Archive {
        Archive(path: path + "/archive")
    }

    public struct Archive {
        /// Path: `/conversations/{convId}/archive`
        public let path: String

        /// Archives conversation
        ///
        /// Archives a conversation by muting it
        /// OauthScopes: WRITE_CONVERSATIONS
        public var post: Request<Void> {
            .post(path)
        }

        /// Unmute conversation
        ///
        /// The conversation will no longer be archived but active again
        /// OauthScopes: WRITE_CONVERSATIONS
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Conversations.WithConvID {
    public var conversationdetails: Conversationdetails {
        Conversationdetails(path: path + "/conversationdetails")
    }

    public struct Conversationdetails {
        /// Path: `/conversations/{convId}/conversationdetails`
        public let path: String

        /// Gets the conference details of a conversation
        ///
        /// Gets the conference details of the given conversation. Conference details include the URL, which is used to join the conference through a web or mobile application, as well as the dial-in phone numbers and conference PIN, which are used to join the conference by phone.
        /// OauthScopes: READ_CONVERSATIONS
        public var get: Request<CircuitAPI.ConversationDetails> {
            .get(path)
        }
    }
}

extension Paths.Conversations.WithConvID {
    public var favorite: Favorite {
        Favorite(path: path + "/favorite")
    }

    public struct Favorite {
        /// Path: `/conversations/{convId}/favorite`
        public let path: String

        /// Adds a conversation to the favorites
        ///
        /// Adds a conversation to the favorites. Favorites can be displayed in a separate side tab inside of the Circuit client to have a better overview of important conversations.
        /// OauthScopes: WRITE_CONVERSATIONS
        public var post: Request<Void> {
            .post(path)
        }

        /// Removes a conversation from favorites
        ///
        /// Removes a conversation from favorites. Favorites can be displayed in a separate side tab inside of the Circuit client to have a better overview of important conversations.
        /// OauthScopes: WRITE_CONVERSATIONS
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Conversations.WithConvID {
    public var items: Items {
        Items(path: path + "/items")
    }

    public struct Items {
        /// Path: `/conversations/{convId}/items`
        public let path: String

        /// Gets a list of conversation items
        ///
        /// Gets a list of conversation items.
        /// OauthScopes: READ_CONVERSATIONS
        public func get(parameters: GetParameters? = nil) -> Request<[CircuitAPI.ConversationItem]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var modTime: Date?
            public var direction: Direction?
            public var results: Double?

            public enum Direction: String, Codable, CaseIterable {
                case before = "BEFORE"
                case after = "AFTER"
            }

            public init(modTime: Date? = nil, direction: Direction? = nil, results: Double? = nil) {
                self.modTime = modTime
                self.direction = direction
                self.results = results
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(modTime, forKey: "modTime")
                encoder.encode(direction, forKey: "direction")
                encoder.encode(results, forKey: "results")
                return encoder.items
            }
        }
    }
}

extension Paths.Conversations.WithConvID {
    public var label: Label {
        Label(path: path + "/label")
    }

    public struct Label {
        /// Path: `/conversations/{convId}/label`
        public let path: String

        /// Adds a label to a conversation
        ///
        /// Adds a label to a conversation, you can search and organize your conversations based on these labels
        /// OauthScopes: WRITE_CONVERSATIONS, ORGANIZE_CONVERSATIONS
        public func post(_ body: PostRequest) -> Request<CircuitAPI.Label> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The actual label
            public var label: String

            public init(label: String) {
                self.label = label
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(label, forKey: "label")
                return encoder.items
            }
        }
    }
}

extension Paths.Conversations.WithConvID.Label {
    public func labelID(_ labelID: String) -> WithLabelID {
        WithLabelID(path: "\(path)/\(labelID)")
    }

    public struct WithLabelID {
        /// Path: `/conversations/{convId}/label/{labelId}`
        public let path: String

        /// Removes a label from a conversation
        ///
        /// Removes a label from a conversation, you can search and organize your conversations based on these labels
        /// OauthScopes: WRITE_CONVERSATIONS
        public var delete: Request<CircuitAPI.Label> {
            .delete(path)
        }
    }
}

extension Paths.Conversations.WithConvID {
    public var messages: Messages {
        Messages(path: path + "/messages")
    }

    public struct Messages {
        /// Path: `/conversations/{convId}/messages`
        public let path: String

        /// Adds a message to a conversation
        ///
        /// Adds a message to the given conversation. This operation can be only performed on behalf of a user who is already a member of the conversation.
        /// OauthScopes: WRITE_CONVERSATIONS, CREATE_CONVERSATIONS_CONTENT
        public func post(_ body: PostRequest? = nil) -> Request<CircuitAPI.ConversationItem> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A comma separated list of attachment IDs from the file API.
            public var attachments: [String]?
            /// The actual content of the item, is mandatory unless an attachment is added
            public var content: String?
            /// The form meta data of the new text item
            public var formMetaData: String?
            /// The subject (headline) of the new text item
            public var subject: String?

            public init(attachments: [String]? = nil, content: String? = nil, formMetaData: String? = nil, subject: String? = nil) {
                self.attachments = attachments
                self.content = content
                self.formMetaData = formMetaData
                self.subject = subject
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(attachments, forKey: "attachments")
                encoder.encode(content, forKey: "content")
                encoder.encode(formMetaData, forKey: "formMetaData")
                encoder.encode(subject, forKey: "subject")
                return encoder.items
            }
        }
    }
}

extension Paths.Conversations.WithConvID.Messages {
    public var flag: Flag {
        Flag(path: path + "/flag")
    }

    public struct Flag {
        /// Path: `/conversations/{convId}/messages/flag`
        public let path: String

        /// Gets a list of the flagged messages of a conversation
        ///
        /// Gets a list of all the flagged messages in the given conversation.
        /// OauthScopes: READ_CONVERSATIONS, ORGANIZE_CONVERSATIONS
        public var get: Request<[CircuitAPI.ConversationItem]> {
            .get(path)
        }
    }
}

extension Paths.Conversations.WithConvID.Messages {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/conversations/{convId}/messages/{itemId}`
        public let path: String

        /// Adds a message to an item
        ///
        /// Adds a message to the existing item. The added message will be a child item of the message with the given itemId.
        /// OauthScopes: WRITE_CONVERSATIONS
        public func post(_ body: PostRequest? = nil) -> Request<CircuitAPI.ConversationItem> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A comma separated list of attachment IDs from the file API.
            public var attachments: [String]?
            /// The actual content of the item
            public var content: String?
            /// The form meta data of the new text item
            public var formMetaData: String?
            /// The subject (headline) of the new text item
            public var subject: String?

            public init(attachments: [String]? = nil, content: String? = nil, formMetaData: String? = nil, subject: String? = nil) {
                self.attachments = attachments
                self.content = content
                self.formMetaData = formMetaData
                self.subject = subject
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(attachments, forKey: "attachments")
                encoder.encode(content, forKey: "content")
                encoder.encode(formMetaData, forKey: "formMetaData")
                encoder.encode(subject, forKey: "subject")
                return encoder.items
            }
        }

        /// Updates a message
        ///
        /// Updates the content or subject of the existing message. Only the creator of the message is allowed to perform this operation.
        /// OauthScopes: WRITE_CONVERSATIONS, UPDATE_CONVERSATION_CONTENT
        public func put(_ body: PutRequest? = nil) -> Request<CircuitAPI.ConversationItem> {
            .put(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PutRequest: Encodable {
            /// A comma separated list of attachment IDs from the file API.
            public var attachments: [String]?
            /// The actual content of the item
            public var content: String?
            /// The form meta data of the new text item
            public var formMetaData: String?
            /// The subject (headline) of the new text item
            public var subject: String?

            public init(attachments: [String]? = nil, content: String? = nil, formMetaData: String? = nil, subject: String? = nil) {
                self.attachments = attachments
                self.content = content
                self.formMetaData = formMetaData
                self.subject = subject
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(attachments, forKey: "attachments")
                encoder.encode(content, forKey: "content")
                encoder.encode(formMetaData, forKey: "formMetaData")
                encoder.encode(subject, forKey: "subject")
                return encoder.items
            }
        }

        /// Deletes a message from a conversation
        ///
        /// Marks a message in the given conversation as deleted. Deleted messages are still part of the conversation, but their content is no more visible. This operation can only be performed on behalf of the message's creator.
        /// OauthScopes: WRITE_CONVERSATIONS, DELETE_CONVERSATIONS_CONTENT
        public var delete: Request<CircuitAPI.ConversationItem> {
            .delete(path)
        }
    }
}

extension Paths.Conversations.WithConvID.Messages.WithItemID {
    public var flag: Flag {
        Flag(path: path + "/flag")
    }

    public struct Flag {
        /// Path: `/conversations/{convId}/messages/{itemId}/flag`
        public let path: String

        /// Adds a flag to a message in a conversation
        ///
        /// Adds a flag to the given message in the given conversation.
        /// OauthScopes: WRITE_CONVERSATIONS, ORGANIZE_CONVERSATIONS
        public func post(_ body: PostRequest? = nil) -> Request<Void> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The time when the item was created
            public var itemCreationTime: String?
            /// The ID of the item's parent
            public var parentID: String?

            public init(itemCreationTime: String? = nil, parentID: String? = nil) {
                self.itemCreationTime = itemCreationTime
                self.parentID = parentID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(itemCreationTime, forKey: "itemCreationTime")
                encoder.encode(parentID, forKey: "parentId")
                return encoder.items
            }
        }

        /// Removes the flag from a message
        ///
        /// Removes the flag from a given message that is posted to the given conversation.
        /// OauthScopes: WRITE_CONVERSATIONS, ORGANIZE_CONVERSATIONS
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Conversations.WithConvID.Messages.WithItemID {
    public var like: Like {
        Like(path: path + "/like")
    }

    public struct Like {
        /// Path: `/conversations/{convId}/messages/{itemId}/like`
        public let path: String

        /// Adds a "like" to a message
        ///
        /// Adds a "like" to the given message in the given conversation
        /// OauthScopes: WRITE_CONVERSATIONS, UPDATE_CONVERSATION_CONTENT
        public var post: Request<Void> {
            .post(path)
        }

        /// Removes a "like" from a message
        ///
        /// Removes a "like" from the given message in the given conversation
        /// OauthScopes: WRITE_CONVERSATIONS, UPDATE_CONVERSATION_CONTENT
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Conversations.WithConvID {
    public var moderators: Moderators {
        Moderators(path: path + "/moderators")
    }

    public struct Moderators {
        /// Path: `/conversations/{convId}/moderators`
        public let path: String

        /// Add moderators
        ///
        /// Adds a list of moderators to a conversation
        /// OauthScopes: WRITE_CONVERSATIONS, MANAGE_CONVERSATIONS
        public func post(_ body: PostRequest) -> Request<Void> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The list of moderator ids to add
            public var moderators: [String]

            public init(moderators: [String]) {
                self.moderators = moderators
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(moderators, forKey: "moderators")
                return encoder.items
            }
        }

        /// Remove moderators
        ///
        /// Removes a list of moderators from a conversation
        /// OauthScopes: WRITE_CONVERSATIONS, MODERATE_CONVERSATIONS
        public func delete(_ body: DeleteRequest) -> Request<Void> {
            .delete(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct DeleteRequest: Encodable {
            /// The list of moderator ids to remove
            public var moderators: [String]

            public init(moderators: [String]) {
                self.moderators = moderators
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(moderators, forKey: "moderators")
                return encoder.items
            }
        }
    }
}

extension Paths.Conversations.WithConvID {
    public var participants: Participants {
        Participants(path: path + "/participants")
    }

    public struct Participants {
        /// Path: `/conversations/{convId}/participants`
        public let path: String

        /// Performs a list of participants
        ///
        /// Performs a search for participants. The max number of participants is configurable. If more participants are available a search pointer is returned for consecutive calls.
        /// OauthScopes: READ_CONVERSATIONS
        public func get(parameters: GetParameters) -> Request<[CircuitAPI.ConversationParticipantsList]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var pageSize: Double
            public var name: String?
            public var type: `Type`?
            public var searchPointer: String?

            public enum `Type`: String, Codable, CaseIterable {
                case regular = "REGULAR"
                case moderator = "MODERATOR"
                case guest = "GUEST"
                case former = "FORMER"
                case bot = "BOT"
            }

            public init(pageSize: Double, name: String? = nil, type: `Type`? = nil, searchPointer: String? = nil) {
                self.pageSize = pageSize
                self.name = name
                self.type = type
                self.searchPointer = searchPointer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(pageSize, forKey: "pageSize")
                encoder.encode(name, forKey: "name")
                encoder.encode(type, forKey: "type")
                encoder.encode(searchPointer, forKey: "searchPointer")
                return encoder.items
            }
        }
    }
}

extension Paths.Conversations.WithConvID {
    public var pins: Pins {
        Pins(path: path + "/pins")
    }

    public struct Pins {
        /// Path: `/conversations/{convId}/pins`
        public let path: String

        /// Returns pinned topics of a conversation
        ///
        /// Returns pinned topics of a conversation
        /// OauthScopes: READ_CONVERSATIONS
        public var get: Request<[CircuitAPI.PinnedTopic]> {
            .get(path)
        }
    }
}

extension Paths.Conversations.WithConvID.Pins {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/conversations/{convId}/pins/{itemId}`
        public let path: String

        /// Pins a topic of a conversation
        ///
        /// Pins a topic of a conversation
        /// OauthScopes: READ_CONVERSATIONS
        public var post: Request<CircuitAPI.Conversation> {
            .post(path)
        }

        /// Unpins a topic of a conversation
        ///
        /// Unpins a topic of a conversation
        /// OauthScopes: READ_CONVERSATIONS
        public var delete: Request<CircuitAPI.Conversation> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var rtc: Rtc {
        Rtc(path: "/rtc")
    }

    public struct Rtc {
        /// Path: `/rtc`
        public let path: String
    }
}

extension Paths.Rtc {
    public var sessions: Sessions {
        Sessions(path: path + "/sessions")
    }

    public struct Sessions {
        /// Path: `/rtc/sessions`
        public let path: String

        /// Gets a list of active sessions
        ///
        /// Gets a list of active RTCsessions
        /// OauthScopes: CALLS
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths {
    public static var spaces: Spaces {
        Spaces(path: "/spaces")
    }

    public struct Spaces {
        /// Path: `/spaces`
        public let path: String

        /// Get the spaces
        ///
        /// Get the spaces
        /// OauthScopes: READ_SPACE
        public func get(timestamp: Date? = nil, numberOfResults: Double? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(timestamp, numberOfResults))
        }

        private func makeGetQuery(_ timestamp: Date?, _ numberOfResults: Double?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(timestamp, forKey: "timestamp")
            encoder.encode(numberOfResults, forKey: "numberOfResults")
            return encoder.items
        }
    }
}

extension Paths.Spaces {
    public var create: Create {
        Create(path: path + "/create")
    }

    public struct Create {
        /// Path: `/spaces/create`
        public let path: String

        /// Create a space
        ///
        /// Create a space
        /// OauthScopes: WRITE_SPACE, MANAGE_SPACE, CREATE_SPACE_CONTENT
        public func post(_ body: PostRequest) -> Request<[String: AnyJSON]> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Access mode
            public var accessModeType: AccessModeType
            /// Description of the space
            public var description: String?
            /// Large picture
            public var largePictureBase64: String?
            /// Name of the space
            public var name: String
            /// Role
            public var role: Role
            /// Small picture
            public var smallPictureBase64: String?
            /// Status
            public var status: Status
            /// Tags of the space
            public var tags: [String]?
            /// Type
            public var type: `Type`

            /// Access mode
            public enum AccessModeType: String, Codable, CaseIterable {
                case internalOnly = "INTERNAL_ONLY"
                case internalExternal = "INTERNAL_EXTERNAL"
            }

            /// Role
            public enum Role: String, Codable, CaseIterable {
                case moderator = "MODERATOR"
                case author = "AUTHOR"
                case participant = "PARTICIPANT"
                case reader = "READER"
            }

            /// Status
            public enum Status: String, Codable, CaseIterable {
                case enabled = "ENABLED"
                case disabled = "DISABLED"
            }

            /// Type
            public enum `Type`: String, Codable, CaseIterable {
                case `open` = "OPEN"
                case closed = "CLOSED"
                case secret = "SECRET"
            }

            public init(accessModeType: AccessModeType, description: String? = nil, largePictureBase64: String? = nil, name: String, role: Role, smallPictureBase64: String? = nil, status: Status, tags: [String]? = nil, type: `Type`) {
                self.accessModeType = accessModeType
                self.description = description
                self.largePictureBase64 = largePictureBase64
                self.name = name
                self.role = role
                self.smallPictureBase64 = smallPictureBase64
                self.status = status
                self.tags = tags
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(accessModeType, forKey: "accessModeType")
                encoder.encode(description, forKey: "description")
                encoder.encode(largePictureBase64, forKey: "largePictureBase64")
                encoder.encode(name, forKey: "name")
                encoder.encode(role, forKey: "role")
                encoder.encode(smallPictureBase64, forKey: "smallPictureBase64")
                encoder.encode(status, forKey: "status")
                encoder.encode(tags, forKey: "tags")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces {
    public var directory: Directory {
        Directory(path: path + "/directory")
    }

    public struct Directory {
        /// Path: `/spaces/directory`
        public let path: String

        /// Get the directory
        ///
        /// Get the directory by a search query in ordered way
        /// OauthScopes: READ_SPACE
        public func get(parameters: GetParameters) -> Request<CircuitAPI.DirectoryResult> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var sortBy: SortBy
            public var sortOrder: SortOrder
            public var filter: Filter
            public var query: String?
            public var pagePointer: String?
            public var numberOfResults: Double?

            public enum SortBy: String, Codable, CaseIterable {
                case lastContent = "LAST_CONTENT"
                case name = "NAME"
                case numberOfUsers = "NUMBER_OF_USERS"
                case creationDate = "CREATION_DATE"
            }

            public enum SortOrder: String, Codable, CaseIterable {
                case ascending = "ASCENDING"
                case descending = "DESCENDING"
            }

            public enum Filter: String, Codable, CaseIterable {
                case `none` = "NONE"
                case joined = "JOINED"
                case requested = "REQUESTED"
                case `open` = "OPEN"
                case closed = "CLOSED"
                case notJoinedRequested = "NOT_JOINED_REQUESTED"
            }

            public init(sortBy: SortBy, sortOrder: SortOrder, filter: Filter, query: String? = nil, pagePointer: String? = nil, numberOfResults: Double? = nil) {
                self.sortBy = sortBy
                self.sortOrder = sortOrder
                self.filter = filter
                self.query = query
                self.pagePointer = pagePointer
                self.numberOfResults = numberOfResults
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(sortBy, forKey: "sortBy")
                encoder.encode(sortOrder, forKey: "sortOrder")
                encoder.encode(filter, forKey: "filter")
                encoder.encode(query, forKey: "query")
                encoder.encode(pagePointer, forKey: "pagePointer")
                encoder.encode(numberOfResults, forKey: "numberOfResults")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces {
    public var exists: Exists {
        Exists(path: path + "/exists")
    }

    public struct Exists {
        /// Path: `/spaces/exists`
        public let path: String
    }
}

extension Paths.Spaces.Exists {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/spaces/exists/{name}`
        public let path: String

        /// Space name exists
        ///
        /// Find out if a space name already exists for non-secret spaces.
        /// OauthScopes: READ_SPACE
        public var get: Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Spaces {
    public var flag: Flag {
        Flag(path: path + "/flag")
    }

    public struct Flag {
        /// Path: `/spaces/flag`
        public let path: String
    }
}

extension Paths.Spaces.Flag {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/spaces/flag/{itemId}`
        public let path: String

        /// Flag a space item
        ///
        /// Flag a space item
        /// OauthScopes: WRITE_SPACE, UPDATE_SPACE_CONTENT
        public var put: Request<Void> {
            .put(path)
        }
    }
}

extension Paths.Spaces {
    public var flagged: Flagged {
        Flagged(path: path + "/flagged")
    }

    public struct Flagged {
        /// Path: `/spaces/flagged`
        public let path: String

        /// Get flagged items
        ///
        /// Get flagged items
        /// OauthScopes: READ_SPACE
        public func get(parameters: GetParameters) -> Request<CircuitAPI.FlaggedItemsResult> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var searchDirection: SearchDirection
            public var timestamp: Date
            public var searchPointer: String?
            public var numberOfResults: Double?

            public enum SearchDirection: String, Codable, CaseIterable {
                case before = "BEFORE"
                case after = "AFTER"
            }

            public init(searchDirection: SearchDirection, timestamp: Date, searchPointer: String? = nil, numberOfResults: Double? = nil) {
                self.searchDirection = searchDirection
                self.timestamp = timestamp
                self.searchPointer = searchPointer
                self.numberOfResults = numberOfResults
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(searchDirection, forKey: "searchDirection")
                encoder.encode(timestamp, forKey: "timestamp")
                encoder.encode(searchPointer, forKey: "searchPointer")
                encoder.encode(numberOfResults, forKey: "numberOfResults")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces {
    public var ids: IDs {
        IDs(path: path + "/ids")
    }

    public struct IDs {
        /// Path: `/spaces/ids`
        public let path: String

        /// Get the spaces by their ids
        ///
        /// Get the spaces by their ids
        /// OauthScopes: READ_SPACE
        public func get(ids: [String]) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(ids))
        }

        private func makeGetQuery(_ ids: [String]) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ids, forKey: "ids")
            return encoder.items
        }
    }
}

extension Paths.Spaces {
    public var item: Item {
        Item(path: path + "/item")
    }

    public struct Item {
        /// Path: `/spaces/item`
        public let path: String
    }
}

extension Paths.Spaces.Item {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/spaces/item/{itemId}`
        public let path: String

        /// Deletes a space item
        ///
        /// Deletes a space item
        /// OauthScopes: WRITE_SPACE, DELETE_SPACE_CONTENT
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Spaces {
    public var like: Like {
        Like(path: path + "/like")
    }

    public struct Like {
        /// Path: `/spaces/like`
        public let path: String
    }
}

extension Paths.Spaces.Like {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/spaces/like/{itemId}`
        public let path: String

        /// Like a space item
        ///
        /// Like a space item
        /// OauthScopes: WRITE_SPACE, UPDATE_SPACE_CONTENT
        public var put: Request<Void> {
            .put(path)
        }
    }
}

extension Paths.Spaces {
    public var likes: Likes {
        Likes(path: path + "/likes")
    }

    public struct Likes {
        /// Path: `/spaces/likes`
        public let path: String
    }
}

extension Paths.Spaces.Likes {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/spaces/likes/{itemId}`
        public let path: String

        /// Get the likes of an item
        ///
        /// Get the likes of an item
        /// OauthScopes: READ_SPACE
        public func get(searchPointer: String? = nil, numberOfResults: Double? = nil) -> Request<CircuitAPI.ParticipantsLikeResult> {
            .get(path, query: makeGetQuery(searchPointer, numberOfResults))
        }

        private func makeGetQuery(_ searchPointer: String?, _ numberOfResults: Double?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(searchPointer, forKey: "searchPointer")
            encoder.encode(numberOfResults, forKey: "numberOfResults")
            return encoder.items
        }
    }
}

extension Paths.Spaces {
    public var search: Search {
        Search(path: path + "/search")
    }

    public struct Search {
        /// Path: `/spaces/search`
        public let path: String
    }
}

extension Paths.Spaces.Search {
    public var add: Add {
        Add(path: path + "/add")
    }

    public struct Add {
        /// Path: `/spaces/search/add`
        public let path: String
    }
}

extension Paths.Spaces.Search.Add {
    public var recent: Recent {
        Recent(path: path + "/recent")
    }

    public struct Recent {
        /// Path: `/spaces/search/add/recent`
        public let path: String

        /// Add recent search
        ///
        /// Add recent search of a client to search controller.
        /// OauthScopes: WRITE_SPACE, MANAGE_SPACE, ORGANIZE_SPACE
        public func put(_ body: PutRequest) -> Request<Void> {
            .put(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PutRequest: Encodable {
            /// The end time.
            public var endTime: Date?
            /// The scope of the search.
            public var scope: Scope
            /// The term to search for.
            public var searchTerm: String
            /// The start time.
            public var startTime: Date?

            /// The scope of the search.
            public enum Scope: String, Codable, CaseIterable {
                case all = "ALL"
                case spaces = "SPACES"
                case topicby = "TOPICBY"
                case files = "FILES"
                case tags = "TAGS"
                case labels = "LABELS"
                case date = "DATE"
            }

            public init(endTime: Date? = nil, scope: Scope, searchTerm: String, startTime: Date? = nil) {
                self.endTime = endTime
                self.scope = scope
                self.searchTerm = searchTerm
                self.startTime = startTime
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endTime, forKey: "endTime")
                encoder.encode(scope, forKey: "scope")
                encoder.encode(searchTerm, forKey: "searchTerm")
                encoder.encode(startTime, forKey: "startTime")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces.Search {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/spaces/search/cancel`
        public let path: String
    }
}

extension Paths.Spaces.Search.Cancel {
    public func searchID(_ searchID: String) -> WithSearchID {
        WithSearchID(path: "\(path)/\(searchID)")
    }

    public struct WithSearchID {
        /// Path: `/spaces/search/cancel/{searchId}`
        public let path: String

        /// Cancels a space search of a client.
        ///
        /// Cancels a space search of a client.
        /// OauthScopes: WRITE_SPACE, MANAGE_SPACE
        public var put: Request<Void> {
            .put(path)
        }
    }
}

extension Paths.Spaces.Search {
    public var recent: Recent {
        Recent(path: path + "/recent")
    }

    public struct Recent {
        /// Path: `/spaces/search/recent`
        public let path: String

        /// Retrieve recent space searches
        ///
        /// Retrieve recent space searches for a user.
        /// OauthScopes: READ_SPACE
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Spaces.Search {
    public var startBasic: StartBasic {
        StartBasic(path: path + "/startBasic")
    }

    public struct StartBasic {
        /// Path: `/spaces/search/startBasic`
        public let path: String

        /// Starts a basic search in spaces
        ///
        /// Starts a basic search in spaces
        /// OauthScopes: READ_SPACE
        public func get(parameters: GetParameters) -> Request<CircuitAPI.BasicSearchResult> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var scope: Scope
            public var searchTerm: String
            public var startTime: Date?
            public var endTime: Date?
            public var prioritySpaces: [String]?

            public enum Scope: String, Codable, CaseIterable {
                case all = "ALL"
                case spaces = "SPACES"
                case topicby = "TOPICBY"
                case files = "FILES"
                case tags = "TAGS"
                case labels = "LABELS"
                case date = "DATE"
            }

            public init(scope: Scope, searchTerm: String, startTime: Date? = nil, endTime: Date? = nil, prioritySpaces: [String]? = nil) {
                self.scope = scope
                self.searchTerm = searchTerm
                self.startTime = startTime
                self.endTime = endTime
                self.prioritySpaces = prioritySpaces
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(scope, forKey: "scope")
                encoder.encode(searchTerm, forKey: "searchTerm")
                encoder.encode(startTime, forKey: "startTime")
                encoder.encode(endTime, forKey: "endTime")
                encoder.encode(prioritySpaces, forKey: "prioritySpaces")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces.Search {
    public var startDetailed: StartDetailed {
        StartDetailed(path: path + "/startDetailed")
    }

    public struct StartDetailed {
        /// Path: `/spaces/search/startDetailed`
        public let path: String

        /// Starts a detailed search in a space
        ///
        /// Starts a detailed search in a space
        /// OauthScopes: READ_SPACE
        public func get(parameters: GetParameters) -> Request<[CircuitAPI.SpaceSearchResultDetailedBack]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var scope: Scope
            public var searchTerm: String
            public var startTime: Date?
            public var endTime: Date?
            public var spaceID: String
            public var searchID: String?

            public enum Scope: String, Codable, CaseIterable {
                case all = "ALL"
                case spaces = "SPACES"
                case topicby = "TOPICBY"
                case files = "FILES"
                case tags = "TAGS"
                case labels = "LABELS"
                case date = "DATE"
            }

            public init(scope: Scope, searchTerm: String, startTime: Date? = nil, endTime: Date? = nil, spaceID: String, searchID: String? = nil) {
                self.scope = scope
                self.searchTerm = searchTerm
                self.startTime = startTime
                self.endTime = endTime
                self.spaceID = spaceID
                self.searchID = searchID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(scope, forKey: "scope")
                encoder.encode(searchTerm, forKey: "searchTerm")
                encoder.encode(startTime, forKey: "startTime")
                encoder.encode(endTime, forKey: "endTime")
                encoder.encode(spaceID, forKey: "spaceId")
                encoder.encode(searchID, forKey: "searchId")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces {
    public var topic: Topic {
        Topic(path: path + "/topic")
    }

    public struct Topic {
        /// Path: `/spaces/topic`
        public let path: String
    }
}

extension Paths.Spaces.Topic {
    public func topicID(_ topicID: String) -> WithTopicID {
        WithTopicID(path: "\(path)/\(topicID)")
    }

    public struct WithTopicID {
        /// Path: `/spaces/topic/{topicId}`
        public let path: String
    }
}

extension Paths.Spaces.Topic.WithTopicID {
    public var updateTags: UpdateTags {
        UpdateTags(path: path + "/updateTags")
    }

    public struct UpdateTags {
        /// Path: `/spaces/topic/{topicId}/updateTags`
        public let path: String

        /// Update tags
        ///
        /// Update the tags of a topic  
        /// OauthScopes: WRITE_SPACE, UPDATE_SPACE_CONTENT
        public func put(_ body: PutRequest) -> Request<CircuitAPI.SpaceTopic> {
            .put(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PutRequest: Encodable {
            /// The tags to update
            public var tags: [String]

            public init(tags: [String]) {
                self.tags = tags
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(tags, forKey: "tags")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces {
    public var unflag: Unflag {
        Unflag(path: path + "/unflag")
    }

    public struct Unflag {
        /// Path: `/spaces/unflag`
        public let path: String
    }
}

extension Paths.Spaces.Unflag {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/spaces/unflag/{itemId}`
        public let path: String

        /// Unflag a space item
        ///
        /// Unflag a space item
        /// OauthScopes: WRITE_SPACE, UPDATE_SPACE_CONTENT
        public var put: Request<Void> {
            .put(path)
        }
    }
}

extension Paths.Spaces {
    public var unlike: Unlike {
        Unlike(path: path + "/unlike")
    }

    public struct Unlike {
        /// Path: `/spaces/unlike`
        public let path: String
    }
}

extension Paths.Spaces.Unlike {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/spaces/unlike/{itemId}`
        public let path: String

        /// Unlike a space item
        ///
        /// Unlike a space item
        /// OauthScopes: WRITE_SPACE, UPDATE_SPACE_CONTENT
        public var put: Request<Void> {
            .put(path)
        }
    }
}

extension Paths.Spaces {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/spaces/{id}`
        public let path: String

        /// Update a space
        ///
        /// Update a space
        /// OauthScopes: WRITE_SPACE, UPDATE_SPACE_CONTENT
        public func put(_ body: PutRequest? = nil) -> Request<[String: AnyJSON]> {
            .put(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PutRequest: Encodable {
            /// Access mode
            public var accessModeType: AccessModeType?
            /// Description of the space
            public var description: String?
            /// Large picture
            public var largePictureBase64: String?
            /// Name of the space
            public var name: String?
            /// Ownerid of the space
            public var ownerID: String?
            /// Role
            public var role: Role?
            /// Small picture
            public var smallPictureBase64: String?
            /// Status
            public var status: Status?
            /// Tags of the space
            public var tags: [String]?
            /// Type
            public var type: `Type`?

            /// Access mode
            public enum AccessModeType: String, Codable, CaseIterable {
                case internalOnly = "INTERNAL_ONLY"
                case internalExternal = "INTERNAL_EXTERNAL"
                case noChange = "NO_CHANGE"
            }

            /// Role
            public enum Role: String, Codable, CaseIterable {
                case moderator = "MODERATOR"
                case author = "AUTHOR"
                case participant = "PARTICIPANT"
                case reader = "READER"
                case noChange = "NO_CHANGE"
            }

            /// Status
            public enum Status: String, Codable, CaseIterable {
                case enabled = "ENABLED"
                case disabled = "DISABLED"
            }

            /// Type
            public enum `Type`: String, Codable, CaseIterable {
                case `open` = "OPEN"
                case closed = "CLOSED"
                case secret = "SECRET"
                case noChange = "NO_CHANGE"
            }

            public init(accessModeType: AccessModeType? = nil, description: String? = nil, largePictureBase64: String? = nil, name: String? = nil, ownerID: String? = nil, role: Role? = nil, smallPictureBase64: String? = nil, status: Status? = nil, tags: [String]? = nil, type: `Type`? = nil) {
                self.accessModeType = accessModeType
                self.description = description
                self.largePictureBase64 = largePictureBase64
                self.name = name
                self.ownerID = ownerID
                self.role = role
                self.smallPictureBase64 = smallPictureBase64
                self.status = status
                self.tags = tags
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(accessModeType, forKey: "accessModeType")
                encoder.encode(description, forKey: "description")
                encoder.encode(largePictureBase64, forKey: "largePictureBase64")
                encoder.encode(name, forKey: "name")
                encoder.encode(ownerID, forKey: "ownerId")
                encoder.encode(role, forKey: "role")
                encoder.encode(smallPictureBase64, forKey: "smallPictureBase64")
                encoder.encode(status, forKey: "status")
                encoder.encode(tags, forKey: "tags")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }

        /// Delete a space
        ///
        /// Delete a space
        /// OauthScopes: WRITE_SPACE, MANAGE_SPACE, DELETE_SPACE_CONTENT
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Spaces.WithID {
    public var join: Join {
        Join(path: path + "/join")
    }

    public struct Join {
        /// Path: `/spaces/{id}/join`
        public let path: String

        /// Join a space
        ///
        /// Join a space
        /// OauthScopes: WRITE_SPACE
        public var post: Request<[String: AnyJSON]> {
            .post(path)
        }
    }
}

extension Paths.Spaces.WithID {
    public var labels: Labels {
        Labels(path: path + "/labels")
    }

    public struct Labels {
        /// Path: `/spaces/{id}/labels`
        public let path: String
    }
}

extension Paths.Spaces.WithID.Labels {
    public var assign: Assign {
        Assign(path: path + "/assign")
    }

    public struct Assign {
        /// Path: `/spaces/{id}/labels/assign`
        public let path: String

        /// Assign labels
        ///
        /// Assign labels to space
        /// OauthScopes: WRITE_SPACE, ORGANIZE_SPACE
        public func post(_ body: PostRequest) -> Request<[CircuitAPI.LabelIDs]> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The labels to assign to the space
            public var labels: [String]

            public init(labels: [String]) {
                self.labels = labels
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(labels, forKey: "labels")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces.WithID.Labels {
    public var unassign: Unassign {
        Unassign(path: path + "/unassign")
    }

    public struct Unassign {
        /// Path: `/spaces/{id}/labels/unassign`
        public let path: String

        /// Unassign labels
        ///
        /// Unassign labels from a space
        /// OauthScopes: WRITE_SPACE, ORGANIZE_SPACE
        public func delete(_ body: DeleteRequest) -> Request<[CircuitAPI.LabelIDs]> {
            .delete(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct DeleteRequest: Encodable {
            /// Missing documentation
            public var labelIDs: [String]

            public init(labelIDs: [String]) {
                self.labelIDs = labelIDs
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(labelIDs, forKey: "labelIds")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces.WithID {
    public var leave: Leave {
        Leave(path: path + "/leave")
    }

    public struct Leave {
        /// Path: `/spaces/{id}/leave`
        public let path: String

        /// Leave a space
        ///
        /// Leave a space
        /// OauthScopes: WRITE_SPACE
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Spaces.WithID {
    public var participant: Participant {
        Participant(path: path + "/participant")
    }

    public struct Participant {
        /// Path: `/spaces/{id}/participant`
        public let path: String

        /// Add Participant to Space
        ///
        /// Add a participant to a space
        /// OauthScopes: WRITE_SPACE, MANAGE_SPACE
        public func post(_ body: PostRequest) -> Request<[[String: AnyJSON]]> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The name of the role of the participant
            public var role: Role
            /// The user id of the participant
            public var userID: [String]

            /// The name of the role of the participant
            public enum Role: String, Codable, CaseIterable {
                case `default` = "DEFAULT"
                case moderator = "MODERATOR"
                case author = "AUTHOR"
                case participant = "PARTICIPANT"
                case reader = "READER"
            }

            public init(role: Role, userID: [String]) {
                self.role = role
                self.userID = userID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(role, forKey: "role")
                encoder.encode(userID, forKey: "userId")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces.WithID.Participant {
    public var remove: Remove {
        Remove(path: path + "/remove")
    }

    public struct Remove {
        /// Path: `/spaces/{id}/participant/remove`
        public let path: String

        /// Removes participants from a space
        ///
        /// Removes Participants from a space
        /// OauthScopes: WRITE_SPACE, MANAGE_SPACE, ORGANIZE_SPACE
        public func post(_ body: PostRequest) -> Request<Void> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The ids of the participants to remove
            public var userIDs: [String]

            public init(userIDs: [String]) {
                self.userIDs = userIDs
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(userIDs, forKey: "userIds")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces.WithID {
    public var participants: Participants {
        Participants(path: path + "/participants")
    }

    public struct Participants {
        /// Path: `/spaces/{id}/participants`
        public let path: String

        /// Get the participants of a space
        ///
        /// Get the participants of a space
        /// OauthScopes: READ_SPACE
        public func get(parameters: GetParameters) -> Request<CircuitAPI.ParticipantsSearchResult> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var sortBy: SortBy
            public var sortOrder: SortOrder
            public var filterType: FilterType
            public var filterValue: String?
            public var query: String?
            public var searchPointer: String?
            public var numberOfResults: Double?

            public enum SortBy: String, Codable, CaseIterable {
                case displayName = "DISPLAY_NAME"
                case name = "NAME"
                case firstName = "FIRST_NAME"
            }

            public enum SortOrder: String, Codable, CaseIterable {
                case ascending = "ASCENDING"
                case descending = "DESCENDING"
            }

            public enum FilterType: String, Codable, CaseIterable {
                case `none` = "NONE"
                case accessType = "ACCESS_TYPE"
                case role = "ROLE"
                case state = "STATE"
            }

            public init(sortBy: SortBy, sortOrder: SortOrder, filterType: FilterType, filterValue: String? = nil, query: String? = nil, searchPointer: String? = nil, numberOfResults: Double? = nil) {
                self.sortBy = sortBy
                self.sortOrder = sortOrder
                self.filterType = filterType
                self.filterValue = filterValue
                self.query = query
                self.searchPointer = searchPointer
                self.numberOfResults = numberOfResults
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(sortBy, forKey: "sortBy")
                encoder.encode(sortOrder, forKey: "sortOrder")
                encoder.encode(filterType, forKey: "filterType")
                encoder.encode(filterValue, forKey: "filterValue")
                encoder.encode(query, forKey: "query")
                encoder.encode(searchPointer, forKey: "searchPointer")
                encoder.encode(numberOfResults, forKey: "numberOfResults")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces.WithID.Participants {
    public var pending: Pending {
        Pending(path: path + "/pending")
    }

    public struct Pending {
        /// Path: `/spaces/{id}/participants/pending`
        public let path: String

        /// Get the pending participants of a space
        ///
        /// Get the pending participants of a space
        /// OauthScopes: WRITE_SPACE, MANAGE_SPACE
        public func get(searchPointer: String? = nil, numberOfResults: Double? = nil) -> Request<CircuitAPI.ParticipantsSearchResult> {
            .get(path, query: makeGetQuery(searchPointer, numberOfResults))
        }

        private func makeGetQuery(_ searchPointer: String?, _ numberOfResults: Double?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(searchPointer, forKey: "searchPointer")
            encoder.encode(numberOfResults, forKey: "numberOfResults")
            return encoder.items
        }
    }
}

extension Paths.Spaces.WithID {
    public var pinnedTopics: PinnedTopics {
        PinnedTopics(path: path + "/pinnedTopics")
    }

    public struct PinnedTopics {
        /// Path: `/spaces/{id}/pinnedTopics`
        public let path: String

        /// Retrieve pinned topics
        ///
        /// Retrieve pinned topics of a space
        /// OauthScopes: READ_SPACE
        public var get: Request<[CircuitAPI.SpacePinnedTopic]> {
            .get(path)
        }
    }
}

extension Paths.Spaces.WithID {
    public var searchParticipantsToAdd: SearchParticipantsToAdd {
        SearchParticipantsToAdd(path: path + "/searchParticipantsToAdd")
    }

    public struct SearchParticipantsToAdd {
        /// Path: `/spaces/{id}/searchParticipantsToAdd`
        public let path: String

        /// Finds participants to add to add to a space
        ///
        /// Finds participants to add to a space 
        /// OauthScopes: WRITE_SPACE, MANAGE_SPACE, ORGANIZE_SPACE
        public func get(query: String) -> Request<[CircuitAPI.AddParticipantsSearchResult]> {
            .get(path, query: [("query", query)])
        }
    }
}

extension Paths.Spaces.WithID {
    public var searchSpaceParticipants: SearchSpaceParticipants {
        SearchSpaceParticipants(path: path + "/searchSpaceParticipants")
    }

    public struct SearchSpaceParticipants {
        /// Path: `/spaces/{id}/searchSpaceParticipants`
        public let path: String

        /// Get the participants of a space
        ///
        /// Get the participants of a space
        /// OauthScopes: READ_SPACE
        public func get(query: String) -> Request<[CircuitAPI.ParticipantsSearchResultLarge]> {
            .get(path, query: [("query", query)])
        }
    }
}

extension Paths.Spaces.WithID {
    public var updateTimestamp: UpdateTimestamp {
        UpdateTimestamp(path: path + "/updateTimestamp")
    }

    public struct UpdateTimestamp {
        /// Path: `/spaces/{id}/updateTimestamp`
        public let path: String

        /// Update read timestamp
        ///
        /// Update read timestamp
        /// OauthScopes: READ_SPACE, WRITE_SPACE
        public func put(_ body: PutRequest) -> Request<Void> {
            .put(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PutRequest: Encodable {
            /// The new timestamp
            public var timestamp: Date

            public init(timestamp: Date) {
                self.timestamp = timestamp
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(timestamp, forKey: "timestamp")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces {
    public func spaceID(_ spaceID: String) -> WithSpaceID {
        WithSpaceID(path: "\(path)/\(spaceID)")
    }

    public struct WithSpaceID {
        /// Path: `/spaces/{spaceId}`
        public let path: String
    }
}

extension Paths.Spaces.WithSpaceID {
    public var participant: Participant {
        Participant(path: path + "/participant")
    }

    public struct Participant {
        /// Path: `/spaces/{spaceId}/participant`
        public let path: String

        /// Update participant
        ///
        /// Update participant in space
        /// OauthScopes: WRITE_SPACE, MANAGE_SPACE, ORGANIZE_SPACE
        public func put(_ body: PutRequest) -> Get.Request<Void> {
            .put(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PutRequest: Encodable {
            /// Updated role of participant
            public var role: Role
            /// The id of the participant to update
            public var userID: String

            /// Updated role of participant
            public enum Role: String, Codable, CaseIterable {
                case moderator = "MODERATOR"
                case author = "AUTHOR"
                case participant = "PARTICIPANT"
                case reader = "READER"
            }

            public init(role: Role, userID: String) {
                self.role = role
                self.userID = userID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(role, forKey: "role")
                encoder.encode(userID, forKey: "userId")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces.WithSpaceID.Participant {
    public var `import`: Import {
        Import(path: path + "/import")
    }

    public struct Import {
        /// Path: `/spaces/{spaceId}/participant/import`
        public let path: String

        /// Missing documentation
        ///
        /// Missing documentation
        /// OauthScopes: READ_SPACE
        public var get: Get.Request<CircuitAPI.ParticipantsImportDataResult> {
            .get(path)
        }
    }
}

extension Paths.Spaces.WithSpaceID.Participant {
    public var request: Request {
        Request(path: path + "/request")
    }

    public struct Request {
        /// Path: `/spaces/{spaceId}/participant/request`
        public let path: String

        /// Request access for a space
        ///
        /// Request access for a space
        /// OauthScopes: READ_SPACE
        public func post(_ body: PostRequest? = nil) -> Get.Request<Void> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Reason why the Access has been requested
            public var reason: String?

            public init(reason: String? = nil) {
                self.reason = reason
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(reason, forKey: "reason")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces.WithSpaceID.Participant {
    public func participantID(_ participantID: String) -> WithParticipantID {
        WithParticipantID(path: "\(path)/\(participantID)")
    }

    public struct WithParticipantID {
        /// Path: `/spaces/{spaceId}/participant/{participantId}`
        public let path: String
    }
}

extension Paths.Spaces.WithSpaceID.Participant.WithParticipantID {
    public var deny: Deny {
        Deny(path: path + "/deny")
    }

    public struct Deny {
        /// Path: `/spaces/{spaceId}/participant/{participantId}/deny`
        public let path: String

        /// Deny access for a space
        ///
        /// Deny access for a space
        /// OauthScopes: WRITE_SPACE, MANAGE_SPACE
        public func post(_ body: PostRequest? = nil) -> Get.Request<Void> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Reason why the request has been denied
            public var reason: String?

            public init(reason: String? = nil) {
                self.reason = reason
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(reason, forKey: "reason")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces.WithSpaceID.Participant.WithParticipantID {
    public var grant: Grant {
        Grant(path: path + "/grant")
    }

    public struct Grant {
        /// Path: `/spaces/{spaceId}/participant/{participantId}/grant`
        public let path: String

        /// Grant access for a space
        ///
        /// Grant access for a space
        /// OauthScopes: WRITE_SPACE, MANAGE_SPACE
        public var post: Get.Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Spaces.WithSpaceID {
    public var topic: Topic {
        Topic(path: path + "/topic")
    }

    public struct Topic {
        /// Path: `/spaces/{spaceId}/topic`
        public let path: String

        /// Creates a new space topic
        ///
        /// Creates a new space topic
        /// OauthScopes: WRITE_SPACE, MANAGE_SPACE, CREATE_SPACE_CONTENT
        public func post(_ body: PostRequest) -> Request<CircuitAPI.SpaceTopic> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The attached files
            public var attachments: [String]?
            /// Complex or not
            public var isComplex: Bool?
            /// The content of this topic
            public var content: String?
            /// The content tags
            public var contentTags: [String]?
            /// The formMetaData
            public var formMetaData: String?
            /// A list of mentioned users
            public var mentionedUser: String?
            /// The subject of the topic
            public var subject: String
            /// The tags
            public var tags: [String]?

            public init(attachments: [String]? = nil, isComplex: Bool? = nil, content: String? = nil, contentTags: [String]? = nil, formMetaData: String? = nil, mentionedUser: String? = nil, subject: String, tags: [String]? = nil) {
                self.attachments = attachments
                self.isComplex = isComplex
                self.content = content
                self.contentTags = contentTags
                self.formMetaData = formMetaData
                self.mentionedUser = mentionedUser
                self.subject = subject
                self.tags = tags
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(attachments, forKey: "attachments")
                encoder.encode(isComplex, forKey: "complex")
                encoder.encode(content, forKey: "content")
                encoder.encode(contentTags, forKey: "contentTags")
                encoder.encode(formMetaData, forKey: "formMetaData")
                encoder.encode(mentionedUser, forKey: "mentionedUser")
                encoder.encode(subject, forKey: "subject")
                encoder.encode(tags, forKey: "tags")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces.WithSpaceID.Topic {
    public func topicID(_ topicID: String) -> WithTopicID {
        WithTopicID(path: "\(path)/\(topicID)")
    }

    public struct WithTopicID {
        /// Path: `/spaces/{spaceId}/topic/{topicId}`
        public let path: String

        /// Gets space replies and a topic
        ///
        /// Gets a number of Space replies with a matching topic
        /// OauthScopes: READ_SPACE
        public func get(numberOfReplies: Double? = nil) -> Request<CircuitAPI.SpaceTopicWithReplies> {
            .get(path, query: makeGetQuery(numberOfReplies))
        }

        private func makeGetQuery(_ numberOfReplies: Double?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(numberOfReplies, forKey: "numberOfReplies")
            return encoder.items
        }

        /// Updates a topic
        ///
        /// Updates a topic
        /// OauthScopes: WRITE_SPACE, UPDATE_SPACE_CONTENT
        public func put(_ body: PutRequest? = nil) -> Request<CircuitAPI.SpaceTopic> {
            .put(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PutRequest: Encodable {
            /// The attached files
            public var attachments: [String]?
            /// Complex or not
            public var isComplex: Bool?
            /// Content of the topic
            public var content: String?
            /// The content tags
            public var contentTags: [String]?
            /// FormMetaData to update
            public var formMetaData: String?
            /// The updated mentioned users
            public var mentionedUsers: [String]?
            /// The subject of the topic
            public var subject: String?
            /// The tags
            public var tags: [String]?

            public init(attachments: [String]? = nil, isComplex: Bool? = nil, content: String? = nil, contentTags: [String]? = nil, formMetaData: String? = nil, mentionedUsers: [String]? = nil, subject: String? = nil, tags: [String]? = nil) {
                self.attachments = attachments
                self.isComplex = isComplex
                self.content = content
                self.contentTags = contentTags
                self.formMetaData = formMetaData
                self.mentionedUsers = mentionedUsers
                self.subject = subject
                self.tags = tags
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(attachments, forKey: "attachments")
                encoder.encode(isComplex, forKey: "complex")
                encoder.encode(content, forKey: "content")
                encoder.encode(contentTags, forKey: "contentTags")
                encoder.encode(formMetaData, forKey: "formMetaData")
                encoder.encode(mentionedUsers, forKey: "mentionedUsers")
                encoder.encode(subject, forKey: "subject")
                encoder.encode(tags, forKey: "tags")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces.WithSpaceID.Topic.WithTopicID {
    public var reply: Reply {
        Reply(path: path + "/reply")
    }

    public struct Reply {
        /// Path: `/spaces/{spaceId}/topic/{topicId}/reply`
        public let path: String

        /// Gets space replies
        ///
        /// Gets a number of Space replies
        /// OauthScopes: READ_SPACE
        public func get(parameters: GetParameters) -> Request<CircuitAPI.SpaceReply> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var searchDirection: SearchDirection
            public var timestamp: Date?
            public var numberOfResults: Double?

            public enum SearchDirection: String, Codable, CaseIterable {
                case before = "BEFORE"
                case after = "AFTER"
            }

            public init(searchDirection: SearchDirection, timestamp: Date? = nil, numberOfResults: Double? = nil) {
                self.searchDirection = searchDirection
                self.timestamp = timestamp
                self.numberOfResults = numberOfResults
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(searchDirection, forKey: "searchDirection")
                encoder.encode(timestamp, forKey: "timestamp")
                encoder.encode(numberOfResults, forKey: "numberOfResults")
                return encoder.items
            }
        }

        /// Creates a reply to a topic
        ///
        /// Creates a reply to a topic
        /// OauthScopes: WRITE_SPACE
        public func post(_ body: PostRequest? = nil) -> Request<CircuitAPI.SpaceReply> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The attached files
            public var attachments: [String]?
            /// Complex or not
            public var isComplex: Bool?
            /// Content of the reply
            public var content: String?
            /// FormMetaData used in the reply
            public var formMetaData: String?
            /// The user mentioned in the reply
            public var mentionedUser: String?

            public init(attachments: [String]? = nil, isComplex: Bool? = nil, content: String? = nil, formMetaData: String? = nil, mentionedUser: String? = nil) {
                self.attachments = attachments
                self.isComplex = isComplex
                self.content = content
                self.formMetaData = formMetaData
                self.mentionedUser = mentionedUser
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(attachments, forKey: "attachments")
                encoder.encode(isComplex, forKey: "complex")
                encoder.encode(content, forKey: "content")
                encoder.encode(formMetaData, forKey: "formMetaData")
                encoder.encode(mentionedUser, forKey: "mentionedUser")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces.WithSpaceID.Topic.WithTopicID.Reply {
    public func replyID(_ replyID: String) -> WithReplyID {
        WithReplyID(path: "\(path)/\(replyID)")
    }

    public struct WithReplyID {
        /// Path: `/spaces/{spaceId}/topic/{topicId}/reply/{replyId}`
        public let path: String

        /// Updates a space reply
        ///
        /// Updates a space reply
        /// OauthScopes: WRITE_SPACE, UPDATE_SPACE_CONTENT
        public func put(_ body: PutRequest? = nil) -> Request<CircuitAPI.SpaceReply> {
            .put(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PutRequest: Encodable {
            /// The attached files
            public var attachments: [String]?
            /// Complex or not
            public var isComplex: Bool?
            /// The content of the reply
            public var content: String?
            /// FormMetaData of the reply
            public var formMetaData: String?
            /// The mentioned users in the reply
            public var mentionedUsers: [String]?

            public init(attachments: [String]? = nil, isComplex: Bool? = nil, content: String? = nil, formMetaData: String? = nil, mentionedUsers: [String]? = nil) {
                self.attachments = attachments
                self.isComplex = isComplex
                self.content = content
                self.formMetaData = formMetaData
                self.mentionedUsers = mentionedUsers
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(attachments, forKey: "attachments")
                encoder.encode(isComplex, forKey: "complex")
                encoder.encode(content, forKey: "content")
                encoder.encode(formMetaData, forKey: "formMetaData")
                encoder.encode(mentionedUsers, forKey: "mentionedUsers")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces.WithSpaceID {
    public var topics: Topics {
        Topics(path: path + "/topics")
    }

    public struct Topics {
        /// Path: `/spaces/{spaceId}/topics`
        public let path: String

        /// Gets space topics
        ///
        /// Gets a number of Space topics
        /// OauthScopes: READ_SPACE
        public func get(parameters: GetParameters) -> Request<[CircuitAPI.SpaceTopic]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var searchDirection: SearchDirection
            public var timestamp: Date?
            public var numberOfResults: Double?

            public enum SearchDirection: String, Codable, CaseIterable {
                case before = "BEFORE"
                case after = "AFTER"
            }

            public init(searchDirection: SearchDirection, timestamp: Date? = nil, numberOfResults: Double? = nil) {
                self.searchDirection = searchDirection
                self.timestamp = timestamp
                self.numberOfResults = numberOfResults
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(searchDirection, forKey: "searchDirection")
                encoder.encode(timestamp, forKey: "timestamp")
                encoder.encode(numberOfResults, forKey: "numberOfResults")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces.WithSpaceID {
    public var welcomebox: Welcomebox {
        Welcomebox(path: path + "/welcomebox")
    }

    public struct Welcomebox {
        /// Path: `/spaces/{spaceId}/welcomebox`
        public let path: String
    }
}

extension Paths.Spaces.WithSpaceID.Welcomebox {
    public func content(_ content: String) -> WithContent {
        WithContent(path: "\(path)/\(content)")
    }

    public struct WithContent {
        /// Path: `/spaces/{spaceId}/welcomebox/{content}`
        public let path: String

        /// Update content of welcome box
        ///
        /// Update content of the welcome box of a space
        /// OauthScopes: MANAGE_SPACE, WRITE_SPACE
        public func put(_ body: PutRequest? = nil) -> Request<Void> {
            .put(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PutRequest: Encodable {
            /// True, false, default:false
            public var isDisplayWelcomeBox: Bool

            public init(isDisplayWelcomeBox: Bool? = nil) {
                self.isDisplayWelcomeBox = isDisplayWelcomeBox ?? false
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isDisplayWelcomeBox, forKey: "displayWelcomeBox")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces {
    public func topicID(_ topicID: String) -> WithTopicID {
        WithTopicID(path: "\(path)/\(topicID)")
    }

    public struct WithTopicID {
        /// Path: `/spaces/{topicId}`
        public let path: String
    }
}

extension Paths.Spaces.WithTopicID {
    public var pin: Pin {
        Pin(path: path + "/pin")
    }

    public struct Pin {
        /// Path: `/spaces/{topicId}/pin`
        public let path: String

        /// Pin a topic
        ///
        /// Pin a topic
        /// OauthScopes: WRITE_SPACE, MANAGE_SPACE
        public func put(_ body: PutRequest) -> Request<Void> {
            .put(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PutRequest: Encodable {
            /// The position to pin to
            public var position: Double

            public init(position: Double) {
                self.position = position
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(position, forKey: "position")
                return encoder.items
            }
        }
    }
}

extension Paths.Spaces.WithTopicID {
    public var unpin: Unpin {
        Unpin(path: path + "/unpin")
    }

    public struct Unpin {
        /// Path: `/spaces/{topicId}/unpin`
        public let path: String

        /// Unpin a topic
        ///
        /// Unpin a topic
        /// OauthScopes: WRITE_SPACE, MANAGE_SPACE
        public var put: Request<Void> {
            .put(path)
        }
    }
}

extension Paths {
    public static var telephony: Telephony {
        Telephony(path: "/telephony")
    }

    public struct Telephony {
        /// Path: `/telephony`
        public let path: String
    }
}

extension Paths.Telephony {
    public var deviceInfos: DeviceInfos {
        DeviceInfos(path: path + "/deviceInfos")
    }

    public struct DeviceInfos {
        /// Path: `/telephony/deviceInfos`
        public let path: String

        /// Get devices infos
        ///
        /// Get the device infos of the requesting user
        /// OauthScopes: READ_USER_PROFILE
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Telephony {
    public var telephonyConversationID: TelephonyConversationID {
        TelephonyConversationID(path: path + "/telephonyConversationId")
    }

    public struct TelephonyConversationID {
        /// Path: `/telephony/telephonyConversationId`
        public let path: String

        /// Get telephony conversation id
        ///
        /// Get telephony conversation id for requesting client
        /// OauthScopes: READ_CONVERSATIONS
        public var get: Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Telephony {
    public func telephonyConversationID(_ telephonyConversationID: String) -> WithTelephonyConversationID {
        WithTelephonyConversationID(path: "\(path)/\(telephonyConversationID)")
    }

    public struct WithTelephonyConversationID {
        /// Path: `/telephony/{telephonyConversationId}`
        public let path: String
    }
}

extension Paths.Telephony.WithTelephonyConversationID {
    public var journal: Journal {
        Journal(path: path + "/journal")
    }

    public struct Journal {
        /// Path: `/telephony/{telephonyConversationId}/journal`
        public let path: String

        /// Get journal
        ///
        /// Get telephony journal
        /// OauthScopes: READ_CONVERSATIONS
        public func get(parameters: GetParameters? = nil) -> Request<[CircuitAPI.ConversationItem]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var timestamp: Double?
            public var numberOfEntries: Double?
            public var direction: Direction?
            public var journalFilter: JournalFilter?

            public enum Direction: String, Codable, CaseIterable {
                case after = "AFTER"
                case before = "BEFORE"
                case both = "BOTH"
            }

            public enum JournalFilter: String, Codable, CaseIterable {
                case all = "ALL"
                case missed = "MISSED"
                case dialed = "DIALED"
                case received = "RECEIVED"
                case diverted = "DIVERTED"
                case voicemails = "VOICEMAILS"
                case unheradVoicemails = "UNHERAD_VOICEMAILS"
            }

            public init(timestamp: Double? = nil, numberOfEntries: Double? = nil, direction: Direction? = nil, journalFilter: JournalFilter? = nil) {
                self.timestamp = timestamp
                self.numberOfEntries = numberOfEntries
                self.direction = direction
                self.journalFilter = journalFilter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(timestamp, forKey: "timestamp")
                encoder.encode(numberOfEntries, forKey: "numberOfEntries")
                encoder.encode(direction, forKey: "direction")
                encoder.encode(journalFilter, forKey: "journalFilter")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var users: Users {
        Users(path: "/users")
    }

    public struct Users {
        /// Path: `/users`
        public let path: String

        /// Search for users
        ///
        /// Search for users based on an email address or username
        /// OauthScopes: READ_USER
        public func get(name: String) -> Request<[CircuitAPI.User]> {
            .get(path, query: [("name", name)])
        }
    }
}

extension Paths.Users {
    public var labels: Labels {
        Labels(path: path + "/labels")
    }

    public struct Labels {
        /// Path: `/users/labels`
        public let path: String

        /// Returns all user labels
        ///
        /// Returns all labels of the user that were defined either explicit or implicit via assignment to conversations.
        /// OauthScopes: READ_USER_PROFILE, ORGANIZE_CONVERSATIONS
        public var get: Request<Data> {
            .get(path)
        }

        /// Add a user label
        ///
        /// Add a label to the list of user labels
        /// OauthScopes: WRITE_USER_PROFILE, ORGANIZE_CONVERSATIONS
        public func post(_ body: PostRequest) -> Request<CircuitAPI.Label> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The label value to add
            public var label: String

            public init(label: String) {
                self.label = label
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(label, forKey: "label")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.Labels {
    public func labelID(_ labelID: String) -> WithLabelID {
        WithLabelID(path: "\(path)/\(labelID)")
    }

    public struct WithLabelID {
        /// Path: `/users/labels/{labelId}`
        public let path: String

        /// Remove a user label
        ///
        /// Remove a label from the list of user labels
        /// OauthScopes: WRITE_USER_PROFILE, ORGANIZE_CONVERSATIONS
        public var delete: Request<CircuitAPI.Label> {
            .delete(path)
        }
    }
}

extension Paths.Users {
    public var list: List {
        List(path: path + "/list")
    }

    public struct List {
        /// Path: `/users/list`
        public let path: String

        /// Search multiple users.
        ///
        /// Search multiple users given by id or email address.
        /// OauthScopes: READ_USER
        public func get(parameters: GetParameters) -> Request<[CircuitAPI.User]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var name: [String]
            public var isReturnFullUserInfo: Bool?
            public var isSecondaryLookup: Bool?

            public init(name: [String], isReturnFullUserInfo: Bool? = nil, isSecondaryLookup: Bool? = nil) {
                self.name = name
                self.isReturnFullUserInfo = isReturnFullUserInfo
                self.isSecondaryLookup = isSecondaryLookup
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(name, forKey: "name")
                encoder.encode(isReturnFullUserInfo, forKey: "returnFullUserInfo")
                encoder.encode(isSecondaryLookup, forKey: "secondaryLookup")
                return encoder.items
            }
        }
    }
}

extension Paths.Users {
    public var presence: Presence {
        Presence(path: path + "/presence")
    }

    public struct Presence {
        /// Path: `/users/presence`
        public let path: String

        /// Gets the presence status
        ///
        /// Gets the presence status of the users whose IDs or email addresses are given.
        /// OauthScopes: READ_USER
        public func get(userIDs: [String]) -> Request<[CircuitAPI.Presence]> {
            .get(path, query: makeGetQuery(userIDs))
        }

        private func makeGetQuery(_ userIDs: [String]) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userIDs, forKey: "userIds")
            return encoder.items
        }

        /// Updates the presence status
        ///
        /// Updates the presence status of the authenticated user.
        /// OauthScopes: WRITE_USER_PROFILE, MANAGE_PRESENCE
        public func put(_ body: PutRequest) -> Request<CircuitAPI.Presence> {
            .put(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PutRequest: Encodable {
            /// Clear the DND of the user.
            public var isClearDND: Bool
            /// Timestamp until the DND state of the user is active. This field is mandatory when the state is set to DND.
            public var dndUntil: Date?
            /// The user's presence.
            public var state: String
            /// An optional status message that is displayed instead of the location
            public var statusMessage: String?

            public init(isClearDND: Bool? = nil, dndUntil: Date? = nil, state: String, statusMessage: String? = nil) {
                self.isClearDND = isClearDND ?? false
                self.dndUntil = dndUntil
                self.state = state
                self.statusMessage = statusMessage
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isClearDND, forKey: "clearDND")
                encoder.encode(dndUntil, forKey: "dndUntil")
                encoder.encode(state, forKey: "state")
                encoder.encode(statusMessage, forKey: "statusMessage")
                return encoder.items
            }
        }
    }
}

extension Paths.Users {
    public var profile: Profile {
        Profile(path: path + "/profile")
    }

    public struct Profile {
        /// Path: `/users/profile`
        public let path: String

        /// Gets the authenticated user's profile information
        ///
        /// Gets the authenticated user's profile information.
        /// OauthScopes: READ_USER_PROFILE
        public var get: Request<Data> {
            .get(path)
        }

        /// Updates the user profile
        ///
        /// Updates the user profile of the authenticated user
        /// OauthScopes: WRITE_USER_PROFILE
        public func put(_ body: PutRequest? = nil) -> Request<CircuitAPI.User> {
            .put(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PutRequest: Encodable {
            /// The new firstname of the user
            public var firstname: String?
            /// The new job title of the user
            public var jobTitle: String?
            /// The new lastname of the user
            public var lastname: String?
            /// The new locale of the user. One of EN_US, DE_DE, EN_GB, ES_ES, FR_FR, IT_IT, RU_RU, ZH_HANS_CN.
            public var locale: Locale?

            /// The new locale of the user. One of EN_US, DE_DE, EN_GB, ES_ES, FR_FR, IT_IT, RU_RU, ZH_HANS_CN.
            public enum Locale: String, Codable, CaseIterable {
                case enUs = "EN_US"
                case deDe = "DE_DE"
                case enGb = "EN_GB"
                case esEs = "ES_ES"
                case frFr = "FR_FR"
                case itIt = "IT_IT"
                case ruRu = "RU_RU"
                case zhHansCn = "ZH_HANS_CN"
                case ptBr = "PT_BR"
                case nlNl = "NL_NL"
                case caEs = "CA_ES"
            }

            public init(firstname: String? = nil, jobTitle: String? = nil, lastname: String? = nil, locale: Locale? = nil) {
                self.firstname = firstname
                self.jobTitle = jobTitle
                self.lastname = lastname
                self.locale = locale
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(firstname, forKey: "firstname")
                encoder.encode(jobTitle, forKey: "jobTitle")
                encoder.encode(lastname, forKey: "lastname")
                encoder.encode(locale, forKey: "locale")
                return encoder.items
            }
        }
    }
}

extension Paths.Users {
    public var supportinfo: Supportinfo {
        Supportinfo(path: path + "/supportinfo")
    }

    public struct Supportinfo {
        /// Path: `/users/supportinfo`
        public let path: String

        /// Gets the support information
        ///
        /// Gets the support information for the tenant of the requesting user
        /// OauthScopes: READ_USER_PROFILE
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Users {
    public func emailAddress(_ emailAddress: String) -> WithEmailAddress {
        WithEmailAddress(path: "\(path)/\(emailAddress)")
    }

    public struct WithEmailAddress {
        /// Path: `/users/{emailAddress}`
        public let path: String
    }
}

extension Paths.Users.WithEmailAddress {
    public var getUserByEmail: GetUserByEmail {
        GetUserByEmail(path: path + "/getUserByEmail")
    }

    public struct GetUserByEmail {
        /// Path: `/users/{emailAddress}/getUserByEmail`
        public let path: String

        /// Get user by email
        ///
        /// Get user by first or secondary email address
        /// OauthScopes: READ_USER_PROFILE
        public func get(isSecondaryLookup: Bool? = nil) -> Request<CircuitAPI.User> {
            .get(path, query: makeGetQuery(isSecondaryLookup))
        }

        private func makeGetQuery(_ isSecondaryLookup: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isSecondaryLookup, forKey: "secondaryLookup")
            return encoder.items
        }
    }
}

extension Paths.Users {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/users/{id}`
        public let path: String

        /// Gets the user's profile information
        ///
        /// Gets the profile information of the user with the given ID.
        /// OauthScopes: READ_USER
        public var get: Request<CircuitAPI.User> {
            .get(path)
        }
    }
}

extension Paths.Users.WithID {
    public var presence: Presence {
        Presence(path: path + "/presence")
    }

    public struct Presence {
        /// Path: `/users/{id}/presence`
        public let path: String

        /// Gets the presence status
        ///
        /// Gets the presence status of the users whose ID or email address is given.
        /// OauthScopes: READ_USER
        public var get: Request<CircuitAPI.Presence> {
            .get(path)
        }
    }
}

extension Paths {
    public static var webhooks: Webhooks {
        Webhooks(path: "/webhooks")
    }

    public struct Webhooks {
        /// Path: `/webhooks`
        public let path: String

        /// Gets a list of webHooks
        ///
        /// Gets the list of webHooks registered for this user or API.
        /// OauthScopes: READ_CONVERSATIONS, READ_USER
        public var get: Request<Data> {
            .get(path)
        }

        /// Registers a WebHook
        ///
        /// Registers the webHook with the given filter and callback URL.
        /// OauthScopes: READ_CONVERSATIONS, READ_USER
        public func post(_ body: PostRequest) -> Request<CircuitAPI.WebHook> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A filter for WebHooks that checks for a list of configured events. This filter will use a regular expression to determine if it is interested in the events or not. The event itself is converted into a string of format AREA.EVENT. Examples: CONVERSATION.CREATE / USER.UPDATE
            public var filter: [FilterItem]
            /// WebHook callback URL
            public var url: String

            public enum FilterItem: String, Codable, CaseIterable {
                case conversationCreate = "CONVERSATION.CREATE"
                case conversationUpdate = "CONVERSATION.UPDATE"
                case conversationAddItem = "CONVERSATION.ADD_ITEM"
                case conversationUpdateItem = "CONVERSATION.UPDATE_ITEM"
                case userIncomingCall = "USER.INCOMING_CALL"
                case userUserUpdated = "USER.USER_UPDATED"
                case userUserSettingUpdated = "USER.USER_SETTING_UPDATED"
                case userSubmitFormData = "USER.SUBMIT_FORM_DATA"
            }

            public init(filter: [FilterItem], url: String) {
                self.filter = filter
                self.url = url
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(filter, forKey: "filter")
                encoder.encode(url, forKey: "url")
                return encoder.items
            }
        }

        /// Removes all webHooks
        ///
        /// Unregisters all webHooks of the authenticated user
        /// OauthScopes: READ_CONVERSATIONS, READ_USER
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Webhooks {
    public var incoming: Incoming {
        Incoming(path: path + "/incoming")
    }

    public struct Incoming {
        /// Path: `/webhooks/incoming`
        public let path: String
    }
}

extension Paths.Webhooks.Incoming {
    public var create: Create {
        Create(path: path + "/create")
    }

    public struct Create {
        /// Path: `/webhooks/incoming/create`
        public let path: String
    }
}

extension Paths.Webhooks.Incoming.Create {
    public func conversationID(_ conversationID: String) -> WithConversationID {
        WithConversationID(path: "\(path)/\(conversationID)")
    }

    public struct WithConversationID {
        /// Path: `/webhooks/incoming/create/{conversationId}`
        public let path: String

        /// Create a new webhook for existing conversation.
        ///
        /// Create a new webhook. Conversation must exist and creater has to be participant.
        /// OauthScopes: WRITE_CONVERSATIONS, MANAGE_CONVERSATIONS
        public func post(parameters: PostParameters? = nil) -> Request<CircuitAPI.IncomingWebhook> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            public var name: String?
            public var userID: String?
            public var description: String?

            public init(name: String? = nil, userID: String? = nil, description: String? = nil) {
                self.name = name
                self.userID = userID
                self.description = description
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(name, forKey: "name")
                encoder.encode(userID, forKey: "userId")
                encoder.encode(description, forKey: "description")
                return encoder.items
            }
        }
    }
}

extension Paths.Webhooks.Incoming {
    public var user: User {
        User(path: path + "/user")
    }

    public struct User {
        /// Path: `/webhooks/incoming/user`
        public let path: String
    }
}

extension Paths.Webhooks.Incoming.User {
    public func userID(_ userID: String) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/webhooks/incoming/user/{userId}`
        public let path: String

        /// Get all webhooks of a special user.
        ///
        /// Get all webhooks of a special user.
        /// OauthScopes: READ_CONVERSATIONS, MANAGE_CONVERSATIONS
        public func get(pagesize: Double? = nil, searchpointer: String? = nil) -> Request<[CircuitAPI.IncomingWebhook]> {
            .get(path, query: makeGetQuery(pagesize, searchpointer))
        }

        private func makeGetQuery(_ pagesize: Double?, _ searchpointer: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(pagesize, forKey: "pagesize")
            encoder.encode(searchpointer, forKey: "searchpointer")
            return encoder.items
        }
    }
}

extension Paths.Webhooks.Incoming {
    public func webhookID(_ webhookID: String) -> WithWebhookID {
        WithWebhookID(path: "\(path)/\(webhookID)")
    }

    public struct WithWebhookID {
        /// Path: `/webhooks/incoming/{webhookId}`
        public let path: String

        /// Post text item for conversation via webhook.
        ///
        /// Post text items to conversations via slack apps.
        public func post(_ body: CircuitAPI.IncomingWebhookSlackMessage) -> Request<Void> {
            .post(path, body: body)
        }

        /// Delete an existing webhook
        ///
        /// Delete a new webhook. Webhook must exist
        /// OauthScopes: WRITE_CONVERSATIONS, MANAGE_CONVERSATIONS
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Webhooks {
    public var presence: Presence {
        Presence(path: path + "/presence")
    }

    public struct Presence {
        /// Path: `/webhooks/presence`
        public let path: String

        /// Registers Presence WebHook registration
        ///
        /// Registers a webHook that has a presence filter with the given URL and userIds. There is a maximum number of userIds allowed
        /// OauthScopes: READ_USER
        public func post(_ body: PostRequest) -> Request<CircuitAPI.WebHook> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// WebHook callback URL
            public var url: String
            /// The IDs of the users to subscribe for their presence
            public var userIDs: [String]

            public init(url: String, userIDs: [String]) {
                self.url = url
                self.userIDs = userIDs
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(url, forKey: "url")
                encoder.encode(userIDs, forKey: "userIds")
                return encoder.items
            }
        }
    }
}

extension Paths.Webhooks.Presence {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/webhooks/presence/{id}`
        public let path: String

        /// Updates a Presence WebHook registration
        ///
        /// Updates a registration of a webHook that has a presence filter. The update can be performed either on the URL and/or the userIds. The new userIds, if any, will override any existing userIds.
        /// OauthScopes: READ_USER
        public func put(_ body: PutRequest? = nil) -> Request<CircuitAPI.WebHook> {
            .put(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PutRequest: Encodable {
            /// WebHook callback URL
            public var url: String?
            /// The IDs of the users to subscribe for their presence
            public var userIDs: [String]?

            public init(url: String? = nil, userIDs: [String]? = nil) {
                self.url = url
                self.userIDs = userIDs
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(url, forKey: "url")
                encoder.encode(userIDs, forKey: "userIds")
                return encoder.items
            }
        }
    }
}

extension Paths.Webhooks {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/webhooks/{id}`
        public let path: String

        /// Gets a webHook
        ///
        /// Gets the registered webHook with the given ID.
        /// OauthScopes: READ_CONVERSATIONS, READ_USER
        public var get: Request<CircuitAPI.WebHook> {
            .get(path)
        }

        /// Updates a WebHook registration
        ///
        /// Updates a webHook registration with the given filter and callback URL.
        /// OauthScopes: READ_CONVERSATIONS, READ_USER
        public func put(_ body: PutRequest? = nil) -> Request<CircuitAPI.WebHook> {
            .put(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PutRequest: Encodable {
            /// A filter for WebHooks that checks for a list of configured events. This filter will use a regular expression to determine if it is interested in the events or not. The event itself is converted into a string of format AREA.EVENT. Examples: CONVERSATION.CREATE / USER.UPDATE
            public var filter: [FilterItem]?
            /// WebHook callback URL
            public var url: String?

            public enum FilterItem: String, Codable, CaseIterable {
                case conversationCreate = "CONVERSATION.CREATE"
                case conversationUpdate = "CONVERSATION.UPDATE"
                case conversationAddItem = "CONVERSATION.ADD_ITEM"
                case conversationUpdateItem = "CONVERSATION.UPDATE_ITEM"
                case userIncomingCall = "USER.INCOMING_CALL"
                case userUserUpdated = "USER.USER_UPDATED"
                case userUserSettingUpdated = "USER.USER_SETTING_UPDATED"
                case userSubmitFormData = "USER.SUBMIT_FORM_DATA"
            }

            public init(filter: [FilterItem]? = nil, url: String? = nil) {
                self.filter = filter
                self.url = url
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(filter, forKey: "filter")
                encoder.encode(url, forKey: "url")
                return encoder.items
            }
        }

        /// Removes a registered webHook
        ///
        /// Unregisters the webHook with the given ID.
        /// OauthScopes: READ_CONVERSATIONS, READ_USER
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

public enum Paths {}
