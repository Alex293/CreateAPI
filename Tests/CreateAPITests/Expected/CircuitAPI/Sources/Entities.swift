// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

public struct AddParticipantsSearchResult: Codable {
    /// The department of the participant
    public var department: String?
    /// The first name of the participant
    public var firstName: String?
    /// Is the participant a member, true or false
    public var isMember: Bool?
    /// The job title of the participant
    public var jobTitle: String?
    /// The last name of the participant
    public var lastName: String?
    /// The uri of the small picture of the participant
    public var smallImageUri: String?
    /// The tenant id of the participant
    public var tenantID: String?
    /// The id of the participant
    public var userID: String?

    public init(department: String? = nil, firstName: String? = nil, isMember: Bool? = nil, jobTitle: String? = nil, lastName: String? = nil, smallImageUri: String? = nil, tenantID: String? = nil, userID: String? = nil) {
        self.department = department
        self.firstName = firstName
        self.isMember = isMember
        self.jobTitle = jobTitle
        self.lastName = lastName
        self.smallImageUri = smallImageUri
        self.tenantID = tenantID
        self.userID = userID
    }

    private enum CodingKeys: String, CodingKey {
        case department
        case firstName
        case isMember
        case jobTitle
        case lastName
        case smallImageUri
        case tenantID = "tenantId"
        case userID = "userId"
    }
}

public struct Attachment: Codable {
    /// The creation time of the attachment.
    public var creationTime: Double?
    /// The id of the creator of the attachment.
    public var creatorID: String?
    /// The delete URL of the attachment.
    public var deleteURL: String?
    /// The id of the attachment file.
    public var fileID: String?
    /// The name of the attachment file.
    public var fileName: String?
    /// The item id to which the attachment is attached.
    public var itemID: String?
    /// The mime type of the attachment file.
    public var mimeType: String?
    /// The modification time of the attachment.
    public var modificationTime: Double?
    /// The size of the attachment file.
    public var size: Double?
    /// The URL of the attachment.
    public var url: String?

    public init(creationTime: Double? = nil, creatorID: String? = nil, deleteURL: String? = nil, fileID: String? = nil, fileName: String? = nil, itemID: String? = nil, mimeType: String? = nil, modificationTime: Double? = nil, size: Double? = nil, url: String? = nil) {
        self.creationTime = creationTime
        self.creatorID = creatorID
        self.deleteURL = deleteURL
        self.fileID = fileID
        self.fileName = fileName
        self.itemID = itemID
        self.mimeType = mimeType
        self.modificationTime = modificationTime
        self.size = size
        self.url = url
    }

    private enum CodingKeys: String, CodingKey {
        case creationTime
        case creatorID = "creatorId"
        case deleteURL = "deleteUrl"
        case fileID = "fileId"
        case fileName
        case itemID = "itemId"
        case mimeType
        case modificationTime
        case size
        case url
    }
}

public struct BasicSearchResult: Codable {
    /// List of spaces
    public var spaces: [Space]?
    /// The status of the search (NORESULT, ERROR, TIMEOUT, MORERESULT)
    public var status: String?

    public init(spaces: [Space]? = nil, status: String? = nil) {
        self.spaces = spaces
        self.status = status
    }
}

public struct BridgeNumber: Codable {
    /// The number that has to be called to join the real time session of a conversation
    public var bridgeNumber: String?
    /// The country where the bridge is hosted
    public var country: String?
    /// Is most used
    public var isMostUsed: Bool?
    /// The locale of the bridge
    public var locale: String?
    /// The name / identifier of the bridge
    public var name: String?
    /// Information of the billing for the call, i.e. if the caller has to pay or not for the call
    public var type: String?

    public init(bridgeNumber: String? = nil, country: String? = nil, isMostUsed: Bool? = nil, locale: String? = nil, name: String? = nil, type: String? = nil) {
        self.bridgeNumber = bridgeNumber
        self.country = country
        self.isMostUsed = isMostUsed
        self.locale = locale
        self.name = name
        self.type = type
    }
}

public struct Conversation: Codable {
    /// The URL of the small avatar image of the conversation
    public var avatar: String?
    /// The URL of the large avatar image of the conversation
    public var avatarLarge: String?
    /// The ID of the conversation
    public var convID: String?
    /// UTC timestamp when the conversation was created
    public var creationTime: Double?
    /// The ID of the user who created the conversation
    public var creatorID: String?
    /// The ID of the Circuit domain (tenant) where the creator of the conversation belongs to
    public var creatorTenantID: String?
    /// The description of the conversation. This field is available only for conversations with type COMMUNITY
    public var description: String?
    /// Indicates whether guest access to the conversation is disabled or not
    public var isGuestAccessDisabled: Bool?
    /// Indicates whether the conversation is moderated or not. In a moderated conversation only participants who have been assigned the role of a moderator are allowed to add or remove participants into the conversation
    public var isModerated: Bool?
    /// UTC timestamp when the conversation was modified. A conversation is modified when any of the conversation object fields change but not when conversation items are added or edited
    public var modificationTime: Double?
    /// Array of active participants
    public var participants: [String]?
    /// The title of the conversation. Conversations of type DIRECT cannot have a title
    public var topic: String?
    /// The title of the conversation. Conversations of type DIRECT cannot have a title
    public var topicPlaceholder: String?
    /// The type of the conversation. It can be one of the following: DIRECT, GROUP, COMMUNITY or LARGE
    public var type: String?

    public init(avatar: String? = nil, avatarLarge: String? = nil, convID: String? = nil, creationTime: Double? = nil, creatorID: String? = nil, creatorTenantID: String? = nil, description: String? = nil, isGuestAccessDisabled: Bool? = nil, isModerated: Bool? = nil, modificationTime: Double? = nil, participants: [String]? = nil, topic: String? = nil, topicPlaceholder: String? = nil, type: String? = nil) {
        self.avatar = avatar
        self.avatarLarge = avatarLarge
        self.convID = convID
        self.creationTime = creationTime
        self.creatorID = creatorID
        self.creatorTenantID = creatorTenantID
        self.description = description
        self.isGuestAccessDisabled = isGuestAccessDisabled
        self.isModerated = isModerated
        self.modificationTime = modificationTime
        self.participants = participants
        self.topic = topic
        self.topicPlaceholder = topicPlaceholder
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case avatar
        case avatarLarge
        case convID = "convId"
        case creationTime
        case creatorID = "creatorId"
        case creatorTenantID = "creatorTenantId"
        case description
        case isGuestAccessDisabled
        case isModerated
        case modificationTime
        case participants
        case topic
        case topicPlaceholder
        case type
    }
}

public struct ConversationDetails: Codable {
    /// A list of bridge numbers which can be used to dial in to the real time session via phone
    public var bridgeNumbers: [BridgeNumber]?
    /// Missing documentation
    public var convID: String?
    /// The user ID of the conversation creator
    public var conversationCreatorID: String?
    /// Indicates if the conversation is allowed to be moderated
    public var isModerationAllowed: Bool?
    /// Indicates if the conversation is allowed to be recorded
    public var isRecordingAllowed: Bool?
    /// A link that can be used in a browser to join the session
    public var link: String?
    /// The PIN to join a real time session via phone
    public var pin: String?

    public init(bridgeNumbers: [BridgeNumber]? = nil, convID: String? = nil, conversationCreatorID: String? = nil, isModerationAllowed: Bool? = nil, isRecordingAllowed: Bool? = nil, link: String? = nil, pin: String? = nil) {
        self.bridgeNumbers = bridgeNumbers
        self.convID = convID
        self.conversationCreatorID = conversationCreatorID
        self.isModerationAllowed = isModerationAllowed
        self.isRecordingAllowed = isRecordingAllowed
        self.link = link
        self.pin = pin
    }

    private enum CodingKeys: String, CodingKey {
        case bridgeNumbers
        case convID = "convId"
        case conversationCreatorID = "conversationCreatorId"
        case isModerationAllowed
        case isRecordingAllowed
        case link
        case pin
    }
}

public struct ConversationItem: Codable {
    /// Array of files attached to the item
    public var attachments: [Attachment]?
    /// The ID of the conversation the item belongs to
    public var convID: String?
    /// UTC timestamp when the item was created
    public var creationTime: Double?
    /// The ID of the user who created the conversation item
    public var creatorID: String?
    /// Indicates whether the item is included in the unread message count
    public var isIncludeInUnreadCount: Bool?
    /// The ID of the item
    public var itemID: String?
    /// UTC timestamp when the conversation was modified
    public var modificationTime: Double?
    public var rtc: RtcItem?
    public var system: SystemItem?
    public var text: ConversationTextItem?
    /// The type of the conversation item. It can be one of the following TEXT, SYSTEM or RTC
    public var type: String?

    public init(attachments: [Attachment]? = nil, convID: String? = nil, creationTime: Double? = nil, creatorID: String? = nil, isIncludeInUnreadCount: Bool? = nil, itemID: String? = nil, modificationTime: Double? = nil, rtc: RtcItem? = nil, system: SystemItem? = nil, text: ConversationTextItem? = nil, type: String? = nil) {
        self.attachments = attachments
        self.convID = convID
        self.creationTime = creationTime
        self.creatorID = creatorID
        self.isIncludeInUnreadCount = isIncludeInUnreadCount
        self.itemID = itemID
        self.modificationTime = modificationTime
        self.rtc = rtc
        self.system = system
        self.text = text
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case attachments
        case convID = "convId"
        case creationTime
        case creatorID = "creatorId"
        case isIncludeInUnreadCount = "includeInUnreadCount"
        case itemID = "itemId"
        case modificationTime
        case rtc
        case system
        case text
        case type
    }
}

public struct ConversationParticipant: Codable {
    /// The display name of the participant.
    public var displayName: String?
    /// The first name of the participant.
    public var firstName: String?
    /// If the participant is deleted.
    public var isDeleted: Bool?
    /// The large image uri of the participant.
    public var largeImageUri: String?
    /// The last name of the participant.
    public var lastName: String?
    /// The small image uri of the participant;
    public var smallImageUri: String?
    /// The type of the participant
    public var type: String?
    /// The unique user id of the participant.
    public var userID: String?

    public init(displayName: String? = nil, firstName: String? = nil, isDeleted: Bool? = nil, largeImageUri: String? = nil, lastName: String? = nil, smallImageUri: String? = nil, type: String? = nil, userID: String? = nil) {
        self.displayName = displayName
        self.firstName = firstName
        self.isDeleted = isDeleted
        self.largeImageUri = largeImageUri
        self.lastName = lastName
        self.smallImageUri = smallImageUri
        self.type = type
        self.userID = userID
    }

    private enum CodingKeys: String, CodingKey {
        case displayName
        case firstName
        case isDeleted
        case largeImageUri
        case lastName
        case smallImageUri
        case type
        case userID = "userId"
    }
}

public struct ConversationParticipantsList: Codable {
    /// Are more results available, then start another search with finer query
    public var hasMore: Bool?
    /// List of participants
    public var participantList: [ConversationParticipant]?
    /// Pointer for stored search
    public var searchPointer: String?

    public init(hasMore: Bool? = nil, participantList: [ConversationParticipant]? = nil, searchPointer: String? = nil) {
        self.hasMore = hasMore
        self.participantList = participantList
        self.searchPointer = searchPointer
    }
}

public struct ConversationSearchResult: Codable {
    /// A list of result items for conversations that match the search term.
    public var matchingConversations: [ConversationSearchResultItem]?

    public init(matchingConversations: [ConversationSearchResultItem]? = nil) {
        self.matchingConversations = matchingConversations
    }
}

public struct ConversationSearchResultItem: Codable {
    /// The ID of the conversation to which the matching items belong.
    public var convID: String?
    /// The conversation items which contain the search result. The list maybe empty in case a hit was found for the conversation related data like topic or participants.
    public var itemIDs: [String]?

    public init(convID: String? = nil, itemIDs: [String]? = nil) {
        self.convID = convID
        self.itemIDs = itemIDs
    }

    private enum CodingKeys: String, CodingKey {
        case convID = "convId"
        case itemIDs = "itemIds"
    }
}

public struct ConversationTextItem: Codable {
    /// The content of the text item
    public var content: String?
    /// The type of the text item. It can be one of the following: RICH (with HTML content) or PLAIN (only text)
    public var contentType: String?
    /// The meta data form
    public var formMetaData: String?
    /// Is this a webhook message?
    public var isWebhookMessage: Bool?
    /// Array of IDs of the users who liked the item
    public var likedUserIDs: [String]?
    /// The ID of the parent item of the text item. This field is optional and can be used for thread views
    public var parentID: String?
    public var preview: Preview?
    /// The state of the text item. It can be one of the following: CREATED (which denotes that it was not modified since its creation), EDITED (which denotes that the creator of this item modified the item) or DELETED (which denotes that the item itself exists but its content was removed)
    public var state: String?
    /// TThe subject of the text item. This field is optional and maybe filled when creating the text item
    public var subject: String?

    public init(content: String? = nil, contentType: String? = nil, formMetaData: String? = nil, isWebhookMessage: Bool? = nil, likedUserIDs: [String]? = nil, parentID: String? = nil, preview: Preview? = nil, state: String? = nil, subject: String? = nil) {
        self.content = content
        self.contentType = contentType
        self.formMetaData = formMetaData
        self.isWebhookMessage = isWebhookMessage
        self.likedUserIDs = likedUserIDs
        self.parentID = parentID
        self.preview = preview
        self.state = state
        self.subject = subject
    }

    private enum CodingKeys: String, CodingKey {
        case content
        case contentType
        case formMetaData
        case isWebhookMessage
        case likedUserIDs = "likedUserIds"
        case parentID = "parentId"
        case preview
        case state
        case subject
    }
}

public struct ConversationsPage: Codable {
    /// List of conversations
    public var conversationList: [Conversation]?
    /// Has more pages of conversations
    public var hasMore: AnyJSON?
    /// Pointer to the next set page of conversations
    public var nextPagePointer: String?

    public init(conversationList: [Conversation]? = nil, hasMore: AnyJSON? = nil, nextPagePointer: String? = nil) {
        self.conversationList = conversationList
        self.hasMore = hasMore
        self.nextPagePointer = nextPagePointer
    }
}

public struct DirectoryResult: Codable {
    /// Are more results available, than start another search
    public var hasMore: Bool?
    /// Pointer for stored search
    public var searchPointer: String?
    /// List of spaces
    public var spaces: [Space]?

    public init(hasMore: Bool? = nil, searchPointer: String? = nil, spaces: [Space]? = nil) {
        self.hasMore = hasMore
        self.searchPointer = searchPointer
        self.spaces = spaces
    }
}

public struct FlaggedItem: Codable {
    public var item: SpaceItem?
    public var parentItem: SpaceItem?

    public init(item: SpaceItem? = nil, parentItem: SpaceItem? = nil) {
        self.item = item
        self.parentItem = parentItem
    }
}

public struct FlaggedItemsResult: Codable {
    /// A list of flagged items
    public var flaggedItems: [FlaggedItem]?
    /// More results available (true-use searchpointer for next search/false)
    public var hasMore: Bool?
    /// The searchpointer
    public var searchPointer: String?

    public init(flaggedItems: [FlaggedItem]? = nil, hasMore: Bool? = nil, searchPointer: String? = nil) {
        self.flaggedItems = flaggedItems
        self.hasMore = hasMore
        self.searchPointer = searchPointer
    }
}

public struct IncomingWebhook: Codable {
    /// The conversation where the posts go to
    public var conversationID: String?
    /// Milliseconds since 1.1.1900 when the hook was created
    public var creationTime: Double?
    /// Th e user who created the webhook
    public var creatorID: String?
    /// A short plain text to describe the webhook
    public var description: String?
    /// Milliseconds since 1.1.1900 when the hook was modified
    public var modificationTime: Double?
    /// A name to identify the webhook
    public var name: String?
    /// Status may be ENABLED or DISABLED. A disabled hook cannot be used
    public var status: String?
    /// The tenant where the conversation and users belong to
    public var tenantID: String?
    /// The url where the webhokk can be used
    public var url: String?
    /// The user who will occur as author of the posts
    public var userID: String?
    /// Unique id of the webhook
    public var webhookID: String?

    public init(conversationID: String? = nil, creationTime: Double? = nil, creatorID: String? = nil, description: String? = nil, modificationTime: Double? = nil, name: String? = nil, status: String? = nil, tenantID: String? = nil, url: String? = nil, userID: String? = nil, webhookID: String? = nil) {
        self.conversationID = conversationID
        self.creationTime = creationTime
        self.creatorID = creatorID
        self.description = description
        self.modificationTime = modificationTime
        self.name = name
        self.status = status
        self.tenantID = tenantID
        self.url = url
        self.userID = userID
        self.webhookID = webhookID
    }

    private enum CodingKeys: String, CodingKey {
        case conversationID = "conversationId"
        case creationTime
        case creatorID = "creatorId"
        case description
        case modificationTime
        case name
        case status
        case tenantID = "tenantId"
        case url
        case userID = "userId"
        case webhookID = "webhookId"
    }
}

public struct IncomingWebhookSlackMessage: Codable {
    /// Missing documentation
    public var fileURL: String?
    /// Missing documentation
    public var filename: String?
    /// Missing documentation
    public var isMarkdown: Bool?
    /// Missing documentation
    public var subject: String?
    /// The text which will occur in the conversation. May contain formats like *bold* or _italic_
    public var text: String?

    public init(fileURL: String? = nil, filename: String? = nil, isMarkdown: Bool? = nil, subject: String? = nil, text: String? = nil) {
        self.fileURL = fileURL
        self.filename = filename
        self.isMarkdown = isMarkdown
        self.subject = subject
        self.text = text
    }

    private enum CodingKeys: String, CodingKey {
        case fileURL
        case filename
        case isMarkdown = "markdown"
        case subject
        case text
    }
}

public struct Label: Codable {
    /// The unique ID of the label
    public var labelID: String?
    /// The clear text value
    public var value: String?

    public init(labelID: String? = nil, value: String? = nil) {
        self.labelID = labelID
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case labelID = "labelId"
        case value
    }
}

public struct LabelIDs: Codable {
    /// A list of label ids.
    public var labelIDs: [String]?

    public init(labelIDs: [String]? = nil) {
        self.labelIDs = labelIDs
    }

    private enum CodingKeys: String, CodingKey {
        case labelIDs = "labelIds"
    }
}

public struct Participant: Codable {
    /// Time when the participant was added to the space
    public var creationTime: Double?
    /// The list of label IDs of all the labels assigned to the space.
    public var labelIDs: [String]?
    /// Time stamp when user last created content in the space.
    public var lastContentCreationTime: Double?
    /// Last time stamp when the user read content in this space.
    public var lastReadTimestamp: Double?
    /// Time when the participant was changed last.
    public var modificationTime: Double?
    /// Number of replies in the space created by this participant.
    public var numberOfReplies: Double?
    /// Number of topics in the space created by this participant.
    public var numberOfTopics: Double?
    /// The name of the role of the participant.
    public var role: String?
    /// The unique ID of the space to which the participant.
    public var spaceID: String?
    /// The name of the state of the participant;
    public var state: String?
    /// The unique tenant id of the participant.
    public var tenantID: String?
    /// The unique user id of the participant.
    public var userID: String?

    public init(creationTime: Double? = nil, labelIDs: [String]? = nil, lastContentCreationTime: Double? = nil, lastReadTimestamp: Double? = nil, modificationTime: Double? = nil, numberOfReplies: Double? = nil, numberOfTopics: Double? = nil, role: String? = nil, spaceID: String? = nil, state: String? = nil, tenantID: String? = nil, userID: String? = nil) {
        self.creationTime = creationTime
        self.labelIDs = labelIDs
        self.lastContentCreationTime = lastContentCreationTime
        self.lastReadTimestamp = lastReadTimestamp
        self.modificationTime = modificationTime
        self.numberOfReplies = numberOfReplies
        self.numberOfTopics = numberOfTopics
        self.role = role
        self.spaceID = spaceID
        self.state = state
        self.tenantID = tenantID
        self.userID = userID
    }

    private enum CodingKeys: String, CodingKey {
        case creationTime
        case labelIDs = "labelIds"
        case lastContentCreationTime
        case lastReadTimestamp
        case modificationTime
        case numberOfReplies
        case numberOfTopics
        case role
        case spaceID = "spaceId"
        case state
        case tenantID = "tenantId"
        case userID = "userId"
    }
}

public struct ParticipantSearchResult: Codable {
    /// Time when the participant was added to the space
    public var creationTime: Double?
    /// The first name of the participant
    public var firstName: String?
    /// The last name of the participant
    public var lastName: String?
    /// Time when the participant was changed last.
    public var modificationTime: Double?
    /// Number of replies in the space created by this participant.
    public var numberOfReplies: Double?
    /// Number of topics in the space created by this participant.
    public var numberOfTopics: Double?
    /// The name of the role of the participant
    public var role: String?
    /// The uri of the small picture of the participant
    public var smallImageUri: String?
    /// The name of the state of the participant
    public var state: String?
    /// The tenant id of the participant
    public var tenantID: String?
    /// The id of the participant
    public var userID: String?

    public init(creationTime: Double? = nil, firstName: String? = nil, lastName: String? = nil, modificationTime: Double? = nil, numberOfReplies: Double? = nil, numberOfTopics: Double? = nil, role: String? = nil, smallImageUri: String? = nil, state: String? = nil, tenantID: String? = nil, userID: String? = nil) {
        self.creationTime = creationTime
        self.firstName = firstName
        self.lastName = lastName
        self.modificationTime = modificationTime
        self.numberOfReplies = numberOfReplies
        self.numberOfTopics = numberOfTopics
        self.role = role
        self.smallImageUri = smallImageUri
        self.state = state
        self.tenantID = tenantID
        self.userID = userID
    }

    private enum CodingKeys: String, CodingKey {
        case creationTime
        case firstName
        case lastName
        case modificationTime
        case numberOfReplies
        case numberOfTopics
        case role
        case smallImageUri
        case state
        case tenantID = "tenantId"
        case userID = "userId"
    }
}

public struct ParticipantSearchResultLarge: Codable {
    /// Time when the participant was added to the space
    public var creationTime: Double?
    /// The department of the participant
    public var department: String?
    /// The first name of the participant
    public var firstName: String?
    /// Is the participant a member of the space
    public var isMember: Bool?
    /// The job description of the participant
    public var jobDescription: String?
    /// The last time the participant created content.
    public var lastContentCreationTime: Double?
    /// The last name of the participant
    public var lastName: String?
    /// Time when the participant was changed last.
    public var modificationTime: Double?
    /// The number of replies
    public var numberOfReplies: Double?
    /// The number of topics
    public var numberOfTopics: Double?
    /// The reason of it all (42)
    public var reason: String?
    /// The name of the role of the participant
    public var role: String?
    /// The uri of the small picture of the participant
    public var smallImageUri: String?
    /// The id of the space
    public var spaceID: String?
    /// The name of the state
    public var state: String?
    /// The tenant id of the participant
    public var tenantID: String?
    /// The id of the participant
    public var userID: String?

    public init(creationTime: Double? = nil, department: String? = nil, firstName: String? = nil, isMember: Bool? = nil, jobDescription: String? = nil, lastContentCreationTime: Double? = nil, lastName: String? = nil, modificationTime: Double? = nil, numberOfReplies: Double? = nil, numberOfTopics: Double? = nil, reason: String? = nil, role: String? = nil, smallImageUri: String? = nil, spaceID: String? = nil, state: String? = nil, tenantID: String? = nil, userID: String? = nil) {
        self.creationTime = creationTime
        self.department = department
        self.firstName = firstName
        self.isMember = isMember
        self.jobDescription = jobDescription
        self.lastContentCreationTime = lastContentCreationTime
        self.lastName = lastName
        self.modificationTime = modificationTime
        self.numberOfReplies = numberOfReplies
        self.numberOfTopics = numberOfTopics
        self.reason = reason
        self.role = role
        self.smallImageUri = smallImageUri
        self.spaceID = spaceID
        self.state = state
        self.tenantID = tenantID
        self.userID = userID
    }

    private enum CodingKeys: String, CodingKey {
        case creationTime
        case department
        case firstName
        case isMember
        case jobDescription
        case lastContentCreationTime
        case lastName
        case modificationTime
        case numberOfReplies
        case numberOfTopics
        case reason
        case role
        case smallImageUri
        case spaceID = "spaceId"
        case state
        case tenantID = "tenantId"
        case userID = "userId"
    }
}

public struct ParticipantsImportDataResult: Codable {
    /// Actual number of imported participants
    public var actualNumberOfImportedParticipants: Double?
    /// Estimated import duration
    public var estimatedImportDuration: Double?
    /// Import end date
    public var importEndDate: Double?
    /// The file id of the import
    public var importFileID: String?
    /// The name of the import file
    public var importFileName: String?
    /// The progress of the import
    public var importProgress: Double?
    /// Import start date
    public var importStartDate: Double?
    /// The status of the import
    public var importStatus: String?
    /// Planned number of imported participants
    public var plannedNumberOfImportedParticipants: Double?
    /// The file id of the result file
    public var resultFileID: String?
    /// The name of the result file
    public var resultFileName: String?

    public init(actualNumberOfImportedParticipants: Double? = nil, estimatedImportDuration: Double? = nil, importEndDate: Double? = nil, importFileID: String? = nil, importFileName: String? = nil, importProgress: Double? = nil, importStartDate: Double? = nil, importStatus: String? = nil, plannedNumberOfImportedParticipants: Double? = nil, resultFileID: String? = nil, resultFileName: String? = nil) {
        self.actualNumberOfImportedParticipants = actualNumberOfImportedParticipants
        self.estimatedImportDuration = estimatedImportDuration
        self.importEndDate = importEndDate
        self.importFileID = importFileID
        self.importFileName = importFileName
        self.importProgress = importProgress
        self.importStartDate = importStartDate
        self.importStatus = importStatus
        self.plannedNumberOfImportedParticipants = plannedNumberOfImportedParticipants
        self.resultFileID = resultFileID
        self.resultFileName = resultFileName
    }

    private enum CodingKeys: String, CodingKey {
        case actualNumberOfImportedParticipants
        case estimatedImportDuration
        case importEndDate
        case importFileID = "importFileId"
        case importFileName
        case importProgress
        case importStartDate
        case importStatus
        case plannedNumberOfImportedParticipants
        case resultFileID = "resultFileId"
        case resultFileName
    }
}

public struct ParticipantsLike: Codable {
    /// The first name of the user
    public var firstName: String?
    /// The large image uri of the user
    public var largeImageUri: String?
    /// The last name of the user
    public var lastName: String?
    /// The small image uri of the user
    public var smallImageUri: String?
    /// The id of the user
    public var userID: String?

    public init(firstName: String? = nil, largeImageUri: String? = nil, lastName: String? = nil, smallImageUri: String? = nil, userID: String? = nil) {
        self.firstName = firstName
        self.largeImageUri = largeImageUri
        self.lastName = lastName
        self.smallImageUri = smallImageUri
        self.userID = userID
    }

    private enum CodingKeys: String, CodingKey {
        case firstName
        case largeImageUri
        case lastName
        case smallImageUri
        case userID = "userId"
    }
}

public struct ParticipantsLikeResult: Codable {
    /// More results available (true-use searchpointer for next search/false)
    public var hasMore: Bool?
    /// A list of participants who like the topic
    public var participants: [ParticipantsLike]?
    /// The searchpointer
    public var searchPointer: String?

    public init(hasMore: Bool? = nil, participants: [ParticipantsLike]? = nil, searchPointer: String? = nil) {
        self.hasMore = hasMore
        self.participants = participants
        self.searchPointer = searchPointer
    }
}

public struct ParticipantsSearchResult: Codable {
    /// Are more results available, than start another search
    public var hasMore: Bool?
    /// List of participants
    public var participants: [ParticipantSearchResult]?
    /// Pointer for stored search
    public var searchPointer: String?

    public init(hasMore: Bool? = nil, participants: [ParticipantSearchResult]? = nil, searchPointer: String? = nil) {
        self.hasMore = hasMore
        self.participants = participants
        self.searchPointer = searchPointer
    }
}

public struct ParticipantsSearchResultLarge: Codable {
    /// Are more results available, then start another search with finer query
    public var hasMore: Bool?
    /// List of participants
    public var participants: [ParticipantSearchResultLarge]?
    /// Pointer for stored search
    public var searchPointer: String?

    public init(hasMore: Bool? = nil, participants: [ParticipantSearchResultLarge]? = nil, searchPointer: String? = nil) {
        self.hasMore = hasMore
        self.participants = participants
        self.searchPointer = searchPointer
    }
}

public struct PinnedTopic: Codable {
    /// "ID of the conversation"
    public var conversationID: String?
    /// "ID of the pinned topic"
    public var conversationItemID: String?
    /// "The exact moment the Pinning was happening"
    public var pinnedTime: Double?

    public init(conversationID: String? = nil, conversationItemID: String? = nil, pinnedTime: Double? = nil) {
        self.conversationID = conversationID
        self.conversationItemID = conversationItemID
        self.pinnedTime = pinnedTime
    }

    private enum CodingKeys: String, CodingKey {
        case conversationID = "conversationId"
        case conversationItemID = "conversationItemId"
        case pinnedTime
    }
}

public struct Presence: Codable {
    /// Timestamp until the DND state of the user is active
    public var dndUntil: Double?
    /// Indicates whether the user has opted out of their presence
    public var isOptedOut: Bool?
    /// The latitude of the geo location of the user
    public var latitude: Double?
    /// The geo location of the user in clear text
    public var locationText: String?
    /// The longitude of the geo location of the user
    public var longitude: Double?
    /// Identifies whether the presence state is based on the state information of a mobile device or not
    public var isMobile: Bool?
    /// N/a
    public var isPoor: Bool?
    /// The presence state of the user. It can be one of the following: AVAILABLE, OFFLINE, AWAY, BUSY, or DND (Do-Not-Disturb)
    public var state: String?
    /// A free formed status message of the user
    public var statusMessage: String?
    /// The timezone offset of the user compared to UTC
    public var timeZoneOffset: Double?
    /// The ID of the user
    public var userID: String?

    public init(dndUntil: Double? = nil, isOptedOut: Bool? = nil, latitude: Double? = nil, locationText: String? = nil, longitude: Double? = nil, isMobile: Bool? = nil, isPoor: Bool? = nil, state: String? = nil, statusMessage: String? = nil, timeZoneOffset: Double? = nil, userID: String? = nil) {
        self.dndUntil = dndUntil
        self.isOptedOut = isOptedOut
        self.latitude = latitude
        self.locationText = locationText
        self.longitude = longitude
        self.isMobile = isMobile
        self.isPoor = isPoor
        self.state = state
        self.statusMessage = statusMessage
        self.timeZoneOffset = timeZoneOffset
        self.userID = userID
    }

    private enum CodingKeys: String, CodingKey {
        case dndUntil
        case isOptedOut
        case latitude
        case locationText
        case longitude
        case isMobile = "mobile"
        case isPoor = "poor"
        case state
        case statusMessage
        case timeZoneOffset
        case userID = "userId"
    }
}

public struct Preview: Codable {
    /// N/a
    public var imageURI: String?
    /// N/a
    public var srcURL: String?
    /// N/a
    public var title: String?
    /// N/a
    public var type: String?

    public init(imageURI: String? = nil, srcURL: String? = nil, title: String? = nil, type: String? = nil) {
        self.imageURI = imageURI
        self.srcURL = srcURL
        self.title = title
        self.type = type
    }
}

public struct RtcEnded: Codable {
    /// The duration of the call.
    public var duration: Double?
    /// The maximum number of attendees during a call.
    public var maxNumberOfAttendees: Double?
    /// UserID of the pick from participant.
    public var pickFromParticipant: String?

    public init(duration: Double? = nil, maxNumberOfAttendees: Double? = nil, pickFromParticipant: String? = nil) {
        self.duration = duration
        self.maxNumberOfAttendees = maxNumberOfAttendees
        self.pickFromParticipant = pickFromParticipant
    }
}

public struct RtcItem: Codable {
    public var ended: RtcEnded?
    /// Indicates a missed call.
    public var missed: String?
    public var moved: RtcMoved?
    /// Participants of the call.
    public var rtcParticipants: [RtcParticipant]?
    /// The type of the RTC item.
    public var type: String?

    public init(ended: RtcEnded? = nil, missed: String? = nil, moved: RtcMoved? = nil, rtcParticipants: [RtcParticipant]? = nil, type: String? = nil) {
        self.ended = ended
        self.missed = missed
        self.moved = moved
        self.rtcParticipants = rtcParticipants
        self.type = type
    }
}

public struct RtcMoved: Codable {
    /// ID of the conversation moved from or to.
    public var conversationID: String?
    /// Moved from or to conversation.
    public var direction: String?

    public init(conversationID: String? = nil, direction: String? = nil) {
        self.conversationID = conversationID
        self.direction = direction
    }

    private enum CodingKeys: String, CodingKey {
        case conversationID = "conversationId"
        case direction
    }
}

public struct RtcParticipant: Codable {
    /// The display name of the participant.
    public var displayName: String?
    /// Missing documentation
    public var fullyQualifiedNumber: String?
    /// Missing documentation
    public var phoneNumber: String?
    /// Missing documentation
    public var resolvedUser: AnyJSON?
    /// The RTC type of the participant.
    public var type: String?
    /// The ID of the participant.
    public var userID: String?

    public init(displayName: String? = nil, fullyQualifiedNumber: String? = nil, phoneNumber: String? = nil, resolvedUser: AnyJSON? = nil, type: String? = nil, userID: String? = nil) {
        self.displayName = displayName
        self.fullyQualifiedNumber = fullyQualifiedNumber
        self.phoneNumber = phoneNumber
        self.resolvedUser = resolvedUser
        self.type = type
        self.userID = userID
    }

    private enum CodingKeys: String, CodingKey {
        case displayName
        case fullyQualifiedNumber
        case phoneNumber
        case resolvedUser
        case type
        case userID = "userId"
    }
}

public struct SharedItem: Codable {
    /// The Id of the container
    public var containerID: String?
    /// Name of the container
    public var containerName: String?
    /// Type of the container
    public var containerType: String?
    /// The time this Item has been created
    public var creationTime: Double?
    /// The Id of the creator
    public var creatorID: String?
    /// Id of the item
    public var itemID: String?
    /// The Id of the parent topic
    public var parentTopicID: String?
    /// The subtype
    public var subType: String?

    public init(containerID: String? = nil, containerName: String? = nil, containerType: String? = nil, creationTime: Double? = nil, creatorID: String? = nil, itemID: String? = nil, parentTopicID: String? = nil, subType: String? = nil) {
        self.containerID = containerID
        self.containerName = containerName
        self.containerType = containerType
        self.creationTime = creationTime
        self.creatorID = creatorID
        self.itemID = itemID
        self.parentTopicID = parentTopicID
        self.subType = subType
    }

    private enum CodingKeys: String, CodingKey {
        case containerID = "containerId"
        case containerName
        case containerType
        case creationTime
        case creatorID = "creatorId"
        case itemID = "itemId"
        case parentTopicID = "parentTopicId"
        case subType
    }
}

public struct Space: Codable {
    /// The name of the access mode type of the space.
    public var accessModeType: String?
    /// The space creation time.
    public var creationTime: Double?
    /// The ID of the space creator.
    public var creatorID: String?
    /// The name of the default role of a new participant.
    public var defaultRole: String?
    /// The space description.
    public var description: String?
    /// Base64 encoded image that can be set during the creation and the update of a space.
    public var largePictureBase64: String?
    /// The content type of the image.
    public var largePictureContentType: String?
    /// The file id of the large version of the picture.
    public var largePictureID: String?
    /// Time stamp when the last content (topic / reply) was created within this space.
    public var lastContentCreationTime: Double?
    /// User ID of the user which created the last content.
    public var lastContentCreatorID: String?
    /// The space modification time.
    public var modificationTime: Double?
    /// The unique space name.
    public var name: String?
    /// Number of external participants in the space.
    public var numberOfExternalParticipants: Double?
    /// Number of participants in the space.
    public var numberOfParticipants: Double?
    /// Number of pinned topics in the space.
    public var numberOfPinnedTopics: Double?
    /// Number of replies in the space.
    public var numberOfReplies: Double?
    /// Number of topics in the space.
    public var numberOfTopics: Double?
    /// The ID of the space owner.
    public var ownerID: String?
    /// Base64 encoded image that can be set during the creation and the update of a space.
    public var smallPictureBase64: String?
    /// The content type of the image.
    public var smallPictureContentType: String?
    /// The file id of the small version of the picture.
    public var smallPictureID: String?
    /// The unique space ID generated by the backend during the creation of the space.
    public var spaceID: String?
    /// The name of the status of the space.
    public var status: String?
    /// The list of space tags.
    public var tags: [String]?
    /// The ID of the space tenant.
    public var tenantID: String?
    /// The name of the space type.
    public var type: String?

    public init(accessModeType: String? = nil, creationTime: Double? = nil, creatorID: String? = nil, defaultRole: String? = nil, description: String? = nil, largePictureBase64: String? = nil, largePictureContentType: String? = nil, largePictureID: String? = nil, lastContentCreationTime: Double? = nil, lastContentCreatorID: String? = nil, modificationTime: Double? = nil, name: String? = nil, numberOfExternalParticipants: Double? = nil, numberOfParticipants: Double? = nil, numberOfPinnedTopics: Double? = nil, numberOfReplies: Double? = nil, numberOfTopics: Double? = nil, ownerID: String? = nil, smallPictureBase64: String? = nil, smallPictureContentType: String? = nil, smallPictureID: String? = nil, spaceID: String? = nil, status: String? = nil, tags: [String]? = nil, tenantID: String? = nil, type: String? = nil) {
        self.accessModeType = accessModeType
        self.creationTime = creationTime
        self.creatorID = creatorID
        self.defaultRole = defaultRole
        self.description = description
        self.largePictureBase64 = largePictureBase64
        self.largePictureContentType = largePictureContentType
        self.largePictureID = largePictureID
        self.lastContentCreationTime = lastContentCreationTime
        self.lastContentCreatorID = lastContentCreatorID
        self.modificationTime = modificationTime
        self.name = name
        self.numberOfExternalParticipants = numberOfExternalParticipants
        self.numberOfParticipants = numberOfParticipants
        self.numberOfPinnedTopics = numberOfPinnedTopics
        self.numberOfReplies = numberOfReplies
        self.numberOfTopics = numberOfTopics
        self.ownerID = ownerID
        self.smallPictureBase64 = smallPictureBase64
        self.smallPictureContentType = smallPictureContentType
        self.smallPictureID = smallPictureID
        self.spaceID = spaceID
        self.status = status
        self.tags = tags
        self.tenantID = tenantID
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case accessModeType
        case creationTime
        case creatorID = "creatorId"
        case defaultRole
        case description
        case largePictureBase64
        case largePictureContentType
        case largePictureID = "largePictureId"
        case lastContentCreationTime
        case lastContentCreatorID = "lastContentCreatorId"
        case modificationTime
        case name
        case numberOfExternalParticipants
        case numberOfParticipants
        case numberOfPinnedTopics
        case numberOfReplies
        case numberOfTopics
        case ownerID = "ownerId"
        case smallPictureBase64
        case smallPictureContentType
        case smallPictureID = "smallPictureId"
        case spaceID = "spaceId"
        case status
        case tags
        case tenantID = "tenantId"
        case type
    }
}

public struct SpaceAttachment: Codable {
    /// Time this item has been created
    public var creationTime: Double?
    /// The id of the creator
    public var creatorID: String?
    /// The id of the field
    public var fileID: String?
    /// Name of the file
    public var fileName: String?
    /// Is inline usage allowed
    public var isInlineUsage: Bool?
    /// Id of the item
    public var itemID: String?
    /// Layout
    public var layout: String?
    /// The media type
    public var mimeType: String?
    /// The time this item has been ben modified
    public var modificationTime: Double?
    /// Size of this file
    public var size: Double?
    /// Id of the space
    public var spaceID: String?
    /// The id of the tumbnail
    public var thumbnailID: String?

    public init(creationTime: Double? = nil, creatorID: String? = nil, fileID: String? = nil, fileName: String? = nil, isInlineUsage: Bool? = nil, itemID: String? = nil, layout: String? = nil, mimeType: String? = nil, modificationTime: Double? = nil, size: Double? = nil, spaceID: String? = nil, thumbnailID: String? = nil) {
        self.creationTime = creationTime
        self.creatorID = creatorID
        self.fileID = fileID
        self.fileName = fileName
        self.isInlineUsage = isInlineUsage
        self.itemID = itemID
        self.layout = layout
        self.mimeType = mimeType
        self.modificationTime = modificationTime
        self.size = size
        self.spaceID = spaceID
        self.thumbnailID = thumbnailID
    }

    private enum CodingKeys: String, CodingKey {
        case creationTime
        case creatorID = "creatorId"
        case fileID = "fileId"
        case fileName
        case isInlineUsage = "inlineUsage"
        case itemID = "itemId"
        case layout
        case mimeType
        case modificationTime
        case size
        case spaceID = "spaceId"
        case thumbnailID = "thumbnailId"
    }
}

public struct SpaceExternalAttachment: Codable {
    public var attachment: SpaceAttachment?
    /// The location of the download
    public var downloadLocation: String?
    /// The location of the preview
    public var previewLocation: String?
    /// The share link token
    public var shareLinkToken: String?
    /// The type
    public var type: String?

    public init(attachment: SpaceAttachment? = nil, downloadLocation: String? = nil, previewLocation: String? = nil, shareLinkToken: String? = nil, type: String? = nil) {
        self.attachment = attachment
        self.downloadLocation = downloadLocation
        self.previewLocation = previewLocation
        self.shareLinkToken = shareLinkToken
        self.type = type
    }
}

public struct SpaceItem: Codable {
    /// The Status of this item
    public var status: String?
    /// The list of attachments
    public var attachments: [SpaceAttachment]?
    /// Is this item complex
    public var isComplex: Bool?
    /// The content of this item
    public var content: String?
    /// The time this item got created
    public var creationTime: Double?
    /// The Id of the creator
    public var creatorID: String?
    /// Incase this item got deleted, the id of the deletor
    public var deletedBy: String?
    /// A list of external attachments
    public var externalAttachments: [SpaceExternalAttachment]?
    /// Incase there is FormMetaData
    public var formMetaData: String?
    /// The Id of this item
    public var itemID: String?
    /// A list of userIds who have been mentioned in this item
    public var mentionedUsers: [String]?
    /// The time this item got modified
    public var modificationTime: Double?
    /// The number of likes
    public var numberOfLikes: Double?
    /// A list of previews
    public var previews: [SpaceItemPreview]?
    /// Missing documentation
    public var sharedItems: [SharedItem]?
    /// The Id of the space containing this item
    public var spaceID: String?
    /// The Id of the tenant
    public var tenantID: String?

    public init(status: String? = nil, attachments: [SpaceAttachment]? = nil, isComplex: Bool? = nil, content: String? = nil, creationTime: Double? = nil, creatorID: String? = nil, deletedBy: String? = nil, externalAttachments: [SpaceExternalAttachment]? = nil, formMetaData: String? = nil, itemID: String? = nil, mentionedUsers: [String]? = nil, modificationTime: Double? = nil, numberOfLikes: Double? = nil, previews: [SpaceItemPreview]? = nil, sharedItems: [SharedItem]? = nil, spaceID: String? = nil, tenantID: String? = nil) {
        self.status = status
        self.attachments = attachments
        self.isComplex = isComplex
        self.content = content
        self.creationTime = creationTime
        self.creatorID = creatorID
        self.deletedBy = deletedBy
        self.externalAttachments = externalAttachments
        self.formMetaData = formMetaData
        self.itemID = itemID
        self.mentionedUsers = mentionedUsers
        self.modificationTime = modificationTime
        self.numberOfLikes = numberOfLikes
        self.previews = previews
        self.sharedItems = sharedItems
        self.spaceID = spaceID
        self.tenantID = tenantID
    }

    private enum CodingKeys: String, CodingKey {
        case status = "Status"
        case attachments
        case isComplex = "complex"
        case content
        case creationTime
        case creatorID = "creatorId"
        case deletedBy
        case externalAttachments
        case formMetaData
        case itemID = "itemId"
        case mentionedUsers
        case modificationTime
        case numberOfLikes
        case previews
        case sharedItems
        case spaceID = "spaceId"
        case tenantID = "tenantId"
    }
}

public struct SpaceItemPreview: Codable {
    /// The description of this preview
    public var description: String?
    /// Html code
    public var html: String?
    /// The URI of the image
    public var imageURI: String?
    /// The provider
    public var provider: String?
    /// The URL of the source
    public var srcURL: String?
    /// The title of this preview
    public var title: String?
    /// The type of this preview
    public var type: String?

    public init(description: String? = nil, html: String? = nil, imageURI: String? = nil, provider: String? = nil, srcURL: String? = nil, title: String? = nil, type: String? = nil) {
        self.description = description
        self.html = html
        self.imageURI = imageURI
        self.provider = provider
        self.srcURL = srcURL
        self.title = title
        self.type = type
    }
}

public struct SpacePinnedTopic: Codable {
    /// The position of a pinned topic
    public var position: Double?
    /// The subject of a pinned topic
    public var subject: String?
    /// The id of a pinned topic
    public var topicID: String?

    public init(position: Double? = nil, subject: String? = nil, topicID: String? = nil) {
        self.position = position
        self.subject = subject
        self.topicID = topicID
    }

    private enum CodingKeys: String, CodingKey {
        case position
        case subject
        case topicID = "topicId"
    }
}

public struct SpaceReply: Codable {
    /// The Id of the parent topic
    public var parentTopicID: String?
    public var spaceItem: SpaceItem?

    public init(parentTopicID: String? = nil, spaceItem: SpaceItem? = nil) {
        self.parentTopicID = parentTopicID
        self.spaceItem = spaceItem
    }

    private enum CodingKeys: String, CodingKey {
        case parentTopicID = "parentTopicId"
        case spaceItem
    }
}

public struct SpaceSearchResultDetailed: Codable {
    /// =The list of file ids
    public var fileIDs: [String]?
    /// =The list of items ids
    public var itemIDs: [String]?
    /// The id of the space
    public var spaceID: String?
    /// The status of the search (NORESULT, ERROR, TIMEOUT, MORERESULT)
    public var status: String?

    public init(fileIDs: [String]? = nil, itemIDs: [String]? = nil, spaceID: String? = nil, status: String? = nil) {
        self.fileIDs = fileIDs
        self.itemIDs = itemIDs
        self.spaceID = spaceID
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case fileIDs = "fileIds"
        case itemIDs = "itemIds"
        case spaceID = "spaceId"
        case status
    }
}

public struct SpaceSearchResultDetailedBack: Codable {
    /// A list of v2restspacesearchresultdetailedback containing spaceId, item ids and file ids
    public var resList: [SpaceSearchResultDetailed]?

    public init(resList: [SpaceSearchResultDetailed]? = nil) {
        self.resList = resList
    }
}

public struct SpaceTopic: Codable {
    /// The last time new content was created
    public var lastContentCreationTime: Double?
    /// The Id of the last content creator
    public var lastContentCreatorID: String?
    /// The number of replies this topic has
    public var numberOfReplies: Double?
    /// Is this topic pinned
    public var isPinned: Bool?
    public var spaceItem: SpaceItem?
    /// The subject of this topic
    public var subject: String?
    /// The tags
    public var tags: [String]?

    public init(lastContentCreationTime: Double? = nil, lastContentCreatorID: String? = nil, numberOfReplies: Double? = nil, isPinned: Bool? = nil, spaceItem: SpaceItem? = nil, subject: String? = nil, tags: [String]? = nil) {
        self.lastContentCreationTime = lastContentCreationTime
        self.lastContentCreatorID = lastContentCreatorID
        self.numberOfReplies = numberOfReplies
        self.isPinned = isPinned
        self.spaceItem = spaceItem
        self.subject = subject
        self.tags = tags
    }

    private enum CodingKeys: String, CodingKey {
        case lastContentCreationTime
        case lastContentCreatorID = "lastContentCreatorId"
        case numberOfReplies
        case isPinned = "pinned"
        case spaceItem
        case subject
        case tags
    }
}

public struct SpaceTopicWithReplies: Codable {
    /// A List holding the replies for a topic
    public var replies: [SpaceReply]?
    public var topic: SpaceTopic?

    public init(replies: [SpaceReply]? = nil, topic: SpaceTopic? = nil) {
        self.replies = replies
        self.topic = topic
    }
}

public struct SpacesSearchTerm: Codable {
    /// The end time
    public var endTime: AnyJSON?
    /// The scope of the search
    public var scope: String?
    /// The search term
    public var searchTerm: String?
    /// The start time
    public var startTime: AnyJSON?

    public init(endTime: AnyJSON? = nil, scope: String? = nil, searchTerm: String? = nil, startTime: AnyJSON? = nil) {
        self.endTime = endTime
        self.scope = scope
        self.searchTerm = searchTerm
        self.startTime = startTime
    }
}

public struct SpacesSearchTermResult: Codable {
    /// A list of space search terms.
    public var resList: [SpacesSearchTerm]?

    public init(resList: [SpacesSearchTerm]? = nil) {
        self.resList = resList
    }
}

public struct SupportInfo: Codable {
    /// The email address of the support
    public var supportEmailAddress: String?
    /// The type of support (a number)
    public var supportType: AnyJSON?

    public init(supportEmailAddress: String? = nil, supportType: AnyJSON? = nil) {
        self.supportEmailAddress = supportEmailAddress
        self.supportType = supportType
    }
}

public struct SystemItem: Codable {
    /// List off affected participants (user ID of the Circuit user) in case the item type PARTICIPANT_ADDED or PARTICIPANT_REMOVED
    public var affectedParticipants: [String]?
    /// Filled with the new topic of a conversation if the type of the item is CONVERSATION_RENAMED.
    public var newTopic: String?
    /// Filled with the previous topic of a conversation if the type of the item is CONVERSATION_RENAMED.
    public var oldTopic: String?
    /// The type of the system item
    public var type: String?

    public init(affectedParticipants: [String]? = nil, newTopic: String? = nil, oldTopic: String? = nil, type: String? = nil) {
        self.affectedParticipants = affectedParticipants
        self.newTopic = newTopic
        self.oldTopic = oldTopic
        self.type = type
    }
}

public struct User: Codable {
    /// The URL of the small avatar picture.
    public var avatar: String?
    /// The URL of the large avatar picture.
    public var avatarLarge: String?
    /// The name of the user's company
    public var company: String?
    /// Missing documentation
    public var department: String?
    /// The user's display name
    public var displayName: String?
    /// The primary email address of the user
    public var emailAddress: String?
    /// Additional email addresses of the user
    public var emailAddresses: [UserEmailAddress]?
    /// The first name of the user
    public var firstName: String?
    /// The job title of the user
    public var jobTitle: String?
    /// The last name of the user
    public var lastName: String?
    /// The locale of the user. (E.g. en-US, de-DE)
    public var locale: String?
    /// Provisioned phone number of the user
    public var phoneNumber: String?
    /// Additional phone numbers of the user
    public var phoneNumbers: [UserPhoneNumber]?
    /// The primary tenant id
    public var primaryTenantID: String?
    /// The secondary email address
    public var secondaryEmailAddress: String?
    /// The secondary tenant id
    public var secondaryTenantID: String?
    /// The ID of the user
    public var userID: String?
    /// The state of the user, e.g. deleted
    public var userState: String?
    /// The type of the user
    public var userType: String?

    public init(avatar: String? = nil, avatarLarge: String? = nil, company: String? = nil, department: String? = nil, displayName: String? = nil, emailAddress: String? = nil, emailAddresses: [UserEmailAddress]? = nil, firstName: String? = nil, jobTitle: String? = nil, lastName: String? = nil, locale: String? = nil, phoneNumber: String? = nil, phoneNumbers: [UserPhoneNumber]? = nil, primaryTenantID: String? = nil, secondaryEmailAddress: String? = nil, secondaryTenantID: String? = nil, userID: String? = nil, userState: String? = nil, userType: String? = nil) {
        self.avatar = avatar
        self.avatarLarge = avatarLarge
        self.company = company
        self.department = department
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.emailAddresses = emailAddresses
        self.firstName = firstName
        self.jobTitle = jobTitle
        self.lastName = lastName
        self.locale = locale
        self.phoneNumber = phoneNumber
        self.phoneNumbers = phoneNumbers
        self.primaryTenantID = primaryTenantID
        self.secondaryEmailAddress = secondaryEmailAddress
        self.secondaryTenantID = secondaryTenantID
        self.userID = userID
        self.userState = userState
        self.userType = userType
    }

    private enum CodingKeys: String, CodingKey {
        case avatar
        case avatarLarge
        case company
        case department
        case displayName
        case emailAddress
        case emailAddresses
        case firstName
        case jobTitle
        case lastName
        case locale
        case phoneNumber
        case phoneNumbers
        case primaryTenantID = "primaryTenantId"
        case secondaryEmailAddress
        case secondaryTenantID = "secondaryTenantId"
        case userID = "userId"
        case userState
        case userType
    }
}

public struct UserEmailAddress: Codable {
    /// The email address
    public var address: String?
    /// The type of the email address
    public var type: String?

    public init(address: String? = nil, type: String? = nil) {
        self.address = address
        self.type = type
    }
}

public struct UserPhoneNumber: Codable {
    /// The phone number
    public var phoneNumber: String?
    /// The type of the phone number
    public var type: String?

    public init(phoneNumber: String? = nil, type: String? = nil) {
        self.phoneNumber = phoneNumber
        self.type = type
    }
}

public struct V2DistributedClientInfo: Codable {
    /// The client id
    public var clientID: String?
    /// The version of the client
    public var clientVersion: String?
    /// The device sub type
    public var deviceSubtype: String?
    /// The devicetype
    public var deviceType: String?
    /// The hardware model
    public var hardwareModel: String?
    /// The home node name
    public var homeNode: String?
    /// The manufacturer
    public var manufacturer: String?
    /// The version of the operating system
    public var osVersion: String?
    /// The user id
    public var userID: String?

    public init(clientID: String? = nil, clientVersion: String? = nil, deviceSubtype: String? = nil, deviceType: String? = nil, hardwareModel: String? = nil, homeNode: String? = nil, manufacturer: String? = nil, osVersion: String? = nil, userID: String? = nil) {
        self.clientID = clientID
        self.clientVersion = clientVersion
        self.deviceSubtype = deviceSubtype
        self.deviceType = deviceType
        self.hardwareModel = hardwareModel
        self.homeNode = homeNode
        self.manufacturer = manufacturer
        self.osVersion = osVersion
        self.userID = userID
    }

    private enum CodingKeys: String, CodingKey {
        case clientID = "clientId"
        case clientVersion
        case deviceSubtype
        case deviceType
        case hardwareModel
        case homeNode
        case manufacturer
        case osVersion
        case userID = "userId"
    }
}

public struct WebHook: Codable {
    /// The time when this WebHook was created. This does not necessary mean the time when an manifest file was created.
    public var creationTime: Double?
    /// An optional list of filter parameters for this webhook.
    public var filter: [String]?
    /// The unique identifier for this webhook. Can be used later to unregister the webhook.
    public var id: String?
    /// The optional list of userids for which this webhook is subscribed, i.e. presence events for the user are forwarded to the WebHook callback URL.
    public var subscriptionIDs: [String]?
    /// The type of a WebHook. This can either be MANUAL or EXTENSION. While manual WebHooks are only temporary and for development only use, permanent ones (EXTENSION) will bemanaged by the system.
    public var type: String?
    /// The callback URL of this webhook.
    public var url: String?
    /// The user ID for which this webhook is subscribed, i.e. events for this user are forwarded to the WebHook callback URL.
    public var userID: String?

    public init(creationTime: Double? = nil, filter: [String]? = nil, id: String? = nil, subscriptionIDs: [String]? = nil, type: String? = nil, url: String? = nil, userID: String? = nil) {
        self.creationTime = creationTime
        self.filter = filter
        self.id = id
        self.subscriptionIDs = subscriptionIDs
        self.type = type
        self.url = url
        self.userID = userID
    }

    private enum CodingKeys: String, CodingKey {
        case creationTime
        case filter
        case id
        case subscriptionIDs = "subscriptionIds"
        case type
        case url
        case userID = "userId"
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
