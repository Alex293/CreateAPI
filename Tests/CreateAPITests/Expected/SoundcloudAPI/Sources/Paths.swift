// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var connect: Connect {
        Connect(path: "/connect")
    }

    public struct Connect {
        /// Path: `/connect`
        public let path: String

        /// The OAuth2 authorization endpoint. Your app redirects a user to this endpoint, allowing them to delegate access to their account.
        ///
        /// <h3>Security Advice</h3>
        /// * Using the [implicit OAuth authorization flow](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-16#section-2.1.2) (`response_type=token`)  is **not recommended**. It can suffer from access token leakage and access token replay attacks. Use `response_type=code` instead.
        /// * Use the `state` parameter for [CSRF protection](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-16#section-4.7). Pass a sufficient  random nonce here and verify this nonce again after retrieving the token.
        public func get(parameters: GetParameters) -> Request<Void> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var clientID: String
            public var redirectUri: String
            public var responseType: ResponseType
            public var scope: String
            public var state: String?

            public enum ResponseType: String, Codable, CaseIterable {
                case code
                case token
                case codeAndToken = "code_and_token"
            }

            public init(clientID: String, redirectUri: String, responseType: ResponseType, scope: String, state: String? = nil) {
                self.clientID = clientID
                self.redirectUri = redirectUri
                self.responseType = responseType
                self.scope = scope
                self.state = state
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(clientID, forKey: "client_id")
                encoder.encode(redirectUri, forKey: "redirect_uri")
                encoder.encode(responseType, forKey: "response_type")
                encoder.encode(scope, forKey: "scope")
                encoder.encode(state, forKey: "state")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var oauth2: Oauth2 {
        Oauth2(path: "/oauth2")
    }

    public struct Oauth2 {
        /// Path: `/oauth2`
        public let path: String
    }
}

extension Paths.Oauth2 {
    public var token: Token {
        Token(path: path + "/token")
    }

    public struct Token {
        /// Path: `/oauth2/token`
        public let path: String

        /// This endpoint accepts POST requests and is used to provision access tokens once a user has authorized your application.
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public enum PostRequest: Encodable {
            case authorizationCode(SoundcloudAPI.AuthorizationCode)
            case refreshToken(SoundcloudAPI.RefreshToken)
            case password(SoundcloudAPI.Password)

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                switch self {
                case .authorizationCode(let value): encoder.encode(value, forKey: "value")
                case .refreshToken(let value): encoder.encode(value, forKey: "value")
                case .password(let value): encoder.encode(value, forKey: "value")
                }
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var me: Me {
        Me(path: "/me")
    }

    public struct Me {
        /// Path: `/me`
        public let path: String

        /// Returns the authenticated userâ€™s information.
        public var get: Request<SoundcloudAPI.CompleteUser> {
            .get(path)
        }
    }
}

extension Paths.Me {
    public var activities: Activities {
        Activities(path: path + "/activities")
    }

    public struct Activities {
        /// Path: `/me/activities`
        public let path: String

        /// Returns the authenticated user's activities.
        public func get(access: [Access]? = nil, limit: Int? = nil) -> Request<SoundcloudAPI.Activities> {
            .get(path, query: makeGetQuery(access, limit))
        }

        private func makeGetQuery(_ access: [Access]?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(access, forKey: "access", explode: false)
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }

        public enum Access: String, Codable, CaseIterable {
            case playable
            case preview
            case blocked
        }
    }
}

extension Paths.Me.Activities {
    public var all: All {
        All(path: path + "/all")
    }

    public struct All {
        /// Path: `/me/activities/all`
        public let path: String
    }
}

extension Paths.Me.Activities.All {
    public var own: Own {
        Own(path: path + "/own")
    }

    public struct Own {
        /// Path: `/me/activities/all/own`
        public let path: String

        /// Recent the authenticated user's activities.
        public func get(access: [Access]? = nil, limit: Int? = nil) -> Request<SoundcloudAPI.Activities> {
            .get(path, query: makeGetQuery(access, limit))
        }

        private func makeGetQuery(_ access: [Access]?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(access, forKey: "access", explode: false)
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }

        public enum Access: String, Codable, CaseIterable {
            case playable
            case preview
            case blocked
        }
    }
}

extension Paths.Me.Activities {
    public var tracks: Tracks {
        Tracks(path: path + "/tracks")
    }

    public struct Tracks {
        /// Path: `/me/activities/tracks`
        public let path: String

        /// Returns the authenticated user's recent track related activities.
        public func get(access: [Access]? = nil, limit: Int? = nil) -> Request<SoundcloudAPI.Activities> {
            .get(path, query: makeGetQuery(access, limit))
        }

        private func makeGetQuery(_ access: [Access]?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(access, forKey: "access", explode: false)
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }

        public enum Access: String, Codable, CaseIterable {
            case playable
            case preview
            case blocked
        }
    }
}

extension Paths.Me {
    public var connections: Connections {
        Connections(path: path + "/connections")
    }

    public struct Connections {
        /// Path: `/me/connections`
        public let path: String

        /// Returns a list of the authenticated user's connected social accounts.
        public func get(limit: Int? = nil, offset: Int? = nil) -> Request<[SoundcloudAPI.Connection]> {
            .get(path, query: makeGetQuery(limit, offset))
        }

        private func makeGetQuery(_ limit: Int?, _ offset: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            encoder.encode(offset, forKey: "offset")
            return encoder.items
        }
    }
}

extension Paths.Me.Connections {
    public func connectionID(_ connectionID: Int) -> WithConnectionID {
        WithConnectionID(path: "\(path)/\(connectionID)")
    }

    public struct WithConnectionID {
        /// Path: `/me/connections/{connection_id}`
        public let path: String

        /// Returns the authenticated user's connected social account.
        public var get: Request<SoundcloudAPI.Connection> {
            .get(path)
        }
    }
}

extension Paths.Me {
    public var likes: Likes {
        Likes(path: path + "/likes")
    }

    public struct Likes {
        /// Path: `/me/likes`
        public let path: String
    }
}

extension Paths.Me.Likes {
    public var tracks: Tracks {
        Tracks(path: path + "/tracks")
    }

    public struct Tracks {
        /// Path: `/me/likes/tracks`
        public let path: String

        /// Returns a list of favorited or liked tracks of the authenticated user.
        public func get(limit: Int? = nil, isLinkedPartitioning: Bool? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(limit, isLinkedPartitioning))
        }

        public enum GetResponse: Decodable {
            case tracks(SoundcloudAPI.Tracks)
            case tracks2([SoundcloudAPI.Track])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(SoundcloudAPI.Tracks.self) {
                    self = .tracks(value)
                } else if let value = try? container.decode([SoundcloudAPI.Track].self) {
                    self = .tracks2(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        private func makeGetQuery(_ limit: Int?, _ isLinkedPartitioning: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            encoder.encode(isLinkedPartitioning, forKey: "linked_partitioning")
            return encoder.items
        }
    }
}

extension Paths.Me {
    public var favorites: Favorites {
        Favorites(path: path + "/favorites")
    }

    public struct Favorites {
        /// Path: `/me/favorites`
        public let path: String
    }
}

extension Paths.Me.Favorites {
    public var ids: IDs {
        IDs(path: path + "/ids")
    }

    public struct IDs {
        /// Path: `/me/favorites/ids`
        public let path: String

        /// Returns userâ€™s favorites ids. (use /me/likes/tracks instead to fetch the authenticated user's likes)
        @available(*, deprecated, message: "Deprecated")
        public func get(limit: Int? = nil) -> Request<Void> {
            .get(path, query: makeGetQuery(limit))
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.Me {
    public var followings: Followings {
        Followings(path: path + "/followings")
    }

    public struct Followings {
        /// Path: `/me/followings`
        public let path: String

        /// Returns a list of users who are followed by the authenticated user.
        public func get(limit: Int? = nil, offset: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(limit, offset))
        }

        public enum GetResponse: Decodable {
            case users(SoundcloudAPI.Users)
            case usersListItems([UsersListItem])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(SoundcloudAPI.Users.self) {
                    self = .users(value)
                } else if let value = try? container.decode([UsersListItem].self) {
                    self = .usersListItems(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        private func makeGetQuery(_ limit: Int?, _ offset: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            encoder.encode(offset, forKey: "offset")
            return encoder.items
        }
    }
}

extension Paths.Me.Followings {
    public var tracks: Tracks {
        Tracks(path: path + "/tracks")
    }

    public struct Tracks {
        /// Path: `/me/followings/tracks`
        public let path: String

        /// Returns a list of recent tracks from users followed by the authenticated user.
        public func get(parameters: GetParameters? = nil) -> Request<[SoundcloudAPI.Track]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var access: [Access]?
            public var limit: Int?
            public var offset: Int?

            public enum Access: String, Codable, CaseIterable {
                case playable
                case preview
                case blocked
            }

            public init(access: [Access]? = nil, limit: Int? = nil, offset: Int? = nil) {
                self.access = access
                self.limit = limit
                self.offset = offset
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(access, forKey: "access", explode: false)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                return encoder.items
            }
        }
    }
}

extension Paths.Me.Followings {
    public func userID(_ userID: Int) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/me/followings/{user_id}`
        public let path: String

        /// Returns a user who is followed by the authenticated user. (use /users/{user_id} instead, to fetch the user details)
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<SoundcloudAPI.User> {
            .get(path)
        }

        /// Follows a user.
        public var put: Request<String> {
            .put(path)
        }

        /// Deletes a user who is followed by the authenticated user.
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths.Me {
    public var followers: Followers {
        Followers(path: path + "/followers")
    }

    public struct Followers {
        /// Path: `/me/followers`
        public let path: String

        /// Returns a list of users who are following the authenticated user.
        public func get(limit: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(limit))
        }

        public enum GetResponse: Decodable {
            case users(SoundcloudAPI.Users)
            case usersListItems([UsersListItem])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(SoundcloudAPI.Users.self) {
                    self = .users(value)
                } else if let value = try? container.decode([UsersListItem].self) {
                    self = .usersListItems(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.Me.Followers {
    public func followerID(_ followerID: Int) -> WithFollowerID {
        WithFollowerID(path: "\(path)/\(followerID)")
    }

    public struct WithFollowerID {
        /// Path: `/me/followers/{follower_id}`
        public let path: String

        /// Returns a user who is following the authenticated user. (use /users/{user_id} instead, to fetch the user details)
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<SoundcloudAPI.User> {
            .get(path)
        }
    }
}

extension Paths.Me {
    public var playlists: Playlists {
        Playlists(path: path + "/playlists")
    }

    public struct Playlists {
        /// Path: `/me/playlists`
        public let path: String

        /// Returns userâ€™s playlists (sets).
        ///
        /// Returns playlist info, playlist tracks and tracks owner info.
        public func get(limit: Int? = nil) -> Request<[SoundcloudAPI.Playlist]> {
            .get(path, query: makeGetQuery(limit))
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.Me.Playlists {
    public func playlistID(_ playlistID: Int) -> WithPlaylistID {
        WithPlaylistID(path: "\(path)/\(playlistID)")
    }

    public struct WithPlaylistID {
        /// Path: `/me/playlists/{playlist_id}`
        public let path: String

        /// Returns playlist. (use /playlists/{playlist_id} instead, to fetch the playlist details)
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<SoundcloudAPI.Playlist> {
            .get(path)
        }
    }
}

extension Paths.Me {
    public var tracks: Tracks {
        Tracks(path: path + "/tracks")
    }

    public struct Tracks {
        /// Path: `/me/tracks`
        public let path: String

        /// Returns a list of user's tracks.
        public func get(limit: Int? = nil, isLinkedPartitioning: Bool? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(limit, isLinkedPartitioning))
        }

        public enum GetResponse: Decodable {
            case tracks(SoundcloudAPI.Tracks)
            case tracks2([SoundcloudAPI.Track])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(SoundcloudAPI.Tracks.self) {
                    self = .tracks(value)
                } else if let value = try? container.decode([SoundcloudAPI.Track].self) {
                    self = .tracks2(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        private func makeGetQuery(_ limit: Int?, _ isLinkedPartitioning: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            encoder.encode(isLinkedPartitioning, forKey: "linked_partitioning")
            return encoder.items
        }
    }
}

extension Paths.Me.Tracks {
    public func trackID(_ trackID: Int) -> WithTrackID {
        WithTrackID(path: "\(path)/\(trackID)")
    }

    public struct WithTrackID {
        /// Path: `/me/tracks/{track_id}`
        public let path: String

        /// Returns a specified track. (use /tracks/{track_id} instead, to fetch the track details)
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<SoundcloudAPI.Track> {
            .get(path)
        }
    }
}

extension Paths {
    public static var tracks: Tracks {
        Tracks(path: "/tracks")
    }

    public struct Tracks {
        /// Path: `/tracks`
        public let path: String

        /// Performs a track search based on a query
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public enum GetResponse: Decodable {
            case tracks(SoundcloudAPI.Tracks)
            case tracks2([SoundcloudAPI.Track])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(SoundcloudAPI.Tracks.self) {
                    self = .tracks(value)
                } else if let value = try? container.decode([SoundcloudAPI.Track].self) {
                    self = .tracks2(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        public struct GetParameters {
            public var q: String
            public var ids: String?
            public var genres: String?
            public var tags: String?
            public var bpm: Bpm?
            public var duration: Duration?
            public var createdAt: CreatedAt?
            public var access: [Access]?
            public var limit: Int?
            public var offset: Int?
            public var isLinkedPartitioning: Bool?

            public struct Bpm: Codable {
                /// Return tracks with at least this bpm value
                ///
                /// Example: 123
                public var from: Int?
                /// Return tracks with at most this bpm value
                ///
                /// Example: 456
                public var to: Int?

                public init(from: Int? = nil, to: Int? = nil) {
                    self.from = from
                    self.to = to
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(from, forKey: "from")
                    encoder.encode(to, forKey: "to")
                    return encoder.items
                }
            }

            public struct Duration: Codable {
                /// Return tracks with at least this duration value
                ///
                /// Example: 123456
                public var from: Int?
                /// Return tracks with at most this duration value
                ///
                /// Example: 456789
                public var to: Int?

                public init(from: Int? = nil, to: Int? = nil) {
                    self.from = from
                    self.to = to
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(from, forKey: "from")
                    encoder.encode(to, forKey: "to")
                    return encoder.items
                }
            }

            public struct CreatedAt: Codable {
                /// (yyyy-mm-dd hh:mm:ss) return tracks created at this date or later
                ///
                /// Example: "2020-12-24T00:00:00.000Z"
                public var from: String?
                /// (yyyy-mm-dd hh:mm:ss) return tracks created at this date or earlier
                ///
                /// Example: "2020-12-26T00:00:00.000Z"
                public var to: String?

                public init(from: String? = nil, to: String? = nil) {
                    self.from = from
                    self.to = to
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(from, forKey: "from")
                    encoder.encode(to, forKey: "to")
                    return encoder.items
                }
            }

            public enum Access: String, Codable, CaseIterable {
                case playable
                case preview
                case blocked
            }

            public init(q: String, ids: String? = nil, genres: String? = nil, tags: String? = nil, bpm: Bpm? = nil, duration: Duration? = nil, createdAt: CreatedAt? = nil, access: [Access]? = nil, limit: Int? = nil, offset: Int? = nil, isLinkedPartitioning: Bool? = nil) {
                self.q = q
                self.ids = ids
                self.genres = genres
                self.tags = tags
                self.bpm = bpm
                self.duration = duration
                self.createdAt = createdAt
                self.access = access
                self.limit = limit
                self.offset = offset
                self.isLinkedPartitioning = isLinkedPartitioning
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(q, forKey: "q")
                encoder.encode(ids, forKey: "ids")
                encoder.encode(genres, forKey: "genres")
                encoder.encode(tags, forKey: "tags")
                encoder.encode(bpm, forKey: "bpm", isDeepObject: true)
                encoder.encode(duration, forKey: "duration", isDeepObject: true)
                encoder.encode(createdAt, forKey: "created_at", isDeepObject: true)
                encoder.encode(access, forKey: "access")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(isLinkedPartitioning, forKey: "linked_partitioning")
                return encoder.items
            }
        }

        /// Uploads a new track.
        public func post(_ body: Data? = nil) -> Request<SoundcloudAPI.Track> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var playlists: Playlists {
        Playlists(path: "/playlists")
    }

    public struct Playlists {
        /// Path: `/playlists`
        public let path: String

        /// Performs a playlist search based on a query
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public enum GetResponse: Decodable {
            case playlists(SoundcloudAPI.Playlists)
            case playlists2([SoundcloudAPI.Playlist])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(SoundcloudAPI.Playlists.self) {
                    self = .playlists(value)
                } else if let value = try? container.decode([SoundcloudAPI.Playlist].self) {
                    self = .playlists2(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        public struct GetParameters {
            public var q: String
            public var access: [Access]?
            public var limit: Int?
            public var offset: Int?
            public var isLinkedPartitioning: Bool?

            public enum Access: String, Codable, CaseIterable {
                case playable
                case preview
                case blocked
            }

            public init(q: String, access: [Access]? = nil, limit: Int? = nil, offset: Int? = nil, isLinkedPartitioning: Bool? = nil) {
                self.q = q
                self.access = access
                self.limit = limit
                self.offset = offset
                self.isLinkedPartitioning = isLinkedPartitioning
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(q, forKey: "q")
                encoder.encode(access, forKey: "access", explode: false)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(isLinkedPartitioning, forKey: "linked_partitioning")
                return encoder.items
            }
        }

        /// Creates a playlist.
        public func post(_ body: SoundcloudAPI.CreateUpdatePlaylistRequest? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        /// Soundcloud Playlist Object
        public struct PostResponse: Decodable {
            /// Playlist title.
            public var title: String?
            /// Playlist identifier.
            public var id: Int?
            /// Type of Soundcloud object (playlist).
            public var kind: String?
            /// URL to a JPEG image.
            public var artworkURL: String?
            /// Created timestamp.
            public var createdAt: String?
            /// Playlist description.
            public var description: String?
            /// Is downloadable.
            public var isDownloadable: Bool?
            /// Playlist duration.
            public var duration: Int?
            /// European Article Number.
            public var ean: String?
            /// Embeddable by.
            public var embeddableBy: String?
            /// Playlist genre.
            public var genre: String?
            /// Label user identifier.
            public var labelID: Int?
            /// Label name.
            public var labelName: String?
            /// Last modified timestamp.
            public var lastModified: String?
            /// License.
            public var license: String?
            /// Playlist permalink.
            public var permalink: String?
            /// Playlist permalink URL.
            public var permalinkURL: String?
            /// Type of playlist.
            public var playlistType: String?
            /// Purchase title.
            public var purchaseTitle: String?
            /// Purchase URL.
            public var purchaseURL: String?
            /// Release.
            public var release: String?
            /// Day of release.
            public var releaseDay: Int?
            /// Month of release.
            public var releaseMonth: Int?
            /// Year of release.
            public var releaseYear: Int?
            /// Type of sharing (private/public).
            public var sharing: String?
            /// Is streamable.
            public var isStreamable: Bool?
            /// Tags.
            public var tagList: String?
            /// Count of tracks.
            public var trackCount: Int?
            /// List of tracks.
            public var tracks: [Track]?
            /// Playlist type.
            public var type: String?
            /// Playlist URI.
            public var uri: String?
            /// SoundCloud User object.
            public var user: SoundcloudAPI.MetaUser?
            /// User identifier.
            public var userID: Int?

            /// Soundcloud Track object.
            public struct Track: Decodable {
                /// Track title.
                public var title: String?
                /// URL to a JPEG image.
                public var artworkURL: String?
                /// Tempo.
                public var bpm: Int?
                /// Number of comments.
                public var commentCount: Int?
                /// Is commentable.
                public var isCommentable: Bool?
                /// Created timestamp.
                public var createdAt: String?
                /// Track description.
                public var description: String?
                /// NUmber of downloads.
                public var downloadCount: Int?
                /// Is downloadable.
                public var downloadable: String?
                /// Track duration.
                public var duration: Int?
                /// Embeddable by.
                ///
                /// - warning: Deprecated.
                public var embeddableBy: String?
                /// Number of favoritings.
                public var favoritingsCount: Int?
                /// Genre
                public var genre: String?
                /// Track identifier.
                public var id: Int?
                /// ISRC code.
                public var isrc: String?
                /// Key signature.
                public var keySignature: String?
                /// Type of object (track).
                public var kind: String?
                /// Label user name.
                public var labelName: String?
                /// License
                public var license: String?
                /// Permalink URL.
                public var permalinkURL: String?
                /// Number of plays.
                public var playbackCount: Int?
                /// Purchase title.
                public var purchaseTitle: String?
                /// Purchase URL.
                public var purchaseURL: String?
                /// Release.
                public var release: String?
                /// Day of release.
                public var releaseDay: Int?
                /// Month of release.
                public var releaseMonth: Int?
                /// Year of release.
                public var releaseYear: Int?
                /// Type of sharing (public/private).
                public var sharing: String?
                /// URL to stream.
                public var streamURL: String?
                /// Is streamable.
                public var isStreamable: Bool?
                /// Tags.
                public var tagList: String?
                /// Track URI.
                public var uri: String?
                /// SoundCloud User object.
                public var user: SoundcloudAPI.MetaUser?
                /// Is user's favourite.
                public var isUserFavorite: Bool?
                /// Number of plays by a user.
                public var userPlaybackCount: Int?
                /// Waveform URL.
                public var waveformURL: String?

                public init(title: String? = nil, artworkURL: String? = nil, bpm: Int? = nil, commentCount: Int? = nil, isCommentable: Bool? = nil, createdAt: String? = nil, description: String? = nil, downloadCount: Int? = nil, downloadable: String? = nil, duration: Int? = nil, embeddableBy: String? = nil, favoritingsCount: Int? = nil, genre: String? = nil, id: Int? = nil, isrc: String? = nil, keySignature: String? = nil, kind: String? = nil, labelName: String? = nil, license: String? = nil, permalinkURL: String? = nil, playbackCount: Int? = nil, purchaseTitle: String? = nil, purchaseURL: String? = nil, release: String? = nil, releaseDay: Int? = nil, releaseMonth: Int? = nil, releaseYear: Int? = nil, sharing: String? = nil, streamURL: String? = nil, isStreamable: Bool? = nil, tagList: String? = nil, uri: String? = nil, user: SoundcloudAPI.MetaUser? = nil, isUserFavorite: Bool? = nil, userPlaybackCount: Int? = nil, waveformURL: String? = nil) {
                    self.title = title
                    self.artworkURL = artworkURL
                    self.bpm = bpm
                    self.commentCount = commentCount
                    self.isCommentable = isCommentable
                    self.createdAt = createdAt
                    self.description = description
                    self.downloadCount = downloadCount
                    self.downloadable = downloadable
                    self.duration = duration
                    self.embeddableBy = embeddableBy
                    self.favoritingsCount = favoritingsCount
                    self.genre = genre
                    self.id = id
                    self.isrc = isrc
                    self.keySignature = keySignature
                    self.kind = kind
                    self.labelName = labelName
                    self.license = license
                    self.permalinkURL = permalinkURL
                    self.playbackCount = playbackCount
                    self.purchaseTitle = purchaseTitle
                    self.purchaseURL = purchaseURL
                    self.release = release
                    self.releaseDay = releaseDay
                    self.releaseMonth = releaseMonth
                    self.releaseYear = releaseYear
                    self.sharing = sharing
                    self.streamURL = streamURL
                    self.isStreamable = isStreamable
                    self.tagList = tagList
                    self.uri = uri
                    self.user = user
                    self.isUserFavorite = isUserFavorite
                    self.userPlaybackCount = userPlaybackCount
                    self.waveformURL = waveformURL
                }

                private enum CodingKeys: String, CodingKey {
                    case title
                    case artworkURL = "artwork_url"
                    case bpm
                    case commentCount = "comment_count"
                    case isCommentable = "commentable"
                    case createdAt = "created_at"
                    case description
                    case downloadCount = "download_count"
                    case downloadable
                    case duration
                    case embeddableBy = "embeddable_by"
                    case favoritingsCount = "favoritings_count"
                    case genre
                    case id
                    case isrc
                    case keySignature = "key_signature"
                    case kind
                    case labelName = "label_name"
                    case license
                    case permalinkURL = "permalink_url"
                    case playbackCount = "playback_count"
                    case purchaseTitle = "purchase_title"
                    case purchaseURL = "purchase_url"
                    case release
                    case releaseDay = "release_day"
                    case releaseMonth = "release_month"
                    case releaseYear = "release_year"
                    case sharing
                    case streamURL = "stream_url"
                    case isStreamable = "streamable"
                    case tagList = "tag_list"
                    case uri
                    case user
                    case isUserFavorite = "user_favorite"
                    case userPlaybackCount = "user_playback_count"
                    case waveformURL = "waveform_url"
                }
            }

            public init(title: String? = nil, id: Int? = nil, kind: String? = nil, artworkURL: String? = nil, createdAt: String? = nil, description: String? = nil, isDownloadable: Bool? = nil, duration: Int? = nil, ean: String? = nil, embeddableBy: String? = nil, genre: String? = nil, labelID: Int? = nil, labelName: String? = nil, lastModified: String? = nil, license: String? = nil, permalink: String? = nil, permalinkURL: String? = nil, playlistType: String? = nil, purchaseTitle: String? = nil, purchaseURL: String? = nil, release: String? = nil, releaseDay: Int? = nil, releaseMonth: Int? = nil, releaseYear: Int? = nil, sharing: String? = nil, isStreamable: Bool? = nil, tagList: String? = nil, trackCount: Int? = nil, tracks: [Track]? = nil, type: String? = nil, uri: String? = nil, user: SoundcloudAPI.MetaUser? = nil, userID: Int? = nil) {
                self.title = title
                self.id = id
                self.kind = kind
                self.artworkURL = artworkURL
                self.createdAt = createdAt
                self.description = description
                self.isDownloadable = isDownloadable
                self.duration = duration
                self.ean = ean
                self.embeddableBy = embeddableBy
                self.genre = genre
                self.labelID = labelID
                self.labelName = labelName
                self.lastModified = lastModified
                self.license = license
                self.permalink = permalink
                self.permalinkURL = permalinkURL
                self.playlistType = playlistType
                self.purchaseTitle = purchaseTitle
                self.purchaseURL = purchaseURL
                self.release = release
                self.releaseDay = releaseDay
                self.releaseMonth = releaseMonth
                self.releaseYear = releaseYear
                self.sharing = sharing
                self.isStreamable = isStreamable
                self.tagList = tagList
                self.trackCount = trackCount
                self.tracks = tracks
                self.type = type
                self.uri = uri
                self.user = user
                self.userID = userID
            }

            private enum CodingKeys: String, CodingKey {
                case title
                case id
                case kind
                case artworkURL = "artwork_url"
                case createdAt = "created_at"
                case description
                case isDownloadable = "downloadable"
                case duration
                case ean
                case embeddableBy = "embeddable_by"
                case genre
                case labelID = "label_id"
                case labelName = "label_name"
                case lastModified = "last_modified"
                case license
                case permalink
                case permalinkURL = "permalink_url"
                case playlistType = "playlist_type"
                case purchaseTitle = "purchase_title"
                case purchaseURL = "purchase_url"
                case release
                case releaseDay = "release_day"
                case releaseMonth = "release_month"
                case releaseYear = "release_year"
                case sharing
                case isStreamable = "streamable"
                case tagList = "tag_list"
                case trackCount = "track_count"
                case tracks
                case type
                case uri
                case user
                case userID = "user_id"
            }
        }
    }
}

extension Paths {
    public static var users: Users {
        Users(path: "/users")
    }

    public struct Users {
        /// Path: `/users`
        public let path: String

        /// Performs a user search based on a query
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public enum GetResponse: Decodable {
            case users(SoundcloudAPI.Users)
            case usersListItems([UsersListItem])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(SoundcloudAPI.Users.self) {
                    self = .users(value)
                } else if let value = try? container.decode([UsersListItem].self) {
                    self = .usersListItems(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        public struct GetParameters {
            public var q: String
            public var ids: String?
            public var limit: Int?
            public var offset: Int?
            public var isLinkedPartitioning: Bool?

            public init(q: String, ids: String? = nil, limit: Int? = nil, offset: Int? = nil, isLinkedPartitioning: Bool? = nil) {
                self.q = q
                self.ids = ids
                self.limit = limit
                self.offset = offset
                self.isLinkedPartitioning = isLinkedPartitioning
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(q, forKey: "q")
                encoder.encode(ids, forKey: "ids")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(isLinkedPartitioning, forKey: "linked_partitioning")
                return encoder.items
            }
        }
    }
}

extension Paths.Playlists {
    public func playlistID(_ playlistID: Int) -> WithPlaylistID {
        WithPlaylistID(path: "\(path)/\(playlistID)")
    }

    public struct WithPlaylistID {
        /// Path: `/playlists/{playlist_id}`
        public let path: String

        /// Returns a playlist.
        public func get(secretToken: String? = nil, access: [Access]? = nil) -> Request<SoundcloudAPI.Playlist> {
            .get(path, query: makeGetQuery(secretToken, access))
        }

        private func makeGetQuery(_ secretToken: String?, _ access: [Access]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(secretToken, forKey: "secret_token")
            encoder.encode(access, forKey: "access", explode: false)
            return encoder.items
        }

        public enum Access: String, Codable, CaseIterable {
            case playable
            case preview
            case blocked
        }

        /// Updates a playlist.
        public func put(_ body: SoundcloudAPI.CreateUpdatePlaylistRequest? = nil) -> Request<PutResponse> {
            .put(path, body: body)
        }

        /// Soundcloud Playlist Object
        public struct PutResponse: Decodable {
            /// Playlist title.
            public var title: String?
            /// Playlist identifier.
            public var id: Int?
            /// Type of Soundcloud object (playlist).
            public var kind: String?
            /// URL to a JPEG image.
            public var artworkURL: String?
            /// Created timestamp.
            public var createdAt: String?
            /// Playlist description.
            public var description: String?
            /// Is downloadable.
            public var isDownloadable: Bool?
            /// Playlist duration.
            public var duration: Int?
            /// European Article Number.
            public var ean: String?
            /// Embeddable by.
            public var embeddableBy: String?
            /// Playlist genre.
            public var genre: String?
            /// Label user identifier.
            public var labelID: Int?
            /// Label name.
            public var labelName: String?
            /// Last modified timestamp.
            public var lastModified: String?
            /// License.
            public var license: String?
            /// Playlist permalink.
            public var permalink: String?
            /// Playlist permalink URL.
            public var permalinkURL: String?
            /// Type of playlist.
            public var playlistType: String?
            /// Purchase title.
            public var purchaseTitle: String?
            /// Purchase URL.
            public var purchaseURL: String?
            /// Release.
            public var release: String?
            /// Day of release.
            public var releaseDay: Int?
            /// Month of release.
            public var releaseMonth: Int?
            /// Year of release.
            public var releaseYear: Int?
            /// Type of sharing (private/public).
            public var sharing: String?
            /// Is streamable.
            public var isStreamable: Bool?
            /// Tags.
            public var tagList: String?
            /// Count of tracks.
            public var trackCount: Int?
            /// List of tracks.
            public var tracks: [Track]?
            /// Playlist type.
            public var type: String?
            /// Playlist URI.
            public var uri: String?
            /// SoundCloud User object.
            public var user: SoundcloudAPI.MetaUser?
            /// User identifier.
            public var userID: Int?

            /// Soundcloud Track object.
            public struct Track: Decodable {
                /// Track title.
                public var title: String?
                /// URL to a JPEG image.
                public var artworkURL: String?
                /// Tempo.
                public var bpm: Int?
                /// Number of comments.
                public var commentCount: Int?
                /// Is commentable.
                public var isCommentable: Bool?
                /// Created timestamp.
                public var createdAt: String?
                /// Track description.
                public var description: String?
                /// NUmber of downloads.
                public var downloadCount: Int?
                /// Is downloadable.
                public var downloadable: String?
                /// Track duration.
                public var duration: Int?
                /// Embeddable by.
                ///
                /// - warning: Deprecated.
                public var embeddableBy: String?
                /// Number of favoritings.
                public var favoritingsCount: Int?
                /// Genre
                public var genre: String?
                /// Track identifier.
                public var id: Int?
                /// ISRC code.
                public var isrc: String?
                /// Key signature.
                public var keySignature: String?
                /// Type of object (track).
                public var kind: String?
                /// Label user name.
                public var labelName: String?
                /// License
                public var license: String?
                /// Permalink URL.
                public var permalinkURL: String?
                /// Number of plays.
                public var playbackCount: Int?
                /// Purchase title.
                public var purchaseTitle: String?
                /// Purchase URL.
                public var purchaseURL: String?
                /// Release.
                public var release: String?
                /// Day of release.
                public var releaseDay: Int?
                /// Month of release.
                public var releaseMonth: Int?
                /// Year of release.
                public var releaseYear: Int?
                /// Type of sharing (public/private).
                public var sharing: String?
                /// URL to stream.
                public var streamURL: String?
                /// Is streamable.
                public var isStreamable: Bool?
                /// Tags.
                public var tagList: String?
                /// Track URI.
                public var uri: String?
                /// SoundCloud User object.
                public var user: SoundcloudAPI.MetaUser?
                /// Is user's favourite.
                public var isUserFavorite: Bool?
                /// Number of plays by a user.
                public var userPlaybackCount: Int?
                /// Waveform URL.
                public var waveformURL: String?

                public init(title: String? = nil, artworkURL: String? = nil, bpm: Int? = nil, commentCount: Int? = nil, isCommentable: Bool? = nil, createdAt: String? = nil, description: String? = nil, downloadCount: Int? = nil, downloadable: String? = nil, duration: Int? = nil, embeddableBy: String? = nil, favoritingsCount: Int? = nil, genre: String? = nil, id: Int? = nil, isrc: String? = nil, keySignature: String? = nil, kind: String? = nil, labelName: String? = nil, license: String? = nil, permalinkURL: String? = nil, playbackCount: Int? = nil, purchaseTitle: String? = nil, purchaseURL: String? = nil, release: String? = nil, releaseDay: Int? = nil, releaseMonth: Int? = nil, releaseYear: Int? = nil, sharing: String? = nil, streamURL: String? = nil, isStreamable: Bool? = nil, tagList: String? = nil, uri: String? = nil, user: SoundcloudAPI.MetaUser? = nil, isUserFavorite: Bool? = nil, userPlaybackCount: Int? = nil, waveformURL: String? = nil) {
                    self.title = title
                    self.artworkURL = artworkURL
                    self.bpm = bpm
                    self.commentCount = commentCount
                    self.isCommentable = isCommentable
                    self.createdAt = createdAt
                    self.description = description
                    self.downloadCount = downloadCount
                    self.downloadable = downloadable
                    self.duration = duration
                    self.embeddableBy = embeddableBy
                    self.favoritingsCount = favoritingsCount
                    self.genre = genre
                    self.id = id
                    self.isrc = isrc
                    self.keySignature = keySignature
                    self.kind = kind
                    self.labelName = labelName
                    self.license = license
                    self.permalinkURL = permalinkURL
                    self.playbackCount = playbackCount
                    self.purchaseTitle = purchaseTitle
                    self.purchaseURL = purchaseURL
                    self.release = release
                    self.releaseDay = releaseDay
                    self.releaseMonth = releaseMonth
                    self.releaseYear = releaseYear
                    self.sharing = sharing
                    self.streamURL = streamURL
                    self.isStreamable = isStreamable
                    self.tagList = tagList
                    self.uri = uri
                    self.user = user
                    self.isUserFavorite = isUserFavorite
                    self.userPlaybackCount = userPlaybackCount
                    self.waveformURL = waveformURL
                }

                private enum CodingKeys: String, CodingKey {
                    case title
                    case artworkURL = "artwork_url"
                    case bpm
                    case commentCount = "comment_count"
                    case isCommentable = "commentable"
                    case createdAt = "created_at"
                    case description
                    case downloadCount = "download_count"
                    case downloadable
                    case duration
                    case embeddableBy = "embeddable_by"
                    case favoritingsCount = "favoritings_count"
                    case genre
                    case id
                    case isrc
                    case keySignature = "key_signature"
                    case kind
                    case labelName = "label_name"
                    case license
                    case permalinkURL = "permalink_url"
                    case playbackCount = "playback_count"
                    case purchaseTitle = "purchase_title"
                    case purchaseURL = "purchase_url"
                    case release
                    case releaseDay = "release_day"
                    case releaseMonth = "release_month"
                    case releaseYear = "release_year"
                    case sharing
                    case streamURL = "stream_url"
                    case isStreamable = "streamable"
                    case tagList = "tag_list"
                    case uri
                    case user
                    case isUserFavorite = "user_favorite"
                    case userPlaybackCount = "user_playback_count"
                    case waveformURL = "waveform_url"
                }
            }

            public init(title: String? = nil, id: Int? = nil, kind: String? = nil, artworkURL: String? = nil, createdAt: String? = nil, description: String? = nil, isDownloadable: Bool? = nil, duration: Int? = nil, ean: String? = nil, embeddableBy: String? = nil, genre: String? = nil, labelID: Int? = nil, labelName: String? = nil, lastModified: String? = nil, license: String? = nil, permalink: String? = nil, permalinkURL: String? = nil, playlistType: String? = nil, purchaseTitle: String? = nil, purchaseURL: String? = nil, release: String? = nil, releaseDay: Int? = nil, releaseMonth: Int? = nil, releaseYear: Int? = nil, sharing: String? = nil, isStreamable: Bool? = nil, tagList: String? = nil, trackCount: Int? = nil, tracks: [Track]? = nil, type: String? = nil, uri: String? = nil, user: SoundcloudAPI.MetaUser? = nil, userID: Int? = nil) {
                self.title = title
                self.id = id
                self.kind = kind
                self.artworkURL = artworkURL
                self.createdAt = createdAt
                self.description = description
                self.isDownloadable = isDownloadable
                self.duration = duration
                self.ean = ean
                self.embeddableBy = embeddableBy
                self.genre = genre
                self.labelID = labelID
                self.labelName = labelName
                self.lastModified = lastModified
                self.license = license
                self.permalink = permalink
                self.permalinkURL = permalinkURL
                self.playlistType = playlistType
                self.purchaseTitle = purchaseTitle
                self.purchaseURL = purchaseURL
                self.release = release
                self.releaseDay = releaseDay
                self.releaseMonth = releaseMonth
                self.releaseYear = releaseYear
                self.sharing = sharing
                self.isStreamable = isStreamable
                self.tagList = tagList
                self.trackCount = trackCount
                self.tracks = tracks
                self.type = type
                self.uri = uri
                self.user = user
                self.userID = userID
            }

            private enum CodingKeys: String, CodingKey {
                case title
                case id
                case kind
                case artworkURL = "artwork_url"
                case createdAt = "created_at"
                case description
                case isDownloadable = "downloadable"
                case duration
                case ean
                case embeddableBy = "embeddable_by"
                case genre
                case labelID = "label_id"
                case labelName = "label_name"
                case lastModified = "last_modified"
                case license
                case permalink
                case permalinkURL = "permalink_url"
                case playlistType = "playlist_type"
                case purchaseTitle = "purchase_title"
                case purchaseURL = "purchase_url"
                case release
                case releaseDay = "release_day"
                case releaseMonth = "release_month"
                case releaseYear = "release_year"
                case sharing
                case isStreamable = "streamable"
                case tagList = "tag_list"
                case trackCount = "track_count"
                case tracks
                case type
                case uri
                case user
                case userID = "user_id"
            }
        }

        /// Deletes a playlist.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Playlists.WithPlaylistID {
    public var tracks: Tracks {
        Tracks(path: path + "/tracks")
    }

    public struct Tracks {
        /// Path: `/playlists/{playlist_id}/tracks`
        public let path: String

        /// Returns tracks under a playlist.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public enum GetResponse: Decodable {
            case tracks(SoundcloudAPI.Tracks)
            case tracks2([SoundcloudAPI.Track])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(SoundcloudAPI.Tracks.self) {
                    self = .tracks(value)
                } else if let value = try? container.decode([SoundcloudAPI.Track].self) {
                    self = .tracks2(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        public struct GetParameters {
            public var secretToken: String?
            public var access: [Access]?
            public var isLinkedPartitioning: Bool?

            public enum Access: String, Codable, CaseIterable {
                case playable
                case preview
                case blocked
            }

            public init(secretToken: String? = nil, access: [Access]? = nil, isLinkedPartitioning: Bool? = nil) {
                self.secretToken = secretToken
                self.access = access
                self.isLinkedPartitioning = isLinkedPartitioning
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(secretToken, forKey: "secret_token")
                encoder.encode(access, forKey: "access", explode: false)
                encoder.encode(isLinkedPartitioning, forKey: "linked_partitioning")
                return encoder.items
            }
        }
    }
}

extension Paths.Playlists.WithPlaylistID {
    public var reposters: Reposters {
        Reposters(path: path + "/reposters")
    }

    public struct Reposters {
        /// Path: `/playlists/{playlist_id}/reposters`
        public let path: String

        /// Returns a collection of playlist's reposters.
        public func get(limit: Int? = nil) -> Request<SoundcloudAPI.MetaUsers> {
            .get(path, query: makeGetQuery(limit))
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.Tracks {
    public func trackID(_ trackID: Int) -> WithTrackID {
        WithTrackID(path: "\(path)/\(trackID)")
    }

    public struct WithTrackID {
        /// Path: `/tracks/{track_id}`
        public let path: String

        /// Returns a track.
        public func get(secretToken: String? = nil) -> Request<SoundcloudAPI.Track> {
            .get(path, query: makeGetQuery(secretToken))
        }

        private func makeGetQuery(_ secretToken: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(secretToken, forKey: "secret_token")
            return encoder.items
        }

        /// Updates a track's information.
        public func put(_ body: SoundcloudAPI.TrackMetadataRequest? = nil) -> Request<SoundcloudAPI.Track> {
            .put(path, body: body)
        }

        /// Deletes a track.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Tracks.WithTrackID {
    public var streams: Streams {
        Streams(path: path + "/streams")
    }

    public struct Streams {
        /// Path: `/tracks/{track_id}/streams`
        public let path: String

        /// Returns a track's streamable URLs
        public func get(secretToken: String? = nil) -> Request<SoundcloudAPI.Streams> {
            .get(path, query: makeGetQuery(secretToken))
        }

        private func makeGetQuery(_ secretToken: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(secretToken, forKey: "secret_token")
            return encoder.items
        }
    }
}

extension Paths.Tracks.WithTrackID {
    public var comments: Comments {
        Comments(path: path + "/comments")
    }

    public struct Comments {
        /// Path: `/tracks/{track_id}/comments`
        public let path: String

        /// Returns the comments posted on the track(track_id).
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public enum GetResponse: Decodable {
            case comments(SoundcloudAPI.Comments)
            case comments2([SoundcloudAPI.Comment])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(SoundcloudAPI.Comments.self) {
                    self = .comments(value)
                } else if let value = try? container.decode([SoundcloudAPI.Comment].self) {
                    self = .comments2(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        public struct GetParameters {
            public var limit: Int?
            public var offset: Int?
            public var isLinkedPartitioning: Bool?

            public init(limit: Int? = nil, offset: Int? = nil, isLinkedPartitioning: Bool? = nil) {
                self.limit = limit
                self.offset = offset
                self.isLinkedPartitioning = isLinkedPartitioning
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(isLinkedPartitioning, forKey: "linked_partitioning")
                return encoder.items
            }
        }

        /// Returns the newly created comment on success
        public func post(comment: PostRequest.Comment? = nil) -> Request<SoundcloudAPI.Comment> {
            .post(path, body: PostRequest(comment: comment))
        }

        public struct PostRequest: Encodable {
            public var comment: Comment?

            public struct Comment: Encodable {
                /// Comment's content
                ///
                /// Example: "test comment"
                public var body: String
                /// Timestamp of a comment. String or float representation is supported
                public var timestamp: Timestamp?

                /// Timestamp of a comment. String or float representation is supported
                public enum Timestamp: Encodable, Hashable {
                    case string(String)
                    case double(Double)

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.singleValueContainer()
                        switch self {
                        case .string(let value): try container.encode(value)
                        case .double(let value): try container.encode(value)
                        }
                    }
                }

                public init(body: String, timestamp: Timestamp? = nil) {
                    self.body = body
                    self.timestamp = timestamp
                }
            }

            public init(comment: Comment? = nil) {
                self.comment = comment
            }
        }
    }
}

extension Paths.Tracks.WithTrackID {
    public var favoriters: Favoriters {
        Favoriters(path: path + "/favoriters")
    }

    public struct Favoriters {
        /// Path: `/tracks/{track_id}/favoriters`
        public let path: String

        /// Returns a list of users who have favorited or liked the track.
        public func get(limit: Int? = nil, offset: Int? = nil) -> Request<[UsersListItem]> {
            .get(path, query: makeGetQuery(limit, offset))
        }

        private func makeGetQuery(_ limit: Int?, _ offset: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            encoder.encode(offset, forKey: "offset")
            return encoder.items
        }
    }
}

extension Paths.Tracks.WithTrackID {
    public var reposters: Reposters {
        Reposters(path: path + "/reposters")
    }

    public struct Reposters {
        /// Path: `/tracks/{track_id}/reposters`
        public let path: String

        /// Returns a collection of track's reposters.
        public func get(limit: Int? = nil) -> Request<SoundcloudAPI.MetaUsers> {
            .get(path, query: makeGetQuery(limit))
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.Tracks.WithTrackID {
    public var related: Related {
        Related(path: path + "/related")
    }

    public struct Related {
        /// Path: `/tracks/{track_id}/related`
        public let path: String

        /// Returns all related tracks of track on SoundCloud.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public enum GetResponse: Decodable {
            case tracks(SoundcloudAPI.Tracks)
            case tracks2([SoundcloudAPI.Track])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(SoundcloudAPI.Tracks.self) {
                    self = .tracks(value)
                } else if let value = try? container.decode([SoundcloudAPI.Track].self) {
                    self = .tracks2(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        public struct GetParameters {
            public var access: [Access]?
            public var limit: Int?
            public var offset: Int?
            public var isLinkedPartitioning: Bool?

            public enum Access: String, Codable, CaseIterable {
                case playable
                case preview
                case blocked
            }

            public init(access: [Access]? = nil, limit: Int? = nil, offset: Int? = nil, isLinkedPartitioning: Bool? = nil) {
                self.access = access
                self.limit = limit
                self.offset = offset
                self.isLinkedPartitioning = isLinkedPartitioning
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(access, forKey: "access", explode: false)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(isLinkedPartitioning, forKey: "linked_partitioning")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var resolve: Resolve {
        Resolve(path: "/resolve")
    }

    public struct Resolve {
        /// Path: `/resolve`
        public let path: String

        /// Resolves soundcloud.com URLs to Resource URLs to use with the API.
        public func get(url: String) -> Request<Void> {
            .get(path, query: [("url", url)])
        }
    }
}

extension Paths.Users {
    public func userID(_ userID: Int) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/users/{user_id}`
        public let path: String

        /// Returns a user.
        public var get: Request<SoundcloudAPI.CompleteUser> {
            .get(path)
        }
    }
}

extension Paths.Users.WithUserID {
    public var comments: Comments {
        Comments(path: path + "/comments")
    }

    public struct Comments {
        /// Path: `/users/{user_id}/comments`
        public let path: String

        /// Returns a list of user's comments.
        public func get(limit: Int? = nil, offset: Int? = nil) -> Request<[SoundcloudAPI.Comment]> {
            .get(path, query: makeGetQuery(limit, offset))
        }

        private func makeGetQuery(_ limit: Int?, _ offset: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            encoder.encode(offset, forKey: "offset")
            return encoder.items
        }
    }
}

extension Paths.Users.WithUserID {
    public var favorites: Favorites {
        Favorites(path: path + "/favorites")
    }

    public struct Favorites {
        /// Path: `/users/{user_id}/favorites`
        public let path: String

        /// Returns a list of user's favorited or liked tracks. (use /users/:userId/likes/tracks instead, to fetch a user's likes)
        @available(*, deprecated, message: "Deprecated")
        public func get(limit: Int? = nil, isLinkedPartitioning: Bool? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(limit, isLinkedPartitioning))
        }

        public enum GetResponse: Decodable {
            case tracks(SoundcloudAPI.Tracks)
            case tracks2([SoundcloudAPI.Track])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(SoundcloudAPI.Tracks.self) {
                    self = .tracks(value)
                } else if let value = try? container.decode([SoundcloudAPI.Track].self) {
                    self = .tracks2(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        private func makeGetQuery(_ limit: Int?, _ isLinkedPartitioning: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            encoder.encode(isLinkedPartitioning, forKey: "linked_partitioning")
            return encoder.items
        }
    }
}

extension Paths.Users.WithUserID {
    public var followers: Followers {
        Followers(path: path + "/followers")
    }

    public struct Followers {
        /// Path: `/users/{user_id}/followers`
        public let path: String

        /// Returns a list of userâ€™s followers.
        ///
        /// Returns a list of users that follows (user_id).
        public func get(limit: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(limit))
        }

        public enum GetResponse: Decodable {
            case users(SoundcloudAPI.Users)
            case usersListItems([UsersListItem])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(SoundcloudAPI.Users.self) {
                    self = .users(value)
                } else if let value = try? container.decode([UsersListItem].self) {
                    self = .usersListItems(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.Users.WithUserID {
    public var followings: Followings {
        Followings(path: path + "/followings")
    }

    public struct Followings {
        /// Path: `/users/{user_id}/followings`
        public let path: String

        /// Returns a list of userâ€™s followings.
        ///
        /// Returns list of users that (user_id) follows.
        public func get(limit: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(limit))
        }

        public enum GetResponse: Decodable {
            case users(SoundcloudAPI.Users)
            case usersListItems([UsersListItem])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(SoundcloudAPI.Users.self) {
                    self = .users(value)
                } else if let value = try? container.decode([UsersListItem].self) {
                    self = .usersListItems(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.Users.WithUserID.Followings {
    public func followingID(_ followingID: Int) -> WithFollowingID {
        WithFollowingID(path: "\(path)/\(followingID)")
    }

    public struct WithFollowingID {
        /// Path: `/users/{user_id}/followings/{following_id}`
        public let path: String

        /// Returns a user's following. (use /users/{user_id} instead, to fetch the user details)
        ///
        /// Returns (following_id) that is followed by (user_id).
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<SoundcloudAPI.CompleteUser> {
            .get(path)
        }
    }
}

extension Paths.Users.WithUserID {
    public var playlists: Playlists {
        Playlists(path: path + "/playlists")
    }

    public struct Playlists {
        /// Path: `/users/{user_id}/playlists`
        public let path: String

        /// Returns a list of user's playlists.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public enum GetResponse: Decodable {
            case playlists(SoundcloudAPI.Playlists)
            case playlists2([SoundcloudAPI.Playlist])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(SoundcloudAPI.Playlists.self) {
                    self = .playlists(value)
                } else if let value = try? container.decode([SoundcloudAPI.Playlist].self) {
                    self = .playlists2(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        public struct GetParameters {
            public var access: [Access]?
            public var limit: Int?
            public var isLinkedPartitioning: Bool?

            public enum Access: String, Codable, CaseIterable {
                case playable
                case preview
                case blocked
            }

            public init(access: [Access]? = nil, limit: Int? = nil, isLinkedPartitioning: Bool? = nil) {
                self.access = access
                self.limit = limit
                self.isLinkedPartitioning = isLinkedPartitioning
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(access, forKey: "access", explode: false)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(isLinkedPartitioning, forKey: "linked_partitioning")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithUserID {
    public var tracks: Tracks {
        Tracks(path: path + "/tracks")
    }

    public struct Tracks {
        /// Path: `/users/{user_id}/tracks`
        public let path: String

        /// Returns a list of user's tracks.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public enum GetResponse: Decodable {
            case tracks(SoundcloudAPI.Tracks)
            case tracks2([SoundcloudAPI.Track])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(SoundcloudAPI.Tracks.self) {
                    self = .tracks(value)
                } else if let value = try? container.decode([SoundcloudAPI.Track].self) {
                    self = .tracks2(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        public struct GetParameters {
            public var access: [Access]?
            public var limit: Int?
            public var isLinkedPartitioning: Bool?

            public enum Access: String, Codable, CaseIterable {
                case playable
                case preview
                case blocked
            }

            public init(access: [Access]? = nil, limit: Int? = nil, isLinkedPartitioning: Bool? = nil) {
                self.access = access
                self.limit = limit
                self.isLinkedPartitioning = isLinkedPartitioning
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(access, forKey: "access", explode: false)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(isLinkedPartitioning, forKey: "linked_partitioning")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithUserID {
    public var webProfiles: WebProfiles {
        WebProfiles(path: path + "/web-profiles")
    }

    public struct WebProfiles {
        /// Path: `/users/{user_id}/web-profiles`
        public let path: String

        /// Returns list of user's links added to their profile (website, facebook, instagram).
        public func get(limit: Int? = nil) -> Request<[WebProfile]> {
            .get(path, query: makeGetQuery(limit))
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.Users.WithUserID {
    public var likes: Likes {
        Likes(path: path + "/likes")
    }

    public struct Likes {
        /// Path: `/users/{user_id}/likes`
        public let path: String
    }
}

extension Paths.Users.WithUserID.Likes {
    public var tracks: Tracks {
        Tracks(path: path + "/tracks")
    }

    public struct Tracks {
        /// Path: `/users/{user_id}/likes/tracks`
        public let path: String

        /// Returns a list of user's liked tracks.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public enum GetResponse: Decodable {
            case tracks(SoundcloudAPI.Tracks)
            case tracks2([SoundcloudAPI.Track])

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(SoundcloudAPI.Tracks.self) {
                    self = .tracks(value)
                } else if let value = try? container.decode([SoundcloudAPI.Track].self) {
                    self = .tracks2(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        public struct GetParameters {
            public var access: [Access]?
            public var limit: Int?
            public var isLinkedPartitioning: Bool?

            public enum Access: String, Codable, CaseIterable {
                case playable
                case preview
                case blocked
            }

            public init(access: [Access]? = nil, limit: Int? = nil, isLinkedPartitioning: Bool? = nil) {
                self.access = access
                self.limit = limit
                self.isLinkedPartitioning = isLinkedPartitioning
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(access, forKey: "access", explode: false)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(isLinkedPartitioning, forKey: "linked_partitioning")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var likes: Likes {
        Likes(path: "/likes")
    }

    public struct Likes {
        /// Path: `/likes`
        public let path: String
    }
}

extension Paths.Likes {
    public var tracks: Tracks {
        Tracks(path: path + "/tracks")
    }

    public struct Tracks {
        /// Path: `/likes/tracks`
        public let path: String
    }
}

extension Paths.Likes.Tracks {
    public func trackID(_ trackID: Int) -> WithTrackID {
        WithTrackID(path: "\(path)/\(trackID)")
    }

    public struct WithTrackID {
        /// Path: `/likes/tracks/{track_id}`
        public let path: String

        /// Likes a track.
        public var post: Request<String> {
            .post(path)
        }

        /// Unlikes a track.
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths.Likes {
    public var playlists: Playlists {
        Playlists(path: path + "/playlists")
    }

    public struct Playlists {
        /// Path: `/likes/playlists`
        public let path: String
    }
}

extension Paths.Likes.Playlists {
    public func playlistID(_ playlistID: Int) -> WithPlaylistID {
        WithPlaylistID(path: "\(path)/\(playlistID)")
    }

    public struct WithPlaylistID {
        /// Path: `/likes/playlists/{playlist_id}`
        public let path: String

        /// Likes a playlist.
        public var post: Request<String> {
            .post(path)
        }

        /// Unlikes a playlist.
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var reposts: Reposts {
        Reposts(path: "/reposts")
    }

    public struct Reposts {
        /// Path: `/reposts`
        public let path: String
    }
}

extension Paths.Reposts {
    public var tracks: Tracks {
        Tracks(path: path + "/tracks")
    }

    public struct Tracks {
        /// Path: `/reposts/tracks`
        public let path: String
    }
}

extension Paths.Reposts.Tracks {
    public func trackID(_ trackID: Int) -> WithTrackID {
        WithTrackID(path: "\(path)/\(trackID)")
    }

    public struct WithTrackID {
        /// Path: `/reposts/tracks/{track_id}`
        public let path: String

        /// Reposts a track as the authenticated user
        public var post: Request<Void> {
            .post(path)
        }

        /// Removes a repost on a track as the authenticated user
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Reposts {
    public var playlists: Playlists {
        Playlists(path: path + "/playlists")
    }

    public struct Playlists {
        /// Path: `/reposts/playlists`
        public let path: String
    }
}

extension Paths.Reposts.Playlists {
    public func playlistID(_ playlistID: Int) -> WithPlaylistID {
        WithPlaylistID(path: "\(path)/\(playlistID)")
    }

    public struct WithPlaylistID {
        /// Path: `/reposts/playlists/{playlist_id}`
        public let path: String

        /// Reposts a playlist as the authenticated user
        public var post: Request<Void> {
            .post(path)
        }

        /// Removes a repost on a playlist as the authenticated user
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

public enum Paths {}
