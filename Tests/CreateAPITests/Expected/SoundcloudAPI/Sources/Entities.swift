// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

public struct AuthorizationCode: Codable {
    public var grantType: GrantType?
    /// Authorization code
    public var authorizationCode: String?
    /// Client ID
    public var clientID: String?
    /// Redirect URI
    public var redirectUri: String?
    /// Client secret
    public var clientSecret: String?

    public enum GrantType: String, Codable, CaseIterable {
        case authorizationCode = "authorization_code"
        case clientCredentials = "client_credentials"
    }

    public init(grantType: GrantType? = nil, authorizationCode: String? = nil, clientID: String? = nil, redirectUri: String? = nil, clientSecret: String? = nil) {
        self.grantType = grantType
        self.authorizationCode = authorizationCode
        self.clientID = clientID
        self.redirectUri = redirectUri
        self.clientSecret = clientSecret
    }

    private enum CodingKeys: String, CodingKey {
        case grantType = "grant_type"
        case authorizationCode = "authorization_code"
        case clientID = "client_id"
        case redirectUri = "redirect_uri"
        case clientSecret = "client_secret"
    }
}

public struct RefreshToken: Codable {
    public var grantType: GrantType?
    /// Refresh token
    public var refreshToken: String?
    /// Client ID
    public var clientID: String?
    /// Redirect URI
    public var redirectUri: String?
    /// Client secret
    public var clientSecret: String?

    public enum GrantType: String, Codable, CaseIterable {
        case refreshToken = "refresh_token"
    }

    public init(grantType: GrantType? = nil, refreshToken: String? = nil, clientID: String? = nil, redirectUri: String? = nil, clientSecret: String? = nil) {
        self.grantType = grantType
        self.refreshToken = refreshToken
        self.clientID = clientID
        self.redirectUri = redirectUri
        self.clientSecret = clientSecret
    }

    private enum CodingKeys: String, CodingKey {
        case grantType = "grant_type"
        case refreshToken = "refresh_token"
        case clientID = "client_id"
        case redirectUri = "redirect_uri"
        case clientSecret = "client_secret"
    }
}

@available(*, deprecated, message: "Deprecated")
public struct Password: Codable {
    public var grantType: GrantType?
    /// User name
    public var userName: String?
    /// User password
    public var password: String?
    /// Client ID
    public var clientID: String?
    /// Redirect URI
    public var redirectUri: String?
    /// Client secret
    public var clientSecret: String?

    public enum GrantType: String, Codable, CaseIterable {
        case password
    }

    public init(grantType: GrantType? = nil, userName: String? = nil, password: String? = nil, clientID: String? = nil, redirectUri: String? = nil, clientSecret: String? = nil) {
        self.grantType = grantType
        self.userName = userName
        self.password = password
        self.clientID = clientID
        self.redirectUri = redirectUri
        self.clientSecret = clientSecret
    }

    private enum CodingKeys: String, CodingKey {
        case grantType = "grant_type"
        case userName = "user_name"
        case password
        case clientID = "client_id"
        case redirectUri = "redirect_uri"
        case clientSecret = "client_secret"
    }
}

public struct Connection: Codable {
    /// Created timestamp.
    public var createdAt: String?
    /// Full Name.
    public var displayName: String?
    /// Unique identifier
    public var id: Int?
    /// Kind of resource.
    public var kind: String?
    /// - warning: Deprecated.
    public var isPostFavorite: Bool?
    /// - warning: Deprecated.
    public var isPostPublish: Bool?
    /// Service.
    public var service: String?
    /// Type.
    public var type: String?
    /// The external link URI.
    public var uri: String?

    public init(createdAt: String? = nil, displayName: String? = nil, id: Int? = nil, kind: String? = nil, isPostFavorite: Bool? = nil, isPostPublish: Bool? = nil, service: String? = nil, type: String? = nil, uri: String? = nil) {
        self.createdAt = createdAt
        self.displayName = displayName
        self.id = id
        self.kind = kind
        self.isPostFavorite = isPostFavorite
        self.isPostPublish = isPostPublish
        self.service = service
        self.type = type
        self.uri = uri
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case displayName = "display_name"
        case id
        case kind
        case isPostFavorite = "post_favorite"
        case isPostPublish = "post_publish"
        case service
        case type
        case uri
    }
}

public struct TrackMetadataRequest: Codable {
    public var track: Track?

    public struct Track: Codable {
        public var title: String?
        public var permalink: String?
        public var sharing: Sharing?
        /// Who can embed this track "all", "me", or "none"
        public var embeddableBy: EmbeddableBy?
        public var purchaseURL: String?
        public var description: String?
        public var genre: String?
        /// The tag_list property contains a list of tags separated by spaces. Multiword tags are quoted in double quotes. We also support machine tags that follow the pattern NAMESPACE:KEY=VALUE. For example: geo:lat=43.555 camel:size=medium “machine:tag=with space” Machine tags are not revealed to the user on the track pages.
        public var tagList: String?
        public var labelName: String?
        public var release: String?
        /// Write only!
        ///
        /// String, formatted as yyyy-mm-dd, representing release date
        public var releaseDate: String?
        public var isStreamable: Bool
        public var isDownloadable: Bool
        /// Possible values: no-rights-reserved, all-rights-reserved, cc-by, cc-by-nc, cc-by-nd, cc-by-sa, cc-by-nc-nd, cc-by-nc-sa
        public var license: License?
        public var isCommentable: Bool
        public var isrc: String?

        public enum Sharing: String, Codable, CaseIterable {
            case `public`
            case `private`
        }

        /// Who can embed this track "all", "me", or "none"
        public enum EmbeddableBy: String, Codable, CaseIterable {
            case all
            case me
            case `none`
        }

        /// Possible values: no-rights-reserved, all-rights-reserved, cc-by, cc-by-nc, cc-by-nd, cc-by-sa, cc-by-nc-nd, cc-by-nc-sa
        public enum License: String, Codable, CaseIterable {
            case noRightsReserved = "no-rights-reserved"
            case allRightsReserved = "all-rights-reserved"
            case ccBy = "cc-by"
            case ccByNc = "cc-by-nc"
            case ccByNd = "cc-by-nd"
            case ccBySa = "cc-by-sa"
            case ccByNcNd = "cc-by-nc-nd"
            case ccByNcSa = "cc-by-nc-sa"
        }

        public init(title: String? = nil, permalink: String? = nil, sharing: Sharing? = nil, embeddableBy: EmbeddableBy? = nil, purchaseURL: String? = nil, description: String? = nil, genre: String? = nil, tagList: String? = nil, labelName: String? = nil, release: String? = nil, releaseDate: String? = nil, isStreamable: Bool? = nil, isDownloadable: Bool? = nil, license: License? = nil, isCommentable: Bool? = nil, isrc: String? = nil) {
            self.title = title
            self.permalink = permalink
            self.sharing = sharing
            self.embeddableBy = embeddableBy
            self.purchaseURL = purchaseURL
            self.description = description
            self.genre = genre
            self.tagList = tagList
            self.labelName = labelName
            self.release = release
            self.releaseDate = releaseDate
            self.isStreamable = isStreamable ?? true
            self.isDownloadable = isDownloadable ?? true
            self.license = license
            self.isCommentable = isCommentable ?? true
            self.isrc = isrc
        }

        private enum CodingKeys: String, CodingKey {
            case title
            case permalink
            case sharing
            case embeddableBy = "embeddable_by"
            case purchaseURL = "purchase_url"
            case description
            case genre
            case tagList = "tag_list"
            case labelName = "label_name"
            case release
            case releaseDate = "release_date"
            case isStreamable = "streamable"
            case isDownloadable = "downloadable"
            case license
            case isCommentable = "commentable"
            case isrc
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.title = try values.decodeIfPresent(String.self, forKey: .title)
            self.permalink = try values.decodeIfPresent(String.self, forKey: .permalink)
            self.sharing = try values.decodeIfPresent(Sharing.self, forKey: .sharing)
            self.embeddableBy = try values.decodeIfPresent(EmbeddableBy.self, forKey: .embeddableBy)
            self.purchaseURL = try values.decodeIfPresent(String.self, forKey: .purchaseURL)
            self.description = try values.decodeIfPresent(String.self, forKey: .description)
            self.genre = try values.decodeIfPresent(String.self, forKey: .genre)
            self.tagList = try values.decodeIfPresent(String.self, forKey: .tagList)
            self.labelName = try values.decodeIfPresent(String.self, forKey: .labelName)
            self.release = try values.decodeIfPresent(String.self, forKey: .release)
            self.releaseDate = try values.decodeIfPresent(String.self, forKey: .releaseDate)
            self.isStreamable = try values.decodeIfPresent(Bool.self, forKey: .isStreamable) ?? true
            self.isDownloadable = try values.decodeIfPresent(Bool.self, forKey: .isDownloadable) ?? true
            self.license = try values.decodeIfPresent(License.self, forKey: .license)
            self.isCommentable = try values.decodeIfPresent(Bool.self, forKey: .isCommentable) ?? true
            self.isrc = try values.decodeIfPresent(String.self, forKey: .isrc)
        }
    }

    public init(track: Track? = nil) {
        self.track = track
    }
}

public struct CreateUpdatePlaylistRequest: Codable {
    public var playlist: Playlist?

    public struct Playlist: Codable {
        /// Title of the playlist
        public var title: String?
        /// Description of the playlist
        public var description: String?
        /// Public or private
        public var sharing: Sharing?
        /// List of tracks to add to playlist
        public var tracks: [Track]?

        /// Public or private
        public enum Sharing: String, Codable, CaseIterable {
            case `public`
            case `private`
        }

        public struct Track: Codable {
            /// SoundCloud track id
            public var id: String

            public init(id: String) {
                self.id = id
            }
        }

        public init(title: String? = nil, description: String? = nil, sharing: Sharing? = nil, tracks: [Track]? = nil) {
            self.title = title
            self.description = description
            self.sharing = sharing
            self.tracks = tracks
        }
    }

    public init(playlist: Playlist? = nil) {
        self.playlist = playlist
    }
}

public struct TrackDataRequest: Codable {
    public var trackTitle: String?
    /// Only for uploading
    public var trackAssetData: String?
    public var trackPermalink: String?
    public var trackSharing: TrackSharing?
    /// Who can embed this track "all", "me", or "none"
    public var trackEmbeddableBy: TrackEmbeddableBy?
    public var trackPurchaseURL: String?
    public var trackDescription: String?
    public var trackGenre: String?
    /// The tag_list property contains a list of tags separated by spaces. Multiword tags are quoted in double quotes. We also support machine tags that follow the pattern NAMESPACE:KEY=VALUE. For example: geo:lat=43.555 camel:size=medium “machine:tag=with space” Machine tags are not revealed to the user on the track pages.
    public var trackTagList: String?
    public var trackLabelName: String?
    public var trackRelease: String?
    /// Write only!
    ///
    /// String, formatted as yyyy-mm-dd, representing release date
    public var trackReleaseDate: String?
    public var isTrackStreamable: Bool
    public var isTrackDownloadable: Bool
    /// Possible values: no-rights-reserved, all-rights-reserved, cc-by, cc-by-nc, cc-by-nd, cc-by-sa, cc-by-nc-nd, cc-by-nc-sa
    public var trackLicense: TrackLicense?
    public var isTrackCommentable: Bool
    public var trackIsrc: String?
    /// Only for uploading, for PRO users
    public var trackArtworkData: String?

    public enum TrackSharing: String, Codable, CaseIterable {
        case `public`
        case `private`
    }

    /// Who can embed this track "all", "me", or "none"
    public enum TrackEmbeddableBy: String, Codable, CaseIterable {
        case all
        case me
        case `none`
    }

    /// Possible values: no-rights-reserved, all-rights-reserved, cc-by, cc-by-nc, cc-by-nd, cc-by-sa, cc-by-nc-nd, cc-by-nc-sa
    public enum TrackLicense: String, Codable, CaseIterable {
        case noRightsReserved = "no-rights-reserved"
        case allRightsReserved = "all-rights-reserved"
        case ccBy = "cc-by"
        case ccByNc = "cc-by-nc"
        case ccByNd = "cc-by-nd"
        case ccBySa = "cc-by-sa"
        case ccByNcNd = "cc-by-nc-nd"
        case ccByNcSa = "cc-by-nc-sa"
    }

    public init(trackTitle: String? = nil, trackAssetData: String? = nil, trackPermalink: String? = nil, trackSharing: TrackSharing? = nil, trackEmbeddableBy: TrackEmbeddableBy? = nil, trackPurchaseURL: String? = nil, trackDescription: String? = nil, trackGenre: String? = nil, trackTagList: String? = nil, trackLabelName: String? = nil, trackRelease: String? = nil, trackReleaseDate: String? = nil, isTrackStreamable: Bool? = nil, isTrackDownloadable: Bool? = nil, trackLicense: TrackLicense? = nil, isTrackCommentable: Bool? = nil, trackIsrc: String? = nil, trackArtworkData: String? = nil) {
        self.trackTitle = trackTitle
        self.trackAssetData = trackAssetData
        self.trackPermalink = trackPermalink
        self.trackSharing = trackSharing
        self.trackEmbeddableBy = trackEmbeddableBy
        self.trackPurchaseURL = trackPurchaseURL
        self.trackDescription = trackDescription
        self.trackGenre = trackGenre
        self.trackTagList = trackTagList
        self.trackLabelName = trackLabelName
        self.trackRelease = trackRelease
        self.trackReleaseDate = trackReleaseDate
        self.isTrackStreamable = isTrackStreamable ?? true
        self.isTrackDownloadable = isTrackDownloadable ?? true
        self.trackLicense = trackLicense
        self.isTrackCommentable = isTrackCommentable ?? true
        self.trackIsrc = trackIsrc
        self.trackArtworkData = trackArtworkData
    }

    private enum CodingKeys: String, CodingKey {
        case trackTitle = "track[title]"
        case trackAssetData = "track[asset_data]"
        case trackPermalink = "track[permalink]"
        case trackSharing = "track[sharing]"
        case trackEmbeddableBy = "track[embeddable_by]"
        case trackPurchaseURL = "track[purchase_url]"
        case trackDescription = "track[description]"
        case trackGenre = "track[genre]"
        case trackTagList = "track[tag_list]"
        case trackLabelName = "track[label_name]"
        case trackRelease = "track[release]"
        case trackReleaseDate = "track[release_date]"
        case isTrackStreamable = "track[streamable]"
        case isTrackDownloadable = "track[downloadable]"
        case trackLicense = "track[license]"
        case isTrackCommentable = "track[commentable]"
        case trackIsrc = "track[isrc]"
        case trackArtworkData = "track[artwork_data]"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.trackTitle = try values.decodeIfPresent(String.self, forKey: .trackTitle)
        self.trackAssetData = try values.decodeIfPresent(String.self, forKey: .trackAssetData)
        self.trackPermalink = try values.decodeIfPresent(String.self, forKey: .trackPermalink)
        self.trackSharing = try values.decodeIfPresent(TrackSharing.self, forKey: .trackSharing)
        self.trackEmbeddableBy = try values.decodeIfPresent(TrackEmbeddableBy.self, forKey: .trackEmbeddableBy)
        self.trackPurchaseURL = try values.decodeIfPresent(String.self, forKey: .trackPurchaseURL)
        self.trackDescription = try values.decodeIfPresent(String.self, forKey: .trackDescription)
        self.trackGenre = try values.decodeIfPresent(String.self, forKey: .trackGenre)
        self.trackTagList = try values.decodeIfPresent(String.self, forKey: .trackTagList)
        self.trackLabelName = try values.decodeIfPresent(String.self, forKey: .trackLabelName)
        self.trackRelease = try values.decodeIfPresent(String.self, forKey: .trackRelease)
        self.trackReleaseDate = try values.decodeIfPresent(String.self, forKey: .trackReleaseDate)
        self.isTrackStreamable = try values.decodeIfPresent(Bool.self, forKey: .isTrackStreamable) ?? true
        self.isTrackDownloadable = try values.decodeIfPresent(Bool.self, forKey: .isTrackDownloadable) ?? true
        self.trackLicense = try values.decodeIfPresent(TrackLicense.self, forKey: .trackLicense)
        self.isTrackCommentable = try values.decodeIfPresent(Bool.self, forKey: .isTrackCommentable) ?? true
        self.trackIsrc = try values.decodeIfPresent(String.self, forKey: .trackIsrc)
        self.trackArtworkData = try values.decodeIfPresent(String.self, forKey: .trackArtworkData)
    }
}

public struct Found: Codable {
    /// Status code.
    public var status: String?
    /// Location URL of the resource.
    public var location: String?

    public init(status: String? = nil, location: String? = nil) {
        self.status = status
        self.location = location
    }
}

public struct Error: Codable {
    public var code: Int?
    public var message: String?
    public var link: String?
    /// - warning: Deprecated.
    public var error: String?
    /// - warning: Deprecated.
    public var errors: [AnyJSON]?
    /// - warning: Deprecated.
    public var status: String?

    public init(code: Int? = nil, message: String? = nil, link: String? = nil, error: String? = nil, errors: [AnyJSON]? = nil, status: String? = nil) {
        self.code = code
        self.message = message
        self.link = link
        self.error = error
        self.errors = errors
        self.status = status
    }
}

public struct TooManyRequests: Codable {
    public var error: Error
    public var spamWarningUrn: String?

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.error = try Error(from: decoder)
        self.spamWarningUrn = try values.decodeIfPresent(String.self, forKey: "spam_warning_urn")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(error, forKey: "error")
        try values.encodeIfPresent(spamWarningUrn, forKey: "spam_warning_urn")
    }
}

/// SoundCloud User object
public struct User: Codable {
    /// URL to a JPEG image
    public var avatarURL: String?
    /// City
    public var city: String?
    /// Country
    public var country: String?
    /// Description
    public var description: String?
    /// Discogs name
    public var discogsName: String?
    /// First name
    public var firstName: String?
    /// Number of followers
    public var followersCount: Int?
    /// Number of followed users
    public var followingsCount: Int?
    /// First and last name
    public var fullName: String?
    /// Unique identifier
    public var id: Int?
    /// Kind of resource
    public var kind: String?
    /// Profile creation datetime
    public var createdAt: Date?
    /// Last modified datetime
    public var lastModified: Date?
    /// Last name
    public var lastName: String?
    /// Myspace name
    ///
    /// - warning: Deprecated.
    public var myspaceName: String?
    /// Permalink of the resource
    public var permalink: String?
    /// URL to the SoundCloud.com page
    public var permalinkURL: String?
    /// Subscription plan of the user
    public var plan: String?
    /// Number of public playlists
    public var playlistCount: Int?
    /// Number of favorited public tracks
    public var publicFavoritesCount: Int?
    /// Number of reposts from user
    public var repostsCount: Int?
    /// Number of public tracks
    public var trackCount: Int?
    /// API resource URL
    public var uri: String?
    /// Username
    public var username: String?
    /// A URL to the website
    public var website: String?
    /// A custom title for the website
    public var websiteTitle: String?
    /// A list subscriptions associated with the user
    ///
    /// - warning: Deprecated.
    public var subscriptions: [Subscription]?

    public struct Subscription: Codable {
        /// Subscription
        public var object: Object?

        /// Subscription
        public struct Object: Codable {
            /// Product
            public var product: Product?
            /// If the subscription is recurring or not
            public var isRecurring: Bool?

            /// Product
            public struct Product: Codable {
                /// Subscription id instance.
                public var id: String?
                /// Subscription name instance.
                public var name: String?

                public init(id: String? = nil, name: String? = nil) {
                    self.id = id
                    self.name = name
                }
            }

            public init(product: Product? = nil, isRecurring: Bool? = nil) {
                self.product = product
                self.isRecurring = isRecurring
            }

            private enum CodingKeys: String, CodingKey {
                case product
                case isRecurring = "recurring"
            }
        }

        public init(object: Object? = nil) {
            self.object = object
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.object = try? container.decode(Object.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = object { try container.encode(value) }
        }
    }

    public init(avatarURL: String? = nil, city: String? = nil, country: String? = nil, description: String? = nil, discogsName: String? = nil, firstName: String? = nil, followersCount: Int? = nil, followingsCount: Int? = nil, fullName: String? = nil, id: Int? = nil, kind: String? = nil, createdAt: Date? = nil, lastModified: Date? = nil, lastName: String? = nil, myspaceName: String? = nil, permalink: String? = nil, permalinkURL: String? = nil, plan: String? = nil, playlistCount: Int? = nil, publicFavoritesCount: Int? = nil, repostsCount: Int? = nil, trackCount: Int? = nil, uri: String? = nil, username: String? = nil, website: String? = nil, websiteTitle: String? = nil, subscriptions: [Subscription]? = nil) {
        self.avatarURL = avatarURL
        self.city = city
        self.country = country
        self.description = description
        self.discogsName = discogsName
        self.firstName = firstName
        self.followersCount = followersCount
        self.followingsCount = followingsCount
        self.fullName = fullName
        self.id = id
        self.kind = kind
        self.createdAt = createdAt
        self.lastModified = lastModified
        self.lastName = lastName
        self.myspaceName = myspaceName
        self.permalink = permalink
        self.permalinkURL = permalinkURL
        self.plan = plan
        self.playlistCount = playlistCount
        self.publicFavoritesCount = publicFavoritesCount
        self.repostsCount = repostsCount
        self.trackCount = trackCount
        self.uri = uri
        self.username = username
        self.website = website
        self.websiteTitle = websiteTitle
        self.subscriptions = subscriptions
    }

    private enum CodingKeys: String, CodingKey {
        case avatarURL = "avatar_url"
        case city
        case country
        case description
        case discogsName = "discogs_name"
        case firstName = "first_name"
        case followersCount = "followers_count"
        case followingsCount = "followings_count"
        case fullName = "full_name"
        case id
        case kind
        case createdAt = "created_at"
        case lastModified = "last_modified"
        case lastName = "last_name"
        case myspaceName = "myspace_name"
        case permalink
        case permalinkURL = "permalink_url"
        case plan
        case playlistCount = "playlist_count"
        case publicFavoritesCount = "public_favorites_count"
        case repostsCount = "reposts_count"
        case trackCount = "track_count"
        case uri
        case username
        case website
        case websiteTitle = "website_title"
        case subscriptions
    }
}

/// SoundCloud User object.
public struct MetaUser: Codable {
    /// URL to a JPEG image
    public var avatarURL: String?
    /// Unique identifier
    public var id: Int?
    /// Kind of resource
    public var kind: String?
    /// Profile creation datetime
    public var createdAt: Date?
    /// Last modified datetime
    public var lastModified: Date?
    /// Permalink of the resource
    public var permalink: String?
    /// URL to the SoundCloud.com page
    public var permalinkURL: String?
    /// API resource URL
    public var uri: String?
    /// Username
    public var username: String?

    public init(avatarURL: String? = nil, id: Int? = nil, kind: String? = nil, createdAt: Date? = nil, lastModified: Date? = nil, permalink: String? = nil, permalinkURL: String? = nil, uri: String? = nil, username: String? = nil) {
        self.avatarURL = avatarURL
        self.id = id
        self.kind = kind
        self.createdAt = createdAt
        self.lastModified = lastModified
        self.permalink = permalink
        self.permalinkURL = permalinkURL
        self.uri = uri
        self.username = username
    }

    private enum CodingKeys: String, CodingKey {
        case avatarURL = "avatar_url"
        case id
        case kind
        case createdAt = "created_at"
        case lastModified = "last_modified"
        case permalink
        case permalinkURL = "permalink_url"
        case uri
        case username
    }
}

/// SoundCloud Complete User object
public struct CompleteUser: Codable {
    /// URL to a JPEG image.
    public var avatarURL: String?
    /// City.
    public var city: String?
    /// Country.
    public var country: String?
    /// Description.
    public var description: String?
    /// Discogs name.
    public var discogsName: String?
    /// First name.
    public var firstName: String?
    /// Number of followers.
    public var followersCount: Int?
    /// Number of followed users.
    public var followingsCount: Int?
    /// First and last name.
    public var fullName: String?
    /// Unique identifier
    public var id: Int?
    /// Kind of resource.
    public var kind: String?
    /// Last modified timestamp.
    public var lastModified: String?
    /// Last name.
    public var lastName: String?
    /// Locale.
    public var locale: String?
    /// Myspace name
    ///
    /// - warning: Deprecated.
    public var myspaceName: String?
    /// Permalink of the resource.
    public var permalink: String?
    /// URL to the SoundCloud.com page.
    public var permalinkURL: String?
    /// Subscription plan of the user.
    public var plan: String?
    /// Number of public playlists.
    public var playlistCount: Int?
    /// Boolean if email is confirmed.
    public var isPrimaryEmailConfirmed: Bool?
    /// Number of private playlists.
    public var privatePlaylistsCount: Int?
    /// Number of private tracks.
    public var privateTracksCount: Int?
    /// Number of favorited public tracks
    public var publicFavoritesCount: Int?
    /// User's upload quota
    public var quota: Quota?
    /// Number of reposts from user
    public var repostsCount: Int?
    /// A list subscriptions associated with the user
    public var subscriptions: [Subscription]?
    /// Number of public tracks.
    public var trackCount: Int?
    /// API resource URL.
    public var uri: String?
    /// Username
    public var username: String?
    /// A URL to the website.
    public var website: String?
    /// A custom title for the website.
    public var websiteTitle: String?

    /// User's upload quota
    public struct Quota: Codable {
        /// Unlimited upload quota.
        public var isUnlimitedUploadQuota: Bool?
        /// Upload seconds used.
        public var uploadSecondsUsed: Int?

        public init(isUnlimitedUploadQuota: Bool? = nil, uploadSecondsUsed: Int? = nil) {
            self.isUnlimitedUploadQuota = isUnlimitedUploadQuota
            self.uploadSecondsUsed = uploadSecondsUsed
        }

        private enum CodingKeys: String, CodingKey {
            case isUnlimitedUploadQuota = "unlimited_upload_quota"
            case uploadSecondsUsed = "upload_seconds_used"
        }
    }

    public struct Subscription: Codable {
        /// Subscription
        public var object: Object?

        /// Subscription
        public struct Object: Codable {
            /// Product
            public var product: Product?
            /// If the subscription is recurring or not
            public var isRecurring: Bool?

            /// Product
            public struct Product: Codable {
                /// Subscription id instance.
                public var id: String?
                /// Subscription name instance.
                public var name: String?

                public init(id: String? = nil, name: String? = nil) {
                    self.id = id
                    self.name = name
                }
            }

            public init(product: Product? = nil, isRecurring: Bool? = nil) {
                self.product = product
                self.isRecurring = isRecurring
            }

            private enum CodingKeys: String, CodingKey {
                case product
                case isRecurring = "recurring"
            }
        }

        public init(object: Object? = nil) {
            self.object = object
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.object = try? container.decode(Object.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = object { try container.encode(value) }
        }
    }

    public init(avatarURL: String? = nil, city: String? = nil, country: String? = nil, description: String? = nil, discogsName: String? = nil, firstName: String? = nil, followersCount: Int? = nil, followingsCount: Int? = nil, fullName: String? = nil, id: Int? = nil, kind: String? = nil, lastModified: String? = nil, lastName: String? = nil, locale: String? = nil, myspaceName: String? = nil, permalink: String? = nil, permalinkURL: String? = nil, plan: String? = nil, playlistCount: Int? = nil, isPrimaryEmailConfirmed: Bool? = nil, privatePlaylistsCount: Int? = nil, privateTracksCount: Int? = nil, publicFavoritesCount: Int? = nil, quota: Quota? = nil, repostsCount: Int? = nil, subscriptions: [Subscription]? = nil, trackCount: Int? = nil, uri: String? = nil, username: String? = nil, website: String? = nil, websiteTitle: String? = nil) {
        self.avatarURL = avatarURL
        self.city = city
        self.country = country
        self.description = description
        self.discogsName = discogsName
        self.firstName = firstName
        self.followersCount = followersCount
        self.followingsCount = followingsCount
        self.fullName = fullName
        self.id = id
        self.kind = kind
        self.lastModified = lastModified
        self.lastName = lastName
        self.locale = locale
        self.myspaceName = myspaceName
        self.permalink = permalink
        self.permalinkURL = permalinkURL
        self.plan = plan
        self.playlistCount = playlistCount
        self.isPrimaryEmailConfirmed = isPrimaryEmailConfirmed
        self.privatePlaylistsCount = privatePlaylistsCount
        self.privateTracksCount = privateTracksCount
        self.publicFavoritesCount = publicFavoritesCount
        self.quota = quota
        self.repostsCount = repostsCount
        self.subscriptions = subscriptions
        self.trackCount = trackCount
        self.uri = uri
        self.username = username
        self.website = website
        self.websiteTitle = websiteTitle
    }

    private enum CodingKeys: String, CodingKey {
        case avatarURL = "avatar_url"
        case city
        case country
        case description
        case discogsName = "discogs_name"
        case firstName = "first_name"
        case followersCount = "followers_count"
        case followingsCount = "followings_count"
        case fullName = "full_name"
        case id
        case kind
        case lastModified = "last_modified"
        case lastName = "last_name"
        case locale
        case myspaceName = "myspace_name"
        case permalink
        case permalinkURL = "permalink_url"
        case plan
        case playlistCount = "playlist_count"
        case isPrimaryEmailConfirmed = "primary_email_confirmed"
        case privatePlaylistsCount = "private_playlists_count"
        case privateTracksCount = "private_tracks_count"
        case publicFavoritesCount = "public_favorites_count"
        case quota
        case repostsCount = "reposts_count"
        case subscriptions
        case trackCount = "track_count"
        case uri
        case username
        case website
        case websiteTitle = "website_title"
    }
}

public struct Users: Codable {
    public var collection: [User]?
    public var nextHref: String?

    public init(collection: [User]? = nil, nextHref: String? = nil) {
        self.collection = collection
        self.nextHref = nextHref
    }

    private enum CodingKeys: String, CodingKey {
        case collection
        case nextHref = "next_href"
    }
}

public struct MetaUsers: Codable {
    public var collection: [MetaUser]?
    public var nextHref: String?

    public init(collection: [MetaUser]? = nil, nextHref: String? = nil) {
        self.collection = collection
        self.nextHref = nextHref
    }

    private enum CodingKeys: String, CodingKey {
        case collection
        case nextHref = "next_href"
    }
}

public typealias UsersList = [UsersListItem]

/// SoundCloud User object
public struct UsersListItem: Codable {
    /// URL to a JPEG image
    public var avatarURL: String?
    /// City
    public var city: String?
    /// Country
    public var country: String?
    /// Description
    public var description: String?
    /// Discogs name
    public var discogsName: String?
    /// First name
    public var firstName: String?
    /// Number of followers
    public var followersCount: Int?
    /// Number of followed users
    public var followingsCount: Int?
    /// First and last name
    public var fullName: String?
    /// Unique identifier
    public var id: Int?
    /// Kind of resource
    public var kind: String?
    /// Last modified datetime
    public var lastModified: Date?
    /// Last name
    public var lastName: String?
    /// Myspace name
    ///
    /// - warning: Deprecated.
    public var myspaceName: String?
    /// Permalink of the resource
    public var permalink: String?
    /// URL to the SoundCloud.com page
    public var permalinkURL: String?
    /// Subscription plan of the user
    public var plan: String?
    /// Number of public playlists
    public var playlistCount: Int?
    /// Number of favorited public tracks
    public var publicFavoritesCount: Int?
    /// Number of reposts from user
    public var repostsCount: Int?
    /// Number of public tracks
    public var trackCount: Int?
    /// API resource URL
    public var uri: String?
    /// Username
    public var username: String?
    /// A URL to the website
    public var website: String?
    /// A custom title for the website
    public var websiteTitle: String?
    /// A list subscriptions associated with the user
    ///
    /// - warning: Deprecated.
    public var subscriptions: [Subscription]?

    public struct Subscription: Codable {
        /// Subscription
        public var object: Object?

        /// Subscription
        public struct Object: Codable {
            /// Product
            public var product: Product?
            /// If the subscription is recurring or not
            public var isRecurring: Bool?

            /// Product
            public struct Product: Codable {
                /// Subscription id instance.
                public var id: String?
                /// Subscription name instance.
                public var name: String?

                public init(id: String? = nil, name: String? = nil) {
                    self.id = id
                    self.name = name
                }
            }

            public init(product: Product? = nil, isRecurring: Bool? = nil) {
                self.product = product
                self.isRecurring = isRecurring
            }

            private enum CodingKeys: String, CodingKey {
                case product
                case isRecurring = "recurring"
            }
        }

        public init(object: Object? = nil) {
            self.object = object
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.object = try? container.decode(Object.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = object { try container.encode(value) }
        }
    }

    public init(avatarURL: String? = nil, city: String? = nil, country: String? = nil, description: String? = nil, discogsName: String? = nil, firstName: String? = nil, followersCount: Int? = nil, followingsCount: Int? = nil, fullName: String? = nil, id: Int? = nil, kind: String? = nil, lastModified: Date? = nil, lastName: String? = nil, myspaceName: String? = nil, permalink: String? = nil, permalinkURL: String? = nil, plan: String? = nil, playlistCount: Int? = nil, publicFavoritesCount: Int? = nil, repostsCount: Int? = nil, trackCount: Int? = nil, uri: String? = nil, username: String? = nil, website: String? = nil, websiteTitle: String? = nil, subscriptions: [Subscription]? = nil) {
        self.avatarURL = avatarURL
        self.city = city
        self.country = country
        self.description = description
        self.discogsName = discogsName
        self.firstName = firstName
        self.followersCount = followersCount
        self.followingsCount = followingsCount
        self.fullName = fullName
        self.id = id
        self.kind = kind
        self.lastModified = lastModified
        self.lastName = lastName
        self.myspaceName = myspaceName
        self.permalink = permalink
        self.permalinkURL = permalinkURL
        self.plan = plan
        self.playlistCount = playlistCount
        self.publicFavoritesCount = publicFavoritesCount
        self.repostsCount = repostsCount
        self.trackCount = trackCount
        self.uri = uri
        self.username = username
        self.website = website
        self.websiteTitle = websiteTitle
        self.subscriptions = subscriptions
    }

    private enum CodingKeys: String, CodingKey {
        case avatarURL = "avatar_url"
        case city
        case country
        case description
        case discogsName = "discogs_name"
        case firstName = "first_name"
        case followersCount = "followers_count"
        case followingsCount = "followings_count"
        case fullName = "full_name"
        case id
        case kind
        case lastModified = "last_modified"
        case lastName = "last_name"
        case myspaceName = "myspace_name"
        case permalink
        case permalinkURL = "permalink_url"
        case plan
        case playlistCount = "playlist_count"
        case publicFavoritesCount = "public_favorites_count"
        case repostsCount = "reposts_count"
        case trackCount = "track_count"
        case uri
        case username
        case website
        case websiteTitle = "website_title"
        case subscriptions
    }
}

/// Soundcloud Track object.
public struct Track: Codable {
    /// Track title.
    public var title: String?
    /// URL to a JPEG image.
    public var artworkURL: String?
    /// Tempo.
    public var bpm: Int?
    /// Number of comments.
    public var commentCount: Int?
    /// Is commentable.
    public var isCommentable: Bool?
    /// Created timestamp.
    public var createdAt: String?
    /// Track description.
    public var description: String?
    /// NUmber of downloads.
    public var downloadCount: Int?
    /// Is downloadable.
    public var downloadable: String?
    /// Track duration.
    public var duration: Int?
    /// Embeddable by.
    ///
    /// - warning: Deprecated.
    public var embeddableBy: String?
    /// Number of favoritings.
    public var favoritingsCount: Int?
    /// Genre
    public var genre: String?
    /// Track identifier.
    public var id: Int?
    /// ISRC code.
    public var isrc: String?
    /// Key signature.
    public var keySignature: String?
    /// Type of object (track).
    public var kind: String?
    /// Label user name.
    public var labelName: String?
    /// License
    public var license: String?
    /// Permalink URL.
    public var permalinkURL: String?
    /// Number of plays.
    public var playbackCount: Int?
    /// Purchase title.
    public var purchaseTitle: String?
    /// Purchase URL.
    public var purchaseURL: String?
    /// Release.
    public var release: String?
    /// Day of release.
    public var releaseDay: Int?
    /// Month of release.
    public var releaseMonth: Int?
    /// Year of release.
    public var releaseYear: Int?
    /// Type of sharing (public/private).
    public var sharing: String?
    /// URL to stream.
    public var streamURL: String?
    /// Is streamable.
    public var isStreamable: Bool?
    /// Tags.
    public var tagList: String?
    /// Track URI.
    public var uri: String?
    /// SoundCloud User object.
    public var user: MetaUser?
    /// Is user's favourite.
    public var isUserFavorite: Bool?
    /// Number of plays by a user.
    public var userPlaybackCount: Int?
    /// Waveform URL.
    public var waveformURL: String?
    /// List of countries where track is available.
    public var availableCountryCodes: String?
    /// Level of access the user (logged in or anonymous) has to the track.
    ///   * `playable` - user is allowed to listen to a full track.
    ///   * `preview` - user is allowed to preview a track, meaning a snippet is available
    ///   * `blocked` - user can only see the metadata of a track, no streaming is possible
    public var access: Access?
    /// URL to download a track.
    public var downloadURL: String?
    /// Number of reposts.
    public var repostsCount: Int?
    /// Secret URL.
    public var secretUri: String?

    /// Level of access the user (logged in or anonymous) has to the track.
    ///   * `playable` - user is allowed to listen to a full track.
    ///   * `preview` - user is allowed to preview a track, meaning a snippet is available
    ///   * `blocked` - user can only see the metadata of a track, no streaming is possible
    public enum Access: String, Codable, CaseIterable {
        case playable
        case preview
        case blocked
    }

    public init(title: String? = nil, artworkURL: String? = nil, bpm: Int? = nil, commentCount: Int? = nil, isCommentable: Bool? = nil, createdAt: String? = nil, description: String? = nil, downloadCount: Int? = nil, downloadable: String? = nil, duration: Int? = nil, embeddableBy: String? = nil, favoritingsCount: Int? = nil, genre: String? = nil, id: Int? = nil, isrc: String? = nil, keySignature: String? = nil, kind: String? = nil, labelName: String? = nil, license: String? = nil, permalinkURL: String? = nil, playbackCount: Int? = nil, purchaseTitle: String? = nil, purchaseURL: String? = nil, release: String? = nil, releaseDay: Int? = nil, releaseMonth: Int? = nil, releaseYear: Int? = nil, sharing: String? = nil, streamURL: String? = nil, isStreamable: Bool? = nil, tagList: String? = nil, uri: String? = nil, user: MetaUser? = nil, isUserFavorite: Bool? = nil, userPlaybackCount: Int? = nil, waveformURL: String? = nil, availableCountryCodes: String? = nil, access: Access? = nil, downloadURL: String? = nil, repostsCount: Int? = nil, secretUri: String? = nil) {
        self.title = title
        self.artworkURL = artworkURL
        self.bpm = bpm
        self.commentCount = commentCount
        self.isCommentable = isCommentable
        self.createdAt = createdAt
        self.description = description
        self.downloadCount = downloadCount
        self.downloadable = downloadable
        self.duration = duration
        self.embeddableBy = embeddableBy
        self.favoritingsCount = favoritingsCount
        self.genre = genre
        self.id = id
        self.isrc = isrc
        self.keySignature = keySignature
        self.kind = kind
        self.labelName = labelName
        self.license = license
        self.permalinkURL = permalinkURL
        self.playbackCount = playbackCount
        self.purchaseTitle = purchaseTitle
        self.purchaseURL = purchaseURL
        self.release = release
        self.releaseDay = releaseDay
        self.releaseMonth = releaseMonth
        self.releaseYear = releaseYear
        self.sharing = sharing
        self.streamURL = streamURL
        self.isStreamable = isStreamable
        self.tagList = tagList
        self.uri = uri
        self.user = user
        self.isUserFavorite = isUserFavorite
        self.userPlaybackCount = userPlaybackCount
        self.waveformURL = waveformURL
        self.availableCountryCodes = availableCountryCodes
        self.access = access
        self.downloadURL = downloadURL
        self.repostsCount = repostsCount
        self.secretUri = secretUri
    }

    private enum CodingKeys: String, CodingKey {
        case title
        case artworkURL = "artwork_url"
        case bpm
        case commentCount = "comment_count"
        case isCommentable = "commentable"
        case createdAt = "created_at"
        case description
        case downloadCount = "download_count"
        case downloadable
        case duration
        case embeddableBy = "embeddable_by"
        case favoritingsCount = "favoritings_count"
        case genre
        case id
        case isrc
        case keySignature = "key_signature"
        case kind
        case labelName = "label_name"
        case license
        case permalinkURL = "permalink_url"
        case playbackCount = "playback_count"
        case purchaseTitle = "purchase_title"
        case purchaseURL = "purchase_url"
        case release
        case releaseDay = "release_day"
        case releaseMonth = "release_month"
        case releaseYear = "release_year"
        case sharing
        case streamURL = "stream_url"
        case isStreamable = "streamable"
        case tagList = "tag_list"
        case uri
        case user
        case isUserFavorite = "user_favorite"
        case userPlaybackCount = "user_playback_count"
        case waveformURL = "waveform_url"
        case availableCountryCodes = "available_country_codes"
        case access
        case downloadURL = "download_url"
        case repostsCount = "reposts_count"
        case secretUri = "secret_uri"
    }
}

public struct Tracks: Codable {
    public var collection: [Track]?
    public var nextHref: String?

    public init(collection: [Track]? = nil, nextHref: String? = nil) {
        self.collection = collection
        self.nextHref = nextHref
    }

    private enum CodingKeys: String, CodingKey {
        case collection
        case nextHref = "next_href"
    }
}

/// Soundcloud Playlist Object
public struct Playlist: Codable {
    /// Playlist title.
    public var title: String?
    /// Playlist identifier.
    public var id: Int?
    /// Type of Soundcloud object (playlist).
    public var kind: String?
    /// URL to a JPEG image.
    public var artworkURL: String?
    /// Created timestamp.
    public var createdAt: String?
    /// Playlist description.
    public var description: String?
    /// Is downloadable.
    public var isDownloadable: Bool?
    /// Playlist duration.
    public var duration: Int?
    /// European Article Number.
    public var ean: String?
    /// Embeddable by.
    public var embeddableBy: String?
    /// Playlist genre.
    public var genre: String?
    /// Label user identifier.
    public var labelID: Int?
    /// Label name.
    public var labelName: String?
    /// Last modified timestamp.
    public var lastModified: String?
    /// License.
    public var license: String?
    /// Playlist permalink.
    public var permalink: String?
    /// Playlist permalink URL.
    public var permalinkURL: String?
    /// Type of playlist.
    public var playlistType: String?
    /// Purchase title.
    public var purchaseTitle: String?
    /// Purchase URL.
    public var purchaseURL: String?
    /// Release.
    public var release: String?
    /// Day of release.
    public var releaseDay: Int?
    /// Month of release.
    public var releaseMonth: Int?
    /// Year of release.
    public var releaseYear: Int?
    /// Type of sharing (private/public).
    public var sharing: String?
    /// Is streamable.
    public var isStreamable: Bool?
    /// Tags.
    public var tagList: String?
    /// Count of tracks.
    public var trackCount: Int?
    /// List of tracks.
    public var tracks: [Track]?
    /// Playlist type.
    public var type: String?
    /// Playlist URI.
    public var uri: String?
    /// SoundCloud User object.
    public var user: MetaUser?
    /// User identifier.
    public var userID: Int?
    /// Count of playlist likes.
    public var likesCount: Int?
    /// SoundCloud User object.
    public var label: MetaUser?
    /// Tracks URI.
    public var tracksUri: String?
    /// Tags.
    public var tags: String?

    public init(title: String? = nil, id: Int? = nil, kind: String? = nil, artworkURL: String? = nil, createdAt: String? = nil, description: String? = nil, isDownloadable: Bool? = nil, duration: Int? = nil, ean: String? = nil, embeddableBy: String? = nil, genre: String? = nil, labelID: Int? = nil, labelName: String? = nil, lastModified: String? = nil, license: String? = nil, permalink: String? = nil, permalinkURL: String? = nil, playlistType: String? = nil, purchaseTitle: String? = nil, purchaseURL: String? = nil, release: String? = nil, releaseDay: Int? = nil, releaseMonth: Int? = nil, releaseYear: Int? = nil, sharing: String? = nil, isStreamable: Bool? = nil, tagList: String? = nil, trackCount: Int? = nil, tracks: [Track]? = nil, type: String? = nil, uri: String? = nil, user: MetaUser? = nil, userID: Int? = nil, likesCount: Int? = nil, label: MetaUser? = nil, tracksUri: String? = nil, tags: String? = nil) {
        self.title = title
        self.id = id
        self.kind = kind
        self.artworkURL = artworkURL
        self.createdAt = createdAt
        self.description = description
        self.isDownloadable = isDownloadable
        self.duration = duration
        self.ean = ean
        self.embeddableBy = embeddableBy
        self.genre = genre
        self.labelID = labelID
        self.labelName = labelName
        self.lastModified = lastModified
        self.license = license
        self.permalink = permalink
        self.permalinkURL = permalinkURL
        self.playlistType = playlistType
        self.purchaseTitle = purchaseTitle
        self.purchaseURL = purchaseURL
        self.release = release
        self.releaseDay = releaseDay
        self.releaseMonth = releaseMonth
        self.releaseYear = releaseYear
        self.sharing = sharing
        self.isStreamable = isStreamable
        self.tagList = tagList
        self.trackCount = trackCount
        self.tracks = tracks
        self.type = type
        self.uri = uri
        self.user = user
        self.userID = userID
        self.likesCount = likesCount
        self.label = label
        self.tracksUri = tracksUri
        self.tags = tags
    }

    private enum CodingKeys: String, CodingKey {
        case title
        case id
        case kind
        case artworkURL = "artwork_url"
        case createdAt = "created_at"
        case description
        case isDownloadable = "downloadable"
        case duration
        case ean
        case embeddableBy = "embeddable_by"
        case genre
        case labelID = "label_id"
        case labelName = "label_name"
        case lastModified = "last_modified"
        case license
        case permalink
        case permalinkURL = "permalink_url"
        case playlistType = "playlist_type"
        case purchaseTitle = "purchase_title"
        case purchaseURL = "purchase_url"
        case release
        case releaseDay = "release_day"
        case releaseMonth = "release_month"
        case releaseYear = "release_year"
        case sharing
        case isStreamable = "streamable"
        case tagList = "tag_list"
        case trackCount = "track_count"
        case tracks
        case type
        case uri
        case user
        case userID = "user_id"
        case likesCount = "likes_count"
        case label
        case tracksUri = "tracks_uri"
        case tags
    }
}

public struct Playlists: Codable {
    public var collection: [Playlist]?
    public var nextHref: String?

    public init(collection: [Playlist]? = nil, nextHref: String? = nil) {
        self.collection = collection
        self.nextHref = nextHref
    }

    private enum CodingKeys: String, CodingKey {
        case collection
        case nextHref = "next_href"
    }
}

/// User's activities.
public struct Activities: Codable {
    public var collection: [CollectionItem]?
    public var nextHref: String?
    public var futureHref: String?

    public struct CollectionItem: Codable {
        /// Type of activity (track).
        public var type: String?
        /// Created timestamp.
        public var createdAt: String?
        /// Origin.
        public var origin: Origin?

        /// Origin.
        public struct Origin: Codable {
            /// Soundcloud Track object.
            public var track: Track?
            /// Soundcloud Playlist Object
            public var playlist: Playlist?

            public init(track: Track? = nil, playlist: Playlist? = nil) {
                self.track = track
                self.playlist = playlist
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                self.track = try? container.decode(Track.self)
                self.playlist = try? container.decode(Playlist.self)
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                if let value = track { try container.encode(value) }
                if let value = playlist { try container.encode(value) }
            }
        }

        public init(type: String? = nil, createdAt: String? = nil, origin: Origin? = nil) {
            self.type = type
            self.createdAt = createdAt
            self.origin = origin
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case createdAt = "created_at"
            case origin
        }
    }

    public init(collection: [CollectionItem]? = nil, nextHref: String? = nil, futureHref: String? = nil) {
        self.collection = collection
        self.nextHref = nextHref
        self.futureHref = futureHref
    }

    private enum CodingKeys: String, CodingKey {
        case collection
        case nextHref = "next_href"
        case futureHref = "future_href"
    }
}

public typealias WebProfiles = [WebProfilesItem]

public struct WebProfilesItem: Codable {
    /// Timestamp of when the link was added to the profile.
    public var createdAt: String?
    /// Id
    public var id: Int?
    /// Kind
    public var kind: String?
    /// Service or platform
    public var service: String?
    /// Link's title
    public var title: String?
    /// URL of the external link
    public var url: String?
    /// Username extracted from the external link
    public var username: String?

    public init(createdAt: String? = nil, id: Int? = nil, kind: String? = nil, service: String? = nil, title: String? = nil, url: String? = nil, username: String? = nil) {
        self.createdAt = createdAt
        self.id = id
        self.kind = kind
        self.service = service
        self.title = title
        self.url = url
        self.username = username
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case id
        case kind
        case service
        case title
        case url
        case username
    }
}

/// User's Comment
public struct Comment: Codable {
    /// Comment body.
    public var body: String?
    /// Created timestamp.
    public var createdAt: String?
    /// Identifier.
    public var id: Int?
    /// Kind (comment).
    public var kind: String?
    /// User's identifier.
    public var userID: Int?
    /// Timestamp.
    public var timestamp: String?
    /// Track's identifier.
    public var trackID: Int?
    /// Comment's URL.
    public var uri: String?
    /// SoundCloud User object
    public var user: User?

    /// SoundCloud User object
    public struct User: Codable {
        /// Unique identifier
        public var id: Int?
        /// Kind of resource.
        public var kind: String?
        /// Permalink of the resource.
        public var permalink: String?
        /// Username
        public var username: String?
        /// Last modified timestamp.
        public var lastModified: String?
        /// API resource URL.
        public var uri: String?
        /// URL to the SoundCloud.com page.
        public var permalinkURL: String?
        /// URL to a JPEG image.
        public var avatarURL: String?
        /// Number of followers.
        public var followersCount: Int?
        /// Number of followed users.
        public var followingsCount: Int?
        /// Number of reposts from user
        public var repostsCount: Int?

        public init(id: Int? = nil, kind: String? = nil, permalink: String? = nil, username: String? = nil, lastModified: String? = nil, uri: String? = nil, permalinkURL: String? = nil, avatarURL: String? = nil, followersCount: Int? = nil, followingsCount: Int? = nil, repostsCount: Int? = nil) {
            self.id = id
            self.kind = kind
            self.permalink = permalink
            self.username = username
            self.lastModified = lastModified
            self.uri = uri
            self.permalinkURL = permalinkURL
            self.avatarURL = avatarURL
            self.followersCount = followersCount
            self.followingsCount = followingsCount
            self.repostsCount = repostsCount
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case kind
            case permalink
            case username
            case lastModified = "last_modified"
            case uri
            case permalinkURL = "permalink_url"
            case avatarURL = "avatar_url"
            case followersCount = "followers_count"
            case followingsCount = "followings_count"
            case repostsCount = "reposts_count"
        }
    }

    public init(body: String? = nil, createdAt: String? = nil, id: Int? = nil, kind: String? = nil, userID: Int? = nil, timestamp: String? = nil, trackID: Int? = nil, uri: String? = nil, user: User? = nil) {
        self.body = body
        self.createdAt = createdAt
        self.id = id
        self.kind = kind
        self.userID = userID
        self.timestamp = timestamp
        self.trackID = trackID
        self.uri = uri
        self.user = user
    }

    private enum CodingKeys: String, CodingKey {
        case body
        case createdAt = "created_at"
        case id
        case kind
        case userID = "user_id"
        case timestamp
        case trackID = "track_id"
        case uri
        case user
    }
}

public struct Comments: Codable {
    public var collection: [Comment]?
    public var nextHref: String?

    public init(collection: [Comment]? = nil, nextHref: String? = nil) {
        self.collection = collection
        self.nextHref = nextHref
    }

    private enum CodingKeys: String, CodingKey {
        case collection
        case nextHref = "next_href"
    }
}

public struct Streams: Codable {
    public var httpMp3128URL: String?
    public var hlsMp3128URL: String?
    public var hlsOpus64URL: String?
    public var previewMp3128URL: String?

    public init(httpMp3128URL: String? = nil, hlsMp3128URL: String? = nil, hlsOpus64URL: String? = nil, previewMp3128URL: String? = nil) {
        self.httpMp3128URL = httpMp3128URL
        self.hlsMp3128URL = hlsMp3128URL
        self.hlsOpus64URL = hlsOpus64URL
        self.previewMp3128URL = previewMp3128URL
    }

    private enum CodingKeys: String, CodingKey {
        case httpMp3128URL = "http_mp3_128_url"
        case hlsMp3128URL = "hls_mp3_128_url"
        case hlsOpus64URL = "hls_opus_64_url"
        case previewMp3128URL = "preview_mp3_128_url"
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
