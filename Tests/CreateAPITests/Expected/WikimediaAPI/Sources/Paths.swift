// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get

extension Paths {
    public static var media: Media {
        Media(path: "/media")
    }

    public struct Media {
        /// Path: `/media`
        public let path: String
    }
}

extension Paths.Media {
    public var math: Math {
        Math(path: path + "/math")
    }

    public struct Math {
        /// Path: `/media/math`
        public let path: String
    }
}

extension Paths.Media.Math {
    public var check: Check {
        Check(path: path + "/check")
    }

    public struct Check {
        /// Path: `/media/math/check`
        public let path: String
    }
}

extension Paths.Media.Math.Check {
    public func type(_ type: String) -> WithType {
        WithType(path: "\(path)/\(type)")
    }

    public struct WithType {
        /// Path: `/media/math/check/{type}`
        public let path: String

        /// Check and normalize a TeX formula.
        ///
        /// Checks the supplied TeX formula for correctness and returns the
        /// normalised formula representation as well as information about
        /// identifiers. Available types are tex and inline-tex. The response
        /// contains the `x-resource-location` header which can be used to retrieve
        /// the render of the checked formula in one of the supported rendering
        /// formats. Just append the value of the header to `/media/math/{format}/`
        /// and perform a GET request against that URL.
        /// 
        /// Stability: [stable](https://www.mediawiki.org/wiki/API_versioning#Stable).
        public func post(_ body: Data) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }
    }
}

extension Paths.Media.Math {
    public var formula: Formula {
        Formula(path: path + "/formula")
    }

    public struct Formula {
        /// Path: `/media/math/formula`
        public let path: String
    }
}

extension Paths.Media.Math.Formula {
    public func hash(_ hash: String) -> WithHash {
        WithHash(path: "\(path)/\(hash)")
    }

    public struct WithHash {
        /// Path: `/media/math/formula/{hash}`
        public let path: String

        /// Get a previously-stored formula
        ///
        /// Returns the previously-stored formula via `/media/math/check/{type}` for
        /// the given hash.
        /// 
        /// Stability: [stable](https://www.mediawiki.org/wiki/API_versioning#Stable).
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Media.Math {
    public var render: Render {
        Render(path: path + "/render")
    }

    public struct Render {
        /// Path: `/media/math/render`
        public let path: String
    }
}

extension Paths.Media.Math.Render {
    public func format(_ format: String) -> WithFormat {
        WithFormat(path: "\(path)/\(format)")
    }

    public struct WithFormat {
        /// Path: `/media/math/render/{format}`
        public let path: String
    }
}

extension Paths.Media.Math.Render.WithFormat {
    public func hash(_ hash: String) -> WithHash {
        WithHash(path: "\(path)/\(hash)")
    }

    public struct WithHash {
        /// Path: `/media/math/render/{format}/{hash}`
        public let path: String

        /// Get rendered formula in the given format.
        ///
        /// Given a request hash, renders a TeX formula into its mathematic
        /// representation in the given format. When a request is issued to the
        /// `/media/math/check/{format}` POST endpoint, the response contains the
        /// `x-resource-location` header denoting the hash ID of the POST data. Once
        /// obtained, this endpoint has to be used to obtain the actual render.
        /// 
        /// Stability: [stable](https://www.mediawiki.org/wiki/API_versioning#Stable).
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths {
    public static var metrics: Metrics {
        Metrics(path: "/metrics")
    }

    public struct Metrics {
        /// Path: `/metrics`
        public let path: String
    }
}

extension Paths.Metrics {
    public var pageviews: Pageviews {
        Pageviews(path: path + "/pageviews")
    }

    public struct Pageviews {
        /// Path: `/metrics/pageviews`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews {
    public var perArticle: PerArticle {
        PerArticle(path: path + "/per-article")
    }

    public struct PerArticle {
        /// Path: `/metrics/pageviews/per-article`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.PerArticle {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/pageviews/per-article/{project}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.PerArticle.WithProject {
    public func access(_ access: String) -> WithAccess {
        WithAccess(path: "\(path)/\(access)")
    }

    public struct WithAccess {
        /// Path: `/metrics/pageviews/per-article/{project}/{access}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.PerArticle.WithProject.WithAccess {
    public func agent(_ agent: String) -> WithAgent {
        WithAgent(path: "\(path)/\(agent)")
    }

    public struct WithAgent {
        /// Path: `/metrics/pageviews/per-article/{project}/{access}/{agent}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.PerArticle.WithProject.WithAccess.WithAgent {
    public func article(_ article: String) -> WithArticle {
        WithArticle(path: "\(path)/\(article)")
    }

    public struct WithArticle {
        /// Path: `/metrics/pageviews/per-article/{project}/{access}/{agent}/{article}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.PerArticle.WithProject.WithAccess.WithAgent.WithArticle {
    public func granularity(_ granularity: String) -> WithGranularity {
        WithGranularity(path: "\(path)/\(granularity)")
    }

    public struct WithGranularity {
        /// Path: `/metrics/pageviews/per-article/{project}/{access}/{agent}/{article}/{granularity}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.PerArticle.WithProject.WithAccess.WithAgent.WithArticle.WithGranularity {
    public func start(_ start: String) -> WithStart {
        WithStart(path: "\(path)/\(start)")
    }

    public struct WithStart {
        /// Path: `/metrics/pageviews/per-article/{project}/{access}/{agent}/{article}/{granularity}/{start}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.PerArticle.WithProject.WithAccess.WithAgent.WithArticle.WithGranularity.WithStart {
    public func end(_ end: String) -> WithEnd {
        WithEnd(path: "\(path)/\(end)")
    }

    public struct WithEnd {
        /// Path: `/metrics/pageviews/per-article/{project}/{access}/{agent}/{article}/{granularity}/{start}/{end}`
        public let path: String

        /// Get pageview counts for a page.
        ///
        /// Given a Mediawiki article and a date range, returns a daily timeseries of its pageview
        /// counts. You can also filter by access method and/or agent type.
        /// 
        /// - Stability: [stable](https://www.mediawiki.org/wiki/API_versioning#Stable)
        /// - Rate limit: 100 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.PageviewArticle> {
            .get(path)
        }
    }
}

extension Paths.Metrics.Pageviews {
    public var aggregate: Aggregate {
        Aggregate(path: path + "/aggregate")
    }

    public struct Aggregate {
        /// Path: `/metrics/pageviews/aggregate`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.Aggregate {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/pageviews/aggregate/{project}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.Aggregate.WithProject {
    public func access(_ access: String) -> WithAccess {
        WithAccess(path: "\(path)/\(access)")
    }

    public struct WithAccess {
        /// Path: `/metrics/pageviews/aggregate/{project}/{access}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.Aggregate.WithProject.WithAccess {
    public func agent(_ agent: String) -> WithAgent {
        WithAgent(path: "\(path)/\(agent)")
    }

    public struct WithAgent {
        /// Path: `/metrics/pageviews/aggregate/{project}/{access}/{agent}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.Aggregate.WithProject.WithAccess.WithAgent {
    public func granularity(_ granularity: String) -> WithGranularity {
        WithGranularity(path: "\(path)/\(granularity)")
    }

    public struct WithGranularity {
        /// Path: `/metrics/pageviews/aggregate/{project}/{access}/{agent}/{granularity}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.Aggregate.WithProject.WithAccess.WithAgent.WithGranularity {
    public func start(_ start: String) -> WithStart {
        WithStart(path: "\(path)/\(start)")
    }

    public struct WithStart {
        /// Path: `/metrics/pageviews/aggregate/{project}/{access}/{agent}/{granularity}/{start}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.Aggregate.WithProject.WithAccess.WithAgent.WithGranularity.WithStart {
    public func end(_ end: String) -> WithEnd {
        WithEnd(path: "\(path)/\(end)")
    }

    public struct WithEnd {
        /// Path: `/metrics/pageviews/aggregate/{project}/{access}/{agent}/{granularity}/{start}/{end}`
        public let path: String

        /// Get pageview counts for a project.
        ///
        /// Given a date range, returns a timeseries of pageview counts. You can filter by project,
        /// access method and/or agent type. You can choose between daily and hourly granularity
        /// as well.
        /// 
        /// - Stability: [stable](https://www.mediawiki.org/wiki/API_versioning#Stable)
        /// - Rate limit: 100 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.PageviewProject> {
            .get(path)
        }
    }
}

extension Paths.Metrics.Pageviews {
    public var top: Top {
        Top(path: path + "/top")
    }

    public struct Top {
        /// Path: `/metrics/pageviews/top`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.Top {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/pageviews/top/{project}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.Top.WithProject {
    public func access(_ access: String) -> WithAccess {
        WithAccess(path: "\(path)/\(access)")
    }

    public struct WithAccess {
        /// Path: `/metrics/pageviews/top/{project}/{access}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.Top.WithProject.WithAccess {
    public func year(_ year: String) -> WithYear {
        WithYear(path: "\(path)/\(year)")
    }

    public struct WithYear {
        /// Path: `/metrics/pageviews/top/{project}/{access}/{year}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.Top.WithProject.WithAccess.WithYear {
    public func month(_ month: String) -> WithMonth {
        WithMonth(path: "\(path)/\(month)")
    }

    public struct WithMonth {
        /// Path: `/metrics/pageviews/top/{project}/{access}/{year}/{month}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.Top.WithProject.WithAccess.WithYear.WithMonth {
    public func day(_ day: String) -> WithDay {
        WithDay(path: "\(path)/\(day)")
    }

    public struct WithDay {
        /// Path: `/metrics/pageviews/top/{project}/{access}/{year}/{month}/{day}`
        public let path: String

        /// Get the most viewed articles for a project.
        ///
        /// Lists the 1000 most viewed articles for a given project and timespan (month or day).
        /// You can filter by access method.
        /// 
        /// - Stability: [stable](https://www.mediawiki.org/wiki/API_versioning#Stable)
        /// - Rate limit: 100 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.PageviewTops> {
            .get(path)
        }
    }
}

extension Paths.Metrics.Pageviews {
    public var topByCountry: TopByCountry {
        TopByCountry(path: path + "/top-by-country")
    }

    public struct TopByCountry {
        /// Path: `/metrics/pageviews/top-by-country`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.TopByCountry {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/pageviews/top-by-country/{project}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.TopByCountry.WithProject {
    public func access(_ access: String) -> WithAccess {
        WithAccess(path: "\(path)/\(access)")
    }

    public struct WithAccess {
        /// Path: `/metrics/pageviews/top-by-country/{project}/{access}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.TopByCountry.WithProject.WithAccess {
    public func year(_ year: String) -> WithYear {
        WithYear(path: "\(path)/\(year)")
    }

    public struct WithYear {
        /// Path: `/metrics/pageviews/top-by-country/{project}/{access}/{year}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.TopByCountry.WithProject.WithAccess.WithYear {
    public func month(_ month: String) -> WithMonth {
        WithMonth(path: "\(path)/\(month)")
    }

    public struct WithMonth {
        /// Path: `/metrics/pageviews/top-by-country/{project}/{access}/{year}/{month}`
        public let path: String

        /// Get pageviews by country and access method.
        ///
        /// Lists the pageviews to this project, split by country of origin for a given month.
        /// Because of privacy reasons, pageviews are given in a bucketed format, and countries
        /// with less than 100 views do not get reported.
        /// Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 100 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.ByCountry> {
            .get(path)
        }
    }
}

extension Paths.Metrics.Pageviews {
    public var topPerCountry: TopPerCountry {
        TopPerCountry(path: path + "/top-per-country")
    }

    public struct TopPerCountry {
        /// Path: `/metrics/pageviews/top-per-country`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.TopPerCountry {
    public func country(_ country: String) -> WithCountry {
        WithCountry(path: "\(path)/\(country)")
    }

    public struct WithCountry {
        /// Path: `/metrics/pageviews/top-per-country/{country}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.TopPerCountry.WithCountry {
    public func access(_ access: String) -> WithAccess {
        WithAccess(path: "\(path)/\(access)")
    }

    public struct WithAccess {
        /// Path: `/metrics/pageviews/top-per-country/{country}/{access}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.TopPerCountry.WithCountry.WithAccess {
    public func year(_ year: String) -> WithYear {
        WithYear(path: "\(path)/\(year)")
    }

    public struct WithYear {
        /// Path: `/metrics/pageviews/top-per-country/{country}/{access}/{year}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.TopPerCountry.WithCountry.WithAccess.WithYear {
    public func month(_ month: String) -> WithMonth {
        WithMonth(path: "\(path)/\(month)")
    }

    public struct WithMonth {
        /// Path: `/metrics/pageviews/top-per-country/{country}/{access}/{year}/{month}`
        public let path: String
    }
}

extension Paths.Metrics.Pageviews.TopPerCountry.WithCountry.WithAccess.WithYear.WithMonth {
    public func day(_ day: String) -> WithDay {
        WithDay(path: "\(path)/\(day)")
    }

    public struct WithDay {
        /// Path: `/metrics/pageviews/top-per-country/{country}/{access}/{year}/{month}/{day}`
        public let path: String

        /// Get the most viewed articles for a country.
        ///
        /// Lists the 1000 most viewed articles for a given country and date, across all projects.
        /// You can filter by access method.
        /// Because of privacy reasons, pageview counts are given in a bounded format and are not reported for certain countries.
        /// Furthermore, articles visited by 1000 unique individuals or fewer on the given date will be excluded from the returned data.
        /// Also, views produced by agents categorized as bots or web crawlers will be excluded from all calculations.
        /// 
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 100 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.PerCountry> {
            .get(path)
        }
    }
}

extension Paths.Metrics {
    public var uniqueDevices: UniqueDevices {
        UniqueDevices(path: path + "/unique-devices")
    }

    public struct UniqueDevices {
        /// Path: `/metrics/unique-devices`
        public let path: String
    }
}

extension Paths.Metrics.UniqueDevices {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/unique-devices/{project}`
        public let path: String
    }
}

extension Paths.Metrics.UniqueDevices.WithProject {
    public func accessSite(_ accessSite: String) -> WithAccessSite {
        WithAccessSite(path: "\(path)/\(accessSite)")
    }

    public struct WithAccessSite {
        /// Path: `/metrics/unique-devices/{project}/{access-site}`
        public let path: String
    }
}

extension Paths.Metrics.UniqueDevices.WithProject.WithAccessSite {
    public func granularity(_ granularity: String) -> WithGranularity {
        WithGranularity(path: "\(path)/\(granularity)")
    }

    public struct WithGranularity {
        /// Path: `/metrics/unique-devices/{project}/{access-site}/{granularity}`
        public let path: String
    }
}

extension Paths.Metrics.UniqueDevices.WithProject.WithAccessSite.WithGranularity {
    public func start(_ start: String) -> WithStart {
        WithStart(path: "\(path)/\(start)")
    }

    public struct WithStart {
        /// Path: `/metrics/unique-devices/{project}/{access-site}/{granularity}/{start}`
        public let path: String
    }
}

extension Paths.Metrics.UniqueDevices.WithProject.WithAccessSite.WithGranularity.WithStart {
    public func end(_ end: String) -> WithEnd {
        WithEnd(path: "\(path)/\(end)")
    }

    public struct WithEnd {
        /// Path: `/metrics/unique-devices/{project}/{access-site}/{granularity}/{start}/{end}`
        public let path: String

        /// Get unique devices count per project
        ///
        /// Given a project and a date range, returns a timeseries of unique devices counts.
        /// You need to specify a project, and can filter by accessed site (mobile or desktop).
        /// You can choose between daily and hourly granularity as well.
        /// 
        /// - Stability: [stable](https://www.mediawiki.org/wiki/API_versioning#Stable)
        /// - Rate limit: 100 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.UniqueDevices> {
            .get(path)
        }
    }
}

extension Paths.Metrics {
    public var legacy: Legacy {
        Legacy(path: path + "/legacy")
    }

    public struct Legacy {
        /// Path: `/metrics/legacy`
        public let path: String
    }
}

extension Paths.Metrics.Legacy {
    public var pagecounts: Pagecounts {
        Pagecounts(path: path + "/pagecounts")
    }

    public struct Pagecounts {
        /// Path: `/metrics/legacy/pagecounts`
        public let path: String
    }
}

extension Paths.Metrics.Legacy.Pagecounts {
    public var aggregate: Aggregate {
        Aggregate(path: path + "/aggregate")
    }

    public struct Aggregate {
        /// Path: `/metrics/legacy/pagecounts/aggregate`
        public let path: String
    }
}

extension Paths.Metrics.Legacy.Pagecounts.Aggregate {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/legacy/pagecounts/aggregate/{project}`
        public let path: String
    }
}

extension Paths.Metrics.Legacy.Pagecounts.Aggregate.WithProject {
    public func accessSite(_ accessSite: String) -> WithAccessSite {
        WithAccessSite(path: "\(path)/\(accessSite)")
    }

    public struct WithAccessSite {
        /// Path: `/metrics/legacy/pagecounts/aggregate/{project}/{access-site}`
        public let path: String
    }
}

extension Paths.Metrics.Legacy.Pagecounts.Aggregate.WithProject.WithAccessSite {
    public func granularity(_ granularity: String) -> WithGranularity {
        WithGranularity(path: "\(path)/\(granularity)")
    }

    public struct WithGranularity {
        /// Path: `/metrics/legacy/pagecounts/aggregate/{project}/{access-site}/{granularity}`
        public let path: String
    }
}

extension Paths.Metrics.Legacy.Pagecounts.Aggregate.WithProject.WithAccessSite.WithGranularity {
    public func start(_ start: String) -> WithStart {
        WithStart(path: "\(path)/\(start)")
    }

    public struct WithStart {
        /// Path: `/metrics/legacy/pagecounts/aggregate/{project}/{access-site}/{granularity}/{start}`
        public let path: String
    }
}

extension Paths.Metrics.Legacy.Pagecounts.Aggregate.WithProject.WithAccessSite.WithGranularity.WithStart {
    public func end(_ end: String) -> WithEnd {
        WithEnd(path: "\(path)/\(end)")
    }

    public struct WithEnd {
        /// Path: `/metrics/legacy/pagecounts/aggregate/{project}/{access-site}/{granularity}/{start}/{end}`
        public let path: String

        /// Given a project and a date range, returns a timeseries of pagecounts.
        /// You can filter by access site (mobile or desktop) and you can choose between monthly,
        /// daily and hourly granularity as well.
        /// 
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 100 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.PagecountsProject> {
            .get(path)
        }
    }
}

extension Paths.Metrics {
    public var editedPages: EditedPages {
        EditedPages(path: path + "/edited-pages")
    }

    public struct EditedPages {
        /// Path: `/metrics/edited-pages`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages {
    public var new: New {
        New(path: path + "/new")
    }

    public struct New {
        /// Path: `/metrics/edited-pages/new`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.New {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/edited-pages/new/{project}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.New.WithProject {
    public func editorType(_ editorType: String) -> WithEditorType {
        WithEditorType(path: "\(path)/\(editorType)")
    }

    public struct WithEditorType {
        /// Path: `/metrics/edited-pages/new/{project}/{editor-type}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.New.WithProject.WithEditorType {
    public func pageType(_ pageType: String) -> WithPageType {
        WithPageType(path: "\(path)/\(pageType)")
    }

    public struct WithPageType {
        /// Path: `/metrics/edited-pages/new/{project}/{editor-type}/{page-type}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.New.WithProject.WithEditorType.WithPageType {
    public func granularity(_ granularity: String) -> WithGranularity {
        WithGranularity(path: "\(path)/\(granularity)")
    }

    public struct WithGranularity {
        /// Path: `/metrics/edited-pages/new/{project}/{editor-type}/{page-type}/{granularity}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.New.WithProject.WithEditorType.WithPageType.WithGranularity {
    public func start(_ start: String) -> WithStart {
        WithStart(path: "\(path)/\(start)")
    }

    public struct WithStart {
        /// Path: `/metrics/edited-pages/new/{project}/{editor-type}/{page-type}/{granularity}/{start}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.New.WithProject.WithEditorType.WithPageType.WithGranularity.WithStart {
    public func end(_ end: String) -> WithEnd {
        WithEnd(path: "\(path)/\(end)")
    }

    public struct WithEnd {
        /// Path: `/metrics/edited-pages/new/{project}/{editor-type}/{page-type}/{granularity}/{start}/{end}`
        public let path: String

        /// Get new pages counts for a project.
        ///
        /// Given a Mediawiki project and a date range, returns a timeseries of its new pages counts.
        /// You can filter by editor type (all-editor-types, anonymous, group-bot, name-bot, user)
        /// or page-type (all-page-types, content or non-content). You can choose between daily and
        /// monthly granularity as well.
        /// 
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 25 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.NewPages> {
            .get(path)
        }
    }
}

extension Paths.Metrics.EditedPages {
    public var aggregate: Aggregate {
        Aggregate(path: path + "/aggregate")
    }

    public struct Aggregate {
        /// Path: `/metrics/edited-pages/aggregate`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.Aggregate {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/edited-pages/aggregate/{project}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.Aggregate.WithProject {
    public func editorType(_ editorType: String) -> WithEditorType {
        WithEditorType(path: "\(path)/\(editorType)")
    }

    public struct WithEditorType {
        /// Path: `/metrics/edited-pages/aggregate/{project}/{editor-type}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.Aggregate.WithProject.WithEditorType {
    public func pageType(_ pageType: String) -> WithPageType {
        WithPageType(path: "\(path)/\(pageType)")
    }

    public struct WithPageType {
        /// Path: `/metrics/edited-pages/aggregate/{project}/{editor-type}/{page-type}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.Aggregate.WithProject.WithEditorType.WithPageType {
    public func activityLevel(_ activityLevel: String) -> WithActivityLevel {
        WithActivityLevel(path: "\(path)/\(activityLevel)")
    }

    public struct WithActivityLevel {
        /// Path: `/metrics/edited-pages/aggregate/{project}/{editor-type}/{page-type}/{activity-level}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.Aggregate.WithProject.WithEditorType.WithPageType.WithActivityLevel {
    public func granularity(_ granularity: String) -> WithGranularity {
        WithGranularity(path: "\(path)/\(granularity)")
    }

    public struct WithGranularity {
        /// Path: `/metrics/edited-pages/aggregate/{project}/{editor-type}/{page-type}/{activity-level}/{granularity}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.Aggregate.WithProject.WithEditorType.WithPageType.WithActivityLevel.WithGranularity {
    public func start(_ start: String) -> WithStart {
        WithStart(path: "\(path)/\(start)")
    }

    public struct WithStart {
        /// Path: `/metrics/edited-pages/aggregate/{project}/{editor-type}/{page-type}/{activity-level}/{granularity}/{start}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.Aggregate.WithProject.WithEditorType.WithPageType.WithActivityLevel.WithGranularity.WithStart {
    public func end(_ end: String) -> WithEnd {
        WithEnd(path: "\(path)/\(end)")
    }

    public struct WithEnd {
        /// Path: `/metrics/edited-pages/aggregate/{project}/{editor-type}/{page-type}/{activity-level}/{granularity}/{start}/{end}`
        public let path: String

        /// Get edited-pages counts for a project.
        ///
        /// Given a Mediawiki project and a date range, returns a timeseries of its edited-pages counts.
        /// You can filter by editor-type (all-editor-types, anonymous, group-bot, name-bot, user),
        /// page-type (all-page-types, content or non-content) or activity-level (1..4-edits,
        /// 5..24-edits, 25..99-edits, 100..-edits). You can choose between daily and monthly
        /// granularity as well.
        /// 
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 25 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.EditedPages> {
            .get(path)
        }
    }
}

extension Paths.Metrics.EditedPages {
    public var topByEdits: TopByEdits {
        TopByEdits(path: path + "/top-by-edits")
    }

    public struct TopByEdits {
        /// Path: `/metrics/edited-pages/top-by-edits`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.TopByEdits {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/edited-pages/top-by-edits/{project}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.TopByEdits.WithProject {
    public func editorType(_ editorType: String) -> WithEditorType {
        WithEditorType(path: "\(path)/\(editorType)")
    }

    public struct WithEditorType {
        /// Path: `/metrics/edited-pages/top-by-edits/{project}/{editor-type}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.TopByEdits.WithProject.WithEditorType {
    public func pageType(_ pageType: String) -> WithPageType {
        WithPageType(path: "\(path)/\(pageType)")
    }

    public struct WithPageType {
        /// Path: `/metrics/edited-pages/top-by-edits/{project}/{editor-type}/{page-type}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.TopByEdits.WithProject.WithEditorType.WithPageType {
    public func year(_ year: String) -> WithYear {
        WithYear(path: "\(path)/\(year)")
    }

    public struct WithYear {
        /// Path: `/metrics/edited-pages/top-by-edits/{project}/{editor-type}/{page-type}/{year}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.TopByEdits.WithProject.WithEditorType.WithPageType.WithYear {
    public func month(_ month: String) -> WithMonth {
        WithMonth(path: "\(path)/\(month)")
    }

    public struct WithMonth {
        /// Path: `/metrics/edited-pages/top-by-edits/{project}/{editor-type}/{page-type}/{year}/{month}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.TopByEdits.WithProject.WithEditorType.WithPageType.WithYear.WithMonth {
    public func day(_ day: String) -> WithDay {
        WithDay(path: "\(path)/\(day)")
    }

    public struct WithDay {
        /// Path: `/metrics/edited-pages/top-by-edits/{project}/{editor-type}/{page-type}/{year}/{month}/{day}`
        public let path: String

        /// Get top 100 edited-pages by edits count.
        ///
        /// Given a Mediawiki project and a date (day or month), returns a timeseries of the top
        /// 100 edited-pages by edits count. You can filter by editor-type (all-editor-types,
        /// anonymous, group-bot, name-bot, user) or page-type (all-page-types, content or
        /// non-content).
        /// 
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 25 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.TopEditedPagesByEdits> {
            .get(path)
        }
    }
}

extension Paths.Metrics.EditedPages {
    public var topByNetBytesDifference: TopByNetBytesDifference {
        TopByNetBytesDifference(path: path + "/top-by-net-bytes-difference")
    }

    public struct TopByNetBytesDifference {
        /// Path: `/metrics/edited-pages/top-by-net-bytes-difference`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.TopByNetBytesDifference {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/edited-pages/top-by-net-bytes-difference/{project}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.TopByNetBytesDifference.WithProject {
    public func editorType(_ editorType: String) -> WithEditorType {
        WithEditorType(path: "\(path)/\(editorType)")
    }

    public struct WithEditorType {
        /// Path: `/metrics/edited-pages/top-by-net-bytes-difference/{project}/{editor-type}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.TopByNetBytesDifference.WithProject.WithEditorType {
    public func pageType(_ pageType: String) -> WithPageType {
        WithPageType(path: "\(path)/\(pageType)")
    }

    public struct WithPageType {
        /// Path: `/metrics/edited-pages/top-by-net-bytes-difference/{project}/{editor-type}/{page-type}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.TopByNetBytesDifference.WithProject.WithEditorType.WithPageType {
    public func year(_ year: String) -> WithYear {
        WithYear(path: "\(path)/\(year)")
    }

    public struct WithYear {
        /// Path: `/metrics/edited-pages/top-by-net-bytes-difference/{project}/{editor-type}/{page-type}/{year}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.TopByNetBytesDifference.WithProject.WithEditorType.WithPageType.WithYear {
    public func month(_ month: String) -> WithMonth {
        WithMonth(path: "\(path)/\(month)")
    }

    public struct WithMonth {
        /// Path: `/metrics/edited-pages/top-by-net-bytes-difference/{project}/{editor-type}/{page-type}/{year}/{month}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.TopByNetBytesDifference.WithProject.WithEditorType.WithPageType.WithYear.WithMonth {
    public func day(_ day: String) -> WithDay {
        WithDay(path: "\(path)/\(day)")
    }

    public struct WithDay {
        /// Path: `/metrics/edited-pages/top-by-net-bytes-difference/{project}/{editor-type}/{page-type}/{year}/{month}/{day}`
        public let path: String

        /// Get top 100 edited-pages by net bytes-difference.
        ///
        /// Given a Mediawiki project and a date (day or month), returns a timeseries of the top 100
        /// edited-pages by net bytes-difference. You can filter by editor-type (all-editor-types,
        /// anonymous, group-bot, name-bot, user) or page-type (all-page-types, content or non-content).
        /// 
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 25 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.TopEditedPagesByNetBytesDiff> {
            .get(path)
        }
    }
}

extension Paths.Metrics.EditedPages {
    public var topByAbsoluteBytesDifference: TopByAbsoluteBytesDifference {
        TopByAbsoluteBytesDifference(path: path + "/top-by-absolute-bytes-difference")
    }

    public struct TopByAbsoluteBytesDifference {
        /// Path: `/metrics/edited-pages/top-by-absolute-bytes-difference`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.TopByAbsoluteBytesDifference {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/edited-pages/top-by-absolute-bytes-difference/{project}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.TopByAbsoluteBytesDifference.WithProject {
    public func editorType(_ editorType: String) -> WithEditorType {
        WithEditorType(path: "\(path)/\(editorType)")
    }

    public struct WithEditorType {
        /// Path: `/metrics/edited-pages/top-by-absolute-bytes-difference/{project}/{editor-type}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.TopByAbsoluteBytesDifference.WithProject.WithEditorType {
    public func pageType(_ pageType: String) -> WithPageType {
        WithPageType(path: "\(path)/\(pageType)")
    }

    public struct WithPageType {
        /// Path: `/metrics/edited-pages/top-by-absolute-bytes-difference/{project}/{editor-type}/{page-type}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.TopByAbsoluteBytesDifference.WithProject.WithEditorType.WithPageType {
    public func year(_ year: String) -> WithYear {
        WithYear(path: "\(path)/\(year)")
    }

    public struct WithYear {
        /// Path: `/metrics/edited-pages/top-by-absolute-bytes-difference/{project}/{editor-type}/{page-type}/{year}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.TopByAbsoluteBytesDifference.WithProject.WithEditorType.WithPageType.WithYear {
    public func month(_ month: String) -> WithMonth {
        WithMonth(path: "\(path)/\(month)")
    }

    public struct WithMonth {
        /// Path: `/metrics/edited-pages/top-by-absolute-bytes-difference/{project}/{editor-type}/{page-type}/{year}/{month}`
        public let path: String
    }
}

extension Paths.Metrics.EditedPages.TopByAbsoluteBytesDifference.WithProject.WithEditorType.WithPageType.WithYear.WithMonth {
    public func day(_ day: String) -> WithDay {
        WithDay(path: "\(path)/\(day)")
    }

    public struct WithDay {
        /// Path: `/metrics/edited-pages/top-by-absolute-bytes-difference/{project}/{editor-type}/{page-type}/{year}/{month}/{day}`
        public let path: String

        /// Get top 100 edited-pages by absolute bytes-difference.
        ///
        /// Given a Mediawiki project and a date (day or month), returns a timeseries of the top 100
        /// edited-pages by absolute bytes-difference. You can filter by editor-type (all-editor-types,
        /// anonymous, group-bot, name-bot, user) or page-type (all-page-types, content or non-content).
        /// 
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 25 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.TopEditedPagesByAbsBytesDiff> {
            .get(path)
        }
    }
}

extension Paths.Metrics {
    public var editors: Editors {
        Editors(path: path + "/editors")
    }

    public struct Editors {
        /// Path: `/metrics/editors`
        public let path: String
    }
}

extension Paths.Metrics.Editors {
    public var aggregate: Aggregate {
        Aggregate(path: path + "/aggregate")
    }

    public struct Aggregate {
        /// Path: `/metrics/editors/aggregate`
        public let path: String
    }
}

extension Paths.Metrics.Editors.Aggregate {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/editors/aggregate/{project}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.Aggregate.WithProject {
    public func editorType(_ editorType: String) -> WithEditorType {
        WithEditorType(path: "\(path)/\(editorType)")
    }

    public struct WithEditorType {
        /// Path: `/metrics/editors/aggregate/{project}/{editor-type}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.Aggregate.WithProject.WithEditorType {
    public func pageType(_ pageType: String) -> WithPageType {
        WithPageType(path: "\(path)/\(pageType)")
    }

    public struct WithPageType {
        /// Path: `/metrics/editors/aggregate/{project}/{editor-type}/{page-type}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.Aggregate.WithProject.WithEditorType.WithPageType {
    public func activityLevel(_ activityLevel: String) -> WithActivityLevel {
        WithActivityLevel(path: "\(path)/\(activityLevel)")
    }

    public struct WithActivityLevel {
        /// Path: `/metrics/editors/aggregate/{project}/{editor-type}/{page-type}/{activity-level}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.Aggregate.WithProject.WithEditorType.WithPageType.WithActivityLevel {
    public func granularity(_ granularity: String) -> WithGranularity {
        WithGranularity(path: "\(path)/\(granularity)")
    }

    public struct WithGranularity {
        /// Path: `/metrics/editors/aggregate/{project}/{editor-type}/{page-type}/{activity-level}/{granularity}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.Aggregate.WithProject.WithEditorType.WithPageType.WithActivityLevel.WithGranularity {
    public func start(_ start: String) -> WithStart {
        WithStart(path: "\(path)/\(start)")
    }

    public struct WithStart {
        /// Path: `/metrics/editors/aggregate/{project}/{editor-type}/{page-type}/{activity-level}/{granularity}/{start}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.Aggregate.WithProject.WithEditorType.WithPageType.WithActivityLevel.WithGranularity.WithStart {
    public func end(_ end: String) -> WithEnd {
        WithEnd(path: "\(path)/\(end)")
    }

    public struct WithEnd {
        /// Path: `/metrics/editors/aggregate/{project}/{editor-type}/{page-type}/{activity-level}/{granularity}/{start}/{end}`
        public let path: String

        /// Get editors counts for a project.
        ///
        /// Given a Mediawiki project and a date range, returns a timeseries of its editors counts.
        /// You can filter by editory-type (all-editor-types, anonymous, group-bot, name-bot, user),
        /// page-type (all-page-types, content or non-content) or activity-level (1..4-edits,
        /// 5..24-edits, 25..99-edits or 100..-edits). You can choose between daily and monthly
        /// granularity as well.
        /// 
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 25 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.Editors> {
            .get(path)
        }
    }
}

extension Paths.Metrics.Editors {
    public var topByEdits: TopByEdits {
        TopByEdits(path: path + "/top-by-edits")
    }

    public struct TopByEdits {
        /// Path: `/metrics/editors/top-by-edits`
        public let path: String
    }
}

extension Paths.Metrics.Editors.TopByEdits {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/editors/top-by-edits/{project}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.TopByEdits.WithProject {
    public func editorType(_ editorType: String) -> WithEditorType {
        WithEditorType(path: "\(path)/\(editorType)")
    }

    public struct WithEditorType {
        /// Path: `/metrics/editors/top-by-edits/{project}/{editor-type}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.TopByEdits.WithProject.WithEditorType {
    public func pageType(_ pageType: String) -> WithPageType {
        WithPageType(path: "\(path)/\(pageType)")
    }

    public struct WithPageType {
        /// Path: `/metrics/editors/top-by-edits/{project}/{editor-type}/{page-type}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.TopByEdits.WithProject.WithEditorType.WithPageType {
    public func year(_ year: String) -> WithYear {
        WithYear(path: "\(path)/\(year)")
    }

    public struct WithYear {
        /// Path: `/metrics/editors/top-by-edits/{project}/{editor-type}/{page-type}/{year}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.TopByEdits.WithProject.WithEditorType.WithPageType.WithYear {
    public func month(_ month: String) -> WithMonth {
        WithMonth(path: "\(path)/\(month)")
    }

    public struct WithMonth {
        /// Path: `/metrics/editors/top-by-edits/{project}/{editor-type}/{page-type}/{year}/{month}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.TopByEdits.WithProject.WithEditorType.WithPageType.WithYear.WithMonth {
    public func day(_ day: String) -> WithDay {
        WithDay(path: "\(path)/\(day)")
    }

    public struct WithDay {
        /// Path: `/metrics/editors/top-by-edits/{project}/{editor-type}/{page-type}/{year}/{month}/{day}`
        public let path: String

        /// Get top 100 editors by edits count.
        ///
        /// Given a Mediawiki project and a date (day or month), returns a timeseries of the top
        /// 100 editors by edits count. You can filter by editor-type (all-editor-types,
        /// anonymous, group-bot, name-bot, user) or page-type (all-page-types, content or
        /// non-content). The user_text returned is either the mediawiki user_text if the user is
        /// registered, or null if user is anonymous.
        /// 
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 25 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.TopEditorsByEdits> {
            .get(path)
        }
    }
}

extension Paths.Metrics.Editors {
    public var topByNetBytesDifference: TopByNetBytesDifference {
        TopByNetBytesDifference(path: path + "/top-by-net-bytes-difference")
    }

    public struct TopByNetBytesDifference {
        /// Path: `/metrics/editors/top-by-net-bytes-difference`
        public let path: String
    }
}

extension Paths.Metrics.Editors.TopByNetBytesDifference {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/editors/top-by-net-bytes-difference/{project}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.TopByNetBytesDifference.WithProject {
    public func editorType(_ editorType: String) -> WithEditorType {
        WithEditorType(path: "\(path)/\(editorType)")
    }

    public struct WithEditorType {
        /// Path: `/metrics/editors/top-by-net-bytes-difference/{project}/{editor-type}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.TopByNetBytesDifference.WithProject.WithEditorType {
    public func pageType(_ pageType: String) -> WithPageType {
        WithPageType(path: "\(path)/\(pageType)")
    }

    public struct WithPageType {
        /// Path: `/metrics/editors/top-by-net-bytes-difference/{project}/{editor-type}/{page-type}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.TopByNetBytesDifference.WithProject.WithEditorType.WithPageType {
    public func year(_ year: String) -> WithYear {
        WithYear(path: "\(path)/\(year)")
    }

    public struct WithYear {
        /// Path: `/metrics/editors/top-by-net-bytes-difference/{project}/{editor-type}/{page-type}/{year}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.TopByNetBytesDifference.WithProject.WithEditorType.WithPageType.WithYear {
    public func month(_ month: String) -> WithMonth {
        WithMonth(path: "\(path)/\(month)")
    }

    public struct WithMonth {
        /// Path: `/metrics/editors/top-by-net-bytes-difference/{project}/{editor-type}/{page-type}/{year}/{month}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.TopByNetBytesDifference.WithProject.WithEditorType.WithPageType.WithYear.WithMonth {
    public func day(_ day: String) -> WithDay {
        WithDay(path: "\(path)/\(day)")
    }

    public struct WithDay {
        /// Path: `/metrics/editors/top-by-net-bytes-difference/{project}/{editor-type}/{page-type}/{year}/{month}/{day}`
        public let path: String

        /// Get top 100 editors by net bytes-difference.
        ///
        /// Given a Mediawiki project and a date (day or month), returns a timeseries of the top 100
        /// editors by net bytes-difference. You can filter by editor-type (all-editor-types, anonymous,
        /// group-bot, name-bot, user) or page-type (all-page-types, content or non-content). The
        /// user_text returned is either the mediawiki user_text if the user is registered, or
        /// "Anonymous Editor" if user is anonymous.
        /// 
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 25 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.TopEditorsByNetBytesDiff> {
            .get(path)
        }
    }
}

extension Paths.Metrics.Editors {
    public var topByAbsoluteBytesDifference: TopByAbsoluteBytesDifference {
        TopByAbsoluteBytesDifference(path: path + "/top-by-absolute-bytes-difference")
    }

    public struct TopByAbsoluteBytesDifference {
        /// Path: `/metrics/editors/top-by-absolute-bytes-difference`
        public let path: String
    }
}

extension Paths.Metrics.Editors.TopByAbsoluteBytesDifference {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/editors/top-by-absolute-bytes-difference/{project}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.TopByAbsoluteBytesDifference.WithProject {
    public func editorType(_ editorType: String) -> WithEditorType {
        WithEditorType(path: "\(path)/\(editorType)")
    }

    public struct WithEditorType {
        /// Path: `/metrics/editors/top-by-absolute-bytes-difference/{project}/{editor-type}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.TopByAbsoluteBytesDifference.WithProject.WithEditorType {
    public func pageType(_ pageType: String) -> WithPageType {
        WithPageType(path: "\(path)/\(pageType)")
    }

    public struct WithPageType {
        /// Path: `/metrics/editors/top-by-absolute-bytes-difference/{project}/{editor-type}/{page-type}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.TopByAbsoluteBytesDifference.WithProject.WithEditorType.WithPageType {
    public func year(_ year: String) -> WithYear {
        WithYear(path: "\(path)/\(year)")
    }

    public struct WithYear {
        /// Path: `/metrics/editors/top-by-absolute-bytes-difference/{project}/{editor-type}/{page-type}/{year}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.TopByAbsoluteBytesDifference.WithProject.WithEditorType.WithPageType.WithYear {
    public func month(_ month: String) -> WithMonth {
        WithMonth(path: "\(path)/\(month)")
    }

    public struct WithMonth {
        /// Path: `/metrics/editors/top-by-absolute-bytes-difference/{project}/{editor-type}/{page-type}/{year}/{month}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.TopByAbsoluteBytesDifference.WithProject.WithEditorType.WithPageType.WithYear.WithMonth {
    public func day(_ day: String) -> WithDay {
        WithDay(path: "\(path)/\(day)")
    }

    public struct WithDay {
        /// Path: `/metrics/editors/top-by-absolute-bytes-difference/{project}/{editor-type}/{page-type}/{year}/{month}/{day}`
        public let path: String

        /// Get top 100 editors by absolute bytes-difference.
        ///
        /// Given a Mediawiki project and a date (day or month), returns a timeseries of the top 100
        /// editors by absolute bytes-difference. You can filter by editor-type (all-editor-types,
        /// anonymous, group-bot, name-bot, user) or page-type (all-page-types, content or non-content).
        /// The user_text returned is either the mediawiki user_text if the user is registered, or
        /// null if user is anonymous.
        /// 
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 25 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.TopEditorsByAbsBytesDiff> {
            .get(path)
        }
    }
}

extension Paths.Metrics {
    public var edits: Edits {
        Edits(path: path + "/edits")
    }

    public struct Edits {
        /// Path: `/metrics/edits`
        public let path: String
    }
}

extension Paths.Metrics.Edits {
    public var aggregate: Aggregate {
        Aggregate(path: path + "/aggregate")
    }

    public struct Aggregate {
        /// Path: `/metrics/edits/aggregate`
        public let path: String
    }
}

extension Paths.Metrics.Edits.Aggregate {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/edits/aggregate/{project}`
        public let path: String
    }
}

extension Paths.Metrics.Edits.Aggregate.WithProject {
    public func editorType(_ editorType: String) -> WithEditorType {
        WithEditorType(path: "\(path)/\(editorType)")
    }

    public struct WithEditorType {
        /// Path: `/metrics/edits/aggregate/{project}/{editor-type}`
        public let path: String
    }
}

extension Paths.Metrics.Edits.Aggregate.WithProject.WithEditorType {
    public func pageType(_ pageType: String) -> WithPageType {
        WithPageType(path: "\(path)/\(pageType)")
    }

    public struct WithPageType {
        /// Path: `/metrics/edits/aggregate/{project}/{editor-type}/{page-type}`
        public let path: String
    }
}

extension Paths.Metrics.Edits.Aggregate.WithProject.WithEditorType.WithPageType {
    public func granularity(_ granularity: String) -> WithGranularity {
        WithGranularity(path: "\(path)/\(granularity)")
    }

    public struct WithGranularity {
        /// Path: `/metrics/edits/aggregate/{project}/{editor-type}/{page-type}/{granularity}`
        public let path: String
    }
}

extension Paths.Metrics.Edits.Aggregate.WithProject.WithEditorType.WithPageType.WithGranularity {
    public func start(_ start: String) -> WithStart {
        WithStart(path: "\(path)/\(start)")
    }

    public struct WithStart {
        /// Path: `/metrics/edits/aggregate/{project}/{editor-type}/{page-type}/{granularity}/{start}`
        public let path: String
    }
}

extension Paths.Metrics.Edits.Aggregate.WithProject.WithEditorType.WithPageType.WithGranularity.WithStart {
    public func end(_ end: String) -> WithEnd {
        WithEnd(path: "\(path)/\(end)")
    }

    public struct WithEnd {
        /// Path: `/metrics/edits/aggregate/{project}/{editor-type}/{page-type}/{granularity}/{start}/{end}`
        public let path: String

        /// Get edits counts for a project.
        ///
        /// Given a Mediawiki project and a date range, returns a timeseries of edits counts.
        /// You can filter by editors-type (all-editor-types, anonymous, bot, registered) and
        /// page-type (all-page-types, content or non-content). You can choose between daily and
        /// monthly granularity as well.
        /// 
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 25 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.Edits> {
            .get(path)
        }
    }
}

extension Paths.Metrics.Edits {
    public var perPage: PerPage {
        PerPage(path: path + "/per-page")
    }

    public struct PerPage {
        /// Path: `/metrics/edits/per-page`
        public let path: String
    }
}

extension Paths.Metrics.Edits.PerPage {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/edits/per-page/{project}`
        public let path: String
    }
}

extension Paths.Metrics.Edits.PerPage.WithProject {
    public func pageTitle(_ pageTitle: String) -> WithPageTitle {
        WithPageTitle(path: "\(path)/\(pageTitle)")
    }

    public struct WithPageTitle {
        /// Path: `/metrics/edits/per-page/{project}/{page-title}`
        public let path: String
    }
}

extension Paths.Metrics.Edits.PerPage.WithProject.WithPageTitle {
    public func editorType(_ editorType: String) -> WithEditorType {
        WithEditorType(path: "\(path)/\(editorType)")
    }

    public struct WithEditorType {
        /// Path: `/metrics/edits/per-page/{project}/{page-title}/{editor-type}`
        public let path: String
    }
}

extension Paths.Metrics.Edits.PerPage.WithProject.WithPageTitle.WithEditorType {
    public func granularity(_ granularity: String) -> WithGranularity {
        WithGranularity(path: "\(path)/\(granularity)")
    }

    public struct WithGranularity {
        /// Path: `/metrics/edits/per-page/{project}/{page-title}/{editor-type}/{granularity}`
        public let path: String
    }
}

extension Paths.Metrics.Edits.PerPage.WithProject.WithPageTitle.WithEditorType.WithGranularity {
    public func start(_ start: String) -> WithStart {
        WithStart(path: "\(path)/\(start)")
    }

    public struct WithStart {
        /// Path: `/metrics/edits/per-page/{project}/{page-title}/{editor-type}/{granularity}/{start}`
        public let path: String
    }
}

extension Paths.Metrics.Edits.PerPage.WithProject.WithPageTitle.WithEditorType.WithGranularity.WithStart {
    public func end(_ end: String) -> WithEnd {
        WithEnd(path: "\(path)/\(end)")
    }

    public struct WithEnd {
        /// Path: `/metrics/edits/per-page/{project}/{page-title}/{editor-type}/{granularity}/{start}/{end}`
        public let path: String

        /// Get edit counts for a page in a project.
        ///
        /// Given a Mediawiki project, a page-title prefixed with its canonical namespace (for
        /// instance 'User:Jimbo_Wales') and a date range, returns a timeseries of edit counts.
        /// You can filter by editors-type (all-editor-types, anonymous, group-bot, name-bot, user).
        /// You can choose between daily and monthly granularity as well.
        /// 
        /// Note: Due to performance of the data-serving backend, this endpoint limits the queryable
        /// timespan to one year (whether in daily or monthly granularity).
        /// 
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 5 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.EditsPerPage> {
            .get(path)
        }
    }
}

extension Paths.Metrics {
    public var registeredUsers: RegisteredUsers {
        RegisteredUsers(path: path + "/registered-users")
    }

    public struct RegisteredUsers {
        /// Path: `/metrics/registered-users`
        public let path: String
    }
}

extension Paths.Metrics.RegisteredUsers {
    public var new: New {
        New(path: path + "/new")
    }

    public struct New {
        /// Path: `/metrics/registered-users/new`
        public let path: String
    }
}

extension Paths.Metrics.RegisteredUsers.New {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/registered-users/new/{project}`
        public let path: String
    }
}

extension Paths.Metrics.RegisteredUsers.New.WithProject {
    public func granularity(_ granularity: String) -> WithGranularity {
        WithGranularity(path: "\(path)/\(granularity)")
    }

    public struct WithGranularity {
        /// Path: `/metrics/registered-users/new/{project}/{granularity}`
        public let path: String
    }
}

extension Paths.Metrics.RegisteredUsers.New.WithProject.WithGranularity {
    public func start(_ start: String) -> WithStart {
        WithStart(path: "\(path)/\(start)")
    }

    public struct WithStart {
        /// Path: `/metrics/registered-users/new/{project}/{granularity}/{start}`
        public let path: String
    }
}

extension Paths.Metrics.RegisteredUsers.New.WithProject.WithGranularity.WithStart {
    public func end(_ end: String) -> WithEnd {
        WithEnd(path: "\(path)/\(end)")
    }

    public struct WithEnd {
        /// Path: `/metrics/registered-users/new/{project}/{granularity}/{start}/{end}`
        public let path: String

        /// Get newly registered users counts for a project.
        ///
        /// Given a Mediawiki project and a date range, returns a timeseries of its newly registered
        /// users counts. You can choose between daily and monthly granularity. The newly registered
        /// users value is computed with self-created users only, not auto-login created ones.
        /// 
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 25 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.NewRegisteredUsers> {
            .get(path)
        }
    }
}

extension Paths.Metrics {
    public var bytesDifference: BytesDifference {
        BytesDifference(path: path + "/bytes-difference")
    }

    public struct BytesDifference {
        /// Path: `/metrics/bytes-difference`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference {
    public var net: Net {
        Net(path: path + "/net")
    }

    public struct Net {
        /// Path: `/metrics/bytes-difference/net`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Net {
    public var aggregate: Aggregate {
        Aggregate(path: path + "/aggregate")
    }

    public struct Aggregate {
        /// Path: `/metrics/bytes-difference/net/aggregate`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Net.Aggregate {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/bytes-difference/net/aggregate/{project}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Net.Aggregate.WithProject {
    public func editorType(_ editorType: String) -> WithEditorType {
        WithEditorType(path: "\(path)/\(editorType)")
    }

    public struct WithEditorType {
        /// Path: `/metrics/bytes-difference/net/aggregate/{project}/{editor-type}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Net.Aggregate.WithProject.WithEditorType {
    public func pageType(_ pageType: String) -> WithPageType {
        WithPageType(path: "\(path)/\(pageType)")
    }

    public struct WithPageType {
        /// Path: `/metrics/bytes-difference/net/aggregate/{project}/{editor-type}/{page-type}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Net.Aggregate.WithProject.WithEditorType.WithPageType {
    public func granularity(_ granularity: String) -> WithGranularity {
        WithGranularity(path: "\(path)/\(granularity)")
    }

    public struct WithGranularity {
        /// Path: `/metrics/bytes-difference/net/aggregate/{project}/{editor-type}/{page-type}/{granularity}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Net.Aggregate.WithProject.WithEditorType.WithPageType.WithGranularity {
    public func start(_ start: String) -> WithStart {
        WithStart(path: "\(path)/\(start)")
    }

    public struct WithStart {
        /// Path: `/metrics/bytes-difference/net/aggregate/{project}/{editor-type}/{page-type}/{granularity}/{start}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Net.Aggregate.WithProject.WithEditorType.WithPageType.WithGranularity.WithStart {
    public func end(_ end: String) -> WithEnd {
        WithEnd(path: "\(path)/\(end)")
    }

    public struct WithEnd {
        /// Path: `/metrics/bytes-difference/net/aggregate/{project}/{editor-type}/{page-type}/{granularity}/{start}/{end}`
        public let path: String

        /// Get the sum of net text bytes difference between current edit and previous one.
        ///
        /// Given a Mediawiki project and a date range, returns a timeseries of bytes difference net
        /// sums. You can filter by editors-type (all-editor-types, anonymous, group-bot, name-bot,
        /// user) and page-type (all-page-types, content or non-content). You can choose between
        /// daily and monthly granularity as well.
        /// 
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 25 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.NetBytesDifference> {
            .get(path)
        }
    }
}

extension Paths.Metrics.BytesDifference.Net {
    public var perPage: PerPage {
        PerPage(path: path + "/per-page")
    }

    public struct PerPage {
        /// Path: `/metrics/bytes-difference/net/per-page`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Net.PerPage {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/bytes-difference/net/per-page/{project}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Net.PerPage.WithProject {
    public func pageTitle(_ pageTitle: String) -> WithPageTitle {
        WithPageTitle(path: "\(path)/\(pageTitle)")
    }

    public struct WithPageTitle {
        /// Path: `/metrics/bytes-difference/net/per-page/{project}/{page-title}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Net.PerPage.WithProject.WithPageTitle {
    public func editorType(_ editorType: String) -> WithEditorType {
        WithEditorType(path: "\(path)/\(editorType)")
    }

    public struct WithEditorType {
        /// Path: `/metrics/bytes-difference/net/per-page/{project}/{page-title}/{editor-type}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Net.PerPage.WithProject.WithPageTitle.WithEditorType {
    public func granularity(_ granularity: String) -> WithGranularity {
        WithGranularity(path: "\(path)/\(granularity)")
    }

    public struct WithGranularity {
        /// Path: `/metrics/bytes-difference/net/per-page/{project}/{page-title}/{editor-type}/{granularity}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Net.PerPage.WithProject.WithPageTitle.WithEditorType.WithGranularity {
    public func start(_ start: String) -> WithStart {
        WithStart(path: "\(path)/\(start)")
    }

    public struct WithStart {
        /// Path: `/metrics/bytes-difference/net/per-page/{project}/{page-title}/{editor-type}/{granularity}/{start}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Net.PerPage.WithProject.WithPageTitle.WithEditorType.WithGranularity.WithStart {
    public func end(_ end: String) -> WithEnd {
        WithEnd(path: "\(path)/\(end)")
    }

    public struct WithEnd {
        /// Path: `/metrics/bytes-difference/net/per-page/{project}/{page-title}/{editor-type}/{granularity}/{start}/{end}`
        public let path: String

        /// Get the sum of net text bytes difference per page.
        ///
        /// Given a Mediawiki project, a page-title prefixed with canonical namespace (for
        /// instance 'User:Jimbo_Wales') and a date range, returns a timeseries of bytes
        /// difference net sums. You can filter by editors-type (all-editor-types, anonymous,
        /// group-bot, name-bot, user). You can choose between daily and monthly granularity as well.
        /// 
        /// Note: Due to performance of the data-serving backend, this endpoint limits the queryable
        /// timespan to one year (whether in daily or monthly granularity).
        /// 
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 25 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.NetBytesDifferencePerPage> {
            .get(path)
        }
    }
}

extension Paths.Metrics.BytesDifference {
    public var absolute: Absolute {
        Absolute(path: path + "/absolute")
    }

    public struct Absolute {
        /// Path: `/metrics/bytes-difference/absolute`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Absolute {
    public var aggregate: Aggregate {
        Aggregate(path: path + "/aggregate")
    }

    public struct Aggregate {
        /// Path: `/metrics/bytes-difference/absolute/aggregate`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Absolute.Aggregate {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/bytes-difference/absolute/aggregate/{project}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Absolute.Aggregate.WithProject {
    public func editorType(_ editorType: String) -> WithEditorType {
        WithEditorType(path: "\(path)/\(editorType)")
    }

    public struct WithEditorType {
        /// Path: `/metrics/bytes-difference/absolute/aggregate/{project}/{editor-type}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Absolute.Aggregate.WithProject.WithEditorType {
    public func pageType(_ pageType: String) -> WithPageType {
        WithPageType(path: "\(path)/\(pageType)")
    }

    public struct WithPageType {
        /// Path: `/metrics/bytes-difference/absolute/aggregate/{project}/{editor-type}/{page-type}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Absolute.Aggregate.WithProject.WithEditorType.WithPageType {
    public func granularity(_ granularity: String) -> WithGranularity {
        WithGranularity(path: "\(path)/\(granularity)")
    }

    public struct WithGranularity {
        /// Path: `/metrics/bytes-difference/absolute/aggregate/{project}/{editor-type}/{page-type}/{granularity}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Absolute.Aggregate.WithProject.WithEditorType.WithPageType.WithGranularity {
    public func start(_ start: String) -> WithStart {
        WithStart(path: "\(path)/\(start)")
    }

    public struct WithStart {
        /// Path: `/metrics/bytes-difference/absolute/aggregate/{project}/{editor-type}/{page-type}/{granularity}/{start}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Absolute.Aggregate.WithProject.WithEditorType.WithPageType.WithGranularity.WithStart {
    public func end(_ end: String) -> WithEnd {
        WithEnd(path: "\(path)/\(end)")
    }

    public struct WithEnd {
        /// Path: `/metrics/bytes-difference/absolute/aggregate/{project}/{editor-type}/{page-type}/{granularity}/{start}/{end}`
        public let path: String

        /// Get the sum of absolute value of text bytes difference between current edit and
        /// previous one.
        ///
        /// Given a Mediawiki project and a date range, returns a timeseries of absolute bytes
        /// difference sums. You can filter by editors-type (all-editor-types, anonymous, group-bot,
        /// name-bot, user) and page-type (all-page-types, content, non-content). You can choose
        /// between daily and monthly granularity as well.
        /// 
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 25 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.AbsoluteBytesDifference> {
            .get(path)
        }
    }
}

extension Paths.Metrics.BytesDifference.Absolute {
    public var perPage: PerPage {
        PerPage(path: path + "/per-page")
    }

    public struct PerPage {
        /// Path: `/metrics/bytes-difference/absolute/per-page`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Absolute.PerPage {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/bytes-difference/absolute/per-page/{project}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Absolute.PerPage.WithProject {
    public func pageTitle(_ pageTitle: String) -> WithPageTitle {
        WithPageTitle(path: "\(path)/\(pageTitle)")
    }

    public struct WithPageTitle {
        /// Path: `/metrics/bytes-difference/absolute/per-page/{project}/{page-title}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Absolute.PerPage.WithProject.WithPageTitle {
    public func editorType(_ editorType: String) -> WithEditorType {
        WithEditorType(path: "\(path)/\(editorType)")
    }

    public struct WithEditorType {
        /// Path: `/metrics/bytes-difference/absolute/per-page/{project}/{page-title}/{editor-type}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Absolute.PerPage.WithProject.WithPageTitle.WithEditorType {
    public func granularity(_ granularity: String) -> WithGranularity {
        WithGranularity(path: "\(path)/\(granularity)")
    }

    public struct WithGranularity {
        /// Path: `/metrics/bytes-difference/absolute/per-page/{project}/{page-title}/{editor-type}/{granularity}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Absolute.PerPage.WithProject.WithPageTitle.WithEditorType.WithGranularity {
    public func start(_ start: String) -> WithStart {
        WithStart(path: "\(path)/\(start)")
    }

    public struct WithStart {
        /// Path: `/metrics/bytes-difference/absolute/per-page/{project}/{page-title}/{editor-type}/{granularity}/{start}`
        public let path: String
    }
}

extension Paths.Metrics.BytesDifference.Absolute.PerPage.WithProject.WithPageTitle.WithEditorType.WithGranularity.WithStart {
    public func end(_ end: String) -> WithEnd {
        WithEnd(path: "\(path)/\(end)")
    }

    public struct WithEnd {
        /// Path: `/metrics/bytes-difference/absolute/per-page/{project}/{page-title}/{editor-type}/{granularity}/{start}/{end}`
        public let path: String

        /// Get the sum of absolute text bytes difference per page.
        ///
        /// Given a Mediawiki project, a page-title prefixed with canonical namespace (for
        /// instance 'User:Jimbo_Wales') and a date range, returns a timeseries of bytes
        /// difference absolute sums. You can filter by editors-type (all-editor-types, anonymous,
        /// group-bot, name-bot, user). You can choose between daily and monthly granularity as well.
        /// 
        /// Note: Due to performance of the data-serving backend, this endpoint limits the queryable
        /// timespan to one year (whether in daily or monthly granularity).
        /// 
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 25 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.AbsoluteBytesDifferencePerPage> {
            .get(path)
        }
    }
}

extension Paths.Metrics {
    public var mediarequests: Mediarequests {
        Mediarequests(path: path + "/mediarequests")
    }

    public struct Mediarequests {
        /// Path: `/metrics/mediarequests`
        public let path: String
    }
}

extension Paths.Metrics.Mediarequests {
    public var aggregate: Aggregate {
        Aggregate(path: path + "/aggregate")
    }

    public struct Aggregate {
        /// Path: `/metrics/mediarequests/aggregate`
        public let path: String
    }
}

extension Paths.Metrics.Mediarequests.Aggregate {
    public func referer(_ referer: String) -> WithReferer {
        WithReferer(path: "\(path)/\(referer)")
    }

    public struct WithReferer {
        /// Path: `/metrics/mediarequests/aggregate/{referer}`
        public let path: String
    }
}

extension Paths.Metrics.Mediarequests.Aggregate.WithReferer {
    public func mediaType(_ mediaType: String) -> WithMediaType {
        WithMediaType(path: "\(path)/\(mediaType)")
    }

    public struct WithMediaType {
        /// Path: `/metrics/mediarequests/aggregate/{referer}/{media_type}`
        public let path: String
    }
}

extension Paths.Metrics.Mediarequests.Aggregate.WithReferer.WithMediaType {
    public func agent(_ agent: String) -> WithAgent {
        WithAgent(path: "\(path)/\(agent)")
    }

    public struct WithAgent {
        /// Path: `/metrics/mediarequests/aggregate/{referer}/{media_type}/{agent}`
        public let path: String
    }
}

extension Paths.Metrics.Mediarequests.Aggregate.WithReferer.WithMediaType.WithAgent {
    public func granularity(_ granularity: String) -> WithGranularity {
        WithGranularity(path: "\(path)/\(granularity)")
    }

    public struct WithGranularity {
        /// Path: `/metrics/mediarequests/aggregate/{referer}/{media_type}/{agent}/{granularity}`
        public let path: String
    }
}

extension Paths.Metrics.Mediarequests.Aggregate.WithReferer.WithMediaType.WithAgent.WithGranularity {
    public func start(_ start: String) -> WithStart {
        WithStart(path: "\(path)/\(start)")
    }

    public struct WithStart {
        /// Path: `/metrics/mediarequests/aggregate/{referer}/{media_type}/{agent}/{granularity}/{start}`
        public let path: String
    }
}

extension Paths.Metrics.Mediarequests.Aggregate.WithReferer.WithMediaType.WithAgent.WithGranularity.WithStart {
    public func end(_ end: String) -> WithEnd {
        WithEnd(path: "\(path)/\(end)")
    }

    public struct WithEnd {
        /// Path: `/metrics/mediarequests/aggregate/{referer}/{media_type}/{agent}/{granularity}/{start}/{end}`
        public let path: String

        /// Get aggregated mediarequest counts per referer.
        ///
        /// Given a date range, returns a timeseries of mediarequest counts. You can filter by referer, media types and/or agent type. You can choose between daily and monthly granularity.
        /// counts. The data can be filtered by agent type.
        /// - Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        /// - Rate limit: 100 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.MediarequestReferer> {
            .get(path)
        }
    }
}

extension Paths.Metrics.Mediarequests {
    public var perFile: PerFile {
        PerFile(path: path + "/per-file")
    }

    public struct PerFile {
        /// Path: `/metrics/mediarequests/per-file`
        public let path: String
    }
}

extension Paths.Metrics.Mediarequests.PerFile {
    public func referer(_ referer: String) -> WithReferer {
        WithReferer(path: "\(path)/\(referer)")
    }

    public struct WithReferer {
        /// Path: `/metrics/mediarequests/per-file/{referer}`
        public let path: String
    }
}

extension Paths.Metrics.Mediarequests.PerFile.WithReferer {
    public func agent(_ agent: String) -> WithAgent {
        WithAgent(path: "\(path)/\(agent)")
    }

    public struct WithAgent {
        /// Path: `/metrics/mediarequests/per-file/{referer}/{agent}`
        public let path: String
    }
}

extension Paths.Metrics.Mediarequests.PerFile.WithReferer.WithAgent {
    public func filePath(_ filePath: String) -> WithFilePath {
        WithFilePath(path: "\(path)/\(filePath)")
    }

    public struct WithFilePath {
        /// Path: `/metrics/mediarequests/per-file/{referer}/{agent}/{file_path}`
        public let path: String
    }
}

extension Paths.Metrics.Mediarequests.PerFile.WithReferer.WithAgent.WithFilePath {
    public func granularity(_ granularity: String) -> WithGranularity {
        WithGranularity(path: "\(path)/\(granularity)")
    }

    public struct WithGranularity {
        /// Path: `/metrics/mediarequests/per-file/{referer}/{agent}/{file_path}/{granularity}`
        public let path: String
    }
}

extension Paths.Metrics.Mediarequests.PerFile.WithReferer.WithAgent.WithFilePath.WithGranularity {
    public func start(_ start: String) -> WithStart {
        WithStart(path: "\(path)/\(start)")
    }

    public struct WithStart {
        /// Path: `/metrics/mediarequests/per-file/{referer}/{agent}/{file_path}/{granularity}/{start}`
        public let path: String
    }
}

extension Paths.Metrics.Mediarequests.PerFile.WithReferer.WithAgent.WithFilePath.WithGranularity.WithStart {
    public func end(_ end: String) -> WithEnd {
        WithEnd(path: "\(path)/\(end)")
    }

    public struct WithEnd {
        /// Path: `/metrics/mediarequests/per-file/{referer}/{agent}/{file_path}/{granularity}/{start}/{end}`
        public let path: String

        /// Get aggregated mediarequest counts for a media file.
        ///
        /// Given a file stored in upload.wikimedia.org (the file storage for all media in any wiki) and a date range,
        /// returns a daily timeseries of its request counts. The data can be filtered by agent type.
        /// 
        /// - Stability: [stable](https://www.mediawiki.org/wiki/API_versioning#Stable)
        /// - Rate limit: 100 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.MediarequestFile> {
            .get(path)
        }
    }
}

extension Paths.Metrics.Mediarequests {
    public var top: Top {
        Top(path: path + "/top")
    }

    public struct Top {
        /// Path: `/metrics/mediarequests/top`
        public let path: String
    }
}

extension Paths.Metrics.Mediarequests.Top {
    public func referer(_ referer: String) -> WithReferer {
        WithReferer(path: "\(path)/\(referer)")
    }

    public struct WithReferer {
        /// Path: `/metrics/mediarequests/top/{referer}`
        public let path: String
    }
}

extension Paths.Metrics.Mediarequests.Top.WithReferer {
    public func mediaType(_ mediaType: String) -> WithMediaType {
        WithMediaType(path: "\(path)/\(mediaType)")
    }

    public struct WithMediaType {
        /// Path: `/metrics/mediarequests/top/{referer}/{media_type}`
        public let path: String
    }
}

extension Paths.Metrics.Mediarequests.Top.WithReferer.WithMediaType {
    public func year(_ year: String) -> WithYear {
        WithYear(path: "\(path)/\(year)")
    }

    public struct WithYear {
        /// Path: `/metrics/mediarequests/top/{referer}/{media_type}/{year}`
        public let path: String
    }
}

extension Paths.Metrics.Mediarequests.Top.WithReferer.WithMediaType.WithYear {
    public func month(_ month: String) -> WithMonth {
        WithMonth(path: "\(path)/\(month)")
    }

    public struct WithMonth {
        /// Path: `/metrics/mediarequests/top/{referer}/{media_type}/{year}/{month}`
        public let path: String
    }
}

extension Paths.Metrics.Mediarequests.Top.WithReferer.WithMediaType.WithYear.WithMonth {
    public func day(_ day: String) -> WithDay {
        WithDay(path: "\(path)/\(day)")
    }

    public struct WithDay {
        /// Path: `/metrics/mediarequests/top/{referer}/{media_type}/{year}/{month}/{day}`
        public let path: String

        /// Get the most requested files for a referer.
        ///
        /// Lists the 1000 most requested files for a given referer and timespan (month or day). You can filter by access method.
        /// - Stability: [stable](https://www.mediawiki.org/wiki/API_versioning#Stable)
        /// - Rate limit: 100 req/s
        /// - License: Data accessible via this endpoint is available under the
        ///   [CC0 1.0 license](https://creativecommons.org/publicdomain/zero/1.0/).
        public var get: Request<WikimediaAPI.MediarequestTops> {
            .get(path)
        }
    }
}

extension Paths.Metrics.Editors {
    public var byCountry: ByCountry {
        ByCountry(path: path + "/by-country")
    }

    public struct ByCountry {
        /// Path: `/metrics/editors/by-country`
        public let path: String
    }
}

extension Paths.Metrics.Editors.ByCountry {
    public func project(_ project: String) -> WithProject {
        WithProject(path: "\(path)/\(project)")
    }

    public struct WithProject {
        /// Path: `/metrics/editors/by-country/{project}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.ByCountry.WithProject {
    public func activityLevel(_ activityLevel: String) -> WithActivityLevel {
        WithActivityLevel(path: "\(path)/\(activityLevel)")
    }

    public struct WithActivityLevel {
        /// Path: `/metrics/editors/by-country/{project}/{activity-level}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.ByCountry.WithProject.WithActivityLevel {
    public func year(_ year: String) -> WithYear {
        WithYear(path: "\(path)/\(year)")
    }

    public struct WithYear {
        /// Path: `/metrics/editors/by-country/{project}/{activity-level}/{year}`
        public let path: String
    }
}

extension Paths.Metrics.Editors.ByCountry.WithProject.WithActivityLevel.WithYear {
    public func month(_ month: String) -> WithMonth {
        WithMonth(path: "\(path)/\(month)")
    }

    public struct WithMonth {
        /// Path: `/metrics/editors/by-country/{project}/{activity-level}/{year}/{month}`
        public let path: String

        /// Get editor counts by country.
        ///
        /// Given a Wikipedia project, an activity level, and a month, returns the upper bounds of
        /// the editor counts, split by country of origin. Because of privacy reasons, editor counts
        /// are given in a bounded format and are not reported for certain countries or for inactive
        /// Wikipedias. Read more about privacy considerations
        /// [here](https://wikitech.wikimedia.org/wiki/Analytics/Data_Lake/Edits/Geoeditors/Public#Privacy).
        /// Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        public var get: Request<WikimediaAPI.EditorsByCountry> {
            .get(path)
        }
    }
}

extension Paths {
    public static var transform: Transform {
        Transform(path: "/transform")
    }

    public struct Transform {
        /// Path: `/transform`
        public let path: String
    }
}

extension Paths.Transform {
    public var html: HTML {
        HTML(path: path + "/html")
    }

    public struct HTML {
        /// Path: `/transform/html`
        public let path: String
    }
}

extension Paths.Transform.HTML {
    public var from: From {
        From(path: path + "/from")
    }

    public struct From {
        /// Path: `/transform/html/from`
        public let path: String
    }
}

extension Paths.Transform.HTML.From {
    public func fromLang(_ fromLang: String) -> WithFromLang {
        WithFromLang(path: "\(path)/\(fromLang)")
    }

    public struct WithFromLang {
        /// Path: `/transform/html/from/{from_lang}`
        public let path: String
    }
}

extension Paths.Transform.HTML.From.WithFromLang {
    public var to: To {
        To(path: path + "/to")
    }

    public struct To {
        /// Path: `/transform/html/from/{from_lang}/to`
        public let path: String
    }
}

extension Paths.Transform.HTML.From.WithFromLang.To {
    public func toLang(_ toLang: String) -> WithToLang {
        WithToLang(path: "\(path)/\(toLang)")
    }

    public struct WithToLang {
        /// Path: `/transform/html/from/{from_lang}/to/{to_lang}`
        public let path: String

        /// Machine-translate content
        ///
        /// Fetches the machine translation for the posted content from the source
        /// to the destination language.
        /// 
        /// Stability: [unstable](https://www.mediawiki.org/wiki/API_versioning#Unstable)
        public func post(_ body: PostRequest) -> Request<WikimediaAPI.CxMt> {
            .post(path, body: body.asQuery())
        }

        public struct PostRequest: Encodable {
            /// The HTML content to translate
            public var html: String

            public init(html: String) {
                self.html = html
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("html", html)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths.Transform.HTML.From.WithFromLang.To.WithToLang {
    public func provider(_ provider: String) -> WithProvider {
        WithProvider(path: "\(path)/\(provider)")
    }

    public struct WithProvider {
        /// Path: `/transform/html/from/{from_lang}/to/{to_lang}/{provider}`
        public let path: String

        /// Machine-translate content
        ///
        /// Fetches the machine translation for the posted content from the source
        /// to the destination language.
        /// 
        /// Stability: [unstable](https://www.mediawiki.org/wiki/API_versioning#Unstable)
        public func post(_ body: Data) -> Request<WikimediaAPI.CxMt> {
            .post(path, body: body)
        }
    }
}

extension Paths.Transform {
    public var word: Word {
        Word(path: path + "/word")
    }

    public struct Word {
        /// Path: `/transform/word`
        public let path: String
    }
}

extension Paths.Transform.Word {
    public var from: From {
        From(path: path + "/from")
    }

    public struct From {
        /// Path: `/transform/word/from`
        public let path: String
    }
}

extension Paths.Transform.Word.From {
    public func fromLang(_ fromLang: String) -> WithFromLang {
        WithFromLang(path: "\(path)/\(fromLang)")
    }

    public struct WithFromLang {
        /// Path: `/transform/word/from/{from_lang}`
        public let path: String
    }
}

extension Paths.Transform.Word.From.WithFromLang {
    public var to: To {
        To(path: path + "/to")
    }

    public struct To {
        /// Path: `/transform/word/from/{from_lang}/to`
        public let path: String
    }
}

extension Paths.Transform.Word.From.WithFromLang.To {
    public func toLang(_ toLang: String) -> WithToLang {
        WithToLang(path: "\(path)/\(toLang)")
    }

    public struct WithToLang {
        /// Path: `/transform/word/from/{from_lang}/to/{to_lang}`
        public let path: String
    }
}

extension Paths.Transform.Word.From.WithFromLang.To.WithToLang {
    public func word(_ word: String) -> WithWord {
        WithWord(path: "\(path)/\(word)")
    }

    public struct WithWord {
        /// Path: `/transform/word/from/{from_lang}/to/{to_lang}/{word}`
        public let path: String

        /// Fetch the dictionary meaning of a word
        ///
        /// Fetches the dictionary meaning of a word from a language and displays
        /// it in the target language.
        /// 
        /// Stability: [unstable](https://www.mediawiki.org/wiki/API_versioning#Unstable)
        public var get: Request<WikimediaAPI.CxDict> {
            .get(path)
        }
    }
}

extension Paths.Transform.Word.From.WithFromLang.To.WithToLang.WithWord {
    public func provider(_ provider: String) -> WithProvider {
        WithProvider(path: "\(path)/\(provider)")
    }

    public struct WithProvider {
        /// Path: `/transform/word/from/{from_lang}/to/{to_lang}/{word}/{provider}`
        public let path: String

        /// Fetch the dictionary meaning of a word
        ///
        /// Fetches the dictionary meaning of a word from a language and displays
        /// it in the target language.
        /// 
        /// Stability: [unstable](https://www.mediawiki.org/wiki/API_versioning#Unstable)
        public var get: Request<WikimediaAPI.CxDict> {
            .get(path)
        }
    }
}

extension Paths.Transform {
    public var list: List {
        List(path: path + "/list")
    }

    public struct List {
        /// Path: `/transform/list`
        public let path: String
    }
}

extension Paths.Transform.List {
    public var pair: Pair {
        Pair(path: path + "/pair")
    }

    public struct Pair {
        /// Path: `/transform/list/pair`
        public let path: String
    }
}

extension Paths.Transform.List.Pair {
    public func from(_ from: String) -> WithFrom {
        WithFrom(path: "\(path)/\(from)")
    }

    public struct WithFrom {
        /// Path: `/transform/list/pair/{from}`
        public let path: String
    }
}

extension Paths.Transform.List.Pair.WithFrom {
    public func to(_ to: String) -> WithTo {
        WithTo(path: "\(path)/\(to)")
    }

    public struct WithTo {
        /// Path: `/transform/list/pair/{from}/{to}`
        public let path: String

        /// Lists the tools available for a language pair
        ///
        /// Fetches the list of tools that are available for the given pair of languages.
        /// 
        /// Stability: [unstable](https://www.mediawiki.org/wiki/API_versioning#Unstable)
        public var get: Request<WikimediaAPI.CxListTools> {
            .get(path)
        }
    }
}

extension Paths.Transform.List {
    public var tool: Tool {
        Tool(path: path + "/tool")
    }

    public struct Tool {
        /// Path: `/transform/list/tool`
        public let path: String
    }
}

extension Paths.Transform.List.Tool {
    public func tool(_ tool: String) -> WithTool {
        WithTool(path: "\(path)/\(tool)")
    }

    public struct WithTool {
        /// Path: `/transform/list/tool/{tool}`
        public let path: String

        /// Lists the tools and language pairs available for the given tool category
        ///
        /// Fetches the list of tools and all of the language pairs it can translate
        /// 
        /// Stability: [unstable](https://www.mediawiki.org/wiki/API_versioning#Unstable)
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Transform.List.Tool.WithTool {
    public func from(_ from: String) -> WithFrom {
        WithFrom(path: "\(path)/\(from)")
    }

    public struct WithFrom {
        /// Path: `/transform/list/tool/{tool}/{from}`
        public let path: String
    }
}

extension Paths.Transform.List.Tool.WithTool.WithFrom {
    public func to(_ to: String) -> WithTo {
        WithTo(path: "\(path)/\(to)")
    }

    public struct WithTo {
        /// Path: `/transform/list/tool/{tool}/{from}/{to}`
        public let path: String

        /// Lists the tools and language pairs available for the given tool category
        ///
        /// Fetches the list of tools and all of the language pairs it can translate
        /// 
        /// Stability: [unstable](https://www.mediawiki.org/wiki/API_versioning#Unstable)
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Transform.List {
    public var languagepairs: Languagepairs {
        Languagepairs(path: path + "/languagepairs")
    }

    public struct Languagepairs {
        /// Path: `/transform/list/languagepairs`
        public let path: String

        /// Lists the language pairs supported by the back-end
        ///
        /// Fetches the list of language pairs the back-end service can translate
        /// 
        /// Stability: [unstable](https://www.mediawiki.org/wiki/API_versioning#Unstable)
        public var get: Request<WikimediaAPI.CxLanguagepairs> {
            .get(path)
        }
    }
}

extension Paths {
    public static var feed: Feed {
        Feed(path: "/feed")
    }

    public struct Feed {
        /// Path: `/feed`
        public let path: String
    }
}

extension Paths.Feed {
    public var availability: Availability {
        Availability(path: path + "/availability")
    }

    public struct Availability {
        /// Path: `/feed/availability`
        public let path: String

        /// Gets availability of featured feed content for the apps by wiki domain.
        ///
        /// Gets availability of featured feed content for the apps by wiki domain.
        /// 
        /// Stability: [experimental](https://www.mediawiki.org/wiki/API_versioning#Experimental)
        public var get: Request<WikimediaAPI.Availability> {
            .get(path)
        }
    }
}

public enum Paths {}

protocol QueryEncodable {
    var asQueryValue: String { get }
}

extension Bool: QueryEncodable {
    var asQueryValue: String {
        self ? "true" : "false"
    }
}

extension Date: QueryEncodable {
    var asQueryValue: String {
        ISO8601DateFormatter().string(from: self)
    }
}

extension Double: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int32: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int64: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension String: QueryEncodable {
    var asQueryValue: String {
        self
    }
}

extension URL: QueryEncodable {
    var asQueryValue: String {
        absoluteString
    }
}

extension RawRepresentable where RawValue == String {
    var asQueryValue: String {
        rawValue
    }
}

extension Array where Element == (String, String?) {
    mutating func addQueryItem<T: RawRepresentable>(_ name: String, _ value: T?) where T.RawValue == String {
        addQueryItem(name, value?.rawValue)
    }
    
    mutating func addQueryItem(_ name: String, _ value: QueryEncodable?) {
        guard let value = value?.asQueryValue, !value.isEmpty else { return }
        append((name, value))
    }
    
    mutating func addDeepObject(_ name: String, _ query: [(String, String?)]) {
        for (key, value) in query {
            addQueryItem("\(name)[\(key)]", value)
        }
    }

    var asPercentEncodedQuery: String {
        var components = URLComponents()
        components.queryItems = self.map(URLQueryItem.init)
        return components.percentEncodedQuery ?? ""
    }
    
    // [("role", "admin"), ("name": "kean)] -> "role,admin,name,kean"
    var asCompactQuery: String {
        flatMap { [$0, $1] }.compactMap { $0 }.joined(separator: ",")
    }
}
