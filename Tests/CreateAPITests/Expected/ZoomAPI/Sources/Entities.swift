// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import NaiveDate

/// List of Roles
public struct RoleList: Codable {
    /// The number of all records available across pages
    public var totalRecords: Int?
    /// List of Roles objects
    public var roles: [Role]?

    public struct Role: Codable {
        /// Role Id
        public var id: String?
        /// Role Name
        public var name: String?
        /// Role Description
        public var description: String?
        /// Total members in this role
        public var totalMembers: Int?

        public init(id: String? = nil, name: String? = nil, description: String? = nil, totalMembers: Int? = nil) {
            self.id = id
            self.name = name
            self.description = description
            self.totalMembers = totalMembers
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
            self.totalMembers = try values.decodeIfPresent(Int.self, forKey: "total_members")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(description, forKey: "description")
            try values.encodeIfPresent(totalMembers, forKey: "total_members")
        }
    }

    public init(totalRecords: Int? = nil, roles: [Role]? = nil) {
        self.totalRecords = totalRecords
        self.roles = roles
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.totalRecords = try values.decodeIfPresent(Int.self, forKey: "total_records")
        self.roles = try values.decodeIfPresent([Role].self, forKey: "roles")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(totalRecords, forKey: "total_records")
        try values.encodeIfPresent(roles, forKey: "roles")
    }
}

/// List of a Role Members
public struct RoleMembersList: Codable {
    /// The number of pages returned for the request made.
    public var pageCount: Int?
    /// The page number of the current results.
    public var pageNumber: Int?
    /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
    public var nextPageToken: String?
    /// The number of records returned within a single API call.
    public var pageSize: Int?
    /// The total number of all the records available across pages.
    public var totalRecords: Int?
    /// List of a Role Members
    public var members: [Member]?

    public struct Member: Codable {
        /// Member ID
        public var id: String?
        /// Member Email
        public var email: String?
        /// Member First Name
        public var firstName: String?
        /// Member Last Name
        public var lastName: String?
        /// Member Type
        public var type: Int?
        /// Member Department
        public var department: String?

        public init(id: String? = nil, email: String? = nil, firstName: String? = nil, lastName: String? = nil, type: Int? = nil, department: String? = nil) {
            self.id = id
            self.email = email
            self.firstName = firstName
            self.lastName = lastName
            self.type = type
            self.department = department
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.email = try values.decodeIfPresent(String.self, forKey: "email")
            self.firstName = try values.decodeIfPresent(String.self, forKey: "first_name")
            self.lastName = try values.decodeIfPresent(String.self, forKey: "last_name")
            self.type = try values.decodeIfPresent(Int.self, forKey: "type")
            self.department = try values.decodeIfPresent(String.self, forKey: "department")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(email, forKey: "email")
            try values.encodeIfPresent(firstName, forKey: "first_name")
            try values.encodeIfPresent(lastName, forKey: "last_name")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encodeIfPresent(department, forKey: "department")
        }
    }

    public init(pageCount: Int? = nil, pageNumber: Int? = nil, nextPageToken: String? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, members: [Member]? = nil) {
        self.pageCount = pageCount
        self.pageNumber = pageNumber
        self.nextPageToken = nextPageToken
        self.pageSize = pageSize
        self.totalRecords = totalRecords
        self.members = members
    }

    private enum CodingKeys: String, CodingKey {
        case pageCount = "page_count"
        case pageNumber = "page_number"
        case nextPageToken = "next_page_token"
        case pageSize = "page_size"
        case totalRecords = "total_records"
        case members
    }
}

/// Pagination object.
public struct PaginationToken: Codable {
    /// The number of pages returned for the request made.
    public var pageCount: Int?
    /// The number of records returned within a single API call.
    public var pageSize: Int?
    /// The number of all records available across pages.
    public var totalRecords: Int?
    /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
    public var nextPageToken: String?

    public init(pageCount: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil) {
        self.pageCount = pageCount
        self.pageSize = pageSize
        self.totalRecords = totalRecords
        self.nextPageToken = nextPageToken
    }

    private enum CodingKeys: String, CodingKey {
        case pageCount = "page_count"
        case pageSize = "page_size"
        case totalRecords = "total_records"
        case nextPageToken = "next_page_token"
    }
}

/// Pagination object.
public struct PaginationToken4IMChat: Codable {
    /// The amount of records returns within a single API call.
    public var pageSize: Int?
    /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of the available result list exceeds the page size. The expiration period is 15 minutes.
    public var nextPageToken: String?

    public init(pageSize: Int? = nil, nextPageToken: String? = nil) {
        self.pageSize = pageSize
        self.nextPageToken = nextPageToken
    }

    private enum CodingKeys: String, CodingKey {
        case pageSize = "page_size"
        case nextPageToken = "next_page_token"
    }
}

/// The channel object represents a Zoom chat [channel](https://support.zoom.us/hc/en-us/articles/200912909-Getting-Started-With-Channels-Group-Messaging-).
public struct Channel: Codable {
    public var properties: Properties?

    public struct Properties: Codable {
        /// The ID of the channel.
        public var id: String?
        /// The [Jabber Identity](https://en.wikipedia.org/wiki/JID_(Jabber)) used to access the account.
        public var jid: String?
        /// The channel name.
        public var name: String?
        /// The channel's type:
        /// * `0` — An unknown channel type.
        /// * `1` — A private channel. Members must be invited to join this channel.
        /// * `2` — A private channel with members that belong to a Zoom account. All members of this channel are from the same organization and must be invited to join.
        /// * `3` — A public channel. Anyone can search for and join this channel.
        /// * `4` — An instant channel. This type of channel is created by adding members to a new chat.
        /// * `5` — A public channel. Anyone can join this channel and invite members from other Zoom accounts.
        public var type: Int?
        public var channelSettings: ChannelSettings?

        public struct ChannelSettings: Codable {
            /// New members to the channel can see previous messages and files posted in the channel.
            public var newMembersCanSeePreviousMessagesFiles: Bool?
            /// Allow members to add external users to the channel. The value can be one of the following:<br>
            /// `0`: Disable. Do not allow channel members to add external users to the channel.<br>
            /// `1`: All channel members. Allow all channel members to add external users to the channel.<br>
            /// `2`: By members in your organization. Allow only members in your organization to add external users to the channel.
            public var allowToAddExternalUsers: Int?
            /// Permissions for members to post to the channel. The value can be one of the following:<br>
            /// `1`: Everyone. All members can post to the channel.<br>
            /// `2`: Admin only. Only the admin can post to the channel<br>
            /// `3`: Admin and specific members. Only the admin and specified members can post to the channel. <br>
            public var postingPermissions: Int?

            public init(newMembersCanSeePreviousMessagesFiles: Bool? = nil, allowToAddExternalUsers: Int? = nil, postingPermissions: Int? = nil) {
                self.newMembersCanSeePreviousMessagesFiles = newMembersCanSeePreviousMessagesFiles
                self.allowToAddExternalUsers = allowToAddExternalUsers
                self.postingPermissions = postingPermissions
            }

            private enum CodingKeys: String, CodingKey {
                case newMembersCanSeePreviousMessagesFiles = "new_members_can_see_previous_messages_files"
                case allowToAddExternalUsers = "allow_to_add_external_users"
                case postingPermissions = "posting_permissions"
            }
        }

        public init(id: String? = nil, jid: String? = nil, name: String? = nil, type: Int? = nil, channelSettings: ChannelSettings? = nil) {
            self.id = id
            self.jid = jid
            self.name = name
            self.type = type
            self.channelSettings = channelSettings
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case jid
            case name
            case type
            case channelSettings = "channel_settings"
        }
    }

    public init(properties: Properties? = nil) {
        self.properties = properties
    }
}

/// Pagination Object.
public struct Pagination: Codable {
    /// The number of pages returned for the request made.
    public var pageCount: Int?
    /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
    public var pageNumber: Int?
    /// The number of records returned with a single API call.
    public var pageSize: Int?
    /// The total number of all the records available across pages.
    public var totalRecords: Int?
    /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
    public var nextPageToken: String?

    public init(pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil) {
        self.pageCount = pageCount
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.totalRecords = totalRecords
        self.nextPageToken = nextPageToken
    }

    private enum CodingKeys: String, CodingKey {
        case pageCount = "page_count"
        case pageNumber = "page_number"
        case pageSize = "page_size"
        case totalRecords = "total_records"
        case nextPageToken = "next_page_token"
    }
}

/// Zoom room.
public struct ZoomRoom: Codable {
    /// Zoom room ID.
    public var id: String?
    /// Zoom room name.
    public var roomName: String?
    /// Zoom calendar name.
    public var calenderName: String?
    /// Zoom room email.
    public var email: String?
    /// Zoom room email type.
    public var accountType: String?
    /// Zoom room status.
    public var status: String?
    /// Zoom room device IP.
    public var deviceIp: String?
    /// Zoom Room camera.
    /// 
    /// **Note:** This response returns an empty string (`““`) value for any users who are **not** a part of the host's account (external users).
    public var camera: String?
    /// Zoom Room microphone.
    /// 
    /// **Note:** This response returns an empty string (`““`) value for any users who are **not** a part of the host's account (external users).
    public var microphone: String?
    /// Zoom Room speaker.
    /// 
    /// **Note:** This response returns an empty string (`““`) value for any users who are **not** a part of the host's account (external users).
    public var speaker: String?
    /// Zoom room last start time.
    public var lastStartTime: String?
    /// Zoom room location.
    public var location: String?
    public var health: String?
    /// Zoom Room issues.
    public var issues: [String]?

    public init(id: String? = nil, roomName: String? = nil, calenderName: String? = nil, email: String? = nil, accountType: String? = nil, status: String? = nil, deviceIp: String? = nil, camera: String? = nil, microphone: String? = nil, speaker: String? = nil, lastStartTime: String? = nil, location: String? = nil, health: String? = nil, issues: [String]? = nil) {
        self.id = id
        self.roomName = roomName
        self.calenderName = calenderName
        self.email = email
        self.accountType = accountType
        self.status = status
        self.deviceIp = deviceIp
        self.camera = camera
        self.microphone = microphone
        self.speaker = speaker
        self.lastStartTime = lastStartTime
        self.location = location
        self.health = health
        self.issues = issues
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case roomName = "room_name"
        case calenderName = "calender_name"
        case email
        case accountType = "account_type"
        case status
        case deviceIp = "device_ip"
        case camera
        case microphone
        case speaker
        case lastStartTime = "last_start_time"
        case location
        case health
        case issues
    }
}

/// Participant QOS
///
/// Information about the participant and their quality of service (QoS).
public struct QOSParticipant: Codable {
    /// The participant's ID. This value is assigned to a participant upon joining a meeting and is only valid for the meeting's duration.
    public var userID: String?
    /// The participant's display name.
    public var userName: String?
    /// The type of device the participant used to join the meeting: 
    /// * `Phone` — The participant joined via PSTN. 
    /// * `H.323/SIP` — The participant joined via an H.323 or SIP device. 
    /// * `Windows` — The participant joined via VoIP using a Windows device. 
    /// * `Mac` — The participant joined via VoIP using a Mac device. 
    /// * `iOS` — The participant joined via VoIP using an iOS device. 
    /// * `Android` — The participant joined via VoIP using an Android device. 
    /// 
    /// **Note:** This response returns an empty string (`““`) value for any users who are **not** a part of the host's account (external users).
    public var device: Device?
    /// The participant's IP address.
    public var ipAddress: String?
    /// The participant's location.
    public var location: String?
    /// The time at which the participant joined the meeting.
    public var joinTime: Date?
    /// The time at which the participant left the meeting.
    public var leaveTime: Date?
    /// The participant's PC name.
    public var pcName: String?
    /// The participant's PC domain. 
    /// 
    /// **Note:** This response returns an empty string (`““`) value for any users who are **not** a part of the host's account (external users).
    public var domain: String?
    /// The participant's MAC address. 
    /// 
    /// **Note:** This response returns an empty string (`““`) value for any users who are **not** a part of the host's account (external users).
    public var macAddr: String?
    /// The participant's hard disk ID. 
    /// 
    /// **Note:** This response returns an empty string (`““`) value for any users who are **not** a part of the host's account (external users).
    public var harddiskID: String?
    /// The participant's Zoom client version.
    public var version: String?
    /// The participant's quality of service information.
    public var userQos: [UserQo]?

    /// The type of device the participant used to join the meeting: 
    /// * `Phone` — The participant joined via PSTN. 
    /// * `H.323/SIP` — The participant joined via an H.323 or SIP device. 
    /// * `Windows` — The participant joined via VoIP using a Windows device. 
    /// * `Mac` — The participant joined via VoIP using a Mac device. 
    /// * `iOS` — The participant joined via VoIP using an iOS device. 
    /// * `Android` — The participant joined via VoIP using an Android device. 
    /// 
    /// **Note:** This response returns an empty string (`““`) value for any users who are **not** a part of the host's account (external users).
    public enum Device: String, Codable, CaseIterable {
        case phone = "Phone"
        case h323Sip = "H.323/SIP"
        case windows = "Windows"
        case mac = "Mac"
        case iOS
        case android = "Android"
    }

    public struct UserQo: Codable {
        /// The QoS date and time.
        public var dateTime: Date?
        /// Audio QoS Object
        public var audioInput: AudioInput?
        /// Audio QoS Object
        public var audioOutput: AudioOutput?
        /// Video QoS Object
        public var videoInput: VideoInput?
        /// Video QoS Object
        public var videoOutput: VideoOutput?
        /// Video QoS Object
        public var asInput: AsInput?
        /// Video QoS Object
        public var asOutput: AsOutput?
        public var cpuUsage: CpuUsage?
        /// The QoS metrics for audio sent by a participant who joined the meeting via a Cloud Room Connector (CRC).
        public var audioDeviceFromCrc: AudioDeviceFromCrc?
        /// The QoS metrics for audio received by a participant who joined the meeting via CRC.
        public var audioDeviceToCrc: AudioDeviceToCrc?
        /// The QoS metrics for video input being sent by a participant who joined the meeting via CRC.
        public var videoDeviceFromCrc: VideoDeviceFromCrc?
        /// The QoS metrics for video output being sent by a participant who joined the meeting via CRC.
        public var videoDeviceToCrc: VideoDeviceToCrc?
        /// The QoS metrics for screen sharing by a participant who joined the meeting via CRC.
        public var asDeviceFromCrc: AsDeviceFromCrc?
        /// The QoS metrics for screen sharing output received by a participant who joined the meeting via CRC.
        public var asDeviceToCrc: AsDeviceToCrc?

        /// Audio QoS Object
        public struct AudioInput: Codable {
            /// The bits per second transmitted along a digital network, in kbsp.
            public var bitrate: String?
            /// The time it took a packet to travel from one point to another, in milliseconds.
            public var latency: String?
            /// The variation in the delay of received packets, in milliseconds.
            public var jitter: String?
            /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
            public var avgLoss: String?
            /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
            public var maxLoss: String?

            public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                self.bitrate = bitrate
                self.latency = latency
                self.jitter = jitter
                self.avgLoss = avgLoss
                self.maxLoss = maxLoss
            }

            private enum CodingKeys: String, CodingKey {
                case bitrate
                case latency
                case jitter
                case avgLoss = "avg_loss"
                case maxLoss = "max_loss"
            }
        }

        /// Audio QoS Object
        public struct AudioOutput: Codable {
            /// The bits per second transmitted along a digital network, in kbsp.
            public var bitrate: String?
            /// The time it took a packet to travel from one point to another, in milliseconds.
            public var latency: String?
            /// The variation in the delay of received packets, in milliseconds.
            public var jitter: String?
            /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
            public var avgLoss: String?
            /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
            public var maxLoss: String?

            public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                self.bitrate = bitrate
                self.latency = latency
                self.jitter = jitter
                self.avgLoss = avgLoss
                self.maxLoss = maxLoss
            }

            private enum CodingKeys: String, CodingKey {
                case bitrate
                case latency
                case jitter
                case avgLoss = "avg_loss"
                case maxLoss = "max_loss"
            }
        }

        /// Video QoS Object
        public struct VideoInput: Codable {
            /// The bits per second transmitted along a digital network, in kbsp.
            public var bitrate: String?
            /// The time it took a packet to travel from one point to another, in milliseconds.
            public var latency: String?
            /// The variation in the delay of received packets, in milliseconds.
            public var jitter: String?
            /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
            public var avgLoss: String?
            /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
            public var maxLoss: String?
            /// The number of pixels in each dimension that the video camera can display.
            public var resolution: String?
            /// The rate at which the video camera can produce unique images (frames). Zoom supports a frame rate of up to 30fps.
            public var frameRate: String?

            public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil, resolution: String? = nil, frameRate: String? = nil) {
                self.bitrate = bitrate
                self.latency = latency
                self.jitter = jitter
                self.avgLoss = avgLoss
                self.maxLoss = maxLoss
                self.resolution = resolution
                self.frameRate = frameRate
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.bitrate = try values.decodeIfPresent(String.self, forKey: "bitrate")
                self.latency = try values.decodeIfPresent(String.self, forKey: "latency")
                self.jitter = try values.decodeIfPresent(String.self, forKey: "jitter")
                self.avgLoss = try values.decodeIfPresent(String.self, forKey: "avg_loss")
                self.maxLoss = try values.decodeIfPresent(String.self, forKey: "max_loss")
                self.resolution = try values.decodeIfPresent(String.self, forKey: "resolution")
                self.frameRate = try values.decodeIfPresent(String.self, forKey: "frame_rate")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(bitrate, forKey: "bitrate")
                try values.encodeIfPresent(latency, forKey: "latency")
                try values.encodeIfPresent(jitter, forKey: "jitter")
                try values.encodeIfPresent(avgLoss, forKey: "avg_loss")
                try values.encodeIfPresent(maxLoss, forKey: "max_loss")
                try values.encodeIfPresent(resolution, forKey: "resolution")
                try values.encodeIfPresent(frameRate, forKey: "frame_rate")
            }
        }

        /// Video QoS Object
        public struct VideoOutput: Codable {
            /// The bits per second transmitted along a digital network, in kbsp.
            public var bitrate: String?
            /// The time it took a packet to travel from one point to another, in milliseconds.
            public var latency: String?
            /// The variation in the delay of received packets, in milliseconds.
            public var jitter: String?
            /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
            public var avgLoss: String?
            /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
            public var maxLoss: String?
            /// The number of pixels in each dimension that the video camera can display.
            public var resolution: String?
            /// The rate at which the video camera can produce unique images (frames). Zoom supports a frame rate of up to 30fps.
            public var frameRate: String?

            public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil, resolution: String? = nil, frameRate: String? = nil) {
                self.bitrate = bitrate
                self.latency = latency
                self.jitter = jitter
                self.avgLoss = avgLoss
                self.maxLoss = maxLoss
                self.resolution = resolution
                self.frameRate = frameRate
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.bitrate = try values.decodeIfPresent(String.self, forKey: "bitrate")
                self.latency = try values.decodeIfPresent(String.self, forKey: "latency")
                self.jitter = try values.decodeIfPresent(String.self, forKey: "jitter")
                self.avgLoss = try values.decodeIfPresent(String.self, forKey: "avg_loss")
                self.maxLoss = try values.decodeIfPresent(String.self, forKey: "max_loss")
                self.resolution = try values.decodeIfPresent(String.self, forKey: "resolution")
                self.frameRate = try values.decodeIfPresent(String.self, forKey: "frame_rate")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(bitrate, forKey: "bitrate")
                try values.encodeIfPresent(latency, forKey: "latency")
                try values.encodeIfPresent(jitter, forKey: "jitter")
                try values.encodeIfPresent(avgLoss, forKey: "avg_loss")
                try values.encodeIfPresent(maxLoss, forKey: "max_loss")
                try values.encodeIfPresent(resolution, forKey: "resolution")
                try values.encodeIfPresent(frameRate, forKey: "frame_rate")
            }
        }

        /// Video QoS Object
        public struct AsInput: Codable {
            /// The bits per second transmitted along a digital network, in kbsp.
            public var bitrate: String?
            /// The time it took a packet to travel from one point to another, in milliseconds.
            public var latency: String?
            /// The variation in the delay of received packets, in milliseconds.
            public var jitter: String?
            /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
            public var avgLoss: String?
            /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
            public var maxLoss: String?
            /// The number of pixels in each dimension that the video camera can display.
            public var resolution: String?
            /// The rate at which the video camera can produce unique images (frames). Zoom supports a frame rate of up to 30fps.
            public var frameRate: String?

            public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil, resolution: String? = nil, frameRate: String? = nil) {
                self.bitrate = bitrate
                self.latency = latency
                self.jitter = jitter
                self.avgLoss = avgLoss
                self.maxLoss = maxLoss
                self.resolution = resolution
                self.frameRate = frameRate
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.bitrate = try values.decodeIfPresent(String.self, forKey: "bitrate")
                self.latency = try values.decodeIfPresent(String.self, forKey: "latency")
                self.jitter = try values.decodeIfPresent(String.self, forKey: "jitter")
                self.avgLoss = try values.decodeIfPresent(String.self, forKey: "avg_loss")
                self.maxLoss = try values.decodeIfPresent(String.self, forKey: "max_loss")
                self.resolution = try values.decodeIfPresent(String.self, forKey: "resolution")
                self.frameRate = try values.decodeIfPresent(String.self, forKey: "frame_rate")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(bitrate, forKey: "bitrate")
                try values.encodeIfPresent(latency, forKey: "latency")
                try values.encodeIfPresent(jitter, forKey: "jitter")
                try values.encodeIfPresent(avgLoss, forKey: "avg_loss")
                try values.encodeIfPresent(maxLoss, forKey: "max_loss")
                try values.encodeIfPresent(resolution, forKey: "resolution")
                try values.encodeIfPresent(frameRate, forKey: "frame_rate")
            }
        }

        /// Video QoS Object
        public struct AsOutput: Codable {
            /// The bits per second transmitted along a digital network, in kbsp.
            public var bitrate: String?
            /// The time it took a packet to travel from one point to another, in milliseconds.
            public var latency: String?
            /// The variation in the delay of received packets, in milliseconds.
            public var jitter: String?
            /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
            public var avgLoss: String?
            /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
            public var maxLoss: String?
            /// The number of pixels in each dimension that the video camera can display.
            public var resolution: String?
            /// The rate at which the video camera can produce unique images (frames). Zoom supports a frame rate of up to 30fps.
            public var frameRate: String?

            public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil, resolution: String? = nil, frameRate: String? = nil) {
                self.bitrate = bitrate
                self.latency = latency
                self.jitter = jitter
                self.avgLoss = avgLoss
                self.maxLoss = maxLoss
                self.resolution = resolution
                self.frameRate = frameRate
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.bitrate = try values.decodeIfPresent(String.self, forKey: "bitrate")
                self.latency = try values.decodeIfPresent(String.self, forKey: "latency")
                self.jitter = try values.decodeIfPresent(String.self, forKey: "jitter")
                self.avgLoss = try values.decodeIfPresent(String.self, forKey: "avg_loss")
                self.maxLoss = try values.decodeIfPresent(String.self, forKey: "max_loss")
                self.resolution = try values.decodeIfPresent(String.self, forKey: "resolution")
                self.frameRate = try values.decodeIfPresent(String.self, forKey: "frame_rate")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(bitrate, forKey: "bitrate")
                try values.encodeIfPresent(latency, forKey: "latency")
                try values.encodeIfPresent(jitter, forKey: "jitter")
                try values.encodeIfPresent(avgLoss, forKey: "avg_loss")
                try values.encodeIfPresent(maxLoss, forKey: "max_loss")
                try values.encodeIfPresent(resolution, forKey: "resolution")
                try values.encodeIfPresent(frameRate, forKey: "frame_rate")
            }
        }

        public struct CpuUsage: Codable {
            /// Zoom's minimum CPU usage.
            public var zoomMinCpuUsage: String?
            /// Zoom's average CPU usage.
            public var zoomAvgCpuUsage: String?
            /// Zoom's maximum CPU usage.
            public var zoomMaxCpuUsage: String?
            /// The system's maximum CPU usage.
            public var systemMaxCpuUsage: String?

            public init(zoomMinCpuUsage: String? = nil, zoomAvgCpuUsage: String? = nil, zoomMaxCpuUsage: String? = nil, systemMaxCpuUsage: String? = nil) {
                self.zoomMinCpuUsage = zoomMinCpuUsage
                self.zoomAvgCpuUsage = zoomAvgCpuUsage
                self.zoomMaxCpuUsage = zoomMaxCpuUsage
                self.systemMaxCpuUsage = systemMaxCpuUsage
            }

            private enum CodingKeys: String, CodingKey {
                case zoomMinCpuUsage = "zoom_min_cpu_usage"
                case zoomAvgCpuUsage = "zoom_avg_cpu_usage"
                case zoomMaxCpuUsage = "zoom_max_cpu_usage"
                case systemMaxCpuUsage = "system_max_cpu_usage"
            }
        }

        /// The QoS metrics for audio sent by a participant who joined the meeting via a Cloud Room Connector (CRC).
        public struct AudioDeviceFromCrc: Codable {
            /// The bits per second transmitted along a digital network, in kbsp.
            public var bitrate: String?
            /// The time it took a packet to travel from one point to another, in milliseconds.
            public var latency: String?
            /// The variation in the delay of received packets, in milliseconds.
            public var jitter: String?
            /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
            public var avgLoss: String?
            /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
            public var maxLoss: String?

            public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                self.bitrate = bitrate
                self.latency = latency
                self.jitter = jitter
                self.avgLoss = avgLoss
                self.maxLoss = maxLoss
            }

            private enum CodingKeys: String, CodingKey {
                case bitrate
                case latency
                case jitter
                case avgLoss = "avg_loss"
                case maxLoss = "max_loss"
            }
        }

        /// The QoS metrics for audio received by a participant who joined the meeting via CRC.
        public struct AudioDeviceToCrc: Codable {
            /// The bits per second transmitted along a digital network, in kbsp.
            public var bitrate: String?
            /// The time it took a packet to travel from one point to another, in milliseconds.
            public var latency: String?
            /// The variation in the delay of received packets, in milliseconds.
            public var jitter: String?
            /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
            public var avgLoss: String?
            /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
            public var maxLoss: String?

            public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                self.bitrate = bitrate
                self.latency = latency
                self.jitter = jitter
                self.avgLoss = avgLoss
                self.maxLoss = maxLoss
            }

            private enum CodingKeys: String, CodingKey {
                case bitrate
                case latency
                case jitter
                case avgLoss = "avg_loss"
                case maxLoss = "max_loss"
            }
        }

        /// The QoS metrics for video input being sent by a participant who joined the meeting via CRC.
        public struct VideoDeviceFromCrc: Codable {
            /// The bits per second transmitted along a digital network, in kbsp.
            public var bitrate: String?
            /// The time it took a packet to travel from one point to another, in milliseconds.
            public var latency: String?
            /// The variation in the delay of received packets, in milliseconds.
            public var jitter: String?
            /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
            public var avgLoss: String?
            /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
            public var maxLoss: String?

            public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                self.bitrate = bitrate
                self.latency = latency
                self.jitter = jitter
                self.avgLoss = avgLoss
                self.maxLoss = maxLoss
            }

            private enum CodingKeys: String, CodingKey {
                case bitrate
                case latency
                case jitter
                case avgLoss = "avg_loss"
                case maxLoss = "max_loss"
            }
        }

        /// The QoS metrics for video output being sent by a participant who joined the meeting via CRC.
        public struct VideoDeviceToCrc: Codable {
            /// The bits per second transmitted along a digital network, in kbsp.
            public var bitrate: String?
            /// The time it took a packet to travel from one point to another, in milliseconds.
            public var latency: String?
            /// The variation in the delay of received packets, in milliseconds.
            public var jitter: String?
            /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
            public var avgLoss: String?
            /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
            public var maxLoss: String?

            public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                self.bitrate = bitrate
                self.latency = latency
                self.jitter = jitter
                self.avgLoss = avgLoss
                self.maxLoss = maxLoss
            }

            private enum CodingKeys: String, CodingKey {
                case bitrate
                case latency
                case jitter
                case avgLoss = "avg_loss"
                case maxLoss = "max_loss"
            }
        }

        /// The QoS metrics for screen sharing by a participant who joined the meeting via CRC.
        public struct AsDeviceFromCrc: Codable {
            /// The bits per second transmitted along a digital network, in kbsp.
            public var bitrate: String?
            /// The time it took a packet to travel from one point to another, in milliseconds.
            public var latency: String?
            /// The variation in the delay of received packets, in milliseconds.
            public var jitter: String?
            /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
            public var avgLoss: String?
            /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
            public var maxLoss: String?

            public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                self.bitrate = bitrate
                self.latency = latency
                self.jitter = jitter
                self.avgLoss = avgLoss
                self.maxLoss = maxLoss
            }

            private enum CodingKeys: String, CodingKey {
                case bitrate
                case latency
                case jitter
                case avgLoss = "avg_loss"
                case maxLoss = "max_loss"
            }
        }

        /// The QoS metrics for screen sharing output received by a participant who joined the meeting via CRC.
        public struct AsDeviceToCrc: Codable {
            /// The bits per second transmitted along a digital network, in kbsp.
            public var bitrate: String?
            /// The time it took a packet to travel from one point to another, in milliseconds.
            public var latency: String?
            /// The variation in the delay of received packets, in milliseconds.
            public var jitter: String?
            /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
            public var avgLoss: String?
            /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
            public var maxLoss: String?

            public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                self.bitrate = bitrate
                self.latency = latency
                self.jitter = jitter
                self.avgLoss = avgLoss
                self.maxLoss = maxLoss
            }

            private enum CodingKeys: String, CodingKey {
                case bitrate
                case latency
                case jitter
                case avgLoss = "avg_loss"
                case maxLoss = "max_loss"
            }
        }

        public init(dateTime: Date? = nil, audioInput: AudioInput? = nil, audioOutput: AudioOutput? = nil, videoInput: VideoInput? = nil, videoOutput: VideoOutput? = nil, asInput: AsInput? = nil, asOutput: AsOutput? = nil, cpuUsage: CpuUsage? = nil, audioDeviceFromCrc: AudioDeviceFromCrc? = nil, audioDeviceToCrc: AudioDeviceToCrc? = nil, videoDeviceFromCrc: VideoDeviceFromCrc? = nil, videoDeviceToCrc: VideoDeviceToCrc? = nil, asDeviceFromCrc: AsDeviceFromCrc? = nil, asDeviceToCrc: AsDeviceToCrc? = nil) {
            self.dateTime = dateTime
            self.audioInput = audioInput
            self.audioOutput = audioOutput
            self.videoInput = videoInput
            self.videoOutput = videoOutput
            self.asInput = asInput
            self.asOutput = asOutput
            self.cpuUsage = cpuUsage
            self.audioDeviceFromCrc = audioDeviceFromCrc
            self.audioDeviceToCrc = audioDeviceToCrc
            self.videoDeviceFromCrc = videoDeviceFromCrc
            self.videoDeviceToCrc = videoDeviceToCrc
            self.asDeviceFromCrc = asDeviceFromCrc
            self.asDeviceToCrc = asDeviceToCrc
        }

        private enum CodingKeys: String, CodingKey {
            case dateTime = "date_time"
            case audioInput = "audio_input"
            case audioOutput = "audio_output"
            case videoInput = "video_input"
            case videoOutput = "video_output"
            case asInput = "as_input"
            case asOutput = "as_output"
            case cpuUsage = "cpu_usage"
            case audioDeviceFromCrc = "audio_device_from_crc"
            case audioDeviceToCrc = "audio_device_to_crc"
            case videoDeviceFromCrc = "video_device_from_crc"
            case videoDeviceToCrc = "video_device_to_crc"
            case asDeviceFromCrc = "as_device_from_crc"
            case asDeviceToCrc = "as_device_to_crc"
        }
    }

    public init(userID: String? = nil, userName: String? = nil, device: Device? = nil, ipAddress: String? = nil, location: String? = nil, joinTime: Date? = nil, leaveTime: Date? = nil, pcName: String? = nil, domain: String? = nil, macAddr: String? = nil, harddiskID: String? = nil, version: String? = nil, userQos: [UserQo]? = nil) {
        self.userID = userID
        self.userName = userName
        self.device = device
        self.ipAddress = ipAddress
        self.location = location
        self.joinTime = joinTime
        self.leaveTime = leaveTime
        self.pcName = pcName
        self.domain = domain
        self.macAddr = macAddr
        self.harddiskID = harddiskID
        self.version = version
        self.userQos = userQos
    }

    private enum CodingKeys: String, CodingKey {
        case userID = "user_id"
        case userName = "user_name"
        case device
        case ipAddress = "ip_address"
        case location
        case joinTime = "join_time"
        case leaveTime = "leave_time"
        case pcName = "pc_name"
        case domain
        case macAddr = "mac_addr"
        case harddiskID = "harddisk_id"
        case version
        case userQos = "user_qos"
    }
}

/// Meeting Quality Object
public struct MeetingQuality: Codable {
    /// The total number of "Good" quality scores.
    public var good: Int?
    /// The total number of "Fair" quality scores.
    public var fair: Int?
    /// The total number of "Poor" quality scores.
    public var poor: Int?
    /// The total number of "Bad" quality scores.
    public var bad: Int?

    public init(good: Int? = nil, fair: Int? = nil, poor: Int? = nil, bad: Int? = nil) {
        self.good = good
        self.fair = fair
        self.poor = poor
        self.bad = bad
    }
}

public struct ZoomRoomList: Codable {
    /// The number of pages returned for the request made.
    public var pageCount: Int?
    /// The page number of the current results.
    public var pageNumber: Int?
    /// The number of records returned with a single API call.
    public var pageSize: Int?
    /// The total number of all the records available across pages.
    public var totalRecords: Int?
    public var nextPageToken: String?
    /// Array of Zoom Rooms
    public var zoomRooms: [ZoomRoom]?

    /// Zoom room.
    public struct ZoomRoom: Codable {
        /// Zoom room ID.
        public var id: String?
        /// Zoom room name.
        public var roomName: String?
        /// Zoom calendar name.
        public var calenderName: String?
        /// Zoom room email.
        public var email: String?
        /// Zoom room email type.
        public var accountType: String?
        /// Zoom room status.
        public var status: String?
        /// Zoom room device IP.
        public var deviceIp: String?
        /// Zoom Room camera.
        /// 
        /// **Note:** This response returns an empty string (`““`) value for any users who are **not** a part of the host's account (external users).
        public var camera: String?
        /// Zoom Room microphone.
        /// 
        /// **Note:** This response returns an empty string (`““`) value for any users who are **not** a part of the host's account (external users).
        public var microphone: String?
        /// Zoom Room speaker.
        /// 
        /// **Note:** This response returns an empty string (`““`) value for any users who are **not** a part of the host's account (external users).
        public var speaker: String?
        /// Zoom room last start time.
        public var lastStartTime: String?
        /// Zoom room location.
        public var location: String?
        public var health: String?
        /// Zoom Room issues.
        public var issues: [String]?

        public init(id: String? = nil, roomName: String? = nil, calenderName: String? = nil, email: String? = nil, accountType: String? = nil, status: String? = nil, deviceIp: String? = nil, camera: String? = nil, microphone: String? = nil, speaker: String? = nil, lastStartTime: String? = nil, location: String? = nil, health: String? = nil, issues: [String]? = nil) {
            self.id = id
            self.roomName = roomName
            self.calenderName = calenderName
            self.email = email
            self.accountType = accountType
            self.status = status
            self.deviceIp = deviceIp
            self.camera = camera
            self.microphone = microphone
            self.speaker = speaker
            self.lastStartTime = lastStartTime
            self.location = location
            self.health = health
            self.issues = issues
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case roomName = "room_name"
            case calenderName = "calender_name"
            case email
            case accountType = "account_type"
            case status
            case deviceIp = "device_ip"
            case camera
            case microphone
            case speaker
            case lastStartTime = "last_start_time"
            case location
            case health
            case issues
        }
    }

    public init(pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil, zoomRooms: [ZoomRoom]? = nil) {
        self.pageCount = pageCount
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.totalRecords = totalRecords
        self.nextPageToken = nextPageToken
        self.zoomRooms = zoomRooms
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.pageCount = try values.decodeIfPresent(Int.self, forKey: "page_count")
        self.pageNumber = try values.decodeIfPresent(Int.self, forKey: "page_number")
        self.pageSize = try values.decodeIfPresent(Int.self, forKey: "page_size")
        self.totalRecords = try values.decodeIfPresent(Int.self, forKey: "total_records")
        self.nextPageToken = try values.decodeIfPresent(String.self, forKey: "next_page_token")
        self.zoomRooms = try values.decodeIfPresent([ZoomRoom].self, forKey: "zoom_rooms")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(pageCount, forKey: "page_count")
        try values.encodeIfPresent(pageNumber, forKey: "page_number")
        try values.encodeIfPresent(pageSize, forKey: "page_size")
        try values.encodeIfPresent(totalRecords, forKey: "total_records")
        try values.encodeIfPresent(nextPageToken, forKey: "next_page_token")
        try values.encodeIfPresent(zoomRooms, forKey: "zoom_rooms")
    }
}

/// Pagination object.
public struct PaginationToken4Qos: Codable {
    /// The number of pages returned for the request made.
    public var pageCount: Int?
    /// The number of items per page.
    public var pageSize: Int?
    /// The number of all records available across pages.
    public var totalRecords: Int?
    /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceed the current page size. The expiration period for this token is 15 minutes.
    public var nextPageToken: String?

    public init(pageCount: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil) {
        self.pageCount = pageCount
        self.pageSize = pageSize
        self.totalRecords = totalRecords
        self.nextPageToken = nextPageToken
    }

    private enum CodingKeys: String, CodingKey {
        case pageCount = "page_count"
        case pageSize = "page_size"
        case totalRecords = "total_records"
        case nextPageToken = "next_page_token"
    }
}

/// Audio QoS Object
public struct QOSAudio: Codable {
    /// The bits per second transmitted along a digital network, in kbsp.
    public var bitrate: String?
    /// The time it took a packet to travel from one point to another, in milliseconds.
    public var latency: String?
    /// The variation in the delay of received packets, in milliseconds.
    public var jitter: String?
    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
    public var avgLoss: String?
    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
    public var maxLoss: String?

    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
        self.bitrate = bitrate
        self.latency = latency
        self.jitter = jitter
        self.avgLoss = avgLoss
        self.maxLoss = maxLoss
    }

    private enum CodingKeys: String, CodingKey {
        case bitrate
        case latency
        case jitter
        case avgLoss = "avg_loss"
        case maxLoss = "max_loss"
    }
}

/// Meeting Metrics
///
/// Meeting metric details.
public struct MeetingMetric: Codable {
    /// Meeting UUID. Please double encode your UUID when using it for API calls if the UUID begins with a '/'or contains '//' in it.
    public var uuid: String?
    /// [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in "**long**" format(represented as int64 data type in JSON), also known as the meeting number.
    public var id: Int?
    /// Meeting topic.
    public var topic: String?
    /// Host display name.
    public var host: String?
    /// Email address of the host.
    public var email: String?
    /// License type of the user.
    public var userType: String?
    /// Meeting start time.
    public var startTime: Date?
    /// Meeting end time.
    public var endTime: Date?
    /// Meeting duration.
    public var duration: String?
    /// Meeting participant count.
    public var participants: Int?
    /// Indicates whether or not the PSTN was used in the meeting.
    public var hasPstn: Bool?
    /// Indicates whether or not VoIP was used in the meeting.
    public var hasVoip: Bool?
    /// Indicates whether or not [third party audio](https://support.zoom.us/hc/en-us/articles/202470795-3rd-Party-Audio-Conference) was used in the meeting.
    public var isHas3rdPartyAudio: Bool?
    /// Indicates whether or not video was used in the meeting.
    public var hasVideo: Bool?
    /// Indicates whether or not screenshare feature was used in the meeting.
    public var hasScreenShare: Bool?
    /// Indicates whether or not the recording feature was used in the meeting.
    public var hasRecording: Bool?
    /// Indicates whether or not someone joined the meeting using SIP.
    public var hasSip: Bool?
    /// Whether the archiving feature was used in the meeting.
    public var hasArchiving: Bool?
    /// The number of Zoom Room participants in the meeting.
    public var inRoomParticipants: Int?
    /// Department of the host.
    public var dept: String?
    /// Custom keys and values assigned to the meeting.
    public var customKeys: [CustomKey]?

    public struct CustomKey: Codable {
        /// Custom key associated with the meeting.
        public var key: String?
        /// Value of the custom key associated with the meeting.
        public var value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }
    }

    public init(uuid: String? = nil, id: Int? = nil, topic: String? = nil, host: String? = nil, email: String? = nil, userType: String? = nil, startTime: Date? = nil, endTime: Date? = nil, duration: String? = nil, participants: Int? = nil, hasPstn: Bool? = nil, hasVoip: Bool? = nil, isHas3rdPartyAudio: Bool? = nil, hasVideo: Bool? = nil, hasScreenShare: Bool? = nil, hasRecording: Bool? = nil, hasSip: Bool? = nil, hasArchiving: Bool? = nil, inRoomParticipants: Int? = nil, dept: String? = nil, customKeys: [CustomKey]? = nil) {
        self.uuid = uuid
        self.id = id
        self.topic = topic
        self.host = host
        self.email = email
        self.userType = userType
        self.startTime = startTime
        self.endTime = endTime
        self.duration = duration
        self.participants = participants
        self.hasPstn = hasPstn
        self.hasVoip = hasVoip
        self.isHas3rdPartyAudio = isHas3rdPartyAudio
        self.hasVideo = hasVideo
        self.hasScreenShare = hasScreenShare
        self.hasRecording = hasRecording
        self.hasSip = hasSip
        self.hasArchiving = hasArchiving
        self.inRoomParticipants = inRoomParticipants
        self.dept = dept
        self.customKeys = customKeys
    }

    private enum CodingKeys: String, CodingKey {
        case uuid
        case id
        case topic
        case host
        case email
        case userType = "user_type"
        case startTime = "start_time"
        case endTime = "end_time"
        case duration
        case participants
        case hasPstn = "has_pstn"
        case hasVoip = "has_voip"
        case isHas3rdPartyAudio = "has_3rd_party_audio"
        case hasVideo = "has_video"
        case hasScreenShare = "has_screen_share"
        case hasRecording = "has_recording"
        case hasSip = "has_sip"
        case hasArchiving = "has_archiving"
        case inRoomParticipants = "in_room_participants"
        case dept
        case customKeys = "custom_keys"
    }
}

/// Video QoS Object
public struct QOSVideo: Codable {
    /// The bits per second transmitted along a digital network, in kbsp.
    public var bitrate: String?
    /// The time it took a packet to travel from one point to another, in milliseconds.
    public var latency: String?
    /// The variation in the delay of received packets, in milliseconds.
    public var jitter: String?
    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
    public var avgLoss: String?
    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
    public var maxLoss: String?
    /// The number of pixels in each dimension that the video camera can display.
    public var resolution: String?
    /// The rate at which the video camera can produce unique images (frames). Zoom supports a frame rate of up to 30fps.
    public var frameRate: String?

    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil, resolution: String? = nil, frameRate: String? = nil) {
        self.bitrate = bitrate
        self.latency = latency
        self.jitter = jitter
        self.avgLoss = avgLoss
        self.maxLoss = maxLoss
        self.resolution = resolution
        self.frameRate = frameRate
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.bitrate = try values.decodeIfPresent(String.self, forKey: "bitrate")
        self.latency = try values.decodeIfPresent(String.self, forKey: "latency")
        self.jitter = try values.decodeIfPresent(String.self, forKey: "jitter")
        self.avgLoss = try values.decodeIfPresent(String.self, forKey: "avg_loss")
        self.maxLoss = try values.decodeIfPresent(String.self, forKey: "max_loss")
        self.resolution = try values.decodeIfPresent(String.self, forKey: "resolution")
        self.frameRate = try values.decodeIfPresent(String.self, forKey: "frame_rate")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(bitrate, forKey: "bitrate")
        try values.encodeIfPresent(latency, forKey: "latency")
        try values.encodeIfPresent(jitter, forKey: "jitter")
        try values.encodeIfPresent(avgLoss, forKey: "avg_loss")
        try values.encodeIfPresent(maxLoss, forKey: "max_loss")
        try values.encodeIfPresent(resolution, forKey: "resolution")
        try values.encodeIfPresent(frameRate, forKey: "frame_rate")
    }
}

/// Metrics
///
/// Meeting metric details.
public struct Listmeetingmetrics: Codable {
    /// Meeting UUID. Please double encode your UUID when using it for API calls if the UUID begins with a '/'or contains '//' in it.
    public var uuid: String?
    /// [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in "**long**" format(represented as int64 data type in JSON), also known as the meeting number.
    public var id: Int?
    /// Meeting topic.
    public var topic: String?
    /// Host display name.
    public var host: String?
    /// Email address of the host.
    public var email: String?
    /// License type of the user.
    public var userType: String?
    /// Meeting start time.
    public var startTime: Date?
    /// Meeting end time.
    public var endTime: Date?
    /// Meeting duration. Formatted as hh:mm:ss, for example: `16:08` for 16 minutes and 8 seconds.
    public var duration: String?
    /// Meeting participant count.
    public var participants: Int?
    /// Indicates whether or not the PSTN was used in the meeting.
    public var hasPstn: Bool?
    /// Indicates whether or not VoIP was used in the meeting.
    public var hasVoip: Bool?
    /// Indicates whether or not [third party audio](https://support.zoom.us/hc/en-us/articles/202470795-3rd-Party-Audio-Conference) was used in the meeting.
    public var isHas3rdPartyAudio: Bool?
    /// Indicates whether or not video was used in the meeting.
    public var hasVideo: Bool?
    /// Indicates whether or not screenshare feature was used in the meeting.
    public var hasScreenShare: Bool?
    /// Indicates whether or not the recording feature was used in the meeting.
    public var hasRecording: Bool?
    /// Indicates whether or not someone joined the meeting using SIP.
    public var hasSip: Bool?
    /// Whether the archiving feature was used in the meeting.
    public var hasArchiving: Bool?
    /// The number of Zoom Room participants in the meeting.
    public var inRoomParticipants: Int?
    /// Department of the host.
    public var dept: String?
    /// Custom keys and values assigned to the meeting.
    public var customKeys: [CustomKey]?
    /// Tracking fields and values assigned to the meeting.
    public var trackingFields: [TrackingField]?

    public struct CustomKey: Codable {
        /// Custom key associated with the meeting.
        public var key: String?
        /// Value of the custom key associated with the meeting.
        public var value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }
    }

    public struct TrackingField: Codable {
        /// Label of the tracking field.
        public var field: String?
        /// Value of the tracking field.
        public var value: String?

        public init(field: String? = nil, value: String? = nil) {
            self.field = field
            self.value = value
        }
    }

    public init(uuid: String? = nil, id: Int? = nil, topic: String? = nil, host: String? = nil, email: String? = nil, userType: String? = nil, startTime: Date? = nil, endTime: Date? = nil, duration: String? = nil, participants: Int? = nil, hasPstn: Bool? = nil, hasVoip: Bool? = nil, isHas3rdPartyAudio: Bool? = nil, hasVideo: Bool? = nil, hasScreenShare: Bool? = nil, hasRecording: Bool? = nil, hasSip: Bool? = nil, hasArchiving: Bool? = nil, inRoomParticipants: Int? = nil, dept: String? = nil, customKeys: [CustomKey]? = nil, trackingFields: [TrackingField]? = nil) {
        self.uuid = uuid
        self.id = id
        self.topic = topic
        self.host = host
        self.email = email
        self.userType = userType
        self.startTime = startTime
        self.endTime = endTime
        self.duration = duration
        self.participants = participants
        self.hasPstn = hasPstn
        self.hasVoip = hasVoip
        self.isHas3rdPartyAudio = isHas3rdPartyAudio
        self.hasVideo = hasVideo
        self.hasScreenShare = hasScreenShare
        self.hasRecording = hasRecording
        self.hasSip = hasSip
        self.hasArchiving = hasArchiving
        self.inRoomParticipants = inRoomParticipants
        self.dept = dept
        self.customKeys = customKeys
        self.trackingFields = trackingFields
    }

    private enum CodingKeys: String, CodingKey {
        case uuid
        case id
        case topic
        case host
        case email
        case userType = "user_type"
        case startTime = "start_time"
        case endTime = "end_time"
        case duration
        case participants
        case hasPstn = "has_pstn"
        case hasVoip = "has_voip"
        case isHas3rdPartyAudio = "has_3rd_party_audio"
        case hasVideo = "has_video"
        case hasScreenShare = "has_screen_share"
        case hasRecording = "has_recording"
        case hasSip = "has_sip"
        case hasArchiving = "has_archiving"
        case inRoomParticipants = "in_room_participants"
        case dept
        case customKeys = "custom_keys"
        case trackingFields = "tracking_fields"
    }
}

/// Participant QOS List
///
/// Participant QOS list.
public struct QOSParticipantList: Codable {
    /// The number of pages returned for the request made.
    public var pageCount: Int?
    /// The number of items per page.
    public var pageSize: Int?
    /// The number of all records available across pages.
    public var totalRecords: Int?
    /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceed the current page size. The expiration period for this token is 15 minutes.
    public var nextPageToken: String?
    /// Information about the participant.
    public var participants: [Participant]?

    /// Participant QOS
    ///
    /// Information about the participant and their quality of service (QoS).
    public struct Participant: Codable {
        /// The participant's ID. This value is assigned to a participant upon joining a meeting and is only valid for the meeting's duration.
        public var userID: String?
        /// The participant's display name.
        public var userName: String?
        /// The type of device the participant used to join the meeting: 
        /// * `Phone` — The participant joined via PSTN. 
        /// * `H.323/SIP` — The participant joined via an H.323 or SIP device. 
        /// * `Windows` — The participant joined via VoIP using a Windows device. 
        /// * `Mac` — The participant joined via VoIP using a Mac device. 
        /// * `iOS` — The participant joined via VoIP using an iOS device. 
        /// * `Android` — The participant joined via VoIP using an Android device. 
        /// 
        /// **Note:** This response returns an empty string (`““`) value for any users who are **not** a part of the host's account (external users).
        public var device: Device?
        /// The participant's IP address.
        public var ipAddress: String?
        /// The participant's location.
        public var location: String?
        /// The time at which the participant joined the meeting.
        public var joinTime: Date?
        /// The time at which the participant left the meeting.
        public var leaveTime: Date?
        /// The participant's PC name.
        public var pcName: String?
        /// The participant's PC domain. 
        /// 
        /// **Note:** This response returns an empty string (`““`) value for any users who are **not** a part of the host's account (external users).
        public var domain: String?
        /// The participant's MAC address. 
        /// 
        /// **Note:** This response returns an empty string (`““`) value for any users who are **not** a part of the host's account (external users).
        public var macAddr: String?
        /// The participant's hard disk ID. 
        /// 
        /// **Note:** This response returns an empty string (`““`) value for any users who are **not** a part of the host's account (external users).
        public var harddiskID: String?
        /// The participant's Zoom client version.
        public var version: String?
        /// The participant's quality of service information.
        public var userQos: [UserQo]?

        /// The type of device the participant used to join the meeting: 
        /// * `Phone` — The participant joined via PSTN. 
        /// * `H.323/SIP` — The participant joined via an H.323 or SIP device. 
        /// * `Windows` — The participant joined via VoIP using a Windows device. 
        /// * `Mac` — The participant joined via VoIP using a Mac device. 
        /// * `iOS` — The participant joined via VoIP using an iOS device. 
        /// * `Android` — The participant joined via VoIP using an Android device. 
        /// 
        /// **Note:** This response returns an empty string (`““`) value for any users who are **not** a part of the host's account (external users).
        public enum Device: String, Codable, CaseIterable {
            case phone = "Phone"
            case h323Sip = "H.323/SIP"
            case windows = "Windows"
            case mac = "Mac"
            case iOS
            case android = "Android"
        }

        public struct UserQo: Codable {
            /// The QoS date and time.
            public var dateTime: Date?
            /// Audio QoS Object
            public var audioInput: AudioInput?
            /// Audio QoS Object
            public var audioOutput: AudioOutput?
            /// Video QoS Object
            public var videoInput: VideoInput?
            /// Video QoS Object
            public var videoOutput: VideoOutput?
            /// Video QoS Object
            public var asInput: AsInput?
            /// Video QoS Object
            public var asOutput: AsOutput?
            public var cpuUsage: CpuUsage?
            /// The QoS metrics for audio sent by a participant who joined the meeting via a Cloud Room Connector (CRC).
            public var audioDeviceFromCrc: AudioDeviceFromCrc?
            /// The QoS metrics for audio received by a participant who joined the meeting via CRC.
            public var audioDeviceToCrc: AudioDeviceToCrc?
            /// The QoS metrics for video input being sent by a participant who joined the meeting via CRC.
            public var videoDeviceFromCrc: VideoDeviceFromCrc?
            /// The QoS metrics for video output being sent by a participant who joined the meeting via CRC.
            public var videoDeviceToCrc: VideoDeviceToCrc?
            /// The QoS metrics for screen sharing by a participant who joined the meeting via CRC.
            public var asDeviceFromCrc: AsDeviceFromCrc?
            /// The QoS metrics for screen sharing output received by a participant who joined the meeting via CRC.
            public var asDeviceToCrc: AsDeviceToCrc?

            /// Audio QoS Object
            public struct AudioInput: Codable {
                /// The bits per second transmitted along a digital network, in kbsp.
                public var bitrate: String?
                /// The time it took a packet to travel from one point to another, in milliseconds.
                public var latency: String?
                /// The variation in the delay of received packets, in milliseconds.
                public var jitter: String?
                /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                public var avgLoss: String?
                /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                public var maxLoss: String?

                public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                    self.bitrate = bitrate
                    self.latency = latency
                    self.jitter = jitter
                    self.avgLoss = avgLoss
                    self.maxLoss = maxLoss
                }

                private enum CodingKeys: String, CodingKey {
                    case bitrate
                    case latency
                    case jitter
                    case avgLoss = "avg_loss"
                    case maxLoss = "max_loss"
                }
            }

            /// Audio QoS Object
            public struct AudioOutput: Codable {
                /// The bits per second transmitted along a digital network, in kbsp.
                public var bitrate: String?
                /// The time it took a packet to travel from one point to another, in milliseconds.
                public var latency: String?
                /// The variation in the delay of received packets, in milliseconds.
                public var jitter: String?
                /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                public var avgLoss: String?
                /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                public var maxLoss: String?

                public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                    self.bitrate = bitrate
                    self.latency = latency
                    self.jitter = jitter
                    self.avgLoss = avgLoss
                    self.maxLoss = maxLoss
                }

                private enum CodingKeys: String, CodingKey {
                    case bitrate
                    case latency
                    case jitter
                    case avgLoss = "avg_loss"
                    case maxLoss = "max_loss"
                }
            }

            /// Video QoS Object
            public struct VideoInput: Codable {
                /// The bits per second transmitted along a digital network, in kbsp.
                public var bitrate: String?
                /// The time it took a packet to travel from one point to another, in milliseconds.
                public var latency: String?
                /// The variation in the delay of received packets, in milliseconds.
                public var jitter: String?
                /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                public var avgLoss: String?
                /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                public var maxLoss: String?
                /// The number of pixels in each dimension that the video camera can display.
                public var resolution: String?
                /// The rate at which the video camera can produce unique images (frames). Zoom supports a frame rate of up to 30fps.
                public var frameRate: String?

                public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil, resolution: String? = nil, frameRate: String? = nil) {
                    self.bitrate = bitrate
                    self.latency = latency
                    self.jitter = jitter
                    self.avgLoss = avgLoss
                    self.maxLoss = maxLoss
                    self.resolution = resolution
                    self.frameRate = frameRate
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.bitrate = try values.decodeIfPresent(String.self, forKey: "bitrate")
                    self.latency = try values.decodeIfPresent(String.self, forKey: "latency")
                    self.jitter = try values.decodeIfPresent(String.self, forKey: "jitter")
                    self.avgLoss = try values.decodeIfPresent(String.self, forKey: "avg_loss")
                    self.maxLoss = try values.decodeIfPresent(String.self, forKey: "max_loss")
                    self.resolution = try values.decodeIfPresent(String.self, forKey: "resolution")
                    self.frameRate = try values.decodeIfPresent(String.self, forKey: "frame_rate")
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(bitrate, forKey: "bitrate")
                    try values.encodeIfPresent(latency, forKey: "latency")
                    try values.encodeIfPresent(jitter, forKey: "jitter")
                    try values.encodeIfPresent(avgLoss, forKey: "avg_loss")
                    try values.encodeIfPresent(maxLoss, forKey: "max_loss")
                    try values.encodeIfPresent(resolution, forKey: "resolution")
                    try values.encodeIfPresent(frameRate, forKey: "frame_rate")
                }
            }

            /// Video QoS Object
            public struct VideoOutput: Codable {
                /// The bits per second transmitted along a digital network, in kbsp.
                public var bitrate: String?
                /// The time it took a packet to travel from one point to another, in milliseconds.
                public var latency: String?
                /// The variation in the delay of received packets, in milliseconds.
                public var jitter: String?
                /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                public var avgLoss: String?
                /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                public var maxLoss: String?
                /// The number of pixels in each dimension that the video camera can display.
                public var resolution: String?
                /// The rate at which the video camera can produce unique images (frames). Zoom supports a frame rate of up to 30fps.
                public var frameRate: String?

                public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil, resolution: String? = nil, frameRate: String? = nil) {
                    self.bitrate = bitrate
                    self.latency = latency
                    self.jitter = jitter
                    self.avgLoss = avgLoss
                    self.maxLoss = maxLoss
                    self.resolution = resolution
                    self.frameRate = frameRate
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.bitrate = try values.decodeIfPresent(String.self, forKey: "bitrate")
                    self.latency = try values.decodeIfPresent(String.self, forKey: "latency")
                    self.jitter = try values.decodeIfPresent(String.self, forKey: "jitter")
                    self.avgLoss = try values.decodeIfPresent(String.self, forKey: "avg_loss")
                    self.maxLoss = try values.decodeIfPresent(String.self, forKey: "max_loss")
                    self.resolution = try values.decodeIfPresent(String.self, forKey: "resolution")
                    self.frameRate = try values.decodeIfPresent(String.self, forKey: "frame_rate")
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(bitrate, forKey: "bitrate")
                    try values.encodeIfPresent(latency, forKey: "latency")
                    try values.encodeIfPresent(jitter, forKey: "jitter")
                    try values.encodeIfPresent(avgLoss, forKey: "avg_loss")
                    try values.encodeIfPresent(maxLoss, forKey: "max_loss")
                    try values.encodeIfPresent(resolution, forKey: "resolution")
                    try values.encodeIfPresent(frameRate, forKey: "frame_rate")
                }
            }

            /// Video QoS Object
            public struct AsInput: Codable {
                /// The bits per second transmitted along a digital network, in kbsp.
                public var bitrate: String?
                /// The time it took a packet to travel from one point to another, in milliseconds.
                public var latency: String?
                /// The variation in the delay of received packets, in milliseconds.
                public var jitter: String?
                /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                public var avgLoss: String?
                /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                public var maxLoss: String?
                /// The number of pixels in each dimension that the video camera can display.
                public var resolution: String?
                /// The rate at which the video camera can produce unique images (frames). Zoom supports a frame rate of up to 30fps.
                public var frameRate: String?

                public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil, resolution: String? = nil, frameRate: String? = nil) {
                    self.bitrate = bitrate
                    self.latency = latency
                    self.jitter = jitter
                    self.avgLoss = avgLoss
                    self.maxLoss = maxLoss
                    self.resolution = resolution
                    self.frameRate = frameRate
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.bitrate = try values.decodeIfPresent(String.self, forKey: "bitrate")
                    self.latency = try values.decodeIfPresent(String.self, forKey: "latency")
                    self.jitter = try values.decodeIfPresent(String.self, forKey: "jitter")
                    self.avgLoss = try values.decodeIfPresent(String.self, forKey: "avg_loss")
                    self.maxLoss = try values.decodeIfPresent(String.self, forKey: "max_loss")
                    self.resolution = try values.decodeIfPresent(String.self, forKey: "resolution")
                    self.frameRate = try values.decodeIfPresent(String.self, forKey: "frame_rate")
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(bitrate, forKey: "bitrate")
                    try values.encodeIfPresent(latency, forKey: "latency")
                    try values.encodeIfPresent(jitter, forKey: "jitter")
                    try values.encodeIfPresent(avgLoss, forKey: "avg_loss")
                    try values.encodeIfPresent(maxLoss, forKey: "max_loss")
                    try values.encodeIfPresent(resolution, forKey: "resolution")
                    try values.encodeIfPresent(frameRate, forKey: "frame_rate")
                }
            }

            /// Video QoS Object
            public struct AsOutput: Codable {
                /// The bits per second transmitted along a digital network, in kbsp.
                public var bitrate: String?
                /// The time it took a packet to travel from one point to another, in milliseconds.
                public var latency: String?
                /// The variation in the delay of received packets, in milliseconds.
                public var jitter: String?
                /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                public var avgLoss: String?
                /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                public var maxLoss: String?
                /// The number of pixels in each dimension that the video camera can display.
                public var resolution: String?
                /// The rate at which the video camera can produce unique images (frames). Zoom supports a frame rate of up to 30fps.
                public var frameRate: String?

                public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil, resolution: String? = nil, frameRate: String? = nil) {
                    self.bitrate = bitrate
                    self.latency = latency
                    self.jitter = jitter
                    self.avgLoss = avgLoss
                    self.maxLoss = maxLoss
                    self.resolution = resolution
                    self.frameRate = frameRate
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.bitrate = try values.decodeIfPresent(String.self, forKey: "bitrate")
                    self.latency = try values.decodeIfPresent(String.self, forKey: "latency")
                    self.jitter = try values.decodeIfPresent(String.self, forKey: "jitter")
                    self.avgLoss = try values.decodeIfPresent(String.self, forKey: "avg_loss")
                    self.maxLoss = try values.decodeIfPresent(String.self, forKey: "max_loss")
                    self.resolution = try values.decodeIfPresent(String.self, forKey: "resolution")
                    self.frameRate = try values.decodeIfPresent(String.self, forKey: "frame_rate")
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(bitrate, forKey: "bitrate")
                    try values.encodeIfPresent(latency, forKey: "latency")
                    try values.encodeIfPresent(jitter, forKey: "jitter")
                    try values.encodeIfPresent(avgLoss, forKey: "avg_loss")
                    try values.encodeIfPresent(maxLoss, forKey: "max_loss")
                    try values.encodeIfPresent(resolution, forKey: "resolution")
                    try values.encodeIfPresent(frameRate, forKey: "frame_rate")
                }
            }

            public struct CpuUsage: Codable {
                /// Zoom's minimum CPU usage.
                public var zoomMinCpuUsage: String?
                /// Zoom's average CPU usage.
                public var zoomAvgCpuUsage: String?
                /// Zoom's maximum CPU usage.
                public var zoomMaxCpuUsage: String?
                /// The system's maximum CPU usage.
                public var systemMaxCpuUsage: String?

                public init(zoomMinCpuUsage: String? = nil, zoomAvgCpuUsage: String? = nil, zoomMaxCpuUsage: String? = nil, systemMaxCpuUsage: String? = nil) {
                    self.zoomMinCpuUsage = zoomMinCpuUsage
                    self.zoomAvgCpuUsage = zoomAvgCpuUsage
                    self.zoomMaxCpuUsage = zoomMaxCpuUsage
                    self.systemMaxCpuUsage = systemMaxCpuUsage
                }

                private enum CodingKeys: String, CodingKey {
                    case zoomMinCpuUsage = "zoom_min_cpu_usage"
                    case zoomAvgCpuUsage = "zoom_avg_cpu_usage"
                    case zoomMaxCpuUsage = "zoom_max_cpu_usage"
                    case systemMaxCpuUsage = "system_max_cpu_usage"
                }
            }

            /// The QoS metrics for audio sent by a participant who joined the meeting via a Cloud Room Connector (CRC).
            public struct AudioDeviceFromCrc: Codable {
                /// The bits per second transmitted along a digital network, in kbsp.
                public var bitrate: String?
                /// The time it took a packet to travel from one point to another, in milliseconds.
                public var latency: String?
                /// The variation in the delay of received packets, in milliseconds.
                public var jitter: String?
                /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                public var avgLoss: String?
                /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                public var maxLoss: String?

                public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                    self.bitrate = bitrate
                    self.latency = latency
                    self.jitter = jitter
                    self.avgLoss = avgLoss
                    self.maxLoss = maxLoss
                }

                private enum CodingKeys: String, CodingKey {
                    case bitrate
                    case latency
                    case jitter
                    case avgLoss = "avg_loss"
                    case maxLoss = "max_loss"
                }
            }

            /// The QoS metrics for audio received by a participant who joined the meeting via CRC.
            public struct AudioDeviceToCrc: Codable {
                /// The bits per second transmitted along a digital network, in kbsp.
                public var bitrate: String?
                /// The time it took a packet to travel from one point to another, in milliseconds.
                public var latency: String?
                /// The variation in the delay of received packets, in milliseconds.
                public var jitter: String?
                /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                public var avgLoss: String?
                /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                public var maxLoss: String?

                public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                    self.bitrate = bitrate
                    self.latency = latency
                    self.jitter = jitter
                    self.avgLoss = avgLoss
                    self.maxLoss = maxLoss
                }

                private enum CodingKeys: String, CodingKey {
                    case bitrate
                    case latency
                    case jitter
                    case avgLoss = "avg_loss"
                    case maxLoss = "max_loss"
                }
            }

            /// The QoS metrics for video input being sent by a participant who joined the meeting via CRC.
            public struct VideoDeviceFromCrc: Codable {
                /// The bits per second transmitted along a digital network, in kbsp.
                public var bitrate: String?
                /// The time it took a packet to travel from one point to another, in milliseconds.
                public var latency: String?
                /// The variation in the delay of received packets, in milliseconds.
                public var jitter: String?
                /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                public var avgLoss: String?
                /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                public var maxLoss: String?

                public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                    self.bitrate = bitrate
                    self.latency = latency
                    self.jitter = jitter
                    self.avgLoss = avgLoss
                    self.maxLoss = maxLoss
                }

                private enum CodingKeys: String, CodingKey {
                    case bitrate
                    case latency
                    case jitter
                    case avgLoss = "avg_loss"
                    case maxLoss = "max_loss"
                }
            }

            /// The QoS metrics for video output being sent by a participant who joined the meeting via CRC.
            public struct VideoDeviceToCrc: Codable {
                /// The bits per second transmitted along a digital network, in kbsp.
                public var bitrate: String?
                /// The time it took a packet to travel from one point to another, in milliseconds.
                public var latency: String?
                /// The variation in the delay of received packets, in milliseconds.
                public var jitter: String?
                /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                public var avgLoss: String?
                /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                public var maxLoss: String?

                public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                    self.bitrate = bitrate
                    self.latency = latency
                    self.jitter = jitter
                    self.avgLoss = avgLoss
                    self.maxLoss = maxLoss
                }

                private enum CodingKeys: String, CodingKey {
                    case bitrate
                    case latency
                    case jitter
                    case avgLoss = "avg_loss"
                    case maxLoss = "max_loss"
                }
            }

            /// The QoS metrics for screen sharing by a participant who joined the meeting via CRC.
            public struct AsDeviceFromCrc: Codable {
                /// The bits per second transmitted along a digital network, in kbsp.
                public var bitrate: String?
                /// The time it took a packet to travel from one point to another, in milliseconds.
                public var latency: String?
                /// The variation in the delay of received packets, in milliseconds.
                public var jitter: String?
                /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                public var avgLoss: String?
                /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                public var maxLoss: String?

                public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                    self.bitrate = bitrate
                    self.latency = latency
                    self.jitter = jitter
                    self.avgLoss = avgLoss
                    self.maxLoss = maxLoss
                }

                private enum CodingKeys: String, CodingKey {
                    case bitrate
                    case latency
                    case jitter
                    case avgLoss = "avg_loss"
                    case maxLoss = "max_loss"
                }
            }

            /// The QoS metrics for screen sharing output received by a participant who joined the meeting via CRC.
            public struct AsDeviceToCrc: Codable {
                /// The bits per second transmitted along a digital network, in kbsp.
                public var bitrate: String?
                /// The time it took a packet to travel from one point to another, in milliseconds.
                public var latency: String?
                /// The variation in the delay of received packets, in milliseconds.
                public var jitter: String?
                /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                public var avgLoss: String?
                /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                public var maxLoss: String?

                public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                    self.bitrate = bitrate
                    self.latency = latency
                    self.jitter = jitter
                    self.avgLoss = avgLoss
                    self.maxLoss = maxLoss
                }

                private enum CodingKeys: String, CodingKey {
                    case bitrate
                    case latency
                    case jitter
                    case avgLoss = "avg_loss"
                    case maxLoss = "max_loss"
                }
            }

            public init(dateTime: Date? = nil, audioInput: AudioInput? = nil, audioOutput: AudioOutput? = nil, videoInput: VideoInput? = nil, videoOutput: VideoOutput? = nil, asInput: AsInput? = nil, asOutput: AsOutput? = nil, cpuUsage: CpuUsage? = nil, audioDeviceFromCrc: AudioDeviceFromCrc? = nil, audioDeviceToCrc: AudioDeviceToCrc? = nil, videoDeviceFromCrc: VideoDeviceFromCrc? = nil, videoDeviceToCrc: VideoDeviceToCrc? = nil, asDeviceFromCrc: AsDeviceFromCrc? = nil, asDeviceToCrc: AsDeviceToCrc? = nil) {
                self.dateTime = dateTime
                self.audioInput = audioInput
                self.audioOutput = audioOutput
                self.videoInput = videoInput
                self.videoOutput = videoOutput
                self.asInput = asInput
                self.asOutput = asOutput
                self.cpuUsage = cpuUsage
                self.audioDeviceFromCrc = audioDeviceFromCrc
                self.audioDeviceToCrc = audioDeviceToCrc
                self.videoDeviceFromCrc = videoDeviceFromCrc
                self.videoDeviceToCrc = videoDeviceToCrc
                self.asDeviceFromCrc = asDeviceFromCrc
                self.asDeviceToCrc = asDeviceToCrc
            }

            private enum CodingKeys: String, CodingKey {
                case dateTime = "date_time"
                case audioInput = "audio_input"
                case audioOutput = "audio_output"
                case videoInput = "video_input"
                case videoOutput = "video_output"
                case asInput = "as_input"
                case asOutput = "as_output"
                case cpuUsage = "cpu_usage"
                case audioDeviceFromCrc = "audio_device_from_crc"
                case audioDeviceToCrc = "audio_device_to_crc"
                case videoDeviceFromCrc = "video_device_from_crc"
                case videoDeviceToCrc = "video_device_to_crc"
                case asDeviceFromCrc = "as_device_from_crc"
                case asDeviceToCrc = "as_device_to_crc"
            }
        }

        public init(userID: String? = nil, userName: String? = nil, device: Device? = nil, ipAddress: String? = nil, location: String? = nil, joinTime: Date? = nil, leaveTime: Date? = nil, pcName: String? = nil, domain: String? = nil, macAddr: String? = nil, harddiskID: String? = nil, version: String? = nil, userQos: [UserQo]? = nil) {
            self.userID = userID
            self.userName = userName
            self.device = device
            self.ipAddress = ipAddress
            self.location = location
            self.joinTime = joinTime
            self.leaveTime = leaveTime
            self.pcName = pcName
            self.domain = domain
            self.macAddr = macAddr
            self.harddiskID = harddiskID
            self.version = version
            self.userQos = userQos
        }

        private enum CodingKeys: String, CodingKey {
            case userID = "user_id"
            case userName = "user_name"
            case device
            case ipAddress = "ip_address"
            case location
            case joinTime = "join_time"
            case leaveTime = "leave_time"
            case pcName = "pc_name"
            case domain
            case macAddr = "mac_addr"
            case harddiskID = "harddisk_id"
            case version
            case userQos = "user_qos"
        }
    }

    public init(pageCount: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil, participants: [Participant]? = nil) {
        self.pageCount = pageCount
        self.pageSize = pageSize
        self.totalRecords = totalRecords
        self.nextPageToken = nextPageToken
        self.participants = participants
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.pageCount = try values.decodeIfPresent(Int.self, forKey: "page_count")
        self.pageSize = try values.decodeIfPresent(Int.self, forKey: "page_size")
        self.totalRecords = try values.decodeIfPresent(Int.self, forKey: "total_records")
        self.nextPageToken = try values.decodeIfPresent(String.self, forKey: "next_page_token")
        self.participants = try values.decodeIfPresent([Participant].self, forKey: "participants")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(pageCount, forKey: "page_count")
        try values.encodeIfPresent(pageSize, forKey: "page_size")
        try values.encodeIfPresent(totalRecords, forKey: "total_records")
        try values.encodeIfPresent(nextPageToken, forKey: "next_page_token")
        try values.encodeIfPresent(participants, forKey: "participants")
    }
}

/// Webinar Metrics
///
/// Webinar metric details.
public struct WebinarMetric: Codable {
    /// Webinar UUID.
    public var uuid: String?
    /// Webinar ID in "**long**" format(represented as int64 data type in JSON), also known as the webinar number.
    public var id: Int?
    /// Webinar topic.
    public var topic: String?
    /// User display name.
    public var host: String?
    /// User email.
    public var email: String?
    /// User type.
    public var userType: String?
    /// Webinar start time.
    public var startTime: Date?
    /// Webinar end time.
    public var endTime: Date?
    /// Webinar duration, formatted as hh:mm:ss, for example: `10:00` for ten minutes.
    public var duration: String?
    /// Webinar participant count.
    public var participants: Int?
    /// Indicates whether or not PSTN was used for the Webinar.
    public var hasPstn: Bool?
    /// Indicates whether or not VoIP was used for the Webinar.
    public var hasVoip: Bool?
    /// Indicates whether or not TSP was used for the Webinar.
    public var isHas3rdPartyAudio: Bool?
    /// Indicates whether or not video was used for the Webinar.
    public var hasVideo: Bool?
    /// Indicates whether or not screen sharing was used for the Webinar.
    public var hasScreenShare: Bool?
    /// Indicates whether or not recording was used for the Webinar.
    public var hasRecording: Bool?
    /// Indicates whether or not SIP was used for the Webinar.
    public var hasSip: Bool?
    /// Whether the archiving feature was used in the webinar.
    public var hasArchiving: Bool?
    /// Department of the host.
    public var dept: String?
    /// Custom keys and values assigned to the Webinar.
    public var customKeys: [CustomKey]?

    public struct CustomKey: Codable {
        /// Custom key associated with the Webinar.
        public var key: String?
        /// Value of the custom key associated with the Webinar.
        public var value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }
    }

    public init(uuid: String? = nil, id: Int? = nil, topic: String? = nil, host: String? = nil, email: String? = nil, userType: String? = nil, startTime: Date? = nil, endTime: Date? = nil, duration: String? = nil, participants: Int? = nil, hasPstn: Bool? = nil, hasVoip: Bool? = nil, isHas3rdPartyAudio: Bool? = nil, hasVideo: Bool? = nil, hasScreenShare: Bool? = nil, hasRecording: Bool? = nil, hasSip: Bool? = nil, hasArchiving: Bool? = nil, dept: String? = nil, customKeys: [CustomKey]? = nil) {
        self.uuid = uuid
        self.id = id
        self.topic = topic
        self.host = host
        self.email = email
        self.userType = userType
        self.startTime = startTime
        self.endTime = endTime
        self.duration = duration
        self.participants = participants
        self.hasPstn = hasPstn
        self.hasVoip = hasVoip
        self.isHas3rdPartyAudio = isHas3rdPartyAudio
        self.hasVideo = hasVideo
        self.hasScreenShare = hasScreenShare
        self.hasRecording = hasRecording
        self.hasSip = hasSip
        self.hasArchiving = hasArchiving
        self.dept = dept
        self.customKeys = customKeys
    }

    private enum CodingKeys: String, CodingKey {
        case uuid
        case id
        case topic
        case host
        case email
        case userType = "user_type"
        case startTime = "start_time"
        case endTime = "end_time"
        case duration
        case participants
        case hasPstn = "has_pstn"
        case hasVoip = "has_voip"
        case isHas3rdPartyAudio = "has_3rd_party_audio"
        case hasVideo = "has_video"
        case hasScreenShare = "has_screen_share"
        case hasRecording = "has_recording"
        case hasSip = "has_sip"
        case hasArchiving = "has_archiving"
        case dept
        case customKeys = "custom_keys"
    }
}

/// Group object.
public struct Group: Codable {
    /// Group name.
    public var name: String?
    /// Total number of members in this group.
    public var totalMembers: Int?

    public init(name: String? = nil, totalMembers: Int? = nil) {
        self.name = name
        self.totalMembers = totalMembers
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case totalMembers = "total_members"
    }
}

/// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
public struct Recurrence: Codable {
    /// Recurrence meeting types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
    public var type: Int
    /// Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
    /// 
    /// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
    public var repeatInterval: Int?
    /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
    /// 
    ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
    public var weeklyDays: WeeklyDays?
    /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
    /// 
    /// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
    public var monthlyDay: Int?
    /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
    public var monthlyWeek: Int?
    /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field. 
    /// 
    /// <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
    public var monthlyWeekDay: Int?
    /// Select how many times the meeting should recur before it is canceled. (Cannot be used with "end_date_time".)
    public var endTimes: Int?
    /// Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
    public var endDateTime: Date?

    /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
    /// 
    ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
    public enum WeeklyDays: String, Codable, CaseIterable {
        case _1 = "1"
        case _2 = "2"
        case _3 = "3"
        case _4 = "4"
        case _5 = "5"
        case _6 = "6"
        case _7 = "7"
    }

    public init(type: Int, repeatInterval: Int? = nil, weeklyDays: WeeklyDays? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
        self.type = type
        self.repeatInterval = repeatInterval
        self.weeklyDays = weeklyDays
        self.monthlyDay = monthlyDay
        self.monthlyWeek = monthlyWeek
        self.monthlyWeekDay = monthlyWeekDay
        self.endTimes = endTimes
        self.endDateTime = endDateTime
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case repeatInterval = "repeat_interval"
        case weeklyDays = "weekly_days"
        case monthlyDay = "monthly_day"
        case monthlyWeek = "monthly_week"
        case monthlyWeekDay = "monthly_week_day"
        case endTimes = "end_times"
        case endDateTime = "end_date_time"
    }
}

/// Registration List
///
/// List of users.
public struct RegistrantList: Codable {
    /// The number of pages returned for the request made.
    public var pageCount: Int?
    /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
    public var pageNumber: Int?
    /// The number of records returned with a single API call.
    public var pageSize: Int?
    /// The total number of all the records available across pages.
    public var totalRecords: Int?
    /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
    public var nextPageToken: String?
    /// List of registrant objects.
    public var registrants: [Registrant]?

    public struct Registrant: Codable {
        /// Registrant ID.
        public var id: String?
        /// Registrant.
        public var b: B
        /// The status of the registrant's registration. <br> `approved`: User has been successfully approved for the webinar.<br> `pending`:  The registration is still pending.<br> `denied`: User has been denied from joining the webinar.
        public var status: String?
        /// The time at which the registrant registered.
        public var createTime: Date?
        /// The URL using which an approved registrant can join the webinar.
        public var joinURL: String?

        /// Registrant.
        public struct B: Codable {
            /// The registrant's email address.
            public var email: String
            /// The registrant's status: 
            /// * `approved` — Registrant is approved. 
            /// * `denied` — Registrant is denied. 
            /// * `pending` — Registrant is waiting for approval.
            public var status: Status?
            /// The registrant's first name.
            public var firstName: String
            /// The registrant's last name.
            public var lastName: String?
            /// The registrant's address.
            public var address: String?
            /// The registrant's city.
            public var city: String?
            /// The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
            public var country: String?
            /// The registrant's ZIP or postal code.
            public var zip: String?
            /// The registrant's state or province.
            public var state: String?
            /// The registrant's phone number.
            public var phone: String?
            /// The registrant's industry.
            public var industry: String?
            /// The registrant's organization.
            public var org: String?
            /// The registrant's job title.
            public var jobTitle: String?
            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public var purchasingTimeFrame: PurchasingTimeFrame?
            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public var roleInPurchaseProcess: RoleInPurchaseProcess?
            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public var noOfEmployees: NoOfEmployees?
            /// The registrant's questions and comments.
            public var comments: String?
            /// Information about custom questions.
            public var customQuestions: [CustomQuestion]?

            /// The registrant's status: 
            /// * `approved` — Registrant is approved. 
            /// * `denied` — Registrant is denied. 
            /// * `pending` — Registrant is waiting for approval.
            public enum Status: String, Codable, CaseIterable {
                case approved
                case denied
                case pending
            }

            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public enum PurchasingTimeFrame: String, Codable, CaseIterable {
                case empty = ""
                case withinAMonth = "Within a month"
                case _13Months = "1-3 months"
                case _46Months = "4-6 months"
                case moreThan6Months = "More than 6 months"
                case noTimeframe = "No timeframe"
            }

            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public enum RoleInPurchaseProcess: String, Codable, CaseIterable {
                case empty = ""
                case decisionMaker = "Decision Maker"
                case evaluatorRecommender = "Evaluator/Recommender"
                case influencer = "Influencer"
                case notInvolved = "Not involved"
            }

            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public enum NoOfEmployees: String, Codable, CaseIterable {
                case empty = ""
                case _120 = "1-20"
                case _2150 = "21-50"
                case _51100 = "51-100"
                case _101500 = "101-500"
                case _5001000 = "500-1,000"
                case _10015000 = "1,001-5,000"
                case _500110000 = "5,001-10,000"
                case moreThan10000 = "More than 10,000"
            }

            /// Information about custom questions.
            public struct CustomQuestion: Codable {
                /// The title of the custom question.
                public var title: String?
                /// The custom question's response value. This has a limit of 128 characters.
                public var value: String?

                public init(title: String? = nil, value: String? = nil) {
                    self.title = title
                    self.value = value
                }
            }

            public init(email: String, status: Status? = nil, firstName: String, lastName: String? = nil, address: String? = nil, city: String? = nil, country: String? = nil, zip: String? = nil, state: String? = nil, phone: String? = nil, industry: String? = nil, org: String? = nil, jobTitle: String? = nil, purchasingTimeFrame: PurchasingTimeFrame? = nil, roleInPurchaseProcess: RoleInPurchaseProcess? = nil, noOfEmployees: NoOfEmployees? = nil, comments: String? = nil, customQuestions: [CustomQuestion]? = nil) {
                self.email = email
                self.status = status
                self.firstName = firstName
                self.lastName = lastName
                self.address = address
                self.city = city
                self.country = country
                self.zip = zip
                self.state = state
                self.phone = phone
                self.industry = industry
                self.org = org
                self.jobTitle = jobTitle
                self.purchasingTimeFrame = purchasingTimeFrame
                self.roleInPurchaseProcess = roleInPurchaseProcess
                self.noOfEmployees = noOfEmployees
                self.comments = comments
                self.customQuestions = customQuestions
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.email = try values.decode(String.self, forKey: "email")
                self.status = try Status(from: decoder)
                self.firstName = try values.decode(String.self, forKey: "first_name")
                self.lastName = try values.decodeIfPresent(String.self, forKey: "last_name")
                self.address = try values.decodeIfPresent(String.self, forKey: "address")
                self.city = try values.decodeIfPresent(String.self, forKey: "city")
                self.country = try values.decodeIfPresent(String.self, forKey: "country")
                self.zip = try values.decodeIfPresent(String.self, forKey: "zip")
                self.state = try values.decodeIfPresent(String.self, forKey: "state")
                self.phone = try values.decodeIfPresent(String.self, forKey: "phone")
                self.industry = try values.decodeIfPresent(String.self, forKey: "industry")
                self.org = try values.decodeIfPresent(String.self, forKey: "org")
                self.jobTitle = try values.decodeIfPresent(String.self, forKey: "job_title")
                self.purchasingTimeFrame = try PurchasingTimeFrame(from: decoder)
                self.roleInPurchaseProcess = try RoleInPurchaseProcess(from: decoder)
                self.noOfEmployees = try NoOfEmployees(from: decoder)
                self.comments = try values.decodeIfPresent(String.self, forKey: "comments")
                self.customQuestions = try values.decodeIfPresent([CustomQuestion].self, forKey: "custom_questions")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(email, forKey: "email")
                try values.encodeIfPresent(status, forKey: "status")
                try values.encode(firstName, forKey: "first_name")
                try values.encodeIfPresent(lastName, forKey: "last_name")
                try values.encodeIfPresent(address, forKey: "address")
                try values.encodeIfPresent(city, forKey: "city")
                try values.encodeIfPresent(country, forKey: "country")
                try values.encodeIfPresent(zip, forKey: "zip")
                try values.encodeIfPresent(state, forKey: "state")
                try values.encodeIfPresent(phone, forKey: "phone")
                try values.encodeIfPresent(industry, forKey: "industry")
                try values.encodeIfPresent(org, forKey: "org")
                try values.encodeIfPresent(jobTitle, forKey: "job_title")
                try values.encodeIfPresent(purchasingTimeFrame, forKey: "purchasing_time_frame")
                try values.encodeIfPresent(roleInPurchaseProcess, forKey: "role_in_purchase_process")
                try values.encodeIfPresent(noOfEmployees, forKey: "no_of_employees")
                try values.encodeIfPresent(comments, forKey: "comments")
                try values.encodeIfPresent(customQuestions, forKey: "custom_questions")
            }
        }

        public init(id: String? = nil, b: B, status: String? = nil, createTime: Date? = nil, joinURL: String? = nil) {
            self.id = id
            self.b = b
            self.status = status
            self.createTime = createTime
            self.joinURL = joinURL
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.b = try B(from: decoder)
            self.status = try values.decodeIfPresent(String.self, forKey: "status")
            self.createTime = try values.decodeIfPresent(Date.self, forKey: "create_time")
            self.joinURL = try values.decodeIfPresent(String.self, forKey: "join_url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encode(b, forKey: "b")
            try values.encodeIfPresent(status, forKey: "status")
            try values.encodeIfPresent(createTime, forKey: "create_time")
            try values.encodeIfPresent(joinURL, forKey: "join_url")
        }
    }

    public init(pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil, registrants: [Registrant]? = nil) {
        self.pageCount = pageCount
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.totalRecords = totalRecords
        self.nextPageToken = nextPageToken
        self.registrants = registrants
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.pageCount = try values.decodeIfPresent(Int.self, forKey: "page_count")
        self.pageNumber = try values.decodeIfPresent(Int.self, forKey: "page_number")
        self.pageSize = try values.decodeIfPresent(Int.self, forKey: "page_size")
        self.totalRecords = try values.decodeIfPresent(Int.self, forKey: "total_records")
        self.nextPageToken = try values.decodeIfPresent(String.self, forKey: "next_page_token")
        self.registrants = try values.decodeIfPresent([Registrant].self, forKey: "registrants")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(pageCount, forKey: "page_count")
        try values.encodeIfPresent(pageNumber, forKey: "page_number")
        try values.encodeIfPresent(pageSize, forKey: "page_size")
        try values.encodeIfPresent(totalRecords, forKey: "total_records")
        try values.encodeIfPresent(nextPageToken, forKey: "next_page_token")
        try values.encodeIfPresent(registrants, forKey: "registrants")
    }
}

/// Occurrence object. This object is only returned for Recurring Webinars.
public struct OccurrencesItem: Codable {
    /// Occurrence ID: Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences.
    public var occurrenceID: String?
    /// Start time.
    public var startTime: Date?
    /// Duration.
    public var duration: Int?
    /// Occurrence status.
    public var status: String?

    public init(occurrenceID: String? = nil, startTime: Date? = nil, duration: Int? = nil, status: String? = nil) {
        self.occurrenceID = occurrenceID
        self.startTime = startTime
        self.duration = duration
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case occurrenceID = "occurrence_id"
        case startTime = "start_time"
        case duration
        case status
    }
}

/// Registrant.
public struct MeetingRegistrant: Codable {
    /// The registrant's email address.
    public var email: String
    /// The registrant's status: 
    /// * `approved` — Registrant is approved. 
    /// * `denied` — Registrant is denied. 
    /// * `pending` — Registrant is waiting for approval.
    public var status: Status?
    /// The registrant's first name.
    public var firstName: String
    /// The registrant's last name.
    public var lastName: String?
    /// The registrant's address.
    public var address: String?
    /// The registrant's city.
    public var city: String?
    /// The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
    public var country: String?
    /// The registrant's ZIP or postal code.
    public var zip: String?
    /// The registrant's state or province.
    public var state: String?
    /// The registrant's phone number.
    public var phone: String?
    /// The registrant's industry.
    public var industry: String?
    /// The registrant's organization.
    public var org: String?
    /// The registrant's job title.
    public var jobTitle: String?
    /// The registrant's purchasing time frame: 
    /// * `Within a month` 
    /// * `1-3 months` 
    /// * `4-6 months` 
    /// * `More than 6 months` 
    /// * `No timeframe`
    public var purchasingTimeFrame: PurchasingTimeFrame?
    /// The registrant's role in the purchase process: 
    /// * `Decision Maker` 
    /// * `Evaluator/Recommender` 
    /// * `Influencer` 
    /// * `Not involved`
    public var roleInPurchaseProcess: RoleInPurchaseProcess?
    /// The registrant's number of employees: 
    /// * `1-20` 
    /// * `21-50` 
    /// * `51-100` 
    /// * `101-500` 
    /// * `500-1,000` 
    /// * `1,001-5,000` 
    /// * `5,001-10,000` 
    /// * `More than 10,000`
    public var noOfEmployees: NoOfEmployees?
    /// The registrant's questions and comments.
    public var comments: String?
    /// Information about custom questions.
    public var customQuestions: [CustomQuestion]?

    /// The registrant's status: 
    /// * `approved` — Registrant is approved. 
    /// * `denied` — Registrant is denied. 
    /// * `pending` — Registrant is waiting for approval.
    public enum Status: String, Codable, CaseIterable {
        case approved
        case denied
        case pending
    }

    /// The registrant's purchasing time frame: 
    /// * `Within a month` 
    /// * `1-3 months` 
    /// * `4-6 months` 
    /// * `More than 6 months` 
    /// * `No timeframe`
    public enum PurchasingTimeFrame: String, Codable, CaseIterable {
        case empty = ""
        case withinAMonth = "Within a month"
        case _13Months = "1-3 months"
        case _46Months = "4-6 months"
        case moreThan6Months = "More than 6 months"
        case noTimeframe = "No timeframe"
    }

    /// The registrant's role in the purchase process: 
    /// * `Decision Maker` 
    /// * `Evaluator/Recommender` 
    /// * `Influencer` 
    /// * `Not involved`
    public enum RoleInPurchaseProcess: String, Codable, CaseIterable {
        case empty = ""
        case decisionMaker = "Decision Maker"
        case evaluatorRecommender = "Evaluator/Recommender"
        case influencer = "Influencer"
        case notInvolved = "Not involved"
    }

    /// The registrant's number of employees: 
    /// * `1-20` 
    /// * `21-50` 
    /// * `51-100` 
    /// * `101-500` 
    /// * `500-1,000` 
    /// * `1,001-5,000` 
    /// * `5,001-10,000` 
    /// * `More than 10,000`
    public enum NoOfEmployees: String, Codable, CaseIterable {
        case empty = ""
        case _120 = "1-20"
        case _2150 = "21-50"
        case _51100 = "51-100"
        case _101500 = "101-500"
        case _5001000 = "500-1,000"
        case _10015000 = "1,001-5,000"
        case _500110000 = "5,001-10,000"
        case moreThan10000 = "More than 10,000"
    }

    /// Information about custom questions.
    public struct CustomQuestion: Codable {
        /// The title of the custom question.
        public var title: String?
        /// The custom question's response value. This has a limit of 128 characters.
        public var value: String?

        public init(title: String? = nil, value: String? = nil) {
            self.title = title
            self.value = value
        }
    }

    public init(email: String, status: Status? = nil, firstName: String, lastName: String? = nil, address: String? = nil, city: String? = nil, country: String? = nil, zip: String? = nil, state: String? = nil, phone: String? = nil, industry: String? = nil, org: String? = nil, jobTitle: String? = nil, purchasingTimeFrame: PurchasingTimeFrame? = nil, roleInPurchaseProcess: RoleInPurchaseProcess? = nil, noOfEmployees: NoOfEmployees? = nil, comments: String? = nil, customQuestions: [CustomQuestion]? = nil) {
        self.email = email
        self.status = status
        self.firstName = firstName
        self.lastName = lastName
        self.address = address
        self.city = city
        self.country = country
        self.zip = zip
        self.state = state
        self.phone = phone
        self.industry = industry
        self.org = org
        self.jobTitle = jobTitle
        self.purchasingTimeFrame = purchasingTimeFrame
        self.roleInPurchaseProcess = roleInPurchaseProcess
        self.noOfEmployees = noOfEmployees
        self.comments = comments
        self.customQuestions = customQuestions
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.email = try values.decode(String.self, forKey: "email")
        self.status = try Status(from: decoder)
        self.firstName = try values.decode(String.self, forKey: "first_name")
        self.lastName = try values.decodeIfPresent(String.self, forKey: "last_name")
        self.address = try values.decodeIfPresent(String.self, forKey: "address")
        self.city = try values.decodeIfPresent(String.self, forKey: "city")
        self.country = try values.decodeIfPresent(String.self, forKey: "country")
        self.zip = try values.decodeIfPresent(String.self, forKey: "zip")
        self.state = try values.decodeIfPresent(String.self, forKey: "state")
        self.phone = try values.decodeIfPresent(String.self, forKey: "phone")
        self.industry = try values.decodeIfPresent(String.self, forKey: "industry")
        self.org = try values.decodeIfPresent(String.self, forKey: "org")
        self.jobTitle = try values.decodeIfPresent(String.self, forKey: "job_title")
        self.purchasingTimeFrame = try PurchasingTimeFrame(from: decoder)
        self.roleInPurchaseProcess = try RoleInPurchaseProcess(from: decoder)
        self.noOfEmployees = try NoOfEmployees(from: decoder)
        self.comments = try values.decodeIfPresent(String.self, forKey: "comments")
        self.customQuestions = try values.decodeIfPresent([CustomQuestion].self, forKey: "custom_questions")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(email, forKey: "email")
        try values.encodeIfPresent(status, forKey: "status")
        try values.encode(firstName, forKey: "first_name")
        try values.encodeIfPresent(lastName, forKey: "last_name")
        try values.encodeIfPresent(address, forKey: "address")
        try values.encodeIfPresent(city, forKey: "city")
        try values.encodeIfPresent(country, forKey: "country")
        try values.encodeIfPresent(zip, forKey: "zip")
        try values.encodeIfPresent(state, forKey: "state")
        try values.encodeIfPresent(phone, forKey: "phone")
        try values.encodeIfPresent(industry, forKey: "industry")
        try values.encodeIfPresent(org, forKey: "org")
        try values.encodeIfPresent(jobTitle, forKey: "job_title")
        try values.encodeIfPresent(purchasingTimeFrame, forKey: "purchasing_time_frame")
        try values.encodeIfPresent(roleInPurchaseProcess, forKey: "role_in_purchase_process")
        try values.encodeIfPresent(noOfEmployees, forKey: "no_of_employees")
        try values.encodeIfPresent(comments, forKey: "comments")
        try values.encodeIfPresent(customQuestions, forKey: "custom_questions")
    }
}

public struct PollList: Codable {
    /// The number of all records available across pages
    public var totalRecords: Int?
    /// Array of Polls
    public var polls: [Poll]?

    public struct Poll: Codable {
        /// ID of Poll
        public var id: String?
        /// Status of Poll:<br>`notstart` - Poll not started<br>`started` - Poll started<br>`ended` - Poll ended<br>`sharing` - Sharing poll results
        public var status: Status?
        /// The poll's title, up to 64 characters.
        public var title: String?
        /// The type of poll: 
        /// * `1` — Poll. 
        /// * `2` — Advanced Poll. This feature must be enabled in your Zoom account. 
        /// * `3` — Quiz. This feature must be enabled in your Zoom account. 
        /// 
        ///  This value defaults to `1`.
        public var pollType: Int?
        /// Whether to allow meeting participants to answer poll questions anonymously: 
        /// * `true` — Anonymous polls enabled. 
        /// * `false` — Participants cannot answer poll questions anonymously. 
        /// 
        /// This value defaults to `false`.
        public var isAnonymous: Bool
        /// Information about the poll's questions.
        public var questions: [Question]?

        /// Status of Poll:<br>`notstart` - Poll not started<br>`started` - Poll started<br>`ended` - Poll ended<br>`sharing` - Sharing poll results
        public enum Status: String, Codable, CaseIterable {
            case notstart
            case started
            case ended
            case sharing
        }

        public struct Question: Codable {
            /// The poll question, up to 255 characters. 
            /// 
            /// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
            public var name: String?
            /// The poll's question and answer type: 
            /// * `single` — Single choice. 
            /// * `multiple` — Multiple choice. 
            /// * `matching` — Matching. 
            /// * `rank_order` — Rank order. 
            /// * `short_answer` — Short answer. 
            /// * `long_answer` — Long answer. 
            /// * `fill_in_the_blank` — Fill in the blank. 
            /// * `rating_scale` — Rating scale.
            public var type: `Type`?
            /// Whether to display the radio selection as a drop-down box: 
            /// * `true` — Show as a drop-down box. 
            /// * `false` — Do not show as a drop-down box. 
            /// 
            /// This value defaults to `false`.
            public var isShowAsDropdown: Bool
            /// Whether participants must answer the question: 
            /// * `true` — The participant must answer the question. 
            /// * `false` — The participant does not need to answer the question. 
            /// 
            /// **Note:** 
            /// * When the poll's `type` value is `1` (Poll), this value defaults to `true`. 
            /// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
            public var isAnswerRequired: Bool
            /// The poll question's available answers. This field requires a **minimum** of two answers. 
            /// 
            /// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers. 
            /// * For `matching` polls, you can only provide a maximum of 16 answers. 
            /// * For `rank_order` polls, you can only provide a maximum of seven answers.
            public var answers: [String]?
            /// The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). 
            /// 
            ///  For `single` and `matching` polls, this field only accepts one answer.
            public var rightAnswers: [String]?
            /// Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
            public var prompts: [Prompt]?
            /// The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
            public var answerMinCharacter: Int?
            /// The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: 
            /// * For `short_answer` polls, a maximum of 500 characters. 
            /// * For `long_answer` polls, a maximum of 2,000 characters.
            public var answerMaxCharacter: Int?
            /// Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: 
            /// * `true` — The answer is case-sensitive. 
            /// * `false` — The answer is not case-sensitive. 
            /// 
            /// This value defaults to `false`.
            public var isCaseSensitive: Bool
            /// The rating scale's minimum value. This value cannot be less than zero. 
            /// 
            /// This field only applies to the `rating_scale` poll.
            public var ratingMinValue: Int?
            /// The rating scale's maximum value, up to a maximum value of 10. 
            /// 
            /// This field only applies to the `rating_scale` poll.
            public var ratingMaxValue: Int?
            /// The low score label used for the `rating_min_value` field. 
            /// 
            /// This field only applies to the `rating_scale` poll.
            public var ratingMinLabel: String?
            /// The high score label used for the `rating_max_value` field. 
            /// 
            /// This field only applies to the `rating_scale` poll.
            public var ratingMaxLabel: String?

            /// The poll's question and answer type: 
            /// * `single` — Single choice. 
            /// * `multiple` — Multiple choice. 
            /// * `matching` — Matching. 
            /// * `rank_order` — Rank order. 
            /// * `short_answer` — Short answer. 
            /// * `long_answer` — Long answer. 
            /// * `fill_in_the_blank` — Fill in the blank. 
            /// * `rating_scale` — Rating scale.
            public enum `Type`: String, Codable, CaseIterable {
                case single
                case multiple
                case matching
                case rankOrder = "rank_order"
                case shortAnswer = "short_answer"
                case longAnswer = "long_answer"
                case fillInTheBlank = "fill_in_the_blank"
                case ratingScale = "rating_scale"
            }

            public struct Prompt: Codable {
                /// The question prompt's title.
                public var promptQuestion: String?
                /// The question prompt's correct answers: 
                /// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. 
                /// * For `rank_order` polls, you can only provide one correct answer.
                public var promptRightAnswers: [String]?

                public init(promptQuestion: String? = nil, promptRightAnswers: [String]? = nil) {
                    self.promptQuestion = promptQuestion
                    self.promptRightAnswers = promptRightAnswers
                }

                private enum CodingKeys: String, CodingKey {
                    case promptQuestion = "prompt_question"
                    case promptRightAnswers = "prompt_right_answers"
                }
            }

            public init(name: String? = nil, type: `Type`? = nil, isShowAsDropdown: Bool? = nil, isAnswerRequired: Bool? = nil, answers: [String]? = nil, rightAnswers: [String]? = nil, prompts: [Prompt]? = nil, answerMinCharacter: Int? = nil, answerMaxCharacter: Int? = nil, isCaseSensitive: Bool? = nil, ratingMinValue: Int? = nil, ratingMaxValue: Int? = nil, ratingMinLabel: String? = nil, ratingMaxLabel: String? = nil) {
                self.name = name
                self.type = type
                self.isShowAsDropdown = isShowAsDropdown ?? false
                self.isAnswerRequired = isAnswerRequired ?? false
                self.answers = answers
                self.rightAnswers = rightAnswers
                self.prompts = prompts
                self.answerMinCharacter = answerMinCharacter
                self.answerMaxCharacter = answerMaxCharacter
                self.isCaseSensitive = isCaseSensitive ?? false
                self.ratingMinValue = ratingMinValue
                self.ratingMaxValue = ratingMaxValue
                self.ratingMinLabel = ratingMinLabel
                self.ratingMaxLabel = ratingMaxLabel
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case type
                case isShowAsDropdown = "show_as_dropdown"
                case isAnswerRequired = "answer_required"
                case answers
                case rightAnswers = "right_answers"
                case prompts
                case answerMinCharacter = "answer_min_character"
                case answerMaxCharacter = "answer_max_character"
                case isCaseSensitive = "case_sensitive"
                case ratingMinValue = "rating_min_value"
                case ratingMaxValue = "rating_max_value"
                case ratingMinLabel = "rating_min_label"
                case ratingMaxLabel = "rating_max_label"
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: CodingKeys.self)
                self.name = try values.decodeIfPresent(String.self, forKey: .name)
                self.type = try values.decodeIfPresent(`Type`.self, forKey: .type)
                self.isShowAsDropdown = try values.decodeIfPresent(Bool.self, forKey: .isShowAsDropdown) ?? false
                self.isAnswerRequired = try values.decodeIfPresent(Bool.self, forKey: .isAnswerRequired) ?? false
                self.answers = try values.decodeIfPresent([String].self, forKey: .answers)
                self.rightAnswers = try values.decodeIfPresent([String].self, forKey: .rightAnswers)
                self.prompts = try values.decodeIfPresent([Prompt].self, forKey: .prompts)
                self.answerMinCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMinCharacter)
                self.answerMaxCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMaxCharacter)
                self.isCaseSensitive = try values.decodeIfPresent(Bool.self, forKey: .isCaseSensitive) ?? false
                self.ratingMinValue = try values.decodeIfPresent(Int.self, forKey: .ratingMinValue)
                self.ratingMaxValue = try values.decodeIfPresent(Int.self, forKey: .ratingMaxValue)
                self.ratingMinLabel = try values.decodeIfPresent(String.self, forKey: .ratingMinLabel)
                self.ratingMaxLabel = try values.decodeIfPresent(String.self, forKey: .ratingMaxLabel)
            }
        }

        public init(id: String? = nil, status: Status? = nil, title: String? = nil, pollType: Int? = nil, isAnonymous: Bool? = nil, questions: [Question]? = nil) {
            self.id = id
            self.status = status
            self.title = title
            self.pollType = pollType
            self.isAnonymous = isAnonymous ?? false
            self.questions = questions
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.status = try Status(from: decoder)
            self.title = try values.decodeIfPresent(String.self, forKey: "title")
            self.pollType = try values.decodeIfPresent(Int.self, forKey: "poll_type")
            self.isAnonymous = try values.decodeIfPresent(Bool.self, forKey: "anonymous") ?? false
            self.questions = try values.decodeIfPresent([Question].self, forKey: "questions")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(status, forKey: "status")
            try values.encodeIfPresent(title, forKey: "title")
            try values.encodeIfPresent(pollType, forKey: "poll_type")
            try values.encodeIfPresent(isAnonymous, forKey: "anonymous")
            try values.encodeIfPresent(questions, forKey: "questions")
        }
    }

    public init(totalRecords: Int? = nil, polls: [Poll]? = nil) {
        self.totalRecords = totalRecords
        self.polls = polls
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.totalRecords = try values.decodeIfPresent(Int.self, forKey: "total_records")
        self.polls = try values.decodeIfPresent([Poll].self, forKey: "polls")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(totalRecords, forKey: "total_records")
        try values.encodeIfPresent(polls, forKey: "polls")
    }
}

/// Occurrence object. This object is only returned for Recurring Webinars.
public struct Occurrence: Codable {
    /// Occurrence ID: Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences.
    public var occurrenceID: String?
    /// Start time.
    public var startTime: Date?
    /// Duration.
    public var duration: Int?
    /// Occurrence status.
    public var status: String?

    public init(occurrenceID: String? = nil, startTime: Date? = nil, duration: Int? = nil, status: String? = nil) {
        self.occurrenceID = occurrenceID
        self.startTime = startTime
        self.duration = duration
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case occurrenceID = "occurrence_id"
        case startTime = "start_time"
        case duration
        case status
    }
}

/// Invite Links
///
/// Invite links response.
public struct InviteLinkResponse: Codable {
    /// The attendee list.
    public var attendees: [Attendee]?

    public struct Attendee: Codable {
        /// The user's display name.
        public var name: String?
        /// The URL to join the meeting.
        public var joinURL: String?

        public init(name: String? = nil, joinURL: String? = nil) {
            self.name = name
            self.joinURL = joinURL
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case joinURL = "join_url"
        }
    }

    public init(attendees: [Attendee]? = nil) {
        self.attendees = attendees
    }
}

/// Information about custom questions.
public struct CustomQuestion: Codable {
    /// The title of the custom question.
    public var title: String?
    /// The custom question's response value. This has a limit of 128 characters.
    public var value: String?

    public init(title: String? = nil, value: String? = nil) {
        self.title = title
        self.value = value
    }
}

/// Information about the registrant.
public struct Registrant: Codable {
    /// The registrant's email address.
    public var email: String
    /// The registrant's status: 
    /// * `approved` — Registrant is approved. 
    /// * `denied` — Registrant is denied. 
    /// * `pending` — Registrant is waiting for approval.
    public var status: Status?
    /// The registrant's first name.
    public var firstName: String
    /// The registrant's last name.
    public var lastName: String?
    /// The registrant's address.
    public var address: String?
    /// The registrant's city.
    public var city: String?
    /// The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
    public var country: String?
    /// The registrant's ZIP or postal code.
    public var zip: String?
    /// The registrant's state or province.
    public var state: String?
    /// The registrant's phone number.
    public var phone: String?
    /// The registrant's industry.
    public var industry: String?
    /// The registrant's organization.
    public var org: String?
    /// The registrant's job title.
    public var jobTitle: String?
    /// The registrant's purchasing time frame: 
    /// * `Within a month` 
    /// * `1-3 months` 
    /// * `4-6 months` 
    /// * `More than 6 months` 
    /// * `No timeframe`
    public var purchasingTimeFrame: PurchasingTimeFrame?
    /// The registrant's role in the purchase process: 
    /// * `Decision Maker` 
    /// * `Evaluator/Recommender` 
    /// * `Influencer` 
    /// * `Not involved`
    public var roleInPurchaseProcess: RoleInPurchaseProcess?
    /// The registrant's number of employees: 
    /// * `1-20` 
    /// * `21-50` 
    /// * `51-100` 
    /// * `101-500` 
    /// * `500-1,000` 
    /// * `1,001-5,000` 
    /// * `5,001-10,000` 
    /// * `More than 10,000`
    public var noOfEmployees: NoOfEmployees?
    /// The registrant's questions and comments.
    public var comments: String?
    /// Information about custom questions.
    public var customQuestions: [CustomQuestion]?

    /// The registrant's status: 
    /// * `approved` — Registrant is approved. 
    /// * `denied` — Registrant is denied. 
    /// * `pending` — Registrant is waiting for approval.
    public enum Status: String, Codable, CaseIterable {
        case approved
        case denied
        case pending
    }

    /// The registrant's purchasing time frame: 
    /// * `Within a month` 
    /// * `1-3 months` 
    /// * `4-6 months` 
    /// * `More than 6 months` 
    /// * `No timeframe`
    public enum PurchasingTimeFrame: String, Codable, CaseIterable {
        case empty = ""
        case withinAMonth = "Within a month"
        case _13Months = "1-3 months"
        case _46Months = "4-6 months"
        case moreThan6Months = "More than 6 months"
        case noTimeframe = "No timeframe"
    }

    /// The registrant's role in the purchase process: 
    /// * `Decision Maker` 
    /// * `Evaluator/Recommender` 
    /// * `Influencer` 
    /// * `Not involved`
    public enum RoleInPurchaseProcess: String, Codable, CaseIterable {
        case empty = ""
        case decisionMaker = "Decision Maker"
        case evaluatorRecommender = "Evaluator/Recommender"
        case influencer = "Influencer"
        case notInvolved = "Not involved"
    }

    /// The registrant's number of employees: 
    /// * `1-20` 
    /// * `21-50` 
    /// * `51-100` 
    /// * `101-500` 
    /// * `500-1,000` 
    /// * `1,001-5,000` 
    /// * `5,001-10,000` 
    /// * `More than 10,000`
    public enum NoOfEmployees: String, Codable, CaseIterable {
        case empty = ""
        case _120 = "1-20"
        case _2150 = "21-50"
        case _51100 = "51-100"
        case _101500 = "101-500"
        case _5001000 = "500-1,000"
        case _10015000 = "1,001-5,000"
        case _500110000 = "5,001-10,000"
        case moreThan10000 = "More than 10,000"
    }

    /// Information about custom questions.
    public struct CustomQuestion: Codable {
        /// The title of the custom question.
        public var title: String?
        /// The custom question's response value. This has a limit of 128 characters.
        public var value: String?

        public init(title: String? = nil, value: String? = nil) {
            self.title = title
            self.value = value
        }
    }

    public init(email: String, status: Status? = nil, firstName: String, lastName: String? = nil, address: String? = nil, city: String? = nil, country: String? = nil, zip: String? = nil, state: String? = nil, phone: String? = nil, industry: String? = nil, org: String? = nil, jobTitle: String? = nil, purchasingTimeFrame: PurchasingTimeFrame? = nil, roleInPurchaseProcess: RoleInPurchaseProcess? = nil, noOfEmployees: NoOfEmployees? = nil, comments: String? = nil, customQuestions: [CustomQuestion]? = nil) {
        self.email = email
        self.status = status
        self.firstName = firstName
        self.lastName = lastName
        self.address = address
        self.city = city
        self.country = country
        self.zip = zip
        self.state = state
        self.phone = phone
        self.industry = industry
        self.org = org
        self.jobTitle = jobTitle
        self.purchasingTimeFrame = purchasingTimeFrame
        self.roleInPurchaseProcess = roleInPurchaseProcess
        self.noOfEmployees = noOfEmployees
        self.comments = comments
        self.customQuestions = customQuestions
    }

    private enum CodingKeys: String, CodingKey {
        case email
        case status
        case firstName = "first_name"
        case lastName = "last_name"
        case address
        case city
        case country
        case zip
        case state
        case phone
        case industry
        case org
        case jobTitle = "job_title"
        case purchasingTimeFrame = "purchasing_time_frame"
        case roleInPurchaseProcess = "role_in_purchase_process"
        case noOfEmployees = "no_of_employees"
        case comments
        case customQuestions = "custom_questions"
    }
}

/// Invite Links
public struct InviteLink: Codable {
    /// The invite link's expiration time, in seconds. 
    /// 
    /// This value defaults to `7200`.
    public var ttl: Int?
    /// The attendees list.
    public var attendees: [Attendee]?

    public struct Attendee: Codable {
        /// User display name.
        public var name: String

        public init(name: String) {
            self.name = name
        }
    }

    public init(ttl: Int? = nil, attendees: [Attendee]? = nil) {
        self.ttl = ttl
        self.attendees = attendees
    }
}

/// Meeting and Webinar Polling Object
///
/// Information about meeting and webinar polling.
public struct Poll: Codable {
    /// The poll's title, up to 64 characters.
    public var title: String?
    /// The type of poll: 
    /// * `1` — Poll. 
    /// * `2` — Advanced Poll. This feature must be enabled in your Zoom account. 
    /// * `3` — Quiz. This feature must be enabled in your Zoom account. 
    /// 
    ///  This value defaults to `1`.
    public var pollType: Int?
    /// Whether to allow meeting participants to answer poll questions anonymously: 
    /// * `true` — Anonymous polls enabled. 
    /// * `false` — Participants cannot answer poll questions anonymously. 
    /// 
    /// This value defaults to `false`.
    public var isAnonymous: Bool
    /// Information about the poll's questions.
    public var questions: [Question]?

    public struct Question: Codable {
        /// The poll question, up to 255 characters. 
        /// 
        /// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
        public var name: String?
        /// The poll's question and answer type: 
        /// * `single` — Single choice. 
        /// * `multiple` — Multiple choice. 
        /// * `matching` — Matching. 
        /// * `rank_order` — Rank order. 
        /// * `short_answer` — Short answer. 
        /// * `long_answer` — Long answer. 
        /// * `fill_in_the_blank` — Fill in the blank. 
        /// * `rating_scale` — Rating scale.
        public var type: `Type`?
        /// Whether to display the radio selection as a drop-down box: 
        /// * `true` — Show as a drop-down box. 
        /// * `false` — Do not show as a drop-down box. 
        /// 
        /// This value defaults to `false`.
        public var isShowAsDropdown: Bool
        /// Whether participants must answer the question: 
        /// * `true` — The participant must answer the question. 
        /// * `false` — The participant does not need to answer the question. 
        /// 
        /// **Note:** 
        /// * When the poll's `type` value is `1` (Poll), this value defaults to `true`. 
        /// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
        public var isAnswerRequired: Bool
        /// The poll question's available answers. This field requires a **minimum** of two answers. 
        /// 
        /// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers. 
        /// * For `matching` polls, you can only provide a maximum of 16 answers. 
        /// * For `rank_order` polls, you can only provide a maximum of seven answers.
        public var answers: [String]?
        /// The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). 
        /// 
        ///  For `single` and `matching` polls, this field only accepts one answer.
        public var rightAnswers: [String]?
        /// Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
        public var prompts: [Prompt]?
        /// The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
        public var answerMinCharacter: Int?
        /// The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: 
        /// * For `short_answer` polls, a maximum of 500 characters. 
        /// * For `long_answer` polls, a maximum of 2,000 characters.
        public var answerMaxCharacter: Int?
        /// Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: 
        /// * `true` — The answer is case-sensitive. 
        /// * `false` — The answer is not case-sensitive. 
        /// 
        /// This value defaults to `false`.
        public var isCaseSensitive: Bool
        /// The rating scale's minimum value. This value cannot be less than zero. 
        /// 
        /// This field only applies to the `rating_scale` poll.
        public var ratingMinValue: Int?
        /// The rating scale's maximum value, up to a maximum value of 10. 
        /// 
        /// This field only applies to the `rating_scale` poll.
        public var ratingMaxValue: Int?
        /// The low score label used for the `rating_min_value` field. 
        /// 
        /// This field only applies to the `rating_scale` poll.
        public var ratingMinLabel: String?
        /// The high score label used for the `rating_max_value` field. 
        /// 
        /// This field only applies to the `rating_scale` poll.
        public var ratingMaxLabel: String?

        /// The poll's question and answer type: 
        /// * `single` — Single choice. 
        /// * `multiple` — Multiple choice. 
        /// * `matching` — Matching. 
        /// * `rank_order` — Rank order. 
        /// * `short_answer` — Short answer. 
        /// * `long_answer` — Long answer. 
        /// * `fill_in_the_blank` — Fill in the blank. 
        /// * `rating_scale` — Rating scale.
        public enum `Type`: String, Codable, CaseIterable {
            case single
            case multiple
            case matching
            case rankOrder = "rank_order"
            case shortAnswer = "short_answer"
            case longAnswer = "long_answer"
            case fillInTheBlank = "fill_in_the_blank"
            case ratingScale = "rating_scale"
        }

        public struct Prompt: Codable {
            /// The question prompt's title.
            public var promptQuestion: String?
            /// The question prompt's correct answers: 
            /// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. 
            /// * For `rank_order` polls, you can only provide one correct answer.
            public var promptRightAnswers: [String]?

            public init(promptQuestion: String? = nil, promptRightAnswers: [String]? = nil) {
                self.promptQuestion = promptQuestion
                self.promptRightAnswers = promptRightAnswers
            }

            private enum CodingKeys: String, CodingKey {
                case promptQuestion = "prompt_question"
                case promptRightAnswers = "prompt_right_answers"
            }
        }

        public init(name: String? = nil, type: `Type`? = nil, isShowAsDropdown: Bool? = nil, isAnswerRequired: Bool? = nil, answers: [String]? = nil, rightAnswers: [String]? = nil, prompts: [Prompt]? = nil, answerMinCharacter: Int? = nil, answerMaxCharacter: Int? = nil, isCaseSensitive: Bool? = nil, ratingMinValue: Int? = nil, ratingMaxValue: Int? = nil, ratingMinLabel: String? = nil, ratingMaxLabel: String? = nil) {
            self.name = name
            self.type = type
            self.isShowAsDropdown = isShowAsDropdown ?? false
            self.isAnswerRequired = isAnswerRequired ?? false
            self.answers = answers
            self.rightAnswers = rightAnswers
            self.prompts = prompts
            self.answerMinCharacter = answerMinCharacter
            self.answerMaxCharacter = answerMaxCharacter
            self.isCaseSensitive = isCaseSensitive ?? false
            self.ratingMinValue = ratingMinValue
            self.ratingMaxValue = ratingMaxValue
            self.ratingMinLabel = ratingMinLabel
            self.ratingMaxLabel = ratingMaxLabel
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case type
            case isShowAsDropdown = "show_as_dropdown"
            case isAnswerRequired = "answer_required"
            case answers
            case rightAnswers = "right_answers"
            case prompts
            case answerMinCharacter = "answer_min_character"
            case answerMaxCharacter = "answer_max_character"
            case isCaseSensitive = "case_sensitive"
            case ratingMinValue = "rating_min_value"
            case ratingMaxValue = "rating_max_value"
            case ratingMinLabel = "rating_min_label"
            case ratingMaxLabel = "rating_max_label"
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.name = try values.decodeIfPresent(String.self, forKey: .name)
            self.type = try values.decodeIfPresent(`Type`.self, forKey: .type)
            self.isShowAsDropdown = try values.decodeIfPresent(Bool.self, forKey: .isShowAsDropdown) ?? false
            self.isAnswerRequired = try values.decodeIfPresent(Bool.self, forKey: .isAnswerRequired) ?? false
            self.answers = try values.decodeIfPresent([String].self, forKey: .answers)
            self.rightAnswers = try values.decodeIfPresent([String].self, forKey: .rightAnswers)
            self.prompts = try values.decodeIfPresent([Prompt].self, forKey: .prompts)
            self.answerMinCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMinCharacter)
            self.answerMaxCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMaxCharacter)
            self.isCaseSensitive = try values.decodeIfPresent(Bool.self, forKey: .isCaseSensitive) ?? false
            self.ratingMinValue = try values.decodeIfPresent(Int.self, forKey: .ratingMinValue)
            self.ratingMaxValue = try values.decodeIfPresent(Int.self, forKey: .ratingMaxValue)
            self.ratingMinLabel = try values.decodeIfPresent(String.self, forKey: .ratingMinLabel)
            self.ratingMaxLabel = try values.decodeIfPresent(String.self, forKey: .ratingMaxLabel)
        }
    }

    public init(title: String? = nil, pollType: Int? = nil, isAnonymous: Bool? = nil, questions: [Question]? = nil) {
        self.title = title
        self.pollType = pollType
        self.isAnonymous = isAnonymous ?? false
        self.questions = questions
    }

    private enum CodingKeys: String, CodingKey {
        case title
        case pollType = "poll_type"
        case isAnonymous = "anonymous"
        case questions
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.title = try values.decodeIfPresent(String.self, forKey: .title)
        self.pollType = try values.decodeIfPresent(Int.self, forKey: .pollType)
        self.isAnonymous = try values.decodeIfPresent(Bool.self, forKey: .isAnonymous) ?? false
        self.questions = try values.decodeIfPresent([Question].self, forKey: .questions)
    }
}

/// Meeting/Webinar Security Settings
public struct MeetingSecuritySettings: Codable {
    public var meetingSecurity: MeetingSecurity?

    public struct MeetingSecurity: Codable {
        /// If set to `true`, meeting passcode will be encrypted and included in the invite link to allow participants to join with just one click without having to enter the passcode.
        public var isEmbedPasswordInJoinLink: Bool?
        /// Allow use of end-to-end encryption for meetings. If set to `true`, you can specify the encryption type in `encryption_type` field.
        public var isEndToEndEncryptedMeetings: Bool?
        /// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
        /// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
        /// 
        /// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
        public var encryptionType: EncryptionType?
        /// If set to `true`, all instant, and scheduled meetings that users can join via client, or room systems will be passcode-protected. The Personal Meeting ID (PMI) meetings are not included in this setting.
        public var isMeetingPassword: Bool?
        /// Meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
        public var meetingPasswordRequirement: MeetingPasswordRequirement?
        /// Require passcode for participants joining by phone. If set to `true`, a numeric passcode will be required for participants joining by phone if your meeting has a passcode. For meeting with an alphanumeric passcode, a numeric version will be generated.
        public var isPhonePassword: Bool?
        /// If set to `true`, all Personal Meeting ID (PMI) meetings that users can join via client, or room systems will be passcode-protected.
        public var isPmiPassword: Bool?
        /// Require a passcode for meetings which have already been scheduled.
        public var requirePasswordForScheduledMeeting: Bool?
        /// If set to `true`, a passcode will be generated when scheduling a Webinar and participants require the passcode to join the Webinar.
        public var isWebinarPassword: Bool?
        /// Require a passcode for webinars which have already been scheduled.
        public var requirePasswordForScheduledWebinar: Bool?
        /// When participants join a meeting, place them in a waiting room and require the host to admit them individually. Enabling the waiting room automatically disables the setting for allowing participants to join before host.
        public var isWaitingRoom: Bool?
        /// Specify the settings to be applied if waiting room is enabled.
        public var waitingRoomSettings: WaitingRoomSettings?
        /// `true`: Require that all meetings are secured with at least one security option.
        /// 
        /// This setting can only be disabled by Enterprise, ISV, Business (with more than 100 licenses), and Education accounts. [Learn more](https://marketplace.zoom.us/docs/guides/stay-up-to-date/announcements#meeting-security).
        public var isAutoSecurity: Bool?
        /// If set to `true`, Block users in specific domains from joining meetings and webinars.
        public var isBlockUserDomain: Bool?
        /// Specific domain, for Example: `*.example.com`.
        public var blockUserDomainList: [String]?

        /// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
        /// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
        /// 
        /// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
        public enum EncryptionType: String, Codable, CaseIterable {
            case enhancedEncryption = "enhanced_encryption"
            case e2ee
        }

        /// Meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
        public struct MeetingPasswordRequirement: Codable {
            /// The minimum length that the meeting/webinar passcode needs to have.
            public var length: Int?
            /// If set to `true`, the passcode must contain at least 1 letter (such as a,b,c...).
            public var haveLetter: Bool?
            /// If set to `true`, the passcode must contain at least 1 number (such as 1,2,3...).
            public var haveNumber: Bool?
            /// If set to `true`, the passcode must have at least 1 special character (!,@,#...).
            public var haveSpecialCharacter: Bool?
            /// If set to `true`, the passcode must only contain numbers and no other characters.
            public var onlyAllowNumeric: Bool?
            /// If set to `true`, the passcode must include both uppercase and lowercase characters.
            public var haveUpperAndLowerCharacters: Bool?
            public var consecutiveCharactersLength: Int?
            /// If set to `true`, users will be informed if the provided passcode is weak.
            public var isWeakEnhanceDetection: Bool?

            public init(length: Int? = nil, haveLetter: Bool? = nil, haveNumber: Bool? = nil, haveSpecialCharacter: Bool? = nil, onlyAllowNumeric: Bool? = nil, haveUpperAndLowerCharacters: Bool? = nil, consecutiveCharactersLength: Int? = nil, isWeakEnhanceDetection: Bool? = nil) {
                self.length = length
                self.haveLetter = haveLetter
                self.haveNumber = haveNumber
                self.haveSpecialCharacter = haveSpecialCharacter
                self.onlyAllowNumeric = onlyAllowNumeric
                self.haveUpperAndLowerCharacters = haveUpperAndLowerCharacters
                self.consecutiveCharactersLength = consecutiveCharactersLength
                self.isWeakEnhanceDetection = isWeakEnhanceDetection
            }

            private enum CodingKeys: String, CodingKey {
                case length
                case haveLetter = "have_letter"
                case haveNumber = "have_number"
                case haveSpecialCharacter = "have_special_character"
                case onlyAllowNumeric = "only_allow_numeric"
                case haveUpperAndLowerCharacters = "have_upper_and_lower_characters"
                case consecutiveCharactersLength = "consecutive_characters_length"
                case isWeakEnhanceDetection = "weak_enhance_detection"
            }
        }

        /// Specify the settings to be applied if waiting room is enabled.
        public struct WaitingRoomSettings: Codable {
            /// Specify who should be admitted to the waiting room. The value of this field can be one of the following:<br>
            /// `0`: All attendees<br> `1`: Users who are not in your account<br> `2`: Users who are not in your account and are not part of your whitelisted domains that are specified in
            public var participantsToPlaceInWaitingRoom: Int?
            /// If the value of the `participants_to_place_in_waiting_room` field is `2`, use this setting to specify the domains that can bypass the waiting room feature. Separate multiple domains with commas(example: "aaa.com,bbb.com").
            public var whitelistedDomainsForWaitingRoom: String?
            /// Specify who can admit participants from the waiting room. The value of this field can be one of the following:<br>
            /// `0`: Host and co-hosts only<br> `1`: Host, co-hosts, and anyone who bypassed the waiting room (only if host and co-hosts are not present).
            public var usersWhoCanAdmitParticipantsFromWaitingRoom: Int?

            public init(participantsToPlaceInWaitingRoom: Int? = nil, whitelistedDomainsForWaitingRoom: String? = nil, usersWhoCanAdmitParticipantsFromWaitingRoom: Int? = nil) {
                self.participantsToPlaceInWaitingRoom = participantsToPlaceInWaitingRoom
                self.whitelistedDomainsForWaitingRoom = whitelistedDomainsForWaitingRoom
                self.usersWhoCanAdmitParticipantsFromWaitingRoom = usersWhoCanAdmitParticipantsFromWaitingRoom
            }

            private enum CodingKeys: String, CodingKey {
                case participantsToPlaceInWaitingRoom = "participants_to_place_in_waiting_room"
                case whitelistedDomainsForWaitingRoom = "whitelisted_domains_for_waiting_room"
                case usersWhoCanAdmitParticipantsFromWaitingRoom = "users_who_can_admit_participants_from_waiting_room"
            }
        }

        public init(isEmbedPasswordInJoinLink: Bool? = nil, isEndToEndEncryptedMeetings: Bool? = nil, encryptionType: EncryptionType? = nil, isMeetingPassword: Bool? = nil, meetingPasswordRequirement: MeetingPasswordRequirement? = nil, isPhonePassword: Bool? = nil, isPmiPassword: Bool? = nil, requirePasswordForScheduledMeeting: Bool? = nil, isWebinarPassword: Bool? = nil, requirePasswordForScheduledWebinar: Bool? = nil, isWaitingRoom: Bool? = nil, waitingRoomSettings: WaitingRoomSettings? = nil, isAutoSecurity: Bool? = nil, isBlockUserDomain: Bool? = nil, blockUserDomainList: [String]? = nil) {
            self.isEmbedPasswordInJoinLink = isEmbedPasswordInJoinLink
            self.isEndToEndEncryptedMeetings = isEndToEndEncryptedMeetings
            self.encryptionType = encryptionType
            self.isMeetingPassword = isMeetingPassword
            self.meetingPasswordRequirement = meetingPasswordRequirement
            self.isPhonePassword = isPhonePassword
            self.isPmiPassword = isPmiPassword
            self.requirePasswordForScheduledMeeting = requirePasswordForScheduledMeeting
            self.isWebinarPassword = isWebinarPassword
            self.requirePasswordForScheduledWebinar = requirePasswordForScheduledWebinar
            self.isWaitingRoom = isWaitingRoom
            self.waitingRoomSettings = waitingRoomSettings
            self.isAutoSecurity = isAutoSecurity
            self.isBlockUserDomain = isBlockUserDomain
            self.blockUserDomainList = blockUserDomainList
        }

        private enum CodingKeys: String, CodingKey {
            case isEmbedPasswordInJoinLink = "embed_password_in_join_link"
            case isEndToEndEncryptedMeetings = "end_to_end_encrypted_meetings"
            case encryptionType = "encryption_type"
            case isMeetingPassword = "meeting_password"
            case meetingPasswordRequirement = "meeting_password_requirement"
            case isPhonePassword = "phone_password"
            case isPmiPassword = "pmi_password"
            case requirePasswordForScheduledMeeting = "require_password_for_scheduled_meeting"
            case isWebinarPassword = "webinar_password"
            case requirePasswordForScheduledWebinar = "require_password_for_scheduled_webinar"
            case isWaitingRoom = "waiting_room"
            case waitingRoomSettings = "waiting_room_settings"
            case isAutoSecurity = "auto_security"
            case isBlockUserDomain = "block_user_domain"
            case blockUserDomainList = "block_user_domain_list"
        }
    }

    public init(meetingSecurity: MeetingSecurity? = nil) {
        self.meetingSecurity = meetingSecurity
    }

    private enum CodingKeys: String, CodingKey {
        case meetingSecurity = "meeting_security"
    }
}

/// List of Groups.
public struct GroupList: Codable {
    /// Total records.
    public var totalRecords: Int?
    /// List of Group objects.
    public var groups: [Group]?

    public struct Group: Codable {
        /// Group ID.
        public var id: String?
        /// Group name.
        public var name: String?
        /// Total number of members in this group.
        public var totalMembers: Int?

        public init(id: String? = nil, name: String? = nil, totalMembers: Int? = nil) {
            self.id = id
            self.name = name
            self.totalMembers = totalMembers
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.totalMembers = try values.decodeIfPresent(Int.self, forKey: "total_members")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(totalMembers, forKey: "total_members")
        }
    }

    public init(totalRecords: Int? = nil, groups: [Group]? = nil) {
        self.totalRecords = totalRecords
        self.groups = groups
    }

    private enum CodingKeys: String, CodingKey {
        case totalRecords = "total_records"
        case groups
    }
}

/// The group's audio conference settings.
public struct GroupSettingsAudioConference: Codable {
    /// The group's [**Toll-free and Fee-based Toll Call**](https://support.zoom.us/hc/en-us/articles/360060950711-Enabling-Toll-free-and-Fee-based-Toll-Call#h_01F51844DRCX3K7BRTMZ40381R) settings.
    public var tollFreeAndFeeBasedTollCall: TollFreeAndFeeBasedTollCall?

    /// The group's [**Toll-free and Fee-based Toll Call**](https://support.zoom.us/hc/en-us/articles/360060950711-Enabling-Toll-free-and-Fee-based-Toll-Call#h_01F51844DRCX3K7BRTMZ40381R) settings.
    public struct TollFreeAndFeeBasedTollCall: Codable {
        /// Whether the group has the [**Toll-free and Fee-based Toll Call**](https://support.zoom.us/hc/en-us/articles/360060950711-Enabling-Toll-free-and-Fee-based-Toll-Call#h_01F51844DRCX3K7BRTMZ40381R) setting enabled.
        public var enable: Bool?
        /// The group's **Toll-free and Fee-based Toll Call** phone number information.
        public var numbers: [Number]?
        /// Whether webinar attendees can dial in through the account's **Toll-free and Fee-based Toll Call** phone numbers. This feature is only available in version 5.2.2 and higher.
        public var allowWebinarAttendeesDial: Bool?

        public struct Number: Codable {
            /// The phone number's [E.164 country calling code](https://en.wikipedia.org/wiki/List_of_country_calling_codes).
            public var code: String?
            /// The phone number's [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
            public var countryCode: String?
            /// The country name.
            public var countryName: String?
            /// The phone number.
            public var number: String?
            /// The phone number's display number.
            public var displayNumber: String?

            public init(code: String? = nil, countryCode: String? = nil, countryName: String? = nil, number: String? = nil, displayNumber: String? = nil) {
                self.code = code
                self.countryCode = countryCode
                self.countryName = countryName
                self.number = number
                self.displayNumber = displayNumber
            }

            private enum CodingKeys: String, CodingKey {
                case code
                case countryCode = "country_code"
                case countryName = "country_name"
                case number
                case displayNumber = "display_number"
            }
        }

        public init(enable: Bool? = nil, numbers: [Number]? = nil, allowWebinarAttendeesDial: Bool? = nil) {
            self.enable = enable
            self.numbers = numbers
            self.allowWebinarAttendeesDial = allowWebinarAttendeesDial
        }

        private enum CodingKeys: String, CodingKey {
            case enable
            case numbers
            case allowWebinarAttendeesDial = "allow_webinar_attendees_dial"
        }
    }

    public init(tollFreeAndFeeBasedTollCall: TollFreeAndFeeBasedTollCall? = nil) {
        self.tollFreeAndFeeBasedTollCall = tollFreeAndFeeBasedTollCall
    }

    private enum CodingKeys: String, CodingKey {
        case tollFreeAndFeeBasedTollCall = "toll_free_and_fee_based_toll_call"
    }
}

public struct GroupSettingsOtherOptions: Codable {
    /// Whether iOS blurs the screenshot in the task switcher when multiple apps are open. Android hides the screenshot in the system-level list of recent apps.
    public var isBlurSnapshot: Bool?
    /// Whether to display the Zoom Help badge on the bottom-right of the page.
    public var allowUsersContactSupportViaChat: Bool?

    public init(isBlurSnapshot: Bool? = nil, allowUsersContactSupportViaChat: Bool? = nil) {
        self.isBlurSnapshot = isBlurSnapshot
        self.allowUsersContactSupportViaChat = allowUsersContactSupportViaChat
    }

    private enum CodingKeys: String, CodingKey {
        case isBlurSnapshot = "blur_snapshot"
        case allowUsersContactSupportViaChat = "allow_users_contact_support_via_chat"
    }
}

public struct Profile: Codable {
    public var recordingStorageLocation: RecordingStorageLocation?

    public struct RecordingStorageLocation: Codable {
        /// Users can choose the country to store their recorded content. Content can include meeting, webinar, and phone recordings, as well as voicemail, transcripts, and custom greeting prompts. See [Managing the Communications Content storage location](https://support.zoom.us/hc/en-us/articles/360050781131) for details.
        /// 
        /// Provide abbreviated country codes as the value for this field. See the [Countries abbreviation list](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries) for details.
        public var allowedValues: [String]?
        /// Abbreviated country code.
        public var value: String?

        public init(allowedValues: [String]? = nil, value: String? = nil) {
            self.allowedValues = allowedValues
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "allowed_values"
            case value
        }
    }

    public init(recordingStorageLocation: RecordingStorageLocation? = nil) {
        self.recordingStorageLocation = recordingStorageLocation
    }

    private enum CodingKeys: String, CodingKey {
        case recordingStorageLocation = "recording_storage_location"
    }
}

/// IM group object.
public struct IMGroup: Codable {
    /// Group name.
    public var name: String?
    /// Total number of members in this group.
    public var totalMembers: Int?
    /// IM Group types:<br>`normal` - Only members can see the other members in the group. Other people can search for members in the group.<br>`shared` - Everyone in the account can see the group and members. <br>`restricted` - No one except group members can see the group or search for other group members.
    public var type: `Type`?
    /// Members can search for others in the same email domain.
    public var isSearchByDomain: Bool?
    /// Members can search for others under same account.
    public var isSearchByAccount: Bool?
    /// Members can search for others under same master account - including all sub accounts.
    public var isSearchByMaAccount: Bool?

    /// IM Group types:<br>`normal` - Only members can see the other members in the group. Other people can search for members in the group.<br>`shared` - Everyone in the account can see the group and members. <br>`restricted` - No one except group members can see the group or search for other group members.
    public enum `Type`: String, Codable, CaseIterable {
        case normal
        case shared
        case restricted
    }

    public init(name: String? = nil, totalMembers: Int? = nil, type: `Type`? = nil, isSearchByDomain: Bool? = nil, isSearchByAccount: Bool? = nil, isSearchByMaAccount: Bool? = nil) {
        self.name = name
        self.totalMembers = totalMembers
        self.type = type
        self.isSearchByDomain = isSearchByDomain
        self.isSearchByAccount = isSearchByAccount
        self.isSearchByMaAccount = isSearchByMaAccount
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.totalMembers = try values.decodeIfPresent(Int.self, forKey: "total_members")
        self.type = try `Type`(from: decoder)
        self.isSearchByDomain = try values.decodeIfPresent(Bool.self, forKey: "search_by_domain")
        self.isSearchByAccount = try values.decodeIfPresent(Bool.self, forKey: "search_by_account")
        self.isSearchByMaAccount = try values.decodeIfPresent(Bool.self, forKey: "search_by_ma_account")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(totalMembers, forKey: "total_members")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encodeIfPresent(isSearchByDomain, forKey: "search_by_domain")
        try values.encodeIfPresent(isSearchByAccount, forKey: "search_by_account")
        try values.encodeIfPresent(isSearchByMaAccount, forKey: "search_by_ma_account")
    }
}

/// Group member object.
public struct GroupMember: Codable {
    /// User ID.
    public var id: String?
    /// User email.
    public var email: String?
    /// User first name.
    public var firstName: String?
    /// User last name.
    public var lastName: String?
    /// User type.<br>
    /// `1` - Basic<br> `2` - Licensed<br> 
    /// `3` - On-prem
    public var type: Int?

    public init(id: String? = nil, email: String? = nil, firstName: String? = nil, lastName: String? = nil, type: Int? = nil) {
        self.id = id
        self.email = email
        self.firstName = firstName
        self.lastName = lastName
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case email
        case firstName = "first_name"
        case lastName = "last_name"
        case type
    }
}

/// List of Group Members.
public struct GroupMemberList: Codable {
    /// The number of pages returned for the request made.
    public var pageCount: Int?
    /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
    public var pageNumber: Int?
    /// The number of records returned with a single API call.
    public var pageSize: Int?
    /// The total number of all the records available across pages.
    public var totalRecords: Int?
    /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
    public var nextPageToken: String?
    /// List of Group member objects.
    public var members: [Member]?

    /// Group member object.
    public struct Member: Codable {
        /// User ID.
        public var id: String?
        /// User email.
        public var email: String?
        /// User first name.
        public var firstName: String?
        /// User last name.
        public var lastName: String?
        /// User type.<br>
        /// `1` - Basic<br> `2` - Licensed<br> 
        /// `3` - On-prem
        public var type: Int?

        public init(id: String? = nil, email: String? = nil, firstName: String? = nil, lastName: String? = nil, type: Int? = nil) {
            self.id = id
            self.email = email
            self.firstName = firstName
            self.lastName = lastName
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case email
            case firstName = "first_name"
            case lastName = "last_name"
            case type
        }
    }

    public init(pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil, members: [Member]? = nil) {
        self.pageCount = pageCount
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.totalRecords = totalRecords
        self.nextPageToken = nextPageToken
        self.members = members
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.pageCount = try values.decodeIfPresent(Int.self, forKey: "page_count")
        self.pageNumber = try values.decodeIfPresent(Int.self, forKey: "page_number")
        self.pageSize = try values.decodeIfPresent(Int.self, forKey: "page_size")
        self.totalRecords = try values.decodeIfPresent(Int.self, forKey: "total_records")
        self.nextPageToken = try values.decodeIfPresent(String.self, forKey: "next_page_token")
        self.members = try values.decodeIfPresent([Member].self, forKey: "members")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(pageCount, forKey: "page_count")
        try values.encodeIfPresent(pageNumber, forKey: "page_number")
        try values.encodeIfPresent(pageSize, forKey: "page_size")
        try values.encodeIfPresent(totalRecords, forKey: "total_records")
        try values.encodeIfPresent(nextPageToken, forKey: "next_page_token")
        try values.encodeIfPresent(members, forKey: "members")
    }
}

/// List of IM Groups.
public struct IMGroupList: Codable {
    /// Total number of records returned.
    public var totalRecords: Int?
    /// List of group objects.
    public var groups: [Group]?

    public struct Group: Codable {
        /// IM group ID.
        public var id: String?
        /// IM group object.
        public var b: B

        /// IM group object.
        public struct B: Codable {
            /// Group name.
            public var name: String?
            /// Total number of members in this group.
            public var totalMembers: Int?
            /// IM Group types:<br>`normal` - Only members can see the other members in the group. Other people can search for members in the group.<br>`shared` - Everyone in the account can see the group and members. <br>`restricted` - No one except group members can see the group or search for other group members.
            public var type: `Type`?
            /// Members can search for others in the same email domain.
            public var isSearchByDomain: Bool?
            /// Members can search for others under same account.
            public var isSearchByAccount: Bool?
            /// Members can search for others under same master account - including all sub accounts.
            public var isSearchByMaAccount: Bool?

            /// IM Group types:<br>`normal` - Only members can see the other members in the group. Other people can search for members in the group.<br>`shared` - Everyone in the account can see the group and members. <br>`restricted` - No one except group members can see the group or search for other group members.
            public enum `Type`: String, Codable, CaseIterable {
                case normal
                case shared
                case restricted
            }

            public init(name: String? = nil, totalMembers: Int? = nil, type: `Type`? = nil, isSearchByDomain: Bool? = nil, isSearchByAccount: Bool? = nil, isSearchByMaAccount: Bool? = nil) {
                self.name = name
                self.totalMembers = totalMembers
                self.type = type
                self.isSearchByDomain = isSearchByDomain
                self.isSearchByAccount = isSearchByAccount
                self.isSearchByMaAccount = isSearchByMaAccount
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.name = try values.decodeIfPresent(String.self, forKey: "name")
                self.totalMembers = try values.decodeIfPresent(Int.self, forKey: "total_members")
                self.type = try `Type`(from: decoder)
                self.isSearchByDomain = try values.decodeIfPresent(Bool.self, forKey: "search_by_domain")
                self.isSearchByAccount = try values.decodeIfPresent(Bool.self, forKey: "search_by_account")
                self.isSearchByMaAccount = try values.decodeIfPresent(Bool.self, forKey: "search_by_ma_account")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(name, forKey: "name")
                try values.encodeIfPresent(totalMembers, forKey: "total_members")
                try values.encodeIfPresent(type, forKey: "type")
                try values.encodeIfPresent(isSearchByDomain, forKey: "search_by_domain")
                try values.encodeIfPresent(isSearchByAccount, forKey: "search_by_account")
                try values.encodeIfPresent(isSearchByMaAccount, forKey: "search_by_ma_account")
            }
        }

        public init(id: String? = nil, b: B) {
            self.id = id
            self.b = b
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.b = try B(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encode(b, forKey: "b")
        }
    }

    public init(totalRecords: Int? = nil, groups: [Group]? = nil) {
        self.totalRecords = totalRecords
        self.groups = groups
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.totalRecords = try values.decodeIfPresent(Int.self, forKey: "total_records")
        self.groups = try values.decodeIfPresent([Group].self, forKey: "groups")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(totalRecords, forKey: "total_records")
        try values.encodeIfPresent(groups, forKey: "groups")
    }
}

/// Meeting live stream.
public struct MeetingLiveStream: Codable {
    /// Streaming URL.
    public var streamURL: String
    /// Stream name and key.
    public var streamKey: String
    /// The live stream page URL.
    public var pageURL: URL

    public init(streamURL: String, streamKey: String, pageURL: URL) {
        self.streamURL = streamURL
        self.streamKey = streamKey
        self.pageURL = pageURL
    }

    private enum CodingKeys: String, CodingKey {
        case streamURL = "stream_url"
        case streamKey = "stream_key"
        case pageURL = "page_url"
    }
}

/// Meeting object.
public struct MeetingInfoGet: Codable {
    /// Meeting topic.
    public var topic: String?
    /// Meeting Types:<br>`1` - Instant meeting.<br>`2` - Scheduled meeting.<br>`3` - Recurring meeting with no fixed time.<br>`4` - PMI Meeting<br>
    /// `8` - Recurring meeting with a fixed time.
    public var type: Int?
    /// Whether the preschedule meeting was created via the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This **only** supports the meeting `type` value of `2` (scheduled meetings) and `3` (recurring meetings with no fixed time): 
    /// * `true` — A GSuite prescheduled meeting. 
    /// * `false` — A regular meeting.
    public var isPreSchedule: Bool
    /// Meeting status
    public var status: Status?
    /// Meeting start time in GMT/UTC. Start time will not be returned if the meeting is an **instant** meeting.
    public var startTime: Date?
    /// Meeting duration.
    public var duration: Int?
    /// Timezone to format the meeting start time on the .
    public var timezone: String?
    /// Time of creation.
    public var createdAt: Date?
    /// Meeting description
    public var agenda: String?
    /// <br><aside>The <code>start_url</code> of a Meeting is a URL using which a host or an alternative host can start the Meeting. 
    /// 
    /// The expiration time for the <code>start_url</code> field listed in the response of [Create a Meeting API](https://marketplace.zoom.us/docs/api-reference/zoom-api/meetings/meetingcreate) is two hours for all regular users. 
    /// 	
    /// For users created using the <code>custCreate</code> option via the [Create Users](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usercreate) API, the expiration time of the <code>start_url</code> field is 90 days.
    /// 	
    /// For security reasons, to retrieve the updated value for the <code>start_url</code> field programmatically (after the expiry time), you must call the [Retrieve a Meeting API](https://marketplace.zoom.us/docs/api-reference/zoom-api/meetings/meeting) and refer to the value of the <code>start_url</code> field in the response.</aside><br>This URL should only be used by the host of the meeting and **should not be shared with anyone other than the host** of the meeting as anyone with this URL will be able to login to the Zoom Client as the host of the meeting.
    public var startURL: String?
    /// URL for participants to join the meeting. This URL should only be shared with users that you would like to invite for the meeting.
    public var joinURL: String?
    /// Meeting passcode.
    public var password: String?
    /// H.323/SIP room system passcode.
    public var h323Password: String?
    /// Encrypted passcode for third party endpoints (H323/SIP).
    public var encryptedPassword: String?
    /// Personal Meeting Id. Only used for scheduled meetings and recurring meetings with no fixed time.
    public var pmi: Int?
    /// Tracking fields
    public var trackingFields: [TrackingField]?
    /// Array of occurrence objects.
    public var occurrences: [Occurrence]?
    /// Meeting settings.
    public var settings: Settings?
    /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
    public var recurrence: Recurrence?

    /// Meeting status
    public enum Status: String, Codable, CaseIterable {
        case waiting
        case started
    }

    public struct TrackingField: Codable {
        /// Label of the tracking field.
        public var field: String?
        /// Value for the field.
        public var value: String?
        /// Indicates whether the [tracking field](https://support.zoom.us/hc/en-us/articles/115000293426-Scheduling-Tracking-Fields) is visible in the meeting scheduling options in the Zoom Web Portal or not.
        /// 
        /// `true`: Tracking field is visible. <br>
        /// 
        /// `false`: Tracking field is not visible to the users when they look at the meeting details in the Zoom Web Portal but the field was used while scheduling this meeting via API. An invisible tracking field can be used by users while scheduling meetings via API only.
        public var isVisible: Bool?

        public init(field: String? = nil, value: String? = nil, isVisible: Bool? = nil) {
            self.field = field
            self.value = value
            self.isVisible = isVisible
        }

        private enum CodingKeys: String, CodingKey {
            case field
            case value
            case isVisible = "visible"
        }
    }

    /// Occurrence object. This object is only returned for Recurring Webinars.
    public struct Occurrence: Codable {
        /// Occurrence ID: Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences.
        public var occurrenceID: String?
        /// Start time.
        public var startTime: Date?
        /// Duration.
        public var duration: Int?
        /// Occurrence status.
        public var status: String?

        public init(occurrenceID: String? = nil, startTime: Date? = nil, duration: Int? = nil, status: String? = nil) {
            self.occurrenceID = occurrenceID
            self.startTime = startTime
            self.duration = duration
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case occurrenceID = "occurrence_id"
            case startTime = "start_time"
            case duration
            case status
        }
    }

    /// Meeting settings.
    public struct Settings: Codable {
        /// Start video when the host joins the meeting.
        public var isHostVideo: Bool?
        /// Start video when participants join the meeting.
        public var isParticipantVideo: Bool?
        /// Host meeting in China.
        public var isCnMeeting: Bool
        /// Host meeting in India.
        public var isInMeeting: Bool
        /// Allow participants to join the meeting before the host starts the meeting. Only used for scheduled or recurring meetings.
        public var isJoinBeforeHost: Bool
        /// If the value of "join_before_host" field is set to true, this field can be used to indicate time limits within which a participant may join a meeting before a host. The value of this field can be one of the following:
        /// 
        /// *  `0`: Allow participant to join anytime.
        /// *  `5`: Allow participant to join 5 minutes before meeting start time.
        ///  * `10`: Allow participant to join 10 minutes before meeting start time.
        public var jbhTime: Int?
        /// Mute participants upon entry.
        public var isMuteUponEntry: Bool
        /// Add watermark when viewing a shared screen.
        public var isWatermark: Bool
        /// Use a personal meeting ID. Only used for scheduled meetings and recurring meetings with no fixed time.
        public var usePmi: Bool
        /// Enable registration and set approval for the registration. Note that this feature requires the host to be of **Licensed** user type. **Registration cannot be enabled for a basic user.** <br><br>
        /// 
        /// `0` - Automatically approve.<br>`1` - Manually approve.<br>`2` - No registration required.
        public var approvalType: Int?
        /// Registration type. Used for recurring meeting with fixed time only. <br>`1` Attendees register once and can attend any of the occurrences.<br>`2` Attendees need to register for each occurrence to attend.<br>`3` Attendees register once and can choose one or more occurrences to attend.
        public var registrationType: Int?
        /// Determine how participants can join the audio portion of the meeting.<br>`both` - Both Telephony and VoIP.<br>`telephony` - Telephony only.<br>`voip` - VoIP only.
        public var audio: Audio?
        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public var autoRecording: AutoRecording?
        /// Only signed in users can join this meeting.
        /// 
        /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
        public var enforceLogin: Bool?
        /// Only signed in users with specified domains can join meetings.
        /// 
        /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
        public var enforceLoginDomains: String?
        /// A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.
        public var alternativeHosts: String?
        /// Close registration after event date
        public var isCloseRegistration: Bool
        /// Enable waiting room
        public var isWaitingRoom: Bool
        /// List of global dial-in countries
        public var globalDialInCountries: [String]?
        /// Global Dial-in Countries/Regions
        public var globalDialInNumbers: [GlobalDialInNumber]?
        /// Contact name for registration
        public var contactName: String?
        /// Contact email for registration
        public var contactEmail: String?
        /// Whether to send registrants email notifications about their registration approval, cancellation, or rejection:
        /// 
        /// * `true` — Send an email notification.
        /// * `false` — Do not send an email notification.
        /// 
        ///  Set this value to `true` to also use the `registrants_confirmation_email` parameter.
        public var isRegistrantsEmailNotification: Bool?
        /// Whether to send registrants an email confirmation:
        /// * `true` — Send a confirmation email.
        /// * `false` — Do not send a confirmation email.
        public var isRegistrantsConfirmationEmail: Bool?
        /// `true`- Only authenticated users can join meetings.
        public var isMeetingAuthentication: Bool?
        /// Meeting authentication option id.
        public var authenticationOption: String?
        /// If user has configured ["Sign Into Zoom with Specified Domains"](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
        public var authenticationDomains: String?
        /// Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
        public var authenticationName: String?
        /// Show social share buttons on the meeting registration page.
        /// This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
        public var isShowShareButton: Bool?
        /// Allow attendees to join the meeting from multiple devices. This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
        public var allowMultipleDevices: Bool?
        /// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
        /// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
        /// 
        /// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
        public var encryptionType: EncryptionType?
        /// Approve or block users from specific regions/countries from joining this meeting.
        public var approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions?
        /// The participants added here will receive unique meeting invite links and bypass authentication.
        public var authenticationException: [AuthenticationExceptionItem]?
        /// Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
        public var breakoutRoom: BreakoutRoom?
        /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
        /// 
        /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
        public var languageInterpretation: LanguageInterpretation?
        /// Custom keys and values assigned to the meeting.
        public var customKeys: [CustomKey]?
        /// Flag to determine whether to send email notifications to alternative hosts, default value is true.
        public var isAlternativeHostsEmailNotification: Bool
        /// Whether the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) is enabled when the meeting starts.
        public var isFocusMode: Bool?
        /// Whether the meeting is set as private.
        public var isPrivateMeeting: Bool?
        /// The calendar type: 
        /// * `1` — Outlook calendar. 
        /// * `2` — Google Calendar.
        public var calendarType: Int?

        /// Determine how participants can join the audio portion of the meeting.<br>`both` - Both Telephony and VoIP.<br>`telephony` - Telephony only.<br>`voip` - VoIP only.
        public enum Audio: String, Codable, CaseIterable {
            case both
            case telephony
            case voip
        }

        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public enum AutoRecording: String, Codable, CaseIterable {
            case local
            case cloud
            case `none`
        }

        public struct GlobalDialInNumber: Codable {
            /// Country code. For example, BR.
            public var country: String?
            /// Full name of country. For example, Brazil.
            public var countryName: String?
            /// City of the number, if any. For example, Chicago.
            public var city: String?
            /// Phone number. For example, +1 2332357613.
            public var number: String?
            /// Type of number.
            public var type: `Type`?

            /// Type of number.
            public enum `Type`: String, Codable, CaseIterable {
                case toll
                case tollfree
            }

            public init(country: String? = nil, countryName: String? = nil, city: String? = nil, number: String? = nil, type: `Type`? = nil) {
                self.country = country
                self.countryName = countryName
                self.city = city
                self.number = number
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case country
                case countryName = "country_name"
                case city
                case number
                case type
            }
        }

        /// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
        /// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
        /// 
        /// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
        public enum EncryptionType: String, Codable, CaseIterable {
            case enhancedEncryption = "enhanced_encryption"
            case e2ee
        }

        /// Approve or block users from specific regions/countries from joining this meeting.
        public struct ApprovedOrDeniedCountriesOrRegions: Codable {
            /// `true`: Setting enabled to either allow users or block users from specific regions to join your meetings. <br>
            /// 
            /// `false`: Setting disabled.
            public var enable: Bool?
            /// Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting. <br><br>
            /// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.<br><br>
            /// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
            public var method: Method?
            /// List of countries/regions from where participants can join this meeting.
            public var approvedList: [String]?
            /// List of countries/regions from where participants can not join this meeting.
            public var deniedList: [String]?

            /// Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting. <br><br>
            /// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.<br><br>
            /// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
            public enum Method: String, Codable, CaseIterable {
                case approve
                case deny
            }

            public init(enable: Bool? = nil, method: Method? = nil, approvedList: [String]? = nil, deniedList: [String]? = nil) {
                self.enable = enable
                self.method = method
                self.approvedList = approvedList
                self.deniedList = deniedList
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case method
                case approvedList = "approved_list"
                case deniedList = "denied_list"
            }
        }

        public struct AuthenticationExceptionItem: Codable {
            /// Name of the participant.
            public var name: String?
            /// Email address of the participant.
            public var email: String?

            public init(name: String? = nil, email: String? = nil) {
                self.name = name
                self.email = email
            }
        }

        /// Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
        public struct BreakoutRoom: Codable {
            /// Set the value of this field to `true` if you would like to enable the [breakout room pre-assign](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4) option.
            public var enable: Bool?
            /// Create room(s).
            public var rooms: [Room]?

            public struct Room: Codable {
                /// Name of the breakout room.
                public var name: String?
                /// Email addresses of the participants who are to be assigned to the breakout room.
                public var participants: [String]?

                public init(name: String? = nil, participants: [String]? = nil) {
                    self.name = name
                    self.participants = participants
                }
            }

            public init(enable: Bool? = nil, rooms: [Room]? = nil) {
                self.enable = enable
                self.rooms = rooms
            }
        }

        /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
        /// 
        /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
        public struct LanguageInterpretation: Codable {
            /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the meeting.
            public var enable: Bool?
            /// Information about the meeting's language interpreters.
            public var interpreters: [Interpreter]?

            public struct Interpreter: Codable {
                /// The interpreter's email address.
                public var email: String?
                /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
                /// 
                /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
                public var languages: String?

                public init(email: String? = nil, languages: String? = nil) {
                    self.email = email
                    self.languages = languages
                }
            }

            public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
                self.enable = enable
                self.interpreters = interpreters
            }
        }

        public struct CustomKey: Codable {
            /// Custom key associated with the user.
            public var key: String?
            /// Value of the custom key associated with the user.
            public var value: String?

            public init(key: String? = nil, value: String? = nil) {
                self.key = key
                self.value = value
            }
        }

        public init(isHostVideo: Bool? = nil, isParticipantVideo: Bool? = nil, isCnMeeting: Bool? = nil, isInMeeting: Bool? = nil, isJoinBeforeHost: Bool? = nil, jbhTime: Int? = nil, isMuteUponEntry: Bool? = nil, isWatermark: Bool? = nil, usePmi: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, enforceLogin: Bool? = nil, enforceLoginDomains: String? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isWaitingRoom: Bool? = nil, globalDialInCountries: [String]? = nil, globalDialInNumbers: [GlobalDialInNumber]? = nil, contactName: String? = nil, contactEmail: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isRegistrantsConfirmationEmail: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, authenticationName: String? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, encryptionType: EncryptionType? = nil, approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions? = nil, authenticationException: [AuthenticationExceptionItem]? = nil, breakoutRoom: BreakoutRoom? = nil, languageInterpretation: LanguageInterpretation? = nil, customKeys: [CustomKey]? = nil, isAlternativeHostsEmailNotification: Bool? = nil, isFocusMode: Bool? = nil, isPrivateMeeting: Bool? = nil, calendarType: Int? = nil) {
            self.isHostVideo = isHostVideo
            self.isParticipantVideo = isParticipantVideo
            self.isCnMeeting = isCnMeeting ?? false
            self.isInMeeting = isInMeeting ?? false
            self.isJoinBeforeHost = isJoinBeforeHost ?? false
            self.jbhTime = jbhTime
            self.isMuteUponEntry = isMuteUponEntry ?? false
            self.isWatermark = isWatermark ?? false
            self.usePmi = usePmi ?? false
            self.approvalType = approvalType
            self.registrationType = registrationType
            self.audio = audio
            self.autoRecording = autoRecording
            self.enforceLogin = enforceLogin
            self.enforceLoginDomains = enforceLoginDomains
            self.alternativeHosts = alternativeHosts
            self.isCloseRegistration = isCloseRegistration ?? false
            self.isWaitingRoom = isWaitingRoom ?? false
            self.globalDialInCountries = globalDialInCountries
            self.globalDialInNumbers = globalDialInNumbers
            self.contactName = contactName
            self.contactEmail = contactEmail
            self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
            self.isRegistrantsConfirmationEmail = isRegistrantsConfirmationEmail
            self.isMeetingAuthentication = isMeetingAuthentication
            self.authenticationOption = authenticationOption
            self.authenticationDomains = authenticationDomains
            self.authenticationName = authenticationName
            self.isShowShareButton = isShowShareButton
            self.allowMultipleDevices = allowMultipleDevices
            self.encryptionType = encryptionType
            self.approvedOrDeniedCountriesOrRegions = approvedOrDeniedCountriesOrRegions
            self.authenticationException = authenticationException
            self.breakoutRoom = breakoutRoom
            self.languageInterpretation = languageInterpretation
            self.customKeys = customKeys
            self.isAlternativeHostsEmailNotification = isAlternativeHostsEmailNotification ?? true
            self.isFocusMode = isFocusMode
            self.isPrivateMeeting = isPrivateMeeting
            self.calendarType = calendarType
        }

        private enum CodingKeys: String, CodingKey {
            case isHostVideo = "host_video"
            case isParticipantVideo = "participant_video"
            case isCnMeeting = "cn_meeting"
            case isInMeeting = "in_meeting"
            case isJoinBeforeHost = "join_before_host"
            case jbhTime = "jbh_time"
            case isMuteUponEntry = "mute_upon_entry"
            case isWatermark = "watermark"
            case usePmi = "use_pmi"
            case approvalType = "approval_type"
            case registrationType = "registration_type"
            case audio
            case autoRecording = "auto_recording"
            case enforceLogin = "enforce_login"
            case enforceLoginDomains = "enforce_login_domains"
            case alternativeHosts = "alternative_hosts"
            case isCloseRegistration = "close_registration"
            case isWaitingRoom = "waiting_room"
            case globalDialInCountries = "global_dial_in_countries"
            case globalDialInNumbers = "global_dial_in_numbers"
            case contactName = "contact_name"
            case contactEmail = "contact_email"
            case isRegistrantsEmailNotification = "registrants_email_notification"
            case isRegistrantsConfirmationEmail = "registrants_confirmation_email"
            case isMeetingAuthentication = "meeting_authentication"
            case authenticationOption = "authentication_option"
            case authenticationDomains = "authentication_domains"
            case authenticationName = "authentication_name"
            case isShowShareButton = "show_share_button"
            case allowMultipleDevices = "allow_multiple_devices"
            case encryptionType = "encryption_type"
            case approvedOrDeniedCountriesOrRegions = "approved_or_denied_countries_or_regions"
            case authenticationException = "authentication_exception"
            case breakoutRoom = "breakout_room"
            case languageInterpretation = "language_interpretation"
            case customKeys = "custom_keys"
            case isAlternativeHostsEmailNotification = "alternative_hosts_email_notification"
            case isFocusMode = "focus_mode"
            case isPrivateMeeting = "private_meeting"
            case calendarType = "calendar_type"
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.isHostVideo = try values.decodeIfPresent(Bool.self, forKey: .isHostVideo)
            self.isParticipantVideo = try values.decodeIfPresent(Bool.self, forKey: .isParticipantVideo)
            self.isCnMeeting = try values.decodeIfPresent(Bool.self, forKey: .isCnMeeting) ?? false
            self.isInMeeting = try values.decodeIfPresent(Bool.self, forKey: .isInMeeting) ?? false
            self.isJoinBeforeHost = try values.decodeIfPresent(Bool.self, forKey: .isJoinBeforeHost) ?? false
            self.jbhTime = try values.decodeIfPresent(Int.self, forKey: .jbhTime)
            self.isMuteUponEntry = try values.decodeIfPresent(Bool.self, forKey: .isMuteUponEntry) ?? false
            self.isWatermark = try values.decodeIfPresent(Bool.self, forKey: .isWatermark) ?? false
            self.usePmi = try values.decodeIfPresent(Bool.self, forKey: .usePmi) ?? false
            self.approvalType = try values.decodeIfPresent(Int.self, forKey: .approvalType)
            self.registrationType = try values.decodeIfPresent(Int.self, forKey: .registrationType)
            self.audio = try values.decodeIfPresent(Audio.self, forKey: .audio)
            self.autoRecording = try values.decodeIfPresent(AutoRecording.self, forKey: .autoRecording)
            self.enforceLogin = try values.decodeIfPresent(Bool.self, forKey: .enforceLogin)
            self.enforceLoginDomains = try values.decodeIfPresent(String.self, forKey: .enforceLoginDomains)
            self.alternativeHosts = try values.decodeIfPresent(String.self, forKey: .alternativeHosts)
            self.isCloseRegistration = try values.decodeIfPresent(Bool.self, forKey: .isCloseRegistration) ?? false
            self.isWaitingRoom = try values.decodeIfPresent(Bool.self, forKey: .isWaitingRoom) ?? false
            self.globalDialInCountries = try values.decodeIfPresent([String].self, forKey: .globalDialInCountries)
            self.globalDialInNumbers = try values.decodeIfPresent([GlobalDialInNumber].self, forKey: .globalDialInNumbers)
            self.contactName = try values.decodeIfPresent(String.self, forKey: .contactName)
            self.contactEmail = try values.decodeIfPresent(String.self, forKey: .contactEmail)
            self.isRegistrantsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsEmailNotification)
            self.isRegistrantsConfirmationEmail = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsConfirmationEmail)
            self.isMeetingAuthentication = try values.decodeIfPresent(Bool.self, forKey: .isMeetingAuthentication)
            self.authenticationOption = try values.decodeIfPresent(String.self, forKey: .authenticationOption)
            self.authenticationDomains = try values.decodeIfPresent(String.self, forKey: .authenticationDomains)
            self.authenticationName = try values.decodeIfPresent(String.self, forKey: .authenticationName)
            self.isShowShareButton = try values.decodeIfPresent(Bool.self, forKey: .isShowShareButton)
            self.allowMultipleDevices = try values.decodeIfPresent(Bool.self, forKey: .allowMultipleDevices)
            self.encryptionType = try values.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
            self.approvedOrDeniedCountriesOrRegions = try values.decodeIfPresent(ApprovedOrDeniedCountriesOrRegions.self, forKey: .approvedOrDeniedCountriesOrRegions)
            self.authenticationException = try values.decodeIfPresent([AuthenticationExceptionItem].self, forKey: .authenticationException)
            self.breakoutRoom = try values.decodeIfPresent(BreakoutRoom.self, forKey: .breakoutRoom)
            self.languageInterpretation = try values.decodeIfPresent(LanguageInterpretation.self, forKey: .languageInterpretation)
            self.customKeys = try values.decodeIfPresent([CustomKey].self, forKey: .customKeys)
            self.isAlternativeHostsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isAlternativeHostsEmailNotification) ?? true
            self.isFocusMode = try values.decodeIfPresent(Bool.self, forKey: .isFocusMode)
            self.isPrivateMeeting = try values.decodeIfPresent(Bool.self, forKey: .isPrivateMeeting)
            self.calendarType = try values.decodeIfPresent(Int.self, forKey: .calendarType)
        }
    }

    /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
    public struct Recurrence: Codable {
        /// Recurrence meeting types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
        public var type: Int
        /// Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
        /// 
        /// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
        public var repeatInterval: Int?
        /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
        /// 
        ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public var weeklyDays: WeeklyDays?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
        /// 
        /// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
        public var monthlyDay: Int?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
        public var monthlyWeek: Int?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field. 
        /// 
        /// <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public var monthlyWeekDay: Int?
        /// Select how many times the meeting should recur before it is canceled. (Cannot be used with "end_date_time".)
        public var endTimes: Int?
        /// Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
        public var endDateTime: Date?

        /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
        /// 
        ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public enum WeeklyDays: String, Codable, CaseIterable {
            case _1 = "1"
            case _2 = "2"
            case _3 = "3"
            case _4 = "4"
            case _5 = "5"
            case _6 = "6"
            case _7 = "7"
        }

        public init(type: Int, repeatInterval: Int? = nil, weeklyDays: WeeklyDays? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
            self.type = type
            self.repeatInterval = repeatInterval
            self.weeklyDays = weeklyDays
            self.monthlyDay = monthlyDay
            self.monthlyWeek = monthlyWeek
            self.monthlyWeekDay = monthlyWeekDay
            self.endTimes = endTimes
            self.endDateTime = endDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case repeatInterval = "repeat_interval"
            case weeklyDays = "weekly_days"
            case monthlyDay = "monthly_day"
            case monthlyWeek = "monthly_week"
            case monthlyWeekDay = "monthly_week_day"
            case endTimes = "end_times"
            case endDateTime = "end_date_time"
        }
    }

    public init(topic: String? = nil, type: Int? = nil, isPreSchedule: Bool? = nil, status: Status? = nil, startTime: Date? = nil, duration: Int? = nil, timezone: String? = nil, createdAt: Date? = nil, agenda: String? = nil, startURL: String? = nil, joinURL: String? = nil, password: String? = nil, h323Password: String? = nil, encryptedPassword: String? = nil, pmi: Int? = nil, trackingFields: [TrackingField]? = nil, occurrences: [Occurrence]? = nil, settings: Settings? = nil, recurrence: Recurrence? = nil) {
        self.topic = topic
        self.type = type
        self.isPreSchedule = isPreSchedule ?? false
        self.status = status
        self.startTime = startTime
        self.duration = duration
        self.timezone = timezone
        self.createdAt = createdAt
        self.agenda = agenda
        self.startURL = startURL
        self.joinURL = joinURL
        self.password = password
        self.h323Password = h323Password
        self.encryptedPassword = encryptedPassword
        self.pmi = pmi
        self.trackingFields = trackingFields
        self.occurrences = occurrences
        self.settings = settings
        self.recurrence = recurrence
    }

    private enum CodingKeys: String, CodingKey {
        case topic
        case type
        case isPreSchedule = "pre_schedule"
        case status
        case startTime = "start_time"
        case duration
        case timezone
        case createdAt = "created_at"
        case agenda
        case startURL = "start_url"
        case joinURL = "join_url"
        case password
        case h323Password = "h323_password"
        case encryptedPassword = "encrypted_password"
        case pmi
        case trackingFields = "tracking_fields"
        case occurrences
        case settings
        case recurrence
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.topic = try values.decodeIfPresent(String.self, forKey: .topic)
        self.type = try values.decodeIfPresent(Int.self, forKey: .type)
        self.isPreSchedule = try values.decodeIfPresent(Bool.self, forKey: .isPreSchedule) ?? false
        self.status = try values.decodeIfPresent(Status.self, forKey: .status)
        self.startTime = try values.decodeIfPresent(Date.self, forKey: .startTime)
        self.duration = try values.decodeIfPresent(Int.self, forKey: .duration)
        self.timezone = try values.decodeIfPresent(String.self, forKey: .timezone)
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: .createdAt)
        self.agenda = try values.decodeIfPresent(String.self, forKey: .agenda)
        self.startURL = try values.decodeIfPresent(String.self, forKey: .startURL)
        self.joinURL = try values.decodeIfPresent(String.self, forKey: .joinURL)
        self.password = try values.decodeIfPresent(String.self, forKey: .password)
        self.h323Password = try values.decodeIfPresent(String.self, forKey: .h323Password)
        self.encryptedPassword = try values.decodeIfPresent(String.self, forKey: .encryptedPassword)
        self.pmi = try values.decodeIfPresent(Int.self, forKey: .pmi)
        self.trackingFields = try values.decodeIfPresent([TrackingField].self, forKey: .trackingFields)
        self.occurrences = try values.decodeIfPresent([Occurrence].self, forKey: .occurrences)
        self.settings = try values.decodeIfPresent(Settings.self, forKey: .settings)
        self.recurrence = try values.decodeIfPresent(Recurrence.self, forKey: .recurrence)
    }
}

public struct RegistrantStatus: Codable {
    /// Registrant Status:<br>`approve` - Approve registrant.<br>`cancel` - Cancel previously approved registrant's registration.<br>`deny` - Deny registrant.
    public var action: Action
    /// List of registrants.
    public var registrants: [Registrant]?

    /// Registrant Status:<br>`approve` - Approve registrant.<br>`cancel` - Cancel previously approved registrant's registration.<br>`deny` - Deny registrant.
    public enum Action: String, Codable, CaseIterable {
        case approve
        case cancel
        case deny
    }

    public struct Registrant: Codable {
        public var id: String?
        public var email: String?

        public init(id: String? = nil, email: String? = nil) {
            self.id = id
            self.email = email
        }
    }

    public init(action: Action, registrants: [Registrant]? = nil) {
        self.action = action
        self.registrants = registrants
    }
}

/// Meeting invitation details.
public struct MeetingInvitation: Codable {
    /// Meeting invitation.
    public var invitation: String?

    public init(invitation: String? = nil) {
        self.invitation = invitation
    }
}

/// Meeting Survey Object
///
/// Information about the meeting survey.
public struct MeetingSurvey: Codable {
    /// The link to the third party meeting survey.
    public var thirdPartySurvey: String?
    /// Information about the customized meeting survey.
    public var customSurvey: CustomSurvey?
    /// Whether the **Show in the browser when the meeting ends** option is enabled: 
    /// * `true` — Enabled. 
    /// * `false` — Disabled. 
    /// 
    ///  This value defaults to `true`.
    public var isShowInTheBrowser: Bool

    /// Information about the customized meeting survey.
    public struct CustomSurvey: Codable {
        /// Whether to allow participants to anonymously answer survey questions: 
        /// * `true` — Anonymous survey enabled. 
        /// * `false` — Participants cannot answer survey questions anonymously. 
        /// 
        ///  This value defaults to `true`.
        public var isAnonymous: Bool
        /// Information about the meeting survey's questions.
        public var questions: [Question]?

        public struct Question: Codable {
            /// The survey question, up to 255 characters.
            public var name: String?
            /// The survey's question and answer type: 
            /// * `single` — Single choice. 
            /// * `mutliple` — Multiple choice. 
            /// * `rating_scale` — Rating scale. 
            /// * `long_answer` — Long answer.
            public var type: `Type`?
            /// Whether to display the radio selection as a drop-down box: 
            /// * `true` — Show as a drop-down box. 
            /// * `false` — Do not show as a drop-down box. 
            /// 
            ///  This value defaults to `false`.
            public var isShowAsDropdown: Bool
            /// Whether participants must answer the question: 
            /// * `true` — The participant must answer the question. 
            /// * `false` — The participant does not need to answer the question. 
            /// 
            ///  This value defaults to `false`.
            public var isAnswerRequired: Bool
            /// The survey question's available answers. This field requires a **minimum** of two answers. 
            /// 
            /// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers. 
            /// * For `matching` polls, you can only provide a maximum of 16 answers. 
            /// * For `rank_order` polls, you can only provide a maximum of seven answers.
            public var answers: [String]?
            /// The allowed minimum number of characters. This field only applies to `long_answer` survey. You must provide at least a **one** character minimum value.
            public var answerMinCharacter: Int?
            /// The allowed maximum number of characters. This field only applies to `long_answer` survey, a maximum of 2,000 characters.
            public var answerMaxCharacter: Int?
            /// The rating scale's minimum value. This value cannot be less than zero. 
            /// 
            ///  This field only applies to the `rating_scale` survey.
            public var ratingMinValue: Int?
            /// The rating scale's maximum value, up to a maximum value of 10. 
            /// 
            ///  This field only applies to the `rating_scale` survey.
            public var ratingMaxValue: Int?
            /// The low score label used for the `rating_min_value` field. 
            /// 
            /// T his field only applies to the `rating_scale` survey.
            public var ratingMinLabel: String?
            /// The high score label used for the `rating_max_value` field. 
            /// 
            ///  This field only applies to the `rating_scale` survey.
            public var ratingMaxLabel: String?

            /// The survey's question and answer type: 
            /// * `single` — Single choice. 
            /// * `mutliple` — Multiple choice. 
            /// * `rating_scale` — Rating scale. 
            /// * `long_answer` — Long answer.
            public enum `Type`: String, Codable, CaseIterable {
                case single
                case multiple
                case ratingScale = "rating_scale"
                case longAnswer = "long_answer"
            }

            public init(name: String? = nil, type: `Type`? = nil, isShowAsDropdown: Bool? = nil, isAnswerRequired: Bool? = nil, answers: [String]? = nil, answerMinCharacter: Int? = nil, answerMaxCharacter: Int? = nil, ratingMinValue: Int? = nil, ratingMaxValue: Int? = nil, ratingMinLabel: String? = nil, ratingMaxLabel: String? = nil) {
                self.name = name
                self.type = type
                self.isShowAsDropdown = isShowAsDropdown ?? false
                self.isAnswerRequired = isAnswerRequired ?? false
                self.answers = answers
                self.answerMinCharacter = answerMinCharacter
                self.answerMaxCharacter = answerMaxCharacter
                self.ratingMinValue = ratingMinValue
                self.ratingMaxValue = ratingMaxValue
                self.ratingMinLabel = ratingMinLabel
                self.ratingMaxLabel = ratingMaxLabel
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case type
                case isShowAsDropdown = "show_as_dropdown"
                case isAnswerRequired = "answer_required"
                case answers
                case answerMinCharacter = "answer_min_character"
                case answerMaxCharacter = "answer_max_character"
                case ratingMinValue = "rating_min_value"
                case ratingMaxValue = "rating_max_value"
                case ratingMinLabel = "rating_min_label"
                case ratingMaxLabel = "rating_max_label"
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: CodingKeys.self)
                self.name = try values.decodeIfPresent(String.self, forKey: .name)
                self.type = try values.decodeIfPresent(`Type`.self, forKey: .type)
                self.isShowAsDropdown = try values.decodeIfPresent(Bool.self, forKey: .isShowAsDropdown) ?? false
                self.isAnswerRequired = try values.decodeIfPresent(Bool.self, forKey: .isAnswerRequired) ?? false
                self.answers = try values.decodeIfPresent([String].self, forKey: .answers)
                self.answerMinCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMinCharacter)
                self.answerMaxCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMaxCharacter)
                self.ratingMinValue = try values.decodeIfPresent(Int.self, forKey: .ratingMinValue)
                self.ratingMaxValue = try values.decodeIfPresent(Int.self, forKey: .ratingMaxValue)
                self.ratingMinLabel = try values.decodeIfPresent(String.self, forKey: .ratingMinLabel)
                self.ratingMaxLabel = try values.decodeIfPresent(String.self, forKey: .ratingMaxLabel)
            }
        }

        public init(isAnonymous: Bool? = nil, questions: [Question]? = nil) {
            self.isAnonymous = isAnonymous ?? false
            self.questions = questions
        }

        private enum CodingKeys: String, CodingKey {
            case isAnonymous = "anonymous"
            case questions
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.isAnonymous = try values.decodeIfPresent(Bool.self, forKey: .isAnonymous) ?? false
            self.questions = try values.decodeIfPresent([Question].self, forKey: .questions)
        }
    }

    public init(thirdPartySurvey: String? = nil, customSurvey: CustomSurvey? = nil, isShowInTheBrowser: Bool? = nil) {
        self.thirdPartySurvey = thirdPartySurvey
        self.customSurvey = customSurvey
        self.isShowInTheBrowser = isShowInTheBrowser ?? true
    }

    private enum CodingKeys: String, CodingKey {
        case thirdPartySurvey = "third_party_survey"
        case customSurvey = "custom_survey"
        case isShowInTheBrowser = "show_in_the_browser"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.thirdPartySurvey = try values.decodeIfPresent(String.self, forKey: .thirdPartySurvey)
        self.customSurvey = try values.decodeIfPresent(CustomSurvey.self, forKey: .customSurvey)
        self.isShowInTheBrowser = try values.decodeIfPresent(Bool.self, forKey: .isShowInTheBrowser) ?? true
    }
}

/// Base object for sessions.
public struct SessionUpdate: Codable {
    /// Meeting topic.
    public var topic: String?
    /// Meeting Types:<br>`1` - Instant meeting.<br>`2` - Scheduled meeting.<br>`3` - Recurring meeting with no fixed time.<br>`8` - Recurring meeting with a fixed time.
    public var type: Int?
    /// Whether to create a prescheduled meeting via the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This **only** supports the meeting `type` value of `2` (scheduled meetings) and `3` (recurring meetings with no fixed time): 
    /// * `true` — Create a prescheduled meeting. 
    /// * `false` — Create a regular meeting.
    public var isPreSchedule: Bool
    /// Meeting start time. When using a format like "yyyy-MM-dd'T'HH:mm:ss'Z'", always use GMT time. When using a format like "yyyy-MM-dd'T'HH:mm:ss", you should use local time and  specify the time zone. Only used for scheduled meetings and recurring meetings with a fixed time.
    public var startTime: Date?
    /// Meeting duration (minutes). Used for scheduled meetings only.
    public var duration: Int?
    /// Time zone to format start_time. For example, "America/Los_Angeles". For scheduled meetings only. Please reference our [time zone](#timezones) list for supported time zones and their formats.
    public var timezone: String?
    /// Meeting passcode. Passcode may only contain the following characters: [a-z A-Z 0-9 @ - _ *] and can have a maximum of 10 characters.
    /// 
    /// **Note:** If the account owner or the admin has configured [minimum passcode requirement settings](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604), the passcode value provided here must meet those requirements. <br><br>If the requirements are enabled, you can view those requirements by calling either the [Get User Settings API](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings) or the  [Get Account Settings](https://marketplace.zoom.us/docs/api-reference/zoom-api/accounts/accountsettings) API.
    public var password: String?
    /// Meeting description.
    public var agenda: String?
    /// Unique identifier of the meeting template. 
    /// 
    /// Use this field if you would like to [schedule the meeting from a meeting template](https://support.zoom.us/hc/en-us/articles/360036559151-Meeting-templates#h_86f06cff-0852-4998-81c5-c83663c176fb). You can retrieve the value of this field by calling the [List meeting templates]() API.
    public var templateID: String?
    /// Tracking fields
    public var trackingFields: [TrackingField]?
    /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
    public var recurrence: Recurrence?
    public var settings: Settings?

    public struct TrackingField: Codable {
        /// Tracking fields type
        public var field: String?
        /// Tracking fields value
        public var value: String?

        public init(field: String? = nil, value: String? = nil) {
            self.field = field
            self.value = value
        }
    }

    /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
    public struct Recurrence: Codable {
        /// Recurrence meeting types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
        public var type: Int
        /// Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
        /// 
        /// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
        public var repeatInterval: Int?
        /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
        /// 
        ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public var weeklyDays: WeeklyDays?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
        /// 
        /// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
        public var monthlyDay: Int?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
        public var monthlyWeek: Int?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field. 
        /// 
        /// <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public var monthlyWeekDay: Int?
        /// Select how many times the meeting should recur before it is canceled. (Cannot be used with "end_date_time".)
        public var endTimes: Int?
        /// Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
        public var endDateTime: Date?

        /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
        /// 
        ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public enum WeeklyDays: String, Codable, CaseIterable {
            case _1 = "1"
            case _2 = "2"
            case _3 = "3"
            case _4 = "4"
            case _5 = "5"
            case _6 = "6"
            case _7 = "7"
        }

        public init(type: Int, repeatInterval: Int? = nil, weeklyDays: WeeklyDays? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
            self.type = type
            self.repeatInterval = repeatInterval
            self.weeklyDays = weeklyDays
            self.monthlyDay = monthlyDay
            self.monthlyWeek = monthlyWeek
            self.monthlyWeekDay = monthlyWeekDay
            self.endTimes = endTimes
            self.endDateTime = endDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case repeatInterval = "repeat_interval"
            case weeklyDays = "weekly_days"
            case monthlyDay = "monthly_day"
            case monthlyWeek = "monthly_week"
            case monthlyWeekDay = "monthly_week_day"
            case endTimes = "end_times"
            case endDateTime = "end_date_time"
        }
    }

    public struct Settings: Codable {
        /// Start video when the host joins the meeting.
        public var isHostVideo: Bool?
        /// Start video when participants join the meeting.
        public var isParticipantVideo: Bool?
        /// Host meeting in China.
        public var isCnMeeting: Bool
        /// Host meeting in India.
        public var isInMeeting: Bool
        /// Allow participants to join the meeting before the host starts the meeting. Only used for scheduled or recurring meetings.
        public var isJoinBeforeHost: Bool
        /// If the value of "join_before_host" field is set to true, this field can be used to indicate time limits within which a participant may join a meeting before a host. The value of this field can be one of the following:
        /// 
        /// *  `0`: Allow participant to join anytime.
        /// *  `5`: Allow participant to join 5 minutes before meeting start time.
        ///  * `10`: Allow participant to join 10 minutes before meeting start time.
        public var jbhTime: Int?
        /// Mute participants upon entry.
        public var isMuteUponEntry: Bool
        /// Add watermark when viewing a shared screen.
        public var isWatermark: Bool
        /// Use a personal meeting ID. Only used for scheduled meetings and recurring meetings with no fixed time.
        public var usePmi: Bool
        /// Enable registration and set approval for the registration. Note that this feature requires the host to be of **Licensed** user type. **Registration cannot be enabled for a basic user.** <br><br>
        /// 
        /// `0` - Automatically approve.<br>`1` - Manually approve.<br>`2` - No registration required.
        public var approvalType: Int?
        /// Registration type. Used for recurring meeting with fixed time only. <br>`1` Attendees register once and can attend any of the occurrences.<br>`2` Attendees need to register for each occurrence to attend.<br>`3` Attendees register once and can choose one or more occurrences to attend.
        public var registrationType: Int?
        /// Determine how participants can join the audio portion of the meeting.<br>`both` - Both Telephony and VoIP.<br>`telephony` - Telephony only.<br>`voip` - VoIP only.
        public var audio: Audio?
        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public var autoRecording: AutoRecording?
        /// Only signed in users can join this meeting.
        /// 
        /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
        public var enforceLogin: Bool?
        /// Only signed in users with specified domains can join meetings.
        /// 
        /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
        public var enforceLoginDomains: String?
        /// A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.
        public var alternativeHosts: String?
        /// Close registration after event date
        public var isCloseRegistration: Bool
        /// Enable waiting room
        public var isWaitingRoom: Bool
        /// List of global dial-in countries
        public var globalDialInCountries: [String]?
        /// Global Dial-in Countries/Regions
        public var globalDialInNumbers: [GlobalDialInNumber]?
        /// Contact name for registration
        public var contactName: String?
        /// Contact email for registration
        public var contactEmail: String?
        /// Whether to send registrants email notifications about their registration approval, cancellation, or rejection:
        /// 
        /// * `true` — Send an email notification.
        /// * `false` — Do not send an email notification.
        /// 
        ///  Set this value to `true` to also use the `registrants_confirmation_email` parameter.
        public var isRegistrantsEmailNotification: Bool?
        /// Whether to send registrants an email confirmation:
        /// * `true` — Send a confirmation email.
        /// * `false` — Do not send a confirmation email.
        public var isRegistrantsConfirmationEmail: Bool?
        /// `true`- Only authenticated users can join meetings.
        public var isMeetingAuthentication: Bool?
        /// Meeting authentication option id.
        public var authenticationOption: String?
        /// If user has configured ["Sign Into Zoom with Specified Domains"](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
        public var authenticationDomains: String?
        /// Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
        public var authenticationName: String?
        /// Show social share buttons on the meeting registration page.
        /// This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
        public var isShowShareButton: Bool?
        /// Allow attendees to join the meeting from multiple devices. This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
        public var allowMultipleDevices: Bool?
        /// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
        /// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
        /// 
        /// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
        public var encryptionType: EncryptionType?
        /// Approve or block users from specific regions/countries from joining this meeting.
        public var approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions?
        /// The participants added here will receive unique meeting invite links and bypass authentication.
        public var authenticationException: [AuthenticationExceptionItem]?
        /// Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
        public var breakoutRoom: BreakoutRoom?
        /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
        /// 
        /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
        public var languageInterpretation: LanguageInterpretation?
        /// Custom keys and values assigned to the meeting.
        public var customKeys: [CustomKey]?
        /// Flag to determine whether to send email notifications to alternative hosts, default value is true.
        public var isAlternativeHostsEmailNotification: Bool
        /// Whether the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) is enabled when the meeting starts.
        public var isFocusMode: Bool?
        /// Whether the meeting is set as private.
        public var isPrivateMeeting: Bool?
        /// The calendar type: 
        /// * `1` — Outlook calendar. 
        /// * `2` — Google Calendar.
        public var calendarType: Int?
        /// A list of the meeting's invitees.
        public var meetingInvitees: [MeetingInvitee]?

        /// Determine how participants can join the audio portion of the meeting.<br>`both` - Both Telephony and VoIP.<br>`telephony` - Telephony only.<br>`voip` - VoIP only.
        public enum Audio: String, Codable, CaseIterable {
            case both
            case telephony
            case voip
        }

        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public enum AutoRecording: String, Codable, CaseIterable {
            case local
            case cloud
            case `none`
        }

        public struct GlobalDialInNumber: Codable {
            /// Country code. For example, BR.
            public var country: String?
            /// Full name of country. For example, Brazil.
            public var countryName: String?
            /// City of the number, if any. For example, Chicago.
            public var city: String?
            /// Phone number. For example, +1 2332357613.
            public var number: String?
            /// Type of number.
            public var type: `Type`?

            /// Type of number.
            public enum `Type`: String, Codable, CaseIterable {
                case toll
                case tollfree
            }

            public init(country: String? = nil, countryName: String? = nil, city: String? = nil, number: String? = nil, type: `Type`? = nil) {
                self.country = country
                self.countryName = countryName
                self.city = city
                self.number = number
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case country
                case countryName = "country_name"
                case city
                case number
                case type
            }
        }

        /// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
        /// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
        /// 
        /// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
        public enum EncryptionType: String, Codable, CaseIterable {
            case enhancedEncryption = "enhanced_encryption"
            case e2ee
        }

        /// Approve or block users from specific regions/countries from joining this meeting.
        public struct ApprovedOrDeniedCountriesOrRegions: Codable {
            /// `true`: Setting enabled to either allow users or block users from specific regions to join your meetings. <br>
            /// 
            /// `false`: Setting disabled.
            public var enable: Bool?
            /// Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting. <br><br>
            /// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.<br><br>
            /// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
            public var method: Method?
            /// List of countries/regions from where participants can join this meeting.
            public var approvedList: [String]?
            /// List of countries/regions from where participants can not join this meeting.
            public var deniedList: [String]?

            /// Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting. <br><br>
            /// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.<br><br>
            /// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
            public enum Method: String, Codable, CaseIterable {
                case approve
                case deny
            }

            public init(enable: Bool? = nil, method: Method? = nil, approvedList: [String]? = nil, deniedList: [String]? = nil) {
                self.enable = enable
                self.method = method
                self.approvedList = approvedList
                self.deniedList = deniedList
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case method
                case approvedList = "approved_list"
                case deniedList = "denied_list"
            }
        }

        public struct AuthenticationExceptionItem: Codable {
            /// Name of the participant.
            public var name: String?
            /// Email address of the participant.
            public var email: String?

            public init(name: String? = nil, email: String? = nil) {
                self.name = name
                self.email = email
            }
        }

        /// Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
        public struct BreakoutRoom: Codable {
            /// Set the value of this field to `true` if you would like to enable the [breakout room pre-assign](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4) option.
            public var enable: Bool?
            /// Create room(s).
            public var rooms: [Room]?

            public struct Room: Codable {
                /// Name of the breakout room.
                public var name: String?
                /// Email addresses of the participants who are to be assigned to the breakout room.
                public var participants: [String]?

                public init(name: String? = nil, participants: [String]? = nil) {
                    self.name = name
                    self.participants = participants
                }
            }

            public init(enable: Bool? = nil, rooms: [Room]? = nil) {
                self.enable = enable
                self.rooms = rooms
            }
        }

        /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
        /// 
        /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
        public struct LanguageInterpretation: Codable {
            /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the meeting.
            public var enable: Bool?
            /// Information about the meeting's language interpreters.
            public var interpreters: [Interpreter]?

            public struct Interpreter: Codable {
                /// The interpreter's email address.
                public var email: String?
                /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
                /// 
                /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
                public var languages: String?

                public init(email: String? = nil, languages: String? = nil) {
                    self.email = email
                    self.languages = languages
                }
            }

            public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
                self.enable = enable
                self.interpreters = interpreters
            }
        }

        public struct CustomKey: Codable {
            /// Custom key associated with the user.
            public var key: String?
            /// Value of the custom key associated with the user.
            public var value: String?

            public init(key: String? = nil, value: String? = nil) {
                self.key = key
                self.value = value
            }
        }

        public struct MeetingInvitee: Codable {
            /// The invitee's email address.
            public var email: String?

            public init(email: String? = nil) {
                self.email = email
            }
        }

        public init(isHostVideo: Bool? = nil, isParticipantVideo: Bool? = nil, isCnMeeting: Bool? = nil, isInMeeting: Bool? = nil, isJoinBeforeHost: Bool? = nil, jbhTime: Int? = nil, isMuteUponEntry: Bool? = nil, isWatermark: Bool? = nil, usePmi: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, enforceLogin: Bool? = nil, enforceLoginDomains: String? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isWaitingRoom: Bool? = nil, globalDialInCountries: [String]? = nil, globalDialInNumbers: [GlobalDialInNumber]? = nil, contactName: String? = nil, contactEmail: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isRegistrantsConfirmationEmail: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, authenticationName: String? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, encryptionType: EncryptionType? = nil, approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions? = nil, authenticationException: [AuthenticationExceptionItem]? = nil, breakoutRoom: BreakoutRoom? = nil, languageInterpretation: LanguageInterpretation? = nil, customKeys: [CustomKey]? = nil, isAlternativeHostsEmailNotification: Bool? = nil, isFocusMode: Bool? = nil, isPrivateMeeting: Bool? = nil, calendarType: Int? = nil, meetingInvitees: [MeetingInvitee]? = nil) {
            self.isHostVideo = isHostVideo
            self.isParticipantVideo = isParticipantVideo
            self.isCnMeeting = isCnMeeting ?? false
            self.isInMeeting = isInMeeting ?? false
            self.isJoinBeforeHost = isJoinBeforeHost ?? false
            self.jbhTime = jbhTime
            self.isMuteUponEntry = isMuteUponEntry ?? false
            self.isWatermark = isWatermark ?? false
            self.usePmi = usePmi ?? false
            self.approvalType = approvalType
            self.registrationType = registrationType
            self.audio = audio
            self.autoRecording = autoRecording
            self.enforceLogin = enforceLogin
            self.enforceLoginDomains = enforceLoginDomains
            self.alternativeHosts = alternativeHosts
            self.isCloseRegistration = isCloseRegistration ?? false
            self.isWaitingRoom = isWaitingRoom ?? false
            self.globalDialInCountries = globalDialInCountries
            self.globalDialInNumbers = globalDialInNumbers
            self.contactName = contactName
            self.contactEmail = contactEmail
            self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
            self.isRegistrantsConfirmationEmail = isRegistrantsConfirmationEmail
            self.isMeetingAuthentication = isMeetingAuthentication
            self.authenticationOption = authenticationOption
            self.authenticationDomains = authenticationDomains
            self.authenticationName = authenticationName
            self.isShowShareButton = isShowShareButton
            self.allowMultipleDevices = allowMultipleDevices
            self.encryptionType = encryptionType
            self.approvedOrDeniedCountriesOrRegions = approvedOrDeniedCountriesOrRegions
            self.authenticationException = authenticationException
            self.breakoutRoom = breakoutRoom
            self.languageInterpretation = languageInterpretation
            self.customKeys = customKeys
            self.isAlternativeHostsEmailNotification = isAlternativeHostsEmailNotification ?? true
            self.isFocusMode = isFocusMode
            self.isPrivateMeeting = isPrivateMeeting
            self.calendarType = calendarType
            self.meetingInvitees = meetingInvitees
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isHostVideo = try values.decodeIfPresent(Bool.self, forKey: "host_video")
            self.isParticipantVideo = try values.decodeIfPresent(Bool.self, forKey: "participant_video")
            self.isCnMeeting = try values.decodeIfPresent(Bool.self, forKey: "cn_meeting") ?? false
            self.isInMeeting = try values.decodeIfPresent(Bool.self, forKey: "in_meeting") ?? false
            self.isJoinBeforeHost = try values.decodeIfPresent(Bool.self, forKey: "join_before_host") ?? false
            self.jbhTime = try values.decodeIfPresent(Int.self, forKey: "jbh_time")
            self.isMuteUponEntry = try values.decodeIfPresent(Bool.self, forKey: "mute_upon_entry") ?? false
            self.isWatermark = try values.decodeIfPresent(Bool.self, forKey: "watermark") ?? false
            self.usePmi = try values.decodeIfPresent(Bool.self, forKey: "use_pmi") ?? false
            self.approvalType = try values.decodeIfPresent(Int.self, forKey: "approval_type")
            self.registrationType = try values.decodeIfPresent(Int.self, forKey: "registration_type")
            self.audio = try Audio(from: decoder)
            self.autoRecording = try AutoRecording(from: decoder)
            self.enforceLogin = try values.decodeIfPresent(Bool.self, forKey: "enforce_login")
            self.enforceLoginDomains = try values.decodeIfPresent(String.self, forKey: "enforce_login_domains")
            self.alternativeHosts = try values.decodeIfPresent(String.self, forKey: "alternative_hosts")
            self.isCloseRegistration = try values.decodeIfPresent(Bool.self, forKey: "close_registration") ?? false
            self.isWaitingRoom = try values.decodeIfPresent(Bool.self, forKey: "waiting_room") ?? false
            self.globalDialInCountries = try values.decodeIfPresent([String].self, forKey: "global_dial_in_countries")
            self.globalDialInNumbers = try values.decodeIfPresent([GlobalDialInNumber].self, forKey: "global_dial_in_numbers")
            self.contactName = try values.decodeIfPresent(String.self, forKey: "contact_name")
            self.contactEmail = try values.decodeIfPresent(String.self, forKey: "contact_email")
            self.isRegistrantsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: "registrants_email_notification")
            self.isRegistrantsConfirmationEmail = try values.decodeIfPresent(Bool.self, forKey: "registrants_confirmation_email")
            self.isMeetingAuthentication = try values.decodeIfPresent(Bool.self, forKey: "meeting_authentication")
            self.authenticationOption = try values.decodeIfPresent(String.self, forKey: "authentication_option")
            self.authenticationDomains = try values.decodeIfPresent(String.self, forKey: "authentication_domains")
            self.authenticationName = try values.decodeIfPresent(String.self, forKey: "authentication_name")
            self.isShowShareButton = try values.decodeIfPresent(Bool.self, forKey: "show_share_button")
            self.allowMultipleDevices = try values.decodeIfPresent(Bool.self, forKey: "allow_multiple_devices")
            self.encryptionType = try EncryptionType(from: decoder)
            self.approvedOrDeniedCountriesOrRegions = try ApprovedOrDeniedCountriesOrRegions(from: decoder)
            self.authenticationException = try values.decodeIfPresent([AuthenticationExceptionItem].self, forKey: "authentication_exception")
            self.breakoutRoom = try BreakoutRoom(from: decoder)
            self.languageInterpretation = try LanguageInterpretation(from: decoder)
            self.customKeys = try values.decodeIfPresent([CustomKey].self, forKey: "custom_keys")
            self.isAlternativeHostsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: "alternative_hosts_email_notification") ?? true
            self.isFocusMode = try values.decodeIfPresent(Bool.self, forKey: "focus_mode")
            self.isPrivateMeeting = try values.decodeIfPresent(Bool.self, forKey: "private_meeting")
            self.calendarType = try values.decodeIfPresent(Int.self, forKey: "calendar_type")
            self.meetingInvitees = try values.decodeIfPresent([MeetingInvitee].self, forKey: "meeting_invitees")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(isHostVideo, forKey: "host_video")
            try values.encodeIfPresent(isParticipantVideo, forKey: "participant_video")
            try values.encodeIfPresent(isCnMeeting, forKey: "cn_meeting")
            try values.encodeIfPresent(isInMeeting, forKey: "in_meeting")
            try values.encodeIfPresent(isJoinBeforeHost, forKey: "join_before_host")
            try values.encodeIfPresent(jbhTime, forKey: "jbh_time")
            try values.encodeIfPresent(isMuteUponEntry, forKey: "mute_upon_entry")
            try values.encodeIfPresent(isWatermark, forKey: "watermark")
            try values.encodeIfPresent(usePmi, forKey: "use_pmi")
            try values.encodeIfPresent(approvalType, forKey: "approval_type")
            try values.encodeIfPresent(registrationType, forKey: "registration_type")
            try values.encodeIfPresent(audio, forKey: "audio")
            try values.encodeIfPresent(autoRecording, forKey: "auto_recording")
            try values.encodeIfPresent(enforceLogin, forKey: "enforce_login")
            try values.encodeIfPresent(enforceLoginDomains, forKey: "enforce_login_domains")
            try values.encodeIfPresent(alternativeHosts, forKey: "alternative_hosts")
            try values.encodeIfPresent(isCloseRegistration, forKey: "close_registration")
            try values.encodeIfPresent(isWaitingRoom, forKey: "waiting_room")
            try values.encodeIfPresent(globalDialInCountries, forKey: "global_dial_in_countries")
            try values.encodeIfPresent(globalDialInNumbers, forKey: "global_dial_in_numbers")
            try values.encodeIfPresent(contactName, forKey: "contact_name")
            try values.encodeIfPresent(contactEmail, forKey: "contact_email")
            try values.encodeIfPresent(isRegistrantsEmailNotification, forKey: "registrants_email_notification")
            try values.encodeIfPresent(isRegistrantsConfirmationEmail, forKey: "registrants_confirmation_email")
            try values.encodeIfPresent(isMeetingAuthentication, forKey: "meeting_authentication")
            try values.encodeIfPresent(authenticationOption, forKey: "authentication_option")
            try values.encodeIfPresent(authenticationDomains, forKey: "authentication_domains")
            try values.encodeIfPresent(authenticationName, forKey: "authentication_name")
            try values.encodeIfPresent(isShowShareButton, forKey: "show_share_button")
            try values.encodeIfPresent(allowMultipleDevices, forKey: "allow_multiple_devices")
            try values.encodeIfPresent(encryptionType, forKey: "encryption_type")
            try values.encodeIfPresent(approvedOrDeniedCountriesOrRegions, forKey: "approved_or_denied_countries_or_regions")
            try values.encodeIfPresent(authenticationException, forKey: "authentication_exception")
            try values.encodeIfPresent(breakoutRoom, forKey: "breakout_room")
            try values.encodeIfPresent(languageInterpretation, forKey: "language_interpretation")
            try values.encodeIfPresent(customKeys, forKey: "custom_keys")
            try values.encodeIfPresent(isAlternativeHostsEmailNotification, forKey: "alternative_hosts_email_notification")
            try values.encodeIfPresent(isFocusMode, forKey: "focus_mode")
            try values.encodeIfPresent(isPrivateMeeting, forKey: "private_meeting")
            try values.encodeIfPresent(calendarType, forKey: "calendar_type")
            try values.encodeIfPresent(meetingInvitees, forKey: "meeting_invitees")
        }
    }

    public init(topic: String? = nil, type: Int? = nil, isPreSchedule: Bool? = nil, startTime: Date? = nil, duration: Int? = nil, timezone: String? = nil, password: String? = nil, agenda: String? = nil, templateID: String? = nil, trackingFields: [TrackingField]? = nil, recurrence: Recurrence? = nil, settings: Settings? = nil) {
        self.topic = topic
        self.type = type
        self.isPreSchedule = isPreSchedule ?? false
        self.startTime = startTime
        self.duration = duration
        self.timezone = timezone
        self.password = password
        self.agenda = agenda
        self.templateID = templateID
        self.trackingFields = trackingFields
        self.recurrence = recurrence
        self.settings = settings
    }

    private enum CodingKeys: String, CodingKey {
        case topic
        case type
        case isPreSchedule = "pre_schedule"
        case startTime = "start_time"
        case duration
        case timezone
        case password
        case agenda
        case templateID = "template_id"
        case trackingFields = "tracking_fields"
        case recurrence
        case settings
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.topic = try values.decodeIfPresent(String.self, forKey: .topic)
        self.type = try values.decodeIfPresent(Int.self, forKey: .type)
        self.isPreSchedule = try values.decodeIfPresent(Bool.self, forKey: .isPreSchedule) ?? false
        self.startTime = try values.decodeIfPresent(Date.self, forKey: .startTime)
        self.duration = try values.decodeIfPresent(Int.self, forKey: .duration)
        self.timezone = try values.decodeIfPresent(String.self, forKey: .timezone)
        self.password = try values.decodeIfPresent(String.self, forKey: .password)
        self.agenda = try values.decodeIfPresent(String.self, forKey: .agenda)
        self.templateID = try values.decodeIfPresent(String.self, forKey: .templateID)
        self.trackingFields = try values.decodeIfPresent([TrackingField].self, forKey: .trackingFields)
        self.recurrence = try values.decodeIfPresent(Recurrence.self, forKey: .recurrence)
        self.settings = try values.decodeIfPresent(Settings.self, forKey: .settings)
    }
}

/// Meeting live stream status.
public struct MeetingLiveStreamStatus: Codable {
    /// Update the status of a live stream.
    /// 
    /// The value can be one of the following:<br>
    /// `start`: Start a live stream. <br>
    /// `stop`: Stop an ongoing live stream.
    public var action: Action?
    /// Update the settings of a live streaming session. The settings can only be updated for a live stream that has been stopped. You can not update the settings of an ongoing live stream.
    public var settings: Settings?

    /// Update the status of a live stream.
    /// 
    /// The value can be one of the following:<br>
    /// `start`: Start a live stream. <br>
    /// `stop`: Stop an ongoing live stream.
    public enum Action: String, Codable, CaseIterable {
        case start
        case stop
    }

    /// Update the settings of a live streaming session. The settings can only be updated for a live stream that has been stopped. You can not update the settings of an ongoing live stream.
    public struct Settings: Codable {
        /// Display the name of the active speaker during a live stream.
        public var isActiveSpeakerName: Bool?
        /// Display name of the live stream.
        public var displayName: String?

        public init(isActiveSpeakerName: Bool? = nil, displayName: String? = nil) {
            self.isActiveSpeakerName = isActiveSpeakerName
            self.displayName = displayName
        }

        private enum CodingKeys: String, CodingKey {
            case isActiveSpeakerName = "active_speaker_name"
            case displayName = "display_name"
        }
    }

    public init(action: Action? = nil, settings: Settings? = nil) {
        self.action = action
        self.settings = settings
    }
}

/// Meeting settings.
public struct MeetingSettings: Codable {
    /// Start video when the host joins the meeting.
    public var isHostVideo: Bool?
    /// Start video when participants join the meeting.
    public var isParticipantVideo: Bool?
    /// Host meeting in China.
    public var isCnMeeting: Bool
    /// Host meeting in India.
    public var isInMeeting: Bool
    /// Allow participants to join the meeting before the host starts the meeting. Only used for scheduled or recurring meetings.
    public var isJoinBeforeHost: Bool
    /// If the value of "join_before_host" field is set to true, this field can be used to indicate time limits within which a participant may join a meeting before a host. The value of this field can be one of the following:
    /// 
    /// *  `0`: Allow participant to join anytime.
    /// *  `5`: Allow participant to join 5 minutes before meeting start time.
    ///  * `10`: Allow participant to join 10 minutes before meeting start time.
    public var jbhTime: Int?
    /// Mute participants upon entry.
    public var isMuteUponEntry: Bool
    /// Add watermark when viewing a shared screen.
    public var isWatermark: Bool
    /// Use a personal meeting ID. Only used for scheduled meetings and recurring meetings with no fixed time.
    public var usePmi: Bool
    /// Enable registration and set approval for the registration. Note that this feature requires the host to be of **Licensed** user type. **Registration cannot be enabled for a basic user.** <br><br>
    /// 
    /// `0` - Automatically approve.<br>`1` - Manually approve.<br>`2` - No registration required.
    public var approvalType: Int?
    /// Registration type. Used for recurring meeting with fixed time only. <br>`1` Attendees register once and can attend any of the occurrences.<br>`2` Attendees need to register for each occurrence to attend.<br>`3` Attendees register once and can choose one or more occurrences to attend.
    public var registrationType: Int?
    /// Determine how participants can join the audio portion of the meeting.<br>`both` - Both Telephony and VoIP.<br>`telephony` - Telephony only.<br>`voip` - VoIP only.
    public var audio: Audio?
    /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
    public var autoRecording: AutoRecording?
    /// Only signed in users can join this meeting.
    /// 
    /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
    public var enforceLogin: Bool?
    /// Only signed in users with specified domains can join meetings.
    /// 
    /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
    public var enforceLoginDomains: String?
    /// A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.
    public var alternativeHosts: String?
    /// Close registration after event date
    public var isCloseRegistration: Bool
    /// Enable waiting room
    public var isWaitingRoom: Bool
    /// List of global dial-in countries
    public var globalDialInCountries: [String]?
    /// Global Dial-in Countries/Regions
    public var globalDialInNumbers: [GlobalDialInNumber]?
    /// Contact name for registration
    public var contactName: String?
    /// Contact email for registration
    public var contactEmail: String?
    /// Whether to send registrants email notifications about their registration approval, cancellation, or rejection:
    /// 
    /// * `true` — Send an email notification.
    /// * `false` — Do not send an email notification.
    /// 
    ///  Set this value to `true` to also use the `registrants_confirmation_email` parameter.
    public var isRegistrantsEmailNotification: Bool?
    /// Whether to send registrants an email confirmation:
    /// * `true` — Send a confirmation email.
    /// * `false` — Do not send a confirmation email.
    public var isRegistrantsConfirmationEmail: Bool?
    /// `true`- Only authenticated users can join meetings.
    public var isMeetingAuthentication: Bool?
    /// Meeting authentication option id.
    public var authenticationOption: String?
    /// If user has configured ["Sign Into Zoom with Specified Domains"](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
    public var authenticationDomains: String?
    /// Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
    public var authenticationName: String?
    /// Show social share buttons on the meeting registration page.
    /// This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
    public var isShowShareButton: Bool?
    /// Allow attendees to join the meeting from multiple devices. This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
    public var allowMultipleDevices: Bool?
    /// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
    /// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
    /// 
    /// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
    public var encryptionType: EncryptionType?
    /// Approve or block users from specific regions/countries from joining this meeting.
    public var approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions?
    /// The participants added here will receive unique meeting invite links and bypass authentication.
    public var authenticationException: [AuthenticationExceptionItem]?
    /// Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
    public var breakoutRoom: BreakoutRoom?
    /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
    /// 
    /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
    public var languageInterpretation: LanguageInterpretation?
    /// Custom keys and values assigned to the meeting.
    public var customKeys: [CustomKey]?
    /// Flag to determine whether to send email notifications to alternative hosts, default value is true.
    public var isAlternativeHostsEmailNotification: Bool
    /// Whether the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) is enabled when the meeting starts.
    public var isFocusMode: Bool?
    /// Whether the meeting is set as private.
    public var isPrivateMeeting: Bool?
    /// The calendar type: 
    /// * `1` — Outlook calendar. 
    /// * `2` — Google Calendar.
    public var calendarType: Int?

    /// Determine how participants can join the audio portion of the meeting.<br>`both` - Both Telephony and VoIP.<br>`telephony` - Telephony only.<br>`voip` - VoIP only.
    public enum Audio: String, Codable, CaseIterable {
        case both
        case telephony
        case voip
    }

    /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
    public enum AutoRecording: String, Codable, CaseIterable {
        case local
        case cloud
        case `none`
    }

    public struct GlobalDialInNumber: Codable {
        /// Country code. For example, BR.
        public var country: String?
        /// Full name of country. For example, Brazil.
        public var countryName: String?
        /// City of the number, if any. For example, Chicago.
        public var city: String?
        /// Phone number. For example, +1 2332357613.
        public var number: String?
        /// Type of number.
        public var type: `Type`?

        /// Type of number.
        public enum `Type`: String, Codable, CaseIterable {
            case toll
            case tollfree
        }

        public init(country: String? = nil, countryName: String? = nil, city: String? = nil, number: String? = nil, type: `Type`? = nil) {
            self.country = country
            self.countryName = countryName
            self.city = city
            self.number = number
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case country
            case countryName = "country_name"
            case city
            case number
            case type
        }
    }

    /// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
    /// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
    /// 
    /// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
    public enum EncryptionType: String, Codable, CaseIterable {
        case enhancedEncryption = "enhanced_encryption"
        case e2ee
    }

    /// Approve or block users from specific regions/countries from joining this meeting.
    public struct ApprovedOrDeniedCountriesOrRegions: Codable {
        /// `true`: Setting enabled to either allow users or block users from specific regions to join your meetings. <br>
        /// 
        /// `false`: Setting disabled.
        public var enable: Bool?
        /// Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting. <br><br>
        /// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.<br><br>
        /// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
        public var method: Method?
        /// List of countries/regions from where participants can join this meeting.
        public var approvedList: [String]?
        /// List of countries/regions from where participants can not join this meeting.
        public var deniedList: [String]?

        /// Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting. <br><br>
        /// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.<br><br>
        /// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
        public enum Method: String, Codable, CaseIterable {
            case approve
            case deny
        }

        public init(enable: Bool? = nil, method: Method? = nil, approvedList: [String]? = nil, deniedList: [String]? = nil) {
            self.enable = enable
            self.method = method
            self.approvedList = approvedList
            self.deniedList = deniedList
        }

        private enum CodingKeys: String, CodingKey {
            case enable
            case method
            case approvedList = "approved_list"
            case deniedList = "denied_list"
        }
    }

    public struct AuthenticationExceptionItem: Codable {
        /// Name of the participant.
        public var name: String?
        /// Email address of the participant.
        public var email: String?

        public init(name: String? = nil, email: String? = nil) {
            self.name = name
            self.email = email
        }
    }

    /// Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
    public struct BreakoutRoom: Codable {
        /// Set the value of this field to `true` if you would like to enable the [breakout room pre-assign](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4) option.
        public var enable: Bool?
        /// Create room(s).
        public var rooms: [Room]?

        public struct Room: Codable {
            /// Name of the breakout room.
            public var name: String?
            /// Email addresses of the participants who are to be assigned to the breakout room.
            public var participants: [String]?

            public init(name: String? = nil, participants: [String]? = nil) {
                self.name = name
                self.participants = participants
            }
        }

        public init(enable: Bool? = nil, rooms: [Room]? = nil) {
            self.enable = enable
            self.rooms = rooms
        }
    }

    /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
    /// 
    /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
    public struct LanguageInterpretation: Codable {
        /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the meeting.
        public var enable: Bool?
        /// Information about the meeting's language interpreters.
        public var interpreters: [Interpreter]?

        public struct Interpreter: Codable {
            /// The interpreter's email address.
            public var email: String?
            /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
            /// 
            /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
            public var languages: String?

            public init(email: String? = nil, languages: String? = nil) {
                self.email = email
                self.languages = languages
            }
        }

        public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
            self.enable = enable
            self.interpreters = interpreters
        }
    }

    public struct CustomKey: Codable {
        /// Custom key associated with the user.
        public var key: String?
        /// Value of the custom key associated with the user.
        public var value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }
    }

    public init(isHostVideo: Bool? = nil, isParticipantVideo: Bool? = nil, isCnMeeting: Bool? = nil, isInMeeting: Bool? = nil, isJoinBeforeHost: Bool? = nil, jbhTime: Int? = nil, isMuteUponEntry: Bool? = nil, isWatermark: Bool? = nil, usePmi: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, enforceLogin: Bool? = nil, enforceLoginDomains: String? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isWaitingRoom: Bool? = nil, globalDialInCountries: [String]? = nil, globalDialInNumbers: [GlobalDialInNumber]? = nil, contactName: String? = nil, contactEmail: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isRegistrantsConfirmationEmail: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, authenticationName: String? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, encryptionType: EncryptionType? = nil, approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions? = nil, authenticationException: [AuthenticationExceptionItem]? = nil, breakoutRoom: BreakoutRoom? = nil, languageInterpretation: LanguageInterpretation? = nil, customKeys: [CustomKey]? = nil, isAlternativeHostsEmailNotification: Bool? = nil, isFocusMode: Bool? = nil, isPrivateMeeting: Bool? = nil, calendarType: Int? = nil) {
        self.isHostVideo = isHostVideo
        self.isParticipantVideo = isParticipantVideo
        self.isCnMeeting = isCnMeeting ?? false
        self.isInMeeting = isInMeeting ?? false
        self.isJoinBeforeHost = isJoinBeforeHost ?? false
        self.jbhTime = jbhTime
        self.isMuteUponEntry = isMuteUponEntry ?? false
        self.isWatermark = isWatermark ?? false
        self.usePmi = usePmi ?? false
        self.approvalType = approvalType
        self.registrationType = registrationType
        self.audio = audio
        self.autoRecording = autoRecording
        self.enforceLogin = enforceLogin
        self.enforceLoginDomains = enforceLoginDomains
        self.alternativeHosts = alternativeHosts
        self.isCloseRegistration = isCloseRegistration ?? false
        self.isWaitingRoom = isWaitingRoom ?? false
        self.globalDialInCountries = globalDialInCountries
        self.globalDialInNumbers = globalDialInNumbers
        self.contactName = contactName
        self.contactEmail = contactEmail
        self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
        self.isRegistrantsConfirmationEmail = isRegistrantsConfirmationEmail
        self.isMeetingAuthentication = isMeetingAuthentication
        self.authenticationOption = authenticationOption
        self.authenticationDomains = authenticationDomains
        self.authenticationName = authenticationName
        self.isShowShareButton = isShowShareButton
        self.allowMultipleDevices = allowMultipleDevices
        self.encryptionType = encryptionType
        self.approvedOrDeniedCountriesOrRegions = approvedOrDeniedCountriesOrRegions
        self.authenticationException = authenticationException
        self.breakoutRoom = breakoutRoom
        self.languageInterpretation = languageInterpretation
        self.customKeys = customKeys
        self.isAlternativeHostsEmailNotification = isAlternativeHostsEmailNotification ?? true
        self.isFocusMode = isFocusMode
        self.isPrivateMeeting = isPrivateMeeting
        self.calendarType = calendarType
    }

    private enum CodingKeys: String, CodingKey {
        case isHostVideo = "host_video"
        case isParticipantVideo = "participant_video"
        case isCnMeeting = "cn_meeting"
        case isInMeeting = "in_meeting"
        case isJoinBeforeHost = "join_before_host"
        case jbhTime = "jbh_time"
        case isMuteUponEntry = "mute_upon_entry"
        case isWatermark = "watermark"
        case usePmi = "use_pmi"
        case approvalType = "approval_type"
        case registrationType = "registration_type"
        case audio
        case autoRecording = "auto_recording"
        case enforceLogin = "enforce_login"
        case enforceLoginDomains = "enforce_login_domains"
        case alternativeHosts = "alternative_hosts"
        case isCloseRegistration = "close_registration"
        case isWaitingRoom = "waiting_room"
        case globalDialInCountries = "global_dial_in_countries"
        case globalDialInNumbers = "global_dial_in_numbers"
        case contactName = "contact_name"
        case contactEmail = "contact_email"
        case isRegistrantsEmailNotification = "registrants_email_notification"
        case isRegistrantsConfirmationEmail = "registrants_confirmation_email"
        case isMeetingAuthentication = "meeting_authentication"
        case authenticationOption = "authentication_option"
        case authenticationDomains = "authentication_domains"
        case authenticationName = "authentication_name"
        case isShowShareButton = "show_share_button"
        case allowMultipleDevices = "allow_multiple_devices"
        case encryptionType = "encryption_type"
        case approvedOrDeniedCountriesOrRegions = "approved_or_denied_countries_or_regions"
        case authenticationException = "authentication_exception"
        case breakoutRoom = "breakout_room"
        case languageInterpretation = "language_interpretation"
        case customKeys = "custom_keys"
        case isAlternativeHostsEmailNotification = "alternative_hosts_email_notification"
        case isFocusMode = "focus_mode"
        case isPrivateMeeting = "private_meeting"
        case calendarType = "calendar_type"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isHostVideo = try values.decodeIfPresent(Bool.self, forKey: .isHostVideo)
        self.isParticipantVideo = try values.decodeIfPresent(Bool.self, forKey: .isParticipantVideo)
        self.isCnMeeting = try values.decodeIfPresent(Bool.self, forKey: .isCnMeeting) ?? false
        self.isInMeeting = try values.decodeIfPresent(Bool.self, forKey: .isInMeeting) ?? false
        self.isJoinBeforeHost = try values.decodeIfPresent(Bool.self, forKey: .isJoinBeforeHost) ?? false
        self.jbhTime = try values.decodeIfPresent(Int.self, forKey: .jbhTime)
        self.isMuteUponEntry = try values.decodeIfPresent(Bool.self, forKey: .isMuteUponEntry) ?? false
        self.isWatermark = try values.decodeIfPresent(Bool.self, forKey: .isWatermark) ?? false
        self.usePmi = try values.decodeIfPresent(Bool.self, forKey: .usePmi) ?? false
        self.approvalType = try values.decodeIfPresent(Int.self, forKey: .approvalType)
        self.registrationType = try values.decodeIfPresent(Int.self, forKey: .registrationType)
        self.audio = try values.decodeIfPresent(Audio.self, forKey: .audio)
        self.autoRecording = try values.decodeIfPresent(AutoRecording.self, forKey: .autoRecording)
        self.enforceLogin = try values.decodeIfPresent(Bool.self, forKey: .enforceLogin)
        self.enforceLoginDomains = try values.decodeIfPresent(String.self, forKey: .enforceLoginDomains)
        self.alternativeHosts = try values.decodeIfPresent(String.self, forKey: .alternativeHosts)
        self.isCloseRegistration = try values.decodeIfPresent(Bool.self, forKey: .isCloseRegistration) ?? false
        self.isWaitingRoom = try values.decodeIfPresent(Bool.self, forKey: .isWaitingRoom) ?? false
        self.globalDialInCountries = try values.decodeIfPresent([String].self, forKey: .globalDialInCountries)
        self.globalDialInNumbers = try values.decodeIfPresent([GlobalDialInNumber].self, forKey: .globalDialInNumbers)
        self.contactName = try values.decodeIfPresent(String.self, forKey: .contactName)
        self.contactEmail = try values.decodeIfPresent(String.self, forKey: .contactEmail)
        self.isRegistrantsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsEmailNotification)
        self.isRegistrantsConfirmationEmail = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsConfirmationEmail)
        self.isMeetingAuthentication = try values.decodeIfPresent(Bool.self, forKey: .isMeetingAuthentication)
        self.authenticationOption = try values.decodeIfPresent(String.self, forKey: .authenticationOption)
        self.authenticationDomains = try values.decodeIfPresent(String.self, forKey: .authenticationDomains)
        self.authenticationName = try values.decodeIfPresent(String.self, forKey: .authenticationName)
        self.isShowShareButton = try values.decodeIfPresent(Bool.self, forKey: .isShowShareButton)
        self.allowMultipleDevices = try values.decodeIfPresent(Bool.self, forKey: .allowMultipleDevices)
        self.encryptionType = try values.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
        self.approvedOrDeniedCountriesOrRegions = try values.decodeIfPresent(ApprovedOrDeniedCountriesOrRegions.self, forKey: .approvedOrDeniedCountriesOrRegions)
        self.authenticationException = try values.decodeIfPresent([AuthenticationExceptionItem].self, forKey: .authenticationException)
        self.breakoutRoom = try values.decodeIfPresent(BreakoutRoom.self, forKey: .breakoutRoom)
        self.languageInterpretation = try values.decodeIfPresent(LanguageInterpretation.self, forKey: .languageInterpretation)
        self.customKeys = try values.decodeIfPresent([CustomKey].self, forKey: .customKeys)
        self.isAlternativeHostsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isAlternativeHostsEmailNotification) ?? true
        self.isFocusMode = try values.decodeIfPresent(Bool.self, forKey: .isFocusMode)
        self.isPrivateMeeting = try values.decodeIfPresent(Bool.self, forKey: .isPrivateMeeting)
        self.calendarType = try values.decodeIfPresent(Int.self, forKey: .calendarType)
    }
}

public struct Meeting: Codable {
    /// Meeting UUID. Unique meeting ID. Each meeting instance will generate its own Meeting UUID (i.e., after a meeting ends, a new UUID will be generated for the next instance of the meeting). Please double encode your UUID when using it for API calls if the UUID begins with a '/'or contains '//' in it.
    public var uuid: String?
    /// Start time
    public var startTime: Date?

    public init(uuid: String? = nil, startTime: Date? = nil) {
        self.uuid = uuid
        self.startTime = startTime
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
        self.startTime = try values.decodeIfPresent(Date.self, forKey: "start_time")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(uuid, forKey: "uuid")
        try values.encodeIfPresent(startTime, forKey: "start_time")
    }
}

/// Meeting object
public struct MeetingInfo: Codable {
    /// Meeting topic
    public var topic: String?
    /// Meeting Type
    public var type: Int?
    /// Whether the prescheduled meeting was created via the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This **only** supports the meeting `type` value of `2` (scheduled meetings) and `3` (recurring meetings with no fixed time): 
    /// * `true` — A GSuite prescheduled meeting. 
    /// * `false` — A regular meeting.
    public var isPreSchedule: Bool
    /// Meeting start date-time in UTC/GMT. Example: "2020-03-31T12:02:00Z"
    public var startTime: Date?
    /// Meeting duration.
    public var duration: Int?
    /// Timezone to format start_time
    public var timezone: String?
    /// The date and time at which this meeting was created.
    public var createdAt: Date?
    /// Agenda
    public var agenda: String?
    /// URL to start the meeting. This URL should only be used by the host of the meeting and **should not be shared with anyone other than the host** of the meeting as anyone with this URL will be able to login to the Zoom Client as the host of the meeting.
    public var startURL: String?
    /// URL for participants to join the meeting. This URL should only be shared with users that you would like to invite for the meeting.
    public var joinURL: String?
    /// Meeting password. Password may only contain the following characters: `[a-z A-Z 0-9 @ - _ * !]`
    /// 
    /// If "Require a password when scheduling new meetings" setting has been **enabled** **and** [locked](https://support.zoom.us/hc/en-us/articles/115005269866-Using-Tiered-Settings#locked) for the user, the password field will be autogenerated in the response even if it is not provided in the API request.
    public var password: String?
    /// H.323/SIP room system password
    public var h323Password: String?
    /// Personal Meeting Id. Only used for scheduled meetings and recurring meetings with no fixed time.
    public var pmi: Int?
    /// Tracking fields
    public var trackingFields: [TrackingField]?
    /// Array of occurrence objects.
    public var occurrences: [Occurrence]?
    /// Meeting settings.
    public var settings: Settings?
    /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
    public var recurrence: Recurrence?

    public struct TrackingField: Codable {
        /// Label of the tracking field.
        public var field: String?
        /// Value for the field.
        public var value: String?
        /// Indicates whether the [tracking field](https://support.zoom.us/hc/en-us/articles/115000293426-Scheduling-Tracking-Fields) is visible in the meeting scheduling options in the Zoom Web Portal or not.
        /// 
        /// `true`: Tracking field is visible. <br>
        /// 
        /// `false`: Tracking field is not visible to the users in the meeting options in the Zoom Web Portal but the field was used while scheduling this meeting via API. An invisible tracking field can be used by users while scheduling meetings via API only.
        public var isVisible: Bool?

        public init(field: String? = nil, value: String? = nil, isVisible: Bool? = nil) {
            self.field = field
            self.value = value
            self.isVisible = isVisible
        }

        private enum CodingKeys: String, CodingKey {
            case field
            case value
            case isVisible = "visible"
        }
    }

    /// Occurrence object. This object is only returned for Recurring Webinars.
    public struct Occurrence: Codable {
        /// Occurrence ID: Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences.
        public var occurrenceID: String?
        /// Start time.
        public var startTime: Date?
        /// Duration.
        public var duration: Int?
        /// Occurrence status.
        public var status: String?

        public init(occurrenceID: String? = nil, startTime: Date? = nil, duration: Int? = nil, status: String? = nil) {
            self.occurrenceID = occurrenceID
            self.startTime = startTime
            self.duration = duration
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case occurrenceID = "occurrence_id"
            case startTime = "start_time"
            case duration
            case status
        }
    }

    /// Meeting settings.
    public struct Settings: Codable {
        /// Start video when the host joins the meeting.
        public var isHostVideo: Bool?
        /// Start video when participants join the meeting.
        public var isParticipantVideo: Bool?
        /// Host meeting in China.
        public var isCnMeeting: Bool
        /// Host meeting in India.
        public var isInMeeting: Bool
        /// Allow participants to join the meeting before the host starts the meeting. Only used for scheduled or recurring meetings.
        public var isJoinBeforeHost: Bool
        /// If the value of "join_before_host" field is set to true, this field can be used to indicate time limits within which a participant may join a meeting before a host. The value of this field can be one of the following:
        /// 
        /// *  `0`: Allow participant to join anytime.
        /// *  `5`: Allow participant to join 5 minutes before meeting start time.
        ///  * `10`: Allow participant to join 10 minutes before meeting start time.
        public var jbhTime: Int?
        /// Mute participants upon entry.
        public var isMuteUponEntry: Bool
        /// Add watermark when viewing a shared screen.
        public var isWatermark: Bool
        /// Use a personal meeting ID. Only used for scheduled meetings and recurring meetings with no fixed time.
        public var usePmi: Bool
        /// Enable registration and set approval for the registration. Note that this feature requires the host to be of **Licensed** user type. **Registration cannot be enabled for a basic user.** <br><br>
        /// 
        /// `0` - Automatically approve.<br>`1` - Manually approve.<br>`2` - No registration required.
        public var approvalType: Int?
        /// Registration type. Used for recurring meeting with fixed time only. <br>`1` Attendees register once and can attend any of the occurrences.<br>`2` Attendees need to register for each occurrence to attend.<br>`3` Attendees register once and can choose one or more occurrences to attend.
        public var registrationType: Int?
        /// Determine how participants can join the audio portion of the meeting.<br>`both` - Both Telephony and VoIP.<br>`telephony` - Telephony only.<br>`voip` - VoIP only.
        public var audio: Audio?
        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public var autoRecording: AutoRecording?
        /// Only signed in users can join this meeting.
        /// 
        /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
        public var enforceLogin: Bool?
        /// Only signed in users with specified domains can join meetings.
        /// 
        /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
        public var enforceLoginDomains: String?
        /// A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.
        public var alternativeHosts: String?
        /// Close registration after event date
        public var isCloseRegistration: Bool
        /// Enable waiting room
        public var isWaitingRoom: Bool
        /// List of global dial-in countries
        public var globalDialInCountries: [String]?
        /// Global Dial-in Countries/Regions
        public var globalDialInNumbers: [GlobalDialInNumber]?
        /// Contact name for registration
        public var contactName: String?
        /// Contact email for registration
        public var contactEmail: String?
        /// Whether to send registrants email notifications about their registration approval, cancellation, or rejection:
        /// 
        /// * `true` — Send an email notification.
        /// * `false` — Do not send an email notification.
        /// 
        ///  Set this value to `true` to also use the `registrants_confirmation_email` parameter.
        public var isRegistrantsEmailNotification: Bool?
        /// Whether to send registrants an email confirmation:
        /// * `true` — Send a confirmation email.
        /// * `false` — Do not send a confirmation email.
        public var isRegistrantsConfirmationEmail: Bool?
        /// `true`- Only authenticated users can join meetings.
        public var isMeetingAuthentication: Bool?
        /// Meeting authentication option id.
        public var authenticationOption: String?
        /// If user has configured ["Sign Into Zoom with Specified Domains"](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
        public var authenticationDomains: String?
        /// Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
        public var authenticationName: String?
        /// Show social share buttons on the meeting registration page.
        /// This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
        public var isShowShareButton: Bool?
        /// Allow attendees to join the meeting from multiple devices. This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
        public var allowMultipleDevices: Bool?
        /// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
        /// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
        /// 
        /// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
        public var encryptionType: EncryptionType?
        /// Approve or block users from specific regions/countries from joining this meeting.
        public var approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions?
        /// The participants added here will receive unique meeting invite links and bypass authentication.
        public var authenticationException: [AuthenticationExceptionItem]?
        /// Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
        public var breakoutRoom: BreakoutRoom?
        /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
        /// 
        /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
        public var languageInterpretation: LanguageInterpretation?
        /// Custom keys and values assigned to the meeting.
        public var customKeys: [CustomKey]?
        /// Flag to determine whether to send email notifications to alternative hosts, default value is true.
        public var isAlternativeHostsEmailNotification: Bool
        /// Whether the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) is enabled when the meeting starts.
        public var isFocusMode: Bool?
        /// Whether the meeting is set as private.
        public var isPrivateMeeting: Bool?
        /// The calendar type: 
        /// * `1` — Outlook calendar. 
        /// * `2` — Google Calendar.
        public var calendarType: Int?

        /// Determine how participants can join the audio portion of the meeting.<br>`both` - Both Telephony and VoIP.<br>`telephony` - Telephony only.<br>`voip` - VoIP only.
        public enum Audio: String, Codable, CaseIterable {
            case both
            case telephony
            case voip
        }

        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public enum AutoRecording: String, Codable, CaseIterable {
            case local
            case cloud
            case `none`
        }

        public struct GlobalDialInNumber: Codable {
            /// Country code. For example, BR.
            public var country: String?
            /// Full name of country. For example, Brazil.
            public var countryName: String?
            /// City of the number, if any. For example, Chicago.
            public var city: String?
            /// Phone number. For example, +1 2332357613.
            public var number: String?
            /// Type of number.
            public var type: `Type`?

            /// Type of number.
            public enum `Type`: String, Codable, CaseIterable {
                case toll
                case tollfree
            }

            public init(country: String? = nil, countryName: String? = nil, city: String? = nil, number: String? = nil, type: `Type`? = nil) {
                self.country = country
                self.countryName = countryName
                self.city = city
                self.number = number
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case country
                case countryName = "country_name"
                case city
                case number
                case type
            }
        }

        /// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
        /// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
        /// 
        /// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
        public enum EncryptionType: String, Codable, CaseIterable {
            case enhancedEncryption = "enhanced_encryption"
            case e2ee
        }

        /// Approve or block users from specific regions/countries from joining this meeting.
        public struct ApprovedOrDeniedCountriesOrRegions: Codable {
            /// `true`: Setting enabled to either allow users or block users from specific regions to join your meetings. <br>
            /// 
            /// `false`: Setting disabled.
            public var enable: Bool?
            /// Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting. <br><br>
            /// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.<br><br>
            /// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
            public var method: Method?
            /// List of countries/regions from where participants can join this meeting.
            public var approvedList: [String]?
            /// List of countries/regions from where participants can not join this meeting.
            public var deniedList: [String]?

            /// Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting. <br><br>
            /// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.<br><br>
            /// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
            public enum Method: String, Codable, CaseIterable {
                case approve
                case deny
            }

            public init(enable: Bool? = nil, method: Method? = nil, approvedList: [String]? = nil, deniedList: [String]? = nil) {
                self.enable = enable
                self.method = method
                self.approvedList = approvedList
                self.deniedList = deniedList
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case method
                case approvedList = "approved_list"
                case deniedList = "denied_list"
            }
        }

        public struct AuthenticationExceptionItem: Codable {
            /// Name of the participant.
            public var name: String?
            /// Email address of the participant.
            public var email: String?

            public init(name: String? = nil, email: String? = nil) {
                self.name = name
                self.email = email
            }
        }

        /// Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
        public struct BreakoutRoom: Codable {
            /// Set the value of this field to `true` if you would like to enable the [breakout room pre-assign](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4) option.
            public var enable: Bool?
            /// Create room(s).
            public var rooms: [Room]?

            public struct Room: Codable {
                /// Name of the breakout room.
                public var name: String?
                /// Email addresses of the participants who are to be assigned to the breakout room.
                public var participants: [String]?

                public init(name: String? = nil, participants: [String]? = nil) {
                    self.name = name
                    self.participants = participants
                }
            }

            public init(enable: Bool? = nil, rooms: [Room]? = nil) {
                self.enable = enable
                self.rooms = rooms
            }
        }

        /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
        /// 
        /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
        public struct LanguageInterpretation: Codable {
            /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the meeting.
            public var enable: Bool?
            /// Information about the meeting's language interpreters.
            public var interpreters: [Interpreter]?

            public struct Interpreter: Codable {
                /// The interpreter's email address.
                public var email: String?
                /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
                /// 
                /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
                public var languages: String?

                public init(email: String? = nil, languages: String? = nil) {
                    self.email = email
                    self.languages = languages
                }
            }

            public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
                self.enable = enable
                self.interpreters = interpreters
            }
        }

        public struct CustomKey: Codable {
            /// Custom key associated with the user.
            public var key: String?
            /// Value of the custom key associated with the user.
            public var value: String?

            public init(key: String? = nil, value: String? = nil) {
                self.key = key
                self.value = value
            }
        }

        public init(isHostVideo: Bool? = nil, isParticipantVideo: Bool? = nil, isCnMeeting: Bool? = nil, isInMeeting: Bool? = nil, isJoinBeforeHost: Bool? = nil, jbhTime: Int? = nil, isMuteUponEntry: Bool? = nil, isWatermark: Bool? = nil, usePmi: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, enforceLogin: Bool? = nil, enforceLoginDomains: String? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isWaitingRoom: Bool? = nil, globalDialInCountries: [String]? = nil, globalDialInNumbers: [GlobalDialInNumber]? = nil, contactName: String? = nil, contactEmail: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isRegistrantsConfirmationEmail: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, authenticationName: String? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, encryptionType: EncryptionType? = nil, approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions? = nil, authenticationException: [AuthenticationExceptionItem]? = nil, breakoutRoom: BreakoutRoom? = nil, languageInterpretation: LanguageInterpretation? = nil, customKeys: [CustomKey]? = nil, isAlternativeHostsEmailNotification: Bool? = nil, isFocusMode: Bool? = nil, isPrivateMeeting: Bool? = nil, calendarType: Int? = nil) {
            self.isHostVideo = isHostVideo
            self.isParticipantVideo = isParticipantVideo
            self.isCnMeeting = isCnMeeting ?? false
            self.isInMeeting = isInMeeting ?? false
            self.isJoinBeforeHost = isJoinBeforeHost ?? false
            self.jbhTime = jbhTime
            self.isMuteUponEntry = isMuteUponEntry ?? false
            self.isWatermark = isWatermark ?? false
            self.usePmi = usePmi ?? false
            self.approvalType = approvalType
            self.registrationType = registrationType
            self.audio = audio
            self.autoRecording = autoRecording
            self.enforceLogin = enforceLogin
            self.enforceLoginDomains = enforceLoginDomains
            self.alternativeHosts = alternativeHosts
            self.isCloseRegistration = isCloseRegistration ?? false
            self.isWaitingRoom = isWaitingRoom ?? false
            self.globalDialInCountries = globalDialInCountries
            self.globalDialInNumbers = globalDialInNumbers
            self.contactName = contactName
            self.contactEmail = contactEmail
            self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
            self.isRegistrantsConfirmationEmail = isRegistrantsConfirmationEmail
            self.isMeetingAuthentication = isMeetingAuthentication
            self.authenticationOption = authenticationOption
            self.authenticationDomains = authenticationDomains
            self.authenticationName = authenticationName
            self.isShowShareButton = isShowShareButton
            self.allowMultipleDevices = allowMultipleDevices
            self.encryptionType = encryptionType
            self.approvedOrDeniedCountriesOrRegions = approvedOrDeniedCountriesOrRegions
            self.authenticationException = authenticationException
            self.breakoutRoom = breakoutRoom
            self.languageInterpretation = languageInterpretation
            self.customKeys = customKeys
            self.isAlternativeHostsEmailNotification = isAlternativeHostsEmailNotification ?? true
            self.isFocusMode = isFocusMode
            self.isPrivateMeeting = isPrivateMeeting
            self.calendarType = calendarType
        }

        private enum CodingKeys: String, CodingKey {
            case isHostVideo = "host_video"
            case isParticipantVideo = "participant_video"
            case isCnMeeting = "cn_meeting"
            case isInMeeting = "in_meeting"
            case isJoinBeforeHost = "join_before_host"
            case jbhTime = "jbh_time"
            case isMuteUponEntry = "mute_upon_entry"
            case isWatermark = "watermark"
            case usePmi = "use_pmi"
            case approvalType = "approval_type"
            case registrationType = "registration_type"
            case audio
            case autoRecording = "auto_recording"
            case enforceLogin = "enforce_login"
            case enforceLoginDomains = "enforce_login_domains"
            case alternativeHosts = "alternative_hosts"
            case isCloseRegistration = "close_registration"
            case isWaitingRoom = "waiting_room"
            case globalDialInCountries = "global_dial_in_countries"
            case globalDialInNumbers = "global_dial_in_numbers"
            case contactName = "contact_name"
            case contactEmail = "contact_email"
            case isRegistrantsEmailNotification = "registrants_email_notification"
            case isRegistrantsConfirmationEmail = "registrants_confirmation_email"
            case isMeetingAuthentication = "meeting_authentication"
            case authenticationOption = "authentication_option"
            case authenticationDomains = "authentication_domains"
            case authenticationName = "authentication_name"
            case isShowShareButton = "show_share_button"
            case allowMultipleDevices = "allow_multiple_devices"
            case encryptionType = "encryption_type"
            case approvedOrDeniedCountriesOrRegions = "approved_or_denied_countries_or_regions"
            case authenticationException = "authentication_exception"
            case breakoutRoom = "breakout_room"
            case languageInterpretation = "language_interpretation"
            case customKeys = "custom_keys"
            case isAlternativeHostsEmailNotification = "alternative_hosts_email_notification"
            case isFocusMode = "focus_mode"
            case isPrivateMeeting = "private_meeting"
            case calendarType = "calendar_type"
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.isHostVideo = try values.decodeIfPresent(Bool.self, forKey: .isHostVideo)
            self.isParticipantVideo = try values.decodeIfPresent(Bool.self, forKey: .isParticipantVideo)
            self.isCnMeeting = try values.decodeIfPresent(Bool.self, forKey: .isCnMeeting) ?? false
            self.isInMeeting = try values.decodeIfPresent(Bool.self, forKey: .isInMeeting) ?? false
            self.isJoinBeforeHost = try values.decodeIfPresent(Bool.self, forKey: .isJoinBeforeHost) ?? false
            self.jbhTime = try values.decodeIfPresent(Int.self, forKey: .jbhTime)
            self.isMuteUponEntry = try values.decodeIfPresent(Bool.self, forKey: .isMuteUponEntry) ?? false
            self.isWatermark = try values.decodeIfPresent(Bool.self, forKey: .isWatermark) ?? false
            self.usePmi = try values.decodeIfPresent(Bool.self, forKey: .usePmi) ?? false
            self.approvalType = try values.decodeIfPresent(Int.self, forKey: .approvalType)
            self.registrationType = try values.decodeIfPresent(Int.self, forKey: .registrationType)
            self.audio = try values.decodeIfPresent(Audio.self, forKey: .audio)
            self.autoRecording = try values.decodeIfPresent(AutoRecording.self, forKey: .autoRecording)
            self.enforceLogin = try values.decodeIfPresent(Bool.self, forKey: .enforceLogin)
            self.enforceLoginDomains = try values.decodeIfPresent(String.self, forKey: .enforceLoginDomains)
            self.alternativeHosts = try values.decodeIfPresent(String.self, forKey: .alternativeHosts)
            self.isCloseRegistration = try values.decodeIfPresent(Bool.self, forKey: .isCloseRegistration) ?? false
            self.isWaitingRoom = try values.decodeIfPresent(Bool.self, forKey: .isWaitingRoom) ?? false
            self.globalDialInCountries = try values.decodeIfPresent([String].self, forKey: .globalDialInCountries)
            self.globalDialInNumbers = try values.decodeIfPresent([GlobalDialInNumber].self, forKey: .globalDialInNumbers)
            self.contactName = try values.decodeIfPresent(String.self, forKey: .contactName)
            self.contactEmail = try values.decodeIfPresent(String.self, forKey: .contactEmail)
            self.isRegistrantsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsEmailNotification)
            self.isRegistrantsConfirmationEmail = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsConfirmationEmail)
            self.isMeetingAuthentication = try values.decodeIfPresent(Bool.self, forKey: .isMeetingAuthentication)
            self.authenticationOption = try values.decodeIfPresent(String.self, forKey: .authenticationOption)
            self.authenticationDomains = try values.decodeIfPresent(String.self, forKey: .authenticationDomains)
            self.authenticationName = try values.decodeIfPresent(String.self, forKey: .authenticationName)
            self.isShowShareButton = try values.decodeIfPresent(Bool.self, forKey: .isShowShareButton)
            self.allowMultipleDevices = try values.decodeIfPresent(Bool.self, forKey: .allowMultipleDevices)
            self.encryptionType = try values.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
            self.approvedOrDeniedCountriesOrRegions = try values.decodeIfPresent(ApprovedOrDeniedCountriesOrRegions.self, forKey: .approvedOrDeniedCountriesOrRegions)
            self.authenticationException = try values.decodeIfPresent([AuthenticationExceptionItem].self, forKey: .authenticationException)
            self.breakoutRoom = try values.decodeIfPresent(BreakoutRoom.self, forKey: .breakoutRoom)
            self.languageInterpretation = try values.decodeIfPresent(LanguageInterpretation.self, forKey: .languageInterpretation)
            self.customKeys = try values.decodeIfPresent([CustomKey].self, forKey: .customKeys)
            self.isAlternativeHostsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isAlternativeHostsEmailNotification) ?? true
            self.isFocusMode = try values.decodeIfPresent(Bool.self, forKey: .isFocusMode)
            self.isPrivateMeeting = try values.decodeIfPresent(Bool.self, forKey: .isPrivateMeeting)
            self.calendarType = try values.decodeIfPresent(Int.self, forKey: .calendarType)
        }
    }

    /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
    public struct Recurrence: Codable {
        /// Recurrence meeting types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
        public var type: Int
        /// Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
        /// 
        /// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
        public var repeatInterval: Int?
        /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
        /// 
        ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public var weeklyDays: WeeklyDays?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
        /// 
        /// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
        public var monthlyDay: Int?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
        public var monthlyWeek: Int?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field. 
        /// 
        /// <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public var monthlyWeekDay: Int?
        /// Select how many times the meeting should recur before it is canceled. (Cannot be used with "end_date_time".)
        public var endTimes: Int?
        /// Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
        public var endDateTime: Date?

        /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
        /// 
        ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public enum WeeklyDays: String, Codable, CaseIterable {
            case _1 = "1"
            case _2 = "2"
            case _3 = "3"
            case _4 = "4"
            case _5 = "5"
            case _6 = "6"
            case _7 = "7"
        }

        public init(type: Int, repeatInterval: Int? = nil, weeklyDays: WeeklyDays? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
            self.type = type
            self.repeatInterval = repeatInterval
            self.weeklyDays = weeklyDays
            self.monthlyDay = monthlyDay
            self.monthlyWeek = monthlyWeek
            self.monthlyWeekDay = monthlyWeekDay
            self.endTimes = endTimes
            self.endDateTime = endDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case repeatInterval = "repeat_interval"
            case weeklyDays = "weekly_days"
            case monthlyDay = "monthly_day"
            case monthlyWeek = "monthly_week"
            case monthlyWeekDay = "monthly_week_day"
            case endTimes = "end_times"
            case endDateTime = "end_date_time"
        }
    }

    public init(topic: String? = nil, type: Int? = nil, isPreSchedule: Bool? = nil, startTime: Date? = nil, duration: Int? = nil, timezone: String? = nil, createdAt: Date? = nil, agenda: String? = nil, startURL: String? = nil, joinURL: String? = nil, password: String? = nil, h323Password: String? = nil, pmi: Int? = nil, trackingFields: [TrackingField]? = nil, occurrences: [Occurrence]? = nil, settings: Settings? = nil, recurrence: Recurrence? = nil) {
        self.topic = topic
        self.type = type
        self.isPreSchedule = isPreSchedule ?? false
        self.startTime = startTime
        self.duration = duration
        self.timezone = timezone
        self.createdAt = createdAt
        self.agenda = agenda
        self.startURL = startURL
        self.joinURL = joinURL
        self.password = password
        self.h323Password = h323Password
        self.pmi = pmi
        self.trackingFields = trackingFields
        self.occurrences = occurrences
        self.settings = settings
        self.recurrence = recurrence
    }

    private enum CodingKeys: String, CodingKey {
        case topic
        case type
        case isPreSchedule = "pre_schedule"
        case startTime = "start_time"
        case duration
        case timezone
        case createdAt = "created_at"
        case agenda
        case startURL = "start_url"
        case joinURL = "join_url"
        case password
        case h323Password = "h323_password"
        case pmi
        case trackingFields = "tracking_fields"
        case occurrences
        case settings
        case recurrence
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.topic = try values.decodeIfPresent(String.self, forKey: .topic)
        self.type = try values.decodeIfPresent(Int.self, forKey: .type)
        self.isPreSchedule = try values.decodeIfPresent(Bool.self, forKey: .isPreSchedule) ?? false
        self.startTime = try values.decodeIfPresent(Date.self, forKey: .startTime)
        self.duration = try values.decodeIfPresent(Int.self, forKey: .duration)
        self.timezone = try values.decodeIfPresent(String.self, forKey: .timezone)
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: .createdAt)
        self.agenda = try values.decodeIfPresent(String.self, forKey: .agenda)
        self.startURL = try values.decodeIfPresent(String.self, forKey: .startURL)
        self.joinURL = try values.decodeIfPresent(String.self, forKey: .joinURL)
        self.password = try values.decodeIfPresent(String.self, forKey: .password)
        self.h323Password = try values.decodeIfPresent(String.self, forKey: .h323Password)
        self.pmi = try values.decodeIfPresent(Int.self, forKey: .pmi)
        self.trackingFields = try values.decodeIfPresent([TrackingField].self, forKey: .trackingFields)
        self.occurrences = try values.decodeIfPresent([Occurrence].self, forKey: .occurrences)
        self.settings = try values.decodeIfPresent(Settings.self, forKey: .settings)
        self.recurrence = try values.decodeIfPresent(Recurrence.self, forKey: .recurrence)
    }
}

/// Registration List
///
/// List of users.
public struct MeetingRegistrantList: Codable {
    /// The number of pages returned for the request made.
    public var pageCount: Int?
    /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
    public var pageNumber: Int?
    /// The number of records returned with a single API call.
    public var pageSize: Int?
    /// The total number of all the records available across pages.
    public var totalRecords: Int?
    /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
    public var nextPageToken: String?
    /// List of registrant objects.
    public var registrants: [Registrant]?

    public struct Registrant: Codable {
        /// Registrant ID.
        public var id: String?
        /// Registrant.
        public var b: B
        /// The status of the registrant's registration. <br> `approved`: User has been successfully approved for the webinar.<br> `pending`:  The registration is still pending.<br> `denied`: User has been denied from joining the webinar.
        public var status: String?
        /// The time at which the registrant registered.
        public var createTime: Date?
        /// The URL using which an approved registrant can join the webinar.
        public var joinURL: String?

        /// Registrant.
        public struct B: Codable {
            /// The registrant's email address.
            public var email: String
            /// The registrant's status: 
            /// * `approved` — Registrant is approved. 
            /// * `denied` — Registrant is denied. 
            /// * `pending` — Registrant is waiting for approval.
            public var status: Status?
            /// The registrant's first name.
            public var firstName: String
            /// The registrant's last name.
            public var lastName: String?
            /// The registrant's address.
            public var address: String?
            /// The registrant's city.
            public var city: String?
            /// The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
            public var country: String?
            /// The registrant's ZIP or postal code.
            public var zip: String?
            /// The registrant's state or province.
            public var state: String?
            /// The registrant's phone number.
            public var phone: String?
            /// The registrant's industry.
            public var industry: String?
            /// The registrant's organization.
            public var org: String?
            /// The registrant's job title.
            public var jobTitle: String?
            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public var purchasingTimeFrame: PurchasingTimeFrame?
            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public var roleInPurchaseProcess: RoleInPurchaseProcess?
            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public var noOfEmployees: NoOfEmployees?
            /// The registrant's questions and comments.
            public var comments: String?
            /// Information about custom questions.
            public var customQuestions: [CustomQuestion]?

            /// The registrant's status: 
            /// * `approved` — Registrant is approved. 
            /// * `denied` — Registrant is denied. 
            /// * `pending` — Registrant is waiting for approval.
            public enum Status: String, Codable, CaseIterable {
                case approved
                case denied
                case pending
            }

            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public enum PurchasingTimeFrame: String, Codable, CaseIterable {
                case empty = ""
                case withinAMonth = "Within a month"
                case _13Months = "1-3 months"
                case _46Months = "4-6 months"
                case moreThan6Months = "More than 6 months"
                case noTimeframe = "No timeframe"
            }

            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public enum RoleInPurchaseProcess: String, Codable, CaseIterable {
                case empty = ""
                case decisionMaker = "Decision Maker"
                case evaluatorRecommender = "Evaluator/Recommender"
                case influencer = "Influencer"
                case notInvolved = "Not involved"
            }

            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public enum NoOfEmployees: String, Codable, CaseIterable {
                case empty = ""
                case _120 = "1-20"
                case _2150 = "21-50"
                case _51100 = "51-100"
                case _101500 = "101-500"
                case _5001000 = "500-1,000"
                case _10015000 = "1,001-5,000"
                case _500110000 = "5,001-10,000"
                case moreThan10000 = "More than 10,000"
            }

            /// Information about custom questions.
            public struct CustomQuestion: Codable {
                /// The title of the custom question.
                public var title: String?
                /// The custom question's response value. This has a limit of 128 characters.
                public var value: String?

                public init(title: String? = nil, value: String? = nil) {
                    self.title = title
                    self.value = value
                }
            }

            public init(email: String, status: Status? = nil, firstName: String, lastName: String? = nil, address: String? = nil, city: String? = nil, country: String? = nil, zip: String? = nil, state: String? = nil, phone: String? = nil, industry: String? = nil, org: String? = nil, jobTitle: String? = nil, purchasingTimeFrame: PurchasingTimeFrame? = nil, roleInPurchaseProcess: RoleInPurchaseProcess? = nil, noOfEmployees: NoOfEmployees? = nil, comments: String? = nil, customQuestions: [CustomQuestion]? = nil) {
                self.email = email
                self.status = status
                self.firstName = firstName
                self.lastName = lastName
                self.address = address
                self.city = city
                self.country = country
                self.zip = zip
                self.state = state
                self.phone = phone
                self.industry = industry
                self.org = org
                self.jobTitle = jobTitle
                self.purchasingTimeFrame = purchasingTimeFrame
                self.roleInPurchaseProcess = roleInPurchaseProcess
                self.noOfEmployees = noOfEmployees
                self.comments = comments
                self.customQuestions = customQuestions
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.email = try values.decode(String.self, forKey: "email")
                self.status = try Status(from: decoder)
                self.firstName = try values.decode(String.self, forKey: "first_name")
                self.lastName = try values.decodeIfPresent(String.self, forKey: "last_name")
                self.address = try values.decodeIfPresent(String.self, forKey: "address")
                self.city = try values.decodeIfPresent(String.self, forKey: "city")
                self.country = try values.decodeIfPresent(String.self, forKey: "country")
                self.zip = try values.decodeIfPresent(String.self, forKey: "zip")
                self.state = try values.decodeIfPresent(String.self, forKey: "state")
                self.phone = try values.decodeIfPresent(String.self, forKey: "phone")
                self.industry = try values.decodeIfPresent(String.self, forKey: "industry")
                self.org = try values.decodeIfPresent(String.self, forKey: "org")
                self.jobTitle = try values.decodeIfPresent(String.self, forKey: "job_title")
                self.purchasingTimeFrame = try PurchasingTimeFrame(from: decoder)
                self.roleInPurchaseProcess = try RoleInPurchaseProcess(from: decoder)
                self.noOfEmployees = try NoOfEmployees(from: decoder)
                self.comments = try values.decodeIfPresent(String.self, forKey: "comments")
                self.customQuestions = try values.decodeIfPresent([CustomQuestion].self, forKey: "custom_questions")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(email, forKey: "email")
                try values.encodeIfPresent(status, forKey: "status")
                try values.encode(firstName, forKey: "first_name")
                try values.encodeIfPresent(lastName, forKey: "last_name")
                try values.encodeIfPresent(address, forKey: "address")
                try values.encodeIfPresent(city, forKey: "city")
                try values.encodeIfPresent(country, forKey: "country")
                try values.encodeIfPresent(zip, forKey: "zip")
                try values.encodeIfPresent(state, forKey: "state")
                try values.encodeIfPresent(phone, forKey: "phone")
                try values.encodeIfPresent(industry, forKey: "industry")
                try values.encodeIfPresent(org, forKey: "org")
                try values.encodeIfPresent(jobTitle, forKey: "job_title")
                try values.encodeIfPresent(purchasingTimeFrame, forKey: "purchasing_time_frame")
                try values.encodeIfPresent(roleInPurchaseProcess, forKey: "role_in_purchase_process")
                try values.encodeIfPresent(noOfEmployees, forKey: "no_of_employees")
                try values.encodeIfPresent(comments, forKey: "comments")
                try values.encodeIfPresent(customQuestions, forKey: "custom_questions")
            }
        }

        public init(id: String? = nil, b: B, status: String? = nil, createTime: Date? = nil, joinURL: String? = nil) {
            self.id = id
            self.b = b
            self.status = status
            self.createTime = createTime
            self.joinURL = joinURL
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.b = try B(from: decoder)
            self.status = try values.decodeIfPresent(String.self, forKey: "status")
            self.createTime = try values.decodeIfPresent(Date.self, forKey: "create_time")
            self.joinURL = try values.decodeIfPresent(String.self, forKey: "join_url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encode(b, forKey: "b")
            try values.encodeIfPresent(status, forKey: "status")
            try values.encodeIfPresent(createTime, forKey: "create_time")
            try values.encodeIfPresent(joinURL, forKey: "join_url")
        }
    }

    public init(pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil, registrants: [Registrant]? = nil) {
        self.pageCount = pageCount
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.totalRecords = totalRecords
        self.nextPageToken = nextPageToken
        self.registrants = registrants
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.pageCount = try values.decodeIfPresent(Int.self, forKey: "page_count")
        self.pageNumber = try values.decodeIfPresent(Int.self, forKey: "page_number")
        self.pageSize = try values.decodeIfPresent(Int.self, forKey: "page_size")
        self.totalRecords = try values.decodeIfPresent(Int.self, forKey: "total_records")
        self.nextPageToken = try values.decodeIfPresent(String.self, forKey: "next_page_token")
        self.registrants = try values.decodeIfPresent([Registrant].self, forKey: "registrants")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(pageCount, forKey: "page_count")
        try values.encodeIfPresent(pageNumber, forKey: "page_number")
        try values.encodeIfPresent(pageSize, forKey: "page_size")
        try values.encodeIfPresent(totalRecords, forKey: "total_records")
        try values.encodeIfPresent(nextPageToken, forKey: "next_page_token")
        try values.encodeIfPresent(registrants, forKey: "registrants")
    }
}

/// The base meeting object.
public struct MeetingCreate: Codable {
    /// The meeting's topic.
    public var topic: String?
    /// The type of meeting:
    /// * `1` — An instant meeting. 
    /// * `2` — A scheduled meeting. 
    /// * `3` — A recurring meeting with no fixed time. 
    /// * `8` — A recurring meeting with fixed time.
    public var type: Int?
    /// Whether to create a prescheduled meeting via the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This **only** supports the meeting `type` value of `2` (scheduled meetings) and `3` (recurring meetings with no fixed time): 
    /// * `true` — Create a prescheduled meeting. 
    /// * `false` — Create a regular meeting.
    public var isPreSchedule: Bool
    /// The meeting's start time. This field is only used for scheduled and/or recurring meetings with a fixed time. This supports local time and GMT formats. 
    /// * To set a meeting's start time in GMT, use the `yyyy-MM-ddTHH:mm:ssZ` date-time format. For example, `2020-03-31T12:02:00Z`. 
    /// * To set a meeting's start time using a specific timezone, use the `yyyy-MM-ddTHH:mm:ss` date-time format and specify the [timezone ID](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#timezones) in the `timezone` field. If you do not specify a timezone, the `timezone` value defaults to your Zoom account's timezone. You can also use `UTC` for the `timezone` value.
    public var startTime: Date?
    /// The meeting's scheduled duration, in minutes. This field is only used for scheduled meetings (`2`).
    public var duration: Int?
    /// The email address or user ID of the user to schedule a meeting for.
    public var scheduleFor: String?
    /// The timezome to assign to the `start_time` value. This field is only used for scheduled meetings (`2`).
    /// 
    /// For a list of supported timezones and their format, refer to our [timezone list documentation](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#timezones).
    public var timezone: String?
    /// The password required to join the meeting. By default, a password can **only** have a maximum length of 10 characters and only contain alphanumeric characters and the `@`, `-`, `_`, and `*` characters. 
    /// * If the account owner or administrator has configured [minimum passcode requirement settings](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604), the password **must** meet those requirements. 
    /// * If password requirements are enabled, use the [**Get User Settings**](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings) API or the [**Get Account Settings**](https://marketplace.zoom.us/docs/api-reference/zoom-api/accounts/accountsettings) API to get the requirements.
    public var password: String?
    /// Whether to generate a default password using the user's settings. This value defaults to `false`. 
    /// 
    /// If this value is `true` and the user has the PMI setting enabled with a password, then the user's meetings will use the PMI password. It will **not** use a default password.
    public var isDefaultPassword: Bool
    /// The meeting's agenda. This value has a maximum length of 2,000 characters.
    public var agenda: String?
    /// Information about the meeting's tracking fields.
    public var trackingFields: [TrackingField]?
    /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
    public var recurrence: Recurrence?
    /// Information about the meeting's settings.
    public var settings: Settings?
    /// The **account admin meeting template** ID with which to schedule a meeting using a [meeting template](https://support.zoom.us/hc/en-us/articles/360036559151-Meeting-templates). For a list of account admin-provided meeting templates, use the [**List meeting templates**](https://marketplace.zoom.us/docs/api-reference/zoom-api/meetings/listmeetingtemplates) API. 
    /// * At this time, this field **only** accepts account admin meeting template IDs. 
    /// * To enable the account admin meeting templates feature, [contact Zoom support](https://support.zoom.us/hc/en-us).
    public var templateID: String?

    public struct TrackingField: Codable {
        /// The tracking field's label.
        public var field: String
        /// The tracking field's value.
        public var value: String?

        public init(field: String, value: String? = nil) {
            self.field = field
            self.value = value
        }
    }

    /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
    public struct Recurrence: Codable {
        /// Recurrence meeting types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
        public var type: Int
        /// Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
        /// 
        /// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
        public var repeatInterval: Int?
        /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
        /// 
        ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public var weeklyDays: WeeklyDays?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
        /// 
        /// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
        public var monthlyDay: Int?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
        public var monthlyWeek: Int?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field. 
        /// 
        /// <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public var monthlyWeekDay: Int?
        /// Select how many times the meeting should recur before it is canceled. (Cannot be used with "end_date_time".)
        public var endTimes: Int?
        /// Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
        public var endDateTime: Date?

        /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
        /// 
        ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public enum WeeklyDays: String, Codable, CaseIterable {
            case _1 = "1"
            case _2 = "2"
            case _3 = "3"
            case _4 = "4"
            case _5 = "5"
            case _6 = "6"
            case _7 = "7"
        }

        public init(type: Int, repeatInterval: Int? = nil, weeklyDays: WeeklyDays? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
            self.type = type
            self.repeatInterval = repeatInterval
            self.weeklyDays = weeklyDays
            self.monthlyDay = monthlyDay
            self.monthlyWeek = monthlyWeek
            self.monthlyWeekDay = monthlyWeekDay
            self.endTimes = endTimes
            self.endDateTime = endDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case repeatInterval = "repeat_interval"
            case weeklyDays = "weekly_days"
            case monthlyDay = "monthly_day"
            case monthlyWeek = "monthly_week"
            case monthlyWeekDay = "monthly_week_day"
            case endTimes = "end_times"
            case endDateTime = "end_date_time"
        }
    }

    /// Information about the meeting's settings.
    public struct Settings: Codable {
        /// Whether to start meetings with the host video on.
        public var isHostVideo: Bool?
        /// Whether to start meetings with the participant video on.
        public var isParticipantVideo: Bool?
        /// Whether to host the meeting in China (CN). This value defaults to `false`.
        public var isCnMeeting: Bool
        /// Whether to host the meeting in India (IN). This value defaults to `false`.
        public var isInMeeting: Bool
        /// Whether participants can join the meeting before its host. This field is only used for scheduled meetings (`2`) or recurring meetings (`3` and `8`). This value defaults to `false`.
        /// 
        /// If the [**Waiting Room** feature](https://support.zoom.us/hc/en-us/articles/115000332726-Waiting-Room) is enabled, this setting is **disabled**.
        public var isJoinBeforeHost: Bool
        /// If the value of the `join_before_host` field is `true`, this field indicates the time limits within which a participant can join a meeting before the meeting's host:
        /// 
        /// * `0` — Allow the participant to join the meeting at anytime.
        /// * `5` — Allow the participant to join 5 minutes before the meeting's start time.
        /// * `10` — Allow the participant to join 10 minutes before the meeting's start time.
        public var jbhTime: Int?
        /// Whether to mute participants upon entry.
        public var isMuteUponEntry: Bool
        /// Whether to add a watermark when viewing a shared screen.
        public var isWatermark: Bool
        /// Whether to use a [PMI (Personal Meeting ID)](https://support.zoom.us/hc/en-us/articles/203276937-Using-Personal-Meeting-ID-PMI-) instead of a generated meeting ID. This field is only used for scheduled meetings (`2`), instant meetings (`1`), or recurring meetings with no fixed time (`3`). This value defaults to `false`.
        public var usePmi: Bool
        /// Enable meeting registration approval: 
        /// * `0` — Automatically approve registration.
        /// * `1` — Manually approve registration.
        /// * `2` — No registration required.
        /// 
        /// This value defaults to `2`.
        public var approvalType: Int?
        /// The meeting's registration type: 
        /// * `1` — Attendees register once and can attend any meeting occurrence. 
        /// * `2` — Attendees must register for each meeting occurrence. 
        /// * `3` — Attendees register once and can select one or more meeting occurrences to attend.
        /// 
        /// This field is only for recurring meetings with fixed times (`8`). This value defaults to `1`.
        public var registrationType: Int?
        /// How participants join the audio portion of the meeting: 
        /// * `both` — Both telephony and VoIP. 
        /// * `telephony` — Telephony only. 
        /// * `voip` — VoIP only.
        /// 
        /// This value defaults to `both`.
        public var audio: Audio?
        /// The automatic recording settings: 
        /// * `local` — Record the meeting locally. 
        /// * `cloud` — Record the meeting to the cloud. 
        /// * `none` — Auto-recording disabled.
        /// 
        /// This value defaults to `none`.
        public var autoRecording: AutoRecording?
        /// A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.
        public var alternativeHosts: String?
        /// Whether to close registration after the event date. This value defaults to `false`.
        public var isCloseRegistration: Bool
        /// Whether to enable the [**Waiting Room** feature](https://support.zoom.us/hc/en-us/articles/115000332726-Waiting-Room). If this value is `true`, this **disables** the `join_before_host` setting.
        public var isWaitingRoom: Bool?
        /// A list of available global dial-in countries.
        public var globalDialInCountries: [String]?
        /// The contact name for meeting registration.
        public var contactName: String?
        /// The contact email address for meeting registration.
        public var contactEmail: String?
        /// Whether to send registrants email notifications about their registration approval, cancellation, or rejection:
        /// 
        /// * `true` — Send an email notification.
        /// * `false` — Do not send an email notification.
        /// 
        ///  Set this value to `true` to also use the `registrants_confirmation_email` parameter.
        public var isRegistrantsEmailNotification: Bool?
        /// Whether to send registrants an email confirmation: 
        /// * `true` — Send a confirmation email. 
        /// * `false` — Do not send a confirmation email.
        public var isRegistrantsConfirmationEmail: Bool?
        /// If true, only [authenticated](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) users can join the meeting.
        public var isMeetingAuthentication: Bool?
        /// If the `meeting_authentication` value is `true`, the type of authentication required for users to join a meeting.
        /// 
        /// To get this value, use the `authentication_options` array's `id` value in the [**Get User Settings**](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings) API response.
        public var authenticationOption: String?
        /// The meeting's authenticated domains. Only Zoom users whose email address contains an authenticated domain can join the meeting. Comma-separate multiple domains or use a wildcard for listing domains.
        public var authenticationDomains: String?
        /// A list of participants that can bypass meeting authentication. These participants will receive a unique meeting invite.
        public var authenticationException: [AuthenticationExceptionItem]?
        /// Add additional meeting [data center regions](https://support.zoom.us/hc/en-us/articles/360042411451-Selecting-data-center-regions-for-hosted-meetings-and-webinars). Provide this value as an array of [country codes](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries) for the countries available as data center regions in the [**Account Profile**](https://zoom.us/account/setting) interface but have been opted out of in the [user settings](https://zoom.us/profile).
        /// 
        /// For example, the data center regions selected in your [**Account Profile**](https://zoom.us/account) are "Europe", "Hong Kong SAR", "Australia", "India", "Japan", "China", "United States", and "Canada". However, in the [**My Profile**](https://zoom.us/profile) settings, you did **not** select "India" and "Japan" for meeting and webinar traffic routing.
        /// 
        /// To include "India" and "Japan" as additional data centers, use the `["IN", "TY"]` value for this field.
        public var additionalDataCenterRegions: [String]?
        /// The [pre-assigned breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms) settings.
        public var breakoutRoom: BreakoutRoom?
        /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
        /// 
        /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
        public var languageInterpretation: LanguageInterpretation?
        /// Whether to include social media sharing buttons on the meeting's registration page. This setting is only applied to meetings with registration enabled.
        public var isShowShareButton: Bool?
        /// Whether to allow attendees to join a meeting from multiple devices. This setting is only applied to meetings with registration enabled.
        public var allowMultipleDevices: Bool?
        /// The type of [end-to-end (E2EE) encryption](https://support.zoom.us/hc/en-us/articles/360048660871) to use for the meeting: 
        /// * `enhanced_encryption` — Enhanced encryption. Encryption is stored in the cloud when you enable this option. 
        /// * `e2ee` — End-to-end encryption. The encryption key is stored on your local device and **cannot** be obtained by anyone else. When you use E2EE encryption, [certain features](https://support.zoom.us/hc/en-us/articles/360048660871), such as cloud recording or phone and SIP/H.323 dial-in, are **disabled**.
        public var encryptionType: EncryptionType?
        /// The list of approved or blocked users from specific countries or regions who can join the meeting.
        public var approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions?
        /// Whether to send email notifications to alternative hosts. This value defaults to `true`.
        public var isAlternativeHostsEmailNotification: Bool
        /// Whether to enable the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) when the meeting starts.
        public var isFocusMode: Bool?
        /// A list of the meeting's invitees.
        public var meetingInvitees: [MeetingInvitee]?
        /// Whether to set the meeting as private.
        public var isPrivateMeeting: Bool?
        /// The calendar type: 
        /// * `1` — Outlook calendar. 
        /// * `2` — Google Calendar.
        public var calendarType: Int?

        /// How participants join the audio portion of the meeting: 
        /// * `both` — Both telephony and VoIP. 
        /// * `telephony` — Telephony only. 
        /// * `voip` — VoIP only.
        /// 
        /// This value defaults to `both`.
        public enum Audio: String, Codable, CaseIterable {
            case both
            case telephony
            case voip
        }

        /// The automatic recording settings: 
        /// * `local` — Record the meeting locally. 
        /// * `cloud` — Record the meeting to the cloud. 
        /// * `none` — Auto-recording disabled.
        /// 
        /// This value defaults to `none`.
        public enum AutoRecording: String, Codable, CaseIterable {
            case local
            case cloud
            case `none`
        }

        public struct AuthenticationExceptionItem: Codable {
            /// The participant's name.
            public var name: String?
            /// The participant's email address.
            public var email: String?

            public init(name: String? = nil, email: String? = nil) {
                self.name = name
                self.email = email
            }
        }

        /// The [pre-assigned breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms) settings.
        public struct BreakoutRoom: Codable {
            /// Whether to enable the [**Breakout Room pre-assign**](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms) option.
            public var enable: Bool?
            /// Information about the breakout rooms.
            public var rooms: [Room]?

            public struct Room: Codable {
                /// The breakout room's name.
                public var name: String?
                /// The email addresses of the participants to assign to the breakout room.
                public var participants: [String]?

                public init(name: String? = nil, participants: [String]? = nil) {
                    self.name = name
                    self.participants = participants
                }
            }

            public init(enable: Bool? = nil, rooms: [Room]? = nil) {
                self.enable = enable
                self.rooms = rooms
            }
        }

        /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
        /// 
        /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
        public struct LanguageInterpretation: Codable {
            /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the meeting.
            public var enable: Bool?
            /// Information about the meeting's language interpreters.
            public var interpreters: [Interpreter]?

            public struct Interpreter: Codable {
                /// The interpreter's email address.
                public var email: String?
                /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
                /// 
                /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
                public var languages: String?

                public init(email: String? = nil, languages: String? = nil) {
                    self.email = email
                    self.languages = languages
                }
            }

            public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
                self.enable = enable
                self.interpreters = interpreters
            }
        }

        /// The type of [end-to-end (E2EE) encryption](https://support.zoom.us/hc/en-us/articles/360048660871) to use for the meeting: 
        /// * `enhanced_encryption` — Enhanced encryption. Encryption is stored in the cloud when you enable this option. 
        /// * `e2ee` — End-to-end encryption. The encryption key is stored on your local device and **cannot** be obtained by anyone else. When you use E2EE encryption, [certain features](https://support.zoom.us/hc/en-us/articles/360048660871), such as cloud recording or phone and SIP/H.323 dial-in, are **disabled**.
        public enum EncryptionType: String, Codable, CaseIterable {
            case enhancedEncryption = "enhanced_encryption"
            case e2ee
        }

        /// The list of approved or blocked users from specific countries or regions who can join the meeting.
        public struct ApprovedOrDeniedCountriesOrRegions: Codable {
            /// Whether to enable the [**Approve or block entry for users from specific countries/regions**](https://support.zoom.us/hc/en-us/articles/360060086231-Approve-or-block-entry-for-users-from-specific-countries-regions) setting.
            public var enable: Bool?
            /// Whether to allow or block users from specific countries or regions: 
            /// * `approve` — Allow users from specific countries or regions to join the meeting. If you select this setting, you must include the approved countries or regions in the `approved_list` field. 
            /// * `deny` — Block users from specific countries or regions from joining the meeting. If you select this setting, you must include the blocked countries or regions in the `denied_list` field.
            public var method: Method?
            /// The list of approved countries or regions.
            public var approvedList: [String]?
            /// The list of blocked countries or regions.
            public var deniedList: [String]?

            /// Whether to allow or block users from specific countries or regions: 
            /// * `approve` — Allow users from specific countries or regions to join the meeting. If you select this setting, you must include the approved countries or regions in the `approved_list` field. 
            /// * `deny` — Block users from specific countries or regions from joining the meeting. If you select this setting, you must include the blocked countries or regions in the `denied_list` field.
            public enum Method: String, Codable, CaseIterable {
                case approve
                case deny
            }

            public init(enable: Bool? = nil, method: Method? = nil, approvedList: [String]? = nil, deniedList: [String]? = nil) {
                self.enable = enable
                self.method = method
                self.approvedList = approvedList
                self.deniedList = deniedList
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case method
                case approvedList = "approved_list"
                case deniedList = "denied_list"
            }
        }

        public struct MeetingInvitee: Codable {
            /// The invitee's email address.
            public var email: String?

            public init(email: String? = nil) {
                self.email = email
            }
        }

        public init(isHostVideo: Bool? = nil, isParticipantVideo: Bool? = nil, isCnMeeting: Bool? = nil, isInMeeting: Bool? = nil, isJoinBeforeHost: Bool? = nil, jbhTime: Int? = nil, isMuteUponEntry: Bool? = nil, isWatermark: Bool? = nil, usePmi: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isWaitingRoom: Bool? = nil, globalDialInCountries: [String]? = nil, contactName: String? = nil, contactEmail: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isRegistrantsConfirmationEmail: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, authenticationException: [AuthenticationExceptionItem]? = nil, additionalDataCenterRegions: [String]? = nil, breakoutRoom: BreakoutRoom? = nil, languageInterpretation: LanguageInterpretation? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, encryptionType: EncryptionType? = nil, approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions? = nil, isAlternativeHostsEmailNotification: Bool? = nil, isFocusMode: Bool? = nil, meetingInvitees: [MeetingInvitee]? = nil, isPrivateMeeting: Bool? = nil, calendarType: Int? = nil) {
            self.isHostVideo = isHostVideo
            self.isParticipantVideo = isParticipantVideo
            self.isCnMeeting = isCnMeeting ?? false
            self.isInMeeting = isInMeeting ?? false
            self.isJoinBeforeHost = isJoinBeforeHost ?? false
            self.jbhTime = jbhTime
            self.isMuteUponEntry = isMuteUponEntry ?? false
            self.isWatermark = isWatermark ?? false
            self.usePmi = usePmi ?? false
            self.approvalType = approvalType
            self.registrationType = registrationType
            self.audio = audio
            self.autoRecording = autoRecording
            self.alternativeHosts = alternativeHosts
            self.isCloseRegistration = isCloseRegistration ?? false
            self.isWaitingRoom = isWaitingRoom
            self.globalDialInCountries = globalDialInCountries
            self.contactName = contactName
            self.contactEmail = contactEmail
            self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
            self.isRegistrantsConfirmationEmail = isRegistrantsConfirmationEmail
            self.isMeetingAuthentication = isMeetingAuthentication
            self.authenticationOption = authenticationOption
            self.authenticationDomains = authenticationDomains
            self.authenticationException = authenticationException
            self.additionalDataCenterRegions = additionalDataCenterRegions
            self.breakoutRoom = breakoutRoom
            self.languageInterpretation = languageInterpretation
            self.isShowShareButton = isShowShareButton
            self.allowMultipleDevices = allowMultipleDevices
            self.encryptionType = encryptionType
            self.approvedOrDeniedCountriesOrRegions = approvedOrDeniedCountriesOrRegions
            self.isAlternativeHostsEmailNotification = isAlternativeHostsEmailNotification ?? true
            self.isFocusMode = isFocusMode
            self.meetingInvitees = meetingInvitees
            self.isPrivateMeeting = isPrivateMeeting
            self.calendarType = calendarType
        }

        private enum CodingKeys: String, CodingKey {
            case isHostVideo = "host_video"
            case isParticipantVideo = "participant_video"
            case isCnMeeting = "cn_meeting"
            case isInMeeting = "in_meeting"
            case isJoinBeforeHost = "join_before_host"
            case jbhTime = "jbh_time"
            case isMuteUponEntry = "mute_upon_entry"
            case isWatermark = "watermark"
            case usePmi = "use_pmi"
            case approvalType = "approval_type"
            case registrationType = "registration_type"
            case audio
            case autoRecording = "auto_recording"
            case alternativeHosts = "alternative_hosts"
            case isCloseRegistration = "close_registration"
            case isWaitingRoom = "waiting_room"
            case globalDialInCountries = "global_dial_in_countries"
            case contactName = "contact_name"
            case contactEmail = "contact_email"
            case isRegistrantsEmailNotification = "registrants_email_notification"
            case isRegistrantsConfirmationEmail = "registrants_confirmation_email"
            case isMeetingAuthentication = "meeting_authentication"
            case authenticationOption = "authentication_option"
            case authenticationDomains = "authentication_domains"
            case authenticationException = "authentication_exception"
            case additionalDataCenterRegions = "additional_data_center_regions"
            case breakoutRoom = "breakout_room"
            case languageInterpretation = "language_interpretation"
            case isShowShareButton = "show_share_button"
            case allowMultipleDevices = "allow_multiple_devices"
            case encryptionType = "encryption_type"
            case approvedOrDeniedCountriesOrRegions = "approved_or_denied_countries_or_regions"
            case isAlternativeHostsEmailNotification = "alternative_hosts_email_notification"
            case isFocusMode = "focus_mode"
            case meetingInvitees = "meeting_invitees"
            case isPrivateMeeting = "private_meeting"
            case calendarType = "calendar_type"
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.isHostVideo = try values.decodeIfPresent(Bool.self, forKey: .isHostVideo)
            self.isParticipantVideo = try values.decodeIfPresent(Bool.self, forKey: .isParticipantVideo)
            self.isCnMeeting = try values.decodeIfPresent(Bool.self, forKey: .isCnMeeting) ?? false
            self.isInMeeting = try values.decodeIfPresent(Bool.self, forKey: .isInMeeting) ?? false
            self.isJoinBeforeHost = try values.decodeIfPresent(Bool.self, forKey: .isJoinBeforeHost) ?? false
            self.jbhTime = try values.decodeIfPresent(Int.self, forKey: .jbhTime)
            self.isMuteUponEntry = try values.decodeIfPresent(Bool.self, forKey: .isMuteUponEntry) ?? false
            self.isWatermark = try values.decodeIfPresent(Bool.self, forKey: .isWatermark) ?? false
            self.usePmi = try values.decodeIfPresent(Bool.self, forKey: .usePmi) ?? false
            self.approvalType = try values.decodeIfPresent(Int.self, forKey: .approvalType)
            self.registrationType = try values.decodeIfPresent(Int.self, forKey: .registrationType)
            self.audio = try values.decodeIfPresent(Audio.self, forKey: .audio)
            self.autoRecording = try values.decodeIfPresent(AutoRecording.self, forKey: .autoRecording)
            self.alternativeHosts = try values.decodeIfPresent(String.self, forKey: .alternativeHosts)
            self.isCloseRegistration = try values.decodeIfPresent(Bool.self, forKey: .isCloseRegistration) ?? false
            self.isWaitingRoom = try values.decodeIfPresent(Bool.self, forKey: .isWaitingRoom)
            self.globalDialInCountries = try values.decodeIfPresent([String].self, forKey: .globalDialInCountries)
            self.contactName = try values.decodeIfPresent(String.self, forKey: .contactName)
            self.contactEmail = try values.decodeIfPresent(String.self, forKey: .contactEmail)
            self.isRegistrantsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsEmailNotification)
            self.isRegistrantsConfirmationEmail = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsConfirmationEmail)
            self.isMeetingAuthentication = try values.decodeIfPresent(Bool.self, forKey: .isMeetingAuthentication)
            self.authenticationOption = try values.decodeIfPresent(String.self, forKey: .authenticationOption)
            self.authenticationDomains = try values.decodeIfPresent(String.self, forKey: .authenticationDomains)
            self.authenticationException = try values.decodeIfPresent([AuthenticationExceptionItem].self, forKey: .authenticationException)
            self.additionalDataCenterRegions = try values.decodeIfPresent([String].self, forKey: .additionalDataCenterRegions)
            self.breakoutRoom = try values.decodeIfPresent(BreakoutRoom.self, forKey: .breakoutRoom)
            self.languageInterpretation = try values.decodeIfPresent(LanguageInterpretation.self, forKey: .languageInterpretation)
            self.isShowShareButton = try values.decodeIfPresent(Bool.self, forKey: .isShowShareButton)
            self.allowMultipleDevices = try values.decodeIfPresent(Bool.self, forKey: .allowMultipleDevices)
            self.encryptionType = try values.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
            self.approvedOrDeniedCountriesOrRegions = try values.decodeIfPresent(ApprovedOrDeniedCountriesOrRegions.self, forKey: .approvedOrDeniedCountriesOrRegions)
            self.isAlternativeHostsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isAlternativeHostsEmailNotification) ?? true
            self.isFocusMode = try values.decodeIfPresent(Bool.self, forKey: .isFocusMode)
            self.meetingInvitees = try values.decodeIfPresent([MeetingInvitee].self, forKey: .meetingInvitees)
            self.isPrivateMeeting = try values.decodeIfPresent(Bool.self, forKey: .isPrivateMeeting)
            self.calendarType = try values.decodeIfPresent(Int.self, forKey: .calendarType)
        }
    }

    public init(topic: String? = nil, type: Int? = nil, isPreSchedule: Bool? = nil, startTime: Date? = nil, duration: Int? = nil, scheduleFor: String? = nil, timezone: String? = nil, password: String? = nil, isDefaultPassword: Bool? = nil, agenda: String? = nil, trackingFields: [TrackingField]? = nil, recurrence: Recurrence? = nil, settings: Settings? = nil, templateID: String? = nil) {
        self.topic = topic
        self.type = type
        self.isPreSchedule = isPreSchedule ?? false
        self.startTime = startTime
        self.duration = duration
        self.scheduleFor = scheduleFor
        self.timezone = timezone
        self.password = password
        self.isDefaultPassword = isDefaultPassword ?? false
        self.agenda = agenda
        self.trackingFields = trackingFields
        self.recurrence = recurrence
        self.settings = settings
        self.templateID = templateID
    }

    private enum CodingKeys: String, CodingKey {
        case topic
        case type
        case isPreSchedule = "pre_schedule"
        case startTime = "start_time"
        case duration
        case scheduleFor = "schedule_for"
        case timezone
        case password
        case isDefaultPassword = "default_password"
        case agenda
        case trackingFields = "tracking_fields"
        case recurrence
        case settings
        case templateID = "template_id"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.topic = try values.decodeIfPresent(String.self, forKey: .topic)
        self.type = try values.decodeIfPresent(Int.self, forKey: .type)
        self.isPreSchedule = try values.decodeIfPresent(Bool.self, forKey: .isPreSchedule) ?? false
        self.startTime = try values.decodeIfPresent(Date.self, forKey: .startTime)
        self.duration = try values.decodeIfPresent(Int.self, forKey: .duration)
        self.scheduleFor = try values.decodeIfPresent(String.self, forKey: .scheduleFor)
        self.timezone = try values.decodeIfPresent(String.self, forKey: .timezone)
        self.password = try values.decodeIfPresent(String.self, forKey: .password)
        self.isDefaultPassword = try values.decodeIfPresent(Bool.self, forKey: .isDefaultPassword) ?? false
        self.agenda = try values.decodeIfPresent(String.self, forKey: .agenda)
        self.trackingFields = try values.decodeIfPresent([TrackingField].self, forKey: .trackingFields)
        self.recurrence = try values.decodeIfPresent(Recurrence.self, forKey: .recurrence)
        self.settings = try values.decodeIfPresent(Settings.self, forKey: .settings)
        self.templateID = try values.decodeIfPresent(String.self, forKey: .templateID)
    }
}

public struct MeetingRegistrantQuestions: Codable {
    /// Array of Registrant Questions
    public var questions: [Question]?
    /// Array of Registrant Custom Questions
    public var customQuestions: [CustomQuestion]?

    public struct Question: Codable {
        /// Field name of the question.
        public var fieldName: FieldName?
        /// Indicates whether or not the displayed fields are required to be filled out by registrants.
        public var isRequired: Bool?

        /// Field name of the question.
        public enum FieldName: String, Codable, CaseIterable {
            case address
            case city
            case country
            case zip
            case state
            case phone
            case industry
            case org
            case jobTitle = "job_title"
            case purchasingTimeFrame = "purchasing_time_frame"
            case roleInPurchaseProcess = "role_in_purchase_process"
            case noOfEmployees = "no_of_employees"
            case comments
        }

        public init(fieldName: FieldName? = nil, isRequired: Bool? = nil) {
            self.fieldName = fieldName
            self.isRequired = isRequired
        }

        private enum CodingKeys: String, CodingKey {
            case fieldName = "field_name"
            case isRequired = "required"
        }
    }

    public struct CustomQuestion: Codable {
        /// Title of the custom question.
        public var title: String?
        /// Type of the question being asked.
        public var type: `Type`?
        /// Indicates whether or not the custom question is required to be answered by participants or not.
        public var isRequired: Bool?
        /// Answer choices for the question. Can not be used for `short` question type as this type of question requires registrants to type out the answer.
        public var answers: [String]?

        /// Type of the question being asked.
        public enum `Type`: String, Codable, CaseIterable {
            case short
            case single
        }

        public init(title: String? = nil, type: `Type`? = nil, isRequired: Bool? = nil, answers: [String]? = nil) {
            self.title = title
            self.type = type
            self.isRequired = isRequired
            self.answers = answers
        }

        private enum CodingKeys: String, CodingKey {
            case title
            case type
            case isRequired = "required"
            case answers
        }
    }

    public init(questions: [Question]? = nil, customQuestions: [CustomQuestion]? = nil) {
        self.questions = questions
        self.customQuestions = customQuestions
    }

    private enum CodingKeys: String, CodingKey {
        case questions
        case customQuestions = "custom_questions"
    }
}

/// Meeting object
public struct MeetingUpdate: Codable {
    /// Meeting topic.
    public var topic: String?
    /// Meeting Types:<br>`1` - Instant meeting.<br>`2` - Scheduled meeting.<br>`3` - Recurring meeting with no fixed time.<br>`8` - Recurring meeting with a fixed time.
    public var type: Int?
    /// Whether to create a prescheduled meeting via the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This **only** supports the meeting `type` value of `2` (scheduled meetings) and `3` (recurring meetings with no fixed time): 
    /// * `true` — Create a prescheduled meeting. 
    /// * `false` — Create a regular meeting.
    public var isPreSchedule: Bool
    /// Meeting start time. When using a format like "yyyy-MM-dd'T'HH:mm:ss'Z'", always use GMT time. When using a format like "yyyy-MM-dd'T'HH:mm:ss", you should use local time and  specify the time zone. Only used for scheduled meetings and recurring meetings with a fixed time.
    public var startTime: Date?
    /// Meeting duration (minutes). Used for scheduled meetings only.
    public var duration: Int?
    /// Time zone to format start_time. For example, "America/Los_Angeles". For scheduled meetings only. Please reference our [time zone](#timezones) list for supported time zones and their formats.
    public var timezone: String?
    /// Meeting passcode. Passcode may only contain the following characters: [a-z A-Z 0-9 @ - _ *] and can have a maximum of 10 characters.
    /// 
    /// **Note:** If the account owner or the admin has configured [minimum passcode requirement settings](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604), the passcode value provided here must meet those requirements. <br><br>If the requirements are enabled, you can view those requirements by calling either the [Get User Settings API](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings) or the  [Get Account Settings](https://marketplace.zoom.us/docs/api-reference/zoom-api/accounts/accountsettings) API.
    public var password: String?
    /// Meeting description.
    public var agenda: String?
    /// Unique identifier of the meeting template. 
    /// 
    /// Use this field if you would like to [schedule the meeting from a meeting template](https://support.zoom.us/hc/en-us/articles/360036559151-Meeting-templates#h_86f06cff-0852-4998-81c5-c83663c176fb). You can retrieve the value of this field by calling the [List meeting templates]() API.
    public var templateID: String?
    /// Tracking fields
    public var trackingFields: [TrackingField]?
    /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
    public var recurrence: Recurrence?
    public var settings: Settings?

    public struct TrackingField: Codable {
        /// Tracking fields type
        public var field: String?
        /// Tracking fields value
        public var value: String?

        public init(field: String? = nil, value: String? = nil) {
            self.field = field
            self.value = value
        }
    }

    /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
    public struct Recurrence: Codable {
        /// Recurrence meeting types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
        public var type: Int
        /// Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
        /// 
        /// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
        public var repeatInterval: Int?
        /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
        /// 
        ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public var weeklyDays: WeeklyDays?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
        /// 
        /// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
        public var monthlyDay: Int?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
        public var monthlyWeek: Int?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field. 
        /// 
        /// <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public var monthlyWeekDay: Int?
        /// Select how many times the meeting should recur before it is canceled. (Cannot be used with "end_date_time".)
        public var endTimes: Int?
        /// Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
        public var endDateTime: Date?

        /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
        /// 
        ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public enum WeeklyDays: String, Codable, CaseIterable {
            case _1 = "1"
            case _2 = "2"
            case _3 = "3"
            case _4 = "4"
            case _5 = "5"
            case _6 = "6"
            case _7 = "7"
        }

        public init(type: Int, repeatInterval: Int? = nil, weeklyDays: WeeklyDays? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
            self.type = type
            self.repeatInterval = repeatInterval
            self.weeklyDays = weeklyDays
            self.monthlyDay = monthlyDay
            self.monthlyWeek = monthlyWeek
            self.monthlyWeekDay = monthlyWeekDay
            self.endTimes = endTimes
            self.endDateTime = endDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case repeatInterval = "repeat_interval"
            case weeklyDays = "weekly_days"
            case monthlyDay = "monthly_day"
            case monthlyWeek = "monthly_week"
            case monthlyWeekDay = "monthly_week_day"
            case endTimes = "end_times"
            case endDateTime = "end_date_time"
        }
    }

    public struct Settings: Codable {
        /// Start video when the host joins the meeting.
        public var isHostVideo: Bool?
        /// Start video when participants join the meeting.
        public var isParticipantVideo: Bool?
        /// Host meeting in China.
        public var isCnMeeting: Bool
        /// Host meeting in India.
        public var isInMeeting: Bool
        /// Allow participants to join the meeting before the host starts the meeting. Only used for scheduled or recurring meetings.
        public var isJoinBeforeHost: Bool
        /// If the value of "join_before_host" field is set to true, this field can be used to indicate time limits within which a participant may join a meeting before a host. The value of this field can be one of the following:
        /// 
        /// *  `0`: Allow participant to join anytime.
        /// *  `5`: Allow participant to join 5 minutes before meeting start time.
        ///  * `10`: Allow participant to join 10 minutes before meeting start time.
        public var jbhTime: Int?
        /// Mute participants upon entry.
        public var isMuteUponEntry: Bool
        /// Add watermark when viewing a shared screen.
        public var isWatermark: Bool
        /// Use a personal meeting ID. Only used for scheduled meetings and recurring meetings with no fixed time.
        public var usePmi: Bool
        /// Enable registration and set approval for the registration. Note that this feature requires the host to be of **Licensed** user type. **Registration cannot be enabled for a basic user.** <br><br>
        /// 
        /// `0` - Automatically approve.<br>`1` - Manually approve.<br>`2` - No registration required.
        public var approvalType: Int?
        /// Registration type. Used for recurring meeting with fixed time only. <br>`1` Attendees register once and can attend any of the occurrences.<br>`2` Attendees need to register for each occurrence to attend.<br>`3` Attendees register once and can choose one or more occurrences to attend.
        public var registrationType: Int?
        /// Determine how participants can join the audio portion of the meeting.<br>`both` - Both Telephony and VoIP.<br>`telephony` - Telephony only.<br>`voip` - VoIP only.
        public var audio: Audio?
        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public var autoRecording: AutoRecording?
        /// Only signed in users can join this meeting.
        /// 
        /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
        public var enforceLogin: Bool?
        /// Only signed in users with specified domains can join meetings.
        /// 
        /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
        public var enforceLoginDomains: String?
        /// A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.
        public var alternativeHosts: String?
        /// Close registration after event date
        public var isCloseRegistration: Bool
        /// Enable waiting room
        public var isWaitingRoom: Bool
        /// List of global dial-in countries
        public var globalDialInCountries: [String]?
        /// Global Dial-in Countries/Regions
        public var globalDialInNumbers: [GlobalDialInNumber]?
        /// Contact name for registration
        public var contactName: String?
        /// Contact email for registration
        public var contactEmail: String?
        /// Whether to send registrants email notifications about their registration approval, cancellation, or rejection:
        /// 
        /// * `true` — Send an email notification.
        /// * `false` — Do not send an email notification.
        /// 
        ///  Set this value to `true` to also use the `registrants_confirmation_email` parameter.
        public var isRegistrantsEmailNotification: Bool?
        /// Whether to send registrants an email confirmation:
        /// * `true` — Send a confirmation email.
        /// * `false` — Do not send a confirmation email.
        public var isRegistrantsConfirmationEmail: Bool?
        /// `true`- Only authenticated users can join meetings.
        public var isMeetingAuthentication: Bool?
        /// Meeting authentication option id.
        public var authenticationOption: String?
        /// If user has configured ["Sign Into Zoom with Specified Domains"](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
        public var authenticationDomains: String?
        /// Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
        public var authenticationName: String?
        /// Show social share buttons on the meeting registration page.
        /// This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
        public var isShowShareButton: Bool?
        /// Allow attendees to join the meeting from multiple devices. This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
        public var allowMultipleDevices: Bool?
        /// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
        /// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
        /// 
        /// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
        public var encryptionType: EncryptionType?
        /// Approve or block users from specific regions/countries from joining this meeting.
        public var approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions?
        /// The participants added here will receive unique meeting invite links and bypass authentication.
        public var authenticationException: [AuthenticationExceptionItem]?
        /// Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
        public var breakoutRoom: BreakoutRoom?
        /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
        /// 
        /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
        public var languageInterpretation: LanguageInterpretation?
        /// Custom keys and values assigned to the meeting.
        public var customKeys: [CustomKey]?
        /// Flag to determine whether to send email notifications to alternative hosts, default value is true.
        public var isAlternativeHostsEmailNotification: Bool
        /// Whether the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) is enabled when the meeting starts.
        public var isFocusMode: Bool?
        /// Whether the meeting is set as private.
        public var isPrivateMeeting: Bool?
        /// The calendar type: 
        /// * `1` — Outlook calendar. 
        /// * `2` — Google Calendar.
        public var calendarType: Int?
        /// A list of the meeting's invitees.
        public var meetingInvitees: [MeetingInvitee]?

        /// Determine how participants can join the audio portion of the meeting.<br>`both` - Both Telephony and VoIP.<br>`telephony` - Telephony only.<br>`voip` - VoIP only.
        public enum Audio: String, Codable, CaseIterable {
            case both
            case telephony
            case voip
        }

        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public enum AutoRecording: String, Codable, CaseIterable {
            case local
            case cloud
            case `none`
        }

        public struct GlobalDialInNumber: Codable {
            /// Country code. For example, BR.
            public var country: String?
            /// Full name of country. For example, Brazil.
            public var countryName: String?
            /// City of the number, if any. For example, Chicago.
            public var city: String?
            /// Phone number. For example, +1 2332357613.
            public var number: String?
            /// Type of number.
            public var type: `Type`?

            /// Type of number.
            public enum `Type`: String, Codable, CaseIterable {
                case toll
                case tollfree
            }

            public init(country: String? = nil, countryName: String? = nil, city: String? = nil, number: String? = nil, type: `Type`? = nil) {
                self.country = country
                self.countryName = countryName
                self.city = city
                self.number = number
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case country
                case countryName = "country_name"
                case city
                case number
                case type
            }
        }

        /// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
        /// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
        /// 
        /// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
        public enum EncryptionType: String, Codable, CaseIterable {
            case enhancedEncryption = "enhanced_encryption"
            case e2ee
        }

        /// Approve or block users from specific regions/countries from joining this meeting.
        public struct ApprovedOrDeniedCountriesOrRegions: Codable {
            /// `true`: Setting enabled to either allow users or block users from specific regions to join your meetings. <br>
            /// 
            /// `false`: Setting disabled.
            public var enable: Bool?
            /// Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting. <br><br>
            /// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.<br><br>
            /// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
            public var method: Method?
            /// List of countries/regions from where participants can join this meeting.
            public var approvedList: [String]?
            /// List of countries/regions from where participants can not join this meeting.
            public var deniedList: [String]?

            /// Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting. <br><br>
            /// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.<br><br>
            /// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
            public enum Method: String, Codable, CaseIterable {
                case approve
                case deny
            }

            public init(enable: Bool? = nil, method: Method? = nil, approvedList: [String]? = nil, deniedList: [String]? = nil) {
                self.enable = enable
                self.method = method
                self.approvedList = approvedList
                self.deniedList = deniedList
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case method
                case approvedList = "approved_list"
                case deniedList = "denied_list"
            }
        }

        public struct AuthenticationExceptionItem: Codable {
            /// Name of the participant.
            public var name: String?
            /// Email address of the participant.
            public var email: String?

            public init(name: String? = nil, email: String? = nil) {
                self.name = name
                self.email = email
            }
        }

        /// Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
        public struct BreakoutRoom: Codable {
            /// Set the value of this field to `true` if you would like to enable the [breakout room pre-assign](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4) option.
            public var enable: Bool?
            /// Create room(s).
            public var rooms: [Room]?

            public struct Room: Codable {
                /// Name of the breakout room.
                public var name: String?
                /// Email addresses of the participants who are to be assigned to the breakout room.
                public var participants: [String]?

                public init(name: String? = nil, participants: [String]? = nil) {
                    self.name = name
                    self.participants = participants
                }
            }

            public init(enable: Bool? = nil, rooms: [Room]? = nil) {
                self.enable = enable
                self.rooms = rooms
            }
        }

        /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
        /// 
        /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
        public struct LanguageInterpretation: Codable {
            /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the meeting.
            public var enable: Bool?
            /// Information about the meeting's language interpreters.
            public var interpreters: [Interpreter]?

            public struct Interpreter: Codable {
                /// The interpreter's email address.
                public var email: String?
                /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
                /// 
                /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
                public var languages: String?

                public init(email: String? = nil, languages: String? = nil) {
                    self.email = email
                    self.languages = languages
                }
            }

            public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
                self.enable = enable
                self.interpreters = interpreters
            }
        }

        public struct CustomKey: Codable {
            /// Custom key associated with the user.
            public var key: String?
            /// Value of the custom key associated with the user.
            public var value: String?

            public init(key: String? = nil, value: String? = nil) {
                self.key = key
                self.value = value
            }
        }

        public struct MeetingInvitee: Codable {
            /// The invitee's email address.
            public var email: String?

            public init(email: String? = nil) {
                self.email = email
            }
        }

        public init(isHostVideo: Bool? = nil, isParticipantVideo: Bool? = nil, isCnMeeting: Bool? = nil, isInMeeting: Bool? = nil, isJoinBeforeHost: Bool? = nil, jbhTime: Int? = nil, isMuteUponEntry: Bool? = nil, isWatermark: Bool? = nil, usePmi: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, enforceLogin: Bool? = nil, enforceLoginDomains: String? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isWaitingRoom: Bool? = nil, globalDialInCountries: [String]? = nil, globalDialInNumbers: [GlobalDialInNumber]? = nil, contactName: String? = nil, contactEmail: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isRegistrantsConfirmationEmail: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, authenticationName: String? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, encryptionType: EncryptionType? = nil, approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions? = nil, authenticationException: [AuthenticationExceptionItem]? = nil, breakoutRoom: BreakoutRoom? = nil, languageInterpretation: LanguageInterpretation? = nil, customKeys: [CustomKey]? = nil, isAlternativeHostsEmailNotification: Bool? = nil, isFocusMode: Bool? = nil, isPrivateMeeting: Bool? = nil, calendarType: Int? = nil, meetingInvitees: [MeetingInvitee]? = nil) {
            self.isHostVideo = isHostVideo
            self.isParticipantVideo = isParticipantVideo
            self.isCnMeeting = isCnMeeting ?? false
            self.isInMeeting = isInMeeting ?? false
            self.isJoinBeforeHost = isJoinBeforeHost ?? false
            self.jbhTime = jbhTime
            self.isMuteUponEntry = isMuteUponEntry ?? false
            self.isWatermark = isWatermark ?? false
            self.usePmi = usePmi ?? false
            self.approvalType = approvalType
            self.registrationType = registrationType
            self.audio = audio
            self.autoRecording = autoRecording
            self.enforceLogin = enforceLogin
            self.enforceLoginDomains = enforceLoginDomains
            self.alternativeHosts = alternativeHosts
            self.isCloseRegistration = isCloseRegistration ?? false
            self.isWaitingRoom = isWaitingRoom ?? false
            self.globalDialInCountries = globalDialInCountries
            self.globalDialInNumbers = globalDialInNumbers
            self.contactName = contactName
            self.contactEmail = contactEmail
            self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
            self.isRegistrantsConfirmationEmail = isRegistrantsConfirmationEmail
            self.isMeetingAuthentication = isMeetingAuthentication
            self.authenticationOption = authenticationOption
            self.authenticationDomains = authenticationDomains
            self.authenticationName = authenticationName
            self.isShowShareButton = isShowShareButton
            self.allowMultipleDevices = allowMultipleDevices
            self.encryptionType = encryptionType
            self.approvedOrDeniedCountriesOrRegions = approvedOrDeniedCountriesOrRegions
            self.authenticationException = authenticationException
            self.breakoutRoom = breakoutRoom
            self.languageInterpretation = languageInterpretation
            self.customKeys = customKeys
            self.isAlternativeHostsEmailNotification = isAlternativeHostsEmailNotification ?? true
            self.isFocusMode = isFocusMode
            self.isPrivateMeeting = isPrivateMeeting
            self.calendarType = calendarType
            self.meetingInvitees = meetingInvitees
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isHostVideo = try values.decodeIfPresent(Bool.self, forKey: "host_video")
            self.isParticipantVideo = try values.decodeIfPresent(Bool.self, forKey: "participant_video")
            self.isCnMeeting = try values.decodeIfPresent(Bool.self, forKey: "cn_meeting") ?? false
            self.isInMeeting = try values.decodeIfPresent(Bool.self, forKey: "in_meeting") ?? false
            self.isJoinBeforeHost = try values.decodeIfPresent(Bool.self, forKey: "join_before_host") ?? false
            self.jbhTime = try values.decodeIfPresent(Int.self, forKey: "jbh_time")
            self.isMuteUponEntry = try values.decodeIfPresent(Bool.self, forKey: "mute_upon_entry") ?? false
            self.isWatermark = try values.decodeIfPresent(Bool.self, forKey: "watermark") ?? false
            self.usePmi = try values.decodeIfPresent(Bool.self, forKey: "use_pmi") ?? false
            self.approvalType = try values.decodeIfPresent(Int.self, forKey: "approval_type")
            self.registrationType = try values.decodeIfPresent(Int.self, forKey: "registration_type")
            self.audio = try Audio(from: decoder)
            self.autoRecording = try AutoRecording(from: decoder)
            self.enforceLogin = try values.decodeIfPresent(Bool.self, forKey: "enforce_login")
            self.enforceLoginDomains = try values.decodeIfPresent(String.self, forKey: "enforce_login_domains")
            self.alternativeHosts = try values.decodeIfPresent(String.self, forKey: "alternative_hosts")
            self.isCloseRegistration = try values.decodeIfPresent(Bool.self, forKey: "close_registration") ?? false
            self.isWaitingRoom = try values.decodeIfPresent(Bool.self, forKey: "waiting_room") ?? false
            self.globalDialInCountries = try values.decodeIfPresent([String].self, forKey: "global_dial_in_countries")
            self.globalDialInNumbers = try values.decodeIfPresent([GlobalDialInNumber].self, forKey: "global_dial_in_numbers")
            self.contactName = try values.decodeIfPresent(String.self, forKey: "contact_name")
            self.contactEmail = try values.decodeIfPresent(String.self, forKey: "contact_email")
            self.isRegistrantsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: "registrants_email_notification")
            self.isRegistrantsConfirmationEmail = try values.decodeIfPresent(Bool.self, forKey: "registrants_confirmation_email")
            self.isMeetingAuthentication = try values.decodeIfPresent(Bool.self, forKey: "meeting_authentication")
            self.authenticationOption = try values.decodeIfPresent(String.self, forKey: "authentication_option")
            self.authenticationDomains = try values.decodeIfPresent(String.self, forKey: "authentication_domains")
            self.authenticationName = try values.decodeIfPresent(String.self, forKey: "authentication_name")
            self.isShowShareButton = try values.decodeIfPresent(Bool.self, forKey: "show_share_button")
            self.allowMultipleDevices = try values.decodeIfPresent(Bool.self, forKey: "allow_multiple_devices")
            self.encryptionType = try EncryptionType(from: decoder)
            self.approvedOrDeniedCountriesOrRegions = try ApprovedOrDeniedCountriesOrRegions(from: decoder)
            self.authenticationException = try values.decodeIfPresent([AuthenticationExceptionItem].self, forKey: "authentication_exception")
            self.breakoutRoom = try BreakoutRoom(from: decoder)
            self.languageInterpretation = try LanguageInterpretation(from: decoder)
            self.customKeys = try values.decodeIfPresent([CustomKey].self, forKey: "custom_keys")
            self.isAlternativeHostsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: "alternative_hosts_email_notification") ?? true
            self.isFocusMode = try values.decodeIfPresent(Bool.self, forKey: "focus_mode")
            self.isPrivateMeeting = try values.decodeIfPresent(Bool.self, forKey: "private_meeting")
            self.calendarType = try values.decodeIfPresent(Int.self, forKey: "calendar_type")
            self.meetingInvitees = try values.decodeIfPresent([MeetingInvitee].self, forKey: "meeting_invitees")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(isHostVideo, forKey: "host_video")
            try values.encodeIfPresent(isParticipantVideo, forKey: "participant_video")
            try values.encodeIfPresent(isCnMeeting, forKey: "cn_meeting")
            try values.encodeIfPresent(isInMeeting, forKey: "in_meeting")
            try values.encodeIfPresent(isJoinBeforeHost, forKey: "join_before_host")
            try values.encodeIfPresent(jbhTime, forKey: "jbh_time")
            try values.encodeIfPresent(isMuteUponEntry, forKey: "mute_upon_entry")
            try values.encodeIfPresent(isWatermark, forKey: "watermark")
            try values.encodeIfPresent(usePmi, forKey: "use_pmi")
            try values.encodeIfPresent(approvalType, forKey: "approval_type")
            try values.encodeIfPresent(registrationType, forKey: "registration_type")
            try values.encodeIfPresent(audio, forKey: "audio")
            try values.encodeIfPresent(autoRecording, forKey: "auto_recording")
            try values.encodeIfPresent(enforceLogin, forKey: "enforce_login")
            try values.encodeIfPresent(enforceLoginDomains, forKey: "enforce_login_domains")
            try values.encodeIfPresent(alternativeHosts, forKey: "alternative_hosts")
            try values.encodeIfPresent(isCloseRegistration, forKey: "close_registration")
            try values.encodeIfPresent(isWaitingRoom, forKey: "waiting_room")
            try values.encodeIfPresent(globalDialInCountries, forKey: "global_dial_in_countries")
            try values.encodeIfPresent(globalDialInNumbers, forKey: "global_dial_in_numbers")
            try values.encodeIfPresent(contactName, forKey: "contact_name")
            try values.encodeIfPresent(contactEmail, forKey: "contact_email")
            try values.encodeIfPresent(isRegistrantsEmailNotification, forKey: "registrants_email_notification")
            try values.encodeIfPresent(isRegistrantsConfirmationEmail, forKey: "registrants_confirmation_email")
            try values.encodeIfPresent(isMeetingAuthentication, forKey: "meeting_authentication")
            try values.encodeIfPresent(authenticationOption, forKey: "authentication_option")
            try values.encodeIfPresent(authenticationDomains, forKey: "authentication_domains")
            try values.encodeIfPresent(authenticationName, forKey: "authentication_name")
            try values.encodeIfPresent(isShowShareButton, forKey: "show_share_button")
            try values.encodeIfPresent(allowMultipleDevices, forKey: "allow_multiple_devices")
            try values.encodeIfPresent(encryptionType, forKey: "encryption_type")
            try values.encodeIfPresent(approvedOrDeniedCountriesOrRegions, forKey: "approved_or_denied_countries_or_regions")
            try values.encodeIfPresent(authenticationException, forKey: "authentication_exception")
            try values.encodeIfPresent(breakoutRoom, forKey: "breakout_room")
            try values.encodeIfPresent(languageInterpretation, forKey: "language_interpretation")
            try values.encodeIfPresent(customKeys, forKey: "custom_keys")
            try values.encodeIfPresent(isAlternativeHostsEmailNotification, forKey: "alternative_hosts_email_notification")
            try values.encodeIfPresent(isFocusMode, forKey: "focus_mode")
            try values.encodeIfPresent(isPrivateMeeting, forKey: "private_meeting")
            try values.encodeIfPresent(calendarType, forKey: "calendar_type")
            try values.encodeIfPresent(meetingInvitees, forKey: "meeting_invitees")
        }
    }

    public init(topic: String? = nil, type: Int? = nil, isPreSchedule: Bool? = nil, startTime: Date? = nil, duration: Int? = nil, timezone: String? = nil, password: String? = nil, agenda: String? = nil, templateID: String? = nil, trackingFields: [TrackingField]? = nil, recurrence: Recurrence? = nil, settings: Settings? = nil) {
        self.topic = topic
        self.type = type
        self.isPreSchedule = isPreSchedule ?? false
        self.startTime = startTime
        self.duration = duration
        self.timezone = timezone
        self.password = password
        self.agenda = agenda
        self.templateID = templateID
        self.trackingFields = trackingFields
        self.recurrence = recurrence
        self.settings = settings
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.topic = try values.decodeIfPresent(String.self, forKey: "topic")
        self.type = try values.decodeIfPresent(Int.self, forKey: "type")
        self.isPreSchedule = try values.decodeIfPresent(Bool.self, forKey: "pre_schedule") ?? false
        self.startTime = try values.decodeIfPresent(Date.self, forKey: "start_time")
        self.duration = try values.decodeIfPresent(Int.self, forKey: "duration")
        self.timezone = try values.decodeIfPresent(String.self, forKey: "timezone")
        self.password = try values.decodeIfPresent(String.self, forKey: "password")
        self.agenda = try values.decodeIfPresent(String.self, forKey: "agenda")
        self.templateID = try values.decodeIfPresent(String.self, forKey: "template_id")
        self.trackingFields = try values.decodeIfPresent([TrackingField].self, forKey: "tracking_fields")
        self.recurrence = try Recurrence(from: decoder)
        self.settings = try Settings(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(topic, forKey: "topic")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encodeIfPresent(isPreSchedule, forKey: "pre_schedule")
        try values.encodeIfPresent(startTime, forKey: "start_time")
        try values.encodeIfPresent(duration, forKey: "duration")
        try values.encodeIfPresent(timezone, forKey: "timezone")
        try values.encodeIfPresent(password, forKey: "password")
        try values.encodeIfPresent(agenda, forKey: "agenda")
        try values.encodeIfPresent(templateID, forKey: "template_id")
        try values.encodeIfPresent(trackingFields, forKey: "tracking_fields")
        try values.encodeIfPresent(recurrence, forKey: "recurrence")
        try values.encodeIfPresent(settings, forKey: "settings")
    }
}

/// The recording meeting object.
public struct RecordingMeeting: Codable {
    /// Unique Meeting Identifier. Each instance of the meeting will have its own UUID.
    public var uuid: String?
    /// Meeting ID - also known as the meeting number.
    public var id: Int?
    /// Unique Identifier of the user account.
    public var accountID: String?
    /// ID of the user set as host of meeting.
    public var hostID: String?
    /// Meeting topic.
    public var topic: String?
    /// The time at which the meeting started.
    public var startTime: Date?
    /// Meeting duration.
    public var duration: Int?
    /// The total file size of the recording. This includes the `recording_files` and `participant_audio_files` files.
    public var totalSize: Int?
    /// The recording's associated type of meeting or webinar: 
    /// 
    /// If the recording is of a meeting: 
    /// * `1` — Instant meeting. 
    /// * `2` — Scheduled meeting. 
    /// * `3` — A recurring meeting with no fixed time. 
    /// * `4` — A meeting created via PMI (Personal Meeting ID). 
    /// * `7` — A [Personal Audio Conference](https://support.zoom.us/hc/en-us/articles/204517069-Getting-Started-with-Personal-Audio-Conference) (PAC). 
    /// * `8` - Recurring meeting with a fixed time. 
    /// 
    /// If the recording is of a webinar: 
    /// * `5` — A webinar. 
    /// * `6` — A recurring webinar without a fixed time 
    /// * `9` — A recurring webinar with a fixed time.
    /// 
    /// If the recording is **not** from a meeting or webinar: 
    /// 
    /// * `99` — A recording uploaded via the [**Recordings**](https://zoom.us/recording) interface on the Zoom Web Portal.
    public var type: `Type`?
    /// Number of recording files returned in the response of this API call. This includes the `recording_files` and  `participant_audio_files` files.
    public var recordingCount: String?
    /// Recording file List
    ///
    /// List of recording file.
    public var recordingFiles: [RecordingFile]

    /// The recording's associated type of meeting or webinar: 
    /// 
    /// If the recording is of a meeting: 
    /// * `1` — Instant meeting. 
    /// * `2` — Scheduled meeting. 
    /// * `3` — A recurring meeting with no fixed time. 
    /// * `4` — A meeting created via PMI (Personal Meeting ID). 
    /// * `7` — A [Personal Audio Conference](https://support.zoom.us/hc/en-us/articles/204517069-Getting-Started-with-Personal-Audio-Conference) (PAC). 
    /// * `8` - Recurring meeting with a fixed time. 
    /// 
    /// If the recording is of a webinar: 
    /// * `5` — A webinar. 
    /// * `6` — A recurring webinar without a fixed time 
    /// * `9` — A recurring webinar with a fixed time.
    /// 
    /// If the recording is **not** from a meeting or webinar: 
    /// 
    /// * `99` — A recording uploaded via the [**Recordings**](https://zoom.us/recording) interface on the Zoom Web Portal.
    public enum `Type`: String, Codable, CaseIterable {
        case _1 = "1"
        case _2 = "2"
        case _3 = "3"
        case _4 = "4"
        case _5 = "5"
        case _6 = "6"
        case _7 = "7"
        case _8 = "8"
        case _9 = "9"
        case _99 = "99"
    }

    public struct RecordingFile: Codable {
        /// The recording file ID. Included in the response of general query.
        public var id: String?
        /// The meeting ID.
        public var meetingID: String?
        /// The recording start time.
        public var recordingStart: String?
        /// The recording end time. Response in general query.
        public var recordingEnd: String?
        /// The recording file type. The value of this field could be one of the following:<br>
        /// `MP4`: Video file of the recording.<br>`M4A` Audio-only file of the recording.<br>`TIMELINE`: Timestamp file of the recording in JSON file format. To get a timeline file, the "Add a timestamp to the recording" setting must be enabled in the [recording settings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-recording#h_3f14c3a4-d16b-4a3c-bbe5-ef7d24500048). The time will display in the host's timezone, set on their Zoom profile.
        /// <br> `TRANSCRIPT`: Transcription file of the recording in VTT format.<br> `CHAT`: A TXT file containing in-meeting chat messages that were sent during the meeting.<br>`CC`: File containing closed captions of the recording in VTT file format.<br>`CSV`: File containing polling data in csv format.
        /// 
        /// <br>
        /// 
        /// A recording file object with file type of either `CC` or `TIMELINE` **does not have** the following properties:<br>
        /// 	`id`, `status`, `file_size`, `recording_type`, and `play_url`.
        public var fileType: String?
        /// The recording file size.
        public var fileSize: Double?
        /// The URL using which a recording file can be played.
        public var playURL: String?
        /// The URL at which to download the the recording. 
        /// 
        /// **JWT apps** 
        /// 
        /// To access a private or password-protected cloud recording of a user in your account, use a [Zoom JWT app](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app). Use the generated JWT token as the value of the `access_token` query parameter and include this query parameter at the end of the URL. For example: 
        /// 
        /// `https://{{base-domain}}/recording/download/{{path-to-file-download}}?access_token={{JWT-token}}` 
        /// 
        /// **OAuth apps** 
        /// 
        /// If a user has authorized and installed your OAuth app that contains recording scopes, use the user's [OAuth access token](https://marketplace.zoom.us/docs/guides/auth/oauth) to download the file. For example: 
        /// 
        /// `https://{{base-domain}}/rec/archive/download/xxx?access_token={{OAuth-access-token}}` 
        /// 
        /// **Note:** This field does **not** return for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). Instead, this API will return the `file_path` field.
        public var downloadURL: String?
        /// The file path to the On-Premise account recording. 
        /// 
        /// **Note:** This API only returns this field for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). It does **not** return the `download_url` field.
        public var filePath: String?
        /// The recording status.
        public var status: Status?
        /// The time at which recording was deleted. Returned in the response only for trash query.
        public var deletedTime: String?
        /// The recording type. The value of this field can be one of the following:<br>`shared_screen_with_speaker_view(CC)`<br>`shared_screen_with_speaker_view`<br>`shared_screen_with_gallery_view`<br>`speaker_view`<br>`gallery_view`<br>`shared_screen`<br>`audio_only`<br>`audio_transcript`<br>`chat_file`<br>`active_speaker`<br>`poll`<br>`timeline`<br>`closed_caption`
        public var recordingType: String?

        /// The recording status.
        public enum Status: String, Codable, CaseIterable {
            case completed
        }

        public init(id: String? = nil, meetingID: String? = nil, recordingStart: String? = nil, recordingEnd: String? = nil, fileType: String? = nil, fileSize: Double? = nil, playURL: String? = nil, downloadURL: String? = nil, filePath: String? = nil, status: Status? = nil, deletedTime: String? = nil, recordingType: String? = nil) {
            self.id = id
            self.meetingID = meetingID
            self.recordingStart = recordingStart
            self.recordingEnd = recordingEnd
            self.fileType = fileType
            self.fileSize = fileSize
            self.playURL = playURL
            self.downloadURL = downloadURL
            self.filePath = filePath
            self.status = status
            self.deletedTime = deletedTime
            self.recordingType = recordingType
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.meetingID = try values.decodeIfPresent(String.self, forKey: "meeting_id")
            self.recordingStart = try values.decodeIfPresent(String.self, forKey: "recording_start")
            self.recordingEnd = try values.decodeIfPresent(String.self, forKey: "recording_end")
            self.fileType = try values.decodeIfPresent(String.self, forKey: "file_type")
            self.fileSize = try values.decodeIfPresent(Double.self, forKey: "file_size")
            self.playURL = try values.decodeIfPresent(String.self, forKey: "play_url")
            self.downloadURL = try values.decodeIfPresent(String.self, forKey: "download_url")
            self.filePath = try values.decodeIfPresent(String.self, forKey: "file_path")
            self.status = try Status(from: decoder)
            self.deletedTime = try values.decodeIfPresent(String.self, forKey: "deleted_time")
            self.recordingType = try values.decodeIfPresent(String.self, forKey: "recording_type")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(meetingID, forKey: "meeting_id")
            try values.encodeIfPresent(recordingStart, forKey: "recording_start")
            try values.encodeIfPresent(recordingEnd, forKey: "recording_end")
            try values.encodeIfPresent(fileType, forKey: "file_type")
            try values.encodeIfPresent(fileSize, forKey: "file_size")
            try values.encodeIfPresent(playURL, forKey: "play_url")
            try values.encodeIfPresent(downloadURL, forKey: "download_url")
            try values.encodeIfPresent(filePath, forKey: "file_path")
            try values.encodeIfPresent(status, forKey: "status")
            try values.encodeIfPresent(deletedTime, forKey: "deleted_time")
            try values.encodeIfPresent(recordingType, forKey: "recording_type")
        }
    }

    public init(uuid: String? = nil, id: Int? = nil, accountID: String? = nil, hostID: String? = nil, topic: String? = nil, startTime: Date? = nil, duration: Int? = nil, totalSize: Int? = nil, type: `Type`? = nil, recordingCount: String? = nil, recordingFiles: [RecordingFile]) {
        self.uuid = uuid
        self.id = id
        self.accountID = accountID
        self.hostID = hostID
        self.topic = topic
        self.startTime = startTime
        self.duration = duration
        self.totalSize = totalSize
        self.type = type
        self.recordingCount = recordingCount
        self.recordingFiles = recordingFiles
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.accountID = try values.decodeIfPresent(String.self, forKey: "account_id")
        self.hostID = try values.decodeIfPresent(String.self, forKey: "host_id")
        self.topic = try values.decodeIfPresent(String.self, forKey: "topic")
        self.startTime = try values.decodeIfPresent(Date.self, forKey: "start_time")
        self.duration = try values.decodeIfPresent(Int.self, forKey: "duration")
        self.totalSize = try values.decodeIfPresent(Int.self, forKey: "total_size")
        self.type = try `Type`(from: decoder)
        self.recordingCount = try values.decodeIfPresent(String.self, forKey: "recording_count")
        self.recordingFiles = try values.decode([RecordingFile].self, forKey: "recordingFiles")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(uuid, forKey: "uuid")
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(accountID, forKey: "account_id")
        try values.encodeIfPresent(hostID, forKey: "host_id")
        try values.encodeIfPresent(topic, forKey: "topic")
        try values.encodeIfPresent(startTime, forKey: "start_time")
        try values.encodeIfPresent(duration, forKey: "duration")
        try values.encodeIfPresent(totalSize, forKey: "total_size")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encodeIfPresent(recordingCount, forKey: "recording_count")
        try values.encode(recordingFiles, forKey: "recordingFiles")
    }
}

public struct RecordingFile: Codable {
    /// The recording file ID. Included in the response of general query.
    public var id: String?
    /// The meeting ID.
    public var meetingID: String?
    /// The recording start time.
    public var recordingStart: String?
    /// The recording end time. Response in general query.
    public var recordingEnd: String?
    /// The recording file type. The value of this field could be one of the following:<br>
    /// `MP4`: Video file of the recording.<br>`M4A` Audio-only file of the recording.<br>`TIMELINE`: Timestamp file of the recording in JSON file format. To get a timeline file, the "Add a timestamp to the recording" setting must be enabled in the [recording settings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-recording#h_3f14c3a4-d16b-4a3c-bbe5-ef7d24500048). The time will display in the host's timezone, set on their Zoom profile.
    /// <br> `TRANSCRIPT`: Transcription file of the recording in VTT format.<br> `CHAT`: A TXT file containing in-meeting chat messages that were sent during the meeting.<br>`CC`: File containing closed captions of the recording in VTT file format.<br>`CSV`: File containing polling data in csv format.
    /// 
    /// <br>
    /// 
    /// A recording file object with file type of either `CC` or `TIMELINE` **does not have** the following properties:<br>
    /// 	`id`, `status`, `file_size`, `recording_type`, and `play_url`.
    public var fileType: String?
    /// The recording file size.
    public var fileSize: Double?
    /// The URL using which a recording file can be played.
    public var playURL: String?
    /// The URL at which to download the the recording. 
    /// 
    /// **JWT apps** 
    /// 
    /// To access a private or password-protected cloud recording of a user in your account, use a [Zoom JWT app](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app). Use the generated JWT token as the value of the `access_token` query parameter and include this query parameter at the end of the URL. For example: 
    /// 
    /// `https://{{base-domain}}/recording/download/{{path-to-file-download}}?access_token={{JWT-token}}` 
    /// 
    /// **OAuth apps** 
    /// 
    /// If a user has authorized and installed your OAuth app that contains recording scopes, use the user's [OAuth access token](https://marketplace.zoom.us/docs/guides/auth/oauth) to download the file. For example: 
    /// 
    /// `https://{{base-domain}}/rec/archive/download/xxx?access_token={{OAuth-access-token}}` 
    /// 
    /// **Note:** This field does **not** return for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). Instead, this API will return the `file_path` field.
    public var downloadURL: String?
    /// The file path to the On-Premise account recording. 
    /// 
    /// **Note:** This API only returns this field for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). It does **not** return the `download_url` field.
    public var filePath: String?
    /// The recording status.
    public var status: Status?
    /// The time at which recording was deleted. Returned in the response only for trash query.
    public var deletedTime: String?
    /// The recording type. The value of this field can be one of the following:<br>`shared_screen_with_speaker_view(CC)`<br>`shared_screen_with_speaker_view`<br>`shared_screen_with_gallery_view`<br>`speaker_view`<br>`gallery_view`<br>`shared_screen`<br>`audio_only`<br>`audio_transcript`<br>`chat_file`<br>`active_speaker`<br>`poll`<br>`timeline`<br>`closed_caption`
    public var recordingType: String?

    /// The recording status.
    public enum Status: String, Codable, CaseIterable {
        case completed
    }

    public init(id: String? = nil, meetingID: String? = nil, recordingStart: String? = nil, recordingEnd: String? = nil, fileType: String? = nil, fileSize: Double? = nil, playURL: String? = nil, downloadURL: String? = nil, filePath: String? = nil, status: Status? = nil, deletedTime: String? = nil, recordingType: String? = nil) {
        self.id = id
        self.meetingID = meetingID
        self.recordingStart = recordingStart
        self.recordingEnd = recordingEnd
        self.fileType = fileType
        self.fileSize = fileSize
        self.playURL = playURL
        self.downloadURL = downloadURL
        self.filePath = filePath
        self.status = status
        self.deletedTime = deletedTime
        self.recordingType = recordingType
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.meetingID = try values.decodeIfPresent(String.self, forKey: "meeting_id")
        self.recordingStart = try values.decodeIfPresent(String.self, forKey: "recording_start")
        self.recordingEnd = try values.decodeIfPresent(String.self, forKey: "recording_end")
        self.fileType = try values.decodeIfPresent(String.self, forKey: "file_type")
        self.fileSize = try values.decodeIfPresent(Double.self, forKey: "file_size")
        self.playURL = try values.decodeIfPresent(String.self, forKey: "play_url")
        self.downloadURL = try values.decodeIfPresent(String.self, forKey: "download_url")
        self.filePath = try values.decodeIfPresent(String.self, forKey: "file_path")
        self.status = try Status(from: decoder)
        self.deletedTime = try values.decodeIfPresent(String.self, forKey: "deleted_time")
        self.recordingType = try values.decodeIfPresent(String.self, forKey: "recording_type")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(meetingID, forKey: "meeting_id")
        try values.encodeIfPresent(recordingStart, forKey: "recording_start")
        try values.encodeIfPresent(recordingEnd, forKey: "recording_end")
        try values.encodeIfPresent(fileType, forKey: "file_type")
        try values.encodeIfPresent(fileSize, forKey: "file_size")
        try values.encodeIfPresent(playURL, forKey: "play_url")
        try values.encodeIfPresent(downloadURL, forKey: "download_url")
        try values.encodeIfPresent(filePath, forKey: "file_path")
        try values.encodeIfPresent(status, forKey: "status")
        try values.encodeIfPresent(deletedTime, forKey: "deleted_time")
        try values.encodeIfPresent(recordingType, forKey: "recording_type")
    }
}

/// Recording file object.
public struct Recording: Codable {
    /// The recording file ID. Included in the response of general query.
    public var id: String?
    /// The meeting ID.
    public var meetingID: String?
    /// The recording start time.
    public var recordingStart: String?
    /// The recording end time. Response in general query.
    public var recordingEnd: String?
    /// The recording file type. The value of this field could be one of the following:<br>
    /// `MP4`: Video file of the recording.<br>`M4A` Audio-only file of the recording.<br>`TIMELINE`: Timestamp file of the recording in JSON file format. To get a timeline file, the "Add a timestamp to the recording" setting must be enabled in the [recording settings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-recording#h_3f14c3a4-d16b-4a3c-bbe5-ef7d24500048). The time will display in the host's timezone, set on their Zoom profile.
    /// <br> `TRANSCRIPT`: Transcription file of the recording in VTT format.<br> `CHAT`: A TXT file containing in-meeting chat messages that were sent during the meeting.<br>`CC`: File containing closed captions of the recording in VTT file format.<br>`CSV`: File containing polling data in csv format.
    /// 
    /// <br>
    /// 
    /// A recording file object with file type of either `CC` or `TIMELINE` **does not have** the following properties:<br>
    /// 	`id`, `status`, `file_size`, `recording_type`, and `play_url`.
    public var fileType: String?
    /// The recording file size.
    public var fileSize: Double?
    /// The URL using which a recording file can be played.
    public var playURL: String?
    /// The URL at which to download the the recording. 
    /// 
    /// **JWT apps** 
    /// 
    /// To access a private or password-protected cloud recording of a user in your account, use a [Zoom JWT app](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app). Use the generated JWT token as the value of the `access_token` query parameter and include this query parameter at the end of the URL. For example: 
    /// 
    /// `https://{{base-domain}}/recording/download/{{path-to-file-download}}?access_token={{JWT-token}}` 
    /// 
    /// **OAuth apps** 
    /// 
    /// If a user has authorized and installed your OAuth app that contains recording scopes, use the user's [OAuth access token](https://marketplace.zoom.us/docs/guides/auth/oauth) to download the file. For example: 
    /// 
    /// `https://{{base-domain}}/rec/archive/download/xxx?access_token={{OAuth-access-token}}` 
    /// 
    /// **Note:** This field does **not** return for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). Instead, this API will return the `file_path` field.
    public var downloadURL: String?
    /// The file path to the On-Premise account recording. 
    /// 
    /// **Note:** This API only returns this field for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). It does **not** return the `download_url` field.
    public var filePath: String?
    /// The recording status.
    public var status: Status?
    /// The time at which recording was deleted. Returned in the response only for trash query.
    public var deletedTime: String?
    /// The recording type. The value of this field can be one of the following:<br>`shared_screen_with_speaker_view(CC)`<br>`shared_screen_with_speaker_view`<br>`shared_screen_with_gallery_view`<br>`speaker_view`<br>`gallery_view`<br>`shared_screen`<br>`audio_only`<br>`audio_transcript`<br>`chat_file`<br>`active_speaker`<br>`poll`<br>`timeline`<br>`closed_caption`
    public var recordingType: String?

    /// The recording status.
    public enum Status: String, Codable, CaseIterable {
        case completed
    }

    public init(id: String? = nil, meetingID: String? = nil, recordingStart: String? = nil, recordingEnd: String? = nil, fileType: String? = nil, fileSize: Double? = nil, playURL: String? = nil, downloadURL: String? = nil, filePath: String? = nil, status: Status? = nil, deletedTime: String? = nil, recordingType: String? = nil) {
        self.id = id
        self.meetingID = meetingID
        self.recordingStart = recordingStart
        self.recordingEnd = recordingEnd
        self.fileType = fileType
        self.fileSize = fileSize
        self.playURL = playURL
        self.downloadURL = downloadURL
        self.filePath = filePath
        self.status = status
        self.deletedTime = deletedTime
        self.recordingType = recordingType
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case meetingID = "meeting_id"
        case recordingStart = "recording_start"
        case recordingEnd = "recording_end"
        case fileType = "file_type"
        case fileSize = "file_size"
        case playURL = "play_url"
        case downloadURL = "download_url"
        case filePath = "file_path"
        case status
        case deletedTime = "deleted_time"
        case recordingType = "recording_type"
    }
}

/// DateTime Object.
public struct DateTime: Codable {
    /// Start Date.
    public var from: NaiveDate?
    /// End Date.
    public var to: NaiveDate?

    public init(from: NaiveDate? = nil, to: NaiveDate? = nil) {
        self.from = from
        self.to = to
    }
}

/// Recording List
///
/// List of recordings.
public struct RecordingMeetingList: Codable {
    /// Start Date.
    public var from: NaiveDate?
    /// End Date.
    public var to: NaiveDate?
    /// The number of pages returned for the request made.
    public var pageCount: Int?
    /// The number of records returned within a single API call.
    public var pageSize: Int?
    /// The number of all records available across pages.
    public var totalRecords: Int?
    /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
    public var nextPageToken: String?
    /// Recording List
    ///
    /// List of recordings.
    public var meetings: [Meeting]?

    /// The recording meeting object.
    public struct Meeting: Codable {
        /// Unique Meeting Identifier. Each instance of the meeting will have its own UUID.
        public var uuid: String?
        /// Meeting ID - also known as the meeting number.
        public var id: Int?
        /// Unique Identifier of the user account.
        public var accountID: String?
        /// ID of the user set as host of meeting.
        public var hostID: String?
        /// Meeting topic.
        public var topic: String?
        /// The time at which the meeting started.
        public var startTime: Date?
        /// Meeting duration.
        public var duration: Int?
        /// The total file size of the recording. This includes the `recording_files` and `participant_audio_files` files.
        public var totalSize: Int?
        /// The recording's associated type of meeting or webinar: 
        /// 
        /// If the recording is of a meeting: 
        /// * `1` — Instant meeting. 
        /// * `2` — Scheduled meeting. 
        /// * `3` — A recurring meeting with no fixed time. 
        /// * `4` — A meeting created via PMI (Personal Meeting ID). 
        /// * `7` — A [Personal Audio Conference](https://support.zoom.us/hc/en-us/articles/204517069-Getting-Started-with-Personal-Audio-Conference) (PAC). 
        /// * `8` - Recurring meeting with a fixed time. 
        /// 
        /// If the recording is of a webinar: 
        /// * `5` — A webinar. 
        /// * `6` — A recurring webinar without a fixed time 
        /// * `9` — A recurring webinar with a fixed time.
        /// 
        /// If the recording is **not** from a meeting or webinar: 
        /// 
        /// * `99` — A recording uploaded via the [**Recordings**](https://zoom.us/recording) interface on the Zoom Web Portal.
        public var type: `Type`?
        /// Number of recording files returned in the response of this API call. This includes the `recording_files` and  `participant_audio_files` files.
        public var recordingCount: String?
        /// Recording file List
        ///
        /// List of recording file.
        public var recordingFiles: [RecordingFile]

        /// The recording's associated type of meeting or webinar: 
        /// 
        /// If the recording is of a meeting: 
        /// * `1` — Instant meeting. 
        /// * `2` — Scheduled meeting. 
        /// * `3` — A recurring meeting with no fixed time. 
        /// * `4` — A meeting created via PMI (Personal Meeting ID). 
        /// * `7` — A [Personal Audio Conference](https://support.zoom.us/hc/en-us/articles/204517069-Getting-Started-with-Personal-Audio-Conference) (PAC). 
        /// * `8` - Recurring meeting with a fixed time. 
        /// 
        /// If the recording is of a webinar: 
        /// * `5` — A webinar. 
        /// * `6` — A recurring webinar without a fixed time 
        /// * `9` — A recurring webinar with a fixed time.
        /// 
        /// If the recording is **not** from a meeting or webinar: 
        /// 
        /// * `99` — A recording uploaded via the [**Recordings**](https://zoom.us/recording) interface on the Zoom Web Portal.
        public enum `Type`: String, Codable, CaseIterable {
            case _1 = "1"
            case _2 = "2"
            case _3 = "3"
            case _4 = "4"
            case _5 = "5"
            case _6 = "6"
            case _7 = "7"
            case _8 = "8"
            case _9 = "9"
            case _99 = "99"
        }

        public struct RecordingFile: Codable {
            /// The recording file ID. Included in the response of general query.
            public var id: String?
            /// The meeting ID.
            public var meetingID: String?
            /// The recording start time.
            public var recordingStart: String?
            /// The recording end time. Response in general query.
            public var recordingEnd: String?
            /// The recording file type. The value of this field could be one of the following:<br>
            /// `MP4`: Video file of the recording.<br>`M4A` Audio-only file of the recording.<br>`TIMELINE`: Timestamp file of the recording in JSON file format. To get a timeline file, the "Add a timestamp to the recording" setting must be enabled in the [recording settings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-recording#h_3f14c3a4-d16b-4a3c-bbe5-ef7d24500048). The time will display in the host's timezone, set on their Zoom profile.
            /// <br> `TRANSCRIPT`: Transcription file of the recording in VTT format.<br> `CHAT`: A TXT file containing in-meeting chat messages that were sent during the meeting.<br>`CC`: File containing closed captions of the recording in VTT file format.<br>`CSV`: File containing polling data in csv format.
            /// 
            /// <br>
            /// 
            /// A recording file object with file type of either `CC` or `TIMELINE` **does not have** the following properties:<br>
            /// 	`id`, `status`, `file_size`, `recording_type`, and `play_url`.
            public var fileType: String?
            /// The recording file size.
            public var fileSize: Double?
            /// The URL using which a recording file can be played.
            public var playURL: String?
            /// The URL at which to download the the recording. 
            /// 
            /// **JWT apps** 
            /// 
            /// To access a private or password-protected cloud recording of a user in your account, use a [Zoom JWT app](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app). Use the generated JWT token as the value of the `access_token` query parameter and include this query parameter at the end of the URL. For example: 
            /// 
            /// `https://{{base-domain}}/recording/download/{{path-to-file-download}}?access_token={{JWT-token}}` 
            /// 
            /// **OAuth apps** 
            /// 
            /// If a user has authorized and installed your OAuth app that contains recording scopes, use the user's [OAuth access token](https://marketplace.zoom.us/docs/guides/auth/oauth) to download the file. For example: 
            /// 
            /// `https://{{base-domain}}/rec/archive/download/xxx?access_token={{OAuth-access-token}}` 
            /// 
            /// **Note:** This field does **not** return for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). Instead, this API will return the `file_path` field.
            public var downloadURL: String?
            /// The file path to the On-Premise account recording. 
            /// 
            /// **Note:** This API only returns this field for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). It does **not** return the `download_url` field.
            public var filePath: String?
            /// The recording status.
            public var status: Status?
            /// The time at which recording was deleted. Returned in the response only for trash query.
            public var deletedTime: String?
            /// The recording type. The value of this field can be one of the following:<br>`shared_screen_with_speaker_view(CC)`<br>`shared_screen_with_speaker_view`<br>`shared_screen_with_gallery_view`<br>`speaker_view`<br>`gallery_view`<br>`shared_screen`<br>`audio_only`<br>`audio_transcript`<br>`chat_file`<br>`active_speaker`<br>`poll`<br>`timeline`<br>`closed_caption`
            public var recordingType: String?

            /// The recording status.
            public enum Status: String, Codable, CaseIterable {
                case completed
            }

            public init(id: String? = nil, meetingID: String? = nil, recordingStart: String? = nil, recordingEnd: String? = nil, fileType: String? = nil, fileSize: Double? = nil, playURL: String? = nil, downloadURL: String? = nil, filePath: String? = nil, status: Status? = nil, deletedTime: String? = nil, recordingType: String? = nil) {
                self.id = id
                self.meetingID = meetingID
                self.recordingStart = recordingStart
                self.recordingEnd = recordingEnd
                self.fileType = fileType
                self.fileSize = fileSize
                self.playURL = playURL
                self.downloadURL = downloadURL
                self.filePath = filePath
                self.status = status
                self.deletedTime = deletedTime
                self.recordingType = recordingType
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decodeIfPresent(String.self, forKey: "id")
                self.meetingID = try values.decodeIfPresent(String.self, forKey: "meeting_id")
                self.recordingStart = try values.decodeIfPresent(String.self, forKey: "recording_start")
                self.recordingEnd = try values.decodeIfPresent(String.self, forKey: "recording_end")
                self.fileType = try values.decodeIfPresent(String.self, forKey: "file_type")
                self.fileSize = try values.decodeIfPresent(Double.self, forKey: "file_size")
                self.playURL = try values.decodeIfPresent(String.self, forKey: "play_url")
                self.downloadURL = try values.decodeIfPresent(String.self, forKey: "download_url")
                self.filePath = try values.decodeIfPresent(String.self, forKey: "file_path")
                self.status = try Status(from: decoder)
                self.deletedTime = try values.decodeIfPresent(String.self, forKey: "deleted_time")
                self.recordingType = try values.decodeIfPresent(String.self, forKey: "recording_type")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(id, forKey: "id")
                try values.encodeIfPresent(meetingID, forKey: "meeting_id")
                try values.encodeIfPresent(recordingStart, forKey: "recording_start")
                try values.encodeIfPresent(recordingEnd, forKey: "recording_end")
                try values.encodeIfPresent(fileType, forKey: "file_type")
                try values.encodeIfPresent(fileSize, forKey: "file_size")
                try values.encodeIfPresent(playURL, forKey: "play_url")
                try values.encodeIfPresent(downloadURL, forKey: "download_url")
                try values.encodeIfPresent(filePath, forKey: "file_path")
                try values.encodeIfPresent(status, forKey: "status")
                try values.encodeIfPresent(deletedTime, forKey: "deleted_time")
                try values.encodeIfPresent(recordingType, forKey: "recording_type")
            }
        }

        public init(uuid: String? = nil, id: Int? = nil, accountID: String? = nil, hostID: String? = nil, topic: String? = nil, startTime: Date? = nil, duration: Int? = nil, totalSize: Int? = nil, type: `Type`? = nil, recordingCount: String? = nil, recordingFiles: [RecordingFile]) {
            self.uuid = uuid
            self.id = id
            self.accountID = accountID
            self.hostID = hostID
            self.topic = topic
            self.startTime = startTime
            self.duration = duration
            self.totalSize = totalSize
            self.type = type
            self.recordingCount = recordingCount
            self.recordingFiles = recordingFiles
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
            self.id = try values.decodeIfPresent(Int.self, forKey: "id")
            self.accountID = try values.decodeIfPresent(String.self, forKey: "account_id")
            self.hostID = try values.decodeIfPresent(String.self, forKey: "host_id")
            self.topic = try values.decodeIfPresent(String.self, forKey: "topic")
            self.startTime = try values.decodeIfPresent(Date.self, forKey: "start_time")
            self.duration = try values.decodeIfPresent(Int.self, forKey: "duration")
            self.totalSize = try values.decodeIfPresent(Int.self, forKey: "total_size")
            self.type = try `Type`(from: decoder)
            self.recordingCount = try values.decodeIfPresent(String.self, forKey: "recording_count")
            self.recordingFiles = try values.decode([RecordingFile].self, forKey: "recordingFiles")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(uuid, forKey: "uuid")
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(accountID, forKey: "account_id")
            try values.encodeIfPresent(hostID, forKey: "host_id")
            try values.encodeIfPresent(topic, forKey: "topic")
            try values.encodeIfPresent(startTime, forKey: "start_time")
            try values.encodeIfPresent(duration, forKey: "duration")
            try values.encodeIfPresent(totalSize, forKey: "total_size")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encodeIfPresent(recordingCount, forKey: "recording_count")
            try values.encode(recordingFiles, forKey: "recordingFiles")
        }
    }

    public init(from: NaiveDate? = nil, to: NaiveDate? = nil, pageCount: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil, meetings: [Meeting]? = nil) {
        self.from = from
        self.to = to
        self.pageCount = pageCount
        self.pageSize = pageSize
        self.totalRecords = totalRecords
        self.nextPageToken = nextPageToken
        self.meetings = meetings
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.from = try values.decodeIfPresent(NaiveDate.self, forKey: "from")
        self.to = try values.decodeIfPresent(NaiveDate.self, forKey: "to")
        self.pageCount = try values.decodeIfPresent(Int.self, forKey: "page_count")
        self.pageSize = try values.decodeIfPresent(Int.self, forKey: "page_size")
        self.totalRecords = try values.decodeIfPresent(Int.self, forKey: "total_records")
        self.nextPageToken = try values.decodeIfPresent(String.self, forKey: "next_page_token")
        self.meetings = try values.decodeIfPresent([Meeting].self, forKey: "meetings")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(from, forKey: "from")
        try values.encodeIfPresent(to, forKey: "to")
        try values.encodeIfPresent(pageCount, forKey: "page_count")
        try values.encodeIfPresent(pageSize, forKey: "page_size")
        try values.encodeIfPresent(totalRecords, forKey: "total_records")
        try values.encodeIfPresent(nextPageToken, forKey: "next_page_token")
        try values.encodeIfPresent(meetings, forKey: "meetings")
    }
}

public struct TrackingFieldList: Codable {
    /// The number of all records available across pages
    public var totalRecords: Int?
    /// Array of Tracking Fields
    public var trackingFields: [TrackingField]?

    public struct TrackingField: Codable {
        /// ID of Tracking Field
        public var id: String?
        /// Label/ Name for the tracking field.
        public var field: String?
        /// Tracking Field Required
        public var isRequired: Bool?
        /// Tracking Field Visible
        public var isVisible: Bool?
        /// Array of recommended values
        public var recommendedValues: [String]?

        public init(id: String? = nil, field: String? = nil, isRequired: Bool? = nil, isVisible: Bool? = nil, recommendedValues: [String]? = nil) {
            self.id = id
            self.field = field
            self.isRequired = isRequired
            self.isVisible = isVisible
            self.recommendedValues = recommendedValues
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.field = try values.decodeIfPresent(String.self, forKey: "field")
            self.isRequired = try values.decodeIfPresent(Bool.self, forKey: "required")
            self.isVisible = try values.decodeIfPresent(Bool.self, forKey: "visible")
            self.recommendedValues = try values.decodeIfPresent([String].self, forKey: "recommended_values")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(field, forKey: "field")
            try values.encodeIfPresent(isRequired, forKey: "required")
            try values.encodeIfPresent(isVisible, forKey: "visible")
            try values.encodeIfPresent(recommendedValues, forKey: "recommended_values")
        }
    }

    public init(totalRecords: Int? = nil, trackingFields: [TrackingField]? = nil) {
        self.totalRecords = totalRecords
        self.trackingFields = trackingFields
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.totalRecords = try values.decodeIfPresent(Int.self, forKey: "total_records")
        self.trackingFields = try values.decodeIfPresent([TrackingField].self, forKey: "tracking_fields")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(totalRecords, forKey: "total_records")
        try values.encodeIfPresent(trackingFields, forKey: "tracking_fields")
    }
}

public struct TrackingField: Codable {
    /// Label/ Name for the tracking field.
    public var field: String?
    /// Tracking Field Required
    public var isRequired: Bool?
    /// Tracking Field Visible
    public var isVisible: Bool?
    /// Array of recommended values
    public var recommendedValues: [String]?

    public init(field: String? = nil, isRequired: Bool? = nil, isVisible: Bool? = nil, recommendedValues: [String]? = nil) {
        self.field = field
        self.isRequired = isRequired
        self.isVisible = isVisible
        self.recommendedValues = recommendedValues
    }

    private enum CodingKeys: String, CodingKey {
        case field
        case isRequired = "required"
        case isVisible = "visible"
        case recommendedValues = "recommended_values"
    }
}

/// The user object represents a specific user on Zoom.
public struct User: Codable {
    /// User's first name.
    public var firstName: String?
    /// User's last name.
    public var lastName: String?
    /// User's email address.
    public var email: String
    /// User's plan type:<br>`1` - Basic.<br>`2` - Licensed.<br>`3` - On-prem.<br>`99` - None (this can only be set with `ssoCreate`).
    public var type: Int
    /// User's [role](https://support.zoom.us/hc/en-us/articles/115001078646-Role-Based-Access-Control) name.
    public var roleName: String?
    /// Personal meeting ID.
    public var pmi: Int?
    /// Use Personal Meeting ID for instant meetings.
    public var usePmi: Bool
    /// The time zone of the user.
    public var timezone: String?
    /// Department.
    public var dept: String?
    /// User create time.
    public var createdAt: Date?
    /// User last login time.
    public var lastLoginTime: Date?
    /// User last login client version.
    public var lastClientVersion: String?

    public init(firstName: String? = nil, lastName: String? = nil, email: String, type: Int, roleName: String? = nil, pmi: Int? = nil, usePmi: Bool? = nil, timezone: String? = nil, dept: String? = nil, createdAt: Date? = nil, lastLoginTime: Date? = nil, lastClientVersion: String? = nil) {
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.type = type
        self.roleName = roleName
        self.pmi = pmi
        self.usePmi = usePmi ?? false
        self.timezone = timezone
        self.dept = dept
        self.createdAt = createdAt
        self.lastLoginTime = lastLoginTime
        self.lastClientVersion = lastClientVersion
    }

    private enum CodingKeys: String, CodingKey {
        case firstName = "first_name"
        case lastName = "last_name"
        case email
        case type
        case roleName = "role_name"
        case pmi
        case usePmi = "use_pmi"
        case timezone
        case dept
        case createdAt = "created_at"
        case lastLoginTime = "last_login_time"
        case lastClientVersion = "last_client_version"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.firstName = try values.decodeIfPresent(String.self, forKey: .firstName)
        self.lastName = try values.decodeIfPresent(String.self, forKey: .lastName)
        self.email = try values.decode(String.self, forKey: .email)
        self.type = try values.decode(Int.self, forKey: .type)
        self.roleName = try values.decodeIfPresent(String.self, forKey: .roleName)
        self.pmi = try values.decodeIfPresent(Int.self, forKey: .pmi)
        self.usePmi = try values.decodeIfPresent(Bool.self, forKey: .usePmi) ?? false
        self.timezone = try values.decodeIfPresent(String.self, forKey: .timezone)
        self.dept = try values.decodeIfPresent(String.self, forKey: .dept)
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: .createdAt)
        self.lastLoginTime = try values.decodeIfPresent(Date.self, forKey: .lastLoginTime)
        self.lastClientVersion = try values.decodeIfPresent(String.self, forKey: .lastClientVersion)
    }
}

/// Telephony update settings: Meeting settings
public struct SettingsUpdateTelephony: Codable {
    /// Third party audio conference.
    public var isThirdPartyAudio: Bool?
    /// Third party audio conference info.
    public var audioConferenceInfo: String?
    /// Show the international numbers link on the invitation email.
    public var isShowInternationalNumbersLink: Bool?
    /// Indicates where most of the participants call into or call from during a meeting.
    public var telephonyRegions: TelephonyRegions?

    /// Indicates where most of the participants call into or call from during a meeting.
    public struct TelephonyRegions: Codable {
        /// The account's selected telephony regions that indicate where most participants call into or call from during a meeting.
        public var selectionValues: String?

        public init(selectionValues: String? = nil) {
            self.selectionValues = selectionValues
        }

        private enum CodingKeys: String, CodingKey {
            case selectionValues = "selection_values"
        }
    }

    public init(isThirdPartyAudio: Bool? = nil, audioConferenceInfo: String? = nil, isShowInternationalNumbersLink: Bool? = nil, telephonyRegions: TelephonyRegions? = nil) {
        self.isThirdPartyAudio = isThirdPartyAudio
        self.audioConferenceInfo = audioConferenceInfo
        self.isShowInternationalNumbersLink = isShowInternationalNumbersLink
        self.telephonyRegions = telephonyRegions
    }

    private enum CodingKeys: String, CodingKey {
        case isThirdPartyAudio = "third_party_audio"
        case audioConferenceInfo = "audio_conference_info"
        case isShowInternationalNumbersLink = "show_international_numbers_link"
        case telephonyRegions = "telephony_regions"
    }
}

public struct UserSettings: Codable {
    /// User settings: Meeting settings
    public var scheduleMeeting: ScheduleMeeting?
    /// User settings: Meeting settings
    public var inMeeting: InMeeting?
    /// User settings: Notification settings
    public var emailNotification: EmailNotification?
    /// User settings: Recording settings
    public var recording: Recording?
    /// User settings: Meeting settings
    public var telephony: Telephony?
    /// User settings: Feature settings
    public var feature: Feature?
    /// User settings: TSP settings
    ///
    /// Account Settings: TSP.
    public var tsp: Tsp?
    public var profile: Profile?
    /// The user's audio conference settings.
    public var audioConferencing: AudioConferencing?

    /// User settings: Meeting settings
    public struct ScheduleMeeting: Codable {
        /// Start meetings with host video on.
        public var isHostVideo: Bool?
        /// Start meetings with participants video on.
        public var isParticipantsVideo: Bool?
        /// Determine how participants can join the audio portion of the meeting:<br>`both` - Telephony and VoIP.<br>`telephony` - Audio PSTN telephony only.<br>`voip` - VoIP only.<br>`thirdParty` - Third party audio conference.
        public var audioType: AudioType?
        /// Join the meeting before host arrives.
        public var isJoinBeforeHost: Bool?
        /// Require a passcode for personal meetings if attendees can join before host.
        public var isForcePmiJbhPassword: Bool?
        /// Generate and require passcode for participants joining by phone.
        public var isPstnPasswordProtected: Bool?
        /// Use Personal Meeting ID (PMI) when scheduling a meeting
        public var usePmiForScheduledMeetings: Bool?
        /// Use Personal Meeting ID (PMI) when starting an instant meeting
        public var usePmiForInstantMeetings: Bool?
        /// Require a passcode when scheduling new meetings.This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
        public var requirePasswordForSchedulingNewMeetings: Bool?
        /// Require a passcode for meetings which have already been scheduled
        public var requirePasswordForScheduledMeetings: Bool?
        /// Passcode for already scheduled meetings
        public var defaultPasswordForScheduledMeetings: String?
        /// Require a passcode for instant meetings. If you use PMI for your instant meetings, this option will be disabled. This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
        public var requirePasswordForInstantMeetings: Bool?
        /// Require a passcode for Personal Meeting ID (PMI). This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
        public var requirePasswordForPmiMeetings: RequirePasswordForPmiMeetings?
        /// PMI passcode
        public var pmiPassword: String?
        /// If the value is set to `true`, the meeting passcode will be encrypted and included in the join meeting link to allow participants to join with just one click without having to enter the passcode.
        public var isEmbedPasswordInJoinLink: Bool?
        /// Account wide meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
        public var meetingPasswordRequirement: MeetingPasswordRequirement?
        /// Personal Meeting Setting.<br><br>
        /// `true`: Indicates that the **"Enable Personal Meeting ID"** setting is turned on. Users can choose to use personal meeting ID for their meetings. <br><br>
        /// `false`: Indicates that the **"Enable Personal Meeting ID"** setting is [turned off](https://support.zoom.us/hc/en-us/articles/201362843-Personal-meeting-ID-PMI-and-personal-link#h_aa0335c8-3b06-41bc-bc1f-a8b84ef17f2a). If this setting is disabled, meetings that were scheduled with PMI will be invalid. Scheduled meetings will need to be manually updated.
        /// For Zoom Phone only:If a user has been assigned a desk phone, **"Elevate to Zoom Meeting"** on desk phone will be disabled.
        public var isPersonalMeeting: Bool?

        /// Determine how participants can join the audio portion of the meeting:<br>`both` - Telephony and VoIP.<br>`telephony` - Audio PSTN telephony only.<br>`voip` - VoIP only.<br>`thirdParty` - Third party audio conference.
        public enum AudioType: String, Codable, CaseIterable {
            case both
            case telephony
            case voip
            case thirdParty
        }

        /// Require a passcode for Personal Meeting ID (PMI). This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
        public enum RequirePasswordForPmiMeetings: String, Codable, CaseIterable {
            case jbhOnly = "jbh_only"
            case all
            case `none`
        }

        /// Account wide meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
        public struct MeetingPasswordRequirement: Codable {
            /// The minimum length that the meeting/webinar passcode needs to have.
            public var length: Int?
            /// If set to `true`, the passcode must contain at least 1 letter (such as a,b,c...).
            public var haveLetter: Bool?
            /// If set to `true`, the passcode must contain at least 1 number (such as 1,2,3...).
            public var haveNumber: Bool?
            /// If set to `true`, the passcode must have at least 1 special character (!,@,#...).
            public var haveSpecialCharacter: Bool?
            /// If set to `true`, the passcode must only contain numbers and no other characters.
            public var onlyAllowNumeric: Bool?
            /// If set to `true`, the passcode must include both uppercase and lowercase characters.
            public var haveUpperAndLowerCharacters: Bool?
            public var consecutiveCharactersLength: Int?
            /// If set to `true`, users will be informed if the provided passcode is weak.
            public var isWeakEnhanceDetection: Bool?

            public init(length: Int? = nil, haveLetter: Bool? = nil, haveNumber: Bool? = nil, haveSpecialCharacter: Bool? = nil, onlyAllowNumeric: Bool? = nil, haveUpperAndLowerCharacters: Bool? = nil, consecutiveCharactersLength: Int? = nil, isWeakEnhanceDetection: Bool? = nil) {
                self.length = length
                self.haveLetter = haveLetter
                self.haveNumber = haveNumber
                self.haveSpecialCharacter = haveSpecialCharacter
                self.onlyAllowNumeric = onlyAllowNumeric
                self.haveUpperAndLowerCharacters = haveUpperAndLowerCharacters
                self.consecutiveCharactersLength = consecutiveCharactersLength
                self.isWeakEnhanceDetection = isWeakEnhanceDetection
            }

            private enum CodingKeys: String, CodingKey {
                case length
                case haveLetter = "have_letter"
                case haveNumber = "have_number"
                case haveSpecialCharacter = "have_special_character"
                case onlyAllowNumeric = "only_allow_numeric"
                case haveUpperAndLowerCharacters = "have_upper_and_lower_characters"
                case consecutiveCharactersLength = "consecutive_characters_length"
                case isWeakEnhanceDetection = "weak_enhance_detection"
            }
        }

        public init(isHostVideo: Bool? = nil, isParticipantsVideo: Bool? = nil, audioType: AudioType? = nil, isJoinBeforeHost: Bool? = nil, isForcePmiJbhPassword: Bool? = nil, isPstnPasswordProtected: Bool? = nil, usePmiForScheduledMeetings: Bool? = nil, usePmiForInstantMeetings: Bool? = nil, requirePasswordForSchedulingNewMeetings: Bool? = nil, requirePasswordForScheduledMeetings: Bool? = nil, defaultPasswordForScheduledMeetings: String? = nil, requirePasswordForInstantMeetings: Bool? = nil, requirePasswordForPmiMeetings: RequirePasswordForPmiMeetings? = nil, pmiPassword: String? = nil, isEmbedPasswordInJoinLink: Bool? = nil, meetingPasswordRequirement: MeetingPasswordRequirement? = nil, isPersonalMeeting: Bool? = nil) {
            self.isHostVideo = isHostVideo
            self.isParticipantsVideo = isParticipantsVideo
            self.audioType = audioType
            self.isJoinBeforeHost = isJoinBeforeHost
            self.isForcePmiJbhPassword = isForcePmiJbhPassword
            self.isPstnPasswordProtected = isPstnPasswordProtected
            self.usePmiForScheduledMeetings = usePmiForScheduledMeetings
            self.usePmiForInstantMeetings = usePmiForInstantMeetings
            self.requirePasswordForSchedulingNewMeetings = requirePasswordForSchedulingNewMeetings
            self.requirePasswordForScheduledMeetings = requirePasswordForScheduledMeetings
            self.defaultPasswordForScheduledMeetings = defaultPasswordForScheduledMeetings
            self.requirePasswordForInstantMeetings = requirePasswordForInstantMeetings
            self.requirePasswordForPmiMeetings = requirePasswordForPmiMeetings
            self.pmiPassword = pmiPassword
            self.isEmbedPasswordInJoinLink = isEmbedPasswordInJoinLink
            self.meetingPasswordRequirement = meetingPasswordRequirement
            self.isPersonalMeeting = isPersonalMeeting
        }

        private enum CodingKeys: String, CodingKey {
            case isHostVideo = "host_video"
            case isParticipantsVideo = "participants_video"
            case audioType = "audio_type"
            case isJoinBeforeHost = "join_before_host"
            case isForcePmiJbhPassword = "force_pmi_jbh_password"
            case isPstnPasswordProtected = "pstn_password_protected"
            case usePmiForScheduledMeetings = "use_pmi_for_scheduled_meetings"
            case usePmiForInstantMeetings = "use_pmi_for_instant_meetings"
            case requirePasswordForSchedulingNewMeetings = "require_password_for_scheduling_new_meetings"
            case requirePasswordForScheduledMeetings = "require_password_for_scheduled_meetings"
            case defaultPasswordForScheduledMeetings = "default_password_for_scheduled_meetings"
            case requirePasswordForInstantMeetings = "require_password_for_instant_meetings"
            case requirePasswordForPmiMeetings = "require_password_for_pmi_meetings"
            case pmiPassword = "pmi_password"
            case isEmbedPasswordInJoinLink = "embed_password_in_join_link"
            case meetingPasswordRequirement = "meeting_password_requirement"
            case isPersonalMeeting = "personal_meeting"
        }
    }

    /// User settings: Meeting settings
    public struct InMeeting: Codable {
        /// Zoom requires encryption for all data between the Zoom cloud, Zoom client, and Zoom Room. Require encryption for 3rd party endpoints (H323/SIP).
        public var isE2eEncryption: Bool?
        /// Enable chat during meeting for all participants.
        public var isChat: Bool
        /// Whether to allow participants to only chat with certain groups:
        /// * `1` — The participant cannot use chat.
        /// * `2` — Host and co-hosts only.
        ///  * `3` — The participant can chat with other participants publicly.
        /// * `4` - The participant can chat with other participants publicly and privately.
        /// 
        /// **Note:** This setting is only available with client versions 5.7.3 and above.
        public var allowParticipantsChatWith: Int?
        /// Whether to allow participants to save meeting chats:
        /// * `1` — Participants cannot save meeting chats.
        /// * `2` — Participants can only save host and co-host meeting chats.
        /// * `3` — Participants can save all meeting chats.
        public var allowUsersSaveChats: Int?
        /// Enable 1:1 private chat between participants during meetings.
        public var isPrivateChat: Bool
        /// Auto save all in-meeting chats.
        public var isAutoSavingChat: Bool
        /// Play sound when participants join or leave:<br>`host` - When host joins or leaves.<br>`all` - When any participant joins or leaves.<br>`none` - No join or leave sound.
        public var entryExitChime: EntryExitChime?
        /// Record and play their own voice.
        public var isRecordPlayVoice: Bool?
        /// Enable option to send feedback to Zoom at the end of the meeting.
        public var isFeedback: Bool
        /// Allow the host to add co-hosts.
        public var isCoHost: Bool
        /// Add polls to the meeting controls.
        public var isPolling: Bool
        /// Allow host to put attendee on hold.
        /// 
        /// **This field has been deprecated and is no longer supported.**
        public var isAttendeeOnHold: Bool
        /// Allow participants to use annotation tools.
        public var isAnnotation: Bool
        /// Enable remote control during screensharing.
        public var isRemoteControl: Bool
        /// Enable non-verbal feedback through screens.
        public var isNonVerbalFeedback: Bool
        /// Allow host to split meeting participants into separate breakout rooms.
        public var isBreakoutRoom: Bool
        /// Whether the host can assign participants to breakout rooms when scheduling. This feature is only available in version 4.5.0 or higher.
        public var isBreakoutRoomSchedule: Bool?
        /// Allow host to provide 1:1 remote support to a participant.
        public var isRemoteSupport: Bool
        /// Enable closed captions.
        public var isClosedCaption: Bool
        /// Enable group HD video.
        public var isGroupHd: Bool
        /// Enable virtual background.
        public var isVirtualBackground: Bool
        /// Settings to manage virtual background.
        public var virtualBackgroundSettings: VirtualBackgroundSettings?
        /// Allow another user to take control of the camera.
        public var isFarEndCameraControl: Bool
        /// Share dual camera (deprecated).
        public var isShareDualCamera: Bool
        /// Enable Waiting room - if enabled, attendees can only join after host approves.
        public var isWaitingRoom: Bool
        /// Whether to allow live streaming.
        public var allowLiveStreaming: Bool?
        /// Whether to allow Facebook live streaming.
        public var isLiveStreamingFacebook: Bool?
        /// Whether to allow Workplace by Facebook live streaming.
        public var isWorkplaceByFacebook: Bool?
        /// Whether to allow YouTube live streaming.
        public var isLiveStreamingYoutube: Bool?
        /// Whether to allow custom live streaming.
        public var isCustomLiveStreamingService: Bool?
        /// The custom live streaming service instructions.
        public var customServiceInstructions: String?
        /// Always show meeting controls during a meeting.
        public var isShowMeetingControlToolbar: Bool?
        /// If set to `true`, you can [select data center regions](https://support.zoom.us/hc/en-us/articles/360042411451-Selecting-data-center-regions-for-hosted-meetings-and-webinars) to use for hosting your real-time meeting and webinar traffic. These regions can be provided in the `data_center_regions` field. If set to `false`, the regions cannot be customized and the default regions will be used.
        public var isCustomDataCenterRegions: Bool?
        /// If you have set the value of `custom_data_center_regions` to `true`, specify the data center regions that you would like to opt in to (country codes from among: ["DE", "NL", "HK", "AU", "IN", "LA", "TY", "CN", "US", "CA"]).
        public var dataCenterRegions: [String]?
        /// Whether meeting participants can [communicate using the emoji reactions](https://support.zoom.us/hc/en-us/articles/115001286183-Nonverbal-feedback-and-meeting-reactions) located in the **Reactions** menu in the meeting toolbar.
        public var isMeetingReactions: Bool?
        /// Allow host and participants to share their screen or content during meetings
        public var isScreenSharing: Bool?
        /// Indicates who can share their screen or content during meetings. The value can be one of the following: <br>
        /// `host`: Only host can share the screen.<br>
        /// `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
        public var whoCanShareScreen: WhoCanShareScreen?
        /// Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:<br>
        /// `host`: Only a host can share the screen when someone else is sharing.<br>
        /// `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
        public var whoCanShareScreenWhenSomeoneIsSharing: WhoCanShareScreenWhenSomeoneIsSharing?
        /// Indicates whether [in-meeting file transfer](https://support.zoom.us/hc/en-us/articles/209605493-In-meeting-file-transfer) setting has been enabled for the user or not.
        public var isFileTransfer: Bool?
        /// Indicates whether the [**Request permission to unmute participants**](https://support.zoom.us/hc/en-us/articles/203435537-Muting-and-unmuting-participants-in-a-meeting#h_01EGK4XFWS1SJGZ71MYGKF7260) option has been enabled for the user or not.
        public var isRequestPermissionToUnmute: Bool?
        /// Whether to allow participants to join a meeting directly from their browser and bypass the Zoom application download process. This is useful for participants who cannot download, install, or run applications. Note that the meeting experience from the browser is limited.
        public var isShowAJoinFromYourBrowserLink: Bool?
        /// Whether to allow participants to join a meeting directly from their mobile browser. Note that the meeting experience from the mobile browser is limited.
        public var isJoinFromMobile: Bool?
        /// Whether to allow participants to join a meeting directly from their desktop browser. Note that the meeting experience from the desktop browser is limited.
        public var isJoinFromDesktop: Bool?
        public var webinarLiveStreaming: WebinarLiveStreaming?
        public var webinarChat: WebinarChat?
        /// Information about the user's closed captioning settings.
        public var closedCaptioning: ClosedCaptioning?
        /// Whether the person sharing during a presentation can allow others to control the slide presentation. This feature is only available in version 5.8.3 or higher.
        public var isSlideControl: Bool?
        /// Whether to allow the host to present a survey to participants once a meeting has ended. This feature is only available in version 5.7.3 or higher.
        public var isMeetingSurvey: Bool?
        /// Information about the user's webinar polling settings.
        public var webinarPolling: WebinarPolling?
        /// Whether to allow the host to present surveys to attendees once a webinar has ended.
        public var isWebinarSurvey: Bool?

        /// Play sound when participants join or leave:<br>`host` - When host joins or leaves.<br>`all` - When any participant joins or leaves.<br>`none` - No join or leave sound.
        public enum EntryExitChime: String, Codable, CaseIterable {
            case host
            case all
            case `none`
        }

        /// Settings to manage virtual background.
        public struct VirtualBackgroundSettings: Codable {
            /// Enable virtual background.
            public var enable: Bool?
            /// Allow use of videos for virtual backgrounds.
            public var allowVideos: Bool?
            /// Allow user to upload custom backgrounds.
            public var allowUploadCustom: Bool?
            public var files: [File]?

            public struct File: Codable {
                /// Unique identifier of the file.
                public var id: String?
                /// File name.
                public var name: String?
                /// File type.
                public var type: String?
                /// Indicates whether or not this file is the default virtual background file.
                public var isDefault: Bool?
                /// File size.
                public var size: String?

                public init(id: String? = nil, name: String? = nil, type: String? = nil, isDefault: Bool? = nil, size: String? = nil) {
                    self.id = id
                    self.name = name
                    self.type = type
                    self.isDefault = isDefault
                    self.size = size
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case name
                    case type
                    case isDefault = "is_default"
                    case size
                }
            }

            public init(enable: Bool? = nil, allowVideos: Bool? = nil, allowUploadCustom: Bool? = nil, files: [File]? = nil) {
                self.enable = enable
                self.allowVideos = allowVideos
                self.allowUploadCustom = allowUploadCustom
                self.files = files
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case allowVideos = "allow_videos"
                case allowUploadCustom = "allow_upload_custom"
                case files
            }
        }

        /// Indicates who can share their screen or content during meetings. The value can be one of the following: <br>
        /// `host`: Only host can share the screen.<br>
        /// `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
        public enum WhoCanShareScreen: String, Codable, CaseIterable {
            case host
            case all
        }

        /// Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:<br>
        /// `host`: Only a host can share the screen when someone else is sharing.<br>
        /// `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
        public enum WhoCanShareScreenWhenSomeoneIsSharing: String, Codable, CaseIterable {
            case host
            case all
        }

        public struct WebinarLiveStreaming: Codable {
            /// Whether webinar live streaming is enabled.
            public var enable: Bool?
            /// The available live streaming services:
            /// * `facebook`
            /// * `workplace_by_facebook`
            /// * `youtube`
            /// * `custom_live_streaming_service`
            public var liveStreamingService: [LiveStreamingServiceItem]?
            /// The specific instructions to allow your account's meeting hosts to configure a custom live stream.
            public var customServiceInstructions: String?
            /// Whether to notify users to watch the live stream. This does not apply to custom RTMP (real-time messaging protocol).
            public var isLiveStreamingReminder: Bool?

            public enum LiveStreamingServiceItem: String, Codable, CaseIterable {
                case facebook
                case workplaceByFacebook = "workplace_by_facebook"
                case youtube
                case customLiveStreamingService = "custom_live_streaming_service"
            }

            public init(enable: Bool? = nil, liveStreamingService: [LiveStreamingServiceItem]? = nil, customServiceInstructions: String? = nil, isLiveStreamingReminder: Bool? = nil) {
                self.enable = enable
                self.liveStreamingService = liveStreamingService
                self.customServiceInstructions = customServiceInstructions
                self.isLiveStreamingReminder = isLiveStreamingReminder
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case liveStreamingService = "live_streaming_service"
                case customServiceInstructions = "custom_service_instructions"
                case isLiveStreamingReminder = "live_streaming_reminder"
            }
        }

        public struct WebinarChat: Codable {
            /// Whether to allow webinar participants to send chat messages.
            public var enable: Bool?
            /// Whether to allow webinar panelists to chat with:
            /// * `1` — Host and all panelists.
            /// * `2` — Everyone.
            public var allowPanelistsChatWith: Int?
            /// Allow webinar attendees to chat with:
            /// * `1` — No one.
            /// * `2` — Host and all panelists.
            /// * `3` — Everyone.
            public var allowAttendeesChatWith: Int?
            /// By default, allow webinar attendees to chat with:
            /// * `1` — Host and all panelists.
            /// * `2` — Everyone.
            public var defaultAttendeesChatWith: Int?
            /// Whether to allow webinar panelists to send direct messages to other panelists.
            public var allowPanelistsSendDirectMessage: Bool?
            /// Whether to allow webinar attendees to save chats:
            /// * `0` — Attendees cannot save chats.
            /// * `1` — Attendees can only save host and panelist chats.
            /// * `2` — Attendees can save all chats.
            public var allowUsersSaveChats: Int?
            /// Whether to automatically save chat messages to a local file on the host's computer when the webinar ends.
            public var allowAutoSaveLocalChatFile: Bool?

            public init(enable: Bool? = nil, allowPanelistsChatWith: Int? = nil, allowAttendeesChatWith: Int? = nil, defaultAttendeesChatWith: Int? = nil, allowPanelistsSendDirectMessage: Bool? = nil, allowUsersSaveChats: Int? = nil, allowAutoSaveLocalChatFile: Bool? = nil) {
                self.enable = enable
                self.allowPanelistsChatWith = allowPanelistsChatWith
                self.allowAttendeesChatWith = allowAttendeesChatWith
                self.defaultAttendeesChatWith = defaultAttendeesChatWith
                self.allowPanelistsSendDirectMessage = allowPanelistsSendDirectMessage
                self.allowUsersSaveChats = allowUsersSaveChats
                self.allowAutoSaveLocalChatFile = allowAutoSaveLocalChatFile
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case allowPanelistsChatWith = "allow_panelists_chat_with"
                case allowAttendeesChatWith = "allow_attendees_chat_with"
                case defaultAttendeesChatWith = "default_attendees_chat_with"
                case allowPanelistsSendDirectMessage = "allow_panelists_send_direct_message"
                case allowUsersSaveChats = "allow_users_save_chats"
                case allowAutoSaveLocalChatFile = "allow_auto_save_local_chat_file"
            }
        }

        /// Information about the user's closed captioning settings.
        public struct ClosedCaptioning: Codable {
            /// Whether to allow the host to type closed captions or assign a participant or 3rd-party service to provide closed captioning.
            public var enable: Bool?
            /// Whether to allow the use of an API token to integrate with 3rd-party closed captioning services.
            public var isThirdPartyCaptioningService: Bool?
            /// Whether to allow a live transcription service to transcribe meetings.
            public var isAutoTranscribing: Bool?
            /// Whether to allow the viewing of full transcripts in the in-meeting side panel.
            public var isViewFullTranscript: Bool?
            /// Whether to allow participants to save closed captions or transcripts.
            public var isSaveCaption: Bool?

            public init(enable: Bool? = nil, isThirdPartyCaptioningService: Bool? = nil, isAutoTranscribing: Bool? = nil, isViewFullTranscript: Bool? = nil, isSaveCaption: Bool? = nil) {
                self.enable = enable
                self.isThirdPartyCaptioningService = isThirdPartyCaptioningService
                self.isAutoTranscribing = isAutoTranscribing
                self.isViewFullTranscript = isViewFullTranscript
                self.isSaveCaption = isSaveCaption
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case isThirdPartyCaptioningService = "third_party_captioning_service"
                case isAutoTranscribing = "auto_transcribing"
                case isViewFullTranscript = "view_full_transcript"
                case isSaveCaption = "save_caption"
            }
        }

        /// Information about the user's webinar polling settings.
        public struct WebinarPolling: Codable {
            /// Whether to allow the host to add polls before or during a webinar.
            public var enable: Bool?
            /// Whether to allow host to create advanced polls and quizzes. Advanced polls and quizzes include single choice, multiple choice, drop down, matching, short answer, long answer, rank order, and fill-in-the-blank questions. Hosts can also set the correct answers for quizzes they create.
            public var isAdvancedPolls: Bool?

            public init(enable: Bool? = nil, isAdvancedPolls: Bool? = nil) {
                self.enable = enable
                self.isAdvancedPolls = isAdvancedPolls
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case isAdvancedPolls = "advanced_polls"
            }
        }

        public init(isE2eEncryption: Bool? = nil, isChat: Bool? = nil, allowParticipantsChatWith: Int? = nil, allowUsersSaveChats: Int? = nil, isPrivateChat: Bool? = nil, isAutoSavingChat: Bool? = nil, entryExitChime: EntryExitChime? = nil, isRecordPlayVoice: Bool? = nil, isFeedback: Bool? = nil, isCoHost: Bool? = nil, isPolling: Bool? = nil, isAttendeeOnHold: Bool? = nil, isAnnotation: Bool? = nil, isRemoteControl: Bool? = nil, isNonVerbalFeedback: Bool? = nil, isBreakoutRoom: Bool? = nil, isBreakoutRoomSchedule: Bool? = nil, isRemoteSupport: Bool? = nil, isClosedCaption: Bool? = nil, isGroupHd: Bool? = nil, isVirtualBackground: Bool? = nil, virtualBackgroundSettings: VirtualBackgroundSettings? = nil, isFarEndCameraControl: Bool? = nil, isShareDualCamera: Bool? = nil, isWaitingRoom: Bool? = nil, allowLiveStreaming: Bool? = nil, isLiveStreamingFacebook: Bool? = nil, isWorkplaceByFacebook: Bool? = nil, isLiveStreamingYoutube: Bool? = nil, isCustomLiveStreamingService: Bool? = nil, customServiceInstructions: String? = nil, isShowMeetingControlToolbar: Bool? = nil, isCustomDataCenterRegions: Bool? = nil, dataCenterRegions: [String]? = nil, isMeetingReactions: Bool? = nil, isScreenSharing: Bool? = nil, whoCanShareScreen: WhoCanShareScreen? = nil, whoCanShareScreenWhenSomeoneIsSharing: WhoCanShareScreenWhenSomeoneIsSharing? = nil, isFileTransfer: Bool? = nil, isRequestPermissionToUnmute: Bool? = nil, isShowAJoinFromYourBrowserLink: Bool? = nil, isJoinFromMobile: Bool? = nil, isJoinFromDesktop: Bool? = nil, webinarLiveStreaming: WebinarLiveStreaming? = nil, webinarChat: WebinarChat? = nil, closedCaptioning: ClosedCaptioning? = nil, isSlideControl: Bool? = nil, isMeetingSurvey: Bool? = nil, webinarPolling: WebinarPolling? = nil, isWebinarSurvey: Bool? = nil) {
            self.isE2eEncryption = isE2eEncryption
            self.isChat = isChat ?? false
            self.allowParticipantsChatWith = allowParticipantsChatWith
            self.allowUsersSaveChats = allowUsersSaveChats
            self.isPrivateChat = isPrivateChat ?? false
            self.isAutoSavingChat = isAutoSavingChat ?? false
            self.entryExitChime = entryExitChime
            self.isRecordPlayVoice = isRecordPlayVoice
            self.isFeedback = isFeedback ?? false
            self.isCoHost = isCoHost ?? false
            self.isPolling = isPolling ?? false
            self.isAttendeeOnHold = isAttendeeOnHold ?? false
            self.isAnnotation = isAnnotation ?? false
            self.isRemoteControl = isRemoteControl ?? false
            self.isNonVerbalFeedback = isNonVerbalFeedback ?? false
            self.isBreakoutRoom = isBreakoutRoom ?? false
            self.isBreakoutRoomSchedule = isBreakoutRoomSchedule
            self.isRemoteSupport = isRemoteSupport ?? false
            self.isClosedCaption = isClosedCaption ?? false
            self.isGroupHd = isGroupHd ?? false
            self.isVirtualBackground = isVirtualBackground ?? false
            self.virtualBackgroundSettings = virtualBackgroundSettings
            self.isFarEndCameraControl = isFarEndCameraControl ?? false
            self.isShareDualCamera = isShareDualCamera ?? false
            self.isWaitingRoom = isWaitingRoom ?? false
            self.allowLiveStreaming = allowLiveStreaming
            self.isLiveStreamingFacebook = isLiveStreamingFacebook
            self.isWorkplaceByFacebook = isWorkplaceByFacebook
            self.isLiveStreamingYoutube = isLiveStreamingYoutube
            self.isCustomLiveStreamingService = isCustomLiveStreamingService
            self.customServiceInstructions = customServiceInstructions
            self.isShowMeetingControlToolbar = isShowMeetingControlToolbar
            self.isCustomDataCenterRegions = isCustomDataCenterRegions
            self.dataCenterRegions = dataCenterRegions
            self.isMeetingReactions = isMeetingReactions
            self.isScreenSharing = isScreenSharing
            self.whoCanShareScreen = whoCanShareScreen
            self.whoCanShareScreenWhenSomeoneIsSharing = whoCanShareScreenWhenSomeoneIsSharing
            self.isFileTransfer = isFileTransfer
            self.isRequestPermissionToUnmute = isRequestPermissionToUnmute
            self.isShowAJoinFromYourBrowserLink = isShowAJoinFromYourBrowserLink
            self.isJoinFromMobile = isJoinFromMobile
            self.isJoinFromDesktop = isJoinFromDesktop
            self.webinarLiveStreaming = webinarLiveStreaming
            self.webinarChat = webinarChat
            self.closedCaptioning = closedCaptioning
            self.isSlideControl = isSlideControl
            self.isMeetingSurvey = isMeetingSurvey
            self.webinarPolling = webinarPolling
            self.isWebinarSurvey = isWebinarSurvey
        }

        private enum CodingKeys: String, CodingKey {
            case isE2eEncryption = "e2e_encryption"
            case isChat = "chat"
            case allowParticipantsChatWith = "allow_participants_chat_with"
            case allowUsersSaveChats = "allow_users_save_chats"
            case isPrivateChat = "private_chat"
            case isAutoSavingChat = "auto_saving_chat"
            case entryExitChime = "entry_exit_chime"
            case isRecordPlayVoice = "record_play_voice"
            case isFeedback = "feedback"
            case isCoHost = "co_host"
            case isPolling = "polling"
            case isAttendeeOnHold = "attendee_on_hold"
            case isAnnotation = "annotation"
            case isRemoteControl = "remote_control"
            case isNonVerbalFeedback = "non_verbal_feedback"
            case isBreakoutRoom = "breakout_room"
            case isBreakoutRoomSchedule = "breakout_room_schedule"
            case isRemoteSupport = "remote_support"
            case isClosedCaption = "closed_caption"
            case isGroupHd = "group_hd"
            case isVirtualBackground = "virtual_background"
            case virtualBackgroundSettings = "virtual_background_settings"
            case isFarEndCameraControl = "far_end_camera_control"
            case isShareDualCamera = "share_dual_camera"
            case isWaitingRoom = "waiting_room"
            case allowLiveStreaming = "allow_live_streaming"
            case isLiveStreamingFacebook = "live_streaming_facebook"
            case isWorkplaceByFacebook = "workplace_by_facebook"
            case isLiveStreamingYoutube = "live_streaming_youtube"
            case isCustomLiveStreamingService = "custom_live_streaming_service"
            case customServiceInstructions = "custom_service_instructions"
            case isShowMeetingControlToolbar = "show_meeting_control_toolbar"
            case isCustomDataCenterRegions = "custom_data_center_regions"
            case dataCenterRegions = "data_center_regions"
            case isMeetingReactions = "meeting_reactions"
            case isScreenSharing = "screen_sharing"
            case whoCanShareScreen = "who_can_share_screen"
            case whoCanShareScreenWhenSomeoneIsSharing = "who_can_share_screen_when_someone_is_sharing"
            case isFileTransfer = "file_transfer"
            case isRequestPermissionToUnmute = "request_permission_to_unmute"
            case isShowAJoinFromYourBrowserLink = "show_a_join_from_your_browser_link"
            case isJoinFromMobile = "join_from_mobile"
            case isJoinFromDesktop = "join_from_desktop"
            case webinarLiveStreaming = "webinar_live_streaming"
            case webinarChat = "webinar_chat"
            case closedCaptioning = "closed_captioning"
            case isSlideControl = "slide_control"
            case isMeetingSurvey = "meeting_survey"
            case webinarPolling = "webinar_polling"
            case isWebinarSurvey = "webinar_survey"
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.isE2eEncryption = try values.decodeIfPresent(Bool.self, forKey: .isE2eEncryption)
            self.isChat = try values.decodeIfPresent(Bool.self, forKey: .isChat) ?? false
            self.allowParticipantsChatWith = try values.decodeIfPresent(Int.self, forKey: .allowParticipantsChatWith)
            self.allowUsersSaveChats = try values.decodeIfPresent(Int.self, forKey: .allowUsersSaveChats)
            self.isPrivateChat = try values.decodeIfPresent(Bool.self, forKey: .isPrivateChat) ?? false
            self.isAutoSavingChat = try values.decodeIfPresent(Bool.self, forKey: .isAutoSavingChat) ?? false
            self.entryExitChime = try values.decodeIfPresent(EntryExitChime.self, forKey: .entryExitChime)
            self.isRecordPlayVoice = try values.decodeIfPresent(Bool.self, forKey: .isRecordPlayVoice)
            self.isFeedback = try values.decodeIfPresent(Bool.self, forKey: .isFeedback) ?? false
            self.isCoHost = try values.decodeIfPresent(Bool.self, forKey: .isCoHost) ?? false
            self.isPolling = try values.decodeIfPresent(Bool.self, forKey: .isPolling) ?? false
            self.isAttendeeOnHold = try values.decodeIfPresent(Bool.self, forKey: .isAttendeeOnHold) ?? false
            self.isAnnotation = try values.decodeIfPresent(Bool.self, forKey: .isAnnotation) ?? false
            self.isRemoteControl = try values.decodeIfPresent(Bool.self, forKey: .isRemoteControl) ?? false
            self.isNonVerbalFeedback = try values.decodeIfPresent(Bool.self, forKey: .isNonVerbalFeedback) ?? false
            self.isBreakoutRoom = try values.decodeIfPresent(Bool.self, forKey: .isBreakoutRoom) ?? false
            self.isBreakoutRoomSchedule = try values.decodeIfPresent(Bool.self, forKey: .isBreakoutRoomSchedule)
            self.isRemoteSupport = try values.decodeIfPresent(Bool.self, forKey: .isRemoteSupport) ?? false
            self.isClosedCaption = try values.decodeIfPresent(Bool.self, forKey: .isClosedCaption) ?? false
            self.isGroupHd = try values.decodeIfPresent(Bool.self, forKey: .isGroupHd) ?? false
            self.isVirtualBackground = try values.decodeIfPresent(Bool.self, forKey: .isVirtualBackground) ?? false
            self.virtualBackgroundSettings = try values.decodeIfPresent(VirtualBackgroundSettings.self, forKey: .virtualBackgroundSettings)
            self.isFarEndCameraControl = try values.decodeIfPresent(Bool.self, forKey: .isFarEndCameraControl) ?? false
            self.isShareDualCamera = try values.decodeIfPresent(Bool.self, forKey: .isShareDualCamera) ?? false
            self.isWaitingRoom = try values.decodeIfPresent(Bool.self, forKey: .isWaitingRoom) ?? false
            self.allowLiveStreaming = try values.decodeIfPresent(Bool.self, forKey: .allowLiveStreaming)
            self.isLiveStreamingFacebook = try values.decodeIfPresent(Bool.self, forKey: .isLiveStreamingFacebook)
            self.isWorkplaceByFacebook = try values.decodeIfPresent(Bool.self, forKey: .isWorkplaceByFacebook)
            self.isLiveStreamingYoutube = try values.decodeIfPresent(Bool.self, forKey: .isLiveStreamingYoutube)
            self.isCustomLiveStreamingService = try values.decodeIfPresent(Bool.self, forKey: .isCustomLiveStreamingService)
            self.customServiceInstructions = try values.decodeIfPresent(String.self, forKey: .customServiceInstructions)
            self.isShowMeetingControlToolbar = try values.decodeIfPresent(Bool.self, forKey: .isShowMeetingControlToolbar)
            self.isCustomDataCenterRegions = try values.decodeIfPresent(Bool.self, forKey: .isCustomDataCenterRegions)
            self.dataCenterRegions = try values.decodeIfPresent([String].self, forKey: .dataCenterRegions)
            self.isMeetingReactions = try values.decodeIfPresent(Bool.self, forKey: .isMeetingReactions)
            self.isScreenSharing = try values.decodeIfPresent(Bool.self, forKey: .isScreenSharing)
            self.whoCanShareScreen = try values.decodeIfPresent(WhoCanShareScreen.self, forKey: .whoCanShareScreen)
            self.whoCanShareScreenWhenSomeoneIsSharing = try values.decodeIfPresent(WhoCanShareScreenWhenSomeoneIsSharing.self, forKey: .whoCanShareScreenWhenSomeoneIsSharing)
            self.isFileTransfer = try values.decodeIfPresent(Bool.self, forKey: .isFileTransfer)
            self.isRequestPermissionToUnmute = try values.decodeIfPresent(Bool.self, forKey: .isRequestPermissionToUnmute)
            self.isShowAJoinFromYourBrowserLink = try values.decodeIfPresent(Bool.self, forKey: .isShowAJoinFromYourBrowserLink)
            self.isJoinFromMobile = try values.decodeIfPresent(Bool.self, forKey: .isJoinFromMobile)
            self.isJoinFromDesktop = try values.decodeIfPresent(Bool.self, forKey: .isJoinFromDesktop)
            self.webinarLiveStreaming = try values.decodeIfPresent(WebinarLiveStreaming.self, forKey: .webinarLiveStreaming)
            self.webinarChat = try values.decodeIfPresent(WebinarChat.self, forKey: .webinarChat)
            self.closedCaptioning = try values.decodeIfPresent(ClosedCaptioning.self, forKey: .closedCaptioning)
            self.isSlideControl = try values.decodeIfPresent(Bool.self, forKey: .isSlideControl)
            self.isMeetingSurvey = try values.decodeIfPresent(Bool.self, forKey: .isMeetingSurvey)
            self.webinarPolling = try values.decodeIfPresent(WebinarPolling.self, forKey: .webinarPolling)
            self.isWebinarSurvey = try values.decodeIfPresent(Bool.self, forKey: .isWebinarSurvey)
        }
    }

    /// User settings: Notification settings
    public struct EmailNotification: Codable {
        /// Whether to notify the host when a cloud recording is available.
        public var isCloudRecordingAvailableReminder: Bool?
        /// Whether to notify the person who scheduled the meeting or webinar for the host when a cloud recording is available.
        public var isRecordingAvailableReminderSchedulers: Bool?
        /// Whether to notify any alternative hosts when a cloud recording is available.
        public var isRecordingAvailableReminderAlternativeHosts: Bool?
        /// When attendees join meeting before host.
        public var isJbhReminder: Bool
        /// When a meeting is cancelled.
        public var isCancelMeetingReminder: Bool
        /// When an alternative host is set or removed from a meeting.
        public var isAlternativeHostReminder: Bool
        /// Notify the host there is a meeting is scheduled, rescheduled, or cancelled.
        public var isScheduleForReminder: Bool

        public init(isCloudRecordingAvailableReminder: Bool? = nil, isRecordingAvailableReminderSchedulers: Bool? = nil, isRecordingAvailableReminderAlternativeHosts: Bool? = nil, isJbhReminder: Bool? = nil, isCancelMeetingReminder: Bool? = nil, isAlternativeHostReminder: Bool? = nil, isScheduleForReminder: Bool? = nil) {
            self.isCloudRecordingAvailableReminder = isCloudRecordingAvailableReminder
            self.isRecordingAvailableReminderSchedulers = isRecordingAvailableReminderSchedulers
            self.isRecordingAvailableReminderAlternativeHosts = isRecordingAvailableReminderAlternativeHosts
            self.isJbhReminder = isJbhReminder ?? false
            self.isCancelMeetingReminder = isCancelMeetingReminder ?? false
            self.isAlternativeHostReminder = isAlternativeHostReminder ?? false
            self.isScheduleForReminder = isScheduleForReminder ?? false
        }

        private enum CodingKeys: String, CodingKey {
            case isCloudRecordingAvailableReminder = "cloud_recording_available_reminder"
            case isRecordingAvailableReminderSchedulers = "recording_available_reminder_schedulers"
            case isRecordingAvailableReminderAlternativeHosts = "recording_available_reminder_alternative_hosts"
            case isJbhReminder = "jbh_reminder"
            case isCancelMeetingReminder = "cancel_meeting_reminder"
            case isAlternativeHostReminder = "alternative_host_reminder"
            case isScheduleForReminder = "schedule_for_reminder"
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.isCloudRecordingAvailableReminder = try values.decodeIfPresent(Bool.self, forKey: .isCloudRecordingAvailableReminder)
            self.isRecordingAvailableReminderSchedulers = try values.decodeIfPresent(Bool.self, forKey: .isRecordingAvailableReminderSchedulers)
            self.isRecordingAvailableReminderAlternativeHosts = try values.decodeIfPresent(Bool.self, forKey: .isRecordingAvailableReminderAlternativeHosts)
            self.isJbhReminder = try values.decodeIfPresent(Bool.self, forKey: .isJbhReminder) ?? false
            self.isCancelMeetingReminder = try values.decodeIfPresent(Bool.self, forKey: .isCancelMeetingReminder) ?? false
            self.isAlternativeHostReminder = try values.decodeIfPresent(Bool.self, forKey: .isAlternativeHostReminder) ?? false
            self.isScheduleForReminder = try values.decodeIfPresent(Bool.self, forKey: .isScheduleForReminder) ?? false
        }
    }

    /// User settings: Recording settings
    public struct Recording: Codable {
        /// Local recording.
        public var isLocalRecording: Bool?
        /// Cloud recording.
        public var isCloudRecording: Bool
        /// Record the active speaker view.
        public var isRecordSpeakerView: Bool
        /// Record the gallery view.
        public var isRecordGalleryView: Bool
        /// Whether to record one audio file for all participants.
        public var isRecordAudioFile: Bool
        /// Save chat text from the meeting.
        public var isSaveChatText: Bool
        /// Show timestamp on video.
        public var isShowTimestamp: Bool
        /// Audio transcript.
        public var isRecordingAudioTranscript: Bool?
        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` - Record on cloud.<br>`none` - Disabled.
        public var autoRecording: AutoRecording?
        /// Host can pause/stop the auto recording in the cloud.
        public var isHostPauseStopRecording: Bool
        /// Auto delete cloud recordings.
        public var autoDeleteCmr: Bool
        /// When the `auto_delete_cmr` value is `true`, this value is the number of days before the auto-deletion of cloud recordings: 
        /// * `30` — 30 days. 
        /// * `60` — 60 days. 
        /// * `90` — 90 days. 
        /// * `120` — 120 days.
        public var autoDeleteCmrDays: Int?
        /// Show a disclaimer to participants before a recording starts
        public var isRecordingDisclaimer: Bool?
        /// This field can be used if `recording_disclaimer` is set to true. This field indicates whether or not you would like to ask participants for consent when a recording starts. The value can be one of the following:<br>
        /// * `true`: Ask participants for consent when a recording starts. <br>
        /// * `false`: Do not ask participants for consent when a recording starts.
        public var isAskParticipantsToConsentDisclaimer: Bool?
        /// Ask host to confirm the disclaimer.
        public var isAskHostToConfirmDisclaimer: Bool?
        /// This object represents the minimum passcode requirements set for recordings via Account Recording Settings.
        public var recordingPasswordRequirement: RecordingPasswordRequirement?
        /// Setting to allow cloud recording access only from specific IP address ranges.
        public var ipAddressAccessControl: IpAddressAccessControl?

        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` - Record on cloud.<br>`none` - Disabled.
        public enum AutoRecording: String, Codable, CaseIterable {
            case local
            case cloud
            case `none`
        }

        /// This object represents the minimum passcode requirements set for recordings via Account Recording Settings.
        public struct RecordingPasswordRequirement: Codable {
            /// Minimum required length for the passcode.
            public var length: Int?
            /// Indicates whether or not passcode must contain at least one alphabetical letter (a, b, c..).
            public var haveLetter: Bool?
            /// Indicates whether or not passcode must contain at least one number(1, 2, 3..).
            public var haveNumber: Bool?
            /// Indicates whether or not passcode must contain at least one special character(!, @, #..).
            public var haveSpecialCharacter: Bool?
            /// Indicates whether or not passcode must contain only numeric characters.
            public var onlyAllowNumeric: Bool?

            public init(length: Int? = nil, haveLetter: Bool? = nil, haveNumber: Bool? = nil, haveSpecialCharacter: Bool? = nil, onlyAllowNumeric: Bool? = nil) {
                self.length = length
                self.haveLetter = haveLetter
                self.haveNumber = haveNumber
                self.haveSpecialCharacter = haveSpecialCharacter
                self.onlyAllowNumeric = onlyAllowNumeric
            }

            private enum CodingKeys: String, CodingKey {
                case length
                case haveLetter = "have_letter"
                case haveNumber = "have_number"
                case haveSpecialCharacter = "have_special_character"
                case onlyAllowNumeric = "only_allow_numeric"
            }
        }

        /// Setting to allow cloud recording access only from specific IP address ranges.
        public struct IpAddressAccessControl: Codable {
            /// If set to `true`, the cloud recordings of this account can only be accessed by the IP addresses defined in the `ip_addresses_or_ranges` property.
            public var enable: Bool?
            /// IP addresses or ranges that have access to the cloud recordings. Separate multiple IP ranges with comma. Use n.n.n.n, n.n.n.n/n or n.n.n.n - n.n.n.n syntax where n is a number.
            /// 
            /// Example: `46.33.24.184, 48.99.100.2/25` or `200.181.108.17 - 220.181.108.157`
            public var ipAddressesOrRanges: String?

            public init(enable: Bool? = nil, ipAddressesOrRanges: String? = nil) {
                self.enable = enable
                self.ipAddressesOrRanges = ipAddressesOrRanges
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case ipAddressesOrRanges = "ip_addresses_or_ranges"
            }
        }

        public init(isLocalRecording: Bool? = nil, isCloudRecording: Bool? = nil, isRecordSpeakerView: Bool? = nil, isRecordGalleryView: Bool? = nil, isRecordAudioFile: Bool? = nil, isSaveChatText: Bool? = nil, isShowTimestamp: Bool? = nil, isRecordingAudioTranscript: Bool? = nil, autoRecording: AutoRecording? = nil, isHostPauseStopRecording: Bool? = nil, autoDeleteCmr: Bool? = nil, autoDeleteCmrDays: Int? = nil, isRecordingDisclaimer: Bool? = nil, isAskParticipantsToConsentDisclaimer: Bool? = nil, isAskHostToConfirmDisclaimer: Bool? = nil, recordingPasswordRequirement: RecordingPasswordRequirement? = nil, ipAddressAccessControl: IpAddressAccessControl? = nil) {
            self.isLocalRecording = isLocalRecording
            self.isCloudRecording = isCloudRecording ?? false
            self.isRecordSpeakerView = isRecordSpeakerView ?? false
            self.isRecordGalleryView = isRecordGalleryView ?? false
            self.isRecordAudioFile = isRecordAudioFile ?? false
            self.isSaveChatText = isSaveChatText ?? false
            self.isShowTimestamp = isShowTimestamp ?? false
            self.isRecordingAudioTranscript = isRecordingAudioTranscript
            self.autoRecording = autoRecording
            self.isHostPauseStopRecording = isHostPauseStopRecording ?? false
            self.autoDeleteCmr = autoDeleteCmr ?? false
            self.autoDeleteCmrDays = autoDeleteCmrDays
            self.isRecordingDisclaimer = isRecordingDisclaimer
            self.isAskParticipantsToConsentDisclaimer = isAskParticipantsToConsentDisclaimer
            self.isAskHostToConfirmDisclaimer = isAskHostToConfirmDisclaimer
            self.recordingPasswordRequirement = recordingPasswordRequirement
            self.ipAddressAccessControl = ipAddressAccessControl
        }

        private enum CodingKeys: String, CodingKey {
            case isLocalRecording = "local_recording"
            case isCloudRecording = "cloud_recording"
            case isRecordSpeakerView = "record_speaker_view"
            case isRecordGalleryView = "record_gallery_view"
            case isRecordAudioFile = "record_audio_file"
            case isSaveChatText = "save_chat_text"
            case isShowTimestamp = "show_timestamp"
            case isRecordingAudioTranscript = "recording_audio_transcript"
            case autoRecording = "auto_recording"
            case isHostPauseStopRecording = "host_pause_stop_recording"
            case autoDeleteCmr = "auto_delete_cmr"
            case autoDeleteCmrDays = "auto_delete_cmr_days"
            case isRecordingDisclaimer = "recording_disclaimer"
            case isAskParticipantsToConsentDisclaimer = "ask_participants_to_consent_disclaimer"
            case isAskHostToConfirmDisclaimer = "ask_host_to_confirm_disclaimer"
            case recordingPasswordRequirement = "recording_password_requirement"
            case ipAddressAccessControl = "ip_address_access_control"
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.isLocalRecording = try values.decodeIfPresent(Bool.self, forKey: .isLocalRecording)
            self.isCloudRecording = try values.decodeIfPresent(Bool.self, forKey: .isCloudRecording) ?? false
            self.isRecordSpeakerView = try values.decodeIfPresent(Bool.self, forKey: .isRecordSpeakerView) ?? false
            self.isRecordGalleryView = try values.decodeIfPresent(Bool.self, forKey: .isRecordGalleryView) ?? false
            self.isRecordAudioFile = try values.decodeIfPresent(Bool.self, forKey: .isRecordAudioFile) ?? false
            self.isSaveChatText = try values.decodeIfPresent(Bool.self, forKey: .isSaveChatText) ?? false
            self.isShowTimestamp = try values.decodeIfPresent(Bool.self, forKey: .isShowTimestamp) ?? false
            self.isRecordingAudioTranscript = try values.decodeIfPresent(Bool.self, forKey: .isRecordingAudioTranscript)
            self.autoRecording = try values.decodeIfPresent(AutoRecording.self, forKey: .autoRecording)
            self.isHostPauseStopRecording = try values.decodeIfPresent(Bool.self, forKey: .isHostPauseStopRecording) ?? false
            self.autoDeleteCmr = try values.decodeIfPresent(Bool.self, forKey: .autoDeleteCmr) ?? false
            self.autoDeleteCmrDays = try values.decodeIfPresent(Int.self, forKey: .autoDeleteCmrDays)
            self.isRecordingDisclaimer = try values.decodeIfPresent(Bool.self, forKey: .isRecordingDisclaimer)
            self.isAskParticipantsToConsentDisclaimer = try values.decodeIfPresent(Bool.self, forKey: .isAskParticipantsToConsentDisclaimer)
            self.isAskHostToConfirmDisclaimer = try values.decodeIfPresent(Bool.self, forKey: .isAskHostToConfirmDisclaimer)
            self.recordingPasswordRequirement = try values.decodeIfPresent(RecordingPasswordRequirement.self, forKey: .recordingPasswordRequirement)
            self.ipAddressAccessControl = try values.decodeIfPresent(IpAddressAccessControl.self, forKey: .ipAddressAccessControl)
        }
    }

    /// User settings: Meeting settings
    public struct Telephony: Codable {
        /// Third party audio conference.
        public var isThirdPartyAudio: Bool?
        /// Third party audio conference info.
        public var audioConferenceInfo: String?
        /// Show the international numbers link on the invitation email.
        public var isShowInternationalNumbersLink: Bool?
        /// Indicates where most of the participants call into or call from during a meeting.
        public var telephonyRegions: TelephonyRegions?

        /// Indicates where most of the participants call into or call from during a meeting.
        public struct TelephonyRegions: Codable {
            /// Telephony region options provided by Zoom to select from.
            public var allowedValues: [String]?
            /// The account's selected telephony regions that indicate where most participants call into or call from during a meeting.
            public var selectionValues: String?

            public init(allowedValues: [String]? = nil, selectionValues: String? = nil) {
                self.allowedValues = allowedValues
                self.selectionValues = selectionValues
            }

            private enum CodingKeys: String, CodingKey {
                case allowedValues = "allowed_values"
                case selectionValues = "selection_values"
            }
        }

        public init(isThirdPartyAudio: Bool? = nil, audioConferenceInfo: String? = nil, isShowInternationalNumbersLink: Bool? = nil, telephonyRegions: TelephonyRegions? = nil) {
            self.isThirdPartyAudio = isThirdPartyAudio
            self.audioConferenceInfo = audioConferenceInfo
            self.isShowInternationalNumbersLink = isShowInternationalNumbersLink
            self.telephonyRegions = telephonyRegions
        }

        private enum CodingKeys: String, CodingKey {
            case isThirdPartyAudio = "third_party_audio"
            case audioConferenceInfo = "audio_conference_info"
            case isShowInternationalNumbersLink = "show_international_numbers_link"
            case telephonyRegions = "telephony_regions"
        }
    }

    /// User settings: Feature settings
    public struct Feature: Codable {
        /// User's meeting capacity.
        public var meetingCapacity: Int?
        /// Large meeting feature.
        public var isLargeMeeting: Bool?
        /// Large meeting capacity: can be 500 or 1000, depending on if the user has a large meeting capacity plan subscription or not.
        public var largeMeetingCapacity: Int?
        /// Webinar feature.
        public var isWebinar: Bool?
        /// Webinar capacity: can be 100, 500, 1000, 3000, 5000 or 10000, depending on if the user has a webinar capacity plan subscription or not.
        public var webinarCapacity: Int?
        /// Whether the Zoom Events feature is enabled for the user.
        public var isZoomEvents: Bool?
        /// The user's Zoom Events plan capacity: `500`, `1000`, `3000`, `5000`, `10000`, `20000`, `30000`, or `50000`.
        public var zoomEventsCapacity: Int?
        /// Host meeting in China.
        public var isCnMeeting: Bool?
        /// Host meeting in India.
        public var isInMeeting: Bool?
        /// Zoom phone feature.
        public var isZoomPhone: Bool?
        /// The user's assigned [Concurrent Meeting](https://support.zoom.us/hc/en-us/articles/206122046) type: 
        /// * `Basic` 
        /// * `Plus` 
        /// * `None` 
        /// 
        ///  **Note:** This feature requires a Concurrent Meeting Basic or Plus plan subscription.
        public var concurrentMeeting: ConcurrentMeeting?

        /// The user's assigned [Concurrent Meeting](https://support.zoom.us/hc/en-us/articles/206122046) type: 
        /// * `Basic` 
        /// * `Plus` 
        /// * `None` 
        /// 
        ///  **Note:** This feature requires a Concurrent Meeting Basic or Plus plan subscription.
        public enum ConcurrentMeeting: String, Codable, CaseIterable {
            case basic = "Basic"
            case plus = "Plus"
            case `none` = "None"
        }

        public init(meetingCapacity: Int? = nil, isLargeMeeting: Bool? = nil, largeMeetingCapacity: Int? = nil, isWebinar: Bool? = nil, webinarCapacity: Int? = nil, isZoomEvents: Bool? = nil, zoomEventsCapacity: Int? = nil, isCnMeeting: Bool? = nil, isInMeeting: Bool? = nil, isZoomPhone: Bool? = nil, concurrentMeeting: ConcurrentMeeting? = nil) {
            self.meetingCapacity = meetingCapacity
            self.isLargeMeeting = isLargeMeeting
            self.largeMeetingCapacity = largeMeetingCapacity
            self.isWebinar = isWebinar
            self.webinarCapacity = webinarCapacity
            self.isZoomEvents = isZoomEvents
            self.zoomEventsCapacity = zoomEventsCapacity
            self.isCnMeeting = isCnMeeting
            self.isInMeeting = isInMeeting
            self.isZoomPhone = isZoomPhone
            self.concurrentMeeting = concurrentMeeting
        }

        private enum CodingKeys: String, CodingKey {
            case meetingCapacity = "meeting_capacity"
            case isLargeMeeting = "large_meeting"
            case largeMeetingCapacity = "large_meeting_capacity"
            case isWebinar = "webinar"
            case webinarCapacity = "webinar_capacity"
            case isZoomEvents = "zoom_events"
            case zoomEventsCapacity = "zoom_events_capacity"
            case isCnMeeting = "cn_meeting"
            case isInMeeting = "in_meeting"
            case isZoomPhone = "zoom_phone"
            case concurrentMeeting = "concurrent_meeting"
        }
    }

    /// User settings: TSP settings
    ///
    /// Account Settings: TSP.
    public struct Tsp: Codable {
        /// Call Out
        public var isCallOut: Bool?
        /// Call Out Countries/Regions
        public var callOutCountries: [[String: AnyJSON]]?
        /// Show international numbers link on the invitation email
        public var isShowInternationalNumbersLink: Bool?

        public init(isCallOut: Bool? = nil, callOutCountries: [[String: AnyJSON]]? = nil, isShowInternationalNumbersLink: Bool? = nil) {
            self.isCallOut = isCallOut
            self.callOutCountries = callOutCountries
            self.isShowInternationalNumbersLink = isShowInternationalNumbersLink
        }

        private enum CodingKeys: String, CodingKey {
            case isCallOut = "call_out"
            case callOutCountries = "call_out_countries"
            case isShowInternationalNumbersLink = "show_international_numbers_link"
        }
    }

    public struct Profile: Codable {
        public var recordingStorageLocation: RecordingStorageLocation?

        public struct RecordingStorageLocation: Codable {
            /// Users can choose the country to store their recorded content. Content can include meeting, webinar, and phone recordings, as well as voicemail, transcripts, and custom greeting prompts. See [Managing the Communications Content storage location](https://support.zoom.us/hc/en-us/articles/360050781131) for details.
            /// 
            /// Provide abbreviated country codes as the value for this field. See the [Countries abbreviation list](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries) for details.
            public var allowedValues: [String]?
            /// Abbreviated country code.
            public var value: String?

            public init(allowedValues: [String]? = nil, value: String? = nil) {
                self.allowedValues = allowedValues
                self.value = value
            }

            private enum CodingKeys: String, CodingKey {
                case allowedValues = "allowed_values"
                case value
            }
        }

        public init(recordingStorageLocation: RecordingStorageLocation? = nil) {
            self.recordingStorageLocation = recordingStorageLocation
        }

        private enum CodingKeys: String, CodingKey {
            case recordingStorageLocation = "recording_storage_location"
        }
    }

    /// The user's audio conference settings.
    public struct AudioConferencing: Codable {
        /// The user's [**Toll-free and Fee-based Toll Call**](https://support.zoom.us/hc/en-us/articles/360060950711-Enabling-Toll-free-and-Fee-based-Toll-Call#h_01F5190TYM8736XHQX683YQYSY) settings.
        public var tollFreeAndFeeBasedTollCall: TollFreeAndFeeBasedTollCall?

        /// The user's [**Toll-free and Fee-based Toll Call**](https://support.zoom.us/hc/en-us/articles/360060950711-Enabling-Toll-free-and-Fee-based-Toll-Call#h_01F5190TYM8736XHQX683YQYSY) settings.
        public struct TollFreeAndFeeBasedTollCall: Codable {
            /// Whether the user has the [**Toll-free and Fee-based Toll Call**](https://support.zoom.us/hc/en-us/articles/360060950711-Enabling-Toll-free-and-Fee-based-Toll-Call#h_01F5190TYM8736XHQX683YQYSY) setting enabled.
            public var enable: Bool?
            /// The user's **Toll-free and Fee-based Toll Call** phone number information.
            public var numbers: [Number]?
            /// Whether webinar attendees can dial in through the account's **Toll-free and Fee-based Toll Call** phone numbers. This feature is only available in version 5.2.2 and higher.
            public var allowWebinarAttendeesDial: Bool?

            public struct Number: Codable {
                /// The phone number's [E.164 country calling code](https://en.wikipedia.org/wiki/List_of_country_calling_codes).
                public var code: String?
                /// The phone number's [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
                public var countryCode: String?
                /// The country name.
                public var countryName: String?
                /// The phone number.
                public var number: String?
                /// The phone number's display number.
                public var displayNumber: String?

                public init(code: String? = nil, countryCode: String? = nil, countryName: String? = nil, number: String? = nil, displayNumber: String? = nil) {
                    self.code = code
                    self.countryCode = countryCode
                    self.countryName = countryName
                    self.number = number
                    self.displayNumber = displayNumber
                }

                private enum CodingKeys: String, CodingKey {
                    case code
                    case countryCode = "country_code"
                    case countryName = "country_name"
                    case number
                    case displayNumber = "display_number"
                }
            }

            public init(enable: Bool? = nil, numbers: [Number]? = nil, allowWebinarAttendeesDial: Bool? = nil) {
                self.enable = enable
                self.numbers = numbers
                self.allowWebinarAttendeesDial = allowWebinarAttendeesDial
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case numbers
                case allowWebinarAttendeesDial = "allow_webinar_attendees_dial"
            }
        }

        public init(tollFreeAndFeeBasedTollCall: TollFreeAndFeeBasedTollCall? = nil) {
            self.tollFreeAndFeeBasedTollCall = tollFreeAndFeeBasedTollCall
        }

        private enum CodingKeys: String, CodingKey {
            case tollFreeAndFeeBasedTollCall = "toll_free_and_fee_based_toll_call"
        }
    }

    public init(scheduleMeeting: ScheduleMeeting? = nil, inMeeting: InMeeting? = nil, emailNotification: EmailNotification? = nil, recording: Recording? = nil, telephony: Telephony? = nil, feature: Feature? = nil, tsp: Tsp? = nil, profile: Profile? = nil, audioConferencing: AudioConferencing? = nil) {
        self.scheduleMeeting = scheduleMeeting
        self.inMeeting = inMeeting
        self.emailNotification = emailNotification
        self.recording = recording
        self.telephony = telephony
        self.feature = feature
        self.tsp = tsp
        self.profile = profile
        self.audioConferencing = audioConferencing
    }

    private enum CodingKeys: String, CodingKey {
        case scheduleMeeting = "schedule_meeting"
        case inMeeting = "in_meeting"
        case emailNotification = "email_notification"
        case recording
        case telephony
        case feature
        case tsp
        case profile
        case audioConferencing = "audio_conferencing"
    }
}

/// User settings: Meeting settings
public struct UserSettingsTelephony: Codable {
    /// Third party audio conference.
    public var isThirdPartyAudio: Bool?
    /// Third party audio conference info.
    public var audioConferenceInfo: String?
    /// Show the international numbers link on the invitation email.
    public var isShowInternationalNumbersLink: Bool?
    /// Indicates where most of the participants call into or call from during a meeting.
    public var telephonyRegions: TelephonyRegions?

    /// Indicates where most of the participants call into or call from during a meeting.
    public struct TelephonyRegions: Codable {
        /// Telephony region options provided by Zoom to select from.
        public var allowedValues: [String]?
        /// The account's selected telephony regions that indicate where most participants call into or call from during a meeting.
        public var selectionValues: String?

        public init(allowedValues: [String]? = nil, selectionValues: String? = nil) {
            self.allowedValues = allowedValues
            self.selectionValues = selectionValues
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "allowed_values"
            case selectionValues = "selection_values"
        }
    }

    public init(isThirdPartyAudio: Bool? = nil, audioConferenceInfo: String? = nil, isShowInternationalNumbersLink: Bool? = nil, telephonyRegions: TelephonyRegions? = nil) {
        self.isThirdPartyAudio = isThirdPartyAudio
        self.audioConferenceInfo = audioConferenceInfo
        self.isShowInternationalNumbersLink = isShowInternationalNumbersLink
        self.telephonyRegions = telephonyRegions
    }

    private enum CodingKeys: String, CodingKey {
        case isThirdPartyAudio = "third_party_audio"
        case audioConferenceInfo = "audio_conference_info"
        case isShowInternationalNumbersLink = "show_international_numbers_link"
        case telephonyRegions = "telephony_regions"
    }
}

/// User settings: Meeting settings
public struct UserSettingsInMeeting: Codable {
    /// Zoom requires encryption for all data between the Zoom cloud, Zoom client, and Zoom Room. Require encryption for 3rd party endpoints (H323/SIP).
    public var isE2eEncryption: Bool?
    /// Enable chat during meeting for all participants.
    public var isChat: Bool
    /// Whether to allow participants to only chat with certain groups:
    /// * `1` — The participant cannot use chat.
    /// * `2` — Host and co-hosts only.
    ///  * `3` — The participant can chat with other participants publicly.
    /// * `4` - The participant can chat with other participants publicly and privately.
    /// 
    /// **Note:** This setting is only available with client versions 5.7.3 and above.
    public var allowParticipantsChatWith: Int?
    /// Whether to allow participants to save meeting chats:
    /// * `1` — Participants cannot save meeting chats.
    /// * `2` — Participants can only save host and co-host meeting chats.
    /// * `3` — Participants can save all meeting chats.
    public var allowUsersSaveChats: Int?
    /// Enable 1:1 private chat between participants during meetings.
    public var isPrivateChat: Bool
    /// Auto save all in-meeting chats.
    public var isAutoSavingChat: Bool
    /// Play sound when participants join or leave:<br>`host` - When host joins or leaves.<br>`all` - When any participant joins or leaves.<br>`none` - No join or leave sound.
    public var entryExitChime: EntryExitChime?
    /// Record and play their own voice.
    public var isRecordPlayVoice: Bool?
    /// Enable option to send feedback to Zoom at the end of the meeting.
    public var isFeedback: Bool
    /// Allow the host to add co-hosts.
    public var isCoHost: Bool
    /// Add polls to the meeting controls.
    public var isPolling: Bool
    /// Allow host to put attendee on hold.
    /// 
    /// **This field has been deprecated and is no longer supported.**
    public var isAttendeeOnHold: Bool
    /// Allow participants to use annotation tools.
    public var isAnnotation: Bool
    /// Enable remote control during screensharing.
    public var isRemoteControl: Bool
    /// Enable non-verbal feedback through screens.
    public var isNonVerbalFeedback: Bool
    /// Allow host to split meeting participants into separate breakout rooms.
    public var isBreakoutRoom: Bool
    /// Whether the host can assign participants to breakout rooms when scheduling. This feature is only available in version 4.5.0 or higher.
    public var isBreakoutRoomSchedule: Bool?
    /// Allow host to provide 1:1 remote support to a participant.
    public var isRemoteSupport: Bool
    /// Enable closed captions.
    public var isClosedCaption: Bool
    /// Enable group HD video.
    public var isGroupHd: Bool
    /// Enable virtual background.
    public var isVirtualBackground: Bool
    /// Settings to manage virtual background.
    public var virtualBackgroundSettings: VirtualBackgroundSettings?
    /// Allow another user to take control of the camera.
    public var isFarEndCameraControl: Bool
    /// Share dual camera (deprecated).
    public var isShareDualCamera: Bool
    /// Enable Waiting room - if enabled, attendees can only join after host approves.
    public var isWaitingRoom: Bool
    /// Whether to allow live streaming.
    public var allowLiveStreaming: Bool?
    /// Whether to allow Facebook live streaming.
    public var isLiveStreamingFacebook: Bool?
    /// Whether to allow Workplace by Facebook live streaming.
    public var isWorkplaceByFacebook: Bool?
    /// Whether to allow YouTube live streaming.
    public var isLiveStreamingYoutube: Bool?
    /// Whether to allow custom live streaming.
    public var isCustomLiveStreamingService: Bool?
    /// The custom live streaming service instructions.
    public var customServiceInstructions: String?
    /// Always show meeting controls during a meeting.
    public var isShowMeetingControlToolbar: Bool?
    /// If set to `true`, you can [select data center regions](https://support.zoom.us/hc/en-us/articles/360042411451-Selecting-data-center-regions-for-hosted-meetings-and-webinars) to use for hosting your real-time meeting and webinar traffic. These regions can be provided in the `data_center_regions` field. If set to `false`, the regions cannot be customized and the default regions will be used.
    public var isCustomDataCenterRegions: Bool?
    /// If you have set the value of `custom_data_center_regions` to `true`, specify the data center regions that you would like to opt in to (country codes from among: ["DE", "NL", "HK", "AU", "IN", "LA", "TY", "CN", "US", "CA"]).
    public var dataCenterRegions: [String]?
    /// Whether meeting participants can [communicate using the emoji reactions](https://support.zoom.us/hc/en-us/articles/115001286183-Nonverbal-feedback-and-meeting-reactions) located in the **Reactions** menu in the meeting toolbar.
    public var isMeetingReactions: Bool?
    /// Allow host and participants to share their screen or content during meetings
    public var isScreenSharing: Bool?
    /// Indicates who can share their screen or content during meetings. The value can be one of the following: <br>
    /// `host`: Only host can share the screen.<br>
    /// `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
    public var whoCanShareScreen: WhoCanShareScreen?
    /// Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:<br>
    /// `host`: Only a host can share the screen when someone else is sharing.<br>
    /// `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
    public var whoCanShareScreenWhenSomeoneIsSharing: WhoCanShareScreenWhenSomeoneIsSharing?
    /// Indicates whether [in-meeting file transfer](https://support.zoom.us/hc/en-us/articles/209605493-In-meeting-file-transfer) setting has been enabled for the user or not.
    public var isFileTransfer: Bool?
    /// Indicates whether the [**Request permission to unmute participants**](https://support.zoom.us/hc/en-us/articles/203435537-Muting-and-unmuting-participants-in-a-meeting#h_01EGK4XFWS1SJGZ71MYGKF7260) option has been enabled for the user or not.
    public var isRequestPermissionToUnmute: Bool?
    /// Whether to allow participants to join a meeting directly from their browser and bypass the Zoom application download process. This is useful for participants who cannot download, install, or run applications. Note that the meeting experience from the browser is limited.
    public var isShowAJoinFromYourBrowserLink: Bool?
    /// Whether to allow participants to join a meeting directly from their mobile browser. Note that the meeting experience from the mobile browser is limited.
    public var isJoinFromMobile: Bool?
    /// Whether to allow participants to join a meeting directly from their desktop browser. Note that the meeting experience from the desktop browser is limited.
    public var isJoinFromDesktop: Bool?
    public var webinarLiveStreaming: WebinarLiveStreaming?
    public var webinarChat: WebinarChat?
    /// Information about the user's closed captioning settings.
    public var closedCaptioning: ClosedCaptioning?
    /// Whether the person sharing during a presentation can allow others to control the slide presentation. This feature is only available in version 5.8.3 or higher.
    public var isSlideControl: Bool?
    /// Whether to allow the host to present a survey to participants once a meeting has ended. This feature is only available in version 5.7.3 or higher.
    public var isMeetingSurvey: Bool?
    /// Information about the user's webinar polling settings.
    public var webinarPolling: WebinarPolling?
    /// Whether to allow the host to present surveys to attendees once a webinar has ended.
    public var isWebinarSurvey: Bool?

    /// Play sound when participants join or leave:<br>`host` - When host joins or leaves.<br>`all` - When any participant joins or leaves.<br>`none` - No join or leave sound.
    public enum EntryExitChime: String, Codable, CaseIterable {
        case host
        case all
        case `none`
    }

    /// Settings to manage virtual background.
    public struct VirtualBackgroundSettings: Codable {
        /// Enable virtual background.
        public var enable: Bool?
        /// Allow use of videos for virtual backgrounds.
        public var allowVideos: Bool?
        /// Allow user to upload custom backgrounds.
        public var allowUploadCustom: Bool?
        public var files: [File]?

        public struct File: Codable {
            /// Unique identifier of the file.
            public var id: String?
            /// File name.
            public var name: String?
            /// File type.
            public var type: String?
            /// Indicates whether or not this file is the default virtual background file.
            public var isDefault: Bool?
            /// File size.
            public var size: String?

            public init(id: String? = nil, name: String? = nil, type: String? = nil, isDefault: Bool? = nil, size: String? = nil) {
                self.id = id
                self.name = name
                self.type = type
                self.isDefault = isDefault
                self.size = size
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case name
                case type
                case isDefault = "is_default"
                case size
            }
        }

        public init(enable: Bool? = nil, allowVideos: Bool? = nil, allowUploadCustom: Bool? = nil, files: [File]? = nil) {
            self.enable = enable
            self.allowVideos = allowVideos
            self.allowUploadCustom = allowUploadCustom
            self.files = files
        }

        private enum CodingKeys: String, CodingKey {
            case enable
            case allowVideos = "allow_videos"
            case allowUploadCustom = "allow_upload_custom"
            case files
        }
    }

    /// Indicates who can share their screen or content during meetings. The value can be one of the following: <br>
    /// `host`: Only host can share the screen.<br>
    /// `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
    public enum WhoCanShareScreen: String, Codable, CaseIterable {
        case host
        case all
    }

    /// Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:<br>
    /// `host`: Only a host can share the screen when someone else is sharing.<br>
    /// `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
    public enum WhoCanShareScreenWhenSomeoneIsSharing: String, Codable, CaseIterable {
        case host
        case all
    }

    public struct WebinarLiveStreaming: Codable {
        /// Whether webinar live streaming is enabled.
        public var enable: Bool?
        /// The available live streaming services:
        /// * `facebook`
        /// * `workplace_by_facebook`
        /// * `youtube`
        /// * `custom_live_streaming_service`
        public var liveStreamingService: [LiveStreamingServiceItem]?
        /// The specific instructions to allow your account's meeting hosts to configure a custom live stream.
        public var customServiceInstructions: String?
        /// Whether to notify users to watch the live stream. This does not apply to custom RTMP (real-time messaging protocol).
        public var isLiveStreamingReminder: Bool?

        public enum LiveStreamingServiceItem: String, Codable, CaseIterable {
            case facebook
            case workplaceByFacebook = "workplace_by_facebook"
            case youtube
            case customLiveStreamingService = "custom_live_streaming_service"
        }

        public init(enable: Bool? = nil, liveStreamingService: [LiveStreamingServiceItem]? = nil, customServiceInstructions: String? = nil, isLiveStreamingReminder: Bool? = nil) {
            self.enable = enable
            self.liveStreamingService = liveStreamingService
            self.customServiceInstructions = customServiceInstructions
            self.isLiveStreamingReminder = isLiveStreamingReminder
        }

        private enum CodingKeys: String, CodingKey {
            case enable
            case liveStreamingService = "live_streaming_service"
            case customServiceInstructions = "custom_service_instructions"
            case isLiveStreamingReminder = "live_streaming_reminder"
        }
    }

    public struct WebinarChat: Codable {
        /// Whether to allow webinar participants to send chat messages.
        public var enable: Bool?
        /// Whether to allow webinar panelists to chat with:
        /// * `1` — Host and all panelists.
        /// * `2` — Everyone.
        public var allowPanelistsChatWith: Int?
        /// Allow webinar attendees to chat with:
        /// * `1` — No one.
        /// * `2` — Host and all panelists.
        /// * `3` — Everyone.
        public var allowAttendeesChatWith: Int?
        /// By default, allow webinar attendees to chat with:
        /// * `1` — Host and all panelists.
        /// * `2` — Everyone.
        public var defaultAttendeesChatWith: Int?
        /// Whether to allow webinar panelists to send direct messages to other panelists.
        public var allowPanelistsSendDirectMessage: Bool?
        /// Whether to allow webinar attendees to save chats:
        /// * `0` — Attendees cannot save chats.
        /// * `1` — Attendees can only save host and panelist chats.
        /// * `2` — Attendees can save all chats.
        public var allowUsersSaveChats: Int?
        /// Whether to automatically save chat messages to a local file on the host's computer when the webinar ends.
        public var allowAutoSaveLocalChatFile: Bool?

        public init(enable: Bool? = nil, allowPanelistsChatWith: Int? = nil, allowAttendeesChatWith: Int? = nil, defaultAttendeesChatWith: Int? = nil, allowPanelistsSendDirectMessage: Bool? = nil, allowUsersSaveChats: Int? = nil, allowAutoSaveLocalChatFile: Bool? = nil) {
            self.enable = enable
            self.allowPanelistsChatWith = allowPanelistsChatWith
            self.allowAttendeesChatWith = allowAttendeesChatWith
            self.defaultAttendeesChatWith = defaultAttendeesChatWith
            self.allowPanelistsSendDirectMessage = allowPanelistsSendDirectMessage
            self.allowUsersSaveChats = allowUsersSaveChats
            self.allowAutoSaveLocalChatFile = allowAutoSaveLocalChatFile
        }

        private enum CodingKeys: String, CodingKey {
            case enable
            case allowPanelistsChatWith = "allow_panelists_chat_with"
            case allowAttendeesChatWith = "allow_attendees_chat_with"
            case defaultAttendeesChatWith = "default_attendees_chat_with"
            case allowPanelistsSendDirectMessage = "allow_panelists_send_direct_message"
            case allowUsersSaveChats = "allow_users_save_chats"
            case allowAutoSaveLocalChatFile = "allow_auto_save_local_chat_file"
        }
    }

    /// Information about the user's closed captioning settings.
    public struct ClosedCaptioning: Codable {
        /// Whether to allow the host to type closed captions or assign a participant or 3rd-party service to provide closed captioning.
        public var enable: Bool?
        /// Whether to allow the use of an API token to integrate with 3rd-party closed captioning services.
        public var isThirdPartyCaptioningService: Bool?
        /// Whether to allow a live transcription service to transcribe meetings.
        public var isAutoTranscribing: Bool?
        /// Whether to allow the viewing of full transcripts in the in-meeting side panel.
        public var isViewFullTranscript: Bool?
        /// Whether to allow participants to save closed captions or transcripts.
        public var isSaveCaption: Bool?

        public init(enable: Bool? = nil, isThirdPartyCaptioningService: Bool? = nil, isAutoTranscribing: Bool? = nil, isViewFullTranscript: Bool? = nil, isSaveCaption: Bool? = nil) {
            self.enable = enable
            self.isThirdPartyCaptioningService = isThirdPartyCaptioningService
            self.isAutoTranscribing = isAutoTranscribing
            self.isViewFullTranscript = isViewFullTranscript
            self.isSaveCaption = isSaveCaption
        }

        private enum CodingKeys: String, CodingKey {
            case enable
            case isThirdPartyCaptioningService = "third_party_captioning_service"
            case isAutoTranscribing = "auto_transcribing"
            case isViewFullTranscript = "view_full_transcript"
            case isSaveCaption = "save_caption"
        }
    }

    /// Information about the user's webinar polling settings.
    public struct WebinarPolling: Codable {
        /// Whether to allow the host to add polls before or during a webinar.
        public var enable: Bool?
        /// Whether to allow host to create advanced polls and quizzes. Advanced polls and quizzes include single choice, multiple choice, drop down, matching, short answer, long answer, rank order, and fill-in-the-blank questions. Hosts can also set the correct answers for quizzes they create.
        public var isAdvancedPolls: Bool?

        public init(enable: Bool? = nil, isAdvancedPolls: Bool? = nil) {
            self.enable = enable
            self.isAdvancedPolls = isAdvancedPolls
        }

        private enum CodingKeys: String, CodingKey {
            case enable
            case isAdvancedPolls = "advanced_polls"
        }
    }

    public init(isE2eEncryption: Bool? = nil, isChat: Bool? = nil, allowParticipantsChatWith: Int? = nil, allowUsersSaveChats: Int? = nil, isPrivateChat: Bool? = nil, isAutoSavingChat: Bool? = nil, entryExitChime: EntryExitChime? = nil, isRecordPlayVoice: Bool? = nil, isFeedback: Bool? = nil, isCoHost: Bool? = nil, isPolling: Bool? = nil, isAttendeeOnHold: Bool? = nil, isAnnotation: Bool? = nil, isRemoteControl: Bool? = nil, isNonVerbalFeedback: Bool? = nil, isBreakoutRoom: Bool? = nil, isBreakoutRoomSchedule: Bool? = nil, isRemoteSupport: Bool? = nil, isClosedCaption: Bool? = nil, isGroupHd: Bool? = nil, isVirtualBackground: Bool? = nil, virtualBackgroundSettings: VirtualBackgroundSettings? = nil, isFarEndCameraControl: Bool? = nil, isShareDualCamera: Bool? = nil, isWaitingRoom: Bool? = nil, allowLiveStreaming: Bool? = nil, isLiveStreamingFacebook: Bool? = nil, isWorkplaceByFacebook: Bool? = nil, isLiveStreamingYoutube: Bool? = nil, isCustomLiveStreamingService: Bool? = nil, customServiceInstructions: String? = nil, isShowMeetingControlToolbar: Bool? = nil, isCustomDataCenterRegions: Bool? = nil, dataCenterRegions: [String]? = nil, isMeetingReactions: Bool? = nil, isScreenSharing: Bool? = nil, whoCanShareScreen: WhoCanShareScreen? = nil, whoCanShareScreenWhenSomeoneIsSharing: WhoCanShareScreenWhenSomeoneIsSharing? = nil, isFileTransfer: Bool? = nil, isRequestPermissionToUnmute: Bool? = nil, isShowAJoinFromYourBrowserLink: Bool? = nil, isJoinFromMobile: Bool? = nil, isJoinFromDesktop: Bool? = nil, webinarLiveStreaming: WebinarLiveStreaming? = nil, webinarChat: WebinarChat? = nil, closedCaptioning: ClosedCaptioning? = nil, isSlideControl: Bool? = nil, isMeetingSurvey: Bool? = nil, webinarPolling: WebinarPolling? = nil, isWebinarSurvey: Bool? = nil) {
        self.isE2eEncryption = isE2eEncryption
        self.isChat = isChat ?? false
        self.allowParticipantsChatWith = allowParticipantsChatWith
        self.allowUsersSaveChats = allowUsersSaveChats
        self.isPrivateChat = isPrivateChat ?? false
        self.isAutoSavingChat = isAutoSavingChat ?? false
        self.entryExitChime = entryExitChime
        self.isRecordPlayVoice = isRecordPlayVoice
        self.isFeedback = isFeedback ?? false
        self.isCoHost = isCoHost ?? false
        self.isPolling = isPolling ?? false
        self.isAttendeeOnHold = isAttendeeOnHold ?? false
        self.isAnnotation = isAnnotation ?? false
        self.isRemoteControl = isRemoteControl ?? false
        self.isNonVerbalFeedback = isNonVerbalFeedback ?? false
        self.isBreakoutRoom = isBreakoutRoom ?? false
        self.isBreakoutRoomSchedule = isBreakoutRoomSchedule
        self.isRemoteSupport = isRemoteSupport ?? false
        self.isClosedCaption = isClosedCaption ?? false
        self.isGroupHd = isGroupHd ?? false
        self.isVirtualBackground = isVirtualBackground ?? false
        self.virtualBackgroundSettings = virtualBackgroundSettings
        self.isFarEndCameraControl = isFarEndCameraControl ?? false
        self.isShareDualCamera = isShareDualCamera ?? false
        self.isWaitingRoom = isWaitingRoom ?? false
        self.allowLiveStreaming = allowLiveStreaming
        self.isLiveStreamingFacebook = isLiveStreamingFacebook
        self.isWorkplaceByFacebook = isWorkplaceByFacebook
        self.isLiveStreamingYoutube = isLiveStreamingYoutube
        self.isCustomLiveStreamingService = isCustomLiveStreamingService
        self.customServiceInstructions = customServiceInstructions
        self.isShowMeetingControlToolbar = isShowMeetingControlToolbar
        self.isCustomDataCenterRegions = isCustomDataCenterRegions
        self.dataCenterRegions = dataCenterRegions
        self.isMeetingReactions = isMeetingReactions
        self.isScreenSharing = isScreenSharing
        self.whoCanShareScreen = whoCanShareScreen
        self.whoCanShareScreenWhenSomeoneIsSharing = whoCanShareScreenWhenSomeoneIsSharing
        self.isFileTransfer = isFileTransfer
        self.isRequestPermissionToUnmute = isRequestPermissionToUnmute
        self.isShowAJoinFromYourBrowserLink = isShowAJoinFromYourBrowserLink
        self.isJoinFromMobile = isJoinFromMobile
        self.isJoinFromDesktop = isJoinFromDesktop
        self.webinarLiveStreaming = webinarLiveStreaming
        self.webinarChat = webinarChat
        self.closedCaptioning = closedCaptioning
        self.isSlideControl = isSlideControl
        self.isMeetingSurvey = isMeetingSurvey
        self.webinarPolling = webinarPolling
        self.isWebinarSurvey = isWebinarSurvey
    }

    private enum CodingKeys: String, CodingKey {
        case isE2eEncryption = "e2e_encryption"
        case isChat = "chat"
        case allowParticipantsChatWith = "allow_participants_chat_with"
        case allowUsersSaveChats = "allow_users_save_chats"
        case isPrivateChat = "private_chat"
        case isAutoSavingChat = "auto_saving_chat"
        case entryExitChime = "entry_exit_chime"
        case isRecordPlayVoice = "record_play_voice"
        case isFeedback = "feedback"
        case isCoHost = "co_host"
        case isPolling = "polling"
        case isAttendeeOnHold = "attendee_on_hold"
        case isAnnotation = "annotation"
        case isRemoteControl = "remote_control"
        case isNonVerbalFeedback = "non_verbal_feedback"
        case isBreakoutRoom = "breakout_room"
        case isBreakoutRoomSchedule = "breakout_room_schedule"
        case isRemoteSupport = "remote_support"
        case isClosedCaption = "closed_caption"
        case isGroupHd = "group_hd"
        case isVirtualBackground = "virtual_background"
        case virtualBackgroundSettings = "virtual_background_settings"
        case isFarEndCameraControl = "far_end_camera_control"
        case isShareDualCamera = "share_dual_camera"
        case isWaitingRoom = "waiting_room"
        case allowLiveStreaming = "allow_live_streaming"
        case isLiveStreamingFacebook = "live_streaming_facebook"
        case isWorkplaceByFacebook = "workplace_by_facebook"
        case isLiveStreamingYoutube = "live_streaming_youtube"
        case isCustomLiveStreamingService = "custom_live_streaming_service"
        case customServiceInstructions = "custom_service_instructions"
        case isShowMeetingControlToolbar = "show_meeting_control_toolbar"
        case isCustomDataCenterRegions = "custom_data_center_regions"
        case dataCenterRegions = "data_center_regions"
        case isMeetingReactions = "meeting_reactions"
        case isScreenSharing = "screen_sharing"
        case whoCanShareScreen = "who_can_share_screen"
        case whoCanShareScreenWhenSomeoneIsSharing = "who_can_share_screen_when_someone_is_sharing"
        case isFileTransfer = "file_transfer"
        case isRequestPermissionToUnmute = "request_permission_to_unmute"
        case isShowAJoinFromYourBrowserLink = "show_a_join_from_your_browser_link"
        case isJoinFromMobile = "join_from_mobile"
        case isJoinFromDesktop = "join_from_desktop"
        case webinarLiveStreaming = "webinar_live_streaming"
        case webinarChat = "webinar_chat"
        case closedCaptioning = "closed_captioning"
        case isSlideControl = "slide_control"
        case isMeetingSurvey = "meeting_survey"
        case webinarPolling = "webinar_polling"
        case isWebinarSurvey = "webinar_survey"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isE2eEncryption = try values.decodeIfPresent(Bool.self, forKey: .isE2eEncryption)
        self.isChat = try values.decodeIfPresent(Bool.self, forKey: .isChat) ?? false
        self.allowParticipantsChatWith = try values.decodeIfPresent(Int.self, forKey: .allowParticipantsChatWith)
        self.allowUsersSaveChats = try values.decodeIfPresent(Int.self, forKey: .allowUsersSaveChats)
        self.isPrivateChat = try values.decodeIfPresent(Bool.self, forKey: .isPrivateChat) ?? false
        self.isAutoSavingChat = try values.decodeIfPresent(Bool.self, forKey: .isAutoSavingChat) ?? false
        self.entryExitChime = try values.decodeIfPresent(EntryExitChime.self, forKey: .entryExitChime)
        self.isRecordPlayVoice = try values.decodeIfPresent(Bool.self, forKey: .isRecordPlayVoice)
        self.isFeedback = try values.decodeIfPresent(Bool.self, forKey: .isFeedback) ?? false
        self.isCoHost = try values.decodeIfPresent(Bool.self, forKey: .isCoHost) ?? false
        self.isPolling = try values.decodeIfPresent(Bool.self, forKey: .isPolling) ?? false
        self.isAttendeeOnHold = try values.decodeIfPresent(Bool.self, forKey: .isAttendeeOnHold) ?? false
        self.isAnnotation = try values.decodeIfPresent(Bool.self, forKey: .isAnnotation) ?? false
        self.isRemoteControl = try values.decodeIfPresent(Bool.self, forKey: .isRemoteControl) ?? false
        self.isNonVerbalFeedback = try values.decodeIfPresent(Bool.self, forKey: .isNonVerbalFeedback) ?? false
        self.isBreakoutRoom = try values.decodeIfPresent(Bool.self, forKey: .isBreakoutRoom) ?? false
        self.isBreakoutRoomSchedule = try values.decodeIfPresent(Bool.self, forKey: .isBreakoutRoomSchedule)
        self.isRemoteSupport = try values.decodeIfPresent(Bool.self, forKey: .isRemoteSupport) ?? false
        self.isClosedCaption = try values.decodeIfPresent(Bool.self, forKey: .isClosedCaption) ?? false
        self.isGroupHd = try values.decodeIfPresent(Bool.self, forKey: .isGroupHd) ?? false
        self.isVirtualBackground = try values.decodeIfPresent(Bool.self, forKey: .isVirtualBackground) ?? false
        self.virtualBackgroundSettings = try values.decodeIfPresent(VirtualBackgroundSettings.self, forKey: .virtualBackgroundSettings)
        self.isFarEndCameraControl = try values.decodeIfPresent(Bool.self, forKey: .isFarEndCameraControl) ?? false
        self.isShareDualCamera = try values.decodeIfPresent(Bool.self, forKey: .isShareDualCamera) ?? false
        self.isWaitingRoom = try values.decodeIfPresent(Bool.self, forKey: .isWaitingRoom) ?? false
        self.allowLiveStreaming = try values.decodeIfPresent(Bool.self, forKey: .allowLiveStreaming)
        self.isLiveStreamingFacebook = try values.decodeIfPresent(Bool.self, forKey: .isLiveStreamingFacebook)
        self.isWorkplaceByFacebook = try values.decodeIfPresent(Bool.self, forKey: .isWorkplaceByFacebook)
        self.isLiveStreamingYoutube = try values.decodeIfPresent(Bool.self, forKey: .isLiveStreamingYoutube)
        self.isCustomLiveStreamingService = try values.decodeIfPresent(Bool.self, forKey: .isCustomLiveStreamingService)
        self.customServiceInstructions = try values.decodeIfPresent(String.self, forKey: .customServiceInstructions)
        self.isShowMeetingControlToolbar = try values.decodeIfPresent(Bool.self, forKey: .isShowMeetingControlToolbar)
        self.isCustomDataCenterRegions = try values.decodeIfPresent(Bool.self, forKey: .isCustomDataCenterRegions)
        self.dataCenterRegions = try values.decodeIfPresent([String].self, forKey: .dataCenterRegions)
        self.isMeetingReactions = try values.decodeIfPresent(Bool.self, forKey: .isMeetingReactions)
        self.isScreenSharing = try values.decodeIfPresent(Bool.self, forKey: .isScreenSharing)
        self.whoCanShareScreen = try values.decodeIfPresent(WhoCanShareScreen.self, forKey: .whoCanShareScreen)
        self.whoCanShareScreenWhenSomeoneIsSharing = try values.decodeIfPresent(WhoCanShareScreenWhenSomeoneIsSharing.self, forKey: .whoCanShareScreenWhenSomeoneIsSharing)
        self.isFileTransfer = try values.decodeIfPresent(Bool.self, forKey: .isFileTransfer)
        self.isRequestPermissionToUnmute = try values.decodeIfPresent(Bool.self, forKey: .isRequestPermissionToUnmute)
        self.isShowAJoinFromYourBrowserLink = try values.decodeIfPresent(Bool.self, forKey: .isShowAJoinFromYourBrowserLink)
        self.isJoinFromMobile = try values.decodeIfPresent(Bool.self, forKey: .isJoinFromMobile)
        self.isJoinFromDesktop = try values.decodeIfPresent(Bool.self, forKey: .isJoinFromDesktop)
        self.webinarLiveStreaming = try values.decodeIfPresent(WebinarLiveStreaming.self, forKey: .webinarLiveStreaming)
        self.webinarChat = try values.decodeIfPresent(WebinarChat.self, forKey: .webinarChat)
        self.closedCaptioning = try values.decodeIfPresent(ClosedCaptioning.self, forKey: .closedCaptioning)
        self.isSlideControl = try values.decodeIfPresent(Bool.self, forKey: .isSlideControl)
        self.isMeetingSurvey = try values.decodeIfPresent(Bool.self, forKey: .isMeetingSurvey)
        self.webinarPolling = try values.decodeIfPresent(WebinarPolling.self, forKey: .webinarPolling)
        self.isWebinarSurvey = try values.decodeIfPresent(Bool.self, forKey: .isWebinarSurvey)
    }
}

/// List of user's schedulers.
public struct UserSchedulersList: Codable {
    /// List of users for whom the current user can schedule meetings.
    public var schedulers: [Scheduler]?

    public struct Scheduler: Codable {
        /// Unique Identifier (User ID) of the Scheduler.
        public var id: String?
        /// Email address of the scheduler.
        public var email: String?
        /// PMI of the meeting host in long (int64) format.
        public var pmi: Int?

        public init(id: String? = nil, email: String? = nil, pmi: Int? = nil) {
            self.id = id
            self.email = email
            self.pmi = pmi
        }
    }

    public init(schedulers: [Scheduler]? = nil) {
        self.schedulers = schedulers
    }
}

/// User settings: Notification settings
public struct UserSettingsEmailNotification: Codable {
    /// Whether to notify the host when a cloud recording is available.
    public var isCloudRecordingAvailableReminder: Bool?
    /// Whether to notify the person who scheduled the meeting or webinar for the host when a cloud recording is available.
    public var isRecordingAvailableReminderSchedulers: Bool?
    /// Whether to notify any alternative hosts when a cloud recording is available.
    public var isRecordingAvailableReminderAlternativeHosts: Bool?
    /// When attendees join meeting before host.
    public var isJbhReminder: Bool
    /// When a meeting is cancelled.
    public var isCancelMeetingReminder: Bool
    /// When an alternative host is set or removed from a meeting.
    public var isAlternativeHostReminder: Bool
    /// Notify the host there is a meeting is scheduled, rescheduled, or cancelled.
    public var isScheduleForReminder: Bool

    public init(isCloudRecordingAvailableReminder: Bool? = nil, isRecordingAvailableReminderSchedulers: Bool? = nil, isRecordingAvailableReminderAlternativeHosts: Bool? = nil, isJbhReminder: Bool? = nil, isCancelMeetingReminder: Bool? = nil, isAlternativeHostReminder: Bool? = nil, isScheduleForReminder: Bool? = nil) {
        self.isCloudRecordingAvailableReminder = isCloudRecordingAvailableReminder
        self.isRecordingAvailableReminderSchedulers = isRecordingAvailableReminderSchedulers
        self.isRecordingAvailableReminderAlternativeHosts = isRecordingAvailableReminderAlternativeHosts
        self.isJbhReminder = isJbhReminder ?? false
        self.isCancelMeetingReminder = isCancelMeetingReminder ?? false
        self.isAlternativeHostReminder = isAlternativeHostReminder ?? false
        self.isScheduleForReminder = isScheduleForReminder ?? false
    }

    private enum CodingKeys: String, CodingKey {
        case isCloudRecordingAvailableReminder = "cloud_recording_available_reminder"
        case isRecordingAvailableReminderSchedulers = "recording_available_reminder_schedulers"
        case isRecordingAvailableReminderAlternativeHosts = "recording_available_reminder_alternative_hosts"
        case isJbhReminder = "jbh_reminder"
        case isCancelMeetingReminder = "cancel_meeting_reminder"
        case isAlternativeHostReminder = "alternative_host_reminder"
        case isScheduleForReminder = "schedule_for_reminder"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isCloudRecordingAvailableReminder = try values.decodeIfPresent(Bool.self, forKey: .isCloudRecordingAvailableReminder)
        self.isRecordingAvailableReminderSchedulers = try values.decodeIfPresent(Bool.self, forKey: .isRecordingAvailableReminderSchedulers)
        self.isRecordingAvailableReminderAlternativeHosts = try values.decodeIfPresent(Bool.self, forKey: .isRecordingAvailableReminderAlternativeHosts)
        self.isJbhReminder = try values.decodeIfPresent(Bool.self, forKey: .isJbhReminder) ?? false
        self.isCancelMeetingReminder = try values.decodeIfPresent(Bool.self, forKey: .isCancelMeetingReminder) ?? false
        self.isAlternativeHostReminder = try values.decodeIfPresent(Bool.self, forKey: .isAlternativeHostReminder) ?? false
        self.isScheduleForReminder = try values.decodeIfPresent(Bool.self, forKey: .isScheduleForReminder) ?? false
    }
}

/// The user's audio conference settings.
public struct UserSettingsAudioConference: Codable {
    /// The user's [**Toll-free and Fee-based Toll Call**](https://support.zoom.us/hc/en-us/articles/360060950711-Enabling-Toll-free-and-Fee-based-Toll-Call#h_01F5190TYM8736XHQX683YQYSY) settings.
    public var tollFreeAndFeeBasedTollCall: TollFreeAndFeeBasedTollCall?

    /// The user's [**Toll-free and Fee-based Toll Call**](https://support.zoom.us/hc/en-us/articles/360060950711-Enabling-Toll-free-and-Fee-based-Toll-Call#h_01F5190TYM8736XHQX683YQYSY) settings.
    public struct TollFreeAndFeeBasedTollCall: Codable {
        /// Whether the user has the [**Toll-free and Fee-based Toll Call**](https://support.zoom.us/hc/en-us/articles/360060950711-Enabling-Toll-free-and-Fee-based-Toll-Call#h_01F5190TYM8736XHQX683YQYSY) setting enabled.
        public var enable: Bool?
        /// The user's **Toll-free and Fee-based Toll Call** phone number information.
        public var numbers: [Number]?
        /// Whether webinar attendees can dial in through the account's **Toll-free and Fee-based Toll Call** phone numbers. This feature is only available in version 5.2.2 and higher.
        public var allowWebinarAttendeesDial: Bool?

        public struct Number: Codable {
            /// The phone number's [E.164 country calling code](https://en.wikipedia.org/wiki/List_of_country_calling_codes).
            public var code: String?
            /// The phone number's [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
            public var countryCode: String?
            /// The country name.
            public var countryName: String?
            /// The phone number.
            public var number: String?
            /// The phone number's display number.
            public var displayNumber: String?

            public init(code: String? = nil, countryCode: String? = nil, countryName: String? = nil, number: String? = nil, displayNumber: String? = nil) {
                self.code = code
                self.countryCode = countryCode
                self.countryName = countryName
                self.number = number
                self.displayNumber = displayNumber
            }

            private enum CodingKeys: String, CodingKey {
                case code
                case countryCode = "country_code"
                case countryName = "country_name"
                case number
                case displayNumber = "display_number"
            }
        }

        public init(enable: Bool? = nil, numbers: [Number]? = nil, allowWebinarAttendeesDial: Bool? = nil) {
            self.enable = enable
            self.numbers = numbers
            self.allowWebinarAttendeesDial = allowWebinarAttendeesDial
        }

        private enum CodingKeys: String, CodingKey {
            case enable
            case numbers
            case allowWebinarAttendeesDial = "allow_webinar_attendees_dial"
        }
    }

    public init(tollFreeAndFeeBasedTollCall: TollFreeAndFeeBasedTollCall? = nil) {
        self.tollFreeAndFeeBasedTollCall = tollFreeAndFeeBasedTollCall
    }

    private enum CodingKeys: String, CodingKey {
        case tollFreeAndFeeBasedTollCall = "toll_free_and_fee_based_toll_call"
    }
}

/// User settings: Feature settings
public struct UserSettingsFeatureUpdate: Codable {
    /// Set a user's meeting capacity. User's meeting capacity denotes the maximum number of participants that can join a meeting scheduled by the user.
    public var meetingCapacity: Int?
    /// Enable [large meeting](https://support.zoom.us/hc/en-us/articles/201362823-What-is-a-Large-Meeting-) feature for the user.
    public var isLargeMeeting: Bool?
    /// Set the meeting capacity for the user if the user has **Large meeting** feature enabled. The value for the field can be either 500 or 1000.
    public var largeMeetingCapacity: Int?
    /// Enable Webinar feature for the user.
    public var isWebinar: Bool?
    /// Set the Webinar capacity for a user who has the Webinar feature enabled. The value of this field can be 100, 500, 1000, 3000, 5000 or 10000.
    public var webinarCapacity: Int?
    /// Whether to enable the Zoom Events feature for the user.
    public var isZoomEvents: Bool?
    /// The user's Zoom Events plan capacity: `500`, `1000`, `3000`, `5000`, `10000`, `20000`, `30000`, or `50000`.
    public var zoomEventsCapacity: Int?
    /// Zoom phone feature.
    public var isZoomPhone: Bool?
    /// The user's assigned [Concurrent Meeting](https://support.zoom.us/hc/en-us/articles/206122046) type: 
    /// * `Basic` 
    /// * `Plus` 
    /// * `None` 
    /// 
    ///  **Note:** This feature requires a Concurrent Meeting Basic or Plus plan subscription.
    public var concurrentMeeting: ConcurrentMeeting?

    /// The user's assigned [Concurrent Meeting](https://support.zoom.us/hc/en-us/articles/206122046) type: 
    /// * `Basic` 
    /// * `Plus` 
    /// * `None` 
    /// 
    ///  **Note:** This feature requires a Concurrent Meeting Basic or Plus plan subscription.
    public enum ConcurrentMeeting: String, Codable, CaseIterable {
        case basic = "Basic"
        case plus = "Plus"
        case `none` = "None"
    }

    public init(meetingCapacity: Int? = nil, isLargeMeeting: Bool? = nil, largeMeetingCapacity: Int? = nil, isWebinar: Bool? = nil, webinarCapacity: Int? = nil, isZoomEvents: Bool? = nil, zoomEventsCapacity: Int? = nil, isZoomPhone: Bool? = nil, concurrentMeeting: ConcurrentMeeting? = nil) {
        self.meetingCapacity = meetingCapacity
        self.isLargeMeeting = isLargeMeeting
        self.largeMeetingCapacity = largeMeetingCapacity
        self.isWebinar = isWebinar
        self.webinarCapacity = webinarCapacity
        self.isZoomEvents = isZoomEvents
        self.zoomEventsCapacity = zoomEventsCapacity
        self.isZoomPhone = isZoomPhone
        self.concurrentMeeting = concurrentMeeting
    }

    private enum CodingKeys: String, CodingKey {
        case meetingCapacity = "meeting_capacity"
        case isLargeMeeting = "large_meeting"
        case largeMeetingCapacity = "large_meeting_capacity"
        case isWebinar = "webinar"
        case webinarCapacity = "webinar_capacity"
        case isZoomEvents = "zoom_events"
        case zoomEventsCapacity = "zoom_events_capacity"
        case isZoomPhone = "zoom_phone"
        case concurrentMeeting = "concurrent_meeting"
    }
}

/// List of user's assistants.
public struct UserAssistantsList: Codable {
    /// List of User's assistants.
    public var assistants: [Assistant]?

    public struct Assistant: Codable {
        /// Assistant's user ID.
        public var id: String?
        /// Assistant's email address.
        public var email: String?

        public init(id: String? = nil, email: String? = nil) {
            self.id = id
            self.email = email
        }
    }

    public init(assistants: [Assistant]? = nil) {
        self.assistants = assistants
    }
}

/// User settings: TSP settings
///
/// Account Settings: TSP.
public struct UserSettingsTSP: Codable {
    /// Call Out
    public var isCallOut: Bool?
    /// Call Out Countries/Regions
    public var callOutCountries: [[String: AnyJSON]]?
    /// Show international numbers link on the invitation email
    public var isShowInternationalNumbersLink: Bool?

    public init(isCallOut: Bool? = nil, callOutCountries: [[String: AnyJSON]]? = nil, isShowInternationalNumbersLink: Bool? = nil) {
        self.isCallOut = isCallOut
        self.callOutCountries = callOutCountries
        self.isShowInternationalNumbersLink = isShowInternationalNumbersLink
    }

    private enum CodingKeys: String, CodingKey {
        case isCallOut = "call_out"
        case callOutCountries = "call_out_countries"
        case isShowInternationalNumbersLink = "show_international_numbers_link"
    }
}

/// User settings: Recording settings
public struct UserSettingsRecording: Codable {
    /// Local recording.
    public var isLocalRecording: Bool?
    /// Cloud recording.
    public var isCloudRecording: Bool
    /// Record the active speaker view.
    public var isRecordSpeakerView: Bool
    /// Record the gallery view.
    public var isRecordGalleryView: Bool
    /// Whether to record one audio file for all participants.
    public var isRecordAudioFile: Bool
    /// Save chat text from the meeting.
    public var isSaveChatText: Bool
    /// Show timestamp on video.
    public var isShowTimestamp: Bool
    /// Audio transcript.
    public var isRecordingAudioTranscript: Bool?
    /// Automatic recording:<br>`local` - Record on local.<br>`cloud` - Record on cloud.<br>`none` - Disabled.
    public var autoRecording: AutoRecording?
    /// Host can pause/stop the auto recording in the cloud.
    public var isHostPauseStopRecording: Bool
    /// Auto delete cloud recordings.
    public var autoDeleteCmr: Bool
    /// When the `auto_delete_cmr` value is `true`, this value is the number of days before the auto-deletion of cloud recordings: 
    /// * `30` — 30 days. 
    /// * `60` — 60 days. 
    /// * `90` — 90 days. 
    /// * `120` — 120 days.
    public var autoDeleteCmrDays: Int?
    /// Show a disclaimer to participants before a recording starts
    public var isRecordingDisclaimer: Bool?
    /// This field can be used if `recording_disclaimer` is set to true. This field indicates whether or not you would like to ask participants for consent when a recording starts. The value can be one of the following:<br>
    /// * `true`: Ask participants for consent when a recording starts. <br>
    /// * `false`: Do not ask participants for consent when a recording starts.
    public var isAskParticipantsToConsentDisclaimer: Bool?
    /// Ask host to confirm the disclaimer.
    public var isAskHostToConfirmDisclaimer: Bool?
    /// This object represents the minimum passcode requirements set for recordings via Account Recording Settings.
    public var recordingPasswordRequirement: RecordingPasswordRequirement?
    /// Setting to allow cloud recording access only from specific IP address ranges.
    public var ipAddressAccessControl: IpAddressAccessControl?

    /// Automatic recording:<br>`local` - Record on local.<br>`cloud` - Record on cloud.<br>`none` - Disabled.
    public enum AutoRecording: String, Codable, CaseIterable {
        case local
        case cloud
        case `none`
    }

    /// This object represents the minimum passcode requirements set for recordings via Account Recording Settings.
    public struct RecordingPasswordRequirement: Codable {
        /// Minimum required length for the passcode.
        public var length: Int?
        /// Indicates whether or not passcode must contain at least one alphabetical letter (a, b, c..).
        public var haveLetter: Bool?
        /// Indicates whether or not passcode must contain at least one number(1, 2, 3..).
        public var haveNumber: Bool?
        /// Indicates whether or not passcode must contain at least one special character(!, @, #..).
        public var haveSpecialCharacter: Bool?
        /// Indicates whether or not passcode must contain only numeric characters.
        public var onlyAllowNumeric: Bool?

        public init(length: Int? = nil, haveLetter: Bool? = nil, haveNumber: Bool? = nil, haveSpecialCharacter: Bool? = nil, onlyAllowNumeric: Bool? = nil) {
            self.length = length
            self.haveLetter = haveLetter
            self.haveNumber = haveNumber
            self.haveSpecialCharacter = haveSpecialCharacter
            self.onlyAllowNumeric = onlyAllowNumeric
        }

        private enum CodingKeys: String, CodingKey {
            case length
            case haveLetter = "have_letter"
            case haveNumber = "have_number"
            case haveSpecialCharacter = "have_special_character"
            case onlyAllowNumeric = "only_allow_numeric"
        }
    }

    /// Setting to allow cloud recording access only from specific IP address ranges.
    public struct IpAddressAccessControl: Codable {
        /// If set to `true`, the cloud recordings of this account can only be accessed by the IP addresses defined in the `ip_addresses_or_ranges` property.
        public var enable: Bool?
        /// IP addresses or ranges that have access to the cloud recordings. Separate multiple IP ranges with comma. Use n.n.n.n, n.n.n.n/n or n.n.n.n - n.n.n.n syntax where n is a number.
        /// 
        /// Example: `46.33.24.184, 48.99.100.2/25` or `200.181.108.17 - 220.181.108.157`
        public var ipAddressesOrRanges: String?

        public init(enable: Bool? = nil, ipAddressesOrRanges: String? = nil) {
            self.enable = enable
            self.ipAddressesOrRanges = ipAddressesOrRanges
        }

        private enum CodingKeys: String, CodingKey {
            case enable
            case ipAddressesOrRanges = "ip_addresses_or_ranges"
        }
    }

    public init(isLocalRecording: Bool? = nil, isCloudRecording: Bool? = nil, isRecordSpeakerView: Bool? = nil, isRecordGalleryView: Bool? = nil, isRecordAudioFile: Bool? = nil, isSaveChatText: Bool? = nil, isShowTimestamp: Bool? = nil, isRecordingAudioTranscript: Bool? = nil, autoRecording: AutoRecording? = nil, isHostPauseStopRecording: Bool? = nil, autoDeleteCmr: Bool? = nil, autoDeleteCmrDays: Int? = nil, isRecordingDisclaimer: Bool? = nil, isAskParticipantsToConsentDisclaimer: Bool? = nil, isAskHostToConfirmDisclaimer: Bool? = nil, recordingPasswordRequirement: RecordingPasswordRequirement? = nil, ipAddressAccessControl: IpAddressAccessControl? = nil) {
        self.isLocalRecording = isLocalRecording
        self.isCloudRecording = isCloudRecording ?? false
        self.isRecordSpeakerView = isRecordSpeakerView ?? false
        self.isRecordGalleryView = isRecordGalleryView ?? false
        self.isRecordAudioFile = isRecordAudioFile ?? false
        self.isSaveChatText = isSaveChatText ?? false
        self.isShowTimestamp = isShowTimestamp ?? false
        self.isRecordingAudioTranscript = isRecordingAudioTranscript
        self.autoRecording = autoRecording
        self.isHostPauseStopRecording = isHostPauseStopRecording ?? false
        self.autoDeleteCmr = autoDeleteCmr ?? false
        self.autoDeleteCmrDays = autoDeleteCmrDays
        self.isRecordingDisclaimer = isRecordingDisclaimer
        self.isAskParticipantsToConsentDisclaimer = isAskParticipantsToConsentDisclaimer
        self.isAskHostToConfirmDisclaimer = isAskHostToConfirmDisclaimer
        self.recordingPasswordRequirement = recordingPasswordRequirement
        self.ipAddressAccessControl = ipAddressAccessControl
    }

    private enum CodingKeys: String, CodingKey {
        case isLocalRecording = "local_recording"
        case isCloudRecording = "cloud_recording"
        case isRecordSpeakerView = "record_speaker_view"
        case isRecordGalleryView = "record_gallery_view"
        case isRecordAudioFile = "record_audio_file"
        case isSaveChatText = "save_chat_text"
        case isShowTimestamp = "show_timestamp"
        case isRecordingAudioTranscript = "recording_audio_transcript"
        case autoRecording = "auto_recording"
        case isHostPauseStopRecording = "host_pause_stop_recording"
        case autoDeleteCmr = "auto_delete_cmr"
        case autoDeleteCmrDays = "auto_delete_cmr_days"
        case isRecordingDisclaimer = "recording_disclaimer"
        case isAskParticipantsToConsentDisclaimer = "ask_participants_to_consent_disclaimer"
        case isAskHostToConfirmDisclaimer = "ask_host_to_confirm_disclaimer"
        case recordingPasswordRequirement = "recording_password_requirement"
        case ipAddressAccessControl = "ip_address_access_control"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isLocalRecording = try values.decodeIfPresent(Bool.self, forKey: .isLocalRecording)
        self.isCloudRecording = try values.decodeIfPresent(Bool.self, forKey: .isCloudRecording) ?? false
        self.isRecordSpeakerView = try values.decodeIfPresent(Bool.self, forKey: .isRecordSpeakerView) ?? false
        self.isRecordGalleryView = try values.decodeIfPresent(Bool.self, forKey: .isRecordGalleryView) ?? false
        self.isRecordAudioFile = try values.decodeIfPresent(Bool.self, forKey: .isRecordAudioFile) ?? false
        self.isSaveChatText = try values.decodeIfPresent(Bool.self, forKey: .isSaveChatText) ?? false
        self.isShowTimestamp = try values.decodeIfPresent(Bool.self, forKey: .isShowTimestamp) ?? false
        self.isRecordingAudioTranscript = try values.decodeIfPresent(Bool.self, forKey: .isRecordingAudioTranscript)
        self.autoRecording = try values.decodeIfPresent(AutoRecording.self, forKey: .autoRecording)
        self.isHostPauseStopRecording = try values.decodeIfPresent(Bool.self, forKey: .isHostPauseStopRecording) ?? false
        self.autoDeleteCmr = try values.decodeIfPresent(Bool.self, forKey: .autoDeleteCmr) ?? false
        self.autoDeleteCmrDays = try values.decodeIfPresent(Int.self, forKey: .autoDeleteCmrDays)
        self.isRecordingDisclaimer = try values.decodeIfPresent(Bool.self, forKey: .isRecordingDisclaimer)
        self.isAskParticipantsToConsentDisclaimer = try values.decodeIfPresent(Bool.self, forKey: .isAskParticipantsToConsentDisclaimer)
        self.isAskHostToConfirmDisclaimer = try values.decodeIfPresent(Bool.self, forKey: .isAskHostToConfirmDisclaimer)
        self.recordingPasswordRequirement = try values.decodeIfPresent(RecordingPasswordRequirement.self, forKey: .recordingPasswordRequirement)
        self.ipAddressAccessControl = try values.decodeIfPresent(IpAddressAccessControl.self, forKey: .ipAddressAccessControl)
    }
}

/// User settings: Feature settings
public struct UserSettingsFeature: Codable {
    /// User's meeting capacity.
    public var meetingCapacity: Int?
    /// Large meeting feature.
    public var isLargeMeeting: Bool?
    /// Large meeting capacity: can be 500 or 1000, depending on if the user has a large meeting capacity plan subscription or not.
    public var largeMeetingCapacity: Int?
    /// Webinar feature.
    public var isWebinar: Bool?
    /// Webinar capacity: can be 100, 500, 1000, 3000, 5000 or 10000, depending on if the user has a webinar capacity plan subscription or not.
    public var webinarCapacity: Int?
    /// Whether the Zoom Events feature is enabled for the user.
    public var isZoomEvents: Bool?
    /// The user's Zoom Events plan capacity: `500`, `1000`, `3000`, `5000`, `10000`, `20000`, `30000`, or `50000`.
    public var zoomEventsCapacity: Int?
    /// Host meeting in China.
    public var isCnMeeting: Bool?
    /// Host meeting in India.
    public var isInMeeting: Bool?
    /// Zoom phone feature.
    public var isZoomPhone: Bool?
    /// The user's assigned [Concurrent Meeting](https://support.zoom.us/hc/en-us/articles/206122046) type: 
    /// * `Basic` 
    /// * `Plus` 
    /// * `None` 
    /// 
    ///  **Note:** This feature requires a Concurrent Meeting Basic or Plus plan subscription.
    public var concurrentMeeting: ConcurrentMeeting?

    /// The user's assigned [Concurrent Meeting](https://support.zoom.us/hc/en-us/articles/206122046) type: 
    /// * `Basic` 
    /// * `Plus` 
    /// * `None` 
    /// 
    ///  **Note:** This feature requires a Concurrent Meeting Basic or Plus plan subscription.
    public enum ConcurrentMeeting: String, Codable, CaseIterable {
        case basic = "Basic"
        case plus = "Plus"
        case `none` = "None"
    }

    public init(meetingCapacity: Int? = nil, isLargeMeeting: Bool? = nil, largeMeetingCapacity: Int? = nil, isWebinar: Bool? = nil, webinarCapacity: Int? = nil, isZoomEvents: Bool? = nil, zoomEventsCapacity: Int? = nil, isCnMeeting: Bool? = nil, isInMeeting: Bool? = nil, isZoomPhone: Bool? = nil, concurrentMeeting: ConcurrentMeeting? = nil) {
        self.meetingCapacity = meetingCapacity
        self.isLargeMeeting = isLargeMeeting
        self.largeMeetingCapacity = largeMeetingCapacity
        self.isWebinar = isWebinar
        self.webinarCapacity = webinarCapacity
        self.isZoomEvents = isZoomEvents
        self.zoomEventsCapacity = zoomEventsCapacity
        self.isCnMeeting = isCnMeeting
        self.isInMeeting = isInMeeting
        self.isZoomPhone = isZoomPhone
        self.concurrentMeeting = concurrentMeeting
    }

    private enum CodingKeys: String, CodingKey {
        case meetingCapacity = "meeting_capacity"
        case isLargeMeeting = "large_meeting"
        case largeMeetingCapacity = "large_meeting_capacity"
        case isWebinar = "webinar"
        case webinarCapacity = "webinar_capacity"
        case isZoomEvents = "zoom_events"
        case zoomEventsCapacity = "zoom_events_capacity"
        case isCnMeeting = "cn_meeting"
        case isInMeeting = "in_meeting"
        case isZoomPhone = "zoom_phone"
        case concurrentMeeting = "concurrent_meeting"
    }
}

/// The user update object represents a user on Zoom.
public struct UserUpdate: Codable {
    /// User's first name. Cannot contain more than 5 Chinese characters.
    public var firstName: String?
    /// User's last name. Cannot contain more than 5 Chinese characters.
    public var lastName: String?
    /// User types:<br>`1` - Basic.<br>`2` - Licensed.<br>`3` - On-prem.<br>`99` - None (this can only be set with `ssoCreate`).
    public var type: Int?
    /// Personal meeting ID: length must be 10.
    public var pmi: Int?
    /// Use Personal Meeting ID for instant meetings.
    public var usePmi: Bool
    /// The time zone ID for a user profile. For this parameter value please refer to the ID value in the [timezone](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#timezones) list.
    public var timezone: String?
    /// Language
    public var language: String?
    /// Department for user profile: use for report.
    public var dept: String?
    /// Personal meeting room name.
    public var vanityName: String?
    /// Host key. It should be a 6-10 digit number.
    public var hostKey: String?
    /// Kaltura user ID.
    public var cmsUserID: String?
    /// User's job title.
    public var jobTitle: String?
    /// User's company.
    public var company: String?
    /// User's location.
    public var location: String?
    /// **Note:** This field has been **deprecated** and will not be supported in the future. Use the **phone_numbers** field instead to assign phone number(s) to a user.
    /// 
    /// 
    /// Phone number of the user. To update a phone number, you must also provide the `phone_country` field.
    public var phoneNumber: String?
    /// **Note:** This field has been **deprecated** and will not be supported in the future. Use the **country** field of the **phone_numbers** object instead to select the country for the phone number.
    /// 
    /// 
    /// 
    /// [Country ID](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries) of the phone number. For example, if the phone number provided in the `phone_number` field is a Brazil based number, the value of the `phone_country` field should be `BR`.
    public var phoneCountry: String?
    /// Custom attribute(s) of the user.
    public var customAttributes: CustomAttributes?
    /// Provide unique identifier of the group that you would like to add a [pending user](https://support.zoom.us/hc/en-us/articles/201363183-Managing-users#h_13c87a2a-ecd6-40ad-be61-a9935e660edb) to. The value of this field can be retrieved from [List Groups](https://marketplace.zoom.us/docs/api-reference/zoom-api/groups/groups) API.
    public var groupID: String?
    public var phoneNumbers: PhoneNumbers?
    /// The manager for the user.
    public var manager: String?
    /// The user's pronouns.
    public var pronouns: String?
    /// The user's display pronouns setting:
    /// * `1` — Ask the user every time they join meetings and webinars. 
    /// * `2` — Always display pronouns in meetings and webinars. 
    /// * `3` — Do not display pronouns in meetings and webinars.
    public var pronounsOption: Int?

    /// Custom attribute(s) of the user.
    public struct CustomAttributes: Codable {
        /// Identifier for the custom attribute.
        public var key: String?
        /// Name of the custom attribute.
        public var name: String?
        /// Value of the custom attribute.
        public var value: String?

        public init(key: String? = nil, name: String? = nil, value: String? = nil) {
            self.key = key
            self.name = name
            self.value = value
        }
    }

    public struct PhoneNumbers: Codable {
        /// [Country ID](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries) of the phone number. For example, if the phone number provided in the `number` field is a Brazil based number, the value of the `country` field should be `BR`.
        public var country: String?
        /// Country code of the phone number. For example, for United States phone numbers, the value of this field should be "+1".
        public var code: String?
        /// Phone number of the user.
        public var number: String?
        /// The label to add to the user's phone number. You can only add one label to the user's phone number:
        /// 
        /// * `Mobile`
        /// * `Office`
        /// * `Home`
        /// * `Fax`
        public var label: Label?

        /// The label to add to the user's phone number. You can only add one label to the user's phone number:
        /// 
        /// * `Mobile`
        /// * `Office`
        /// * `Home`
        /// * `Fax`
        public enum Label: String, Codable, CaseIterable {
            case mobile = "Mobile"
            case office = "Office"
            case home = "Home"
            case fax = "Fax"
        }

        public init(country: String? = nil, code: String? = nil, number: String? = nil, label: Label? = nil) {
            self.country = country
            self.code = code
            self.number = number
            self.label = label
        }
    }

    public init(firstName: String? = nil, lastName: String? = nil, type: Int? = nil, pmi: Int? = nil, usePmi: Bool? = nil, timezone: String? = nil, language: String? = nil, dept: String? = nil, vanityName: String? = nil, hostKey: String? = nil, cmsUserID: String? = nil, jobTitle: String? = nil, company: String? = nil, location: String? = nil, phoneNumber: String? = nil, phoneCountry: String? = nil, customAttributes: CustomAttributes? = nil, groupID: String? = nil, phoneNumbers: PhoneNumbers? = nil, manager: String? = nil, pronouns: String? = nil, pronounsOption: Int? = nil) {
        self.firstName = firstName
        self.lastName = lastName
        self.type = type
        self.pmi = pmi
        self.usePmi = usePmi ?? false
        self.timezone = timezone
        self.language = language
        self.dept = dept
        self.vanityName = vanityName
        self.hostKey = hostKey
        self.cmsUserID = cmsUserID
        self.jobTitle = jobTitle
        self.company = company
        self.location = location
        self.phoneNumber = phoneNumber
        self.phoneCountry = phoneCountry
        self.customAttributes = customAttributes
        self.groupID = groupID
        self.phoneNumbers = phoneNumbers
        self.manager = manager
        self.pronouns = pronouns
        self.pronounsOption = pronounsOption
    }

    private enum CodingKeys: String, CodingKey {
        case firstName = "first_name"
        case lastName = "last_name"
        case type
        case pmi
        case usePmi = "use_pmi"
        case timezone
        case language
        case dept
        case vanityName = "vanity_name"
        case hostKey = "host_key"
        case cmsUserID = "cms_user_id"
        case jobTitle = "job_title"
        case company
        case location
        case phoneNumber = "phone_number"
        case phoneCountry = "phone_country"
        case customAttributes = "custom_attributes"
        case groupID = "group_id"
        case phoneNumbers = "phone_numbers"
        case manager
        case pronouns
        case pronounsOption = "pronouns_option"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.firstName = try values.decodeIfPresent(String.self, forKey: .firstName)
        self.lastName = try values.decodeIfPresent(String.self, forKey: .lastName)
        self.type = try values.decodeIfPresent(Int.self, forKey: .type)
        self.pmi = try values.decodeIfPresent(Int.self, forKey: .pmi)
        self.usePmi = try values.decodeIfPresent(Bool.self, forKey: .usePmi) ?? false
        self.timezone = try values.decodeIfPresent(String.self, forKey: .timezone)
        self.language = try values.decodeIfPresent(String.self, forKey: .language)
        self.dept = try values.decodeIfPresent(String.self, forKey: .dept)
        self.vanityName = try values.decodeIfPresent(String.self, forKey: .vanityName)
        self.hostKey = try values.decodeIfPresent(String.self, forKey: .hostKey)
        self.cmsUserID = try values.decodeIfPresent(String.self, forKey: .cmsUserID)
        self.jobTitle = try values.decodeIfPresent(String.self, forKey: .jobTitle)
        self.company = try values.decodeIfPresent(String.self, forKey: .company)
        self.location = try values.decodeIfPresent(String.self, forKey: .location)
        self.phoneNumber = try values.decodeIfPresent(String.self, forKey: .phoneNumber)
        self.phoneCountry = try values.decodeIfPresent(String.self, forKey: .phoneCountry)
        self.customAttributes = try values.decodeIfPresent(CustomAttributes.self, forKey: .customAttributes)
        self.groupID = try values.decodeIfPresent(String.self, forKey: .groupID)
        self.phoneNumbers = try values.decodeIfPresent(PhoneNumbers.self, forKey: .phoneNumbers)
        self.manager = try values.decodeIfPresent(String.self, forKey: .manager)
        self.pronouns = try values.decodeIfPresent(String.self, forKey: .pronouns)
        self.pronounsOption = try values.decodeIfPresent(Int.self, forKey: .pronounsOption)
    }
}

/// User settings
public struct UserSettingsUpdate: Codable {
    /// User settings: Meeting settings
    public var scheduleMeeting: ScheduleMeeting?
    /// User settings: Meeting settings
    public var inMeeting: InMeeting?
    /// User settings: Notification settings
    public var emailNotification: EmailNotification?
    /// User settings: Recording settings
    public var recording: Recording?
    /// Telephony update settings: Meeting settings
    public var telephony: Telephony?
    /// User settings: Feature settings
    public var feature: Feature?
    /// User settings: TSP settings
    ///
    /// Account Settings: TSP.
    public var tsp: Tsp?
    public var profile: Profile?

    /// User settings: Meeting settings
    public struct ScheduleMeeting: Codable {
        /// Start meetings with host video on.
        public var isHostVideo: Bool?
        /// Start meetings with participants video on.
        public var isParticipantsVideo: Bool?
        /// Determine how participants can join the audio portion of the meeting:<br>`both` - Telephony and VoIP.<br>`telephony` - Audio PSTN telephony only.<br>`voip` - VoIP only.<br>`thirdParty` - Third party audio conference.
        public var audioType: AudioType?
        /// Join the meeting before host arrives.
        public var isJoinBeforeHost: Bool?
        /// Require a passcode for personal meetings if attendees can join before host.
        public var isForcePmiJbhPassword: Bool?
        /// Generate and require passcode for participants joining by phone.
        public var isPstnPasswordProtected: Bool?
        /// Use Personal Meeting ID (PMI) when scheduling a meeting
        public var usePmiForScheduledMeetings: Bool?
        /// Use Personal Meeting ID (PMI) when starting an instant meeting
        public var usePmiForInstantMeetings: Bool?
        /// Require a passcode when scheduling new meetings.This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
        public var requirePasswordForSchedulingNewMeetings: Bool?
        /// Require a passcode for meetings which have already been scheduled
        public var requirePasswordForScheduledMeetings: Bool?
        /// Passcode for already scheduled meetings
        public var defaultPasswordForScheduledMeetings: String?
        /// Require a passcode for instant meetings. If you use PMI for your instant meetings, this option will be disabled. This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
        public var requirePasswordForInstantMeetings: Bool?
        /// Require a passcode for Personal Meeting ID (PMI). This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
        public var requirePasswordForPmiMeetings: RequirePasswordForPmiMeetings?
        /// PMI passcode
        public var pmiPassword: String?
        /// If the value is set to `true`, the meeting passcode will be encrypted and included in the join meeting link to allow participants to join with just one click without having to enter the passcode.
        public var isEmbedPasswordInJoinLink: Bool?
        /// Account wide meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
        public var meetingPasswordRequirement: MeetingPasswordRequirement?
        /// Personal Meeting Setting.<br><br>
        /// `true`: Indicates that the **"Enable Personal Meeting ID"** setting is turned on. Users can choose to use personal meeting ID for their meetings. <br><br>
        /// `false`: Indicates that the **"Enable Personal Meeting ID"** setting is [turned off](https://support.zoom.us/hc/en-us/articles/201362843-Personal-meeting-ID-PMI-and-personal-link#h_aa0335c8-3b06-41bc-bc1f-a8b84ef17f2a). If this setting is disabled, meetings that were scheduled with PMI will be invalid. Scheduled meetings will need to be manually updated.
        /// For Zoom Phone only:If a user has been assigned a desk phone, **"Elevate to Zoom Meeting"** on desk phone will be disabled.
        public var isPersonalMeeting: Bool?

        /// Determine how participants can join the audio portion of the meeting:<br>`both` - Telephony and VoIP.<br>`telephony` - Audio PSTN telephony only.<br>`voip` - VoIP only.<br>`thirdParty` - Third party audio conference.
        public enum AudioType: String, Codable, CaseIterable {
            case both
            case telephony
            case voip
            case thirdParty
        }

        /// Require a passcode for Personal Meeting ID (PMI). This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
        public enum RequirePasswordForPmiMeetings: String, Codable, CaseIterable {
            case jbhOnly = "jbh_only"
            case all
            case `none`
        }

        /// Account wide meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
        public struct MeetingPasswordRequirement: Codable {
            /// The minimum length that the meeting/webinar passcode needs to have.
            public var length: Int?
            /// If set to `true`, the passcode must contain at least 1 letter (such as a,b,c...).
            public var haveLetter: Bool?
            /// If set to `true`, the passcode must contain at least 1 number (such as 1,2,3...).
            public var haveNumber: Bool?
            /// If set to `true`, the passcode must have at least 1 special character (!,@,#...).
            public var haveSpecialCharacter: Bool?
            /// If set to `true`, the passcode must only contain numbers and no other characters.
            public var onlyAllowNumeric: Bool?
            /// If set to `true`, the passcode must include both uppercase and lowercase characters.
            public var haveUpperAndLowerCharacters: Bool?
            public var consecutiveCharactersLength: Int?
            /// If set to `true`, users will be informed if the provided passcode is weak.
            public var isWeakEnhanceDetection: Bool?

            public init(length: Int? = nil, haveLetter: Bool? = nil, haveNumber: Bool? = nil, haveSpecialCharacter: Bool? = nil, onlyAllowNumeric: Bool? = nil, haveUpperAndLowerCharacters: Bool? = nil, consecutiveCharactersLength: Int? = nil, isWeakEnhanceDetection: Bool? = nil) {
                self.length = length
                self.haveLetter = haveLetter
                self.haveNumber = haveNumber
                self.haveSpecialCharacter = haveSpecialCharacter
                self.onlyAllowNumeric = onlyAllowNumeric
                self.haveUpperAndLowerCharacters = haveUpperAndLowerCharacters
                self.consecutiveCharactersLength = consecutiveCharactersLength
                self.isWeakEnhanceDetection = isWeakEnhanceDetection
            }

            private enum CodingKeys: String, CodingKey {
                case length
                case haveLetter = "have_letter"
                case haveNumber = "have_number"
                case haveSpecialCharacter = "have_special_character"
                case onlyAllowNumeric = "only_allow_numeric"
                case haveUpperAndLowerCharacters = "have_upper_and_lower_characters"
                case consecutiveCharactersLength = "consecutive_characters_length"
                case isWeakEnhanceDetection = "weak_enhance_detection"
            }
        }

        public init(isHostVideo: Bool? = nil, isParticipantsVideo: Bool? = nil, audioType: AudioType? = nil, isJoinBeforeHost: Bool? = nil, isForcePmiJbhPassword: Bool? = nil, isPstnPasswordProtected: Bool? = nil, usePmiForScheduledMeetings: Bool? = nil, usePmiForInstantMeetings: Bool? = nil, requirePasswordForSchedulingNewMeetings: Bool? = nil, requirePasswordForScheduledMeetings: Bool? = nil, defaultPasswordForScheduledMeetings: String? = nil, requirePasswordForInstantMeetings: Bool? = nil, requirePasswordForPmiMeetings: RequirePasswordForPmiMeetings? = nil, pmiPassword: String? = nil, isEmbedPasswordInJoinLink: Bool? = nil, meetingPasswordRequirement: MeetingPasswordRequirement? = nil, isPersonalMeeting: Bool? = nil) {
            self.isHostVideo = isHostVideo
            self.isParticipantsVideo = isParticipantsVideo
            self.audioType = audioType
            self.isJoinBeforeHost = isJoinBeforeHost
            self.isForcePmiJbhPassword = isForcePmiJbhPassword
            self.isPstnPasswordProtected = isPstnPasswordProtected
            self.usePmiForScheduledMeetings = usePmiForScheduledMeetings
            self.usePmiForInstantMeetings = usePmiForInstantMeetings
            self.requirePasswordForSchedulingNewMeetings = requirePasswordForSchedulingNewMeetings
            self.requirePasswordForScheduledMeetings = requirePasswordForScheduledMeetings
            self.defaultPasswordForScheduledMeetings = defaultPasswordForScheduledMeetings
            self.requirePasswordForInstantMeetings = requirePasswordForInstantMeetings
            self.requirePasswordForPmiMeetings = requirePasswordForPmiMeetings
            self.pmiPassword = pmiPassword
            self.isEmbedPasswordInJoinLink = isEmbedPasswordInJoinLink
            self.meetingPasswordRequirement = meetingPasswordRequirement
            self.isPersonalMeeting = isPersonalMeeting
        }

        private enum CodingKeys: String, CodingKey {
            case isHostVideo = "host_video"
            case isParticipantsVideo = "participants_video"
            case audioType = "audio_type"
            case isJoinBeforeHost = "join_before_host"
            case isForcePmiJbhPassword = "force_pmi_jbh_password"
            case isPstnPasswordProtected = "pstn_password_protected"
            case usePmiForScheduledMeetings = "use_pmi_for_scheduled_meetings"
            case usePmiForInstantMeetings = "use_pmi_for_instant_meetings"
            case requirePasswordForSchedulingNewMeetings = "require_password_for_scheduling_new_meetings"
            case requirePasswordForScheduledMeetings = "require_password_for_scheduled_meetings"
            case defaultPasswordForScheduledMeetings = "default_password_for_scheduled_meetings"
            case requirePasswordForInstantMeetings = "require_password_for_instant_meetings"
            case requirePasswordForPmiMeetings = "require_password_for_pmi_meetings"
            case pmiPassword = "pmi_password"
            case isEmbedPasswordInJoinLink = "embed_password_in_join_link"
            case meetingPasswordRequirement = "meeting_password_requirement"
            case isPersonalMeeting = "personal_meeting"
        }
    }

    /// User settings: Meeting settings
    public struct InMeeting: Codable {
        /// Zoom requires encryption for all data between the Zoom cloud, Zoom client, and Zoom Room. Require encryption for 3rd party endpoints (H323/SIP).
        public var isE2eEncryption: Bool?
        /// Enable chat during meeting for all participants.
        public var isChat: Bool
        /// Whether to allow participants to only chat with certain groups:
        /// * `1` — The participant cannot use chat.
        /// * `2` — Host and co-hosts only.
        ///  * `3` — The participant can chat with other participants publicly.
        /// * `4` - The participant can chat with other participants publicly and privately.
        /// 
        /// **Note:** This setting is only available with client versions 5.7.3 and above.
        public var allowParticipantsChatWith: Int?
        /// Whether to allow participants to save meeting chats:
        /// * `1` — Participants cannot save meeting chats.
        /// * `2` — Participants can only save host and co-host meeting chats.
        /// * `3` — Participants can save all meeting chats.
        public var allowUsersSaveChats: Int?
        /// Enable 1:1 private chat between participants during meetings.
        public var isPrivateChat: Bool
        /// Auto save all in-meeting chats.
        public var isAutoSavingChat: Bool
        /// Play sound when participants join or leave:<br>`host` - When host joins or leaves.<br>`all` - When any participant joins or leaves.<br>`none` - No join or leave sound.
        public var entryExitChime: EntryExitChime?
        /// Record and play their own voice.
        public var isRecordPlayVoice: Bool?
        /// Enable option to send feedback to Zoom at the end of the meeting.
        public var isFeedback: Bool
        /// Allow the host to add co-hosts.
        public var isCoHost: Bool
        /// Add polls to the meeting controls.
        public var isPolling: Bool
        /// Allow host to put attendee on hold.
        /// 
        /// **This field has been deprecated and is no longer supported.**
        public var isAttendeeOnHold: Bool
        /// Allow participants to use annotation tools.
        public var isAnnotation: Bool
        /// Enable remote control during screensharing.
        public var isRemoteControl: Bool
        /// Enable non-verbal feedback through screens.
        public var isNonVerbalFeedback: Bool
        /// Allow host to split meeting participants into separate breakout rooms.
        public var isBreakoutRoom: Bool
        /// Whether the host can assign participants to breakout rooms when scheduling. This feature is only available in version 4.5.0 or higher.
        public var isBreakoutRoomSchedule: Bool?
        /// Allow host to provide 1:1 remote support to a participant.
        public var isRemoteSupport: Bool
        /// Enable closed captions.
        public var isClosedCaption: Bool
        /// Enable group HD video.
        public var isGroupHd: Bool
        /// Enable virtual background.
        public var isVirtualBackground: Bool
        /// Settings to manage virtual background.
        public var virtualBackgroundSettings: VirtualBackgroundSettings?
        /// Allow another user to take control of the camera.
        public var isFarEndCameraControl: Bool
        /// Share dual camera (deprecated).
        public var isShareDualCamera: Bool
        /// Enable Waiting room - if enabled, attendees can only join after host approves.
        public var isWaitingRoom: Bool
        /// Whether to allow live streaming.
        public var allowLiveStreaming: Bool?
        /// Whether to allow Facebook live streaming.
        public var isLiveStreamingFacebook: Bool?
        /// Whether to allow Workplace by Facebook live streaming.
        public var isWorkplaceByFacebook: Bool?
        /// Whether to allow YouTube live streaming.
        public var isLiveStreamingYoutube: Bool?
        /// Whether to allow custom live streaming.
        public var isCustomLiveStreamingService: Bool?
        /// The custom live streaming service instructions.
        public var customServiceInstructions: String?
        /// Always show meeting controls during a meeting.
        public var isShowMeetingControlToolbar: Bool?
        /// If set to `true`, you can [select data center regions](https://support.zoom.us/hc/en-us/articles/360042411451-Selecting-data-center-regions-for-hosted-meetings-and-webinars) to use for hosting your real-time meeting and webinar traffic. These regions can be provided in the `data_center_regions` field. If set to `false`, the regions cannot be customized and the default regions will be used.
        public var isCustomDataCenterRegions: Bool?
        /// If you have set the value of `custom_data_center_regions` to `true`, specify the data center regions that you would like to opt in to (country codes from among: ["DE", "NL", "HK", "AU", "IN", "LA", "TY", "CN", "US", "CA"]).
        public var dataCenterRegions: [String]?
        /// Whether meeting participants can [communicate using the emoji reactions](https://support.zoom.us/hc/en-us/articles/115001286183-Nonverbal-feedback-and-meeting-reactions) located in the **Reactions** menu in the meeting toolbar.
        public var isMeetingReactions: Bool?
        /// Allow host and participants to share their screen or content during meetings
        public var isScreenSharing: Bool?
        /// Indicates who can share their screen or content during meetings. The value can be one of the following: <br>
        /// `host`: Only host can share the screen.<br>
        /// `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
        public var whoCanShareScreen: WhoCanShareScreen?
        /// Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:<br>
        /// `host`: Only a host can share the screen when someone else is sharing.<br>
        /// `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
        public var whoCanShareScreenWhenSomeoneIsSharing: WhoCanShareScreenWhenSomeoneIsSharing?
        /// Indicates whether [in-meeting file transfer](https://support.zoom.us/hc/en-us/articles/209605493-In-meeting-file-transfer) setting has been enabled for the user or not.
        public var isFileTransfer: Bool?
        /// Indicates whether the [**Request permission to unmute participants**](https://support.zoom.us/hc/en-us/articles/203435537-Muting-and-unmuting-participants-in-a-meeting#h_01EGK4XFWS1SJGZ71MYGKF7260) option has been enabled for the user or not.
        public var isRequestPermissionToUnmute: Bool?
        /// Whether to allow participants to join a meeting directly from their browser and bypass the Zoom application download process. This is useful for participants who cannot download, install, or run applications. Note that the meeting experience from the browser is limited.
        public var isShowAJoinFromYourBrowserLink: Bool?
        /// Whether to allow participants to join a meeting directly from their mobile browser. Note that the meeting experience from the mobile browser is limited.
        public var isJoinFromMobile: Bool?
        /// Whether to allow participants to join a meeting directly from their desktop browser. Note that the meeting experience from the desktop browser is limited.
        public var isJoinFromDesktop: Bool?
        public var webinarLiveStreaming: WebinarLiveStreaming?
        public var webinarChat: WebinarChat?
        /// Information about the user's closed captioning settings.
        public var closedCaptioning: ClosedCaptioning?
        /// Whether the person sharing during a presentation can allow others to control the slide presentation. This feature is only available in version 5.8.3 or higher.
        public var isSlideControl: Bool?
        /// Whether to allow the host to present a survey to participants once a meeting has ended. This feature is only available in version 5.7.3 or higher.
        public var isMeetingSurvey: Bool?
        /// Information about the user's webinar polling settings.
        public var webinarPolling: WebinarPolling?
        /// Whether to allow the host to present surveys to attendees once a webinar has ended.
        public var isWebinarSurvey: Bool?

        /// Play sound when participants join or leave:<br>`host` - When host joins or leaves.<br>`all` - When any participant joins or leaves.<br>`none` - No join or leave sound.
        public enum EntryExitChime: String, Codable, CaseIterable {
            case host
            case all
            case `none`
        }

        /// Settings to manage virtual background.
        public struct VirtualBackgroundSettings: Codable {
            /// Enable virtual background.
            public var enable: Bool?
            /// Allow use of videos for virtual backgrounds.
            public var allowVideos: Bool?
            /// Allow user to upload custom backgrounds.
            public var allowUploadCustom: Bool?
            public var files: [File]?

            public struct File: Codable {
                /// Unique identifier of the file.
                public var id: String?
                /// File name.
                public var name: String?
                /// File type.
                public var type: String?
                /// Indicates whether or not this file is the default virtual background file.
                public var isDefault: Bool?
                /// File size.
                public var size: String?

                public init(id: String? = nil, name: String? = nil, type: String? = nil, isDefault: Bool? = nil, size: String? = nil) {
                    self.id = id
                    self.name = name
                    self.type = type
                    self.isDefault = isDefault
                    self.size = size
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case name
                    case type
                    case isDefault = "is_default"
                    case size
                }
            }

            public init(enable: Bool? = nil, allowVideos: Bool? = nil, allowUploadCustom: Bool? = nil, files: [File]? = nil) {
                self.enable = enable
                self.allowVideos = allowVideos
                self.allowUploadCustom = allowUploadCustom
                self.files = files
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case allowVideos = "allow_videos"
                case allowUploadCustom = "allow_upload_custom"
                case files
            }
        }

        /// Indicates who can share their screen or content during meetings. The value can be one of the following: <br>
        /// `host`: Only host can share the screen.<br>
        /// `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
        public enum WhoCanShareScreen: String, Codable, CaseIterable {
            case host
            case all
        }

        /// Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:<br>
        /// `host`: Only a host can share the screen when someone else is sharing.<br>
        /// `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
        public enum WhoCanShareScreenWhenSomeoneIsSharing: String, Codable, CaseIterable {
            case host
            case all
        }

        public struct WebinarLiveStreaming: Codable {
            /// Whether webinar live streaming is enabled.
            public var enable: Bool?
            /// The available live streaming services:
            /// * `facebook`
            /// * `workplace_by_facebook`
            /// * `youtube`
            /// * `custom_live_streaming_service`
            public var liveStreamingService: [LiveStreamingServiceItem]?
            /// The specific instructions to allow your account's meeting hosts to configure a custom live stream.
            public var customServiceInstructions: String?
            /// Whether to notify users to watch the live stream. This does not apply to custom RTMP (real-time messaging protocol).
            public var isLiveStreamingReminder: Bool?

            public enum LiveStreamingServiceItem: String, Codable, CaseIterable {
                case facebook
                case workplaceByFacebook = "workplace_by_facebook"
                case youtube
                case customLiveStreamingService = "custom_live_streaming_service"
            }

            public init(enable: Bool? = nil, liveStreamingService: [LiveStreamingServiceItem]? = nil, customServiceInstructions: String? = nil, isLiveStreamingReminder: Bool? = nil) {
                self.enable = enable
                self.liveStreamingService = liveStreamingService
                self.customServiceInstructions = customServiceInstructions
                self.isLiveStreamingReminder = isLiveStreamingReminder
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case liveStreamingService = "live_streaming_service"
                case customServiceInstructions = "custom_service_instructions"
                case isLiveStreamingReminder = "live_streaming_reminder"
            }
        }

        public struct WebinarChat: Codable {
            /// Whether to allow webinar participants to send chat messages.
            public var enable: Bool?
            /// Whether to allow webinar panelists to chat with:
            /// * `1` — Host and all panelists.
            /// * `2` — Everyone.
            public var allowPanelistsChatWith: Int?
            /// Allow webinar attendees to chat with:
            /// * `1` — No one.
            /// * `2` — Host and all panelists.
            /// * `3` — Everyone.
            public var allowAttendeesChatWith: Int?
            /// By default, allow webinar attendees to chat with:
            /// * `1` — Host and all panelists.
            /// * `2` — Everyone.
            public var defaultAttendeesChatWith: Int?
            /// Whether to allow webinar panelists to send direct messages to other panelists.
            public var allowPanelistsSendDirectMessage: Bool?
            /// Whether to allow webinar attendees to save chats:
            /// * `0` — Attendees cannot save chats.
            /// * `1` — Attendees can only save host and panelist chats.
            /// * `2` — Attendees can save all chats.
            public var allowUsersSaveChats: Int?
            /// Whether to automatically save chat messages to a local file on the host's computer when the webinar ends.
            public var allowAutoSaveLocalChatFile: Bool?

            public init(enable: Bool? = nil, allowPanelistsChatWith: Int? = nil, allowAttendeesChatWith: Int? = nil, defaultAttendeesChatWith: Int? = nil, allowPanelistsSendDirectMessage: Bool? = nil, allowUsersSaveChats: Int? = nil, allowAutoSaveLocalChatFile: Bool? = nil) {
                self.enable = enable
                self.allowPanelistsChatWith = allowPanelistsChatWith
                self.allowAttendeesChatWith = allowAttendeesChatWith
                self.defaultAttendeesChatWith = defaultAttendeesChatWith
                self.allowPanelistsSendDirectMessage = allowPanelistsSendDirectMessage
                self.allowUsersSaveChats = allowUsersSaveChats
                self.allowAutoSaveLocalChatFile = allowAutoSaveLocalChatFile
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case allowPanelistsChatWith = "allow_panelists_chat_with"
                case allowAttendeesChatWith = "allow_attendees_chat_with"
                case defaultAttendeesChatWith = "default_attendees_chat_with"
                case allowPanelistsSendDirectMessage = "allow_panelists_send_direct_message"
                case allowUsersSaveChats = "allow_users_save_chats"
                case allowAutoSaveLocalChatFile = "allow_auto_save_local_chat_file"
            }
        }

        /// Information about the user's closed captioning settings.
        public struct ClosedCaptioning: Codable {
            /// Whether to allow the host to type closed captions or assign a participant or 3rd-party service to provide closed captioning.
            public var enable: Bool?
            /// Whether to allow the use of an API token to integrate with 3rd-party closed captioning services.
            public var isThirdPartyCaptioningService: Bool?
            /// Whether to allow a live transcription service to transcribe meetings.
            public var isAutoTranscribing: Bool?
            /// Whether to allow the viewing of full transcripts in the in-meeting side panel.
            public var isViewFullTranscript: Bool?
            /// Whether to allow participants to save closed captions or transcripts.
            public var isSaveCaption: Bool?

            public init(enable: Bool? = nil, isThirdPartyCaptioningService: Bool? = nil, isAutoTranscribing: Bool? = nil, isViewFullTranscript: Bool? = nil, isSaveCaption: Bool? = nil) {
                self.enable = enable
                self.isThirdPartyCaptioningService = isThirdPartyCaptioningService
                self.isAutoTranscribing = isAutoTranscribing
                self.isViewFullTranscript = isViewFullTranscript
                self.isSaveCaption = isSaveCaption
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case isThirdPartyCaptioningService = "third_party_captioning_service"
                case isAutoTranscribing = "auto_transcribing"
                case isViewFullTranscript = "view_full_transcript"
                case isSaveCaption = "save_caption"
            }
        }

        /// Information about the user's webinar polling settings.
        public struct WebinarPolling: Codable {
            /// Whether to allow the host to add polls before or during a webinar.
            public var enable: Bool?
            /// Whether to allow host to create advanced polls and quizzes. Advanced polls and quizzes include single choice, multiple choice, drop down, matching, short answer, long answer, rank order, and fill-in-the-blank questions. Hosts can also set the correct answers for quizzes they create.
            public var isAdvancedPolls: Bool?

            public init(enable: Bool? = nil, isAdvancedPolls: Bool? = nil) {
                self.enable = enable
                self.isAdvancedPolls = isAdvancedPolls
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case isAdvancedPolls = "advanced_polls"
            }
        }

        public init(isE2eEncryption: Bool? = nil, isChat: Bool? = nil, allowParticipantsChatWith: Int? = nil, allowUsersSaveChats: Int? = nil, isPrivateChat: Bool? = nil, isAutoSavingChat: Bool? = nil, entryExitChime: EntryExitChime? = nil, isRecordPlayVoice: Bool? = nil, isFeedback: Bool? = nil, isCoHost: Bool? = nil, isPolling: Bool? = nil, isAttendeeOnHold: Bool? = nil, isAnnotation: Bool? = nil, isRemoteControl: Bool? = nil, isNonVerbalFeedback: Bool? = nil, isBreakoutRoom: Bool? = nil, isBreakoutRoomSchedule: Bool? = nil, isRemoteSupport: Bool? = nil, isClosedCaption: Bool? = nil, isGroupHd: Bool? = nil, isVirtualBackground: Bool? = nil, virtualBackgroundSettings: VirtualBackgroundSettings? = nil, isFarEndCameraControl: Bool? = nil, isShareDualCamera: Bool? = nil, isWaitingRoom: Bool? = nil, allowLiveStreaming: Bool? = nil, isLiveStreamingFacebook: Bool? = nil, isWorkplaceByFacebook: Bool? = nil, isLiveStreamingYoutube: Bool? = nil, isCustomLiveStreamingService: Bool? = nil, customServiceInstructions: String? = nil, isShowMeetingControlToolbar: Bool? = nil, isCustomDataCenterRegions: Bool? = nil, dataCenterRegions: [String]? = nil, isMeetingReactions: Bool? = nil, isScreenSharing: Bool? = nil, whoCanShareScreen: WhoCanShareScreen? = nil, whoCanShareScreenWhenSomeoneIsSharing: WhoCanShareScreenWhenSomeoneIsSharing? = nil, isFileTransfer: Bool? = nil, isRequestPermissionToUnmute: Bool? = nil, isShowAJoinFromYourBrowserLink: Bool? = nil, isJoinFromMobile: Bool? = nil, isJoinFromDesktop: Bool? = nil, webinarLiveStreaming: WebinarLiveStreaming? = nil, webinarChat: WebinarChat? = nil, closedCaptioning: ClosedCaptioning? = nil, isSlideControl: Bool? = nil, isMeetingSurvey: Bool? = nil, webinarPolling: WebinarPolling? = nil, isWebinarSurvey: Bool? = nil) {
            self.isE2eEncryption = isE2eEncryption
            self.isChat = isChat ?? false
            self.allowParticipantsChatWith = allowParticipantsChatWith
            self.allowUsersSaveChats = allowUsersSaveChats
            self.isPrivateChat = isPrivateChat ?? false
            self.isAutoSavingChat = isAutoSavingChat ?? false
            self.entryExitChime = entryExitChime
            self.isRecordPlayVoice = isRecordPlayVoice
            self.isFeedback = isFeedback ?? false
            self.isCoHost = isCoHost ?? false
            self.isPolling = isPolling ?? false
            self.isAttendeeOnHold = isAttendeeOnHold ?? false
            self.isAnnotation = isAnnotation ?? false
            self.isRemoteControl = isRemoteControl ?? false
            self.isNonVerbalFeedback = isNonVerbalFeedback ?? false
            self.isBreakoutRoom = isBreakoutRoom ?? false
            self.isBreakoutRoomSchedule = isBreakoutRoomSchedule
            self.isRemoteSupport = isRemoteSupport ?? false
            self.isClosedCaption = isClosedCaption ?? false
            self.isGroupHd = isGroupHd ?? false
            self.isVirtualBackground = isVirtualBackground ?? false
            self.virtualBackgroundSettings = virtualBackgroundSettings
            self.isFarEndCameraControl = isFarEndCameraControl ?? false
            self.isShareDualCamera = isShareDualCamera ?? false
            self.isWaitingRoom = isWaitingRoom ?? false
            self.allowLiveStreaming = allowLiveStreaming
            self.isLiveStreamingFacebook = isLiveStreamingFacebook
            self.isWorkplaceByFacebook = isWorkplaceByFacebook
            self.isLiveStreamingYoutube = isLiveStreamingYoutube
            self.isCustomLiveStreamingService = isCustomLiveStreamingService
            self.customServiceInstructions = customServiceInstructions
            self.isShowMeetingControlToolbar = isShowMeetingControlToolbar
            self.isCustomDataCenterRegions = isCustomDataCenterRegions
            self.dataCenterRegions = dataCenterRegions
            self.isMeetingReactions = isMeetingReactions
            self.isScreenSharing = isScreenSharing
            self.whoCanShareScreen = whoCanShareScreen
            self.whoCanShareScreenWhenSomeoneIsSharing = whoCanShareScreenWhenSomeoneIsSharing
            self.isFileTransfer = isFileTransfer
            self.isRequestPermissionToUnmute = isRequestPermissionToUnmute
            self.isShowAJoinFromYourBrowserLink = isShowAJoinFromYourBrowserLink
            self.isJoinFromMobile = isJoinFromMobile
            self.isJoinFromDesktop = isJoinFromDesktop
            self.webinarLiveStreaming = webinarLiveStreaming
            self.webinarChat = webinarChat
            self.closedCaptioning = closedCaptioning
            self.isSlideControl = isSlideControl
            self.isMeetingSurvey = isMeetingSurvey
            self.webinarPolling = webinarPolling
            self.isWebinarSurvey = isWebinarSurvey
        }

        private enum CodingKeys: String, CodingKey {
            case isE2eEncryption = "e2e_encryption"
            case isChat = "chat"
            case allowParticipantsChatWith = "allow_participants_chat_with"
            case allowUsersSaveChats = "allow_users_save_chats"
            case isPrivateChat = "private_chat"
            case isAutoSavingChat = "auto_saving_chat"
            case entryExitChime = "entry_exit_chime"
            case isRecordPlayVoice = "record_play_voice"
            case isFeedback = "feedback"
            case isCoHost = "co_host"
            case isPolling = "polling"
            case isAttendeeOnHold = "attendee_on_hold"
            case isAnnotation = "annotation"
            case isRemoteControl = "remote_control"
            case isNonVerbalFeedback = "non_verbal_feedback"
            case isBreakoutRoom = "breakout_room"
            case isBreakoutRoomSchedule = "breakout_room_schedule"
            case isRemoteSupport = "remote_support"
            case isClosedCaption = "closed_caption"
            case isGroupHd = "group_hd"
            case isVirtualBackground = "virtual_background"
            case virtualBackgroundSettings = "virtual_background_settings"
            case isFarEndCameraControl = "far_end_camera_control"
            case isShareDualCamera = "share_dual_camera"
            case isWaitingRoom = "waiting_room"
            case allowLiveStreaming = "allow_live_streaming"
            case isLiveStreamingFacebook = "live_streaming_facebook"
            case isWorkplaceByFacebook = "workplace_by_facebook"
            case isLiveStreamingYoutube = "live_streaming_youtube"
            case isCustomLiveStreamingService = "custom_live_streaming_service"
            case customServiceInstructions = "custom_service_instructions"
            case isShowMeetingControlToolbar = "show_meeting_control_toolbar"
            case isCustomDataCenterRegions = "custom_data_center_regions"
            case dataCenterRegions = "data_center_regions"
            case isMeetingReactions = "meeting_reactions"
            case isScreenSharing = "screen_sharing"
            case whoCanShareScreen = "who_can_share_screen"
            case whoCanShareScreenWhenSomeoneIsSharing = "who_can_share_screen_when_someone_is_sharing"
            case isFileTransfer = "file_transfer"
            case isRequestPermissionToUnmute = "request_permission_to_unmute"
            case isShowAJoinFromYourBrowserLink = "show_a_join_from_your_browser_link"
            case isJoinFromMobile = "join_from_mobile"
            case isJoinFromDesktop = "join_from_desktop"
            case webinarLiveStreaming = "webinar_live_streaming"
            case webinarChat = "webinar_chat"
            case closedCaptioning = "closed_captioning"
            case isSlideControl = "slide_control"
            case isMeetingSurvey = "meeting_survey"
            case webinarPolling = "webinar_polling"
            case isWebinarSurvey = "webinar_survey"
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.isE2eEncryption = try values.decodeIfPresent(Bool.self, forKey: .isE2eEncryption)
            self.isChat = try values.decodeIfPresent(Bool.self, forKey: .isChat) ?? false
            self.allowParticipantsChatWith = try values.decodeIfPresent(Int.self, forKey: .allowParticipantsChatWith)
            self.allowUsersSaveChats = try values.decodeIfPresent(Int.self, forKey: .allowUsersSaveChats)
            self.isPrivateChat = try values.decodeIfPresent(Bool.self, forKey: .isPrivateChat) ?? false
            self.isAutoSavingChat = try values.decodeIfPresent(Bool.self, forKey: .isAutoSavingChat) ?? false
            self.entryExitChime = try values.decodeIfPresent(EntryExitChime.self, forKey: .entryExitChime)
            self.isRecordPlayVoice = try values.decodeIfPresent(Bool.self, forKey: .isRecordPlayVoice)
            self.isFeedback = try values.decodeIfPresent(Bool.self, forKey: .isFeedback) ?? false
            self.isCoHost = try values.decodeIfPresent(Bool.self, forKey: .isCoHost) ?? false
            self.isPolling = try values.decodeIfPresent(Bool.self, forKey: .isPolling) ?? false
            self.isAttendeeOnHold = try values.decodeIfPresent(Bool.self, forKey: .isAttendeeOnHold) ?? false
            self.isAnnotation = try values.decodeIfPresent(Bool.self, forKey: .isAnnotation) ?? false
            self.isRemoteControl = try values.decodeIfPresent(Bool.self, forKey: .isRemoteControl) ?? false
            self.isNonVerbalFeedback = try values.decodeIfPresent(Bool.self, forKey: .isNonVerbalFeedback) ?? false
            self.isBreakoutRoom = try values.decodeIfPresent(Bool.self, forKey: .isBreakoutRoom) ?? false
            self.isBreakoutRoomSchedule = try values.decodeIfPresent(Bool.self, forKey: .isBreakoutRoomSchedule)
            self.isRemoteSupport = try values.decodeIfPresent(Bool.self, forKey: .isRemoteSupport) ?? false
            self.isClosedCaption = try values.decodeIfPresent(Bool.self, forKey: .isClosedCaption) ?? false
            self.isGroupHd = try values.decodeIfPresent(Bool.self, forKey: .isGroupHd) ?? false
            self.isVirtualBackground = try values.decodeIfPresent(Bool.self, forKey: .isVirtualBackground) ?? false
            self.virtualBackgroundSettings = try values.decodeIfPresent(VirtualBackgroundSettings.self, forKey: .virtualBackgroundSettings)
            self.isFarEndCameraControl = try values.decodeIfPresent(Bool.self, forKey: .isFarEndCameraControl) ?? false
            self.isShareDualCamera = try values.decodeIfPresent(Bool.self, forKey: .isShareDualCamera) ?? false
            self.isWaitingRoom = try values.decodeIfPresent(Bool.self, forKey: .isWaitingRoom) ?? false
            self.allowLiveStreaming = try values.decodeIfPresent(Bool.self, forKey: .allowLiveStreaming)
            self.isLiveStreamingFacebook = try values.decodeIfPresent(Bool.self, forKey: .isLiveStreamingFacebook)
            self.isWorkplaceByFacebook = try values.decodeIfPresent(Bool.self, forKey: .isWorkplaceByFacebook)
            self.isLiveStreamingYoutube = try values.decodeIfPresent(Bool.self, forKey: .isLiveStreamingYoutube)
            self.isCustomLiveStreamingService = try values.decodeIfPresent(Bool.self, forKey: .isCustomLiveStreamingService)
            self.customServiceInstructions = try values.decodeIfPresent(String.self, forKey: .customServiceInstructions)
            self.isShowMeetingControlToolbar = try values.decodeIfPresent(Bool.self, forKey: .isShowMeetingControlToolbar)
            self.isCustomDataCenterRegions = try values.decodeIfPresent(Bool.self, forKey: .isCustomDataCenterRegions)
            self.dataCenterRegions = try values.decodeIfPresent([String].self, forKey: .dataCenterRegions)
            self.isMeetingReactions = try values.decodeIfPresent(Bool.self, forKey: .isMeetingReactions)
            self.isScreenSharing = try values.decodeIfPresent(Bool.self, forKey: .isScreenSharing)
            self.whoCanShareScreen = try values.decodeIfPresent(WhoCanShareScreen.self, forKey: .whoCanShareScreen)
            self.whoCanShareScreenWhenSomeoneIsSharing = try values.decodeIfPresent(WhoCanShareScreenWhenSomeoneIsSharing.self, forKey: .whoCanShareScreenWhenSomeoneIsSharing)
            self.isFileTransfer = try values.decodeIfPresent(Bool.self, forKey: .isFileTransfer)
            self.isRequestPermissionToUnmute = try values.decodeIfPresent(Bool.self, forKey: .isRequestPermissionToUnmute)
            self.isShowAJoinFromYourBrowserLink = try values.decodeIfPresent(Bool.self, forKey: .isShowAJoinFromYourBrowserLink)
            self.isJoinFromMobile = try values.decodeIfPresent(Bool.self, forKey: .isJoinFromMobile)
            self.isJoinFromDesktop = try values.decodeIfPresent(Bool.self, forKey: .isJoinFromDesktop)
            self.webinarLiveStreaming = try values.decodeIfPresent(WebinarLiveStreaming.self, forKey: .webinarLiveStreaming)
            self.webinarChat = try values.decodeIfPresent(WebinarChat.self, forKey: .webinarChat)
            self.closedCaptioning = try values.decodeIfPresent(ClosedCaptioning.self, forKey: .closedCaptioning)
            self.isSlideControl = try values.decodeIfPresent(Bool.self, forKey: .isSlideControl)
            self.isMeetingSurvey = try values.decodeIfPresent(Bool.self, forKey: .isMeetingSurvey)
            self.webinarPolling = try values.decodeIfPresent(WebinarPolling.self, forKey: .webinarPolling)
            self.isWebinarSurvey = try values.decodeIfPresent(Bool.self, forKey: .isWebinarSurvey)
        }
    }

    /// User settings: Notification settings
    public struct EmailNotification: Codable {
        /// Whether to notify the host when a cloud recording is available.
        public var isCloudRecordingAvailableReminder: Bool?
        /// Whether to notify the person who scheduled the meeting or webinar for the host when a cloud recording is available.
        public var isRecordingAvailableReminderSchedulers: Bool?
        /// Whether to notify any alternative hosts when a cloud recording is available.
        public var isRecordingAvailableReminderAlternativeHosts: Bool?
        /// When attendees join meeting before host.
        public var isJbhReminder: Bool
        /// When a meeting is cancelled.
        public var isCancelMeetingReminder: Bool
        /// When an alternative host is set or removed from a meeting.
        public var isAlternativeHostReminder: Bool
        /// Notify the host there is a meeting is scheduled, rescheduled, or cancelled.
        public var isScheduleForReminder: Bool

        public init(isCloudRecordingAvailableReminder: Bool? = nil, isRecordingAvailableReminderSchedulers: Bool? = nil, isRecordingAvailableReminderAlternativeHosts: Bool? = nil, isJbhReminder: Bool? = nil, isCancelMeetingReminder: Bool? = nil, isAlternativeHostReminder: Bool? = nil, isScheduleForReminder: Bool? = nil) {
            self.isCloudRecordingAvailableReminder = isCloudRecordingAvailableReminder
            self.isRecordingAvailableReminderSchedulers = isRecordingAvailableReminderSchedulers
            self.isRecordingAvailableReminderAlternativeHosts = isRecordingAvailableReminderAlternativeHosts
            self.isJbhReminder = isJbhReminder ?? false
            self.isCancelMeetingReminder = isCancelMeetingReminder ?? false
            self.isAlternativeHostReminder = isAlternativeHostReminder ?? false
            self.isScheduleForReminder = isScheduleForReminder ?? false
        }

        private enum CodingKeys: String, CodingKey {
            case isCloudRecordingAvailableReminder = "cloud_recording_available_reminder"
            case isRecordingAvailableReminderSchedulers = "recording_available_reminder_schedulers"
            case isRecordingAvailableReminderAlternativeHosts = "recording_available_reminder_alternative_hosts"
            case isJbhReminder = "jbh_reminder"
            case isCancelMeetingReminder = "cancel_meeting_reminder"
            case isAlternativeHostReminder = "alternative_host_reminder"
            case isScheduleForReminder = "schedule_for_reminder"
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.isCloudRecordingAvailableReminder = try values.decodeIfPresent(Bool.self, forKey: .isCloudRecordingAvailableReminder)
            self.isRecordingAvailableReminderSchedulers = try values.decodeIfPresent(Bool.self, forKey: .isRecordingAvailableReminderSchedulers)
            self.isRecordingAvailableReminderAlternativeHosts = try values.decodeIfPresent(Bool.self, forKey: .isRecordingAvailableReminderAlternativeHosts)
            self.isJbhReminder = try values.decodeIfPresent(Bool.self, forKey: .isJbhReminder) ?? false
            self.isCancelMeetingReminder = try values.decodeIfPresent(Bool.self, forKey: .isCancelMeetingReminder) ?? false
            self.isAlternativeHostReminder = try values.decodeIfPresent(Bool.self, forKey: .isAlternativeHostReminder) ?? false
            self.isScheduleForReminder = try values.decodeIfPresent(Bool.self, forKey: .isScheduleForReminder) ?? false
        }
    }

    /// User settings: Recording settings
    public struct Recording: Codable {
        /// Local recording.
        public var isLocalRecording: Bool?
        /// Cloud recording.
        public var isCloudRecording: Bool
        /// Record the active speaker view.
        public var isRecordSpeakerView: Bool
        /// Record the gallery view.
        public var isRecordGalleryView: Bool
        /// Whether to record one audio file for all participants.
        public var isRecordAudioFile: Bool
        /// Save chat text from the meeting.
        public var isSaveChatText: Bool
        /// Show timestamp on video.
        public var isShowTimestamp: Bool
        /// Audio transcript.
        public var isRecordingAudioTranscript: Bool?
        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` - Record on cloud.<br>`none` - Disabled.
        public var autoRecording: AutoRecording?
        /// Host can pause/stop the auto recording in the cloud.
        public var isHostPauseStopRecording: Bool
        /// Auto delete cloud recordings.
        public var autoDeleteCmr: Bool
        /// When the `auto_delete_cmr` value is `true`, this value is the number of days before the auto-deletion of cloud recordings: 
        /// * `30` — 30 days. 
        /// * `60` — 60 days. 
        /// * `90` — 90 days. 
        /// * `120` — 120 days.
        public var autoDeleteCmrDays: Int?
        /// Show a disclaimer to participants before a recording starts
        public var isRecordingDisclaimer: Bool?
        /// This field can be used if `recording_disclaimer` is set to true. This field indicates whether or not you would like to ask participants for consent when a recording starts. The value can be one of the following:<br>
        /// * `true`: Ask participants for consent when a recording starts. <br>
        /// * `false`: Do not ask participants for consent when a recording starts.
        public var isAskParticipantsToConsentDisclaimer: Bool?
        /// Ask host to confirm the disclaimer.
        public var isAskHostToConfirmDisclaimer: Bool?
        /// This object represents the minimum passcode requirements set for recordings via Account Recording Settings.
        public var recordingPasswordRequirement: RecordingPasswordRequirement?
        /// Setting to allow cloud recording access only from specific IP address ranges.
        public var ipAddressAccessControl: IpAddressAccessControl?

        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` - Record on cloud.<br>`none` - Disabled.
        public enum AutoRecording: String, Codable, CaseIterable {
            case local
            case cloud
            case `none`
        }

        /// This object represents the minimum passcode requirements set for recordings via Account Recording Settings.
        public struct RecordingPasswordRequirement: Codable {
            /// Minimum required length for the passcode.
            public var length: Int?
            /// Indicates whether or not passcode must contain at least one alphabetical letter (a, b, c..).
            public var haveLetter: Bool?
            /// Indicates whether or not passcode must contain at least one number(1, 2, 3..).
            public var haveNumber: Bool?
            /// Indicates whether or not passcode must contain at least one special character(!, @, #..).
            public var haveSpecialCharacter: Bool?
            /// Indicates whether or not passcode must contain only numeric characters.
            public var onlyAllowNumeric: Bool?

            public init(length: Int? = nil, haveLetter: Bool? = nil, haveNumber: Bool? = nil, haveSpecialCharacter: Bool? = nil, onlyAllowNumeric: Bool? = nil) {
                self.length = length
                self.haveLetter = haveLetter
                self.haveNumber = haveNumber
                self.haveSpecialCharacter = haveSpecialCharacter
                self.onlyAllowNumeric = onlyAllowNumeric
            }

            private enum CodingKeys: String, CodingKey {
                case length
                case haveLetter = "have_letter"
                case haveNumber = "have_number"
                case haveSpecialCharacter = "have_special_character"
                case onlyAllowNumeric = "only_allow_numeric"
            }
        }

        /// Setting to allow cloud recording access only from specific IP address ranges.
        public struct IpAddressAccessControl: Codable {
            /// If set to `true`, the cloud recordings of this account can only be accessed by the IP addresses defined in the `ip_addresses_or_ranges` property.
            public var enable: Bool?
            /// IP addresses or ranges that have access to the cloud recordings. Separate multiple IP ranges with comma. Use n.n.n.n, n.n.n.n/n or n.n.n.n - n.n.n.n syntax where n is a number.
            /// 
            /// Example: `46.33.24.184, 48.99.100.2/25` or `200.181.108.17 - 220.181.108.157`
            public var ipAddressesOrRanges: String?

            public init(enable: Bool? = nil, ipAddressesOrRanges: String? = nil) {
                self.enable = enable
                self.ipAddressesOrRanges = ipAddressesOrRanges
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case ipAddressesOrRanges = "ip_addresses_or_ranges"
            }
        }

        public init(isLocalRecording: Bool? = nil, isCloudRecording: Bool? = nil, isRecordSpeakerView: Bool? = nil, isRecordGalleryView: Bool? = nil, isRecordAudioFile: Bool? = nil, isSaveChatText: Bool? = nil, isShowTimestamp: Bool? = nil, isRecordingAudioTranscript: Bool? = nil, autoRecording: AutoRecording? = nil, isHostPauseStopRecording: Bool? = nil, autoDeleteCmr: Bool? = nil, autoDeleteCmrDays: Int? = nil, isRecordingDisclaimer: Bool? = nil, isAskParticipantsToConsentDisclaimer: Bool? = nil, isAskHostToConfirmDisclaimer: Bool? = nil, recordingPasswordRequirement: RecordingPasswordRequirement? = nil, ipAddressAccessControl: IpAddressAccessControl? = nil) {
            self.isLocalRecording = isLocalRecording
            self.isCloudRecording = isCloudRecording ?? false
            self.isRecordSpeakerView = isRecordSpeakerView ?? false
            self.isRecordGalleryView = isRecordGalleryView ?? false
            self.isRecordAudioFile = isRecordAudioFile ?? false
            self.isSaveChatText = isSaveChatText ?? false
            self.isShowTimestamp = isShowTimestamp ?? false
            self.isRecordingAudioTranscript = isRecordingAudioTranscript
            self.autoRecording = autoRecording
            self.isHostPauseStopRecording = isHostPauseStopRecording ?? false
            self.autoDeleteCmr = autoDeleteCmr ?? false
            self.autoDeleteCmrDays = autoDeleteCmrDays
            self.isRecordingDisclaimer = isRecordingDisclaimer
            self.isAskParticipantsToConsentDisclaimer = isAskParticipantsToConsentDisclaimer
            self.isAskHostToConfirmDisclaimer = isAskHostToConfirmDisclaimer
            self.recordingPasswordRequirement = recordingPasswordRequirement
            self.ipAddressAccessControl = ipAddressAccessControl
        }

        private enum CodingKeys: String, CodingKey {
            case isLocalRecording = "local_recording"
            case isCloudRecording = "cloud_recording"
            case isRecordSpeakerView = "record_speaker_view"
            case isRecordGalleryView = "record_gallery_view"
            case isRecordAudioFile = "record_audio_file"
            case isSaveChatText = "save_chat_text"
            case isShowTimestamp = "show_timestamp"
            case isRecordingAudioTranscript = "recording_audio_transcript"
            case autoRecording = "auto_recording"
            case isHostPauseStopRecording = "host_pause_stop_recording"
            case autoDeleteCmr = "auto_delete_cmr"
            case autoDeleteCmrDays = "auto_delete_cmr_days"
            case isRecordingDisclaimer = "recording_disclaimer"
            case isAskParticipantsToConsentDisclaimer = "ask_participants_to_consent_disclaimer"
            case isAskHostToConfirmDisclaimer = "ask_host_to_confirm_disclaimer"
            case recordingPasswordRequirement = "recording_password_requirement"
            case ipAddressAccessControl = "ip_address_access_control"
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.isLocalRecording = try values.decodeIfPresent(Bool.self, forKey: .isLocalRecording)
            self.isCloudRecording = try values.decodeIfPresent(Bool.self, forKey: .isCloudRecording) ?? false
            self.isRecordSpeakerView = try values.decodeIfPresent(Bool.self, forKey: .isRecordSpeakerView) ?? false
            self.isRecordGalleryView = try values.decodeIfPresent(Bool.self, forKey: .isRecordGalleryView) ?? false
            self.isRecordAudioFile = try values.decodeIfPresent(Bool.self, forKey: .isRecordAudioFile) ?? false
            self.isSaveChatText = try values.decodeIfPresent(Bool.self, forKey: .isSaveChatText) ?? false
            self.isShowTimestamp = try values.decodeIfPresent(Bool.self, forKey: .isShowTimestamp) ?? false
            self.isRecordingAudioTranscript = try values.decodeIfPresent(Bool.self, forKey: .isRecordingAudioTranscript)
            self.autoRecording = try values.decodeIfPresent(AutoRecording.self, forKey: .autoRecording)
            self.isHostPauseStopRecording = try values.decodeIfPresent(Bool.self, forKey: .isHostPauseStopRecording) ?? false
            self.autoDeleteCmr = try values.decodeIfPresent(Bool.self, forKey: .autoDeleteCmr) ?? false
            self.autoDeleteCmrDays = try values.decodeIfPresent(Int.self, forKey: .autoDeleteCmrDays)
            self.isRecordingDisclaimer = try values.decodeIfPresent(Bool.self, forKey: .isRecordingDisclaimer)
            self.isAskParticipantsToConsentDisclaimer = try values.decodeIfPresent(Bool.self, forKey: .isAskParticipantsToConsentDisclaimer)
            self.isAskHostToConfirmDisclaimer = try values.decodeIfPresent(Bool.self, forKey: .isAskHostToConfirmDisclaimer)
            self.recordingPasswordRequirement = try values.decodeIfPresent(RecordingPasswordRequirement.self, forKey: .recordingPasswordRequirement)
            self.ipAddressAccessControl = try values.decodeIfPresent(IpAddressAccessControl.self, forKey: .ipAddressAccessControl)
        }
    }

    /// Telephony update settings: Meeting settings
    public struct Telephony: Codable {
        /// Third party audio conference.
        public var isThirdPartyAudio: Bool?
        /// Third party audio conference info.
        public var audioConferenceInfo: String?
        /// Show the international numbers link on the invitation email.
        public var isShowInternationalNumbersLink: Bool?
        /// Indicates where most of the participants call into or call from during a meeting.
        public var telephonyRegions: TelephonyRegions?

        /// Indicates where most of the participants call into or call from during a meeting.
        public struct TelephonyRegions: Codable {
            /// The account's selected telephony regions that indicate where most participants call into or call from during a meeting.
            public var selectionValues: String?

            public init(selectionValues: String? = nil) {
                self.selectionValues = selectionValues
            }

            private enum CodingKeys: String, CodingKey {
                case selectionValues = "selection_values"
            }
        }

        public init(isThirdPartyAudio: Bool? = nil, audioConferenceInfo: String? = nil, isShowInternationalNumbersLink: Bool? = nil, telephonyRegions: TelephonyRegions? = nil) {
            self.isThirdPartyAudio = isThirdPartyAudio
            self.audioConferenceInfo = audioConferenceInfo
            self.isShowInternationalNumbersLink = isShowInternationalNumbersLink
            self.telephonyRegions = telephonyRegions
        }

        private enum CodingKeys: String, CodingKey {
            case isThirdPartyAudio = "third_party_audio"
            case audioConferenceInfo = "audio_conference_info"
            case isShowInternationalNumbersLink = "show_international_numbers_link"
            case telephonyRegions = "telephony_regions"
        }
    }

    /// User settings: Feature settings
    public struct Feature: Codable {
        /// Set a user's meeting capacity. User's meeting capacity denotes the maximum number of participants that can join a meeting scheduled by the user.
        public var meetingCapacity: Int?
        /// Enable [large meeting](https://support.zoom.us/hc/en-us/articles/201362823-What-is-a-Large-Meeting-) feature for the user.
        public var isLargeMeeting: Bool?
        /// Set the meeting capacity for the user if the user has **Large meeting** feature enabled. The value for the field can be either 500 or 1000.
        public var largeMeetingCapacity: Int?
        /// Enable Webinar feature for the user.
        public var isWebinar: Bool?
        /// Set the Webinar capacity for a user who has the Webinar feature enabled. The value of this field can be 100, 500, 1000, 3000, 5000 or 10000.
        public var webinarCapacity: Int?
        /// Whether to enable the Zoom Events feature for the user.
        public var isZoomEvents: Bool?
        /// The user's Zoom Events plan capacity: `500`, `1000`, `3000`, `5000`, `10000`, `20000`, `30000`, or `50000`.
        public var zoomEventsCapacity: Int?
        /// Zoom phone feature.
        public var isZoomPhone: Bool?
        /// The user's assigned [Concurrent Meeting](https://support.zoom.us/hc/en-us/articles/206122046) type: 
        /// * `Basic` 
        /// * `Plus` 
        /// * `None` 
        /// 
        ///  **Note:** This feature requires a Concurrent Meeting Basic or Plus plan subscription.
        public var concurrentMeeting: ConcurrentMeeting?

        /// The user's assigned [Concurrent Meeting](https://support.zoom.us/hc/en-us/articles/206122046) type: 
        /// * `Basic` 
        /// * `Plus` 
        /// * `None` 
        /// 
        ///  **Note:** This feature requires a Concurrent Meeting Basic or Plus plan subscription.
        public enum ConcurrentMeeting: String, Codable, CaseIterable {
            case basic = "Basic"
            case plus = "Plus"
            case `none` = "None"
        }

        public init(meetingCapacity: Int? = nil, isLargeMeeting: Bool? = nil, largeMeetingCapacity: Int? = nil, isWebinar: Bool? = nil, webinarCapacity: Int? = nil, isZoomEvents: Bool? = nil, zoomEventsCapacity: Int? = nil, isZoomPhone: Bool? = nil, concurrentMeeting: ConcurrentMeeting? = nil) {
            self.meetingCapacity = meetingCapacity
            self.isLargeMeeting = isLargeMeeting
            self.largeMeetingCapacity = largeMeetingCapacity
            self.isWebinar = isWebinar
            self.webinarCapacity = webinarCapacity
            self.isZoomEvents = isZoomEvents
            self.zoomEventsCapacity = zoomEventsCapacity
            self.isZoomPhone = isZoomPhone
            self.concurrentMeeting = concurrentMeeting
        }

        private enum CodingKeys: String, CodingKey {
            case meetingCapacity = "meeting_capacity"
            case isLargeMeeting = "large_meeting"
            case largeMeetingCapacity = "large_meeting_capacity"
            case isWebinar = "webinar"
            case webinarCapacity = "webinar_capacity"
            case isZoomEvents = "zoom_events"
            case zoomEventsCapacity = "zoom_events_capacity"
            case isZoomPhone = "zoom_phone"
            case concurrentMeeting = "concurrent_meeting"
        }
    }

    /// User settings: TSP settings
    ///
    /// Account Settings: TSP.
    public struct Tsp: Codable {
        /// Call Out
        public var isCallOut: Bool?
        /// Call Out Countries/Regions
        public var callOutCountries: [[String: AnyJSON]]?
        /// Show international numbers link on the invitation email
        public var isShowInternationalNumbersLink: Bool?

        public init(isCallOut: Bool? = nil, callOutCountries: [[String: AnyJSON]]? = nil, isShowInternationalNumbersLink: Bool? = nil) {
            self.isCallOut = isCallOut
            self.callOutCountries = callOutCountries
            self.isShowInternationalNumbersLink = isShowInternationalNumbersLink
        }

        private enum CodingKeys: String, CodingKey {
            case isCallOut = "call_out"
            case callOutCountries = "call_out_countries"
            case isShowInternationalNumbersLink = "show_international_numbers_link"
        }
    }

    public struct Profile: Codable {
        public var recordingStorageLocation: RecordingStorageLocation?

        public struct RecordingStorageLocation: Codable {
            /// Users can choose the country to store their recorded content. Content can include meeting, webinar, and phone recordings, as well as voicemail, transcripts, and custom greeting prompts. See [Managing the Communications Content storage location](https://support.zoom.us/hc/en-us/articles/360050781131) for details.
            /// 
            /// Provide abbreviated country codes as the value for this field. See the [Countries abbreviation list](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries) for details.
            public var allowedValues: [String]?
            /// Abbreviated country code.
            public var value: String?

            public init(allowedValues: [String]? = nil, value: String? = nil) {
                self.allowedValues = allowedValues
                self.value = value
            }

            private enum CodingKeys: String, CodingKey {
                case allowedValues = "allowed_values"
                case value
            }
        }

        public init(recordingStorageLocation: RecordingStorageLocation? = nil) {
            self.recordingStorageLocation = recordingStorageLocation
        }

        private enum CodingKeys: String, CodingKey {
            case recordingStorageLocation = "recording_storage_location"
        }
    }

    public init(scheduleMeeting: ScheduleMeeting? = nil, inMeeting: InMeeting? = nil, emailNotification: EmailNotification? = nil, recording: Recording? = nil, telephony: Telephony? = nil, feature: Feature? = nil, tsp: Tsp? = nil, profile: Profile? = nil) {
        self.scheduleMeeting = scheduleMeeting
        self.inMeeting = inMeeting
        self.emailNotification = emailNotification
        self.recording = recording
        self.telephony = telephony
        self.feature = feature
        self.tsp = tsp
        self.profile = profile
    }

    private enum CodingKeys: String, CodingKey {
        case scheduleMeeting = "schedule_meeting"
        case inMeeting = "in_meeting"
        case emailNotification = "email_notification"
        case recording
        case telephony
        case feature
        case tsp
        case profile
    }
}

public struct UserPermissions: Codable {
    /// List of user permissions.
    public var permissions: [String]?

    public init(permissions: [String]? = nil) {
        self.permissions = permissions
    }
}

/// User settings: Meeting settings
public struct UserSettingsScheduleMeeting: Codable {
    /// Start meetings with host video on.
    public var isHostVideo: Bool?
    /// Start meetings with participants video on.
    public var isParticipantsVideo: Bool?
    /// Determine how participants can join the audio portion of the meeting:<br>`both` - Telephony and VoIP.<br>`telephony` - Audio PSTN telephony only.<br>`voip` - VoIP only.<br>`thirdParty` - Third party audio conference.
    public var audioType: AudioType?
    /// Join the meeting before host arrives.
    public var isJoinBeforeHost: Bool?
    /// Require a passcode for personal meetings if attendees can join before host.
    public var isForcePmiJbhPassword: Bool?
    /// Generate and require passcode for participants joining by phone.
    public var isPstnPasswordProtected: Bool?
    /// Use Personal Meeting ID (PMI) when scheduling a meeting
    public var usePmiForScheduledMeetings: Bool?
    /// Use Personal Meeting ID (PMI) when starting an instant meeting
    public var usePmiForInstantMeetings: Bool?
    /// Require a passcode when scheduling new meetings.This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
    public var requirePasswordForSchedulingNewMeetings: Bool?
    /// Require a passcode for meetings which have already been scheduled
    public var requirePasswordForScheduledMeetings: Bool?
    /// Passcode for already scheduled meetings
    public var defaultPasswordForScheduledMeetings: String?
    /// Require a passcode for instant meetings. If you use PMI for your instant meetings, this option will be disabled. This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
    public var requirePasswordForInstantMeetings: Bool?
    /// Require a passcode for Personal Meeting ID (PMI). This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
    public var requirePasswordForPmiMeetings: RequirePasswordForPmiMeetings?
    /// PMI passcode
    public var pmiPassword: String?
    /// If the value is set to `true`, the meeting passcode will be encrypted and included in the join meeting link to allow participants to join with just one click without having to enter the passcode.
    public var isEmbedPasswordInJoinLink: Bool?
    /// Account wide meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
    public var meetingPasswordRequirement: MeetingPasswordRequirement?
    /// Personal Meeting Setting.<br><br>
    /// `true`: Indicates that the **"Enable Personal Meeting ID"** setting is turned on. Users can choose to use personal meeting ID for their meetings. <br><br>
    /// `false`: Indicates that the **"Enable Personal Meeting ID"** setting is [turned off](https://support.zoom.us/hc/en-us/articles/201362843-Personal-meeting-ID-PMI-and-personal-link#h_aa0335c8-3b06-41bc-bc1f-a8b84ef17f2a). If this setting is disabled, meetings that were scheduled with PMI will be invalid. Scheduled meetings will need to be manually updated.
    /// For Zoom Phone only:If a user has been assigned a desk phone, **"Elevate to Zoom Meeting"** on desk phone will be disabled.
    public var isPersonalMeeting: Bool?

    /// Determine how participants can join the audio portion of the meeting:<br>`both` - Telephony and VoIP.<br>`telephony` - Audio PSTN telephony only.<br>`voip` - VoIP only.<br>`thirdParty` - Third party audio conference.
    public enum AudioType: String, Codable, CaseIterable {
        case both
        case telephony
        case voip
        case thirdParty
    }

    /// Require a passcode for Personal Meeting ID (PMI). This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
    public enum RequirePasswordForPmiMeetings: String, Codable, CaseIterable {
        case jbhOnly = "jbh_only"
        case all
        case `none`
    }

    /// Account wide meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
    public struct MeetingPasswordRequirement: Codable {
        /// The minimum length that the meeting/webinar passcode needs to have.
        public var length: Int?
        /// If set to `true`, the passcode must contain at least 1 letter (such as a,b,c...).
        public var haveLetter: Bool?
        /// If set to `true`, the passcode must contain at least 1 number (such as 1,2,3...).
        public var haveNumber: Bool?
        /// If set to `true`, the passcode must have at least 1 special character (!,@,#...).
        public var haveSpecialCharacter: Bool?
        /// If set to `true`, the passcode must only contain numbers and no other characters.
        public var onlyAllowNumeric: Bool?
        /// If set to `true`, the passcode must include both uppercase and lowercase characters.
        public var haveUpperAndLowerCharacters: Bool?
        public var consecutiveCharactersLength: Int?
        /// If set to `true`, users will be informed if the provided passcode is weak.
        public var isWeakEnhanceDetection: Bool?

        public init(length: Int? = nil, haveLetter: Bool? = nil, haveNumber: Bool? = nil, haveSpecialCharacter: Bool? = nil, onlyAllowNumeric: Bool? = nil, haveUpperAndLowerCharacters: Bool? = nil, consecutiveCharactersLength: Int? = nil, isWeakEnhanceDetection: Bool? = nil) {
            self.length = length
            self.haveLetter = haveLetter
            self.haveNumber = haveNumber
            self.haveSpecialCharacter = haveSpecialCharacter
            self.onlyAllowNumeric = onlyAllowNumeric
            self.haveUpperAndLowerCharacters = haveUpperAndLowerCharacters
            self.consecutiveCharactersLength = consecutiveCharactersLength
            self.isWeakEnhanceDetection = isWeakEnhanceDetection
        }

        private enum CodingKeys: String, CodingKey {
            case length
            case haveLetter = "have_letter"
            case haveNumber = "have_number"
            case haveSpecialCharacter = "have_special_character"
            case onlyAllowNumeric = "only_allow_numeric"
            case haveUpperAndLowerCharacters = "have_upper_and_lower_characters"
            case consecutiveCharactersLength = "consecutive_characters_length"
            case isWeakEnhanceDetection = "weak_enhance_detection"
        }
    }

    public init(isHostVideo: Bool? = nil, isParticipantsVideo: Bool? = nil, audioType: AudioType? = nil, isJoinBeforeHost: Bool? = nil, isForcePmiJbhPassword: Bool? = nil, isPstnPasswordProtected: Bool? = nil, usePmiForScheduledMeetings: Bool? = nil, usePmiForInstantMeetings: Bool? = nil, requirePasswordForSchedulingNewMeetings: Bool? = nil, requirePasswordForScheduledMeetings: Bool? = nil, defaultPasswordForScheduledMeetings: String? = nil, requirePasswordForInstantMeetings: Bool? = nil, requirePasswordForPmiMeetings: RequirePasswordForPmiMeetings? = nil, pmiPassword: String? = nil, isEmbedPasswordInJoinLink: Bool? = nil, meetingPasswordRequirement: MeetingPasswordRequirement? = nil, isPersonalMeeting: Bool? = nil) {
        self.isHostVideo = isHostVideo
        self.isParticipantsVideo = isParticipantsVideo
        self.audioType = audioType
        self.isJoinBeforeHost = isJoinBeforeHost
        self.isForcePmiJbhPassword = isForcePmiJbhPassword
        self.isPstnPasswordProtected = isPstnPasswordProtected
        self.usePmiForScheduledMeetings = usePmiForScheduledMeetings
        self.usePmiForInstantMeetings = usePmiForInstantMeetings
        self.requirePasswordForSchedulingNewMeetings = requirePasswordForSchedulingNewMeetings
        self.requirePasswordForScheduledMeetings = requirePasswordForScheduledMeetings
        self.defaultPasswordForScheduledMeetings = defaultPasswordForScheduledMeetings
        self.requirePasswordForInstantMeetings = requirePasswordForInstantMeetings
        self.requirePasswordForPmiMeetings = requirePasswordForPmiMeetings
        self.pmiPassword = pmiPassword
        self.isEmbedPasswordInJoinLink = isEmbedPasswordInJoinLink
        self.meetingPasswordRequirement = meetingPasswordRequirement
        self.isPersonalMeeting = isPersonalMeeting
    }

    private enum CodingKeys: String, CodingKey {
        case isHostVideo = "host_video"
        case isParticipantsVideo = "participants_video"
        case audioType = "audio_type"
        case isJoinBeforeHost = "join_before_host"
        case isForcePmiJbhPassword = "force_pmi_jbh_password"
        case isPstnPasswordProtected = "pstn_password_protected"
        case usePmiForScheduledMeetings = "use_pmi_for_scheduled_meetings"
        case usePmiForInstantMeetings = "use_pmi_for_instant_meetings"
        case requirePasswordForSchedulingNewMeetings = "require_password_for_scheduling_new_meetings"
        case requirePasswordForScheduledMeetings = "require_password_for_scheduled_meetings"
        case defaultPasswordForScheduledMeetings = "default_password_for_scheduled_meetings"
        case requirePasswordForInstantMeetings = "require_password_for_instant_meetings"
        case requirePasswordForPmiMeetings = "require_password_for_pmi_meetings"
        case pmiPassword = "pmi_password"
        case isEmbedPasswordInJoinLink = "embed_password_in_join_link"
        case meetingPasswordRequirement = "meeting_password_requirement"
        case isPersonalMeeting = "personal_meeting"
    }
}

/// The H.323/SIP device object.
public struct Device: Codable {
    /// Device name.
    public var name: String
    /// Device protocol:<br>`H.323` - H.323.<br>`SIP` - SIP.
    public var `protocol`: `Protocol`
    /// Device IP.
    public var ip: String
    /// Device encryption:<br>`auto` - auto.<br>`yes` - yes.<br>`no` - no.
    public var encryption: Encryption

    /// Device protocol:<br>`H.323` - H.323.<br>`SIP` - SIP.
    public enum `Protocol`: String, Codable, CaseIterable {
        case h323 = "H.323"
        case sip = "SIP"
    }

    /// Device encryption:<br>`auto` - auto.<br>`yes` - yes.<br>`no` - no.
    public enum Encryption: String, Codable, CaseIterable {
        case auto
        case yes
        case no
    }

    public init(name: String, `protocol`: `Protocol`, ip: String, encryption: Encryption) {
        self.name = name
        self.protocol = `protocol`
        self.ip = ip
        self.encryption = encryption
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case `protocol` = "protocol"
        case ip
        case encryption
    }
}

/// H.323/SIP Device List
///
/// List of H.323/SIP Devices.
public struct DeviceList: Codable {
    /// The number of pages returned for the request made.
    public var pageCount: Int?
    /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
    public var pageNumber: Int?
    /// The number of records returned with a single API call.
    public var pageSize: Int?
    /// The total number of all the records available across pages.
    public var totalRecords: Int?
    /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
    public var nextPageToken: String?
    /// List of H.323/SIP Device objects.
    public var devices: [Device]?

    public struct Device: Codable {
        /// Device ID.
        public var id: String?
        /// Device name.
        public var name: String
        /// Device protocol:<br>`H.323` - H.323.<br>`SIP` - SIP.
        public var `protocol`: `Protocol`
        /// Device IP.
        public var ip: String
        /// Device encryption:<br>`auto` - auto.<br>`yes` - yes.<br>`no` - no.
        public var encryption: Encryption

        /// Device protocol:<br>`H.323` - H.323.<br>`SIP` - SIP.
        public enum `Protocol`: String, Codable, CaseIterable {
            case h323 = "H.323"
            case sip = "SIP"
        }

        /// Device encryption:<br>`auto` - auto.<br>`yes` - yes.<br>`no` - no.
        public enum Encryption: String, Codable, CaseIterable {
            case auto
            case yes
            case no
        }

        public init(id: String? = nil, name: String, `protocol`: `Protocol`, ip: String, encryption: Encryption) {
            self.id = id
            self.name = name
            self.protocol = `protocol`
            self.ip = ip
            self.encryption = encryption
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.name = try values.decode(String.self, forKey: "name")
            self.protocol = try `Protocol`(from: decoder)
            self.ip = try values.decode(String.self, forKey: "ip")
            self.encryption = try Encryption(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encode(name, forKey: "name")
            try values.encode(`protocol`, forKey: "protocol")
            try values.encode(ip, forKey: "ip")
            try values.encode(encryption, forKey: "encryption")
        }
    }

    public init(pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil, devices: [Device]? = nil) {
        self.pageCount = pageCount
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.totalRecords = totalRecords
        self.nextPageToken = nextPageToken
        self.devices = devices
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.pageCount = try values.decodeIfPresent(Int.self, forKey: "page_count")
        self.pageNumber = try values.decodeIfPresent(Int.self, forKey: "page_number")
        self.pageSize = try values.decodeIfPresent(Int.self, forKey: "page_size")
        self.totalRecords = try values.decodeIfPresent(Int.self, forKey: "total_records")
        self.nextPageToken = try values.decodeIfPresent(String.self, forKey: "next_page_token")
        self.devices = try values.decodeIfPresent([Device].self, forKey: "devices")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(pageCount, forKey: "page_count")
        try values.encodeIfPresent(pageNumber, forKey: "page_number")
        try values.encodeIfPresent(pageSize, forKey: "page_size")
        try values.encodeIfPresent(totalRecords, forKey: "total_records")
        try values.encodeIfPresent(nextPageToken, forKey: "next_page_token")
        try values.encodeIfPresent(devices, forKey: "devices")
    }
}

/// Base webinar object for sessions.
public struct CreateWebinar: Codable {
    /// Webinar topic.
    public var topic: String?
    /// Webinar Types:<br>`5` - Webinar.<br>`6` - Recurring webinar with no fixed time.<br>`9` - Recurring webinar with a fixed time.
    public var type: Int?
    /// Webinar start time. We support two formats for `start_time` - local time and GMT.<br> 
    /// 
    /// To set time as GMT the format should be `yyyy-MM-dd`T`HH:mm:ssZ`.
    /// 
    /// To set time using a specific timezone, use `yyyy-MM-dd`T`HH:mm:ss` format and specify the timezone [ID](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#timezones) in the `timezone` field OR leave it blank and the timezone set on your Zoom account will be used. You can also set the time as UTC as the timezone field.
    /// 
    /// The `start_time` should only be used for scheduled and / or recurring webinars with fixed time.
    public var startTime: Date?
    /// Webinar duration (minutes). Used for scheduled webinars only.
    public var duration: Int?
    /// Time zone to format start_time. For example, "America/Los_Angeles". For scheduled meetings only. Please reference our [timezone](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#timezones) list for supported time zones and their formats.
    public var timezone: String?
    /// Webinar passcode. Passcode may only contain the following characters: [a-z A-Z 0-9 @ - _ * !]. Max of 10 characters.
    /// 
    /// If "Require a passcode when scheduling new meetings" setting has been **enabled** **and** [locked](https://support.zoom.us/hc/en-us/articles/115005269866-Using-Tiered-Settings#locked) for the user, the passcode field will be autogenerated for the Webinar in the response even if it is not provided in the API request. <br><br>
    /// 
    /// **Note:** If the account owner or the admin has configured [minimum passcode requirement settings](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604), the passcode value provided here must meet those requirements. <br><br>If the requirements are enabled, you can view those requirements by calling [Get Account Settings](https://marketplace.zoom.us/docs/api-reference/zoom-api/accounts/accountsettings) API.
    public var password: String?
    /// Webinar description.
    public var agenda: String?
    /// Tracking fields
    public var trackingFields: [TrackingField]?
    /// Recurrence Webinar
    ///
    /// Recurrence object. Use this object only for a webinar of type `9` i.e., a recurring webinar with fixed time.
    public var recurrence: Recurrence?
    /// Create Webinar settings.
    public var settings: Settings?
    /// The webinar template ID with which to schedule a webinar using a [webinar template](https://support.zoom.us/hc/en-us/articles/115001079746-Webinar-Templates). For a list of webinar templates, use the [**List webinar templates**](https://marketplace.zoom.us/docs/api-reference/zoom-api/webinars/listwebinartemplates) API.
    public var templateID: String?

    public struct TrackingField: Codable {
        /// Tracking fields type
        public var field: String
        /// Tracking fields value
        public var value: String?

        public init(field: String, value: String? = nil) {
            self.field = field
            self.value = value
        }
    }

    /// Recurrence Webinar
    ///
    /// Recurrence object. Use this object only for a webinar of type `9` i.e., a recurring webinar with fixed time.
    public struct Recurrence: Codable {
        /// Recurrence webinar types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
        public var type: Int
        /// Define the interval at which the webinar should recur. For instance, if you would like to schedule a Webinar that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
        /// 
        /// For a daily webinar, the maximum interval you can set is `90` days. For a weekly webinar, the maximum interval that you can set is `12` weeks. For a monthly webinar, the maximum interval that you can set is `3` months.
        public var repeatInterval: Int?
        /// Use this field **only if you're scheduling a recurring webinar of type** `2` to state which day(s) of the week the webinar should repeat. <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the Webinar should recur on Sunday, provide `"1"` as the value of this field.  <br><br> **Note:** If you would like the webinar to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the Webinar should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
        /// 
        /// <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public var weeklyDays: String?
        /// Use this field **only if you're scheduling a recurring webinar of type** `3` to state which day in a month, the webinar should recur. The value range is from 1 to 31.
        /// 
        /// For instance, if you would like the webinar to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the webinar to recur once every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
        public var monthlyDay: Int?
        /// Use this field **only if you're scheduling a recurring webinar of type** `3` to state the week of the month when the webinar should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the webinar should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
        public var monthlyWeek: Int?
        /// Use this field **only if you're scheduling a recurring webinar of type** `3` to state a specific day in a week when the monthly webinar should recur. To use this field, you must also use the `monthly_week` field. <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public var monthlyWeekDay: Int?
        /// Select how many times the webinar will recur before it is canceled. (Cannot be used with "end_date_time".)
        public var endTimes: Int?
        /// Select a date when the webinar will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
        public var endDateTime: Date?

        public init(type: Int, repeatInterval: Int? = nil, weeklyDays: String? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
            self.type = type
            self.repeatInterval = repeatInterval
            self.weeklyDays = weeklyDays
            self.monthlyDay = monthlyDay
            self.monthlyWeek = monthlyWeek
            self.monthlyWeekDay = monthlyWeekDay
            self.endTimes = endTimes
            self.endDateTime = endDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case repeatInterval = "repeat_interval"
            case weeklyDays = "weekly_days"
            case monthlyDay = "monthly_day"
            case monthlyWeek = "monthly_week"
            case monthlyWeekDay = "monthly_week_day"
            case endTimes = "end_times"
            case endDateTime = "end_date_time"
        }
    }

    /// Create Webinar settings.
    public struct Settings: Codable {
        /// Start video when host joins webinar.
        public var isHostVideo: Bool?
        /// Start video when panelists join webinar.
        public var isPanelistsVideo: Bool?
        /// Enable practice session.
        public var isPracticeSession: Bool
        /// Default to HD video.
        public var isHdVideo: Bool
        /// Whether HD video for attendees is enabled. This value defaults to `false`.
        public var isHdVideoForAttendees: Bool
        /// Whether to always send 1080p video to attendees. This value defaults to `false`.
        public var isSend1080pVideoToAttendees: Bool
        /// The default value is `2`. To enable registration required, set the approval type to `0` or `1`.  Values include:<br>
        /// 
        /// `0` - Automatically approve.<br>`1` - Manually approve.<br>`2` - No registration required.
        public var approvalType: Int?
        /// Registration types. Only used for recurring webinars with a fixed time.<br>`1` - Attendees register once and can attend any of the webinar sessions.<br>`2` - Attendees need to register for each session in order to attend.<br>`3` - Attendees register once and can choose one or more sessions to attend.
        public var registrationType: Int?
        /// Determine how participants can join the audio portion of the meeting.
        public var audio: Audio?
        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public var autoRecording: AutoRecording?
        /// Only signed-in users can join this meeting. 
        /// 
        /// **This field is deprecated and will not be supported in future.** <br><br> Instead of this field, use the "meeting_authentication", "authentication_option" and/or "authentication_domains" fields to establish the authentication mechanism for this Webinar.
        public var enforceLogin: Bool?
        /// Only signed-in users with specified domains can join meetings.
        /// 
        /// **This field is deprecated and will not be supported in future.** <br><br> Instead of this field, use the "authentication_domains" field for this Webinar.
        public var enforceLoginDomains: String?
        /// Alternative host emails or IDs. Multiple values separated by comma.
        public var alternativeHosts: String?
        /// Close registration after event date.
        public var isCloseRegistration: Bool?
        /// Show social share buttons on the registration page.
        public var isShowShareButton: Bool?
        /// Allow attendees to join from multiple devices.
        public var allowMultipleDevices: Bool?
        /// Make the webinar on-demand
        public var isOnDemand: Bool
        /// List of global dial-in countries
        public var globalDialInCountries: [String]?
        /// Contact name for registration
        public var contactName: String?
        /// Contact email for registration
        public var contactEmail: String?
        /// Restrict number of registrants for a webinar. By default, it is set to `0`. A `0` value means that the restriction option is disabled. Provide a number higher than 0 to restrict the webinar registrants by the that number.
        public var registrantsRestrictNumber: Int?
        /// Zoom will open a survey page in attendees' browsers after leaving the webinar
        public var isPostWebinarSurvey: Bool?
        /// Survey url for post webinar survey
        public var surveyURL: String?
        /// Send email notifications to registrants about approval, cancellation, denial of the registration. The value of this field must be set to true in order to use the `registrants_confirmation_email` field.
        public var isRegistrantsEmailNotification: Bool?
        /// Only [authenticated](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) users can join meeting if the value of this field is set to `true`.
        public var isMeetingAuthentication: Bool?
        /// Specify the authentication type for users to join a Webinar with`meeting_authentication` setting set to `true`. The value of this field can be retrieved from the `id` field within `authentication_options` array in the response of [Get User Settings API](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings).
        public var authenticationOption: String?
        /// Meeting authentication domains. This option, allows you to specify the rule so that Zoom users, whose email address contains a certain domain, can join the Webinar. You can either provide multiple domains, using a comma in between and/or use a wildcard for listing domains.
        public var authenticationDomains: String?
        /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
        public var questionAndAnswer: QuestionAndAnswer?
        /// Set the email language to one of the following:
        /// `en-US`,`de-DE`,`es-ES`,`fr-FR`,`jp-JP`,`pt-PT`,`ru-RU`,`zh-CN`, `zh-TW`, `ko-KO`, `it-IT`, `vi-VN`.
        public var emailLanguage: String?
        /// * `true`: Send invitation email to panelists.
        /// 
        /// * `false`: Do not send invitation email to panelists.
        public var isPanelistsInvitationEmailNotification: Bool?
        /// Send reminder email to attendees and panelists.
        public var attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification?
        /// Send follow-up email to attendees.
        public var followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification?
        /// Send follow-up email to absentees.
        public var followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification?
        /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
        /// 
        /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
        public var languageInterpretation: LanguageInterpretation?

        /// Determine how participants can join the audio portion of the meeting.
        public enum Audio: String, Codable, CaseIterable {
            case both
            case telephony
            case voip
        }

        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public enum AutoRecording: String, Codable, CaseIterable {
            case local
            case cloud
            case `none`
        }

        /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
        public struct QuestionAndAnswer: Codable {
            /// * `true`: Enable [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
            /// 
            /// * `false`: Disable Q&A for webinar.
            public var enable: Bool?
            /// * `true`: Allow participants to send questions without providing their name to the host, co-host, and panelists..
            /// 
            /// * `false`: Do not allow anonymous questions.
            public var allowAnonymousQuestions: Bool?
            /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
            /// 
            /// * `only`: Attendees are able to view answered questions only.
            /// 
            /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
            public var answerQuestions: AnswerQuestions?
            /// * `true`: Attendees can click the thumbs up button to bring popular questions to the top of the Q&A window.
            /// 
            /// * `false`: Attendees can not click the thumbs up button on questions.
            public var attendeesCanUpvote: Bool?
            /// * `true`: Attendees can answer questions or leave a comment in the question thread.
            /// 
            /// * `false`: Attendees can not answer questions or leave a comment in the question thread
            public var attendeesCanComment: Bool?

            /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
            /// 
            /// * `only`: Attendees are able to view answered questions only.
            /// 
            /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
            public enum AnswerQuestions: String, Codable, CaseIterable {
                case only
                case all
            }

            public init(enable: Bool? = nil, allowAnonymousQuestions: Bool? = nil, answerQuestions: AnswerQuestions? = nil, attendeesCanUpvote: Bool? = nil, attendeesCanComment: Bool? = nil) {
                self.enable = enable
                self.allowAnonymousQuestions = allowAnonymousQuestions
                self.answerQuestions = answerQuestions
                self.attendeesCanUpvote = attendeesCanUpvote
                self.attendeesCanComment = attendeesCanComment
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case allowAnonymousQuestions = "allow_anonymous_questions"
                case answerQuestions = "answer_questions"
                case attendeesCanUpvote = "attendees_can_upvote"
                case attendeesCanComment = "attendees_can_comment"
            }
        }

        /// Send reminder email to attendees and panelists.
        public struct AttendeesAndPanelistsReminderEmailNotification: Codable {
            /// * `true`: Send reminder email to attendees and panelists.
            /// 
            /// * `false`: Do not send reminder email to attendees and panelists.
            public var enable: Bool?
            /// `0` - No plan.<br>`1` - Send 1 hour before webinar.<br>`2` - Send 1 day before webinar.<br>`3` - Send 1 hour and 1 day before webinar.<br>`4` - Send 1 week before webinar.<br>`5` - Send 1 hour and 1 week before webinar.<br>`6` - Send 1 day and 1 week before webinar.<br>`7` - Send 1 hour, 1 day and 1 week before webinar.
            public var type: Int?

            public init(enable: Bool? = nil, type: Int? = nil) {
                self.enable = enable
                self.type = type
            }
        }

        /// Send follow-up email to attendees.
        public struct FollowUpAttendeesEmailNotification: Codable {
            /// * `true`: Send follow-up email to attendees.
            /// 
            /// * `false`: Do not send follow-up email to attendees.
            public var enable: Bool?
            /// `0` - No plan.<br>`1` - Send 1 day after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
            public var type: Int?

            public init(enable: Bool? = nil, type: Int? = nil) {
                self.enable = enable
                self.type = type
            }
        }

        /// Send follow-up email to absentees.
        public struct FollowUpAbsenteesEmailNotification: Codable {
            /// * `true`: Send follow-up email to absentees.
            /// 
            /// * `false`: Do not send follow-up email to absentees.
            public var enable: Bool?
            /// `0` - No plan.<br>`1` - Send 1 days after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
            public var type: Int?

            public init(enable: Bool? = nil, type: Int? = nil) {
                self.enable = enable
                self.type = type
            }
        }

        /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
        /// 
        /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
        public struct LanguageInterpretation: Codable {
            /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the webinar.
            public var enable: Bool?
            /// Information about the webinar's language interpreters.
            public var interpreters: [Interpreter]?

            public struct Interpreter: Codable {
                /// The interpreter's email address.
                public var email: String?
                /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
                /// 
                /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
                public var languages: String?

                public init(email: String? = nil, languages: String? = nil) {
                    self.email = email
                    self.languages = languages
                }
            }

            public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
                self.enable = enable
                self.interpreters = interpreters
            }
        }

        public init(isHostVideo: Bool? = nil, isPanelistsVideo: Bool? = nil, isPracticeSession: Bool? = nil, isHdVideo: Bool? = nil, isHdVideoForAttendees: Bool? = nil, isSend1080pVideoToAttendees: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, enforceLogin: Bool? = nil, enforceLoginDomains: String? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, isOnDemand: Bool? = nil, globalDialInCountries: [String]? = nil, contactName: String? = nil, contactEmail: String? = nil, registrantsRestrictNumber: Int? = nil, isPostWebinarSurvey: Bool? = nil, surveyURL: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, questionAndAnswer: QuestionAndAnswer? = nil, emailLanguage: String? = nil, isPanelistsInvitationEmailNotification: Bool? = nil, attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification? = nil, followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification? = nil, followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification? = nil, languageInterpretation: LanguageInterpretation? = nil) {
            self.isHostVideo = isHostVideo
            self.isPanelistsVideo = isPanelistsVideo
            self.isPracticeSession = isPracticeSession ?? false
            self.isHdVideo = isHdVideo ?? false
            self.isHdVideoForAttendees = isHdVideoForAttendees ?? false
            self.isSend1080pVideoToAttendees = isSend1080pVideoToAttendees ?? false
            self.approvalType = approvalType
            self.registrationType = registrationType
            self.audio = audio
            self.autoRecording = autoRecording
            self.enforceLogin = enforceLogin
            self.enforceLoginDomains = enforceLoginDomains
            self.alternativeHosts = alternativeHosts
            self.isCloseRegistration = isCloseRegistration
            self.isShowShareButton = isShowShareButton
            self.allowMultipleDevices = allowMultipleDevices
            self.isOnDemand = isOnDemand ?? false
            self.globalDialInCountries = globalDialInCountries
            self.contactName = contactName
            self.contactEmail = contactEmail
            self.registrantsRestrictNumber = registrantsRestrictNumber
            self.isPostWebinarSurvey = isPostWebinarSurvey
            self.surveyURL = surveyURL
            self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
            self.isMeetingAuthentication = isMeetingAuthentication
            self.authenticationOption = authenticationOption
            self.authenticationDomains = authenticationDomains
            self.questionAndAnswer = questionAndAnswer
            self.emailLanguage = emailLanguage
            self.isPanelistsInvitationEmailNotification = isPanelistsInvitationEmailNotification
            self.attendeesAndPanelistsReminderEmailNotification = attendeesAndPanelistsReminderEmailNotification
            self.followUpAttendeesEmailNotification = followUpAttendeesEmailNotification
            self.followUpAbsenteesEmailNotification = followUpAbsenteesEmailNotification
            self.languageInterpretation = languageInterpretation
        }

        private enum CodingKeys: String, CodingKey {
            case isHostVideo = "host_video"
            case isPanelistsVideo = "panelists_video"
            case isPracticeSession = "practice_session"
            case isHdVideo = "hd_video"
            case isHdVideoForAttendees = "hd_video_for_attendees"
            case isSend1080pVideoToAttendees = "send_1080p_video_to_attendees"
            case approvalType = "approval_type"
            case registrationType = "registration_type"
            case audio
            case autoRecording = "auto_recording"
            case enforceLogin = "enforce_login"
            case enforceLoginDomains = "enforce_login_domains"
            case alternativeHosts = "alternative_hosts"
            case isCloseRegistration = "close_registration"
            case isShowShareButton = "show_share_button"
            case allowMultipleDevices = "allow_multiple_devices"
            case isOnDemand = "on_demand"
            case globalDialInCountries = "global_dial_in_countries"
            case contactName = "contact_name"
            case contactEmail = "contact_email"
            case registrantsRestrictNumber = "registrants_restrict_number"
            case isPostWebinarSurvey = "post_webinar_survey"
            case surveyURL = "survey_url"
            case isRegistrantsEmailNotification = "registrants_email_notification"
            case isMeetingAuthentication = "meeting_authentication"
            case authenticationOption = "authentication_option"
            case authenticationDomains = "authentication_domains"
            case questionAndAnswer = "question_and_answer"
            case emailLanguage = "email_language"
            case isPanelistsInvitationEmailNotification = "panelists_invitation_email_notification"
            case attendeesAndPanelistsReminderEmailNotification = "attendees_and_panelists_reminder_email_notification"
            case followUpAttendeesEmailNotification = "follow_up_attendees_email_notification"
            case followUpAbsenteesEmailNotification = "follow_up_absentees_email_notification"
            case languageInterpretation = "language_interpretation"
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.isHostVideo = try values.decodeIfPresent(Bool.self, forKey: .isHostVideo)
            self.isPanelistsVideo = try values.decodeIfPresent(Bool.self, forKey: .isPanelistsVideo)
            self.isPracticeSession = try values.decodeIfPresent(Bool.self, forKey: .isPracticeSession) ?? false
            self.isHdVideo = try values.decodeIfPresent(Bool.self, forKey: .isHdVideo) ?? false
            self.isHdVideoForAttendees = try values.decodeIfPresent(Bool.self, forKey: .isHdVideoForAttendees) ?? false
            self.isSend1080pVideoToAttendees = try values.decodeIfPresent(Bool.self, forKey: .isSend1080pVideoToAttendees) ?? false
            self.approvalType = try values.decodeIfPresent(Int.self, forKey: .approvalType)
            self.registrationType = try values.decodeIfPresent(Int.self, forKey: .registrationType)
            self.audio = try values.decodeIfPresent(Audio.self, forKey: .audio)
            self.autoRecording = try values.decodeIfPresent(AutoRecording.self, forKey: .autoRecording)
            self.enforceLogin = try values.decodeIfPresent(Bool.self, forKey: .enforceLogin)
            self.enforceLoginDomains = try values.decodeIfPresent(String.self, forKey: .enforceLoginDomains)
            self.alternativeHosts = try values.decodeIfPresent(String.self, forKey: .alternativeHosts)
            self.isCloseRegistration = try values.decodeIfPresent(Bool.self, forKey: .isCloseRegistration)
            self.isShowShareButton = try values.decodeIfPresent(Bool.self, forKey: .isShowShareButton)
            self.allowMultipleDevices = try values.decodeIfPresent(Bool.self, forKey: .allowMultipleDevices)
            self.isOnDemand = try values.decodeIfPresent(Bool.self, forKey: .isOnDemand) ?? false
            self.globalDialInCountries = try values.decodeIfPresent([String].self, forKey: .globalDialInCountries)
            self.contactName = try values.decodeIfPresent(String.self, forKey: .contactName)
            self.contactEmail = try values.decodeIfPresent(String.self, forKey: .contactEmail)
            self.registrantsRestrictNumber = try values.decodeIfPresent(Int.self, forKey: .registrantsRestrictNumber)
            self.isPostWebinarSurvey = try values.decodeIfPresent(Bool.self, forKey: .isPostWebinarSurvey)
            self.surveyURL = try values.decodeIfPresent(String.self, forKey: .surveyURL)
            self.isRegistrantsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsEmailNotification)
            self.isMeetingAuthentication = try values.decodeIfPresent(Bool.self, forKey: .isMeetingAuthentication)
            self.authenticationOption = try values.decodeIfPresent(String.self, forKey: .authenticationOption)
            self.authenticationDomains = try values.decodeIfPresent(String.self, forKey: .authenticationDomains)
            self.questionAndAnswer = try values.decodeIfPresent(QuestionAndAnswer.self, forKey: .questionAndAnswer)
            self.emailLanguage = try values.decodeIfPresent(String.self, forKey: .emailLanguage)
            self.isPanelistsInvitationEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isPanelistsInvitationEmailNotification)
            self.attendeesAndPanelistsReminderEmailNotification = try values.decodeIfPresent(AttendeesAndPanelistsReminderEmailNotification.self, forKey: .attendeesAndPanelistsReminderEmailNotification)
            self.followUpAttendeesEmailNotification = try values.decodeIfPresent(FollowUpAttendeesEmailNotification.self, forKey: .followUpAttendeesEmailNotification)
            self.followUpAbsenteesEmailNotification = try values.decodeIfPresent(FollowUpAbsenteesEmailNotification.self, forKey: .followUpAbsenteesEmailNotification)
            self.languageInterpretation = try values.decodeIfPresent(LanguageInterpretation.self, forKey: .languageInterpretation)
        }
    }

    public init(topic: String? = nil, type: Int? = nil, startTime: Date? = nil, duration: Int? = nil, timezone: String? = nil, password: String? = nil, agenda: String? = nil, trackingFields: [TrackingField]? = nil, recurrence: Recurrence? = nil, settings: Settings? = nil, templateID: String? = nil) {
        self.topic = topic
        self.type = type
        self.startTime = startTime
        self.duration = duration
        self.timezone = timezone
        self.password = password
        self.agenda = agenda
        self.trackingFields = trackingFields
        self.recurrence = recurrence
        self.settings = settings
        self.templateID = templateID
    }

    private enum CodingKeys: String, CodingKey {
        case topic
        case type
        case startTime = "start_time"
        case duration
        case timezone
        case password
        case agenda
        case trackingFields = "tracking_fields"
        case recurrence
        case settings
        case templateID = "template_id"
    }
}

/// Webinar registrant.
public struct WebinarRegistrant: Codable {
    /// The registrant's email address.
    public var email: String
    /// The registrant's status: 
    /// * `approved` — Registrant is approved. 
    /// * `denied` — Registrant is denied. 
    /// * `pending` — Registrant is waiting for approval.
    public var status: Status?
    /// The registrant's first name.
    public var firstName: String
    /// The registrant's last name.
    public var lastName: String?
    /// The registrant's address.
    public var address: String?
    /// The registrant's city.
    public var city: String?
    /// The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
    public var country: String?
    /// The registrant's ZIP or postal code.
    public var zip: String?
    /// The registrant's state or province.
    public var state: String?
    /// The registrant's phone number.
    public var phone: String?
    /// The registrant's industry.
    public var industry: String?
    /// The registrant's organization.
    public var org: String?
    /// The registrant's job title.
    public var jobTitle: String?
    /// The registrant's purchasing time frame: 
    /// * `Within a month` 
    /// * `1-3 months` 
    /// * `4-6 months` 
    /// * `More than 6 months` 
    /// * `No timeframe`
    public var purchasingTimeFrame: PurchasingTimeFrame?
    /// The registrant's role in the purchase process: 
    /// * `Decision Maker` 
    /// * `Evaluator/Recommender` 
    /// * `Influencer` 
    /// * `Not involved`
    public var roleInPurchaseProcess: RoleInPurchaseProcess?
    /// The registrant's number of employees: 
    /// * `1-20` 
    /// * `21-50` 
    /// * `51-100` 
    /// * `101-500` 
    /// * `500-1,000` 
    /// * `1,001-5,000` 
    /// * `5,001-10,000` 
    /// * `More than 10,000`
    public var noOfEmployees: NoOfEmployees?
    /// The registrant's questions and comments.
    public var comments: String?
    /// Information about custom questions.
    public var customQuestions: [CustomQuestion]?

    /// The registrant's status: 
    /// * `approved` — Registrant is approved. 
    /// * `denied` — Registrant is denied. 
    /// * `pending` — Registrant is waiting for approval.
    public enum Status: String, Codable, CaseIterable {
        case approved
        case denied
        case pending
    }

    /// The registrant's purchasing time frame: 
    /// * `Within a month` 
    /// * `1-3 months` 
    /// * `4-6 months` 
    /// * `More than 6 months` 
    /// * `No timeframe`
    public enum PurchasingTimeFrame: String, Codable, CaseIterable {
        case empty = ""
        case withinAMonth = "Within a month"
        case _13Months = "1-3 months"
        case _46Months = "4-6 months"
        case moreThan6Months = "More than 6 months"
        case noTimeframe = "No timeframe"
    }

    /// The registrant's role in the purchase process: 
    /// * `Decision Maker` 
    /// * `Evaluator/Recommender` 
    /// * `Influencer` 
    /// * `Not involved`
    public enum RoleInPurchaseProcess: String, Codable, CaseIterable {
        case empty = ""
        case decisionMaker = "Decision Maker"
        case evaluatorRecommender = "Evaluator/Recommender"
        case influencer = "Influencer"
        case notInvolved = "Not involved"
    }

    /// The registrant's number of employees: 
    /// * `1-20` 
    /// * `21-50` 
    /// * `51-100` 
    /// * `101-500` 
    /// * `500-1,000` 
    /// * `1,001-5,000` 
    /// * `5,001-10,000` 
    /// * `More than 10,000`
    public enum NoOfEmployees: String, Codable, CaseIterable {
        case empty = ""
        case _120 = "1-20"
        case _2150 = "21-50"
        case _51100 = "51-100"
        case _101500 = "101-500"
        case _5001000 = "500-1,000"
        case _10015000 = "1,001-5,000"
        case _500110000 = "5,001-10,000"
        case moreThan10000 = "More than 10,000"
    }

    /// Information about custom questions.
    public struct CustomQuestion: Codable {
        /// The title of the custom question.
        public var title: String?
        /// The custom question's response value. This has a limit of 128 characters.
        public var value: String?

        public init(title: String? = nil, value: String? = nil) {
            self.title = title
            self.value = value
        }
    }

    public init(email: String, status: Status? = nil, firstName: String, lastName: String? = nil, address: String? = nil, city: String? = nil, country: String? = nil, zip: String? = nil, state: String? = nil, phone: String? = nil, industry: String? = nil, org: String? = nil, jobTitle: String? = nil, purchasingTimeFrame: PurchasingTimeFrame? = nil, roleInPurchaseProcess: RoleInPurchaseProcess? = nil, noOfEmployees: NoOfEmployees? = nil, comments: String? = nil, customQuestions: [CustomQuestion]? = nil) {
        self.email = email
        self.status = status
        self.firstName = firstName
        self.lastName = lastName
        self.address = address
        self.city = city
        self.country = country
        self.zip = zip
        self.state = state
        self.phone = phone
        self.industry = industry
        self.org = org
        self.jobTitle = jobTitle
        self.purchasingTimeFrame = purchasingTimeFrame
        self.roleInPurchaseProcess = roleInPurchaseProcess
        self.noOfEmployees = noOfEmployees
        self.comments = comments
        self.customQuestions = customQuestions
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.email = try values.decode(String.self, forKey: "email")
        self.status = try Status(from: decoder)
        self.firstName = try values.decode(String.self, forKey: "first_name")
        self.lastName = try values.decodeIfPresent(String.self, forKey: "last_name")
        self.address = try values.decodeIfPresent(String.self, forKey: "address")
        self.city = try values.decodeIfPresent(String.self, forKey: "city")
        self.country = try values.decodeIfPresent(String.self, forKey: "country")
        self.zip = try values.decodeIfPresent(String.self, forKey: "zip")
        self.state = try values.decodeIfPresent(String.self, forKey: "state")
        self.phone = try values.decodeIfPresent(String.self, forKey: "phone")
        self.industry = try values.decodeIfPresent(String.self, forKey: "industry")
        self.org = try values.decodeIfPresent(String.self, forKey: "org")
        self.jobTitle = try values.decodeIfPresent(String.self, forKey: "job_title")
        self.purchasingTimeFrame = try PurchasingTimeFrame(from: decoder)
        self.roleInPurchaseProcess = try RoleInPurchaseProcess(from: decoder)
        self.noOfEmployees = try NoOfEmployees(from: decoder)
        self.comments = try values.decodeIfPresent(String.self, forKey: "comments")
        self.customQuestions = try values.decodeIfPresent([CustomQuestion].self, forKey: "custom_questions")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(email, forKey: "email")
        try values.encodeIfPresent(status, forKey: "status")
        try values.encode(firstName, forKey: "first_name")
        try values.encodeIfPresent(lastName, forKey: "last_name")
        try values.encodeIfPresent(address, forKey: "address")
        try values.encodeIfPresent(city, forKey: "city")
        try values.encodeIfPresent(country, forKey: "country")
        try values.encodeIfPresent(zip, forKey: "zip")
        try values.encodeIfPresent(state, forKey: "state")
        try values.encodeIfPresent(phone, forKey: "phone")
        try values.encodeIfPresent(industry, forKey: "industry")
        try values.encodeIfPresent(org, forKey: "org")
        try values.encodeIfPresent(jobTitle, forKey: "job_title")
        try values.encodeIfPresent(purchasingTimeFrame, forKey: "purchasing_time_frame")
        try values.encodeIfPresent(roleInPurchaseProcess, forKey: "role_in_purchase_process")
        try values.encodeIfPresent(noOfEmployees, forKey: "no_of_employees")
        try values.encodeIfPresent(comments, forKey: "comments")
        try values.encodeIfPresent(customQuestions, forKey: "custom_questions")
    }
}

/// Webinar object.
public struct WebinarInfo: Codable {
    /// Webinar topic.
    public var topic: String?
    /// Webinar Types:<br>`5` - Webinar.<br>`6` - Recurring webinar with no fixed time.<br>`9` - Recurring webinar with a fixed time.
    public var type: Int?
    /// Webinar start time in GMT/UTC.
    public var startTime: Date?
    /// Webinar duration.
    public var duration: Int?
    /// Time zone to format start_time.
    public var timezone: String?
    /// Webinar agenda.
    public var agenda: String?
    /// Create time.
    public var createdAt: Date?
    /// <br><aside>The <code>start_url</code> of a Webinar is a URL using which a host or an alternative host can start the Webinar. This URL should only be used by the host of the meeting and should not be shared with anyone other than the host of the Webinar. 
    /// 
    /// The expiration time for the <code>start_url</code> field listed in the response of [Create a Webinar API](https://marketplace.zoom.us/docs/api-reference/zoom-api/webinars/webinarcreate) is two hours for all regular users. 
    /// 	
    /// For users created using the <code>custCreate</code> option via the [Create Users](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usercreate) API, the expiration time of the <code>start_url</code> field is 90 days.
    /// 	
    /// For security reasons, to retrieve the latest value for the <code>start_url</code> field programmatically (after expiry), you must call the [Retrieve a Webinar API](https://marketplace.zoom.us/docs/api-reference/zoom-api/webinars/webinar) and refer to the value of the <code>start_url</code> field in the response.</aside><br><br><br>
    public var startURL: String?
    /// URL to join the Webinar. This URL should only be shared with the users who should be invited to the Webinar.
    public var joinURL: String?
    /// Tracking fields
    public var trackingFields: [TrackingField]?
    /// Array of occurrence objects.
    public var occurrences: [Occurrence]?
    /// Webinar settings.
    public var settings: Settings?
    /// Recurrence Webinar
    ///
    /// Recurrence object. Use this object only for a webinar of type `9` i.e., a recurring webinar with fixed time.
    public var recurrence: Recurrence?
    /// Webinar passcode. 
    /// 
    /// If "Require a passcode when scheduling new meetings" setting has been **enabled** **and** [locked](https://support.zoom.us/hc/en-us/articles/115005269866-Using-Tiered-Settings#locked) for the user, the passcode field will be autogenerated for the Webinar in the response even if it is not provided in the API request. <br><br>
    /// **Note:** If the account owner or the admin has configured [minimum passcode requirement settings](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604), the passcode value provided here must meet those requirements. <br><br>If the requirements are enabled, you can view those requirements by calling either the [Get User Settings API](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings) or the  [Get Account Settings](https://marketplace.zoom.us/docs/api-reference/zoom-api/accounts/accountsettings) API.
    public var password: String?

    public struct TrackingField: Codable {
        /// Tracking fields type
        public var field: String?
        /// Tracking fields value
        public var value: String?

        public init(field: String? = nil, value: String? = nil) {
            self.field = field
            self.value = value
        }
    }

    /// Occurrence object. This object is only returned for Recurring Webinars.
    public struct Occurrence: Codable {
        /// Occurrence ID: Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences.
        public var occurrenceID: String?
        /// Start time.
        public var startTime: Date?
        /// Duration.
        public var duration: Int?
        /// Occurrence status.
        public var status: String?

        public init(occurrenceID: String? = nil, startTime: Date? = nil, duration: Int? = nil, status: String? = nil) {
            self.occurrenceID = occurrenceID
            self.startTime = startTime
            self.duration = duration
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case occurrenceID = "occurrence_id"
            case startTime = "start_time"
            case duration
            case status
        }
    }

    /// Webinar settings.
    public struct Settings: Codable {
        /// Start video when host joins webinar.
        public var isHostVideo: Bool?
        /// Start video when panelists join webinar.
        public var isPanelistsVideo: Bool?
        /// Enable practice session.
        public var isPracticeSession: Bool
        /// Default to HD video.
        public var isHdVideo: Bool
        /// Whether HD video for attendees is enabled. This value defaults to `false`.
        public var isHdVideoForAttendees: Bool
        /// Whether to always send 1080p video to attendees. This value defaults to `false`.
        public var isSend1080pVideoToAttendees: Bool
        /// `0` - Automatically approve.<br>`1` - Manually approve.<br>`2` - No registration required.
        public var approvalType: Int?
        /// Registration types. Only used for recurring webinars with a fixed time.<br>`1` - Attendees register once and can attend any of the webinar sessions.<br>`2` - Attendees need to register for each session in order to attend.<br>`3` - Attendees register once and can choose one or more sessions to attend.
        public var registrationType: Int?
        /// Determine how participants can join the audio portion of the webinar.
        public var audio: Audio?
        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public var autoRecording: AutoRecording?
        /// Only signed in users can join this meeting.
        /// 
        /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the Webinar.
        public var enforceLogin: Bool?
        /// Only signed in users with specified domains can join meetings.
        /// 
        /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the Webinar.
        public var enforceLoginDomains: String?
        /// Alternative host emails or IDs. Multiple values separated by comma.
        public var alternativeHosts: String?
        /// Close registration after event date.
        public var isCloseRegistration: Bool?
        /// Show social share buttons on the registration page.
        public var isShowShareButton: Bool?
        /// Allow attendees to join from multiple devices.
        public var allowMultipleDevices: Bool?
        /// Make the webinar on-demand
        public var isOnDemand: Bool
        /// List of global dial-in countries
        public var globalDialInCountries: [String]?
        /// Contact name for registration
        public var contactName: String?
        /// Contact email for registration
        public var contactEmail: String?
        /// Send confirmation email to registrants
        public var isRegistrantsConfirmationEmail: Bool?
        /// Restrict number of registrants for a webinar. By default, it is set to `0`. A `0` value means that the restriction option is disabled. Provide a number higher than 0 to restrict the webinar registrants by the that number.
        public var registrantsRestrictNumber: Int?
        /// Send notification email to registrants when the host updates a webinar.
        public var isNotifyRegistrants: Bool?
        /// Zoom will open a survey page in attendees' browsers after leaving the webinar
        public var isPostWebinarSurvey: Bool?
        /// Survey url for post webinar survey
        public var surveyURL: String?
        /// Send email notifications to registrants about approval, cancellation, denial of the registration. The value of this field must be set to true in order to use the `registrants_confirmation_email` field.
        public var isRegistrantsEmailNotification: Bool?
        /// `true`- Only authenticated users can join Webinar.
        public var isMeetingAuthentication: Bool?
        /// Webinar authentication option id.
        public var authenticationOption: String?
        /// If user has configured ["Sign Into Zoom with Specified Domains"](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
        public var authenticationDomains: String?
        /// Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
        public var authenticationName: String?
        /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
        public var questionAndAnswer: QuestionAndAnswer?
        /// Set the email language to one of the following:
        /// `en-US`,`de-DE`,`es-ES`,`fr-FR`,`jp-JP`,`pt-PT`,`ru-RU`,`zh-CN`, `zh-TW`, `ko-KO`, `it-IT`, `vi-VN`.
        public var emailLanguage: String?
        /// * `true`: Send invitation email to panelists.
        /// 
        /// * `false`: Do not send invitation email to panelists.
        public var isPanelistsInvitationEmailNotification: Bool?
        /// Send reminder email to attendees and panelists.
        public var attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification?
        /// Send follow-up email to attendees.
        public var followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification?
        /// Send follow-up email to absentees.
        public var followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification?
        /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
        /// 
        /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
        public var languageInterpretation: LanguageInterpretation?

        /// Determine how participants can join the audio portion of the webinar.
        public enum Audio: String, Codable, CaseIterable {
            case both
            case telephony
            case voip
        }

        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public enum AutoRecording: String, Codable, CaseIterable {
            case local
            case cloud
            case `none`
        }

        /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
        public struct QuestionAndAnswer: Codable {
            /// * `true`: Enable [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
            /// 
            /// * `false`: Disable Q&A for webinar.
            public var enable: Bool?
            /// * `true`: Allow participants to send questions without providing their name to the host, co-host, and panelists..
            /// 
            /// * `false`: Do not allow anonymous questions.
            public var allowAnonymousQuestions: Bool?
            /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
            /// 
            /// * `only`: Attendees are able to view answered questions only.
            /// 
            /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
            public var answerQuestions: AnswerQuestions?
            /// * `true`: Attendees can click the thumbs up button to bring popular questions to the top of the Q&A window.
            /// 
            /// * `false`: Attendees can not click the thumbs up button on questions.
            public var attendeesCanUpvote: Bool?
            /// * `true`: Attendees can answer questions or leave a comment in the question thread.
            /// 
            /// * `false`: Attendees can not answer questions or leave a comment in the question thread
            public var attendeesCanComment: Bool?

            /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
            /// 
            /// * `only`: Attendees are able to view answered questions only.
            /// 
            /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
            public enum AnswerQuestions: String, Codable, CaseIterable {
                case only
                case all
            }

            public init(enable: Bool? = nil, allowAnonymousQuestions: Bool? = nil, answerQuestions: AnswerQuestions? = nil, attendeesCanUpvote: Bool? = nil, attendeesCanComment: Bool? = nil) {
                self.enable = enable
                self.allowAnonymousQuestions = allowAnonymousQuestions
                self.answerQuestions = answerQuestions
                self.attendeesCanUpvote = attendeesCanUpvote
                self.attendeesCanComment = attendeesCanComment
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case allowAnonymousQuestions = "allow_anonymous_questions"
                case answerQuestions = "answer_questions"
                case attendeesCanUpvote = "attendees_can_upvote"
                case attendeesCanComment = "attendees_can_comment"
            }
        }

        /// Send reminder email to attendees and panelists.
        public struct AttendeesAndPanelistsReminderEmailNotification: Codable {
            /// * `true`: Send reminder email to attendees and panelists.
            /// 
            /// * `false`: Do not send reminder email to attendees and panelists.
            public var enable: Bool?
            /// `0` - No plan.<br>`1` - Send 1 hour before webinar.<br>`2` - Send 1 day before webinar.<br>`3` - Send 1 hour and 1 day before webinar.<br>`4` - Send 1 week before webinar.<br>`5` - Send 1 hour and 1 week before webinar.<br>`6` - Send 1 day and 1 week before webinar.<br>`7` - Send 1 hour, 1 day and 1 week before webinar.
            public var type: Int?

            public init(enable: Bool? = nil, type: Int? = nil) {
                self.enable = enable
                self.type = type
            }
        }

        /// Send follow-up email to attendees.
        public struct FollowUpAttendeesEmailNotification: Codable {
            /// * `true`: Send follow-up email to attendees.
            /// 
            /// * `false`: Do not send follow-up email to attendees.
            public var enable: Bool?
            /// `0` - No plan.<br>`1` - Send 1 day after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
            public var type: Int?

            public init(enable: Bool? = nil, type: Int? = nil) {
                self.enable = enable
                self.type = type
            }
        }

        /// Send follow-up email to absentees.
        public struct FollowUpAbsenteesEmailNotification: Codable {
            /// * `true`: Send follow-up email to absentees.
            /// 
            /// * `false`: Do not send follow-up email to absentees.
            public var enable: Bool?
            /// `0` - No plan.<br>`1` - Send 1 days after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
            public var type: Int?

            public init(enable: Bool? = nil, type: Int? = nil) {
                self.enable = enable
                self.type = type
            }
        }

        /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
        /// 
        /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
        public struct LanguageInterpretation: Codable {
            /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the webinar.
            public var enable: Bool?
            /// Information about the webinar's language interpreters.
            public var interpreters: [Interpreter]?

            public struct Interpreter: Codable {
                /// The interpreter's email address.
                public var email: String?
                /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
                /// 
                /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
                public var languages: String?

                public init(email: String? = nil, languages: String? = nil) {
                    self.email = email
                    self.languages = languages
                }
            }

            public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
                self.enable = enable
                self.interpreters = interpreters
            }
        }

        public init(isHostVideo: Bool? = nil, isPanelistsVideo: Bool? = nil, isPracticeSession: Bool? = nil, isHdVideo: Bool? = nil, isHdVideoForAttendees: Bool? = nil, isSend1080pVideoToAttendees: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, enforceLogin: Bool? = nil, enforceLoginDomains: String? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, isOnDemand: Bool? = nil, globalDialInCountries: [String]? = nil, contactName: String? = nil, contactEmail: String? = nil, isRegistrantsConfirmationEmail: Bool? = nil, registrantsRestrictNumber: Int? = nil, isNotifyRegistrants: Bool? = nil, isPostWebinarSurvey: Bool? = nil, surveyURL: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, authenticationName: String? = nil, questionAndAnswer: QuestionAndAnswer? = nil, emailLanguage: String? = nil, isPanelistsInvitationEmailNotification: Bool? = nil, attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification? = nil, followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification? = nil, followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification? = nil, languageInterpretation: LanguageInterpretation? = nil) {
            self.isHostVideo = isHostVideo
            self.isPanelistsVideo = isPanelistsVideo
            self.isPracticeSession = isPracticeSession ?? false
            self.isHdVideo = isHdVideo ?? false
            self.isHdVideoForAttendees = isHdVideoForAttendees ?? false
            self.isSend1080pVideoToAttendees = isSend1080pVideoToAttendees ?? false
            self.approvalType = approvalType
            self.registrationType = registrationType
            self.audio = audio
            self.autoRecording = autoRecording
            self.enforceLogin = enforceLogin
            self.enforceLoginDomains = enforceLoginDomains
            self.alternativeHosts = alternativeHosts
            self.isCloseRegistration = isCloseRegistration
            self.isShowShareButton = isShowShareButton
            self.allowMultipleDevices = allowMultipleDevices
            self.isOnDemand = isOnDemand ?? false
            self.globalDialInCountries = globalDialInCountries
            self.contactName = contactName
            self.contactEmail = contactEmail
            self.isRegistrantsConfirmationEmail = isRegistrantsConfirmationEmail
            self.registrantsRestrictNumber = registrantsRestrictNumber
            self.isNotifyRegistrants = isNotifyRegistrants
            self.isPostWebinarSurvey = isPostWebinarSurvey
            self.surveyURL = surveyURL
            self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
            self.isMeetingAuthentication = isMeetingAuthentication
            self.authenticationOption = authenticationOption
            self.authenticationDomains = authenticationDomains
            self.authenticationName = authenticationName
            self.questionAndAnswer = questionAndAnswer
            self.emailLanguage = emailLanguage
            self.isPanelistsInvitationEmailNotification = isPanelistsInvitationEmailNotification
            self.attendeesAndPanelistsReminderEmailNotification = attendeesAndPanelistsReminderEmailNotification
            self.followUpAttendeesEmailNotification = followUpAttendeesEmailNotification
            self.followUpAbsenteesEmailNotification = followUpAbsenteesEmailNotification
            self.languageInterpretation = languageInterpretation
        }

        private enum CodingKeys: String, CodingKey {
            case isHostVideo = "host_video"
            case isPanelistsVideo = "panelists_video"
            case isPracticeSession = "practice_session"
            case isHdVideo = "hd_video"
            case isHdVideoForAttendees = "hd_video_for_attendees"
            case isSend1080pVideoToAttendees = "send_1080p_video_to_attendees"
            case approvalType = "approval_type"
            case registrationType = "registration_type"
            case audio
            case autoRecording = "auto_recording"
            case enforceLogin = "enforce_login"
            case enforceLoginDomains = "enforce_login_domains"
            case alternativeHosts = "alternative_hosts"
            case isCloseRegistration = "close_registration"
            case isShowShareButton = "show_share_button"
            case allowMultipleDevices = "allow_multiple_devices"
            case isOnDemand = "on_demand"
            case globalDialInCountries = "global_dial_in_countries"
            case contactName = "contact_name"
            case contactEmail = "contact_email"
            case isRegistrantsConfirmationEmail = "registrants_confirmation_email"
            case registrantsRestrictNumber = "registrants_restrict_number"
            case isNotifyRegistrants = "notify_registrants"
            case isPostWebinarSurvey = "post_webinar_survey"
            case surveyURL = "survey_url"
            case isRegistrantsEmailNotification = "registrants_email_notification"
            case isMeetingAuthentication = "meeting_authentication"
            case authenticationOption = "authentication_option"
            case authenticationDomains = "authentication_domains"
            case authenticationName = "authentication_name"
            case questionAndAnswer = "question_and_answer"
            case emailLanguage = "email_language"
            case isPanelistsInvitationEmailNotification = "panelists_invitation_email_notification"
            case attendeesAndPanelistsReminderEmailNotification = "attendees_and_panelists_reminder_email_notification"
            case followUpAttendeesEmailNotification = "follow_up_attendees_email_notification"
            case followUpAbsenteesEmailNotification = "follow_up_absentees_email_notification"
            case languageInterpretation = "language_interpretation"
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.isHostVideo = try values.decodeIfPresent(Bool.self, forKey: .isHostVideo)
            self.isPanelistsVideo = try values.decodeIfPresent(Bool.self, forKey: .isPanelistsVideo)
            self.isPracticeSession = try values.decodeIfPresent(Bool.self, forKey: .isPracticeSession) ?? false
            self.isHdVideo = try values.decodeIfPresent(Bool.self, forKey: .isHdVideo) ?? false
            self.isHdVideoForAttendees = try values.decodeIfPresent(Bool.self, forKey: .isHdVideoForAttendees) ?? false
            self.isSend1080pVideoToAttendees = try values.decodeIfPresent(Bool.self, forKey: .isSend1080pVideoToAttendees) ?? false
            self.approvalType = try values.decodeIfPresent(Int.self, forKey: .approvalType)
            self.registrationType = try values.decodeIfPresent(Int.self, forKey: .registrationType)
            self.audio = try values.decodeIfPresent(Audio.self, forKey: .audio)
            self.autoRecording = try values.decodeIfPresent(AutoRecording.self, forKey: .autoRecording)
            self.enforceLogin = try values.decodeIfPresent(Bool.self, forKey: .enforceLogin)
            self.enforceLoginDomains = try values.decodeIfPresent(String.self, forKey: .enforceLoginDomains)
            self.alternativeHosts = try values.decodeIfPresent(String.self, forKey: .alternativeHosts)
            self.isCloseRegistration = try values.decodeIfPresent(Bool.self, forKey: .isCloseRegistration)
            self.isShowShareButton = try values.decodeIfPresent(Bool.self, forKey: .isShowShareButton)
            self.allowMultipleDevices = try values.decodeIfPresent(Bool.self, forKey: .allowMultipleDevices)
            self.isOnDemand = try values.decodeIfPresent(Bool.self, forKey: .isOnDemand) ?? false
            self.globalDialInCountries = try values.decodeIfPresent([String].self, forKey: .globalDialInCountries)
            self.contactName = try values.decodeIfPresent(String.self, forKey: .contactName)
            self.contactEmail = try values.decodeIfPresent(String.self, forKey: .contactEmail)
            self.isRegistrantsConfirmationEmail = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsConfirmationEmail)
            self.registrantsRestrictNumber = try values.decodeIfPresent(Int.self, forKey: .registrantsRestrictNumber)
            self.isNotifyRegistrants = try values.decodeIfPresent(Bool.self, forKey: .isNotifyRegistrants)
            self.isPostWebinarSurvey = try values.decodeIfPresent(Bool.self, forKey: .isPostWebinarSurvey)
            self.surveyURL = try values.decodeIfPresent(String.self, forKey: .surveyURL)
            self.isRegistrantsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsEmailNotification)
            self.isMeetingAuthentication = try values.decodeIfPresent(Bool.self, forKey: .isMeetingAuthentication)
            self.authenticationOption = try values.decodeIfPresent(String.self, forKey: .authenticationOption)
            self.authenticationDomains = try values.decodeIfPresent(String.self, forKey: .authenticationDomains)
            self.authenticationName = try values.decodeIfPresent(String.self, forKey: .authenticationName)
            self.questionAndAnswer = try values.decodeIfPresent(QuestionAndAnswer.self, forKey: .questionAndAnswer)
            self.emailLanguage = try values.decodeIfPresent(String.self, forKey: .emailLanguage)
            self.isPanelistsInvitationEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isPanelistsInvitationEmailNotification)
            self.attendeesAndPanelistsReminderEmailNotification = try values.decodeIfPresent(AttendeesAndPanelistsReminderEmailNotification.self, forKey: .attendeesAndPanelistsReminderEmailNotification)
            self.followUpAttendeesEmailNotification = try values.decodeIfPresent(FollowUpAttendeesEmailNotification.self, forKey: .followUpAttendeesEmailNotification)
            self.followUpAbsenteesEmailNotification = try values.decodeIfPresent(FollowUpAbsenteesEmailNotification.self, forKey: .followUpAbsenteesEmailNotification)
            self.languageInterpretation = try values.decodeIfPresent(LanguageInterpretation.self, forKey: .languageInterpretation)
        }
    }

    /// Recurrence Webinar
    ///
    /// Recurrence object. Use this object only for a webinar of type `9` i.e., a recurring webinar with fixed time.
    public struct Recurrence: Codable {
        /// Recurrence webinar types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
        public var type: Int
        /// Define the interval at which the webinar should recur. For instance, if you would like to schedule a Webinar that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
        /// 
        /// For a daily webinar, the maximum interval you can set is `90` days. For a weekly webinar, the maximum interval that you can set is `12` weeks. For a monthly webinar, the maximum interval that you can set is `3` months.
        public var repeatInterval: Int?
        /// Use this field **only if you're scheduling a recurring webinar of type** `2` to state which day(s) of the week the webinar should repeat. <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the Webinar should recur on Sunday, provide `"1"` as the value of this field.  <br><br> **Note:** If you would like the webinar to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the Webinar should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
        /// 
        /// <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public var weeklyDays: String?
        /// Use this field **only if you're scheduling a recurring webinar of type** `3` to state which day in a month, the webinar should recur. The value range is from 1 to 31.
        /// 
        /// For instance, if you would like the webinar to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the webinar to recur once every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
        public var monthlyDay: Int?
        /// Use this field **only if you're scheduling a recurring webinar of type** `3` to state the week of the month when the webinar should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the webinar should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
        public var monthlyWeek: Int?
        /// Use this field **only if you're scheduling a recurring webinar of type** `3` to state a specific day in a week when the monthly webinar should recur. To use this field, you must also use the `monthly_week` field. <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public var monthlyWeekDay: Int?
        /// Select how many times the webinar will recur before it is canceled. (Cannot be used with "end_date_time".)
        public var endTimes: Int?
        /// Select a date when the webinar will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
        public var endDateTime: Date?

        public init(type: Int, repeatInterval: Int? = nil, weeklyDays: String? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
            self.type = type
            self.repeatInterval = repeatInterval
            self.weeklyDays = weeklyDays
            self.monthlyDay = monthlyDay
            self.monthlyWeek = monthlyWeek
            self.monthlyWeekDay = monthlyWeekDay
            self.endTimes = endTimes
            self.endDateTime = endDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case repeatInterval = "repeat_interval"
            case weeklyDays = "weekly_days"
            case monthlyDay = "monthly_day"
            case monthlyWeek = "monthly_week"
            case monthlyWeekDay = "monthly_week_day"
            case endTimes = "end_times"
            case endDateTime = "end_date_time"
        }
    }

    public init(topic: String? = nil, type: Int? = nil, startTime: Date? = nil, duration: Int? = nil, timezone: String? = nil, agenda: String? = nil, createdAt: Date? = nil, startURL: String? = nil, joinURL: String? = nil, trackingFields: [TrackingField]? = nil, occurrences: [Occurrence]? = nil, settings: Settings? = nil, recurrence: Recurrence? = nil, password: String? = nil) {
        self.topic = topic
        self.type = type
        self.startTime = startTime
        self.duration = duration
        self.timezone = timezone
        self.agenda = agenda
        self.createdAt = createdAt
        self.startURL = startURL
        self.joinURL = joinURL
        self.trackingFields = trackingFields
        self.occurrences = occurrences
        self.settings = settings
        self.recurrence = recurrence
        self.password = password
    }

    private enum CodingKeys: String, CodingKey {
        case topic
        case type
        case startTime = "start_time"
        case duration
        case timezone
        case agenda
        case createdAt = "created_at"
        case startURL = "start_url"
        case joinURL = "join_url"
        case trackingFields = "tracking_fields"
        case occurrences
        case settings
        case recurrence
        case password
    }
}

/// Base webinar object for sessions.
public struct SessionWebinarUpdate: Codable {
    /// Webinar topic.
    public var topic: String?
    /// Webinar Types:<br>`5` - webinar.<br>`6` - Recurring webinar with no fixed time.<br>`9` - Recurring webinar with a fixed time.
    public var type: Int?
    /// Webinar start time, in the format "yyyy-MM-dd'T'HH:mm:ss'Z'." Should be in GMT time. In the format "yyyy-MM-dd'T'HH:mm:ss." This should be in local time and the timezone should be specified. Only used for scheduled webinars and recurring webinars with a fixed time.
    public var startTime: Date?
    /// Webinar duration (minutes). Used for scheduled webinar only.
    public var duration: Int?
    /// Time zone to format start_time. For example, "America/Los_Angeles". For scheduled meetings only. Please reference our [time zone](#timezones) list for supported time zones and their formats.
    public var timezone: String?
    /// [Webinar passcode](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords). By default, passcode may only contain the following characters: [a-z A-Z 0-9 @ - _ * !] and can have a maximum of 10 characters.
    /// 
    /// **Note:** If the account owner or the admin has configured [minimum passcode requirement settings](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604), the passcode value provided here must meet those requirements. <br><br>If the requirements are enabled, you can view those requirements by calling either the [Get User Settings API](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings) or the  [Get Account Settings](https://marketplace.zoom.us/docs/api-reference/zoom-api/accounts/accountsettings) API. 
    /// 
    /// If "**Require a passcode when scheduling new meetings**" setting has been **enabled** **and** [locked](https://support.zoom.us/hc/en-us/articles/115005269866-Using-Tiered-Settings#locked) for the user, the passcode field will be autogenerated for the Webinar in the response even if it is not provided in the API request. <br><br>
    public var password: String?
    /// Webinar description.
    public var agenda: String?
    /// Tracking fields
    public var trackingFields: [TrackingField]?
    /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
    public var recurrence: Recurrence?
    public var settings: Settings?

    public struct TrackingField: Codable {
        /// Tracking fields type
        public var field: String?
        /// Tracking fields value
        public var value: String?

        public init(field: String? = nil, value: String? = nil) {
            self.field = field
            self.value = value
        }
    }

    /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
    public struct Recurrence: Codable {
        /// Recurrence meeting types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
        public var type: Int
        /// Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
        /// 
        /// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
        public var repeatInterval: Int?
        /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
        /// 
        ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public var weeklyDays: WeeklyDays?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
        /// 
        /// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
        public var monthlyDay: Int?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
        public var monthlyWeek: Int?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field. 
        /// 
        /// <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public var monthlyWeekDay: Int?
        /// Select how many times the meeting should recur before it is canceled. (Cannot be used with "end_date_time".)
        public var endTimes: Int?
        /// Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
        public var endDateTime: Date?

        /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
        /// 
        ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public enum WeeklyDays: String, Codable, CaseIterable {
            case _1 = "1"
            case _2 = "2"
            case _3 = "3"
            case _4 = "4"
            case _5 = "5"
            case _6 = "6"
            case _7 = "7"
        }

        public init(type: Int, repeatInterval: Int? = nil, weeklyDays: WeeklyDays? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
            self.type = type
            self.repeatInterval = repeatInterval
            self.weeklyDays = weeklyDays
            self.monthlyDay = monthlyDay
            self.monthlyWeek = monthlyWeek
            self.monthlyWeekDay = monthlyWeekDay
            self.endTimes = endTimes
            self.endDateTime = endDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case repeatInterval = "repeat_interval"
            case weeklyDays = "weekly_days"
            case monthlyDay = "monthly_day"
            case monthlyWeek = "monthly_week"
            case monthlyWeekDay = "monthly_week_day"
            case endTimes = "end_times"
            case endDateTime = "end_date_time"
        }
    }

    public struct Settings: Codable {
        /// Start video when host joins webinar.
        public var isHostVideo: Bool?
        /// Start video when panelists join webinar.
        public var isPanelistsVideo: Bool?
        /// Enable practice session.
        public var isPracticeSession: Bool
        /// Default to HD video.
        public var isHdVideo: Bool
        /// Whether HD video for attendees is enabled. This value defaults to `false`.
        public var isHdVideoForAttendees: Bool
        /// Whether to always send 1080p video to attendees. This value defaults to `false`.
        public var isSend1080pVideoToAttendees: Bool
        /// `0` - Automatically approve.<br>`1` - Manually approve.<br>`2` - No registration required.
        public var approvalType: Int?
        /// Registration types. Only used for recurring webinars with a fixed time.<br>`1` - Attendees register once and can attend any of the webinar sessions.<br>`2` - Attendees need to register for each session in order to attend.<br>`3` - Attendees register once and can choose one or more sessions to attend.
        public var registrationType: Int?
        /// Determine how participants can join the audio portion of the webinar.
        public var audio: Audio?
        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public var autoRecording: AutoRecording?
        /// Only signed in users can join this meeting.
        /// 
        /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the Webinar.
        public var enforceLogin: Bool?
        /// Only signed in users with specified domains can join meetings.
        /// 
        /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the Webinar.
        public var enforceLoginDomains: String?
        /// Alternative host emails or IDs. Multiple values separated by comma.
        public var alternativeHosts: String?
        /// Close registration after event date.
        public var isCloseRegistration: Bool?
        /// Show social share buttons on the registration page.
        public var isShowShareButton: Bool?
        /// Allow attendees to join from multiple devices.
        public var allowMultipleDevices: Bool?
        /// Make the webinar on-demand
        public var isOnDemand: Bool
        /// List of global dial-in countries
        public var globalDialInCountries: [String]?
        /// Contact name for registration
        public var contactName: String?
        /// Contact email for registration
        public var contactEmail: String?
        /// Send confirmation email to registrants
        public var isRegistrantsConfirmationEmail: Bool?
        /// Restrict number of registrants for a webinar. By default, it is set to `0`. A `0` value means that the restriction option is disabled. Provide a number higher than 0 to restrict the webinar registrants by the that number.
        public var registrantsRestrictNumber: Int?
        /// Send notification email to registrants when the host updates a webinar.
        public var isNotifyRegistrants: Bool?
        /// Zoom will open a survey page in attendees' browsers after leaving the webinar
        public var isPostWebinarSurvey: Bool?
        /// Survey url for post webinar survey
        public var surveyURL: String?
        /// Send email notifications to registrants about approval, cancellation, denial of the registration. The value of this field must be set to true in order to use the `registrants_confirmation_email` field.
        public var isRegistrantsEmailNotification: Bool?
        /// `true`- Only authenticated users can join Webinar.
        public var isMeetingAuthentication: Bool?
        /// Webinar authentication option id.
        public var authenticationOption: String?
        /// If user has configured ["Sign Into Zoom with Specified Domains"](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
        public var authenticationDomains: String?
        /// Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
        public var authenticationName: String?
        /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
        public var questionAndAnswer: QuestionAndAnswer?
        /// Set the email language to one of the following:
        /// `en-US`,`de-DE`,`es-ES`,`fr-FR`,`jp-JP`,`pt-PT`,`ru-RU`,`zh-CN`, `zh-TW`, `ko-KO`, `it-IT`, `vi-VN`.
        public var emailLanguage: String?
        /// * `true`: Send invitation email to panelists.
        /// 
        /// * `false`: Do not send invitation email to panelists.
        public var isPanelistsInvitationEmailNotification: Bool?
        /// Send reminder email to attendees and panelists.
        public var attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification?
        /// Send follow-up email to attendees.
        public var followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification?
        /// Send follow-up email to absentees.
        public var followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification?
        /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
        /// 
        /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
        public var languageInterpretation: LanguageInterpretation?

        /// Determine how participants can join the audio portion of the webinar.
        public enum Audio: String, Codable, CaseIterable {
            case both
            case telephony
            case voip
        }

        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public enum AutoRecording: String, Codable, CaseIterable {
            case local
            case cloud
            case `none`
        }

        /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
        public struct QuestionAndAnswer: Codable {
            /// * `true`: Enable [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
            /// 
            /// * `false`: Disable Q&A for webinar.
            public var enable: Bool?
            /// * `true`: Allow participants to send questions without providing their name to the host, co-host, and panelists..
            /// 
            /// * `false`: Do not allow anonymous questions.
            public var allowAnonymousQuestions: Bool?
            /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
            /// 
            /// * `only`: Attendees are able to view answered questions only.
            /// 
            /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
            public var answerQuestions: AnswerQuestions?
            /// * `true`: Attendees can click the thumbs up button to bring popular questions to the top of the Q&A window.
            /// 
            /// * `false`: Attendees can not click the thumbs up button on questions.
            public var attendeesCanUpvote: Bool?
            /// * `true`: Attendees can answer questions or leave a comment in the question thread.
            /// 
            /// * `false`: Attendees can not answer questions or leave a comment in the question thread
            public var attendeesCanComment: Bool?

            /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
            /// 
            /// * `only`: Attendees are able to view answered questions only.
            /// 
            /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
            public enum AnswerQuestions: String, Codable, CaseIterable {
                case only
                case all
            }

            public init(enable: Bool? = nil, allowAnonymousQuestions: Bool? = nil, answerQuestions: AnswerQuestions? = nil, attendeesCanUpvote: Bool? = nil, attendeesCanComment: Bool? = nil) {
                self.enable = enable
                self.allowAnonymousQuestions = allowAnonymousQuestions
                self.answerQuestions = answerQuestions
                self.attendeesCanUpvote = attendeesCanUpvote
                self.attendeesCanComment = attendeesCanComment
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case allowAnonymousQuestions = "allow_anonymous_questions"
                case answerQuestions = "answer_questions"
                case attendeesCanUpvote = "attendees_can_upvote"
                case attendeesCanComment = "attendees_can_comment"
            }
        }

        /// Send reminder email to attendees and panelists.
        public struct AttendeesAndPanelistsReminderEmailNotification: Codable {
            /// * `true`: Send reminder email to attendees and panelists.
            /// 
            /// * `false`: Do not send reminder email to attendees and panelists.
            public var enable: Bool?
            /// `0` - No plan.<br>`1` - Send 1 hour before webinar.<br>`2` - Send 1 day before webinar.<br>`3` - Send 1 hour and 1 day before webinar.<br>`4` - Send 1 week before webinar.<br>`5` - Send 1 hour and 1 week before webinar.<br>`6` - Send 1 day and 1 week before webinar.<br>`7` - Send 1 hour, 1 day and 1 week before webinar.
            public var type: Int?

            public init(enable: Bool? = nil, type: Int? = nil) {
                self.enable = enable
                self.type = type
            }
        }

        /// Send follow-up email to attendees.
        public struct FollowUpAttendeesEmailNotification: Codable {
            /// * `true`: Send follow-up email to attendees.
            /// 
            /// * `false`: Do not send follow-up email to attendees.
            public var enable: Bool?
            /// `0` - No plan.<br>`1` - Send 1 day after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
            public var type: Int?

            public init(enable: Bool? = nil, type: Int? = nil) {
                self.enable = enable
                self.type = type
            }
        }

        /// Send follow-up email to absentees.
        public struct FollowUpAbsenteesEmailNotification: Codable {
            /// * `true`: Send follow-up email to absentees.
            /// 
            /// * `false`: Do not send follow-up email to absentees.
            public var enable: Bool?
            /// `0` - No plan.<br>`1` - Send 1 days after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
            public var type: Int?

            public init(enable: Bool? = nil, type: Int? = nil) {
                self.enable = enable
                self.type = type
            }
        }

        /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
        /// 
        /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
        public struct LanguageInterpretation: Codable {
            /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the webinar.
            public var enable: Bool?
            /// Information about the webinar's language interpreters.
            public var interpreters: [Interpreter]?

            public struct Interpreter: Codable {
                /// The interpreter's email address.
                public var email: String?
                /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
                /// 
                /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
                public var languages: String?

                public init(email: String? = nil, languages: String? = nil) {
                    self.email = email
                    self.languages = languages
                }
            }

            public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
                self.enable = enable
                self.interpreters = interpreters
            }
        }

        public init(isHostVideo: Bool? = nil, isPanelistsVideo: Bool? = nil, isPracticeSession: Bool? = nil, isHdVideo: Bool? = nil, isHdVideoForAttendees: Bool? = nil, isSend1080pVideoToAttendees: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, enforceLogin: Bool? = nil, enforceLoginDomains: String? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, isOnDemand: Bool? = nil, globalDialInCountries: [String]? = nil, contactName: String? = nil, contactEmail: String? = nil, isRegistrantsConfirmationEmail: Bool? = nil, registrantsRestrictNumber: Int? = nil, isNotifyRegistrants: Bool? = nil, isPostWebinarSurvey: Bool? = nil, surveyURL: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, authenticationName: String? = nil, questionAndAnswer: QuestionAndAnswer? = nil, emailLanguage: String? = nil, isPanelistsInvitationEmailNotification: Bool? = nil, attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification? = nil, followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification? = nil, followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification? = nil, languageInterpretation: LanguageInterpretation? = nil) {
            self.isHostVideo = isHostVideo
            self.isPanelistsVideo = isPanelistsVideo
            self.isPracticeSession = isPracticeSession ?? false
            self.isHdVideo = isHdVideo ?? false
            self.isHdVideoForAttendees = isHdVideoForAttendees ?? false
            self.isSend1080pVideoToAttendees = isSend1080pVideoToAttendees ?? false
            self.approvalType = approvalType
            self.registrationType = registrationType
            self.audio = audio
            self.autoRecording = autoRecording
            self.enforceLogin = enforceLogin
            self.enforceLoginDomains = enforceLoginDomains
            self.alternativeHosts = alternativeHosts
            self.isCloseRegistration = isCloseRegistration
            self.isShowShareButton = isShowShareButton
            self.allowMultipleDevices = allowMultipleDevices
            self.isOnDemand = isOnDemand ?? false
            self.globalDialInCountries = globalDialInCountries
            self.contactName = contactName
            self.contactEmail = contactEmail
            self.isRegistrantsConfirmationEmail = isRegistrantsConfirmationEmail
            self.registrantsRestrictNumber = registrantsRestrictNumber
            self.isNotifyRegistrants = isNotifyRegistrants
            self.isPostWebinarSurvey = isPostWebinarSurvey
            self.surveyURL = surveyURL
            self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
            self.isMeetingAuthentication = isMeetingAuthentication
            self.authenticationOption = authenticationOption
            self.authenticationDomains = authenticationDomains
            self.authenticationName = authenticationName
            self.questionAndAnswer = questionAndAnswer
            self.emailLanguage = emailLanguage
            self.isPanelistsInvitationEmailNotification = isPanelistsInvitationEmailNotification
            self.attendeesAndPanelistsReminderEmailNotification = attendeesAndPanelistsReminderEmailNotification
            self.followUpAttendeesEmailNotification = followUpAttendeesEmailNotification
            self.followUpAbsenteesEmailNotification = followUpAbsenteesEmailNotification
            self.languageInterpretation = languageInterpretation
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isHostVideo = try values.decodeIfPresent(Bool.self, forKey: "host_video")
            self.isPanelistsVideo = try values.decodeIfPresent(Bool.self, forKey: "panelists_video")
            self.isPracticeSession = try values.decodeIfPresent(Bool.self, forKey: "practice_session") ?? false
            self.isHdVideo = try values.decodeIfPresent(Bool.self, forKey: "hd_video") ?? false
            self.isHdVideoForAttendees = try values.decodeIfPresent(Bool.self, forKey: "hd_video_for_attendees") ?? false
            self.isSend1080pVideoToAttendees = try values.decodeIfPresent(Bool.self, forKey: "send_1080p_video_to_attendees") ?? false
            self.approvalType = try values.decodeIfPresent(Int.self, forKey: "approval_type")
            self.registrationType = try values.decodeIfPresent(Int.self, forKey: "registration_type")
            self.audio = try Audio(from: decoder)
            self.autoRecording = try AutoRecording(from: decoder)
            self.enforceLogin = try values.decodeIfPresent(Bool.self, forKey: "enforce_login")
            self.enforceLoginDomains = try values.decodeIfPresent(String.self, forKey: "enforce_login_domains")
            self.alternativeHosts = try values.decodeIfPresent(String.self, forKey: "alternative_hosts")
            self.isCloseRegistration = try values.decodeIfPresent(Bool.self, forKey: "close_registration")
            self.isShowShareButton = try values.decodeIfPresent(Bool.self, forKey: "show_share_button")
            self.allowMultipleDevices = try values.decodeIfPresent(Bool.self, forKey: "allow_multiple_devices")
            self.isOnDemand = try values.decodeIfPresent(Bool.self, forKey: "on_demand") ?? false
            self.globalDialInCountries = try values.decodeIfPresent([String].self, forKey: "global_dial_in_countries")
            self.contactName = try values.decodeIfPresent(String.self, forKey: "contact_name")
            self.contactEmail = try values.decodeIfPresent(String.self, forKey: "contact_email")
            self.isRegistrantsConfirmationEmail = try values.decodeIfPresent(Bool.self, forKey: "registrants_confirmation_email")
            self.registrantsRestrictNumber = try values.decodeIfPresent(Int.self, forKey: "registrants_restrict_number")
            self.isNotifyRegistrants = try values.decodeIfPresent(Bool.self, forKey: "notify_registrants")
            self.isPostWebinarSurvey = try values.decodeIfPresent(Bool.self, forKey: "post_webinar_survey")
            self.surveyURL = try values.decodeIfPresent(String.self, forKey: "survey_url")
            self.isRegistrantsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: "registrants_email_notification")
            self.isMeetingAuthentication = try values.decodeIfPresent(Bool.self, forKey: "meeting_authentication")
            self.authenticationOption = try values.decodeIfPresent(String.self, forKey: "authentication_option")
            self.authenticationDomains = try values.decodeIfPresent(String.self, forKey: "authentication_domains")
            self.authenticationName = try values.decodeIfPresent(String.self, forKey: "authentication_name")
            self.questionAndAnswer = try QuestionAndAnswer(from: decoder)
            self.emailLanguage = try values.decodeIfPresent(String.self, forKey: "email_language")
            self.isPanelistsInvitationEmailNotification = try values.decodeIfPresent(Bool.self, forKey: "panelists_invitation_email_notification")
            self.attendeesAndPanelistsReminderEmailNotification = try AttendeesAndPanelistsReminderEmailNotification(from: decoder)
            self.followUpAttendeesEmailNotification = try FollowUpAttendeesEmailNotification(from: decoder)
            self.followUpAbsenteesEmailNotification = try FollowUpAbsenteesEmailNotification(from: decoder)
            self.languageInterpretation = try LanguageInterpretation(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(isHostVideo, forKey: "host_video")
            try values.encodeIfPresent(isPanelistsVideo, forKey: "panelists_video")
            try values.encodeIfPresent(isPracticeSession, forKey: "practice_session")
            try values.encodeIfPresent(isHdVideo, forKey: "hd_video")
            try values.encodeIfPresent(isHdVideoForAttendees, forKey: "hd_video_for_attendees")
            try values.encodeIfPresent(isSend1080pVideoToAttendees, forKey: "send_1080p_video_to_attendees")
            try values.encodeIfPresent(approvalType, forKey: "approval_type")
            try values.encodeIfPresent(registrationType, forKey: "registration_type")
            try values.encodeIfPresent(audio, forKey: "audio")
            try values.encodeIfPresent(autoRecording, forKey: "auto_recording")
            try values.encodeIfPresent(enforceLogin, forKey: "enforce_login")
            try values.encodeIfPresent(enforceLoginDomains, forKey: "enforce_login_domains")
            try values.encodeIfPresent(alternativeHosts, forKey: "alternative_hosts")
            try values.encodeIfPresent(isCloseRegistration, forKey: "close_registration")
            try values.encodeIfPresent(isShowShareButton, forKey: "show_share_button")
            try values.encodeIfPresent(allowMultipleDevices, forKey: "allow_multiple_devices")
            try values.encodeIfPresent(isOnDemand, forKey: "on_demand")
            try values.encodeIfPresent(globalDialInCountries, forKey: "global_dial_in_countries")
            try values.encodeIfPresent(contactName, forKey: "contact_name")
            try values.encodeIfPresent(contactEmail, forKey: "contact_email")
            try values.encodeIfPresent(isRegistrantsConfirmationEmail, forKey: "registrants_confirmation_email")
            try values.encodeIfPresent(registrantsRestrictNumber, forKey: "registrants_restrict_number")
            try values.encodeIfPresent(isNotifyRegistrants, forKey: "notify_registrants")
            try values.encodeIfPresent(isPostWebinarSurvey, forKey: "post_webinar_survey")
            try values.encodeIfPresent(surveyURL, forKey: "survey_url")
            try values.encodeIfPresent(isRegistrantsEmailNotification, forKey: "registrants_email_notification")
            try values.encodeIfPresent(isMeetingAuthentication, forKey: "meeting_authentication")
            try values.encodeIfPresent(authenticationOption, forKey: "authentication_option")
            try values.encodeIfPresent(authenticationDomains, forKey: "authentication_domains")
            try values.encodeIfPresent(authenticationName, forKey: "authentication_name")
            try values.encodeIfPresent(questionAndAnswer, forKey: "question_and_answer")
            try values.encodeIfPresent(emailLanguage, forKey: "email_language")
            try values.encodeIfPresent(isPanelistsInvitationEmailNotification, forKey: "panelists_invitation_email_notification")
            try values.encodeIfPresent(attendeesAndPanelistsReminderEmailNotification, forKey: "attendees_and_panelists_reminder_email_notification")
            try values.encodeIfPresent(followUpAttendeesEmailNotification, forKey: "follow_up_attendees_email_notification")
            try values.encodeIfPresent(followUpAbsenteesEmailNotification, forKey: "follow_up_absentees_email_notification")
            try values.encodeIfPresent(languageInterpretation, forKey: "language_interpretation")
        }
    }

    public init(topic: String? = nil, type: Int? = nil, startTime: Date? = nil, duration: Int? = nil, timezone: String? = nil, password: String? = nil, agenda: String? = nil, trackingFields: [TrackingField]? = nil, recurrence: Recurrence? = nil, settings: Settings? = nil) {
        self.topic = topic
        self.type = type
        self.startTime = startTime
        self.duration = duration
        self.timezone = timezone
        self.password = password
        self.agenda = agenda
        self.trackingFields = trackingFields
        self.recurrence = recurrence
        self.settings = settings
    }

    private enum CodingKeys: String, CodingKey {
        case topic
        case type
        case startTime = "start_time"
        case duration
        case timezone
        case password
        case agenda
        case trackingFields = "tracking_fields"
        case recurrence
        case settings
    }
}

/// Webinar live stream status.
public struct WebinarLiveStreamStatus: Codable {
    /// Update the status of a live stream. This value can be one of the following:
    /// 
    /// * `start` — Start a webinar live stream.
    /// 
    /// * `stop` — Stop an ongoing webinar live stream.
    public var action: Action?
    /// Update the live stream session's settings. You can **only** update settings for a stopped live stream.
    public var settings: Settings?

    /// Update the status of a live stream. This value can be one of the following:
    /// 
    /// * `start` — Start a webinar live stream.
    /// 
    /// * `stop` — Stop an ongoing webinar live stream.
    public enum Action: String, Codable, CaseIterable {
        case start
        case stop
    }

    /// Update the live stream session's settings. You can **only** update settings for a stopped live stream.
    public struct Settings: Codable {
        /// Display the name of the active speaker during a live stream.
        public var isActiveSpeakerName: Bool?
        /// Display the name of the live stream.
        public var displayName: String?

        public init(isActiveSpeakerName: Bool? = nil, displayName: String? = nil) {
            self.isActiveSpeakerName = isActiveSpeakerName
            self.displayName = displayName
        }

        private enum CodingKeys: String, CodingKey {
            case isActiveSpeakerName = "active_speaker_name"
            case displayName = "display_name"
        }
    }

    public init(action: Action? = nil, settings: Settings? = nil) {
        self.action = action
        self.settings = settings
    }
}

/// Webinar panelist.
public struct WebinarPanelist: Codable {
    /// List of panelist objects.
    public var panelists: [Panelist]?

    public struct Panelist: Codable {
        /// The panelist's full name.
        /// 
        /// **Note:** This value cannot exceed more than 12 Chinese characters.
        public var name: String?
        /// Panelist's email.
        public var email: String?

        public init(name: String? = nil, email: String? = nil) {
            self.name = name
            self.email = email
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.email = try values.decodeIfPresent(String.self, forKey: "email")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(email, forKey: "email")
        }
    }

    public init(panelists: [Panelist]? = nil) {
        self.panelists = panelists
    }
}

/// Webinar settings.
public struct WebinarSettings: Codable {
    /// Start video when host joins webinar.
    public var isHostVideo: Bool?
    /// Start video when panelists join webinar.
    public var isPanelistsVideo: Bool?
    /// Enable practice session.
    public var isPracticeSession: Bool
    /// Default to HD video.
    public var isHdVideo: Bool
    /// Whether HD video for attendees is enabled. This value defaults to `false`.
    public var isHdVideoForAttendees: Bool
    /// Whether to always send 1080p video to attendees. This value defaults to `false`.
    public var isSend1080pVideoToAttendees: Bool
    /// `0` - Automatically approve.<br>`1` - Manually approve.<br>`2` - No registration required.
    public var approvalType: Int?
    /// Registration types. Only used for recurring webinars with a fixed time.<br>`1` - Attendees register once and can attend any of the webinar sessions.<br>`2` - Attendees need to register for each session in order to attend.<br>`3` - Attendees register once and can choose one or more sessions to attend.
    public var registrationType: Int?
    /// Determine how participants can join the audio portion of the webinar.
    public var audio: Audio?
    /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
    public var autoRecording: AutoRecording?
    /// Only signed in users can join this meeting.
    /// 
    /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the Webinar.
    public var enforceLogin: Bool?
    /// Only signed in users with specified domains can join meetings.
    /// 
    /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the Webinar.
    public var enforceLoginDomains: String?
    /// Alternative host emails or IDs. Multiple values separated by comma.
    public var alternativeHosts: String?
    /// Close registration after event date.
    public var isCloseRegistration: Bool?
    /// Show social share buttons on the registration page.
    public var isShowShareButton: Bool?
    /// Allow attendees to join from multiple devices.
    public var allowMultipleDevices: Bool?
    /// Make the webinar on-demand
    public var isOnDemand: Bool
    /// List of global dial-in countries
    public var globalDialInCountries: [String]?
    /// Contact name for registration
    public var contactName: String?
    /// Contact email for registration
    public var contactEmail: String?
    /// Send confirmation email to registrants
    public var isRegistrantsConfirmationEmail: Bool?
    /// Restrict number of registrants for a webinar. By default, it is set to `0`. A `0` value means that the restriction option is disabled. Provide a number higher than 0 to restrict the webinar registrants by the that number.
    public var registrantsRestrictNumber: Int?
    /// Send notification email to registrants when the host updates a webinar.
    public var isNotifyRegistrants: Bool?
    /// Zoom will open a survey page in attendees' browsers after leaving the webinar
    public var isPostWebinarSurvey: Bool?
    /// Survey url for post webinar survey
    public var surveyURL: String?
    /// Send email notifications to registrants about approval, cancellation, denial of the registration. The value of this field must be set to true in order to use the `registrants_confirmation_email` field.
    public var isRegistrantsEmailNotification: Bool?
    /// `true`- Only authenticated users can join Webinar.
    public var isMeetingAuthentication: Bool?
    /// Webinar authentication option id.
    public var authenticationOption: String?
    /// If user has configured ["Sign Into Zoom with Specified Domains"](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
    public var authenticationDomains: String?
    /// Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
    public var authenticationName: String?
    /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
    public var questionAndAnswer: QuestionAndAnswer?
    /// Set the email language to one of the following:
    /// `en-US`,`de-DE`,`es-ES`,`fr-FR`,`jp-JP`,`pt-PT`,`ru-RU`,`zh-CN`, `zh-TW`, `ko-KO`, `it-IT`, `vi-VN`.
    public var emailLanguage: String?
    /// * `true`: Send invitation email to panelists.
    /// 
    /// * `false`: Do not send invitation email to panelists.
    public var isPanelistsInvitationEmailNotification: Bool?
    /// Send reminder email to attendees and panelists.
    public var attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification?
    /// Send follow-up email to attendees.
    public var followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification?
    /// Send follow-up email to absentees.
    public var followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification?
    /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
    /// 
    /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
    public var languageInterpretation: LanguageInterpretation?

    /// Determine how participants can join the audio portion of the webinar.
    public enum Audio: String, Codable, CaseIterable {
        case both
        case telephony
        case voip
    }

    /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
    public enum AutoRecording: String, Codable, CaseIterable {
        case local
        case cloud
        case `none`
    }

    /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
    public struct QuestionAndAnswer: Codable {
        /// * `true`: Enable [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
        /// 
        /// * `false`: Disable Q&A for webinar.
        public var enable: Bool?
        /// * `true`: Allow participants to send questions without providing their name to the host, co-host, and panelists..
        /// 
        /// * `false`: Do not allow anonymous questions.
        public var allowAnonymousQuestions: Bool?
        /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
        /// 
        /// * `only`: Attendees are able to view answered questions only.
        /// 
        /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
        public var answerQuestions: AnswerQuestions?
        /// * `true`: Attendees can click the thumbs up button to bring popular questions to the top of the Q&A window.
        /// 
        /// * `false`: Attendees can not click the thumbs up button on questions.
        public var attendeesCanUpvote: Bool?
        /// * `true`: Attendees can answer questions or leave a comment in the question thread.
        /// 
        /// * `false`: Attendees can not answer questions or leave a comment in the question thread
        public var attendeesCanComment: Bool?

        /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
        /// 
        /// * `only`: Attendees are able to view answered questions only.
        /// 
        /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
        public enum AnswerQuestions: String, Codable, CaseIterable {
            case only
            case all
        }

        public init(enable: Bool? = nil, allowAnonymousQuestions: Bool? = nil, answerQuestions: AnswerQuestions? = nil, attendeesCanUpvote: Bool? = nil, attendeesCanComment: Bool? = nil) {
            self.enable = enable
            self.allowAnonymousQuestions = allowAnonymousQuestions
            self.answerQuestions = answerQuestions
            self.attendeesCanUpvote = attendeesCanUpvote
            self.attendeesCanComment = attendeesCanComment
        }

        private enum CodingKeys: String, CodingKey {
            case enable
            case allowAnonymousQuestions = "allow_anonymous_questions"
            case answerQuestions = "answer_questions"
            case attendeesCanUpvote = "attendees_can_upvote"
            case attendeesCanComment = "attendees_can_comment"
        }
    }

    /// Send reminder email to attendees and panelists.
    public struct AttendeesAndPanelistsReminderEmailNotification: Codable {
        /// * `true`: Send reminder email to attendees and panelists.
        /// 
        /// * `false`: Do not send reminder email to attendees and panelists.
        public var enable: Bool?
        /// `0` - No plan.<br>`1` - Send 1 hour before webinar.<br>`2` - Send 1 day before webinar.<br>`3` - Send 1 hour and 1 day before webinar.<br>`4` - Send 1 week before webinar.<br>`5` - Send 1 hour and 1 week before webinar.<br>`6` - Send 1 day and 1 week before webinar.<br>`7` - Send 1 hour, 1 day and 1 week before webinar.
        public var type: Int?

        public init(enable: Bool? = nil, type: Int? = nil) {
            self.enable = enable
            self.type = type
        }
    }

    /// Send follow-up email to attendees.
    public struct FollowUpAttendeesEmailNotification: Codable {
        /// * `true`: Send follow-up email to attendees.
        /// 
        /// * `false`: Do not send follow-up email to attendees.
        public var enable: Bool?
        /// `0` - No plan.<br>`1` - Send 1 day after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
        public var type: Int?

        public init(enable: Bool? = nil, type: Int? = nil) {
            self.enable = enable
            self.type = type
        }
    }

    /// Send follow-up email to absentees.
    public struct FollowUpAbsenteesEmailNotification: Codable {
        /// * `true`: Send follow-up email to absentees.
        /// 
        /// * `false`: Do not send follow-up email to absentees.
        public var enable: Bool?
        /// `0` - No plan.<br>`1` - Send 1 days after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
        public var type: Int?

        public init(enable: Bool? = nil, type: Int? = nil) {
            self.enable = enable
            self.type = type
        }
    }

    /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
    /// 
    /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
    public struct LanguageInterpretation: Codable {
        /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the webinar.
        public var enable: Bool?
        /// Information about the webinar's language interpreters.
        public var interpreters: [Interpreter]?

        public struct Interpreter: Codable {
            /// The interpreter's email address.
            public var email: String?
            /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
            /// 
            /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
            public var languages: String?

            public init(email: String? = nil, languages: String? = nil) {
                self.email = email
                self.languages = languages
            }
        }

        public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
            self.enable = enable
            self.interpreters = interpreters
        }
    }

    public init(isHostVideo: Bool? = nil, isPanelistsVideo: Bool? = nil, isPracticeSession: Bool? = nil, isHdVideo: Bool? = nil, isHdVideoForAttendees: Bool? = nil, isSend1080pVideoToAttendees: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, enforceLogin: Bool? = nil, enforceLoginDomains: String? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, isOnDemand: Bool? = nil, globalDialInCountries: [String]? = nil, contactName: String? = nil, contactEmail: String? = nil, isRegistrantsConfirmationEmail: Bool? = nil, registrantsRestrictNumber: Int? = nil, isNotifyRegistrants: Bool? = nil, isPostWebinarSurvey: Bool? = nil, surveyURL: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, authenticationName: String? = nil, questionAndAnswer: QuestionAndAnswer? = nil, emailLanguage: String? = nil, isPanelistsInvitationEmailNotification: Bool? = nil, attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification? = nil, followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification? = nil, followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification? = nil, languageInterpretation: LanguageInterpretation? = nil) {
        self.isHostVideo = isHostVideo
        self.isPanelistsVideo = isPanelistsVideo
        self.isPracticeSession = isPracticeSession ?? false
        self.isHdVideo = isHdVideo ?? false
        self.isHdVideoForAttendees = isHdVideoForAttendees ?? false
        self.isSend1080pVideoToAttendees = isSend1080pVideoToAttendees ?? false
        self.approvalType = approvalType
        self.registrationType = registrationType
        self.audio = audio
        self.autoRecording = autoRecording
        self.enforceLogin = enforceLogin
        self.enforceLoginDomains = enforceLoginDomains
        self.alternativeHosts = alternativeHosts
        self.isCloseRegistration = isCloseRegistration
        self.isShowShareButton = isShowShareButton
        self.allowMultipleDevices = allowMultipleDevices
        self.isOnDemand = isOnDemand ?? false
        self.globalDialInCountries = globalDialInCountries
        self.contactName = contactName
        self.contactEmail = contactEmail
        self.isRegistrantsConfirmationEmail = isRegistrantsConfirmationEmail
        self.registrantsRestrictNumber = registrantsRestrictNumber
        self.isNotifyRegistrants = isNotifyRegistrants
        self.isPostWebinarSurvey = isPostWebinarSurvey
        self.surveyURL = surveyURL
        self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
        self.isMeetingAuthentication = isMeetingAuthentication
        self.authenticationOption = authenticationOption
        self.authenticationDomains = authenticationDomains
        self.authenticationName = authenticationName
        self.questionAndAnswer = questionAndAnswer
        self.emailLanguage = emailLanguage
        self.isPanelistsInvitationEmailNotification = isPanelistsInvitationEmailNotification
        self.attendeesAndPanelistsReminderEmailNotification = attendeesAndPanelistsReminderEmailNotification
        self.followUpAttendeesEmailNotification = followUpAttendeesEmailNotification
        self.followUpAbsenteesEmailNotification = followUpAbsenteesEmailNotification
        self.languageInterpretation = languageInterpretation
    }

    private enum CodingKeys: String, CodingKey {
        case isHostVideo = "host_video"
        case isPanelistsVideo = "panelists_video"
        case isPracticeSession = "practice_session"
        case isHdVideo = "hd_video"
        case isHdVideoForAttendees = "hd_video_for_attendees"
        case isSend1080pVideoToAttendees = "send_1080p_video_to_attendees"
        case approvalType = "approval_type"
        case registrationType = "registration_type"
        case audio
        case autoRecording = "auto_recording"
        case enforceLogin = "enforce_login"
        case enforceLoginDomains = "enforce_login_domains"
        case alternativeHosts = "alternative_hosts"
        case isCloseRegistration = "close_registration"
        case isShowShareButton = "show_share_button"
        case allowMultipleDevices = "allow_multiple_devices"
        case isOnDemand = "on_demand"
        case globalDialInCountries = "global_dial_in_countries"
        case contactName = "contact_name"
        case contactEmail = "contact_email"
        case isRegistrantsConfirmationEmail = "registrants_confirmation_email"
        case registrantsRestrictNumber = "registrants_restrict_number"
        case isNotifyRegistrants = "notify_registrants"
        case isPostWebinarSurvey = "post_webinar_survey"
        case surveyURL = "survey_url"
        case isRegistrantsEmailNotification = "registrants_email_notification"
        case isMeetingAuthentication = "meeting_authentication"
        case authenticationOption = "authentication_option"
        case authenticationDomains = "authentication_domains"
        case authenticationName = "authentication_name"
        case questionAndAnswer = "question_and_answer"
        case emailLanguage = "email_language"
        case isPanelistsInvitationEmailNotification = "panelists_invitation_email_notification"
        case attendeesAndPanelistsReminderEmailNotification = "attendees_and_panelists_reminder_email_notification"
        case followUpAttendeesEmailNotification = "follow_up_attendees_email_notification"
        case followUpAbsenteesEmailNotification = "follow_up_absentees_email_notification"
        case languageInterpretation = "language_interpretation"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isHostVideo = try values.decodeIfPresent(Bool.self, forKey: .isHostVideo)
        self.isPanelistsVideo = try values.decodeIfPresent(Bool.self, forKey: .isPanelistsVideo)
        self.isPracticeSession = try values.decodeIfPresent(Bool.self, forKey: .isPracticeSession) ?? false
        self.isHdVideo = try values.decodeIfPresent(Bool.self, forKey: .isHdVideo) ?? false
        self.isHdVideoForAttendees = try values.decodeIfPresent(Bool.self, forKey: .isHdVideoForAttendees) ?? false
        self.isSend1080pVideoToAttendees = try values.decodeIfPresent(Bool.self, forKey: .isSend1080pVideoToAttendees) ?? false
        self.approvalType = try values.decodeIfPresent(Int.self, forKey: .approvalType)
        self.registrationType = try values.decodeIfPresent(Int.self, forKey: .registrationType)
        self.audio = try values.decodeIfPresent(Audio.self, forKey: .audio)
        self.autoRecording = try values.decodeIfPresent(AutoRecording.self, forKey: .autoRecording)
        self.enforceLogin = try values.decodeIfPresent(Bool.self, forKey: .enforceLogin)
        self.enforceLoginDomains = try values.decodeIfPresent(String.self, forKey: .enforceLoginDomains)
        self.alternativeHosts = try values.decodeIfPresent(String.self, forKey: .alternativeHosts)
        self.isCloseRegistration = try values.decodeIfPresent(Bool.self, forKey: .isCloseRegistration)
        self.isShowShareButton = try values.decodeIfPresent(Bool.self, forKey: .isShowShareButton)
        self.allowMultipleDevices = try values.decodeIfPresent(Bool.self, forKey: .allowMultipleDevices)
        self.isOnDemand = try values.decodeIfPresent(Bool.self, forKey: .isOnDemand) ?? false
        self.globalDialInCountries = try values.decodeIfPresent([String].self, forKey: .globalDialInCountries)
        self.contactName = try values.decodeIfPresent(String.self, forKey: .contactName)
        self.contactEmail = try values.decodeIfPresent(String.self, forKey: .contactEmail)
        self.isRegistrantsConfirmationEmail = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsConfirmationEmail)
        self.registrantsRestrictNumber = try values.decodeIfPresent(Int.self, forKey: .registrantsRestrictNumber)
        self.isNotifyRegistrants = try values.decodeIfPresent(Bool.self, forKey: .isNotifyRegistrants)
        self.isPostWebinarSurvey = try values.decodeIfPresent(Bool.self, forKey: .isPostWebinarSurvey)
        self.surveyURL = try values.decodeIfPresent(String.self, forKey: .surveyURL)
        self.isRegistrantsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsEmailNotification)
        self.isMeetingAuthentication = try values.decodeIfPresent(Bool.self, forKey: .isMeetingAuthentication)
        self.authenticationOption = try values.decodeIfPresent(String.self, forKey: .authenticationOption)
        self.authenticationDomains = try values.decodeIfPresent(String.self, forKey: .authenticationDomains)
        self.authenticationName = try values.decodeIfPresent(String.self, forKey: .authenticationName)
        self.questionAndAnswer = try values.decodeIfPresent(QuestionAndAnswer.self, forKey: .questionAndAnswer)
        self.emailLanguage = try values.decodeIfPresent(String.self, forKey: .emailLanguage)
        self.isPanelistsInvitationEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isPanelistsInvitationEmailNotification)
        self.attendeesAndPanelistsReminderEmailNotification = try values.decodeIfPresent(AttendeesAndPanelistsReminderEmailNotification.self, forKey: .attendeesAndPanelistsReminderEmailNotification)
        self.followUpAttendeesEmailNotification = try values.decodeIfPresent(FollowUpAttendeesEmailNotification.self, forKey: .followUpAttendeesEmailNotification)
        self.followUpAbsenteesEmailNotification = try values.decodeIfPresent(FollowUpAbsenteesEmailNotification.self, forKey: .followUpAbsenteesEmailNotification)
        self.languageInterpretation = try values.decodeIfPresent(LanguageInterpretation.self, forKey: .languageInterpretation)
    }
}

/// Webinar panelist.
public struct WebinarPanelistList: Codable {
    /// Total records.
    public var totalRecords: Int?
    /// List of panelist objects.
    public var panelists: [Panelist]?

    public struct Panelist: Codable {
        /// Panelist's ID.
        public var id: String?
        /// The panelist's full name.
        /// 
        /// **Note:** This value cannot exceed more than 12 Chinese characters.
        public var name: String?
        /// Panelist's email.
        public var email: String?
        /// Join URL.
        public var joinURL: String?

        public init(id: String? = nil, name: String? = nil, email: String? = nil, joinURL: String? = nil) {
            self.id = id
            self.name = name
            self.email = email
            self.joinURL = joinURL
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.email = try values.decodeIfPresent(String.self, forKey: "email")
            self.joinURL = try values.decodeIfPresent(String.self, forKey: "join_url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(email, forKey: "email")
            try values.encodeIfPresent(joinURL, forKey: "join_url")
        }
    }

    public init(totalRecords: Int? = nil, panelists: [Panelist]? = nil) {
        self.totalRecords = totalRecords
        self.panelists = panelists
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.totalRecords = try values.decodeIfPresent(Int.self, forKey: "total_records")
        self.panelists = try values.decodeIfPresent([Panelist].self, forKey: "panelists")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(totalRecords, forKey: "total_records")
        try values.encodeIfPresent(panelists, forKey: "panelists")
    }
}

/// Registration List
///
/// List of users.
public struct WebinarRegistrantList: Codable {
    /// The number of pages returned for the request made.
    public var pageCount: Int?
    /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
    public var pageNumber: Int?
    /// The number of records returned with a single API call.
    public var pageSize: Int?
    /// The total number of all the records available across pages.
    public var totalRecords: Int?
    /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
    public var nextPageToken: String?
    /// List of registrant objects.
    public var registrants: [Registrant]?

    public struct Registrant: Codable {
        /// Registrant ID.
        public var id: String?
        /// Registrant.
        public var b: B
        /// The status of the registrant's registration. <br> `approved`: User has been successfully approved for the webinar.<br> `pending`:  The registration is still pending.<br> `denied`: User has been denied from joining the webinar.
        public var status: String?
        /// The time at which the registrant registered.
        public var createTime: Date?
        /// The URL using which an approved registrant can join the webinar.
        public var joinURL: String?

        /// Registrant.
        public struct B: Codable {
            /// The registrant's email address.
            public var email: String
            /// The registrant's status: 
            /// * `approved` — Registrant is approved. 
            /// * `denied` — Registrant is denied. 
            /// * `pending` — Registrant is waiting for approval.
            public var status: Status?
            /// The registrant's first name.
            public var firstName: String
            /// The registrant's last name.
            public var lastName: String?
            /// The registrant's address.
            public var address: String?
            /// The registrant's city.
            public var city: String?
            /// The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
            public var country: String?
            /// The registrant's ZIP or postal code.
            public var zip: String?
            /// The registrant's state or province.
            public var state: String?
            /// The registrant's phone number.
            public var phone: String?
            /// The registrant's industry.
            public var industry: String?
            /// The registrant's organization.
            public var org: String?
            /// The registrant's job title.
            public var jobTitle: String?
            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public var purchasingTimeFrame: PurchasingTimeFrame?
            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public var roleInPurchaseProcess: RoleInPurchaseProcess?
            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public var noOfEmployees: NoOfEmployees?
            /// The registrant's questions and comments.
            public var comments: String?
            /// Information about custom questions.
            public var customQuestions: [CustomQuestion]?

            /// The registrant's status: 
            /// * `approved` — Registrant is approved. 
            /// * `denied` — Registrant is denied. 
            /// * `pending` — Registrant is waiting for approval.
            public enum Status: String, Codable, CaseIterable {
                case approved
                case denied
                case pending
            }

            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public enum PurchasingTimeFrame: String, Codable, CaseIterable {
                case empty = ""
                case withinAMonth = "Within a month"
                case _13Months = "1-3 months"
                case _46Months = "4-6 months"
                case moreThan6Months = "More than 6 months"
                case noTimeframe = "No timeframe"
            }

            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public enum RoleInPurchaseProcess: String, Codable, CaseIterable {
                case empty = ""
                case decisionMaker = "Decision Maker"
                case evaluatorRecommender = "Evaluator/Recommender"
                case influencer = "Influencer"
                case notInvolved = "Not involved"
            }

            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public enum NoOfEmployees: String, Codable, CaseIterable {
                case empty = ""
                case _120 = "1-20"
                case _2150 = "21-50"
                case _51100 = "51-100"
                case _101500 = "101-500"
                case _5001000 = "500-1,000"
                case _10015000 = "1,001-5,000"
                case _500110000 = "5,001-10,000"
                case moreThan10000 = "More than 10,000"
            }

            /// Information about custom questions.
            public struct CustomQuestion: Codable {
                /// The title of the custom question.
                public var title: String?
                /// The custom question's response value. This has a limit of 128 characters.
                public var value: String?

                public init(title: String? = nil, value: String? = nil) {
                    self.title = title
                    self.value = value
                }
            }

            public init(email: String, status: Status? = nil, firstName: String, lastName: String? = nil, address: String? = nil, city: String? = nil, country: String? = nil, zip: String? = nil, state: String? = nil, phone: String? = nil, industry: String? = nil, org: String? = nil, jobTitle: String? = nil, purchasingTimeFrame: PurchasingTimeFrame? = nil, roleInPurchaseProcess: RoleInPurchaseProcess? = nil, noOfEmployees: NoOfEmployees? = nil, comments: String? = nil, customQuestions: [CustomQuestion]? = nil) {
                self.email = email
                self.status = status
                self.firstName = firstName
                self.lastName = lastName
                self.address = address
                self.city = city
                self.country = country
                self.zip = zip
                self.state = state
                self.phone = phone
                self.industry = industry
                self.org = org
                self.jobTitle = jobTitle
                self.purchasingTimeFrame = purchasingTimeFrame
                self.roleInPurchaseProcess = roleInPurchaseProcess
                self.noOfEmployees = noOfEmployees
                self.comments = comments
                self.customQuestions = customQuestions
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.email = try values.decode(String.self, forKey: "email")
                self.status = try Status(from: decoder)
                self.firstName = try values.decode(String.self, forKey: "first_name")
                self.lastName = try values.decodeIfPresent(String.self, forKey: "last_name")
                self.address = try values.decodeIfPresent(String.self, forKey: "address")
                self.city = try values.decodeIfPresent(String.self, forKey: "city")
                self.country = try values.decodeIfPresent(String.self, forKey: "country")
                self.zip = try values.decodeIfPresent(String.self, forKey: "zip")
                self.state = try values.decodeIfPresent(String.self, forKey: "state")
                self.phone = try values.decodeIfPresent(String.self, forKey: "phone")
                self.industry = try values.decodeIfPresent(String.self, forKey: "industry")
                self.org = try values.decodeIfPresent(String.self, forKey: "org")
                self.jobTitle = try values.decodeIfPresent(String.self, forKey: "job_title")
                self.purchasingTimeFrame = try PurchasingTimeFrame(from: decoder)
                self.roleInPurchaseProcess = try RoleInPurchaseProcess(from: decoder)
                self.noOfEmployees = try NoOfEmployees(from: decoder)
                self.comments = try values.decodeIfPresent(String.self, forKey: "comments")
                self.customQuestions = try values.decodeIfPresent([CustomQuestion].self, forKey: "custom_questions")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(email, forKey: "email")
                try values.encodeIfPresent(status, forKey: "status")
                try values.encode(firstName, forKey: "first_name")
                try values.encodeIfPresent(lastName, forKey: "last_name")
                try values.encodeIfPresent(address, forKey: "address")
                try values.encodeIfPresent(city, forKey: "city")
                try values.encodeIfPresent(country, forKey: "country")
                try values.encodeIfPresent(zip, forKey: "zip")
                try values.encodeIfPresent(state, forKey: "state")
                try values.encodeIfPresent(phone, forKey: "phone")
                try values.encodeIfPresent(industry, forKey: "industry")
                try values.encodeIfPresent(org, forKey: "org")
                try values.encodeIfPresent(jobTitle, forKey: "job_title")
                try values.encodeIfPresent(purchasingTimeFrame, forKey: "purchasing_time_frame")
                try values.encodeIfPresent(roleInPurchaseProcess, forKey: "role_in_purchase_process")
                try values.encodeIfPresent(noOfEmployees, forKey: "no_of_employees")
                try values.encodeIfPresent(comments, forKey: "comments")
                try values.encodeIfPresent(customQuestions, forKey: "custom_questions")
            }
        }

        public init(id: String? = nil, b: B, status: String? = nil, createTime: Date? = nil, joinURL: String? = nil) {
            self.id = id
            self.b = b
            self.status = status
            self.createTime = createTime
            self.joinURL = joinURL
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.b = try B(from: decoder)
            self.status = try values.decodeIfPresent(String.self, forKey: "status")
            self.createTime = try values.decodeIfPresent(Date.self, forKey: "create_time")
            self.joinURL = try values.decodeIfPresent(String.self, forKey: "join_url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encode(b, forKey: "b")
            try values.encodeIfPresent(status, forKey: "status")
            try values.encodeIfPresent(createTime, forKey: "create_time")
            try values.encodeIfPresent(joinURL, forKey: "join_url")
        }
    }

    public init(pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil, registrants: [Registrant]? = nil) {
        self.pageCount = pageCount
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.totalRecords = totalRecords
        self.nextPageToken = nextPageToken
        self.registrants = registrants
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.pageCount = try values.decodeIfPresent(Int.self, forKey: "page_count")
        self.pageNumber = try values.decodeIfPresent(Int.self, forKey: "page_number")
        self.pageSize = try values.decodeIfPresent(Int.self, forKey: "page_size")
        self.totalRecords = try values.decodeIfPresent(Int.self, forKey: "total_records")
        self.nextPageToken = try values.decodeIfPresent(String.self, forKey: "next_page_token")
        self.registrants = try values.decodeIfPresent([Registrant].self, forKey: "registrants")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(pageCount, forKey: "page_count")
        try values.encodeIfPresent(pageNumber, forKey: "page_number")
        try values.encodeIfPresent(pageSize, forKey: "page_size")
        try values.encodeIfPresent(totalRecords, forKey: "total_records")
        try values.encodeIfPresent(nextPageToken, forKey: "next_page_token")
        try values.encodeIfPresent(registrants, forKey: "registrants")
    }
}

/// List of panelists.
public struct PanelistList: Codable {
    /// Total records.
    public var totalRecords: Int?
    /// List of panelist objects.
    public var panelists: [Panelist]?

    public struct Panelist: Codable {
        /// Panelist's ID.
        public var id: String?
        /// The panelist's full name.
        /// 
        /// **Note:** This value cannot exceed more than 12 Chinese characters.
        public var name: String?
        /// Panelist's email.
        public var email: String?
        /// Join URL.
        public var joinURL: String?

        public init(id: String? = nil, name: String? = nil, email: String? = nil, joinURL: String? = nil) {
            self.id = id
            self.name = name
            self.email = email
            self.joinURL = joinURL
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.email = try values.decodeIfPresent(String.self, forKey: "email")
            self.joinURL = try values.decodeIfPresent(String.self, forKey: "join_url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(email, forKey: "email")
            try values.encodeIfPresent(joinURL, forKey: "join_url")
        }
    }

    public init(totalRecords: Int? = nil, panelists: [Panelist]? = nil) {
        self.totalRecords = totalRecords
        self.panelists = panelists
    }

    private enum CodingKeys: String, CodingKey {
        case totalRecords = "total_records"
        case panelists
    }
}

public struct Webinar: Codable {
    /// Webinar UUID.
    public var uuid: String?
    /// Start time.
    public var startTime: Date?

    public init(uuid: String? = nil, startTime: Date? = nil) {
        self.uuid = uuid
        self.startTime = startTime
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
        self.startTime = try values.decodeIfPresent(Date.self, forKey: "start_time")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(uuid, forKey: "uuid")
        try values.encodeIfPresent(startTime, forKey: "start_time")
    }
}

/// Create Webinar settings.
public struct CreateWebinarSettings: Codable {
    /// Start video when host joins webinar.
    public var isHostVideo: Bool?
    /// Start video when panelists join webinar.
    public var isPanelistsVideo: Bool?
    /// Enable practice session.
    public var isPracticeSession: Bool
    /// Default to HD video.
    public var isHdVideo: Bool
    /// Whether HD video for attendees is enabled. This value defaults to `false`.
    public var isHdVideoForAttendees: Bool
    /// Whether to always send 1080p video to attendees. This value defaults to `false`.
    public var isSend1080pVideoToAttendees: Bool
    /// The default value is `2`. To enable registration required, set the approval type to `0` or `1`.  Values include:<br>
    /// 
    /// `0` - Automatically approve.<br>`1` - Manually approve.<br>`2` - No registration required.
    public var approvalType: Int?
    /// Registration types. Only used for recurring webinars with a fixed time.<br>`1` - Attendees register once and can attend any of the webinar sessions.<br>`2` - Attendees need to register for each session in order to attend.<br>`3` - Attendees register once and can choose one or more sessions to attend.
    public var registrationType: Int?
    /// Determine how participants can join the audio portion of the meeting.
    public var audio: Audio?
    /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
    public var autoRecording: AutoRecording?
    /// Only signed-in users can join this meeting. 
    /// 
    /// **This field is deprecated and will not be supported in future.** <br><br> Instead of this field, use the "meeting_authentication", "authentication_option" and/or "authentication_domains" fields to establish the authentication mechanism for this Webinar.
    public var enforceLogin: Bool?
    /// Only signed-in users with specified domains can join meetings.
    /// 
    /// **This field is deprecated and will not be supported in future.** <br><br> Instead of this field, use the "authentication_domains" field for this Webinar.
    public var enforceLoginDomains: String?
    /// Alternative host emails or IDs. Multiple values separated by comma.
    public var alternativeHosts: String?
    /// Close registration after event date.
    public var isCloseRegistration: Bool?
    /// Show social share buttons on the registration page.
    public var isShowShareButton: Bool?
    /// Allow attendees to join from multiple devices.
    public var allowMultipleDevices: Bool?
    /// Make the webinar on-demand
    public var isOnDemand: Bool
    /// List of global dial-in countries
    public var globalDialInCountries: [String]?
    /// Contact name for registration
    public var contactName: String?
    /// Contact email for registration
    public var contactEmail: String?
    /// Restrict number of registrants for a webinar. By default, it is set to `0`. A `0` value means that the restriction option is disabled. Provide a number higher than 0 to restrict the webinar registrants by the that number.
    public var registrantsRestrictNumber: Int?
    /// Zoom will open a survey page in attendees' browsers after leaving the webinar
    public var isPostWebinarSurvey: Bool?
    /// Survey url for post webinar survey
    public var surveyURL: String?
    /// Send email notifications to registrants about approval, cancellation, denial of the registration. The value of this field must be set to true in order to use the `registrants_confirmation_email` field.
    public var isRegistrantsEmailNotification: Bool?
    /// Only [authenticated](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) users can join meeting if the value of this field is set to `true`.
    public var isMeetingAuthentication: Bool?
    /// Specify the authentication type for users to join a Webinar with`meeting_authentication` setting set to `true`. The value of this field can be retrieved from the `id` field within `authentication_options` array in the response of [Get User Settings API](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings).
    public var authenticationOption: String?
    /// Meeting authentication domains. This option, allows you to specify the rule so that Zoom users, whose email address contains a certain domain, can join the Webinar. You can either provide multiple domains, using a comma in between and/or use a wildcard for listing domains.
    public var authenticationDomains: String?
    /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
    public var questionAndAnswer: QuestionAndAnswer?
    /// Set the email language to one of the following:
    /// `en-US`,`de-DE`,`es-ES`,`fr-FR`,`jp-JP`,`pt-PT`,`ru-RU`,`zh-CN`, `zh-TW`, `ko-KO`, `it-IT`, `vi-VN`.
    public var emailLanguage: String?
    /// * `true`: Send invitation email to panelists.
    /// 
    /// * `false`: Do not send invitation email to panelists.
    public var isPanelistsInvitationEmailNotification: Bool?
    /// Send reminder email to attendees and panelists.
    public var attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification?
    /// Send follow-up email to attendees.
    public var followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification?
    /// Send follow-up email to absentees.
    public var followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification?
    /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
    /// 
    /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
    public var languageInterpretation: LanguageInterpretation?

    /// Determine how participants can join the audio portion of the meeting.
    public enum Audio: String, Codable, CaseIterable {
        case both
        case telephony
        case voip
    }

    /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
    public enum AutoRecording: String, Codable, CaseIterable {
        case local
        case cloud
        case `none`
    }

    /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
    public struct QuestionAndAnswer: Codable {
        /// * `true`: Enable [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
        /// 
        /// * `false`: Disable Q&A for webinar.
        public var enable: Bool?
        /// * `true`: Allow participants to send questions without providing their name to the host, co-host, and panelists..
        /// 
        /// * `false`: Do not allow anonymous questions.
        public var allowAnonymousQuestions: Bool?
        /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
        /// 
        /// * `only`: Attendees are able to view answered questions only.
        /// 
        /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
        public var answerQuestions: AnswerQuestions?
        /// * `true`: Attendees can click the thumbs up button to bring popular questions to the top of the Q&A window.
        /// 
        /// * `false`: Attendees can not click the thumbs up button on questions.
        public var attendeesCanUpvote: Bool?
        /// * `true`: Attendees can answer questions or leave a comment in the question thread.
        /// 
        /// * `false`: Attendees can not answer questions or leave a comment in the question thread
        public var attendeesCanComment: Bool?

        /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
        /// 
        /// * `only`: Attendees are able to view answered questions only.
        /// 
        /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
        public enum AnswerQuestions: String, Codable, CaseIterable {
            case only
            case all
        }

        public init(enable: Bool? = nil, allowAnonymousQuestions: Bool? = nil, answerQuestions: AnswerQuestions? = nil, attendeesCanUpvote: Bool? = nil, attendeesCanComment: Bool? = nil) {
            self.enable = enable
            self.allowAnonymousQuestions = allowAnonymousQuestions
            self.answerQuestions = answerQuestions
            self.attendeesCanUpvote = attendeesCanUpvote
            self.attendeesCanComment = attendeesCanComment
        }

        private enum CodingKeys: String, CodingKey {
            case enable
            case allowAnonymousQuestions = "allow_anonymous_questions"
            case answerQuestions = "answer_questions"
            case attendeesCanUpvote = "attendees_can_upvote"
            case attendeesCanComment = "attendees_can_comment"
        }
    }

    /// Send reminder email to attendees and panelists.
    public struct AttendeesAndPanelistsReminderEmailNotification: Codable {
        /// * `true`: Send reminder email to attendees and panelists.
        /// 
        /// * `false`: Do not send reminder email to attendees and panelists.
        public var enable: Bool?
        /// `0` - No plan.<br>`1` - Send 1 hour before webinar.<br>`2` - Send 1 day before webinar.<br>`3` - Send 1 hour and 1 day before webinar.<br>`4` - Send 1 week before webinar.<br>`5` - Send 1 hour and 1 week before webinar.<br>`6` - Send 1 day and 1 week before webinar.<br>`7` - Send 1 hour, 1 day and 1 week before webinar.
        public var type: Int?

        public init(enable: Bool? = nil, type: Int? = nil) {
            self.enable = enable
            self.type = type
        }
    }

    /// Send follow-up email to attendees.
    public struct FollowUpAttendeesEmailNotification: Codable {
        /// * `true`: Send follow-up email to attendees.
        /// 
        /// * `false`: Do not send follow-up email to attendees.
        public var enable: Bool?
        /// `0` - No plan.<br>`1` - Send 1 day after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
        public var type: Int?

        public init(enable: Bool? = nil, type: Int? = nil) {
            self.enable = enable
            self.type = type
        }
    }

    /// Send follow-up email to absentees.
    public struct FollowUpAbsenteesEmailNotification: Codable {
        /// * `true`: Send follow-up email to absentees.
        /// 
        /// * `false`: Do not send follow-up email to absentees.
        public var enable: Bool?
        /// `0` - No plan.<br>`1` - Send 1 days after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
        public var type: Int?

        public init(enable: Bool? = nil, type: Int? = nil) {
            self.enable = enable
            self.type = type
        }
    }

    /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
    /// 
    /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
    public struct LanguageInterpretation: Codable {
        /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the webinar.
        public var enable: Bool?
        /// Information about the webinar's language interpreters.
        public var interpreters: [Interpreter]?

        public struct Interpreter: Codable {
            /// The interpreter's email address.
            public var email: String?
            /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
            /// 
            /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
            public var languages: String?

            public init(email: String? = nil, languages: String? = nil) {
                self.email = email
                self.languages = languages
            }
        }

        public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
            self.enable = enable
            self.interpreters = interpreters
        }
    }

    public init(isHostVideo: Bool? = nil, isPanelistsVideo: Bool? = nil, isPracticeSession: Bool? = nil, isHdVideo: Bool? = nil, isHdVideoForAttendees: Bool? = nil, isSend1080pVideoToAttendees: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, enforceLogin: Bool? = nil, enforceLoginDomains: String? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, isOnDemand: Bool? = nil, globalDialInCountries: [String]? = nil, contactName: String? = nil, contactEmail: String? = nil, registrantsRestrictNumber: Int? = nil, isPostWebinarSurvey: Bool? = nil, surveyURL: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, questionAndAnswer: QuestionAndAnswer? = nil, emailLanguage: String? = nil, isPanelistsInvitationEmailNotification: Bool? = nil, attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification? = nil, followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification? = nil, followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification? = nil, languageInterpretation: LanguageInterpretation? = nil) {
        self.isHostVideo = isHostVideo
        self.isPanelistsVideo = isPanelistsVideo
        self.isPracticeSession = isPracticeSession ?? false
        self.isHdVideo = isHdVideo ?? false
        self.isHdVideoForAttendees = isHdVideoForAttendees ?? false
        self.isSend1080pVideoToAttendees = isSend1080pVideoToAttendees ?? false
        self.approvalType = approvalType
        self.registrationType = registrationType
        self.audio = audio
        self.autoRecording = autoRecording
        self.enforceLogin = enforceLogin
        self.enforceLoginDomains = enforceLoginDomains
        self.alternativeHosts = alternativeHosts
        self.isCloseRegistration = isCloseRegistration
        self.isShowShareButton = isShowShareButton
        self.allowMultipleDevices = allowMultipleDevices
        self.isOnDemand = isOnDemand ?? false
        self.globalDialInCountries = globalDialInCountries
        self.contactName = contactName
        self.contactEmail = contactEmail
        self.registrantsRestrictNumber = registrantsRestrictNumber
        self.isPostWebinarSurvey = isPostWebinarSurvey
        self.surveyURL = surveyURL
        self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
        self.isMeetingAuthentication = isMeetingAuthentication
        self.authenticationOption = authenticationOption
        self.authenticationDomains = authenticationDomains
        self.questionAndAnswer = questionAndAnswer
        self.emailLanguage = emailLanguage
        self.isPanelistsInvitationEmailNotification = isPanelistsInvitationEmailNotification
        self.attendeesAndPanelistsReminderEmailNotification = attendeesAndPanelistsReminderEmailNotification
        self.followUpAttendeesEmailNotification = followUpAttendeesEmailNotification
        self.followUpAbsenteesEmailNotification = followUpAbsenteesEmailNotification
        self.languageInterpretation = languageInterpretation
    }

    private enum CodingKeys: String, CodingKey {
        case isHostVideo = "host_video"
        case isPanelistsVideo = "panelists_video"
        case isPracticeSession = "practice_session"
        case isHdVideo = "hd_video"
        case isHdVideoForAttendees = "hd_video_for_attendees"
        case isSend1080pVideoToAttendees = "send_1080p_video_to_attendees"
        case approvalType = "approval_type"
        case registrationType = "registration_type"
        case audio
        case autoRecording = "auto_recording"
        case enforceLogin = "enforce_login"
        case enforceLoginDomains = "enforce_login_domains"
        case alternativeHosts = "alternative_hosts"
        case isCloseRegistration = "close_registration"
        case isShowShareButton = "show_share_button"
        case allowMultipleDevices = "allow_multiple_devices"
        case isOnDemand = "on_demand"
        case globalDialInCountries = "global_dial_in_countries"
        case contactName = "contact_name"
        case contactEmail = "contact_email"
        case registrantsRestrictNumber = "registrants_restrict_number"
        case isPostWebinarSurvey = "post_webinar_survey"
        case surveyURL = "survey_url"
        case isRegistrantsEmailNotification = "registrants_email_notification"
        case isMeetingAuthentication = "meeting_authentication"
        case authenticationOption = "authentication_option"
        case authenticationDomains = "authentication_domains"
        case questionAndAnswer = "question_and_answer"
        case emailLanguage = "email_language"
        case isPanelistsInvitationEmailNotification = "panelists_invitation_email_notification"
        case attendeesAndPanelistsReminderEmailNotification = "attendees_and_panelists_reminder_email_notification"
        case followUpAttendeesEmailNotification = "follow_up_attendees_email_notification"
        case followUpAbsenteesEmailNotification = "follow_up_absentees_email_notification"
        case languageInterpretation = "language_interpretation"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isHostVideo = try values.decodeIfPresent(Bool.self, forKey: .isHostVideo)
        self.isPanelistsVideo = try values.decodeIfPresent(Bool.self, forKey: .isPanelistsVideo)
        self.isPracticeSession = try values.decodeIfPresent(Bool.self, forKey: .isPracticeSession) ?? false
        self.isHdVideo = try values.decodeIfPresent(Bool.self, forKey: .isHdVideo) ?? false
        self.isHdVideoForAttendees = try values.decodeIfPresent(Bool.self, forKey: .isHdVideoForAttendees) ?? false
        self.isSend1080pVideoToAttendees = try values.decodeIfPresent(Bool.self, forKey: .isSend1080pVideoToAttendees) ?? false
        self.approvalType = try values.decodeIfPresent(Int.self, forKey: .approvalType)
        self.registrationType = try values.decodeIfPresent(Int.self, forKey: .registrationType)
        self.audio = try values.decodeIfPresent(Audio.self, forKey: .audio)
        self.autoRecording = try values.decodeIfPresent(AutoRecording.self, forKey: .autoRecording)
        self.enforceLogin = try values.decodeIfPresent(Bool.self, forKey: .enforceLogin)
        self.enforceLoginDomains = try values.decodeIfPresent(String.self, forKey: .enforceLoginDomains)
        self.alternativeHosts = try values.decodeIfPresent(String.self, forKey: .alternativeHosts)
        self.isCloseRegistration = try values.decodeIfPresent(Bool.self, forKey: .isCloseRegistration)
        self.isShowShareButton = try values.decodeIfPresent(Bool.self, forKey: .isShowShareButton)
        self.allowMultipleDevices = try values.decodeIfPresent(Bool.self, forKey: .allowMultipleDevices)
        self.isOnDemand = try values.decodeIfPresent(Bool.self, forKey: .isOnDemand) ?? false
        self.globalDialInCountries = try values.decodeIfPresent([String].self, forKey: .globalDialInCountries)
        self.contactName = try values.decodeIfPresent(String.self, forKey: .contactName)
        self.contactEmail = try values.decodeIfPresent(String.self, forKey: .contactEmail)
        self.registrantsRestrictNumber = try values.decodeIfPresent(Int.self, forKey: .registrantsRestrictNumber)
        self.isPostWebinarSurvey = try values.decodeIfPresent(Bool.self, forKey: .isPostWebinarSurvey)
        self.surveyURL = try values.decodeIfPresent(String.self, forKey: .surveyURL)
        self.isRegistrantsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsEmailNotification)
        self.isMeetingAuthentication = try values.decodeIfPresent(Bool.self, forKey: .isMeetingAuthentication)
        self.authenticationOption = try values.decodeIfPresent(String.self, forKey: .authenticationOption)
        self.authenticationDomains = try values.decodeIfPresent(String.self, forKey: .authenticationDomains)
        self.questionAndAnswer = try values.decodeIfPresent(QuestionAndAnswer.self, forKey: .questionAndAnswer)
        self.emailLanguage = try values.decodeIfPresent(String.self, forKey: .emailLanguage)
        self.isPanelistsInvitationEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isPanelistsInvitationEmailNotification)
        self.attendeesAndPanelistsReminderEmailNotification = try values.decodeIfPresent(AttendeesAndPanelistsReminderEmailNotification.self, forKey: .attendeesAndPanelistsReminderEmailNotification)
        self.followUpAttendeesEmailNotification = try values.decodeIfPresent(FollowUpAttendeesEmailNotification.self, forKey: .followUpAttendeesEmailNotification)
        self.followUpAbsenteesEmailNotification = try values.decodeIfPresent(FollowUpAbsenteesEmailNotification.self, forKey: .followUpAbsenteesEmailNotification)
        self.languageInterpretation = try values.decodeIfPresent(LanguageInterpretation.self, forKey: .languageInterpretation)
    }
}

/// Webinar Survey Object
///
/// Information about the webinar survey.
public struct WebinarSurvey: Codable {
    /// The link to the third party webinar survey.
    public var thirdPartySurvey: String?
    /// Information about the customized webinar survey.
    public var customSurvey: CustomSurvey?
    /// Whether the **Show the link on the follow-up email** option is enabled: 
    /// * `true` — Enabled. 
    /// * `false` — Disabled. 
    /// 
    ///  This value defaults to `false`.
    public var isShowInTheFollowUpEmail: Bool
    /// Whether the **Show in the browser when the webinar ends** option is enabled: 
    /// * `true` — Enabled. 
    /// * `false` — Disabled. 
    /// 
    ///  This value defaults to `true`.
    public var isShowInTheBrowser: Bool

    /// Information about the customized webinar survey.
    public struct CustomSurvey: Codable {
        /// Whether to allow participants to anonymously answer survey questions: 
        /// * `true` — Anonymous survey enabled. 
        /// * `false` — Participants cannot answer survey questions anonymously. 
        /// 
        ///  This value defaults to `true`.
        public var isAnonymous: Bool
        /// Information about the webinar survey's questions.
        public var questions: [Question]?

        public struct Question: Codable {
            /// The survey question, up to 255 characters.
            public var name: String?
            /// The survey's question and answer type: 
            /// * `single` — Single choice. 
            /// * `mutliple` — Multiple choice. 
            /// * `rating_scale` — Rating scale. 
            /// * `long_answer` — Long answer.
            public var type: `Type`?
            /// Whether to display the radio selection as a drop-down box: 
            /// * `true` — Show as a drop-down box. 
            /// * `false` — Do not show as a drop-down box. 
            /// 
            ///  This value defaults to `false`.
            public var isShowAsDropdown: Bool
            /// Whether participants must answer the question: 
            /// * `true` — The participant must answer the question. 
            /// * `false` — The participant does not need to answer the question. 
            /// 
            ///  This value defaults to `false`.
            public var isAnswerRequired: Bool
            /// The survey question's available answers. This field requires a **minimum** of two answers. 
            /// 
            /// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers. 
            /// * For `matching` polls, you can only provide a maximum of 16 answers. 
            /// * For `rank_order` polls, you can only provide a maximum of seven answers.
            public var answers: [String]?
            /// The allowed minimum number of characters. This field only applies to `long_answer` survey. You must provide at least a **one** character minimum value.
            public var answerMinCharacter: Int?
            /// The allowed maximum number of characters. This field only applies to `long_answer` survey, a maximum of 2,000 characters.
            public var answerMaxCharacter: Int?
            /// The rating scale's minimum value. This value cannot be less than zero. 
            /// 
            ///  This field only applies to the `rating_scale` survey.
            public var ratingMinValue: Int?
            /// The rating scale's maximum value, up to a maximum value of 10. 
            /// 
            ///  This field only applies to the `rating_scale` survey.
            public var ratingMaxValue: Int?
            /// The low score label used for the `rating_min_value` field. 
            /// 
            ///  This field only applies to the `rating_scale` survey.
            public var ratingMinLabel: String?
            /// The high score label used for the `rating_max_value` field. 
            /// 
            ///  This field only applies to the `rating_scale` survey.
            public var ratingMaxLabel: String?

            /// The survey's question and answer type: 
            /// * `single` — Single choice. 
            /// * `mutliple` — Multiple choice. 
            /// * `rating_scale` — Rating scale. 
            /// * `long_answer` — Long answer.
            public enum `Type`: String, Codable, CaseIterable {
                case single
                case multiple
                case ratingScale = "rating_scale"
                case longAnswer = "long_answer"
            }

            public init(name: String? = nil, type: `Type`? = nil, isShowAsDropdown: Bool? = nil, isAnswerRequired: Bool? = nil, answers: [String]? = nil, answerMinCharacter: Int? = nil, answerMaxCharacter: Int? = nil, ratingMinValue: Int? = nil, ratingMaxValue: Int? = nil, ratingMinLabel: String? = nil, ratingMaxLabel: String? = nil) {
                self.name = name
                self.type = type
                self.isShowAsDropdown = isShowAsDropdown ?? false
                self.isAnswerRequired = isAnswerRequired ?? false
                self.answers = answers
                self.answerMinCharacter = answerMinCharacter
                self.answerMaxCharacter = answerMaxCharacter
                self.ratingMinValue = ratingMinValue
                self.ratingMaxValue = ratingMaxValue
                self.ratingMinLabel = ratingMinLabel
                self.ratingMaxLabel = ratingMaxLabel
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case type
                case isShowAsDropdown = "show_as_dropdown"
                case isAnswerRequired = "answer_required"
                case answers
                case answerMinCharacter = "answer_min_character"
                case answerMaxCharacter = "answer_max_character"
                case ratingMinValue = "rating_min_value"
                case ratingMaxValue = "rating_max_value"
                case ratingMinLabel = "rating_min_label"
                case ratingMaxLabel = "rating_max_label"
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: CodingKeys.self)
                self.name = try values.decodeIfPresent(String.self, forKey: .name)
                self.type = try values.decodeIfPresent(`Type`.self, forKey: .type)
                self.isShowAsDropdown = try values.decodeIfPresent(Bool.self, forKey: .isShowAsDropdown) ?? false
                self.isAnswerRequired = try values.decodeIfPresent(Bool.self, forKey: .isAnswerRequired) ?? false
                self.answers = try values.decodeIfPresent([String].self, forKey: .answers)
                self.answerMinCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMinCharacter)
                self.answerMaxCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMaxCharacter)
                self.ratingMinValue = try values.decodeIfPresent(Int.self, forKey: .ratingMinValue)
                self.ratingMaxValue = try values.decodeIfPresent(Int.self, forKey: .ratingMaxValue)
                self.ratingMinLabel = try values.decodeIfPresent(String.self, forKey: .ratingMinLabel)
                self.ratingMaxLabel = try values.decodeIfPresent(String.self, forKey: .ratingMaxLabel)
            }
        }

        public init(isAnonymous: Bool? = nil, questions: [Question]? = nil) {
            self.isAnonymous = isAnonymous ?? false
            self.questions = questions
        }

        private enum CodingKeys: String, CodingKey {
            case isAnonymous = "anonymous"
            case questions
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.isAnonymous = try values.decodeIfPresent(Bool.self, forKey: .isAnonymous) ?? false
            self.questions = try values.decodeIfPresent([Question].self, forKey: .questions)
        }
    }

    public init(thirdPartySurvey: String? = nil, customSurvey: CustomSurvey? = nil, isShowInTheFollowUpEmail: Bool? = nil, isShowInTheBrowser: Bool? = nil) {
        self.thirdPartySurvey = thirdPartySurvey
        self.customSurvey = customSurvey
        self.isShowInTheFollowUpEmail = isShowInTheFollowUpEmail ?? false
        self.isShowInTheBrowser = isShowInTheBrowser ?? true
    }

    private enum CodingKeys: String, CodingKey {
        case thirdPartySurvey = "third_party_survey"
        case customSurvey = "custom_survey"
        case isShowInTheFollowUpEmail = "show_in_the_follow_up_email"
        case isShowInTheBrowser = "show_in_the_browser"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.thirdPartySurvey = try values.decodeIfPresent(String.self, forKey: .thirdPartySurvey)
        self.customSurvey = try values.decodeIfPresent(CustomSurvey.self, forKey: .customSurvey)
        self.isShowInTheFollowUpEmail = try values.decodeIfPresent(Bool.self, forKey: .isShowInTheFollowUpEmail) ?? false
        self.isShowInTheBrowser = try values.decodeIfPresent(Bool.self, forKey: .isShowInTheBrowser) ?? true
    }
}

/// User List
///
/// List of webinars.
public struct WebinarList: Codable {
    /// The number of pages returned for the request made.
    public var pageCount: Int?
    /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
    public var pageNumber: Int?
    /// The number of records returned with a single API call.
    public var pageSize: Int?
    /// The total number of all the records available across pages.
    public var totalRecords: Int?
    /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
    public var nextPageToken: String?
    /// List of webinar objects.
    public var webinars: [Webinar]?

    public struct Webinar: Codable {
        /// Unique identifier of a Webinar. Each webinar instance will generate its own UUID. Once a Webinar ends, the value of uuid for the same webinar will be different from when it was scheduled.
        public var uuid: String?
        /// Webinar ID in "**long**" format(represented as int64 data type in JSON), also known as the webinar number.
        public var id: Int?
        /// ID of the host of the webinar.
        public var hostID: String?
        /// Meeting topic.
        public var topic: String?
        /// Webinar Types:<br>`5` - Webinar.<br>`6` - Recurring webinar with no fixed time.<br>`9` - Recurring webinar with a fixed time.
        public var type: String?
        /// Meeting duration.
        public var duration: Int?
        /// [Timezone ID](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#timezones) for the Webinar.
        public var timezone: String?
        /// Time of webinar creation.
        public var createdAt: Date?
        /// Join URL of the webinar (using which others can join the webinar).
        public var joinURL: String?
        /// Webinar Description. The length of agenda gets truncated to 250 characters when you list all webinars for a user. To view the complete agenda, retrieve details for a single webinar [here](https://marketplace.zoom.us/docs/api-reference/zoom-api/webinars/webinar).
        public var agenda: String?
        /// Scheduled start time of the Webinar.
        public var startTime: Date?

        public init(uuid: String? = nil, id: Int? = nil, hostID: String? = nil, topic: String? = nil, type: String? = nil, duration: Int? = nil, timezone: String? = nil, createdAt: Date? = nil, joinURL: String? = nil, agenda: String? = nil, startTime: Date? = nil) {
            self.uuid = uuid
            self.id = id
            self.hostID = hostID
            self.topic = topic
            self.type = type
            self.duration = duration
            self.timezone = timezone
            self.createdAt = createdAt
            self.joinURL = joinURL
            self.agenda = agenda
            self.startTime = startTime
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
            self.id = try values.decodeIfPresent(Int.self, forKey: "id")
            self.hostID = try values.decodeIfPresent(String.self, forKey: "host_id")
            self.topic = try values.decodeIfPresent(String.self, forKey: "topic")
            self.type = try values.decodeIfPresent(String.self, forKey: "type")
            self.duration = try values.decodeIfPresent(Int.self, forKey: "duration")
            self.timezone = try values.decodeIfPresent(String.self, forKey: "timezone")
            self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
            self.joinURL = try values.decodeIfPresent(String.self, forKey: "join_url")
            self.agenda = try values.decodeIfPresent(String.self, forKey: "agenda")
            self.startTime = try values.decodeIfPresent(Date.self, forKey: "start_time")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(uuid, forKey: "uuid")
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(hostID, forKey: "host_id")
            try values.encodeIfPresent(topic, forKey: "topic")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encodeIfPresent(duration, forKey: "duration")
            try values.encodeIfPresent(timezone, forKey: "timezone")
            try values.encodeIfPresent(createdAt, forKey: "created_at")
            try values.encodeIfPresent(joinURL, forKey: "join_url")
            try values.encodeIfPresent(agenda, forKey: "agenda")
            try values.encodeIfPresent(startTime, forKey: "start_time")
        }
    }

    public init(pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil, webinars: [Webinar]? = nil) {
        self.pageCount = pageCount
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.totalRecords = totalRecords
        self.nextPageToken = nextPageToken
        self.webinars = webinars
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.pageCount = try values.decodeIfPresent(Int.self, forKey: "page_count")
        self.pageNumber = try values.decodeIfPresent(Int.self, forKey: "page_number")
        self.pageSize = try values.decodeIfPresent(Int.self, forKey: "page_size")
        self.totalRecords = try values.decodeIfPresent(Int.self, forKey: "total_records")
        self.nextPageToken = try values.decodeIfPresent(String.self, forKey: "next_page_token")
        self.webinars = try values.decodeIfPresent([Webinar].self, forKey: "webinars")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(pageCount, forKey: "page_count")
        try values.encodeIfPresent(pageNumber, forKey: "page_number")
        try values.encodeIfPresent(pageSize, forKey: "page_size")
        try values.encodeIfPresent(totalRecords, forKey: "total_records")
        try values.encodeIfPresent(nextPageToken, forKey: "next_page_token")
        try values.encodeIfPresent(webinars, forKey: "webinars")
    }
}

/// Panelist base object.
public struct Panelist: Codable {
    /// The panelist's full name.
    /// 
    /// **Note:** This value cannot exceed more than 12 Chinese characters.
    public var name: String?
    /// Panelist's email.
    public var email: String?

    public init(name: String? = nil, email: String? = nil) {
        self.name = name
        self.email = email
    }
}

public struct WebinarRegistrantQuestions: Codable {
    /// Array of registration fields whose values should be provided by registrants during registration.
    public var questions: [Question]?
    /// Array of Registrant Custom Questions.
    public var customQuestions: [CustomQuestion]?

    public struct Question: Codable {
        /// Field name
        public var fieldName: FieldName?
        /// State whether the selected fields are required or optional.
        public var isRequired: Bool?

        /// Field name
        public enum FieldName: String, Codable, CaseIterable {
            case lastName = "last_name"
            case address
            case city
            case country
            case zip
            case state
            case phone
            case industry
            case org
            case jobTitle = "job_title"
            case purchasingTimeFrame = "purchasing_time_frame"
            case roleInPurchaseProcess = "role_in_purchase_process"
            case noOfEmployees = "no_of_employees"
            case comments
        }

        public init(fieldName: FieldName? = nil, isRequired: Bool? = nil) {
            self.fieldName = fieldName
            self.isRequired = isRequired
        }

        private enum CodingKeys: String, CodingKey {
            case fieldName = "field_name"
            case isRequired = "required"
        }
    }

    public struct CustomQuestion: Codable {
        /// Custom question.
        public var title: String?
        /// The question-answer type.
        public var type: `Type`?
        /// State whether or not the custom question is required to be answered by a registrant.
        public var isRequired: Bool?
        /// An array of answer choices. Can't be used for short answer type.
        public var answers: [String]?

        /// The question-answer type.
        public enum `Type`: String, Codable, CaseIterable {
            case short
            case singleRadio = "single_radio"
            case singleDropdown = "single_dropdown"
            case multiple
        }

        public init(title: String? = nil, type: `Type`? = nil, isRequired: Bool? = nil, answers: [String]? = nil) {
            self.title = title
            self.type = type
            self.isRequired = isRequired
            self.answers = answers
        }

        private enum CodingKeys: String, CodingKey {
            case title
            case type
            case isRequired = "required"
            case answers
        }
    }

    public init(questions: [Question]? = nil, customQuestions: [CustomQuestion]? = nil) {
        self.questions = questions
        self.customQuestions = customQuestions
    }

    private enum CodingKeys: String, CodingKey {
        case questions
        case customQuestions = "custom_questions"
    }
}

/// Recurrence object. Use this object only for a webinar of type `9` i.e., a recurring webinar with fixed time.
public struct RecurrenceWebinar: Codable {
    /// Recurrence webinar types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
    public var type: Int
    /// Define the interval at which the webinar should recur. For instance, if you would like to schedule a Webinar that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
    /// 
    /// For a daily webinar, the maximum interval you can set is `90` days. For a weekly webinar, the maximum interval that you can set is `12` weeks. For a monthly webinar, the maximum interval that you can set is `3` months.
    public var repeatInterval: Int?
    /// Use this field **only if you're scheduling a recurring webinar of type** `2` to state which day(s) of the week the webinar should repeat. <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the Webinar should recur on Sunday, provide `"1"` as the value of this field.  <br><br> **Note:** If you would like the webinar to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the Webinar should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
    /// 
    /// <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
    public var weeklyDays: String?
    /// Use this field **only if you're scheduling a recurring webinar of type** `3` to state which day in a month, the webinar should recur. The value range is from 1 to 31.
    /// 
    /// For instance, if you would like the webinar to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the webinar to recur once every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
    public var monthlyDay: Int?
    /// Use this field **only if you're scheduling a recurring webinar of type** `3` to state the week of the month when the webinar should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the webinar should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
    public var monthlyWeek: Int?
    /// Use this field **only if you're scheduling a recurring webinar of type** `3` to state a specific day in a week when the monthly webinar should recur. To use this field, you must also use the `monthly_week` field. <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
    public var monthlyWeekDay: Int?
    /// Select how many times the webinar will recur before it is canceled. (Cannot be used with "end_date_time".)
    public var endTimes: Int?
    /// Select a date when the webinar will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
    public var endDateTime: Date?

    public init(type: Int, repeatInterval: Int? = nil, weeklyDays: String? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
        self.type = type
        self.repeatInterval = repeatInterval
        self.weeklyDays = weeklyDays
        self.monthlyDay = monthlyDay
        self.monthlyWeek = monthlyWeek
        self.monthlyWeekDay = monthlyWeekDay
        self.endTimes = endTimes
        self.endDateTime = endDateTime
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case repeatInterval = "repeat_interval"
        case weeklyDays = "weekly_days"
        case monthlyDay = "monthly_day"
        case monthlyWeek = "monthly_week"
        case monthlyWeekDay = "monthly_week_day"
        case endTimes = "end_times"
        case endDateTime = "end_date_time"
    }
}

/// Webinar live stream.
public struct WebinarLiveStream: Codable {
    /// The webinar live stream URL.
    public var streamURL: String
    /// The webinar live stream name and key.
    public var streamKey: String
    /// The webinar live stream page's URL.
    public var pageURL: URL

    public init(streamURL: String, streamKey: String, pageURL: URL) {
        self.streamURL = streamURL
        self.streamKey = streamKey
        self.pageURL = pageURL
    }

    private enum CodingKeys: String, CodingKey {
        case streamURL = "stream_url"
        case streamKey = "stream_key"
        case pageURL = "page_url"
    }
}

/// Webinar object
public struct WebinarUpdate: Codable {
    /// Webinar topic.
    public var topic: String?
    /// Webinar Types:<br>`5` - webinar.<br>`6` - Recurring webinar with no fixed time.<br>`9` - Recurring webinar with a fixed time.
    public var type: Int?
    /// Webinar start time, in the format "yyyy-MM-dd'T'HH:mm:ss'Z'." Should be in GMT time. In the format "yyyy-MM-dd'T'HH:mm:ss." This should be in local time and the timezone should be specified. Only used for scheduled webinars and recurring webinars with a fixed time.
    public var startTime: Date?
    /// Webinar duration (minutes). Used for scheduled webinar only.
    public var duration: Int?
    /// Time zone to format start_time. For example, "America/Los_Angeles". For scheduled meetings only. Please reference our [time zone](#timezones) list for supported time zones and their formats.
    public var timezone: String?
    /// [Webinar passcode](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords). By default, passcode may only contain the following characters: [a-z A-Z 0-9 @ - _ * !] and can have a maximum of 10 characters.
    /// 
    /// **Note:** If the account owner or the admin has configured [minimum passcode requirement settings](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604), the passcode value provided here must meet those requirements. <br><br>If the requirements are enabled, you can view those requirements by calling either the [Get User Settings API](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings) or the  [Get Account Settings](https://marketplace.zoom.us/docs/api-reference/zoom-api/accounts/accountsettings) API. 
    /// 
    /// If "**Require a passcode when scheduling new meetings**" setting has been **enabled** **and** [locked](https://support.zoom.us/hc/en-us/articles/115005269866-Using-Tiered-Settings#locked) for the user, the passcode field will be autogenerated for the Webinar in the response even if it is not provided in the API request. <br><br>
    public var password: String?
    /// Webinar description.
    public var agenda: String?
    /// Tracking fields
    public var trackingFields: [TrackingField]?
    /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
    public var recurrence: Recurrence?
    public var settings: Settings?

    public struct TrackingField: Codable {
        /// Tracking fields type
        public var field: String?
        /// Tracking fields value
        public var value: String?

        public init(field: String? = nil, value: String? = nil) {
            self.field = field
            self.value = value
        }
    }

    /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
    public struct Recurrence: Codable {
        /// Recurrence meeting types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
        public var type: Int
        /// Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
        /// 
        /// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
        public var repeatInterval: Int?
        /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
        /// 
        ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public var weeklyDays: WeeklyDays?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
        /// 
        /// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
        public var monthlyDay: Int?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
        public var monthlyWeek: Int?
        /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field. 
        /// 
        /// <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public var monthlyWeekDay: Int?
        /// Select how many times the meeting should recur before it is canceled. (Cannot be used with "end_date_time".)
        public var endTimes: Int?
        /// Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
        public var endDateTime: Date?

        /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
        /// 
        ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
        public enum WeeklyDays: String, Codable, CaseIterable {
            case _1 = "1"
            case _2 = "2"
            case _3 = "3"
            case _4 = "4"
            case _5 = "5"
            case _6 = "6"
            case _7 = "7"
        }

        public init(type: Int, repeatInterval: Int? = nil, weeklyDays: WeeklyDays? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
            self.type = type
            self.repeatInterval = repeatInterval
            self.weeklyDays = weeklyDays
            self.monthlyDay = monthlyDay
            self.monthlyWeek = monthlyWeek
            self.monthlyWeekDay = monthlyWeekDay
            self.endTimes = endTimes
            self.endDateTime = endDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case repeatInterval = "repeat_interval"
            case weeklyDays = "weekly_days"
            case monthlyDay = "monthly_day"
            case monthlyWeek = "monthly_week"
            case monthlyWeekDay = "monthly_week_day"
            case endTimes = "end_times"
            case endDateTime = "end_date_time"
        }
    }

    public struct Settings: Codable {
        /// Start video when host joins webinar.
        public var isHostVideo: Bool?
        /// Start video when panelists join webinar.
        public var isPanelistsVideo: Bool?
        /// Enable practice session.
        public var isPracticeSession: Bool
        /// Default to HD video.
        public var isHdVideo: Bool
        /// Whether HD video for attendees is enabled. This value defaults to `false`.
        public var isHdVideoForAttendees: Bool
        /// Whether to always send 1080p video to attendees. This value defaults to `false`.
        public var isSend1080pVideoToAttendees: Bool
        /// `0` - Automatically approve.<br>`1` - Manually approve.<br>`2` - No registration required.
        public var approvalType: Int?
        /// Registration types. Only used for recurring webinars with a fixed time.<br>`1` - Attendees register once and can attend any of the webinar sessions.<br>`2` - Attendees need to register for each session in order to attend.<br>`3` - Attendees register once and can choose one or more sessions to attend.
        public var registrationType: Int?
        /// Determine how participants can join the audio portion of the webinar.
        public var audio: Audio?
        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public var autoRecording: AutoRecording?
        /// Only signed in users can join this meeting.
        /// 
        /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the Webinar.
        public var enforceLogin: Bool?
        /// Only signed in users with specified domains can join meetings.
        /// 
        /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the Webinar.
        public var enforceLoginDomains: String?
        /// Alternative host emails or IDs. Multiple values separated by comma.
        public var alternativeHosts: String?
        /// Close registration after event date.
        public var isCloseRegistration: Bool?
        /// Show social share buttons on the registration page.
        public var isShowShareButton: Bool?
        /// Allow attendees to join from multiple devices.
        public var allowMultipleDevices: Bool?
        /// Make the webinar on-demand
        public var isOnDemand: Bool
        /// List of global dial-in countries
        public var globalDialInCountries: [String]?
        /// Contact name for registration
        public var contactName: String?
        /// Contact email for registration
        public var contactEmail: String?
        /// Send confirmation email to registrants
        public var isRegistrantsConfirmationEmail: Bool?
        /// Restrict number of registrants for a webinar. By default, it is set to `0`. A `0` value means that the restriction option is disabled. Provide a number higher than 0 to restrict the webinar registrants by the that number.
        public var registrantsRestrictNumber: Int?
        /// Send notification email to registrants when the host updates a webinar.
        public var isNotifyRegistrants: Bool?
        /// Zoom will open a survey page in attendees' browsers after leaving the webinar
        public var isPostWebinarSurvey: Bool?
        /// Survey url for post webinar survey
        public var surveyURL: String?
        /// Send email notifications to registrants about approval, cancellation, denial of the registration. The value of this field must be set to true in order to use the `registrants_confirmation_email` field.
        public var isRegistrantsEmailNotification: Bool?
        /// `true`- Only authenticated users can join Webinar.
        public var isMeetingAuthentication: Bool?
        /// Webinar authentication option id.
        public var authenticationOption: String?
        /// If user has configured ["Sign Into Zoom with Specified Domains"](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
        public var authenticationDomains: String?
        /// Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
        public var authenticationName: String?
        /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
        public var questionAndAnswer: QuestionAndAnswer?
        /// Set the email language to one of the following:
        /// `en-US`,`de-DE`,`es-ES`,`fr-FR`,`jp-JP`,`pt-PT`,`ru-RU`,`zh-CN`, `zh-TW`, `ko-KO`, `it-IT`, `vi-VN`.
        public var emailLanguage: String?
        /// * `true`: Send invitation email to panelists.
        /// 
        /// * `false`: Do not send invitation email to panelists.
        public var isPanelistsInvitationEmailNotification: Bool?
        /// Send reminder email to attendees and panelists.
        public var attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification?
        /// Send follow-up email to attendees.
        public var followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification?
        /// Send follow-up email to absentees.
        public var followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification?
        /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
        /// 
        /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
        public var languageInterpretation: LanguageInterpretation?

        /// Determine how participants can join the audio portion of the webinar.
        public enum Audio: String, Codable, CaseIterable {
            case both
            case telephony
            case voip
        }

        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public enum AutoRecording: String, Codable, CaseIterable {
            case local
            case cloud
            case `none`
        }

        /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
        public struct QuestionAndAnswer: Codable {
            /// * `true`: Enable [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
            /// 
            /// * `false`: Disable Q&A for webinar.
            public var enable: Bool?
            /// * `true`: Allow participants to send questions without providing their name to the host, co-host, and panelists..
            /// 
            /// * `false`: Do not allow anonymous questions.
            public var allowAnonymousQuestions: Bool?
            /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
            /// 
            /// * `only`: Attendees are able to view answered questions only.
            /// 
            /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
            public var answerQuestions: AnswerQuestions?
            /// * `true`: Attendees can click the thumbs up button to bring popular questions to the top of the Q&A window.
            /// 
            /// * `false`: Attendees can not click the thumbs up button on questions.
            public var attendeesCanUpvote: Bool?
            /// * `true`: Attendees can answer questions or leave a comment in the question thread.
            /// 
            /// * `false`: Attendees can not answer questions or leave a comment in the question thread
            public var attendeesCanComment: Bool?

            /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
            /// 
            /// * `only`: Attendees are able to view answered questions only.
            /// 
            /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
            public enum AnswerQuestions: String, Codable, CaseIterable {
                case only
                case all
            }

            public init(enable: Bool? = nil, allowAnonymousQuestions: Bool? = nil, answerQuestions: AnswerQuestions? = nil, attendeesCanUpvote: Bool? = nil, attendeesCanComment: Bool? = nil) {
                self.enable = enable
                self.allowAnonymousQuestions = allowAnonymousQuestions
                self.answerQuestions = answerQuestions
                self.attendeesCanUpvote = attendeesCanUpvote
                self.attendeesCanComment = attendeesCanComment
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case allowAnonymousQuestions = "allow_anonymous_questions"
                case answerQuestions = "answer_questions"
                case attendeesCanUpvote = "attendees_can_upvote"
                case attendeesCanComment = "attendees_can_comment"
            }
        }

        /// Send reminder email to attendees and panelists.
        public struct AttendeesAndPanelistsReminderEmailNotification: Codable {
            /// * `true`: Send reminder email to attendees and panelists.
            /// 
            /// * `false`: Do not send reminder email to attendees and panelists.
            public var enable: Bool?
            /// `0` - No plan.<br>`1` - Send 1 hour before webinar.<br>`2` - Send 1 day before webinar.<br>`3` - Send 1 hour and 1 day before webinar.<br>`4` - Send 1 week before webinar.<br>`5` - Send 1 hour and 1 week before webinar.<br>`6` - Send 1 day and 1 week before webinar.<br>`7` - Send 1 hour, 1 day and 1 week before webinar.
            public var type: Int?

            public init(enable: Bool? = nil, type: Int? = nil) {
                self.enable = enable
                self.type = type
            }
        }

        /// Send follow-up email to attendees.
        public struct FollowUpAttendeesEmailNotification: Codable {
            /// * `true`: Send follow-up email to attendees.
            /// 
            /// * `false`: Do not send follow-up email to attendees.
            public var enable: Bool?
            /// `0` - No plan.<br>`1` - Send 1 day after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
            public var type: Int?

            public init(enable: Bool? = nil, type: Int? = nil) {
                self.enable = enable
                self.type = type
            }
        }

        /// Send follow-up email to absentees.
        public struct FollowUpAbsenteesEmailNotification: Codable {
            /// * `true`: Send follow-up email to absentees.
            /// 
            /// * `false`: Do not send follow-up email to absentees.
            public var enable: Bool?
            /// `0` - No plan.<br>`1` - Send 1 days after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
            public var type: Int?

            public init(enable: Bool? = nil, type: Int? = nil) {
                self.enable = enable
                self.type = type
            }
        }

        /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
        /// 
        /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
        public struct LanguageInterpretation: Codable {
            /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the webinar.
            public var enable: Bool?
            /// Information about the webinar's language interpreters.
            public var interpreters: [Interpreter]?

            public struct Interpreter: Codable {
                /// The interpreter's email address.
                public var email: String?
                /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
                /// 
                /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
                public var languages: String?

                public init(email: String? = nil, languages: String? = nil) {
                    self.email = email
                    self.languages = languages
                }
            }

            public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
                self.enable = enable
                self.interpreters = interpreters
            }
        }

        public init(isHostVideo: Bool? = nil, isPanelistsVideo: Bool? = nil, isPracticeSession: Bool? = nil, isHdVideo: Bool? = nil, isHdVideoForAttendees: Bool? = nil, isSend1080pVideoToAttendees: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, enforceLogin: Bool? = nil, enforceLoginDomains: String? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, isOnDemand: Bool? = nil, globalDialInCountries: [String]? = nil, contactName: String? = nil, contactEmail: String? = nil, isRegistrantsConfirmationEmail: Bool? = nil, registrantsRestrictNumber: Int? = nil, isNotifyRegistrants: Bool? = nil, isPostWebinarSurvey: Bool? = nil, surveyURL: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, authenticationName: String? = nil, questionAndAnswer: QuestionAndAnswer? = nil, emailLanguage: String? = nil, isPanelistsInvitationEmailNotification: Bool? = nil, attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification? = nil, followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification? = nil, followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification? = nil, languageInterpretation: LanguageInterpretation? = nil) {
            self.isHostVideo = isHostVideo
            self.isPanelistsVideo = isPanelistsVideo
            self.isPracticeSession = isPracticeSession ?? false
            self.isHdVideo = isHdVideo ?? false
            self.isHdVideoForAttendees = isHdVideoForAttendees ?? false
            self.isSend1080pVideoToAttendees = isSend1080pVideoToAttendees ?? false
            self.approvalType = approvalType
            self.registrationType = registrationType
            self.audio = audio
            self.autoRecording = autoRecording
            self.enforceLogin = enforceLogin
            self.enforceLoginDomains = enforceLoginDomains
            self.alternativeHosts = alternativeHosts
            self.isCloseRegistration = isCloseRegistration
            self.isShowShareButton = isShowShareButton
            self.allowMultipleDevices = allowMultipleDevices
            self.isOnDemand = isOnDemand ?? false
            self.globalDialInCountries = globalDialInCountries
            self.contactName = contactName
            self.contactEmail = contactEmail
            self.isRegistrantsConfirmationEmail = isRegistrantsConfirmationEmail
            self.registrantsRestrictNumber = registrantsRestrictNumber
            self.isNotifyRegistrants = isNotifyRegistrants
            self.isPostWebinarSurvey = isPostWebinarSurvey
            self.surveyURL = surveyURL
            self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
            self.isMeetingAuthentication = isMeetingAuthentication
            self.authenticationOption = authenticationOption
            self.authenticationDomains = authenticationDomains
            self.authenticationName = authenticationName
            self.questionAndAnswer = questionAndAnswer
            self.emailLanguage = emailLanguage
            self.isPanelistsInvitationEmailNotification = isPanelistsInvitationEmailNotification
            self.attendeesAndPanelistsReminderEmailNotification = attendeesAndPanelistsReminderEmailNotification
            self.followUpAttendeesEmailNotification = followUpAttendeesEmailNotification
            self.followUpAbsenteesEmailNotification = followUpAbsenteesEmailNotification
            self.languageInterpretation = languageInterpretation
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isHostVideo = try values.decodeIfPresent(Bool.self, forKey: "host_video")
            self.isPanelistsVideo = try values.decodeIfPresent(Bool.self, forKey: "panelists_video")
            self.isPracticeSession = try values.decodeIfPresent(Bool.self, forKey: "practice_session") ?? false
            self.isHdVideo = try values.decodeIfPresent(Bool.self, forKey: "hd_video") ?? false
            self.isHdVideoForAttendees = try values.decodeIfPresent(Bool.self, forKey: "hd_video_for_attendees") ?? false
            self.isSend1080pVideoToAttendees = try values.decodeIfPresent(Bool.self, forKey: "send_1080p_video_to_attendees") ?? false
            self.approvalType = try values.decodeIfPresent(Int.self, forKey: "approval_type")
            self.registrationType = try values.decodeIfPresent(Int.self, forKey: "registration_type")
            self.audio = try Audio(from: decoder)
            self.autoRecording = try AutoRecording(from: decoder)
            self.enforceLogin = try values.decodeIfPresent(Bool.self, forKey: "enforce_login")
            self.enforceLoginDomains = try values.decodeIfPresent(String.self, forKey: "enforce_login_domains")
            self.alternativeHosts = try values.decodeIfPresent(String.self, forKey: "alternative_hosts")
            self.isCloseRegistration = try values.decodeIfPresent(Bool.self, forKey: "close_registration")
            self.isShowShareButton = try values.decodeIfPresent(Bool.self, forKey: "show_share_button")
            self.allowMultipleDevices = try values.decodeIfPresent(Bool.self, forKey: "allow_multiple_devices")
            self.isOnDemand = try values.decodeIfPresent(Bool.self, forKey: "on_demand") ?? false
            self.globalDialInCountries = try values.decodeIfPresent([String].self, forKey: "global_dial_in_countries")
            self.contactName = try values.decodeIfPresent(String.self, forKey: "contact_name")
            self.contactEmail = try values.decodeIfPresent(String.self, forKey: "contact_email")
            self.isRegistrantsConfirmationEmail = try values.decodeIfPresent(Bool.self, forKey: "registrants_confirmation_email")
            self.registrantsRestrictNumber = try values.decodeIfPresent(Int.self, forKey: "registrants_restrict_number")
            self.isNotifyRegistrants = try values.decodeIfPresent(Bool.self, forKey: "notify_registrants")
            self.isPostWebinarSurvey = try values.decodeIfPresent(Bool.self, forKey: "post_webinar_survey")
            self.surveyURL = try values.decodeIfPresent(String.self, forKey: "survey_url")
            self.isRegistrantsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: "registrants_email_notification")
            self.isMeetingAuthentication = try values.decodeIfPresent(Bool.self, forKey: "meeting_authentication")
            self.authenticationOption = try values.decodeIfPresent(String.self, forKey: "authentication_option")
            self.authenticationDomains = try values.decodeIfPresent(String.self, forKey: "authentication_domains")
            self.authenticationName = try values.decodeIfPresent(String.self, forKey: "authentication_name")
            self.questionAndAnswer = try QuestionAndAnswer(from: decoder)
            self.emailLanguage = try values.decodeIfPresent(String.self, forKey: "email_language")
            self.isPanelistsInvitationEmailNotification = try values.decodeIfPresent(Bool.self, forKey: "panelists_invitation_email_notification")
            self.attendeesAndPanelistsReminderEmailNotification = try AttendeesAndPanelistsReminderEmailNotification(from: decoder)
            self.followUpAttendeesEmailNotification = try FollowUpAttendeesEmailNotification(from: decoder)
            self.followUpAbsenteesEmailNotification = try FollowUpAbsenteesEmailNotification(from: decoder)
            self.languageInterpretation = try LanguageInterpretation(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(isHostVideo, forKey: "host_video")
            try values.encodeIfPresent(isPanelistsVideo, forKey: "panelists_video")
            try values.encodeIfPresent(isPracticeSession, forKey: "practice_session")
            try values.encodeIfPresent(isHdVideo, forKey: "hd_video")
            try values.encodeIfPresent(isHdVideoForAttendees, forKey: "hd_video_for_attendees")
            try values.encodeIfPresent(isSend1080pVideoToAttendees, forKey: "send_1080p_video_to_attendees")
            try values.encodeIfPresent(approvalType, forKey: "approval_type")
            try values.encodeIfPresent(registrationType, forKey: "registration_type")
            try values.encodeIfPresent(audio, forKey: "audio")
            try values.encodeIfPresent(autoRecording, forKey: "auto_recording")
            try values.encodeIfPresent(enforceLogin, forKey: "enforce_login")
            try values.encodeIfPresent(enforceLoginDomains, forKey: "enforce_login_domains")
            try values.encodeIfPresent(alternativeHosts, forKey: "alternative_hosts")
            try values.encodeIfPresent(isCloseRegistration, forKey: "close_registration")
            try values.encodeIfPresent(isShowShareButton, forKey: "show_share_button")
            try values.encodeIfPresent(allowMultipleDevices, forKey: "allow_multiple_devices")
            try values.encodeIfPresent(isOnDemand, forKey: "on_demand")
            try values.encodeIfPresent(globalDialInCountries, forKey: "global_dial_in_countries")
            try values.encodeIfPresent(contactName, forKey: "contact_name")
            try values.encodeIfPresent(contactEmail, forKey: "contact_email")
            try values.encodeIfPresent(isRegistrantsConfirmationEmail, forKey: "registrants_confirmation_email")
            try values.encodeIfPresent(registrantsRestrictNumber, forKey: "registrants_restrict_number")
            try values.encodeIfPresent(isNotifyRegistrants, forKey: "notify_registrants")
            try values.encodeIfPresent(isPostWebinarSurvey, forKey: "post_webinar_survey")
            try values.encodeIfPresent(surveyURL, forKey: "survey_url")
            try values.encodeIfPresent(isRegistrantsEmailNotification, forKey: "registrants_email_notification")
            try values.encodeIfPresent(isMeetingAuthentication, forKey: "meeting_authentication")
            try values.encodeIfPresent(authenticationOption, forKey: "authentication_option")
            try values.encodeIfPresent(authenticationDomains, forKey: "authentication_domains")
            try values.encodeIfPresent(authenticationName, forKey: "authentication_name")
            try values.encodeIfPresent(questionAndAnswer, forKey: "question_and_answer")
            try values.encodeIfPresent(emailLanguage, forKey: "email_language")
            try values.encodeIfPresent(isPanelistsInvitationEmailNotification, forKey: "panelists_invitation_email_notification")
            try values.encodeIfPresent(attendeesAndPanelistsReminderEmailNotification, forKey: "attendees_and_panelists_reminder_email_notification")
            try values.encodeIfPresent(followUpAttendeesEmailNotification, forKey: "follow_up_attendees_email_notification")
            try values.encodeIfPresent(followUpAbsenteesEmailNotification, forKey: "follow_up_absentees_email_notification")
            try values.encodeIfPresent(languageInterpretation, forKey: "language_interpretation")
        }
    }

    public init(topic: String? = nil, type: Int? = nil, startTime: Date? = nil, duration: Int? = nil, timezone: String? = nil, password: String? = nil, agenda: String? = nil, trackingFields: [TrackingField]? = nil, recurrence: Recurrence? = nil, settings: Settings? = nil) {
        self.topic = topic
        self.type = type
        self.startTime = startTime
        self.duration = duration
        self.timezone = timezone
        self.password = password
        self.agenda = agenda
        self.trackingFields = trackingFields
        self.recurrence = recurrence
        self.settings = settings
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.topic = try values.decodeIfPresent(String.self, forKey: "topic")
        self.type = try values.decodeIfPresent(Int.self, forKey: "type")
        self.startTime = try values.decodeIfPresent(Date.self, forKey: "start_time")
        self.duration = try values.decodeIfPresent(Int.self, forKey: "duration")
        self.timezone = try values.decodeIfPresent(String.self, forKey: "timezone")
        self.password = try values.decodeIfPresent(String.self, forKey: "password")
        self.agenda = try values.decodeIfPresent(String.self, forKey: "agenda")
        self.trackingFields = try values.decodeIfPresent([TrackingField].self, forKey: "tracking_fields")
        self.recurrence = try Recurrence(from: decoder)
        self.settings = try Settings(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(topic, forKey: "topic")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encodeIfPresent(startTime, forKey: "start_time")
        try values.encodeIfPresent(duration, forKey: "duration")
        try values.encodeIfPresent(timezone, forKey: "timezone")
        try values.encodeIfPresent(password, forKey: "password")
        try values.encodeIfPresent(agenda, forKey: "agenda")
        try values.encodeIfPresent(trackingFields, forKey: "tracking_fields")
        try values.encodeIfPresent(recurrence, forKey: "recurrence")
        try values.encodeIfPresent(settings, forKey: "settings")
    }
}

/// The recording file object.
public struct RecordingSeparateAudio: Codable {
    /// The recording file's unique ID. This is included in the general query response.
    public var id: String?
    /// The recording file's start time.
    public var recordingStart: Date?
    /// The recording file's end time. This is included in the general query response.
    public var recordingEnd: Date?
    /// The recording file's format. One of:
    /// 
    /// * `MP4` — Video file.
    /// * `M4A` — Audio-only file.
    /// * `TIMELINE` — Timestamp file of the recording, in JSON file format. To get a timeline file, the **Add a timestamp to the recording** setting **must** be enabled in the [recording settings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-recording#h_3f14c3a4-d16b-4a3c-bbe5-ef7d24500048). The time will display in the host's timezone.
    /// * `TRANSCRIPT` — A transcript of the recording, in VTT format.
    /// * `CHAT` — A text file containing chat messages sent during the meeting.
    /// * `CC` — A file containing the closed captions of the recording, in VTT file format.
    /// * `CSV` — A file containing polling data, in CSV format.
    /// 
    /// A recording file object with file the `CC` or `TIMELINE` value **does not** have the `id`, `status`, `file_size`, `recording_type`, and `play_url` properties.
    public var fileType: String?
    /// The recording file's size, in bytes.
    public var fileSize: Double?
    /// The URL at which the recording file can be opened and played.
    public var playURL: String?
    /// The URL at which to download the the recording. 
    /// 
    /// **JWT apps** 
    /// 
    /// To access a private or password-protected cloud recording of a user in your account, use a [Zoom JWT app](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app). Use the generated JWT token as the value of the `access_token` query parameter and include this query parameter at the end of the URL. For example: 
    /// 
    /// `https://{{base-domain}}/recording/download/{{path-to-file-download}}?access_token={{JWT-token}}` 
    /// 
    /// **OAuth apps** 
    /// 
    /// If a user has authorized and installed your OAuth app that contains recording scopes, use the user’s [OAuth access token](https://marketplace.zoom.us/docs/guides/auth/oauth) to download the file. For example: 
    /// 
    /// `https://{{base-domain}}/rec/archive/download/xxx?access_token={{OAuth-access-token}}` 
    /// 
    /// **Note:** This field does **not** return for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). Instead, this API will return the `file_path` field.
    public var downloadURL: String?
    /// The file path to the On-Premise account recording. 
    /// 
    /// **Note:** This API only returns this field for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). It does **not** return the `download_url` field.
    public var filePath: String?
    /// The recording file's status.
    public var status: Status?
    /// The recording file's name.
    public var fileName: String?

    /// The recording file's status.
    public enum Status: String, Codable, CaseIterable {
        case completed
    }

    public init(id: String? = nil, recordingStart: Date? = nil, recordingEnd: Date? = nil, fileType: String? = nil, fileSize: Double? = nil, playURL: String? = nil, downloadURL: String? = nil, filePath: String? = nil, status: Status? = nil, fileName: String? = nil) {
        self.id = id
        self.recordingStart = recordingStart
        self.recordingEnd = recordingEnd
        self.fileType = fileType
        self.fileSize = fileSize
        self.playURL = playURL
        self.downloadURL = downloadURL
        self.filePath = filePath
        self.status = status
        self.fileName = fileName
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case recordingStart = "recording_start"
        case recordingEnd = "recording_end"
        case fileType = "file_type"
        case fileSize = "file_size"
        case playURL = "play_url"
        case downloadURL = "download_url"
        case filePath = "file_path"
        case status
        case fileName = "file_name"
    }
}

/// Registrant Status
public struct RecordingRegistrantStatus: Codable {
    public var action: Action
    /// List of registrants
    public var registrants: [Registrant]?

    public enum Action: String, Codable, CaseIterable {
        case approve
        case deny
    }

    public struct Registrant: Codable {
        public var id: String?

        public init(id: String? = nil) {
            self.id = id
        }
    }

    public init(action: Action, registrants: [Registrant]? = nil) {
        self.action = action
        self.registrants = registrants
    }
}

public struct RecordingRegistrantQuestions: Codable {
    /// Array of Registrant Questions
    public var questions: [Question]?
    /// Array of Registrant Custom Questions
    public var customQuestions: [CustomQuestion]?

    public struct Question: Codable {
        /// Field name.
        public var fieldName: FieldName?
        /// State whether the field is required to be answered by the registrant or not.
        public var isRequired: Bool?

        /// Field name.
        public enum FieldName: String, Codable, CaseIterable {
            case lastName = "last_name"
            case address
            case city
            case country
            case zip
            case state
            case phone
            case industry
            case org
            case jobTitle = "job_title"
            case purchasingTimeFrame = "purchasing_time_frame"
            case roleInPurchaseProcess = "role_in_purchase_process"
            case noOfEmployees = "no_of_employees"
            case comments
        }

        public init(fieldName: FieldName? = nil, isRequired: Bool? = nil) {
            self.fieldName = fieldName
            self.isRequired = isRequired
        }

        private enum CodingKeys: String, CodingKey {
            case fieldName = "field_name"
            case isRequired = "required"
        }
    }

    public struct CustomQuestion: Codable {
        /// Title of the question.
        public var title: String?
        /// The type of registration question and answers.
        public var type: `Type`?
        /// State whether registrants are required to answer custom questions or not.
        public var isRequired: Bool?
        /// Answer choices for the question. Can not be used with Short answer type.
        public var answers: [String]?

        /// The type of registration question and answers.
        public enum `Type`: String, Codable, CaseIterable {
            case short
            case single
            case multiple
        }

        public init(title: String? = nil, type: `Type`? = nil, isRequired: Bool? = nil, answers: [String]? = nil) {
            self.title = title
            self.type = type
            self.isRequired = isRequired
            self.answers = answers
        }

        private enum CodingKeys: String, CodingKey {
            case title
            case type
            case isRequired = "required"
            case answers
        }
    }

    public init(questions: [Question]? = nil, customQuestions: [CustomQuestion]? = nil) {
        self.questions = questions
        self.customQuestions = customQuestions
    }

    private enum CodingKeys: String, CodingKey {
        case questions
        case customQuestions = "custom_questions"
    }
}

/// Cloud Recording Registration List
///
/// Information about the cloud recording registrations.
public struct MeetingRecordingRegistrantList: Codable {
    /// The number of pages returned for the request made.
    public var pageCount: Int?
    /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
    public var pageNumber: Int?
    /// The number of records returned with a single API call.
    public var pageSize: Int?
    /// The total number of all the records available across pages.
    public var totalRecords: Int?
    /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
    public var nextPageToken: String?
    /// Information about the cloud recording registrants.
    public var registrants: [Registrant]?

    public struct Registrant: Codable {
        /// The registrant's ID.
        public var id: String?
        /// Registrant.
        public var b: B

        /// Registrant.
        public struct B: Codable {
            /// The registrant's email address.
            public var email: String
            /// The registrant's status: 
            /// * `approved` — Registrant is approved. 
            /// * `denied` — Registrant is denied. 
            /// * `pending` — Registrant is waiting for approval.
            public var status: Status?
            /// The registrant's first name.
            public var firstName: String
            /// The registrant's last name.
            public var lastName: String?
            /// The registrant's address.
            public var address: String?
            /// The registrant's city.
            public var city: String?
            /// The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
            public var country: String?
            /// The registrant's ZIP or postal code.
            public var zip: String?
            /// The registrant's state or province.
            public var state: String?
            /// The registrant's phone number.
            public var phone: String?
            /// The registrant's industry.
            public var industry: String?
            /// The registrant's organization.
            public var org: String?
            /// The registrant's job title.
            public var jobTitle: String?
            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public var purchasingTimeFrame: PurchasingTimeFrame?
            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public var roleInPurchaseProcess: RoleInPurchaseProcess?
            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public var noOfEmployees: NoOfEmployees?
            /// The registrant's questions and comments.
            public var comments: String?
            /// Information about custom questions.
            public var customQuestions: [CustomQuestion]?

            /// The registrant's status: 
            /// * `approved` — Registrant is approved. 
            /// * `denied` — Registrant is denied. 
            /// * `pending` — Registrant is waiting for approval.
            public enum Status: String, Codable, CaseIterable {
                case approved
                case denied
                case pending
            }

            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public enum PurchasingTimeFrame: String, Codable, CaseIterable {
                case empty = ""
                case withinAMonth = "Within a month"
                case _13Months = "1-3 months"
                case _46Months = "4-6 months"
                case moreThan6Months = "More than 6 months"
                case noTimeframe = "No timeframe"
            }

            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public enum RoleInPurchaseProcess: String, Codable, CaseIterable {
                case empty = ""
                case decisionMaker = "Decision Maker"
                case evaluatorRecommender = "Evaluator/Recommender"
                case influencer = "Influencer"
                case notInvolved = "Not involved"
            }

            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public enum NoOfEmployees: String, Codable, CaseIterable {
                case empty = ""
                case _120 = "1-20"
                case _2150 = "21-50"
                case _51100 = "51-100"
                case _101500 = "101-500"
                case _5001000 = "500-1,000"
                case _10015000 = "1,001-5,000"
                case _500110000 = "5,001-10,000"
                case moreThan10000 = "More than 10,000"
            }

            /// Information about custom questions.
            public struct CustomQuestion: Codable {
                /// The title of the custom question.
                public var title: String?
                /// The custom question's response value. This has a limit of 128 characters.
                public var value: String?

                public init(title: String? = nil, value: String? = nil) {
                    self.title = title
                    self.value = value
                }
            }

            public init(email: String, status: Status? = nil, firstName: String, lastName: String? = nil, address: String? = nil, city: String? = nil, country: String? = nil, zip: String? = nil, state: String? = nil, phone: String? = nil, industry: String? = nil, org: String? = nil, jobTitle: String? = nil, purchasingTimeFrame: PurchasingTimeFrame? = nil, roleInPurchaseProcess: RoleInPurchaseProcess? = nil, noOfEmployees: NoOfEmployees? = nil, comments: String? = nil, customQuestions: [CustomQuestion]? = nil) {
                self.email = email
                self.status = status
                self.firstName = firstName
                self.lastName = lastName
                self.address = address
                self.city = city
                self.country = country
                self.zip = zip
                self.state = state
                self.phone = phone
                self.industry = industry
                self.org = org
                self.jobTitle = jobTitle
                self.purchasingTimeFrame = purchasingTimeFrame
                self.roleInPurchaseProcess = roleInPurchaseProcess
                self.noOfEmployees = noOfEmployees
                self.comments = comments
                self.customQuestions = customQuestions
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.email = try values.decode(String.self, forKey: "email")
                self.status = try Status(from: decoder)
                self.firstName = try values.decode(String.self, forKey: "first_name")
                self.lastName = try values.decodeIfPresent(String.self, forKey: "last_name")
                self.address = try values.decodeIfPresent(String.self, forKey: "address")
                self.city = try values.decodeIfPresent(String.self, forKey: "city")
                self.country = try values.decodeIfPresent(String.self, forKey: "country")
                self.zip = try values.decodeIfPresent(String.self, forKey: "zip")
                self.state = try values.decodeIfPresent(String.self, forKey: "state")
                self.phone = try values.decodeIfPresent(String.self, forKey: "phone")
                self.industry = try values.decodeIfPresent(String.self, forKey: "industry")
                self.org = try values.decodeIfPresent(String.self, forKey: "org")
                self.jobTitle = try values.decodeIfPresent(String.self, forKey: "job_title")
                self.purchasingTimeFrame = try PurchasingTimeFrame(from: decoder)
                self.roleInPurchaseProcess = try RoleInPurchaseProcess(from: decoder)
                self.noOfEmployees = try NoOfEmployees(from: decoder)
                self.comments = try values.decodeIfPresent(String.self, forKey: "comments")
                self.customQuestions = try values.decodeIfPresent([CustomQuestion].self, forKey: "custom_questions")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(email, forKey: "email")
                try values.encodeIfPresent(status, forKey: "status")
                try values.encode(firstName, forKey: "first_name")
                try values.encodeIfPresent(lastName, forKey: "last_name")
                try values.encodeIfPresent(address, forKey: "address")
                try values.encodeIfPresent(city, forKey: "city")
                try values.encodeIfPresent(country, forKey: "country")
                try values.encodeIfPresent(zip, forKey: "zip")
                try values.encodeIfPresent(state, forKey: "state")
                try values.encodeIfPresent(phone, forKey: "phone")
                try values.encodeIfPresent(industry, forKey: "industry")
                try values.encodeIfPresent(org, forKey: "org")
                try values.encodeIfPresent(jobTitle, forKey: "job_title")
                try values.encodeIfPresent(purchasingTimeFrame, forKey: "purchasing_time_frame")
                try values.encodeIfPresent(roleInPurchaseProcess, forKey: "role_in_purchase_process")
                try values.encodeIfPresent(noOfEmployees, forKey: "no_of_employees")
                try values.encodeIfPresent(comments, forKey: "comments")
                try values.encodeIfPresent(customQuestions, forKey: "custom_questions")
            }
        }

        public init(id: String? = nil, b: B) {
            self.id = id
            self.b = b
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.b = try B(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encode(b, forKey: "b")
        }
    }

    public init(pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil, registrants: [Registrant]? = nil) {
        self.pageCount = pageCount
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.totalRecords = totalRecords
        self.nextPageToken = nextPageToken
        self.registrants = registrants
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.pageCount = try values.decodeIfPresent(Int.self, forKey: "page_count")
        self.pageNumber = try values.decodeIfPresent(Int.self, forKey: "page_number")
        self.pageSize = try values.decodeIfPresent(Int.self, forKey: "page_size")
        self.totalRecords = try values.decodeIfPresent(Int.self, forKey: "total_records")
        self.nextPageToken = try values.decodeIfPresent(String.self, forKey: "next_page_token")
        self.registrants = try values.decodeIfPresent([Registrant].self, forKey: "registrants")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(pageCount, forKey: "page_count")
        try values.encodeIfPresent(pageNumber, forKey: "page_number")
        try values.encodeIfPresent(pageSize, forKey: "page_size")
        try values.encodeIfPresent(totalRecords, forKey: "total_records")
        try values.encodeIfPresent(nextPageToken, forKey: "next_page_token")
        try values.encodeIfPresent(registrants, forKey: "registrants")
    }
}

public struct ParticipantAudioFile: Codable {
    /// The recording file's unique ID. This is included in the general query response.
    public var id: String?
    /// The recording file's start time.
    public var recordingStart: Date?
    /// The recording file's end time. This is included in the general query response.
    public var recordingEnd: Date?
    /// The recording file's format. One of:
    /// 
    /// * `MP4` — Video file.
    /// * `M4A` — Audio-only file.
    /// * `TIMELINE` — Timestamp file of the recording, in JSON file format. To get a timeline file, the **Add a timestamp to the recording** setting **must** be enabled in the [recording settings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-recording#h_3f14c3a4-d16b-4a3c-bbe5-ef7d24500048). The time will display in the host's timezone.
    /// * `TRANSCRIPT` — A transcript of the recording, in VTT format.
    /// * `CHAT` — A text file containing chat messages sent during the meeting.
    /// * `CC` — A file containing the closed captions of the recording, in VTT file format.
    /// * `CSV` — A file containing polling data, in CSV format.
    /// 
    /// A recording file object with file the `CC` or `TIMELINE` value **does not** have the `id`, `status`, `file_size`, `recording_type`, and `play_url` properties.
    public var fileType: String?
    /// The recording file's size, in bytes.
    public var fileSize: Double?
    /// The URL at which the recording file can be opened and played.
    public var playURL: String?
    /// The URL at which to download the the recording. 
    /// 
    /// **JWT apps** 
    /// 
    /// To access a private or password-protected cloud recording of a user in your account, use a [Zoom JWT app](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app). Use the generated JWT token as the value of the `access_token` query parameter and include this query parameter at the end of the URL. For example: 
    /// 
    /// `https://{{base-domain}}/recording/download/{{path-to-file-download}}?access_token={{JWT-token}}` 
    /// 
    /// **OAuth apps** 
    /// 
    /// If a user has authorized and installed your OAuth app that contains recording scopes, use the user’s [OAuth access token](https://marketplace.zoom.us/docs/guides/auth/oauth) to download the file. For example: 
    /// 
    /// `https://{{base-domain}}/rec/archive/download/xxx?access_token={{OAuth-access-token}}` 
    /// 
    /// **Note:** This field does **not** return for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). Instead, this API will return the `file_path` field.
    public var downloadURL: String?
    /// The file path to the On-Premise account recording. 
    /// 
    /// **Note:** This API only returns this field for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). It does **not** return the `download_url` field.
    public var filePath: String?
    /// The recording file's status.
    public var status: Status?
    /// The recording file's name.
    public var fileName: String?

    /// The recording file's status.
    public enum Status: String, Codable, CaseIterable {
        case completed
    }

    public init(id: String? = nil, recordingStart: Date? = nil, recordingEnd: Date? = nil, fileType: String? = nil, fileSize: Double? = nil, playURL: String? = nil, downloadURL: String? = nil, filePath: String? = nil, status: Status? = nil, fileName: String? = nil) {
        self.id = id
        self.recordingStart = recordingStart
        self.recordingEnd = recordingEnd
        self.fileType = fileType
        self.fileSize = fileSize
        self.playURL = playURL
        self.downloadURL = downloadURL
        self.filePath = filePath
        self.status = status
        self.fileName = fileName
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.recordingStart = try values.decodeIfPresent(Date.self, forKey: "recording_start")
        self.recordingEnd = try values.decodeIfPresent(Date.self, forKey: "recording_end")
        self.fileType = try values.decodeIfPresent(String.self, forKey: "file_type")
        self.fileSize = try values.decodeIfPresent(Double.self, forKey: "file_size")
        self.playURL = try values.decodeIfPresent(String.self, forKey: "play_url")
        self.downloadURL = try values.decodeIfPresent(String.self, forKey: "download_url")
        self.filePath = try values.decodeIfPresent(String.self, forKey: "file_path")
        self.status = try Status(from: decoder)
        self.fileName = try values.decodeIfPresent(String.self, forKey: "file_name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(recordingStart, forKey: "recording_start")
        try values.encodeIfPresent(recordingEnd, forKey: "recording_end")
        try values.encodeIfPresent(fileType, forKey: "file_type")
        try values.encodeIfPresent(fileSize, forKey: "file_size")
        try values.encodeIfPresent(playURL, forKey: "play_url")
        try values.encodeIfPresent(downloadURL, forKey: "download_url")
        try values.encodeIfPresent(filePath, forKey: "file_path")
        try values.encodeIfPresent(status, forKey: "status")
        try values.encodeIfPresent(fileName, forKey: "file_name")
    }
}

public struct RecordingSettings: Codable {
    /// Determine how the meeting recording is shared.
    public var shareRecording: ShareRecording?
    /// Only authenticated users can view.
    public var isRecordingAuthentication: Bool?
    /// Authentication Options.
    public var authenticationOption: String?
    /// Authentication domains.
    public var authenticationDomains: String?
    /// Determine whether a viewer can download the recording file or not.
    public var isViewerDownload: Bool?
    /// Enable password protection for the recording by setting a password. The password must have a minimum of **eight** characters with a mix of numbers, letters and special characters.<br><br>
    /// **Note:** If the account owner or the admin has set minimum password strength requirements for recordings via Account Settings, the password value provided here must meet those requirements. <br><br>If the requirements are enabled, you can view those requirements by calling either the [Get User Settings API](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings) or the [Get Account Settings](https://marketplace.zoom.us/docs/api-reference/zoom-api/accounts/accountsettings) API.
    public var password: String?
    /// Determine whether registration  isrequired to view the recording.
    public var isOnDemand: Bool?
    /// Approval type for the registration.<br>
    /// `0`- Automatically approve the registration when a user registers.<br>
    /// `1` - Manually approve or deny the registration of a user.<br>
    /// `2` - No registration required to view the recording.
    public var approvalType: Int?
    /// Send an email to host when someone registers to view the recording. This applies for On-demand recordings only.
    public var isSendEmailToHost: Bool?
    /// Show social share buttons on registration page. This applies for On-demand recordings only.
    public var isShowSocialShareButtons: Bool?
    /// Name of the recording.
    public var topic: String?

    /// Determine how the meeting recording is shared.
    public enum ShareRecording: String, Codable, CaseIterable {
        case publicly
        case internally
        case `none`
    }

    public init(shareRecording: ShareRecording? = nil, isRecordingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, isViewerDownload: Bool? = nil, password: String? = nil, isOnDemand: Bool? = nil, approvalType: Int? = nil, isSendEmailToHost: Bool? = nil, isShowSocialShareButtons: Bool? = nil, topic: String? = nil) {
        self.shareRecording = shareRecording
        self.isRecordingAuthentication = isRecordingAuthentication
        self.authenticationOption = authenticationOption
        self.authenticationDomains = authenticationDomains
        self.isViewerDownload = isViewerDownload
        self.password = password
        self.isOnDemand = isOnDemand
        self.approvalType = approvalType
        self.isSendEmailToHost = isSendEmailToHost
        self.isShowSocialShareButtons = isShowSocialShareButtons
        self.topic = topic
    }

    private enum CodingKeys: String, CodingKey {
        case shareRecording = "share_recording"
        case isRecordingAuthentication = "recording_authentication"
        case authenticationOption = "authentication_option"
        case authenticationDomains = "authentication_domains"
        case isViewerDownload = "viewer_download"
        case password
        case isOnDemand = "on_demand"
        case approvalType = "approval_type"
        case isSendEmailToHost = "send_email_to_host"
        case isShowSocialShareButtons = "show_social_share_buttons"
        case topic
    }
}

/// Cloud Recording Registration List
///
/// Information about the cloud recording registrations.
public struct RecordingRegistrantList: Codable {
    /// The number of pages returned for the request made.
    public var pageCount: Int?
    /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
    public var pageNumber: Int?
    /// The number of records returned with a single API call.
    public var pageSize: Int?
    /// The total number of all the records available across pages.
    public var totalRecords: Int?
    /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
    public var nextPageToken: String?
    /// Information about the cloud recording registrants.
    public var registrants: [Registrant]?

    public struct Registrant: Codable {
        /// The registrant's ID.
        public var id: String?
        /// Registrant.
        public var b: B

        /// Registrant.
        public struct B: Codable {
            /// The registrant's email address.
            public var email: String
            /// The registrant's status: 
            /// * `approved` — Registrant is approved. 
            /// * `denied` — Registrant is denied. 
            /// * `pending` — Registrant is waiting for approval.
            public var status: Status?
            /// The registrant's first name.
            public var firstName: String
            /// The registrant's last name.
            public var lastName: String?
            /// The registrant's address.
            public var address: String?
            /// The registrant's city.
            public var city: String?
            /// The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
            public var country: String?
            /// The registrant's ZIP or postal code.
            public var zip: String?
            /// The registrant's state or province.
            public var state: String?
            /// The registrant's phone number.
            public var phone: String?
            /// The registrant's industry.
            public var industry: String?
            /// The registrant's organization.
            public var org: String?
            /// The registrant's job title.
            public var jobTitle: String?
            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public var purchasingTimeFrame: PurchasingTimeFrame?
            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public var roleInPurchaseProcess: RoleInPurchaseProcess?
            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public var noOfEmployees: NoOfEmployees?
            /// The registrant's questions and comments.
            public var comments: String?
            /// Information about custom questions.
            public var customQuestions: [CustomQuestion]?

            /// The registrant's status: 
            /// * `approved` — Registrant is approved. 
            /// * `denied` — Registrant is denied. 
            /// * `pending` — Registrant is waiting for approval.
            public enum Status: String, Codable, CaseIterable {
                case approved
                case denied
                case pending
            }

            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public enum PurchasingTimeFrame: String, Codable, CaseIterable {
                case empty = ""
                case withinAMonth = "Within a month"
                case _13Months = "1-3 months"
                case _46Months = "4-6 months"
                case moreThan6Months = "More than 6 months"
                case noTimeframe = "No timeframe"
            }

            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public enum RoleInPurchaseProcess: String, Codable, CaseIterable {
                case empty = ""
                case decisionMaker = "Decision Maker"
                case evaluatorRecommender = "Evaluator/Recommender"
                case influencer = "Influencer"
                case notInvolved = "Not involved"
            }

            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public enum NoOfEmployees: String, Codable, CaseIterable {
                case empty = ""
                case _120 = "1-20"
                case _2150 = "21-50"
                case _51100 = "51-100"
                case _101500 = "101-500"
                case _5001000 = "500-1,000"
                case _10015000 = "1,001-5,000"
                case _500110000 = "5,001-10,000"
                case moreThan10000 = "More than 10,000"
            }

            /// Information about custom questions.
            public struct CustomQuestion: Codable {
                /// The title of the custom question.
                public var title: String?
                /// The custom question's response value. This has a limit of 128 characters.
                public var value: String?

                public init(title: String? = nil, value: String? = nil) {
                    self.title = title
                    self.value = value
                }
            }

            public init(email: String, status: Status? = nil, firstName: String, lastName: String? = nil, address: String? = nil, city: String? = nil, country: String? = nil, zip: String? = nil, state: String? = nil, phone: String? = nil, industry: String? = nil, org: String? = nil, jobTitle: String? = nil, purchasingTimeFrame: PurchasingTimeFrame? = nil, roleInPurchaseProcess: RoleInPurchaseProcess? = nil, noOfEmployees: NoOfEmployees? = nil, comments: String? = nil, customQuestions: [CustomQuestion]? = nil) {
                self.email = email
                self.status = status
                self.firstName = firstName
                self.lastName = lastName
                self.address = address
                self.city = city
                self.country = country
                self.zip = zip
                self.state = state
                self.phone = phone
                self.industry = industry
                self.org = org
                self.jobTitle = jobTitle
                self.purchasingTimeFrame = purchasingTimeFrame
                self.roleInPurchaseProcess = roleInPurchaseProcess
                self.noOfEmployees = noOfEmployees
                self.comments = comments
                self.customQuestions = customQuestions
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.email = try values.decode(String.self, forKey: "email")
                self.status = try Status(from: decoder)
                self.firstName = try values.decode(String.self, forKey: "first_name")
                self.lastName = try values.decodeIfPresent(String.self, forKey: "last_name")
                self.address = try values.decodeIfPresent(String.self, forKey: "address")
                self.city = try values.decodeIfPresent(String.self, forKey: "city")
                self.country = try values.decodeIfPresent(String.self, forKey: "country")
                self.zip = try values.decodeIfPresent(String.self, forKey: "zip")
                self.state = try values.decodeIfPresent(String.self, forKey: "state")
                self.phone = try values.decodeIfPresent(String.self, forKey: "phone")
                self.industry = try values.decodeIfPresent(String.self, forKey: "industry")
                self.org = try values.decodeIfPresent(String.self, forKey: "org")
                self.jobTitle = try values.decodeIfPresent(String.self, forKey: "job_title")
                self.purchasingTimeFrame = try PurchasingTimeFrame(from: decoder)
                self.roleInPurchaseProcess = try RoleInPurchaseProcess(from: decoder)
                self.noOfEmployees = try NoOfEmployees(from: decoder)
                self.comments = try values.decodeIfPresent(String.self, forKey: "comments")
                self.customQuestions = try values.decodeIfPresent([CustomQuestion].self, forKey: "custom_questions")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(email, forKey: "email")
                try values.encodeIfPresent(status, forKey: "status")
                try values.encode(firstName, forKey: "first_name")
                try values.encodeIfPresent(lastName, forKey: "last_name")
                try values.encodeIfPresent(address, forKey: "address")
                try values.encodeIfPresent(city, forKey: "city")
                try values.encodeIfPresent(country, forKey: "country")
                try values.encodeIfPresent(zip, forKey: "zip")
                try values.encodeIfPresent(state, forKey: "state")
                try values.encodeIfPresent(phone, forKey: "phone")
                try values.encodeIfPresent(industry, forKey: "industry")
                try values.encodeIfPresent(org, forKey: "org")
                try values.encodeIfPresent(jobTitle, forKey: "job_title")
                try values.encodeIfPresent(purchasingTimeFrame, forKey: "purchasing_time_frame")
                try values.encodeIfPresent(roleInPurchaseProcess, forKey: "role_in_purchase_process")
                try values.encodeIfPresent(noOfEmployees, forKey: "no_of_employees")
                try values.encodeIfPresent(comments, forKey: "comments")
                try values.encodeIfPresent(customQuestions, forKey: "custom_questions")
            }
        }

        public init(id: String? = nil, b: B) {
            self.id = id
            self.b = b
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.b = try B(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encode(b, forKey: "b")
        }
    }

    public init(pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil, registrants: [Registrant]? = nil) {
        self.pageCount = pageCount
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.totalRecords = totalRecords
        self.nextPageToken = nextPageToken
        self.registrants = registrants
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.pageCount = try values.decodeIfPresent(Int.self, forKey: "page_count")
        self.pageNumber = try values.decodeIfPresent(Int.self, forKey: "page_number")
        self.pageSize = try values.decodeIfPresent(Int.self, forKey: "page_size")
        self.totalRecords = try values.decodeIfPresent(Int.self, forKey: "total_records")
        self.nextPageToken = try values.decodeIfPresent(String.self, forKey: "next_page_token")
        self.registrants = try values.decodeIfPresent([Registrant].self, forKey: "registrants")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(pageCount, forKey: "page_count")
        try values.encodeIfPresent(pageNumber, forKey: "page_number")
        try values.encodeIfPresent(pageSize, forKey: "page_size")
        try values.encodeIfPresent(totalRecords, forKey: "total_records")
        try values.encodeIfPresent(nextPageToken, forKey: "next_page_token")
        try values.encodeIfPresent(registrants, forKey: "registrants")
    }
}

public struct CloudArchivedFiles: Codable {
    /// The meeting's universally unique ID (UUID). Each meeting instance generates its own meeting UUID.
    public var uuid: String
    /// The meeting's ID, in long (int64) format. This is also known as the meeting number.
    public var id: Int
    /// The ID of the user who was set as the meeting's host.
    public var hostID: String
    /// The meeting's topic.
    public var topic: String
    /// The type of archived meeting or the webinar:
    /// 
    /// Meeting types:
    /// * `1` — Instant meeting.
    /// * `2` — Scheduled meeting.
    /// * `3` — Recurring meeting with no fixed time.
    /// * `4` — Meeting created using a Personal Meeting ID.
    /// * `7` — Personal Audio Conference ([PAC](https://support.zoom.us/hc/en-us/articles/204517069-Getting-Started-with-Personal-Audio-Conference)).
    /// * `8` — Recurring meeting with a fixed time.
    /// 
    /// Webinar types:
    /// * `5` — Webinar
    /// * `6` — Recurring webinar without a fixed time.
    /// * `9` — Recurring webinar with a fixed time.
    /// 
    /// If the recording is **not** from a meeting or webinar:
    /// 
    /// * `99` — A recording uploaded via the [**Recordings**](https://zoom.us/recording) interface on the Zoom Web Portal.
    /// * `100` — A [breakout room](https://support.zoom.us/hc/en-us/articles/115005769646-Participating-in-breakout-rooms).
    public var type: Int
    /// The meeting's start time.
    public var startTime: Date
    /// The meeting's timezone.
    public var timezone: String
    /// The meeting's duration.
    public var duration: Int
    /// The total size of the archive file.
    public var totalSize: Int
    /// The number of recording files returned in the API call response.
    public var recordingCount: Int
    /// Whether the meeting or webinar is internal or external: 
    /// * `internal` — An internal meeting or webinar. 
    /// * `external` — An external meeting or webinar. 
    /// 
    ///  The `id`, `host_id`, and `topic` PII (Personal Identifiable Information) values in this response are removed when this value is `external`.
    public var meetingType: MeetingType
    /// The user's account name.
    public var accountName: String
    /// The meeting or webinar's archive completion time.
    public var completeTime: Date
    /// Whether the meeting room is a [breakout room](https://support.zoom.us/hc/en-us/articles/115005769646-Participating-in-breakout-rooms).
    public var isBreakoutRoom: Bool
    /// The parent meeting's universally unique ID (UUID). Each meeting instance generates its own meeting UUID. If the `is_breakout_room` value is `true`, the API returns this value.
    public var parentMeetingID: String?
    /// Information about the archive files.
    public var archiveFiles: [[String: AnyJSON]]

    /// Whether the meeting or webinar is internal or external: 
    /// * `internal` — An internal meeting or webinar. 
    /// * `external` — An external meeting or webinar. 
    /// 
    ///  The `id`, `host_id`, and `topic` PII (Personal Identifiable Information) values in this response are removed when this value is `external`.
    public enum MeetingType: String, Codable, CaseIterable {
        case `internal`
        case external
    }

    public init(uuid: String, id: Int, hostID: String, topic: String, type: Int, startTime: Date, timezone: String, duration: Int, totalSize: Int, recordingCount: Int, meetingType: MeetingType, accountName: String, completeTime: Date, isBreakoutRoom: Bool, parentMeetingID: String? = nil, archiveFiles: [[String: AnyJSON]]) {
        self.uuid = uuid
        self.id = id
        self.hostID = hostID
        self.topic = topic
        self.type = type
        self.startTime = startTime
        self.timezone = timezone
        self.duration = duration
        self.totalSize = totalSize
        self.recordingCount = recordingCount
        self.meetingType = meetingType
        self.accountName = accountName
        self.completeTime = completeTime
        self.isBreakoutRoom = isBreakoutRoom
        self.parentMeetingID = parentMeetingID
        self.archiveFiles = archiveFiles
    }

    private enum CodingKeys: String, CodingKey {
        case uuid
        case id
        case hostID = "host_id"
        case topic
        case type
        case startTime = "start_time"
        case timezone
        case duration
        case totalSize = "total_size"
        case recordingCount = "recording_count"
        case meetingType = "meeting_type"
        case accountName = "account_name"
        case completeTime = "complete_time"
        case isBreakoutRoom = "is_breakout_room"
        case parentMeetingID = "parent_meeting_id"
        case archiveFiles = "archive_files"
    }
}

/// Information about the account's plan.
public struct AccountPlanRequired: Codable {
    /// The account's [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
    public var type: String
    /// The account plan's number of hosts.
    public var hosts: Int

    public init(type: String, hosts: Int) {
        self.type = type
        self.hosts = hosts
    }
}

/// Information about the account's Base plan.
public struct AccountPlanBaseRequired: Codable {
    /// The account's [Base plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#base-plans).
    public var type: String
    /// The account plan's number of hosts: 
    /// * For a Pro plan, provide a value between `1` and `9`. 
    /// * For a Business Plan, provide a value between `10` and `49`. 
    /// * For a Education Plan, provide a value between `20` and `149`. 
    /// * For a Free Trial Plan, provide a value between `1` and `9999`. 
    /// 
    /// You **must** provide at least one positive integer value for the `hosts` or the `increasing_hosts` field.
    public var hosts: Int
    /// An optional number of additional hosts to add to the account's Base plan. 
    /// 
    /// You **must** provide at least one positive integer value for the `hosts` or the `increasing_hosts` field.
    public var increasingHosts: Int?

    public init(type: String, hosts: Int, increasingHosts: Int? = nil) {
        self.type = type
        self.hosts = hosts
        self.increasingHosts = increasingHosts
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case hosts
        case increasingHosts = "increasing_hosts"
    }
}

/// The account's billing contact information.
public struct BillingContactRequired: Codable {
    /// The billing contact's first name.
    public var firstName: String
    /// The billing contact's last name.
    public var lastName: String
    /// The billing contact's email address.
    public var email: String
    /// The billing contact's phone number.
    public var phoneNumber: String
    /// The billing contact's address.
    public var address: String
    /// The billing contact's apartment or suite number.
    public var apt: String?
    /// The billing contact's city.
    public var city: String
    /// The billing contact's state.
    public var state: String
    /// The billing contact's zip or postal code.
    public var zip: String
    /// The billing contact's [country ID abbreviation](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
    public var country: String

    public init(firstName: String, lastName: String, email: String, phoneNumber: String, address: String, apt: String? = nil, city: String, state: String, zip: String, country: String) {
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.phoneNumber = phoneNumber
        self.address = address
        self.apt = apt
        self.city = city
        self.state = state
        self.zip = zip
        self.country = country
    }

    private enum CodingKeys: String, CodingKey {
        case firstName = "first_name"
        case lastName = "last_name"
        case email
        case phoneNumber = "phone_number"
        case address
        case apt
        case city
        case state
        case zip
        case country
    }
}

/// Billing Contact object.
public struct BillingContact: Codable {
    /// Billing Contact's first name.
    public var firstName: String?
    /// Billing Contact's last name.
    public var lastName: String?
    /// Billing Contact's email address.
    public var email: String?
    /// Billing Contact's phone number.
    public var phoneNumber: String?
    /// Billing Contact's address.
    public var address: String?
    /// Billing Contact's apartment/suite.
    public var apt: String?
    /// Billing Contact's city.
    public var city: String?
    /// Billing Contact's state.
    public var state: String?
    /// Billing Contact's zip/postal code.
    public var zip: String?
    /// Billing Contact's country.
    public var country: String?

    public init(firstName: String? = nil, lastName: String? = nil, email: String? = nil, phoneNumber: String? = nil, address: String? = nil, apt: String? = nil, city: String? = nil, state: String? = nil, zip: String? = nil, country: String? = nil) {
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.phoneNumber = phoneNumber
        self.address = address
        self.apt = apt
        self.city = city
        self.state = state
        self.zip = zip
        self.country = country
    }

    private enum CodingKeys: String, CodingKey {
        case firstName = "first_name"
        case lastName = "last_name"
        case email
        case phoneNumber = "phone_number"
        case address
        case apt
        case city
        case state
        case zip
        case country
    }
}

/// Information about the account's Zoom Phone plan.
public struct PhonePlan: Codable {
    /// Information about the account's Zoom Phone Base plan.
    public var planBase: PlanBase?
    /// Information about the account's additional Zoom Phone calling plans.
    public var planCalling: [PlanCallingItem]?
    /// Information about the account's additional Zoom Phone number plans.
    public var planNumber: [PlanNumberItem]?

    /// Information about the account's Zoom Phone Base plan.
    public struct PlanBase: Codable {
        /// The [Zoom Phone Base plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#additional-zoom-phone-plans).
        public var type: String?
        /// A comma-separated list of the account's call-out countries. 
        /// 
        ///  For a list of values, refer to the `ID` field in the [TSP callout countries](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#tsp-countries) table.
        public var calloutCountries: String?

        public init(type: String? = nil, calloutCountries: String? = nil) {
            self.type = type
            self.calloutCountries = calloutCountries
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case calloutCountries = "callout_countries"
        }
    }

    public struct PlanCallingItem: Codable {
        /// The additional [Zoom Phone calling plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#additional-zoom-phone-plans).
        public var type: String?
        /// The account plan's number of hosts.
        public var hosts: Int?

        public init(type: String? = nil, hosts: Int? = nil) {
            self.type = type
            self.hosts = hosts
        }
    }

    public struct PlanNumberItem: Codable {
        /// The additional [Zoom Phone number plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#additional-zoom-phone-plans).
        public var type: String?
        /// The account plan's number of hosts.
        public var hosts: Int?

        public init(type: String? = nil, hosts: Int? = nil) {
            self.type = type
            self.hosts = hosts
        }
    }

    public init(planBase: PlanBase? = nil, planCalling: [PlanCallingItem]? = nil, planNumber: [PlanNumberItem]? = nil) {
        self.planBase = planBase
        self.planCalling = planCalling
        self.planNumber = planNumber
    }

    private enum CodingKeys: String, CodingKey {
        case planBase = "plan_base"
        case planCalling = "plan_calling"
        case planNumber = "plan_number"
    }
}

/// Information about the account's plan.
public struct AccountPlan: Codable {
    /// The account's [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
    public var type: String?
    /// The account plan's number of hosts.
    public var hosts: Int?

    public init(type: String? = nil, hosts: Int? = nil) {
        self.type = type
        self.hosts = hosts
    }
}

/// Information about the account's plan.
public struct AccountPlans: Codable {
    /// Information about the account's Base plan.
    public var planBase: PlanBase
    /// Information about the account's plan.
    public var planZoomRooms: PlanZoomRooms?
    /// Information about the account's plan.
    public var planRoomConnector: PlanRoomConnector?
    /// Information about the account's Large Meeting plan.
    public var planLargeMeeting: [PlanLargeMeetingItem]?
    /// Information about the account's Webinar plan.
    public var planWebinar: [PlanWebinarItem]?
    /// Information about the account's Zoom Events plan.
    public var planZoomEvents: [PlanZoomEvent]?
    /// The account's [Cloud Recording plan](https://marketplace.zoom.us/docs/api-reference/other-references/plans#cloud-recording-plans).
    public var planRecording: String?
    /// Information about the account's Audio Conferencing plan.
    public var planAudio: PlanAudio?
    /// Information about the account's Zoom Phone plan.
    public var planPhone: PlanPhone?

    /// Information about the account's Base plan.
    public struct PlanBase: Codable {
        /// The account's [Base plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#base-plans).
        public var type: String
        /// The account plan's number of hosts: 
        /// * For a Pro plan, provide a value between `1` and `9`. 
        /// * For a Business Plan, provide a value between `10` and `49`. 
        /// * For a Education Plan, provide a value between `20` and `149`. 
        /// * For a Free Trial Plan, provide a value between `1` and `9999`. 
        /// 
        /// You **must** provide at least one positive integer value for the `hosts` or the `increasing_hosts` field.
        public var hosts: Int
        /// An optional number of additional hosts to add to the account's Base plan. 
        /// 
        /// You **must** provide at least one positive integer value for the `hosts` or the `increasing_hosts` field.
        public var increasingHosts: Int?

        public init(type: String, hosts: Int, increasingHosts: Int? = nil) {
            self.type = type
            self.hosts = hosts
            self.increasingHosts = increasingHosts
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case hosts
            case increasingHosts = "increasing_hosts"
        }
    }

    /// Information about the account's plan.
    public struct PlanZoomRooms: Codable {
        /// The account's [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
        public var type: String?
        /// The account plan's number of hosts.
        public var hosts: Int?

        public init(type: String? = nil, hosts: Int? = nil) {
            self.type = type
            self.hosts = hosts
        }
    }

    /// Information about the account's plan.
    public struct PlanRoomConnector: Codable {
        /// The account's [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
        public var type: String?
        /// The account plan's number of hosts.
        public var hosts: Int?

        public init(type: String? = nil, hosts: Int? = nil) {
            self.type = type
            self.hosts = hosts
        }
    }

    /// Information about the account's plan.
    public struct PlanLargeMeetingItem: Codable {
        /// The account's [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
        public var type: String?
        /// The account plan's number of hosts.
        public var hosts: Int?

        public init(type: String? = nil, hosts: Int? = nil) {
            self.type = type
            self.hosts = hosts
        }
    }

    /// Information about the account's plan.
    public struct PlanWebinarItem: Codable {
        /// The account's [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
        public var type: String?
        /// The account plan's number of hosts.
        public var hosts: Int?

        public init(type: String? = nil, hosts: Int? = nil) {
            self.type = type
            self.hosts = hosts
        }
    }

    /// Information about the account's plan.
    public struct PlanZoomEvent: Codable {
        /// The account's [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
        public var type: String?
        /// The account plan's number of hosts.
        public var hosts: Int?

        public init(type: String? = nil, hosts: Int? = nil) {
            self.type = type
            self.hosts = hosts
        }
    }

    /// Information about the account's Audio Conferencing plan.
    public struct PlanAudio: Codable {
        /// The [Audio Conferencing plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#audio-conferencing-plans).
        public var type: String?
        /// A comma-separated list of the account's toll-free countries 
        /// 
        ///  For a list of values, refer to the `ID` field in the [Toll-free countries](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#toll-free) table.
        public var tollfreeCountries: String?
        /// A comma-separated list of the account's premium countries. 
        /// 
        ///  For a list of values, refer to the `ID` field in the [Premium countries](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#premium) table.
        public var premiumCountries: String?
        /// A comma-separated list of the account's call-out countries. 
        /// 
        ///  For a list of values, refer to the `ID` field in the [TSP callout countries](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#tsp-countries) table.
        public var calloutCountries: String?
        /// The account's dedicated dial-in (DDI) numbers.
        public var ddiNumbers: Int?

        public init(type: String? = nil, tollfreeCountries: String? = nil, premiumCountries: String? = nil, calloutCountries: String? = nil, ddiNumbers: Int? = nil) {
            self.type = type
            self.tollfreeCountries = tollfreeCountries
            self.premiumCountries = premiumCountries
            self.calloutCountries = calloutCountries
            self.ddiNumbers = ddiNumbers
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case tollfreeCountries = "tollfree_countries"
            case premiumCountries = "premium_countries"
            case calloutCountries = "callout_countries"
            case ddiNumbers = "ddi_numbers"
        }
    }

    /// Information about the account's Zoom Phone plan.
    public struct PlanPhone: Codable {
        /// Information about the account's Zoom Phone Base plan.
        public var planBase: PlanBase?
        /// Information about the account's additional Zoom Phone calling plans.
        public var planCalling: [PlanCallingItem]?
        /// Information about the account's additional Zoom Phone number plans.
        public var planNumber: [PlanNumberItem]?

        /// Information about the account's Zoom Phone Base plan.
        public struct PlanBase: Codable {
            /// The [Zoom Phone Base plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#additional-zoom-phone-plans).
            public var type: String?
            /// A comma-separated list of the account's call-out countries. 
            /// 
            ///  For a list of values, refer to the `ID` field in the [TSP callout countries](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#tsp-countries) table.
            public var calloutCountries: String?

            public init(type: String? = nil, calloutCountries: String? = nil) {
                self.type = type
                self.calloutCountries = calloutCountries
            }

            private enum CodingKeys: String, CodingKey {
                case type
                case calloutCountries = "callout_countries"
            }
        }

        public struct PlanCallingItem: Codable {
            /// The additional [Zoom Phone calling plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#additional-zoom-phone-plans).
            public var type: String?
            /// The account plan's number of hosts.
            public var hosts: Int?

            public init(type: String? = nil, hosts: Int? = nil) {
                self.type = type
                self.hosts = hosts
            }
        }

        public struct PlanNumberItem: Codable {
            /// The additional [Zoom Phone number plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#additional-zoom-phone-plans).
            public var type: String?
            /// The account plan's number of hosts.
            public var hosts: Int?

            public init(type: String? = nil, hosts: Int? = nil) {
                self.type = type
                self.hosts = hosts
            }
        }

        public init(planBase: PlanBase? = nil, planCalling: [PlanCallingItem]? = nil, planNumber: [PlanNumberItem]? = nil) {
            self.planBase = planBase
            self.planCalling = planCalling
            self.planNumber = planNumber
        }

        private enum CodingKeys: String, CodingKey {
            case planBase = "plan_base"
            case planCalling = "plan_calling"
            case planNumber = "plan_number"
        }
    }

    public init(planBase: PlanBase, planZoomRooms: PlanZoomRooms? = nil, planRoomConnector: PlanRoomConnector? = nil, planLargeMeeting: [PlanLargeMeetingItem]? = nil, planWebinar: [PlanWebinarItem]? = nil, planZoomEvents: [PlanZoomEvent]? = nil, planRecording: String? = nil, planAudio: PlanAudio? = nil, planPhone: PlanPhone? = nil) {
        self.planBase = planBase
        self.planZoomRooms = planZoomRooms
        self.planRoomConnector = planRoomConnector
        self.planLargeMeeting = planLargeMeeting
        self.planWebinar = planWebinar
        self.planZoomEvents = planZoomEvents
        self.planRecording = planRecording
        self.planAudio = planAudio
        self.planPhone = planPhone
    }

    private enum CodingKeys: String, CodingKey {
        case planBase = "plan_base"
        case planZoomRooms = "plan_zoom_rooms"
        case planRoomConnector = "plan_room_connector"
        case planLargeMeeting = "plan_large_meeting"
        case planWebinar = "plan_webinar"
        case planZoomEvents = "plan_zoom_events"
        case planRecording = "plan_recording"
        case planAudio = "plan_audio"
        case planPhone = "plan_phone"
    }
}

/// TSP Accounts List
///
/// List of TSP accounts.
public struct Tsp: Codable {
    /// Conference code: numeric value, length is less than 16.
    public var conferenceCode: String
    /// Leader PIN: numeric value, length is less than 16.
    public var leaderPin: String
    /// List of dial in numbers.
    public var dialInNumbers: [DialInNumber]?
    /// Telephony bridge
    public var tspBridge: TspBridge?

    public struct DialInNumber: Codable {
        /// Country code.
        public var code: String?
        /// Dial-in number: length is less than 16.
        public var number: String?
        /// Dial-in number types:<br>`toll` - Toll number.<br>`tollfree` -Toll free number.<br>
        /// `media_link` - Media link.
        public var type: `Type`?
        /// Country Label, if passed, will display in place of code.
        public var countryLabel: String?

        /// Dial-in number types:<br>`toll` - Toll number.<br>`tollfree` -Toll free number.<br>
        /// `media_link` - Media link.
        public enum `Type`: String, Codable, CaseIterable {
            case toll
            case tollfree
            case mediaLink = "media_link"
        }

        public init(code: String? = nil, number: String? = nil, type: `Type`? = nil, countryLabel: String? = nil) {
            self.code = code
            self.number = number
            self.type = type
            self.countryLabel = countryLabel
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case number
            case type
            case countryLabel = "country_label"
        }
    }

    /// Telephony bridge
    public enum TspBridge: String, Codable, CaseIterable {
        case usTspTb = "US_TSP_TB"
        case euTspTb = "EU_TSP_TB"
    }

    public init(conferenceCode: String, leaderPin: String, dialInNumbers: [DialInNumber]? = nil, tspBridge: TspBridge? = nil) {
        self.conferenceCode = conferenceCode
        self.leaderPin = leaderPin
        self.dialInNumbers = dialInNumbers
        self.tspBridge = tspBridge
    }

    private enum CodingKeys: String, CodingKey {
        case conferenceCode = "conference_code"
        case leaderPin = "leader_pin"
        case dialInNumbers = "dial_in_numbers"
        case tspBridge = "tsp_bridge"
    }
}

/// TSP Global Dial-In URL Setting
public struct TspGlobalDialIn: Codable {
    /// The global dial-in URL for a TSP enabled account. The URL must be valid with a max-length of 512 characters.
    public var audioURL: String?

    public init(audioURL: String? = nil) {
        self.audioURL = audioURL
    }

    private enum CodingKeys: String, CodingKey {
        case audioURL = "audio_url"
    }
}

/// Account Settings: In Meeting.
public struct AccountSettingsInMeeting: Codable {
    /// Zoom requires encryption for all data between the Zoom cloud, Zoom client, and Zoom Room. Require encryption for 3rd party endpoints (H323/SIP).
    public var isE2eEncryption: Bool?
    /// Allow meeting participants to send a message that is visible to all participants.
    public var isChat: Bool?
    /// Whether to allow participants to only chat with certain groups:
    /// * `1` — The participant cannot use chat.
    /// * `2` — Host and co-hosts only.
    ///  * `3` — The participant can chat with other participants publicly.
    /// * `4` - The participant can chat with other participants publicly and privately.
    /// 
    /// **Note:** This setting is only available with client versions 5.7.3 and above.
    public var allowParticipantsChatWith: Int?
    /// Whether to allow participants to save meeting chats:
    /// * `1` — Participants cannot save meeting chats.
    /// * `2` — Participants can only save host and co-host meeting chats.
    /// * `3` — Participants can save all meeting chats.
    public var allowUsersSaveChats: Int?
    /// Allow a meeting participant to send a private message to another participant.
    public var isPrivateChat: Bool?
    /// Automatically save all in-meeting chats so that the host does not need to manually save the chat transcript after the meeting starts.
    public var isAutoSavingChat: Bool?
    /// Play sound when participants join or leave.<br>`host` - Heard by host only.<br>`all` - Heard by host and all attendees.<br>`none` - Disable.
    public var entryExitChime: EntryExitChime?
    /// Record and play their own voice.
    public var isRecordPlayOwnVoice: Bool?
    /// Add a "Feedback" tab to the Windows Settings or Mac Preferences dialog. Enable users to provide feedback to Zoom at the end of the meeting.
    public var isFeedback: Bool?
    /// Display a thumbs up or down survey at the end of each meeting.
    public var isPostMeetingFeedback: Bool?
    /// Allow the host to add co-hosts.
    public var isCoHost: Bool?
    /// Add "Polls" to the meeting controls.
    public var isPolling: Bool?
    /// Allow host to put attendee on hold.
    /// 
    /// **This field has been deprecated and is no longer supported.**
    public var isAttendeeOnHold: Bool
    /// Always show the meeting control toolbar.
    public var isShowMeetingControlToolbar: Bool?
    /// Show the Zoom desktop application when sharing screens.
    public var allowShowZoomWindows: Bool?
    /// Allow participants to use annotation tools to add information to shared screens.
    public var isAnnotation: Bool?
    /// Allow participants to share a whiteboard that includes annotation tools.
    public var isWhiteboard: Bool?
    /// Whether attendees can ask the host and panelists questions in the webinar.
    public var isWebinarQuestionAnswer: Bool?
    /// Allow an anonymous Q&A in a webinar.
    public var isAnonymousQuestionAnswer: Bool?
    /// Allow host to split meeting participants into separate, smaller rooms.
    public var isBreakoutRoom: Bool?
    /// Whether the host can assign participants to breakout rooms when scheduling. This feature is only available in version 4.5.0 or higher.
    public var isBreakoutRoomSchedule: Bool?
    /// Allow a host to type closed captions. Enable a host to assign a participant or third party device to add closed captions.
    public var isClosedCaption: Bool?
    /// Allow another user to take control of your camera during a meeting.
    public var isFarEndCameraControl: Bool?
    /// Activate higher quality video for host and participants.
    /// Please note: This will use more bandwidth.
    public var isGroupHd: Bool?
    /// Allow users to replace their background with any selected image. Choose or upload an image in the Zoom desktop application settings.
    public var isVirtualBackground: Bool?
    /// Settings to manage virtual background.
    public var virtualBackgroundSettings: VirtualBackgroundSettings?
    /// Add a watermark when viewing a shared screen.
    public var isWatermark: Bool?
    /// Identify guest participants in a meeting or webinar.
    public var isAlertGuestJoin: Bool?
    /// Enable users to see and add contacts to the "auto-answer group" in the chat contact list. Any call from members of this group will automatically be answered.
    public var isAutoAnswer: Bool?
    /// Peer to peer connection while only two people are in a meeting.
    public var isP2pConnetion: Bool?
    /// Peer to peer listening ports range.
    public var isP2pPorts: Bool?
    /// The listening ports range, separated by a comma (ex 55,56). The ports range must be between 1 to 65535.
    public var portsRange: String?
    /// Only show the default email when sending email invites.
    public var isSendingDefaultEmailInvites: Bool?
    /// Use HTML formatted email for the Outlook plugin.
    public var useHTMLFormatEmail: Bool?
    /// DSCP marking.
    public var isDscpMarking: Bool?
    /// DSCP audio.
    public var dscpAudio: Int?
    /// DSCP video.
    public var dscpVideo: Int?
    /// Allow users to select stereo audio in their client settings.
    public var isStereoAudio: Bool?
    /// Allow users to select original sound in their client settings.
    public var isOriginalAudio: Bool?
    /// Allow screen sharing.
    public var isScreenSharing: Bool?
    /// Allow users to request remote control.
    public var isRemoteControl: Bool?
    /// Whether to allow livestreaming.
    public var allowLiveStreaming: Bool?
    /// Whether to allow Facebook livestreaming.
    public var isLiveStreamingFacebook: Bool?
    /// Whether to allow Workplace by Facebook livestreaming.
    public var isWorkplaceByFacebook: Bool?
    /// Whether to allow YouTube livestreaming.
    public var isLiveStreamingYoutube: Bool?
    /// Whether to allow custom livestreaming.
    public var isCustomLiveStreamingService: Bool?
    /// The specific instructions to configure a custom livestream.
    public var customServiceInstructions: String?
    /// If set to `true`, account owners and admins on paid accounts can [select data center regions](https://support.zoom.us/hc/en-us/articles/360042411451-Selecting-data-center-regions-for-hosted-meetings-and-webinars) to use for hosting their real-time meeting and webinar traffic. These regions can be provided in the `data_center_regions` field. If set to `false`, the regions cannot be customized and the default regions will be used.
    public var isCustomDataCenterRegions: Bool?
    /// If you have set the value of `custom_data_center_regions` to `true`, specify the data center regions that you would like to opt in to (country codes from among: ["EU", "HK", "AU", "IN", "LA", "TY", "CN", "US", "CA"]).
    public var dataCenterRegions: [String]?
    /// Whether meeting participants can [communicate using the emoji reactions](https://support.zoom.us/hc/en-us/articles/115001286183-Nonverbal-feedback-and-meeting-reactions) located in the **Reactions** menu in the meeting toolbar.
    public var isMeetingReactions: Bool?
    /// Whether to allow participants to join a meeting directly from their browser and bypass the Zoom application download process. This is useful for participants who cannot download, install, or run applications. Note that the meeting experience from the browser is limited.
    public var isShowAJoinFromYourBrowserLink: Bool?
    /// Whether to allow participants to join a meeting directly from their mobile browser. Note that the meeting experience from the mobile browser is limited.
    public var isJoinFromMobile: Bool?
    /// Whether to allow participants to join a meeting directly from their desktop browser. Note that the meeting experience from the desktop browser is limited.
    public var isJoinFromDesktop: Bool?
    /// If the value of this field is set to `true`, meeting participants and webinar panelists can be allowed to rename themselves during a meeting or a webinar.
    public var allowParticipantsToRename: Bool?
    /// Indicates who can share their screen or content during meetings. The value can be one of the following: <br>
    /// `host`: Only host can share the screen.<br>
    /// `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
    public var whoCanShareScreen: WhoCanShareScreen?
    /// Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:<br>
    /// `host`: Only a host can share the screen when someone else is sharing.<br>
    /// `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
    public var whoCanShareScreenWhenSomeoneIsSharing: WhoCanShareScreenWhenSomeoneIsSharing?
    /// Indicates whether [in-meeting file transfer](https://support.zoom.us/hc/en-us/articles/209605493-In-meeting-file-transfer) setting has been enabled on the account or not.
    public var isFileTransfer: Bool?
    /// Indicates whether the [**Request permission to unmute participants**](https://support.zoom.us/hc/en-us/articles/203435537-Muting-and-unmuting-participants-in-a-meeting#h_01EGK4XFWS1SJGZ71MYGKF7260) option has been enabled for the account or not.
    public var isRequestPermissionToUnmute: Bool?
    public var webinarLiveStreaming: WebinarLiveStreaming?
    public var webinarChat: WebinarChat?
    /// Information about the account's closed captioning settings.
    public var closedCaptioning: ClosedCaptioning?
    /// Whether the person sharing during a presentation can allow others to control the slide presentation. This feature is only available in version 5.8.3 or higher.
    public var isSlideControl: Bool?
    /// Whether to allow the host to present a survey to participants once a meeting has ended. This feature is only available in version 5.7.3 or higher.
    public var isMeetingSurvey: Bool?
    /// Information about the account's webinar polling settings.
    public var webinarPolling: WebinarPolling?
    /// Whether to allow the host to present surveys to attendees once a webinar has ended.
    public var isWebinarSurvey: Bool?

    /// Play sound when participants join or leave.<br>`host` - Heard by host only.<br>`all` - Heard by host and all attendees.<br>`none` - Disable.
    public enum EntryExitChime: String, Codable, CaseIterable {
        case host
        case all
        case `none`
    }

    /// Settings to manage virtual background.
    public struct VirtualBackgroundSettings: Codable {
        /// Enable virtual background.
        public var enable: Bool?
        /// Allow use of videos for virtual backgrounds.
        public var allowVideos: Bool?
        /// Allow users to upload custom backgrounds.
        public var allowUploadCustom: Bool?
        public var files: [File]?

        public struct File: Codable {
            /// Unique identifier of the file.
            public var id: String?
            /// File name.
            public var name: String?
            /// File type.
            public var type: String?
            /// Indicates whether or not this file is the default virtual background file.
            public var isDefault: Bool?
            /// File size.
            public var size: String?

            public init(id: String? = nil, name: String? = nil, type: String? = nil, isDefault: Bool? = nil, size: String? = nil) {
                self.id = id
                self.name = name
                self.type = type
                self.isDefault = isDefault
                self.size = size
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case name
                case type
                case isDefault = "is_default"
                case size
            }
        }

        public init(enable: Bool? = nil, allowVideos: Bool? = nil, allowUploadCustom: Bool? = nil, files: [File]? = nil) {
            self.enable = enable
            self.allowVideos = allowVideos
            self.allowUploadCustom = allowUploadCustom
            self.files = files
        }

        private enum CodingKeys: String, CodingKey {
            case enable
            case allowVideos = "allow_videos"
            case allowUploadCustom = "allow_upload_custom"
            case files
        }
    }

    /// Indicates who can share their screen or content during meetings. The value can be one of the following: <br>
    /// `host`: Only host can share the screen.<br>
    /// `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
    public enum WhoCanShareScreen: String, Codable, CaseIterable {
        case host
        case all
    }

    /// Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:<br>
    /// `host`: Only a host can share the screen when someone else is sharing.<br>
    /// `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
    public enum WhoCanShareScreenWhenSomeoneIsSharing: String, Codable, CaseIterable {
        case host
        case all
    }

    public struct WebinarLiveStreaming: Codable {
        /// Whether webinar livestreaming is enabled.
        public var enable: Bool?
        /// The available livestreaming services:
        /// * `facebook`
        /// * `workplace_by_facebook`
        /// * `youtube`
        /// * `custom_live_streaming_service`
        public var liveStreamingService: [LiveStreamingServiceItem]?
        /// The specific instructions to allow your account's meeting hosts to configure a custom livestream.
        public var customServiceInstructions: String?
        /// Whether to notify users to watch the livestream. This does not apply to custom RTMP (real-time messaging protocol).
        public var isLiveStreamingReminder: Bool?

        public enum LiveStreamingServiceItem: String, Codable, CaseIterable {
            case facebook
            case workplaceByFacebook = "workplace_by_facebook"
            case youtube
            case customLiveStreamingService = "custom_live_streaming_service"
        }

        public init(enable: Bool? = nil, liveStreamingService: [LiveStreamingServiceItem]? = nil, customServiceInstructions: String? = nil, isLiveStreamingReminder: Bool? = nil) {
            self.enable = enable
            self.liveStreamingService = liveStreamingService
            self.customServiceInstructions = customServiceInstructions
            self.isLiveStreamingReminder = isLiveStreamingReminder
        }

        private enum CodingKeys: String, CodingKey {
            case enable
            case liveStreamingService = "live_streaming_service"
            case customServiceInstructions = "custom_service_instructions"
            case isLiveStreamingReminder = "live_streaming_reminder"
        }
    }

    public struct WebinarChat: Codable {
        /// Whether to allow webinar participants to send chat messages.
        public var enable: Bool?
        /// Allow webinar panelists to chat with:
        /// * `1` — Host and all panelists.
        /// * `2` — Everyone.
        public var allowPanelistsChatWith: Int?
        /// Allow webinar attendees to chat with:
        /// * `1` — No one.
        /// * `2` — Host and all panelists.
        /// * `3` — Everyone.
        public var allowAttendeesChatWith: Int?
        /// By default, allow webinar attendees to chat with:
        /// * `1` — Host and all panelists.
        /// * `2` — Everyone.
        public var defaultAttendeesChatWith: Int?
        /// Whether to allow webinar panelists to send direct messages to other panelists.
        public var allowPanelistsSendDirectMessage: Bool?
        /// Whether to allow webinar attendees to save chats:
        /// * `0` — Attendees cannot save chats.
        /// * `1` — Attendees can only save host and panelist chats.
        /// * `2` — Attendees can save all chats.
        public var allowUsersSaveChats: Int?
        /// Whether to automatically save chat messages to a local file on the host's computer when the webinar ends.
        public var allowAutoSaveLocalChatFile: Bool?

        public init(enable: Bool? = nil, allowPanelistsChatWith: Int? = nil, allowAttendeesChatWith: Int? = nil, defaultAttendeesChatWith: Int? = nil, allowPanelistsSendDirectMessage: Bool? = nil, allowUsersSaveChats: Int? = nil, allowAutoSaveLocalChatFile: Bool? = nil) {
            self.enable = enable
            self.allowPanelistsChatWith = allowPanelistsChatWith
            self.allowAttendeesChatWith = allowAttendeesChatWith
            self.defaultAttendeesChatWith = defaultAttendeesChatWith
            self.allowPanelistsSendDirectMessage = allowPanelistsSendDirectMessage
            self.allowUsersSaveChats = allowUsersSaveChats
            self.allowAutoSaveLocalChatFile = allowAutoSaveLocalChatFile
        }

        private enum CodingKeys: String, CodingKey {
            case enable
            case allowPanelistsChatWith = "allow_panelists_chat_with"
            case allowAttendeesChatWith = "allow_attendees_chat_with"
            case defaultAttendeesChatWith = "default_attendees_chat_with"
            case allowPanelistsSendDirectMessage = "allow_panelists_send_direct_message"
            case allowUsersSaveChats = "allow_users_save_chats"
            case allowAutoSaveLocalChatFile = "allow_auto_save_local_chat_file"
        }
    }

    /// Information about the account's closed captioning settings.
    public struct ClosedCaptioning: Codable {
        /// Whether to allow the host to type closed captions or assign a participant or 3rd-party service to provide closed captioning.
        public var enable: Bool?
        /// Whether to allow the use of an API token to integrate with 3rd-party closed captioning services.
        public var isThirdPartyCaptioningService: Bool?
        /// Whether to allow a live transcription service to transcribe meetings.
        public var isAutoTranscribing: Bool?
        /// Whether to allow the viewing of full transcripts in the in-meeting side panel.
        public var isViewFullTranscript: Bool?
        /// Whether to allow participants to save closed captions or transcripts.
        public var isSaveCaption: Bool?

        public init(enable: Bool? = nil, isThirdPartyCaptioningService: Bool? = nil, isAutoTranscribing: Bool? = nil, isViewFullTranscript: Bool? = nil, isSaveCaption: Bool? = nil) {
            self.enable = enable
            self.isThirdPartyCaptioningService = isThirdPartyCaptioningService
            self.isAutoTranscribing = isAutoTranscribing
            self.isViewFullTranscript = isViewFullTranscript
            self.isSaveCaption = isSaveCaption
        }

        private enum CodingKeys: String, CodingKey {
            case enable
            case isThirdPartyCaptioningService = "third_party_captioning_service"
            case isAutoTranscribing = "auto_transcribing"
            case isViewFullTranscript = "view_full_transcript"
            case isSaveCaption = "save_caption"
        }
    }

    /// Information about the account's webinar polling settings.
    public struct WebinarPolling: Codable {
        /// Whether to allow the host to add polls before or during a webinar.
        public var enable: Bool?
        /// Whether to allow host to create advanced polls and quizzes. Advanced polls and quizzes include single choice, multiple choice, drop down, matching, short answer, long answer, rank order, and fill-in-the-blank questions. Hosts can also set the correct answers for quizzes they create.
        public var isAdvancedPolls: Bool?

        public init(enable: Bool? = nil, isAdvancedPolls: Bool? = nil) {
            self.enable = enable
            self.isAdvancedPolls = isAdvancedPolls
        }

        private enum CodingKeys: String, CodingKey {
            case enable
            case isAdvancedPolls = "advanced_polls"
        }
    }

    public init(isE2eEncryption: Bool? = nil, isChat: Bool? = nil, allowParticipantsChatWith: Int? = nil, allowUsersSaveChats: Int? = nil, isPrivateChat: Bool? = nil, isAutoSavingChat: Bool? = nil, entryExitChime: EntryExitChime? = nil, isRecordPlayOwnVoice: Bool? = nil, isFeedback: Bool? = nil, isPostMeetingFeedback: Bool? = nil, isCoHost: Bool? = nil, isPolling: Bool? = nil, isAttendeeOnHold: Bool? = nil, isShowMeetingControlToolbar: Bool? = nil, allowShowZoomWindows: Bool? = nil, isAnnotation: Bool? = nil, isWhiteboard: Bool? = nil, isWebinarQuestionAnswer: Bool? = nil, isAnonymousQuestionAnswer: Bool? = nil, isBreakoutRoom: Bool? = nil, isBreakoutRoomSchedule: Bool? = nil, isClosedCaption: Bool? = nil, isFarEndCameraControl: Bool? = nil, isGroupHd: Bool? = nil, isVirtualBackground: Bool? = nil, virtualBackgroundSettings: VirtualBackgroundSettings? = nil, isWatermark: Bool? = nil, isAlertGuestJoin: Bool? = nil, isAutoAnswer: Bool? = nil, isP2pConnetion: Bool? = nil, isP2pPorts: Bool? = nil, portsRange: String? = nil, isSendingDefaultEmailInvites: Bool? = nil, useHTMLFormatEmail: Bool? = nil, isDscpMarking: Bool? = nil, dscpAudio: Int? = nil, dscpVideo: Int? = nil, isStereoAudio: Bool? = nil, isOriginalAudio: Bool? = nil, isScreenSharing: Bool? = nil, isRemoteControl: Bool? = nil, allowLiveStreaming: Bool? = nil, isLiveStreamingFacebook: Bool? = nil, isWorkplaceByFacebook: Bool? = nil, isLiveStreamingYoutube: Bool? = nil, isCustomLiveStreamingService: Bool? = nil, customServiceInstructions: String? = nil, isCustomDataCenterRegions: Bool? = nil, dataCenterRegions: [String]? = nil, isMeetingReactions: Bool? = nil, isShowAJoinFromYourBrowserLink: Bool? = nil, isJoinFromMobile: Bool? = nil, isJoinFromDesktop: Bool? = nil, allowParticipantsToRename: Bool? = nil, whoCanShareScreen: WhoCanShareScreen? = nil, whoCanShareScreenWhenSomeoneIsSharing: WhoCanShareScreenWhenSomeoneIsSharing? = nil, isFileTransfer: Bool? = nil, isRequestPermissionToUnmute: Bool? = nil, webinarLiveStreaming: WebinarLiveStreaming? = nil, webinarChat: WebinarChat? = nil, closedCaptioning: ClosedCaptioning? = nil, isSlideControl: Bool? = nil, isMeetingSurvey: Bool? = nil, webinarPolling: WebinarPolling? = nil, isWebinarSurvey: Bool? = nil) {
        self.isE2eEncryption = isE2eEncryption
        self.isChat = isChat
        self.allowParticipantsChatWith = allowParticipantsChatWith
        self.allowUsersSaveChats = allowUsersSaveChats
        self.isPrivateChat = isPrivateChat
        self.isAutoSavingChat = isAutoSavingChat
        self.entryExitChime = entryExitChime
        self.isRecordPlayOwnVoice = isRecordPlayOwnVoice
        self.isFeedback = isFeedback
        self.isPostMeetingFeedback = isPostMeetingFeedback
        self.isCoHost = isCoHost
        self.isPolling = isPolling
        self.isAttendeeOnHold = isAttendeeOnHold ?? false
        self.isShowMeetingControlToolbar = isShowMeetingControlToolbar
        self.allowShowZoomWindows = allowShowZoomWindows
        self.isAnnotation = isAnnotation
        self.isWhiteboard = isWhiteboard
        self.isWebinarQuestionAnswer = isWebinarQuestionAnswer
        self.isAnonymousQuestionAnswer = isAnonymousQuestionAnswer
        self.isBreakoutRoom = isBreakoutRoom
        self.isBreakoutRoomSchedule = isBreakoutRoomSchedule
        self.isClosedCaption = isClosedCaption
        self.isFarEndCameraControl = isFarEndCameraControl
        self.isGroupHd = isGroupHd
        self.isVirtualBackground = isVirtualBackground
        self.virtualBackgroundSettings = virtualBackgroundSettings
        self.isWatermark = isWatermark
        self.isAlertGuestJoin = isAlertGuestJoin
        self.isAutoAnswer = isAutoAnswer
        self.isP2pConnetion = isP2pConnetion
        self.isP2pPorts = isP2pPorts
        self.portsRange = portsRange
        self.isSendingDefaultEmailInvites = isSendingDefaultEmailInvites
        self.useHTMLFormatEmail = useHTMLFormatEmail
        self.isDscpMarking = isDscpMarking
        self.dscpAudio = dscpAudio
        self.dscpVideo = dscpVideo
        self.isStereoAudio = isStereoAudio
        self.isOriginalAudio = isOriginalAudio
        self.isScreenSharing = isScreenSharing
        self.isRemoteControl = isRemoteControl
        self.allowLiveStreaming = allowLiveStreaming
        self.isLiveStreamingFacebook = isLiveStreamingFacebook
        self.isWorkplaceByFacebook = isWorkplaceByFacebook
        self.isLiveStreamingYoutube = isLiveStreamingYoutube
        self.isCustomLiveStreamingService = isCustomLiveStreamingService
        self.customServiceInstructions = customServiceInstructions
        self.isCustomDataCenterRegions = isCustomDataCenterRegions
        self.dataCenterRegions = dataCenterRegions
        self.isMeetingReactions = isMeetingReactions
        self.isShowAJoinFromYourBrowserLink = isShowAJoinFromYourBrowserLink
        self.isJoinFromMobile = isJoinFromMobile
        self.isJoinFromDesktop = isJoinFromDesktop
        self.allowParticipantsToRename = allowParticipantsToRename
        self.whoCanShareScreen = whoCanShareScreen
        self.whoCanShareScreenWhenSomeoneIsSharing = whoCanShareScreenWhenSomeoneIsSharing
        self.isFileTransfer = isFileTransfer
        self.isRequestPermissionToUnmute = isRequestPermissionToUnmute
        self.webinarLiveStreaming = webinarLiveStreaming
        self.webinarChat = webinarChat
        self.closedCaptioning = closedCaptioning
        self.isSlideControl = isSlideControl
        self.isMeetingSurvey = isMeetingSurvey
        self.webinarPolling = webinarPolling
        self.isWebinarSurvey = isWebinarSurvey
    }

    private enum CodingKeys: String, CodingKey {
        case isE2eEncryption = "e2e_encryption"
        case isChat = "chat"
        case allowParticipantsChatWith = "allow_participants_chat_with"
        case allowUsersSaveChats = "allow_users_save_chats"
        case isPrivateChat = "private_chat"
        case isAutoSavingChat = "auto_saving_chat"
        case entryExitChime = "entry_exit_chime"
        case isRecordPlayOwnVoice = "record_play_own_voice"
        case isFeedback = "feedback"
        case isPostMeetingFeedback = "post_meeting_feedback"
        case isCoHost = "co_host"
        case isPolling = "polling"
        case isAttendeeOnHold = "attendee_on_hold"
        case isShowMeetingControlToolbar = "show_meeting_control_toolbar"
        case allowShowZoomWindows = "allow_show_zoom_windows"
        case isAnnotation = "annotation"
        case isWhiteboard = "whiteboard"
        case isWebinarQuestionAnswer = "webinar_question_answer"
        case isAnonymousQuestionAnswer = "anonymous_question_answer"
        case isBreakoutRoom = "breakout_room"
        case isBreakoutRoomSchedule = "breakout_room_schedule"
        case isClosedCaption = "closed_caption"
        case isFarEndCameraControl = "far_end_camera_control"
        case isGroupHd = "group_hd"
        case isVirtualBackground = "virtual_background"
        case virtualBackgroundSettings = "virtual_background_settings"
        case isWatermark = "watermark"
        case isAlertGuestJoin = "alert_guest_join"
        case isAutoAnswer = "auto_answer"
        case isP2pConnetion = "p2p_connetion"
        case isP2pPorts = "p2p_ports"
        case portsRange = "ports_range"
        case isSendingDefaultEmailInvites = "sending_default_email_invites"
        case useHTMLFormatEmail = "use_html_format_email"
        case isDscpMarking = "dscp_marking"
        case dscpAudio = "dscp_audio"
        case dscpVideo = "dscp_video"
        case isStereoAudio = "stereo_audio"
        case isOriginalAudio = "original_audio"
        case isScreenSharing = "screen_sharing"
        case isRemoteControl = "remote_control"
        case allowLiveStreaming = "allow_live_streaming"
        case isLiveStreamingFacebook = "live_streaming_facebook"
        case isWorkplaceByFacebook = "workplace_by_facebook"
        case isLiveStreamingYoutube = "live_streaming_youtube"
        case isCustomLiveStreamingService = "custom_live_streaming_service"
        case customServiceInstructions = "custom_service_instructions"
        case isCustomDataCenterRegions = "custom_data_center_regions"
        case dataCenterRegions = "data_center_regions"
        case isMeetingReactions = "meeting_reactions"
        case isShowAJoinFromYourBrowserLink = "show_a_join_from_your_browser_link"
        case isJoinFromMobile = "join_from_mobile"
        case isJoinFromDesktop = "join_from_desktop"
        case allowParticipantsToRename = "allow_participants_to_rename"
        case whoCanShareScreen = "who_can_share_screen"
        case whoCanShareScreenWhenSomeoneIsSharing = "who_can_share_screen_when_someone_is_sharing"
        case isFileTransfer = "file_transfer"
        case isRequestPermissionToUnmute = "request_permission_to_unmute"
        case webinarLiveStreaming = "webinar_live_streaming"
        case webinarChat = "webinar_chat"
        case closedCaptioning = "closed_captioning"
        case isSlideControl = "slide_control"
        case isMeetingSurvey = "meeting_survey"
        case webinarPolling = "webinar_polling"
        case isWebinarSurvey = "webinar_survey"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isE2eEncryption = try values.decodeIfPresent(Bool.self, forKey: .isE2eEncryption)
        self.isChat = try values.decodeIfPresent(Bool.self, forKey: .isChat)
        self.allowParticipantsChatWith = try values.decodeIfPresent(Int.self, forKey: .allowParticipantsChatWith)
        self.allowUsersSaveChats = try values.decodeIfPresent(Int.self, forKey: .allowUsersSaveChats)
        self.isPrivateChat = try values.decodeIfPresent(Bool.self, forKey: .isPrivateChat)
        self.isAutoSavingChat = try values.decodeIfPresent(Bool.self, forKey: .isAutoSavingChat)
        self.entryExitChime = try values.decodeIfPresent(EntryExitChime.self, forKey: .entryExitChime)
        self.isRecordPlayOwnVoice = try values.decodeIfPresent(Bool.self, forKey: .isRecordPlayOwnVoice)
        self.isFeedback = try values.decodeIfPresent(Bool.self, forKey: .isFeedback)
        self.isPostMeetingFeedback = try values.decodeIfPresent(Bool.self, forKey: .isPostMeetingFeedback)
        self.isCoHost = try values.decodeIfPresent(Bool.self, forKey: .isCoHost)
        self.isPolling = try values.decodeIfPresent(Bool.self, forKey: .isPolling)
        self.isAttendeeOnHold = try values.decodeIfPresent(Bool.self, forKey: .isAttendeeOnHold) ?? false
        self.isShowMeetingControlToolbar = try values.decodeIfPresent(Bool.self, forKey: .isShowMeetingControlToolbar)
        self.allowShowZoomWindows = try values.decodeIfPresent(Bool.self, forKey: .allowShowZoomWindows)
        self.isAnnotation = try values.decodeIfPresent(Bool.self, forKey: .isAnnotation)
        self.isWhiteboard = try values.decodeIfPresent(Bool.self, forKey: .isWhiteboard)
        self.isWebinarQuestionAnswer = try values.decodeIfPresent(Bool.self, forKey: .isWebinarQuestionAnswer)
        self.isAnonymousQuestionAnswer = try values.decodeIfPresent(Bool.self, forKey: .isAnonymousQuestionAnswer)
        self.isBreakoutRoom = try values.decodeIfPresent(Bool.self, forKey: .isBreakoutRoom)
        self.isBreakoutRoomSchedule = try values.decodeIfPresent(Bool.self, forKey: .isBreakoutRoomSchedule)
        self.isClosedCaption = try values.decodeIfPresent(Bool.self, forKey: .isClosedCaption)
        self.isFarEndCameraControl = try values.decodeIfPresent(Bool.self, forKey: .isFarEndCameraControl)
        self.isGroupHd = try values.decodeIfPresent(Bool.self, forKey: .isGroupHd)
        self.isVirtualBackground = try values.decodeIfPresent(Bool.self, forKey: .isVirtualBackground)
        self.virtualBackgroundSettings = try values.decodeIfPresent(VirtualBackgroundSettings.self, forKey: .virtualBackgroundSettings)
        self.isWatermark = try values.decodeIfPresent(Bool.self, forKey: .isWatermark)
        self.isAlertGuestJoin = try values.decodeIfPresent(Bool.self, forKey: .isAlertGuestJoin)
        self.isAutoAnswer = try values.decodeIfPresent(Bool.self, forKey: .isAutoAnswer)
        self.isP2pConnetion = try values.decodeIfPresent(Bool.self, forKey: .isP2pConnetion)
        self.isP2pPorts = try values.decodeIfPresent(Bool.self, forKey: .isP2pPorts)
        self.portsRange = try values.decodeIfPresent(String.self, forKey: .portsRange)
        self.isSendingDefaultEmailInvites = try values.decodeIfPresent(Bool.self, forKey: .isSendingDefaultEmailInvites)
        self.useHTMLFormatEmail = try values.decodeIfPresent(Bool.self, forKey: .useHTMLFormatEmail)
        self.isDscpMarking = try values.decodeIfPresent(Bool.self, forKey: .isDscpMarking)
        self.dscpAudio = try values.decodeIfPresent(Int.self, forKey: .dscpAudio)
        self.dscpVideo = try values.decodeIfPresent(Int.self, forKey: .dscpVideo)
        self.isStereoAudio = try values.decodeIfPresent(Bool.self, forKey: .isStereoAudio)
        self.isOriginalAudio = try values.decodeIfPresent(Bool.self, forKey: .isOriginalAudio)
        self.isScreenSharing = try values.decodeIfPresent(Bool.self, forKey: .isScreenSharing)
        self.isRemoteControl = try values.decodeIfPresent(Bool.self, forKey: .isRemoteControl)
        self.allowLiveStreaming = try values.decodeIfPresent(Bool.self, forKey: .allowLiveStreaming)
        self.isLiveStreamingFacebook = try values.decodeIfPresent(Bool.self, forKey: .isLiveStreamingFacebook)
        self.isWorkplaceByFacebook = try values.decodeIfPresent(Bool.self, forKey: .isWorkplaceByFacebook)
        self.isLiveStreamingYoutube = try values.decodeIfPresent(Bool.self, forKey: .isLiveStreamingYoutube)
        self.isCustomLiveStreamingService = try values.decodeIfPresent(Bool.self, forKey: .isCustomLiveStreamingService)
        self.customServiceInstructions = try values.decodeIfPresent(String.self, forKey: .customServiceInstructions)
        self.isCustomDataCenterRegions = try values.decodeIfPresent(Bool.self, forKey: .isCustomDataCenterRegions)
        self.dataCenterRegions = try values.decodeIfPresent([String].self, forKey: .dataCenterRegions)
        self.isMeetingReactions = try values.decodeIfPresent(Bool.self, forKey: .isMeetingReactions)
        self.isShowAJoinFromYourBrowserLink = try values.decodeIfPresent(Bool.self, forKey: .isShowAJoinFromYourBrowserLink)
        self.isJoinFromMobile = try values.decodeIfPresent(Bool.self, forKey: .isJoinFromMobile)
        self.isJoinFromDesktop = try values.decodeIfPresent(Bool.self, forKey: .isJoinFromDesktop)
        self.allowParticipantsToRename = try values.decodeIfPresent(Bool.self, forKey: .allowParticipantsToRename)
        self.whoCanShareScreen = try values.decodeIfPresent(WhoCanShareScreen.self, forKey: .whoCanShareScreen)
        self.whoCanShareScreenWhenSomeoneIsSharing = try values.decodeIfPresent(WhoCanShareScreenWhenSomeoneIsSharing.self, forKey: .whoCanShareScreenWhenSomeoneIsSharing)
        self.isFileTransfer = try values.decodeIfPresent(Bool.self, forKey: .isFileTransfer)
        self.isRequestPermissionToUnmute = try values.decodeIfPresent(Bool.self, forKey: .isRequestPermissionToUnmute)
        self.webinarLiveStreaming = try values.decodeIfPresent(WebinarLiveStreaming.self, forKey: .webinarLiveStreaming)
        self.webinarChat = try values.decodeIfPresent(WebinarChat.self, forKey: .webinarChat)
        self.closedCaptioning = try values.decodeIfPresent(ClosedCaptioning.self, forKey: .closedCaptioning)
        self.isSlideControl = try values.decodeIfPresent(Bool.self, forKey: .isSlideControl)
        self.isMeetingSurvey = try values.decodeIfPresent(Bool.self, forKey: .isMeetingSurvey)
        self.webinarPolling = try values.decodeIfPresent(WebinarPolling.self, forKey: .webinarPolling)
        self.isWebinarSurvey = try values.decodeIfPresent(Bool.self, forKey: .isWebinarSurvey)
    }
}

/// Account Settings: Integration.
public struct AccountSettingsIntegration: Codable {
    /// Enable meetings to be scheduled using Google Calendar.
    public var isGoogleCalendar: Bool?
    /// Enable users who join a meeting from their mobile device to share content from their Google Drive.
    public var isGoogleDrive: Bool?
    /// Enable users who join a meeting from their mobile device to share content from their Dropbox account.
    public var isDropbox: Bool?
    /// Enable users who join a meeting from their mobile device to share content from their Box account.
    public var isBox: Bool?
    /// Enable users who join a meeting from their mobile device to share content from their Microsoft OneDrive account.
    public var isMicrosoftOneDrive: Bool?
    /// Enable users to control a connected Kubi device from within a Zoom meeting.
    public var isKubi: Bool?

    public init(isGoogleCalendar: Bool? = nil, isGoogleDrive: Bool? = nil, isDropbox: Bool? = nil, isBox: Bool? = nil, isMicrosoftOneDrive: Bool? = nil, isKubi: Bool? = nil) {
        self.isGoogleCalendar = isGoogleCalendar
        self.isGoogleDrive = isGoogleDrive
        self.isDropbox = isDropbox
        self.isBox = isBox
        self.isMicrosoftOneDrive = isMicrosoftOneDrive
        self.isKubi = isKubi
    }

    private enum CodingKeys: String, CodingKey {
        case isGoogleCalendar = "google_calendar"
        case isGoogleDrive = "google_drive"
        case isDropbox = "dropbox"
        case isBox = "box"
        case isMicrosoftOneDrive = "microsoft_one_drive"
        case isKubi = "kubi"
    }
}

/// The account's audio conference settings.
public struct AccountSettingsAudioConference: Codable {
    /// The account's [**Toll-free and Fee-based Toll Call**](https://support.zoom.us/hc/en-us/articles/360060950711-Enabling-Toll-free-and-Fee-based-Toll-Call#h_01F51680NJ7YHZDXGJNSKDGM2P) settings.
    public var tollFreeAndFeeBasedTollCall: TollFreeAndFeeBasedTollCall?

    /// The account's [**Toll-free and Fee-based Toll Call**](https://support.zoom.us/hc/en-us/articles/360060950711-Enabling-Toll-free-and-Fee-based-Toll-Call#h_01F51680NJ7YHZDXGJNSKDGM2P) settings.
    public struct TollFreeAndFeeBasedTollCall: Codable {
        /// Whether the account has the [**Toll-free and Fee-based Toll Call**](https://support.zoom.us/hc/en-us/articles/360060950711-Enabling-Toll-free-and-Fee-based-Toll-Call#h_01F51680NJ7YHZDXGJNSKDGM2P) setting enabled.
        public var enable: Bool?
        /// The account's **Toll-free and Fee-based Toll Call** phone number information.
        public var numbers: [Number]?
        /// Whether webinar attendees can dial in through the account's **Toll-free and Fee-based Toll Call** phone numbers. This feature is only available in version 5.2.2 and higher.
        public var allowWebinarAttendeesDial: Bool?

        public struct Number: Codable {
            /// The phone number's [E.164 country calling code](https://en.wikipedia.org/wiki/List_of_country_calling_codes).
            public var code: String?
            /// The phone number's [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
            public var countryCode: String?
            /// The country name.
            public var countryName: String?
            /// The phone number.
            public var number: String?
            /// The phone number's display number.
            public var displayNumber: String?

            public init(code: String? = nil, countryCode: String? = nil, countryName: String? = nil, number: String? = nil, displayNumber: String? = nil) {
                self.code = code
                self.countryCode = countryCode
                self.countryName = countryName
                self.number = number
                self.displayNumber = displayNumber
            }

            private enum CodingKeys: String, CodingKey {
                case code
                case countryCode = "country_code"
                case countryName = "country_name"
                case number
                case displayNumber = "display_number"
            }
        }

        public init(enable: Bool? = nil, numbers: [Number]? = nil, allowWebinarAttendeesDial: Bool? = nil) {
            self.enable = enable
            self.numbers = numbers
            self.allowWebinarAttendeesDial = allowWebinarAttendeesDial
        }

        private enum CodingKeys: String, CodingKey {
            case enable
            case numbers
            case allowWebinarAttendeesDial = "allow_webinar_attendees_dial"
        }
    }

    public init(tollFreeAndFeeBasedTollCall: TollFreeAndFeeBasedTollCall? = nil) {
        self.tollFreeAndFeeBasedTollCall = tollFreeAndFeeBasedTollCall
    }

    private enum CodingKeys: String, CodingKey {
        case tollFreeAndFeeBasedTollCall = "toll_free_and_fee_based_toll_call"
    }
}

/// List of managed domains.
public struct DomainsList: Codable {
    /// Total records.
    public var totalRecords: Int?
    /// List of managed domain objects.
    public var domains: [Domain]?

    public struct Domain: Codable {
        /// Domain name.
        public var domain: String?
        /// Domain status.
        public var status: String?

        public init(domain: String? = nil, status: String? = nil) {
            self.domain = domain
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.domain = try values.decodeIfPresent(String.self, forKey: "domain")
            self.status = try values.decodeIfPresent(String.self, forKey: "status")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(domain, forKey: "domain")
            try values.encodeIfPresent(status, forKey: "status")
        }
    }

    public init(totalRecords: Int? = nil, domains: [Domain]? = nil) {
        self.totalRecords = totalRecords
        self.domains = domains
    }

    private enum CodingKeys: String, CodingKey {
        case totalRecords = "total_records"
        case domains
    }
}

/// Account options object.
public struct AccountOptions: Codable {
    /// Enable/disable the option for a sub account to use shared [Virtual Room Connector(s)](https://support.zoom.us/hc/en-us/articles/202134758-Getting-Started-With-Virtual-Room-Connector) that are set up by the master account. Virtual Room Connectors can only be used by On-prem users.
    public var isShareRc: Bool
    /// Specify the IP addresses of the Room Connectors that you would like to share with the sub account. Multiple values can be separated by comma. If no value is provided in this field, all the Room Connectors of a master account will be shared with the sub account.
    /// 
    /// 
    /// **Note:** This option can only be used if the value of `share_rc` is set to `true`.
    public var roomConnectorList: [String]?
    /// Enable/disable the option for a sub account to use shared [Meeting Connector(s)](https://support.zoom.us/hc/en-us/articles/201363093-Getting-Started-with-the-Meeting-Connector) that are set up by the master account. Meeting Connectors can only be used by On-prem users.
    public var isShareMc: Bool
    /// Specify the IP addresses of the Meeting Connectors that you would like to share with the sub account. Multiple values can be separated by comma. If no value is provided in this field, all the Meeting Connectors of a master account will be shared with the sub account.
    /// 
    /// 
    /// **Note:** This option can only be used if the value of `share_mc` is set to `true`.
    public var meetingConnectorList: [String]?
    /// Payee:<br>`master` - master account holder pays.<br>`sub` - Sub account holder pays.
    public var payMode: PayMode?
    /// Toggle whether automatic billing renewal is on or off.
    public var isBillingAutoRenew: Bool?

    /// Payee:<br>`master` - master account holder pays.<br>`sub` - Sub account holder pays.
    public enum PayMode: String, Codable, CaseIterable {
        case master
        case sub
    }

    public init(isShareRc: Bool? = nil, roomConnectorList: [String]? = nil, isShareMc: Bool? = nil, meetingConnectorList: [String]? = nil, payMode: PayMode? = nil, isBillingAutoRenew: Bool? = nil) {
        self.isShareRc = isShareRc ?? false
        self.roomConnectorList = roomConnectorList
        self.isShareMc = isShareMc ?? false
        self.meetingConnectorList = meetingConnectorList
        self.payMode = payMode
        self.isBillingAutoRenew = isBillingAutoRenew
    }

    private enum CodingKeys: String, CodingKey {
        case isShareRc = "share_rc"
        case roomConnectorList = "room_connector_list"
        case isShareMc = "share_mc"
        case meetingConnectorList = "meeting_connector_list"
        case payMode = "pay_mode"
        case isBillingAutoRenew = "billing_auto_renew"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isShareRc = try values.decodeIfPresent(Bool.self, forKey: .isShareRc) ?? false
        self.roomConnectorList = try values.decodeIfPresent([String].self, forKey: .roomConnectorList)
        self.isShareMc = try values.decodeIfPresent(Bool.self, forKey: .isShareMc) ?? false
        self.meetingConnectorList = try values.decodeIfPresent([String].self, forKey: .meetingConnectorList)
        self.payMode = try values.decodeIfPresent(PayMode.self, forKey: .payMode)
        self.isBillingAutoRenew = try values.decodeIfPresent(Bool.self, forKey: .isBillingAutoRenew)
    }
}

/// [Security settings](https://support.zoom.us/hc/en-us/articles/360034675592-Advanced-security-settings#h_bf8a25f6-9a66-447a-befd-f02ed3404f89) of an Account.
public struct AccountSettingsSecurity: Codable {
    /// Only account administrators can change a user's username and picture.
    public var isAdminChangeNamePic: Bool?
    /// Allow users to import photos from a photo library on a  device.
    public var isImportPhotosFromDevices: Bool?
    /// Hide billing information.
    public var isHideBillingInfo: Bool?
    /// This object refers to the [enhanced password rules](https://support.zoom.us/hc/en-us/articles/360034675592-Advanced-security-settings#h_bf8a25f6-9a66-447a-befd-f02ed3404f89) that allows Zoom account admins and owners to apply extra requiremets to the users' Zoom login password.
    public var passwordRequirement: PasswordRequirement?
    /// Settings for 2FA( [two factor authentication](https://support.zoom.us/hc/en-us/articles/360038247071) ). The value can be one of the following:
    /// `all`: Two factor authentication will be enabled for all users in the account.<br>
    /// `none`: Two factor authentication is disabled.<br>
    /// `group`: Two factor authentication will be enabled for users belonging to specific groups. If 2FA is enabled for certain groups, the group IDs of the group(s) will be provided in the `sign_in_with_two_factor_auth_groups` field.<br>
    /// `role`: Two factor authentication will be enabled only for users assigned with specific roles in the account. If 2FA is enabled for specific roles, the role IDs will be provided in the
    /// `sign_in_with_two_factor_auth_roles` field.
    public var signInWithTwoFactorAuth: SignInWithTwoFactorAuth?
    /// Settings for User Sign In interval requirements after a period of inactivity. If enabled, this setting forces automatic logout of users in Zoom Client app after a set amount of time. <br>
    /// 
    /// If this setting is disabled, the value of this field will be `0`. If the setting is enabled, the value of this field will indicate the **period of inactivity** in minutes after which, an inactive user will be automatically logged out of the Zoom Client. The value for the period of inactivity can be one of the following:<br>
    /// 
    /// `5`: 5 minutes<br>
    /// `10`: 10 minutes<br>
    /// `15`: 15 minutes<br>
    /// `30`: 30 minutes<br>
    /// `45`: 45 minutes<br>
    /// `60`: 60 minutes<br>
    /// `90`: 90 minutes<br>
    /// `120`: 120 minutes
    public var signAgainPeriodForInactivityOnClient: Int?
    /// Settings for User Sign In interval requirements after a period of inactivity. If enabled, this setting forces automatic logout of users in Zoom Web Portal after a set amount of time. <br>
    /// 
    /// If this setting is disabled, the value of this field will be `0`. If the setting is enabled, the value of this field will indicate the **period of inactivity** in minutes after which, an inactive user will be automatically logged out of the Zoom Web Portal. The value for the period of inactivity can be one of the following:<br>
    /// 
    /// `5`: 5 minutes<br>
    /// `10`: 10 minutes<br>
    /// `15`: 15 minutes<br>
    /// `30`: 30 minutes<br>
    /// `60`: 60 minutes<br>
    /// `120`: 120 minutes
    public var signAgainPeriodForInactivityOnWeb: Int?
    /// This field contains group IDs of groups that have 2FA enabled. This field is only returned if the value of `sign_in_with_two_factor_auth` is `group`
    public var signInWithTwoFactorAuthGroups: [String]?
    /// This field contains role IDs of roles that have 2FA enabled. This field is only returned if the value of `sign_in_with_two_factor_auth` is `role`.
    public var signInWithTwoFactorAuthRoles: [String]?

    /// This object refers to the [enhanced password rules](https://support.zoom.us/hc/en-us/articles/360034675592-Advanced-security-settings#h_bf8a25f6-9a66-447a-befd-f02ed3404f89) that allows Zoom account admins and owners to apply extra requiremets to the users' Zoom login password.
    public struct PasswordRequirement: Codable {
        /// Specify a minimum length for the password. The password length can be from a minimum of 9 characters, up to 14 characters. If you provide `0` as the value of this field, this field will be disabled and not be used and the basic password length requirement (minimum of 8 characters) will be applied for the requirement.
        public var minimumPasswordLength: Int?
        /// If the value of this field is set to `true`, the password must have at least one special character(!, @, #...).
        public var haveSpecialCharacter: Bool?
        /// Specify the max length of consecutive characters(abcde...) that can be used in a password.
        /// If you set the value of this field to `0`, no restriction will be applied on consecutive characters. 
        /// 
        /// If you would like to set this restriction, you can specify a number between 4 and 8 that define the maximum allowed length for consecutive characters in a password.
        /// 
        /// The max allowed length will be `n-1` where `n` refers to the value you provide for this field.  For instance, if you provide `4` as the value, there can only be a maximum of `3` consecutive characters in a password(example: abc1x@8fdh).
        public var consecutiveCharactersLength: Int?
        /// If the value of this field is set to `true`, user passwords will have to pass detection through a weak password dictionary in case hackers use simple passwords to sign in to your users’ accounts.
        public var isWeakEnhanceDetection: Bool?

        public init(minimumPasswordLength: Int? = nil, haveSpecialCharacter: Bool? = nil, consecutiveCharactersLength: Int? = nil, isWeakEnhanceDetection: Bool? = nil) {
            self.minimumPasswordLength = minimumPasswordLength
            self.haveSpecialCharacter = haveSpecialCharacter
            self.consecutiveCharactersLength = consecutiveCharactersLength
            self.isWeakEnhanceDetection = isWeakEnhanceDetection
        }

        private enum CodingKeys: String, CodingKey {
            case minimumPasswordLength = "minimum_password_length"
            case haveSpecialCharacter = "have_special_character"
            case consecutiveCharactersLength = "consecutive_characters_length"
            case isWeakEnhanceDetection = "weak_enhance_detection"
        }
    }

    /// Settings for 2FA( [two factor authentication](https://support.zoom.us/hc/en-us/articles/360038247071) ). The value can be one of the following:
    /// `all`: Two factor authentication will be enabled for all users in the account.<br>
    /// `none`: Two factor authentication is disabled.<br>
    /// `group`: Two factor authentication will be enabled for users belonging to specific groups. If 2FA is enabled for certain groups, the group IDs of the group(s) will be provided in the `sign_in_with_two_factor_auth_groups` field.<br>
    /// `role`: Two factor authentication will be enabled only for users assigned with specific roles in the account. If 2FA is enabled for specific roles, the role IDs will be provided in the
    /// `sign_in_with_two_factor_auth_roles` field.
    public enum SignInWithTwoFactorAuth: String, Codable, CaseIterable {
        case all
        case group
        case role
        case `none`
    }

    public init(isAdminChangeNamePic: Bool? = nil, isImportPhotosFromDevices: Bool? = nil, isHideBillingInfo: Bool? = nil, passwordRequirement: PasswordRequirement? = nil, signInWithTwoFactorAuth: SignInWithTwoFactorAuth? = nil, signAgainPeriodForInactivityOnClient: Int? = nil, signAgainPeriodForInactivityOnWeb: Int? = nil, signInWithTwoFactorAuthGroups: [String]? = nil, signInWithTwoFactorAuthRoles: [String]? = nil) {
        self.isAdminChangeNamePic = isAdminChangeNamePic
        self.isImportPhotosFromDevices = isImportPhotosFromDevices
        self.isHideBillingInfo = isHideBillingInfo
        self.passwordRequirement = passwordRequirement
        self.signInWithTwoFactorAuth = signInWithTwoFactorAuth
        self.signAgainPeriodForInactivityOnClient = signAgainPeriodForInactivityOnClient
        self.signAgainPeriodForInactivityOnWeb = signAgainPeriodForInactivityOnWeb
        self.signInWithTwoFactorAuthGroups = signInWithTwoFactorAuthGroups
        self.signInWithTwoFactorAuthRoles = signInWithTwoFactorAuthRoles
    }

    private enum CodingKeys: String, CodingKey {
        case isAdminChangeNamePic = "admin_change_name_pic"
        case isImportPhotosFromDevices = "import_photos_from_devices"
        case isHideBillingInfo = "hide_billing_info"
        case passwordRequirement = "password_requirement"
        case signInWithTwoFactorAuth = "sign_in_with_two_factor_auth"
        case signAgainPeriodForInactivityOnClient = "sign_again_period_for_inactivity_on_client"
        case signAgainPeriodForInactivityOnWeb = "sign_again_period_for_inactivity_on_web"
        case signInWithTwoFactorAuthGroups = "sign_in_with_two_factor_auth_groups"
        case signInWithTwoFactorAuthRoles = "sign_in_with_two_factor_auth_roles"
    }
}

/// Account Settings: Telephony.
public struct AccountSettingsTelephony: Codable {
    /// Users can join the meeting using the existing third party audio configuration.
    public var isThirdPartyAudio: Bool?
    /// Third party audio conference info.
    public var audioConferenceInfo: String?
    /// Indicates where most of the participants call into or call from duriing a meeting.
    public var telephonyRegions: TelephonyRegions?

    /// Indicates where most of the participants call into or call from duriing a meeting.
    public struct TelephonyRegions: Codable {
        /// Telephony region options provided by Zoom to select from.
        public var allowedValues: [String]?
        /// The account's selected telephony regions that indicate where most participants call in to or call from during a meeting.
        public var selectionValues: String?

        public init(allowedValues: [String]? = nil, selectionValues: String? = nil) {
            self.allowedValues = allowedValues
            self.selectionValues = selectionValues
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "allowed_values"
            case selectionValues = "selection_values"
        }
    }

    public init(isThirdPartyAudio: Bool? = nil, audioConferenceInfo: String? = nil, telephonyRegions: TelephonyRegions? = nil) {
        self.isThirdPartyAudio = isThirdPartyAudio
        self.audioConferenceInfo = audioConferenceInfo
        self.telephonyRegions = telephonyRegions
    }

    private enum CodingKeys: String, CodingKey {
        case isThirdPartyAudio = "third_party_audio"
        case audioConferenceInfo = "audio_conference_info"
        case telephonyRegions = "telephony_regions"
    }
}

/// List of Accounts.
public struct AccountList: Codable {
    /// The number of pages returned for the request made.
    public var pageCount: Int?
    /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
    public var pageNumber: Int?
    /// The number of records returned with a single API call.
    public var pageSize: Int?
    /// The total number of all the records available across pages.
    public var totalRecords: Int?
    /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
    public var nextPageToken: String?
    /// List of Account objects.
    public var accounts: [Account]?

    public struct Account: Codable {
        /// Account ID.
        public var id: String?
        /// Account name.
        public var accountName: String?
        /// Account owner email.
        ///
        /// Example: "john.doe@zoom.us"
        public var ownerEmail: String?
        /// Account type.
        public var accountType: String?
        /// Account seats.
        public var seats: Int?
        /// Account subscription start date and time.
        public var subscriptionStartTime: Date?
        /// Account subscription end date and time.
        public var subscriptionEndTime: Date?
        /// Account creation date and time.
        public var createdAt: Date?
        /// Account Number of the account.
        public var accountNumber: String?

        public init(id: String? = nil, accountName: String? = nil, ownerEmail: String? = nil, accountType: String? = nil, seats: Int? = nil, subscriptionStartTime: Date? = nil, subscriptionEndTime: Date? = nil, createdAt: Date? = nil, accountNumber: String? = nil) {
            self.id = id
            self.accountName = accountName
            self.ownerEmail = ownerEmail
            self.accountType = accountType
            self.seats = seats
            self.subscriptionStartTime = subscriptionStartTime
            self.subscriptionEndTime = subscriptionEndTime
            self.createdAt = createdAt
            self.accountNumber = accountNumber
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case accountName = "account_name"
            case ownerEmail = "owner_email"
            case accountType = "account_type"
            case seats
            case subscriptionStartTime = "subscription_start_time"
            case subscriptionEndTime = "subscription_end_time"
            case createdAt = "created_at"
            case accountNumber = "account_number"
        }
    }

    public init(pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil, accounts: [Account]? = nil) {
        self.pageCount = pageCount
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.totalRecords = totalRecords
        self.nextPageToken = nextPageToken
        self.accounts = accounts
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.pageCount = try values.decodeIfPresent(Int.self, forKey: "page_count")
        self.pageNumber = try values.decodeIfPresent(Int.self, forKey: "page_number")
        self.pageSize = try values.decodeIfPresent(Int.self, forKey: "page_size")
        self.totalRecords = try values.decodeIfPresent(Int.self, forKey: "total_records")
        self.nextPageToken = try values.decodeIfPresent(String.self, forKey: "next_page_token")
        self.accounts = try values.decodeIfPresent([Account].self, forKey: "accounts")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(pageCount, forKey: "page_count")
        try values.encodeIfPresent(pageNumber, forKey: "page_number")
        try values.encodeIfPresent(pageSize, forKey: "page_size")
        try values.encodeIfPresent(totalRecords, forKey: "total_records")
        try values.encodeIfPresent(nextPageToken, forKey: "next_page_token")
        try values.encodeIfPresent(accounts, forKey: "accounts")
    }
}

/// Update account settings
public struct AccountUpdateSettings: Codable {
    /// Account Settings: Schedule Meeting.
    public var scheduleMeeting: ScheduleMeeting?
    /// Account Settings: In Meeting.
    public var inMeeting: InMeeting?
    /// Account Settings: Notification.
    public var emailNotification: EmailNotification?
    /// Account Settings: Zoom Rooms.
    public var zoomRooms: ZoomRooms?
    /// [Security settings](https://support.zoom.us/hc/en-us/articles/360034675592-Advanced-security-settings#h_bf8a25f6-9a66-447a-befd-f02ed3404f89) of an Account.
    public var security: Security?
    /// Account Settings: Recording.
    public var recording: Recording?
    /// Account Settings Update: Telephony.
    public var telephony: Telephony?
    /// Account Settings: Integration.
    public var integration: Integration?
    /// Account Settings: Feature.
    public var feature: Feature?
    /// Account Settings: TSP.
    public var tsp: Tsp?
    public var profile: Profile?
    public var otherOptions: OtherOptions?
    /// The account's audio conference settings.
    public var audioConferencing: AudioConferencing?

    /// Account Settings: Schedule Meeting.
    public struct ScheduleMeeting: Codable {
        /// Start meetings with the host video on.
        public var isHostVideo: Bool?
        /// Start meetings with the participant video on. Participants can change this setting during the meeting.
        public var isParticipantVideo: Bool?
        /// Determine how participants can join the audio portion of the meeting.<br>`both` - Telephony and VoIP.<br>`telephony` - Audio PSTN telephony only.<br>`voip` - VoIP only.<br>`thirdParty` - 3rd party audio conference.
        public var audioType: AudioType?
        /// Allow participants to join the meeting before the host arrives.
        public var isJoinBeforeHost: Bool?
        /// If the value of "join_before_host" field is set to true, this field can be used to indicate time limits within which a participant may join a meeting before a host. The value of this field can be one of the following:
        /// 
        /// *  `0`: Allow participant to join anytime.
        /// *  `5`: Allow participant to join 5 minutes before meeting start time.
        ///  * `10`: Allow participant to join 10 minutes before meeting start time.
        public var jbhTime: Int?
        /// Only Zoom users who are signed in can join meetings.
        public var enforceLogin: Bool?
        /// Only signed in users with a specific domain can join meetings.
        public var enforceLoginWithDomains: Bool?
        /// Only signed in users with a specified domain can join the meeting.
        public var enforceLoginDomains: String?
        /// Always display "Zoom Meeting" as the meeting topic.
        public var isNotStoreMeetingTopic: Bool?
        /// Require a password for Personal Meetings if attendees can join before host.
        public var isForcePmiJbhPassword: Bool?
        /// Use Personal Meeting ID (PMI) when scheduling a meeting
        public var usePmiForScheduledMeetings: Bool?
        /// Use Personal Meeting ID (PMI) when starting an instant meeting
        public var usePmiForInstantMeetings: Bool?
        /// Require a password when scheduling new meetings. This setting applies for regular meetings that do not use PMI. If enabled, a password will be generated while a host schedules a new meeting and participants will be required to enter the password before they can join the meeting. This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
        public var requirePasswordForSchedulingNewMeetings: Bool?
        /// Require a password for meetings which have already been scheduled
        public var requirePasswordForScheduledMeetings: Bool?
        /// Require a password for instant meetings. If you use PMI for your instant meetings, this option will be disabled. This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
        public var requirePasswordForInstantMeetings: Bool?
        /// Require a password for a meeting held using Personal Meeting ID (PMI) This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
        public var requirePasswordForPmiMeetings: RequirePasswordForPmiMeetings?
        /// Account wide meeting/webinar [password requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
        public var meetingPasswordRequirement: MeetingPasswordRequirement?
        /// Personal Meeting Setting.<br><br>
        /// `true`: Indicates that the **"Enable Personal Meeting ID"** setting is turned on. Users can choose to use personal meeting ID for their meetings. <br><br>
        /// `false`: Indicates that the **"Enable Personal Meeting ID"** setting is [turned off](https://support.zoom.us/hc/en-us/articles/201362843-Personal-meeting-ID-PMI-and-personal-link#h_aa0335c8-3b06-41bc-bc1f-a8b84ef17f2a). If this setting is disabled, meetings that were scheduled with PMI will be invalid. Scheduled meetings will need to be manually updated.
        /// For Zoom Phone only:If a user has been assigned a desk phone, **"Elevate to Zoom Meeting"** on desk phone will be disabled.
        public var isPersonalMeeting: Bool?

        /// Determine how participants can join the audio portion of the meeting.<br>`both` - Telephony and VoIP.<br>`telephony` - Audio PSTN telephony only.<br>`voip` - VoIP only.<br>`thirdParty` - 3rd party audio conference.
        public enum AudioType: String, Codable, CaseIterable {
            case both
            case telephony
            case voip
            case thirdParty
        }

        /// Require a password for a meeting held using Personal Meeting ID (PMI) This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
        public enum RequirePasswordForPmiMeetings: String, Codable, CaseIterable {
            case jbhOnly = "jbh_only"
            case all
            case `none`
        }

        /// Account wide meeting/webinar [password requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
        public struct MeetingPasswordRequirement: Codable {
            /// The minimum length that the meeting/webinar password needs to have.
            public var length: Int?
            /// If set to `true`, the password must contain at least 1 letter (such as a,b,c...).
            public var haveLetter: Bool?
            /// If set to `true`, the password must contain at least 1 number (such as 1,2,3...).
            public var haveNumber: Bool?
            /// If set to `true`, the password must have at least 1 special character (!,@,#...).
            public var haveSpecialCharacter: Bool?
            /// If set to `true`, the password must only contain numbers and no other characters.
            public var onlyAllowNumeric: Bool?
            /// If set to `true`, the password must include both uppercase and lowercase characters.
            public var haveUpperAndLowerCharacters: Bool?
            public var consecutiveCharactersLength: Int?
            /// If set to `true`, users will be informed if the provided password is weak.
            public var isWeakEnhanceDetection: Bool?

            public init(length: Int? = nil, haveLetter: Bool? = nil, haveNumber: Bool? = nil, haveSpecialCharacter: Bool? = nil, onlyAllowNumeric: Bool? = nil, haveUpperAndLowerCharacters: Bool? = nil, consecutiveCharactersLength: Int? = nil, isWeakEnhanceDetection: Bool? = nil) {
                self.length = length
                self.haveLetter = haveLetter
                self.haveNumber = haveNumber
                self.haveSpecialCharacter = haveSpecialCharacter
                self.onlyAllowNumeric = onlyAllowNumeric
                self.haveUpperAndLowerCharacters = haveUpperAndLowerCharacters
                self.consecutiveCharactersLength = consecutiveCharactersLength
                self.isWeakEnhanceDetection = isWeakEnhanceDetection
            }

            private enum CodingKeys: String, CodingKey {
                case length
                case haveLetter = "have_letter"
                case haveNumber = "have_number"
                case haveSpecialCharacter = "have_special_character"
                case onlyAllowNumeric = "only_allow_numeric"
                case haveUpperAndLowerCharacters = "have_upper_and_lower_characters"
                case consecutiveCharactersLength = "consecutive_characters_length"
                case isWeakEnhanceDetection = "weak_enhance_detection"
            }
        }

        public init(isHostVideo: Bool? = nil, isParticipantVideo: Bool? = nil, audioType: AudioType? = nil, isJoinBeforeHost: Bool? = nil, jbhTime: Int? = nil, enforceLogin: Bool? = nil, enforceLoginWithDomains: Bool? = nil, enforceLoginDomains: String? = nil, isNotStoreMeetingTopic: Bool? = nil, isForcePmiJbhPassword: Bool? = nil, usePmiForScheduledMeetings: Bool? = nil, usePmiForInstantMeetings: Bool? = nil, requirePasswordForSchedulingNewMeetings: Bool? = nil, requirePasswordForScheduledMeetings: Bool? = nil, requirePasswordForInstantMeetings: Bool? = nil, requirePasswordForPmiMeetings: RequirePasswordForPmiMeetings? = nil, meetingPasswordRequirement: MeetingPasswordRequirement? = nil, isPersonalMeeting: Bool? = nil) {
            self.isHostVideo = isHostVideo
            self.isParticipantVideo = isParticipantVideo
            self.audioType = audioType
            self.isJoinBeforeHost = isJoinBeforeHost
            self.jbhTime = jbhTime
            self.enforceLogin = enforceLogin
            self.enforceLoginWithDomains = enforceLoginWithDomains
            self.enforceLoginDomains = enforceLoginDomains
            self.isNotStoreMeetingTopic = isNotStoreMeetingTopic
            self.isForcePmiJbhPassword = isForcePmiJbhPassword
            self.usePmiForScheduledMeetings = usePmiForScheduledMeetings
            self.usePmiForInstantMeetings = usePmiForInstantMeetings
            self.requirePasswordForSchedulingNewMeetings = requirePasswordForSchedulingNewMeetings
            self.requirePasswordForScheduledMeetings = requirePasswordForScheduledMeetings
            self.requirePasswordForInstantMeetings = requirePasswordForInstantMeetings
            self.requirePasswordForPmiMeetings = requirePasswordForPmiMeetings
            self.meetingPasswordRequirement = meetingPasswordRequirement
            self.isPersonalMeeting = isPersonalMeeting
        }

        private enum CodingKeys: String, CodingKey {
            case isHostVideo = "host_video"
            case isParticipantVideo = "participant_video"
            case audioType = "audio_type"
            case isJoinBeforeHost = "join_before_host"
            case jbhTime = "jbh_time"
            case enforceLogin = "enforce_login"
            case enforceLoginWithDomains = "enforce_login_with_domains"
            case enforceLoginDomains = "enforce_login_domains"
            case isNotStoreMeetingTopic = "not_store_meeting_topic"
            case isForcePmiJbhPassword = "force_pmi_jbh_password"
            case usePmiForScheduledMeetings = "use_pmi_for_scheduled_meetings"
            case usePmiForInstantMeetings = "use_pmi_for_instant_meetings"
            case requirePasswordForSchedulingNewMeetings = "require_password_for_scheduling_new_meetings"
            case requirePasswordForScheduledMeetings = "require_password_for_scheduled_meetings"
            case requirePasswordForInstantMeetings = "require_password_for_instant_meetings"
            case requirePasswordForPmiMeetings = "require_password_for_pmi_meetings"
            case meetingPasswordRequirement = "meeting_password_requirement"
            case isPersonalMeeting = "personal_meeting"
        }
    }

    /// Account Settings: In Meeting.
    public struct InMeeting: Codable {
        /// Zoom requires encryption for all data between the Zoom cloud, Zoom client, and Zoom Room. Require encryption for 3rd party endpoints (H323/SIP).
        public var isE2eEncryption: Bool?
        /// Allow meeting participants to send a message that is visible to all participants.
        public var isChat: Bool?
        /// Whether to allow participants to only chat with certain groups:
        /// * `1` — The participant cannot use chat.
        /// * `2` — Host and co-hosts only.
        ///  * `3` — The participant can chat with other participants publicly.
        /// * `4` - The participant can chat with other participants publicly and privately.
        /// 
        /// **Note:** This setting is only available with client versions 5.7.3 and above.
        public var allowParticipantsChatWith: Int?
        /// Whether to allow participants to save meeting chats:
        /// * `1` — Participants cannot save meeting chats.
        /// * `2` — Participants can only save host and co-host meeting chats.
        /// * `3` — Participants can save all meeting chats.
        public var allowUsersSaveChats: Int?
        /// Allow a meeting participant to send a private message to another participant.
        public var isPrivateChat: Bool?
        /// Automatically save all in-meeting chats so that the host does not need to manually save the chat transcript after the meeting starts.
        public var isAutoSavingChat: Bool?
        /// Play sound when participants join or leave.<br>`host` - Heard by host only.<br>`all` - Heard by host and all attendees.<br>`none` - Disable.
        public var entryExitChime: EntryExitChime?
        /// Record and play their own voice.
        public var isRecordPlayOwnVoice: Bool?
        /// Add a "Feedback" tab to the Windows Settings or Mac Preferences dialog. Enable users to provide feedback to Zoom at the end of the meeting.
        public var isFeedback: Bool?
        /// Display a thumbs up or down survey at the end of each meeting.
        public var isPostMeetingFeedback: Bool?
        /// Allow the host to add co-hosts.
        public var isCoHost: Bool?
        /// Add "Polls" to the meeting controls.
        public var isPolling: Bool?
        /// Allow host to put attendee on hold.
        /// 
        /// **This field has been deprecated and is no longer supported.**
        public var isAttendeeOnHold: Bool
        /// Always show the meeting control toolbar.
        public var isShowMeetingControlToolbar: Bool?
        /// Show the Zoom desktop application when sharing screens.
        public var allowShowZoomWindows: Bool?
        /// Allow participants to use annotation tools to add information to shared screens.
        public var isAnnotation: Bool?
        /// Allow participants to share a whiteboard that includes annotation tools.
        public var isWhiteboard: Bool?
        /// Whether attendees can ask the host and panelists questions in the webinar.
        public var isWebinarQuestionAnswer: Bool?
        /// Allow an anonymous Q&A in a webinar.
        public var isAnonymousQuestionAnswer: Bool?
        /// Allow host to split meeting participants into separate, smaller rooms.
        public var isBreakoutRoom: Bool?
        /// Whether the host can assign participants to breakout rooms when scheduling. This feature is only available in version 4.5.0 or higher.
        public var isBreakoutRoomSchedule: Bool?
        /// Allow a host to type closed captions. Enable a host to assign a participant or third party device to add closed captions.
        public var isClosedCaption: Bool?
        /// Allow another user to take control of your camera during a meeting.
        public var isFarEndCameraControl: Bool?
        /// Activate higher quality video for host and participants.
        /// Please note: This will use more bandwidth.
        public var isGroupHd: Bool?
        /// Allow users to replace their background with any selected image. Choose or upload an image in the Zoom desktop application settings.
        public var isVirtualBackground: Bool?
        /// Settings to manage virtual background.
        public var virtualBackgroundSettings: VirtualBackgroundSettings?
        /// Add a watermark when viewing a shared screen.
        public var isWatermark: Bool?
        /// Identify guest participants in a meeting or webinar.
        public var isAlertGuestJoin: Bool?
        /// Enable users to see and add contacts to the "auto-answer group" in the chat contact list. Any call from members of this group will automatically be answered.
        public var isAutoAnswer: Bool?
        /// Peer to peer connection while only two people are in a meeting.
        public var isP2pConnetion: Bool?
        /// Peer to peer listening ports range.
        public var isP2pPorts: Bool?
        /// The listening ports range, separated by a comma (ex 55,56). The ports range must be between 1 to 65535.
        public var portsRange: String?
        /// Only show the default email when sending email invites.
        public var isSendingDefaultEmailInvites: Bool?
        /// Use HTML formatted email for the Outlook plugin.
        public var useHTMLFormatEmail: Bool?
        /// DSCP marking.
        public var isDscpMarking: Bool?
        /// DSCP audio.
        public var dscpAudio: Int?
        /// DSCP video.
        public var dscpVideo: Int?
        /// Allow users to select stereo audio in their client settings.
        public var isStereoAudio: Bool?
        /// Allow users to select original sound in their client settings.
        public var isOriginalAudio: Bool?
        /// Allow screen sharing.
        public var isScreenSharing: Bool?
        /// Allow users to request remote control.
        public var isRemoteControl: Bool?
        /// Whether to allow livestreaming.
        public var allowLiveStreaming: Bool?
        /// Whether to allow Facebook livestreaming.
        public var isLiveStreamingFacebook: Bool?
        /// Whether to allow Workplace by Facebook livestreaming.
        public var isWorkplaceByFacebook: Bool?
        /// Whether to allow YouTube livestreaming.
        public var isLiveStreamingYoutube: Bool?
        /// Whether to allow custom livestreaming.
        public var isCustomLiveStreamingService: Bool?
        /// The specific instructions to configure a custom livestream.
        public var customServiceInstructions: String?
        /// If set to `true`, account owners and admins on paid accounts can [select data center regions](https://support.zoom.us/hc/en-us/articles/360042411451-Selecting-data-center-regions-for-hosted-meetings-and-webinars) to use for hosting their real-time meeting and webinar traffic. These regions can be provided in the `data_center_regions` field. If set to `false`, the regions cannot be customized and the default regions will be used.
        public var isCustomDataCenterRegions: Bool?
        /// If you have set the value of `custom_data_center_regions` to `true`, specify the data center regions that you would like to opt in to (country codes from among: ["EU", "HK", "AU", "IN", "LA", "TY", "CN", "US", "CA"]).
        public var dataCenterRegions: [String]?
        /// Whether meeting participants can [communicate using the emoji reactions](https://support.zoom.us/hc/en-us/articles/115001286183-Nonverbal-feedback-and-meeting-reactions) located in the **Reactions** menu in the meeting toolbar.
        public var isMeetingReactions: Bool?
        /// Whether to allow participants to join a meeting directly from their browser and bypass the Zoom application download process. This is useful for participants who cannot download, install, or run applications. Note that the meeting experience from the browser is limited.
        public var isShowAJoinFromYourBrowserLink: Bool?
        /// Whether to allow participants to join a meeting directly from their mobile browser. Note that the meeting experience from the mobile browser is limited.
        public var isJoinFromMobile: Bool?
        /// Whether to allow participants to join a meeting directly from their desktop browser. Note that the meeting experience from the desktop browser is limited.
        public var isJoinFromDesktop: Bool?
        /// If the value of this field is set to `true`, meeting participants and webinar panelists can be allowed to rename themselves during a meeting or a webinar.
        public var allowParticipantsToRename: Bool?
        /// Indicates who can share their screen or content during meetings. The value can be one of the following: <br>
        /// `host`: Only host can share the screen.<br>
        /// `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
        public var whoCanShareScreen: WhoCanShareScreen?
        /// Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:<br>
        /// `host`: Only a host can share the screen when someone else is sharing.<br>
        /// `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
        public var whoCanShareScreenWhenSomeoneIsSharing: WhoCanShareScreenWhenSomeoneIsSharing?
        /// Indicates whether [in-meeting file transfer](https://support.zoom.us/hc/en-us/articles/209605493-In-meeting-file-transfer) setting has been enabled on the account or not.
        public var isFileTransfer: Bool?
        /// Indicates whether the [**Request permission to unmute participants**](https://support.zoom.us/hc/en-us/articles/203435537-Muting-and-unmuting-participants-in-a-meeting#h_01EGK4XFWS1SJGZ71MYGKF7260) option has been enabled for the account or not.
        public var isRequestPermissionToUnmute: Bool?
        public var webinarLiveStreaming: WebinarLiveStreaming?
        public var webinarChat: WebinarChat?
        /// Information about the account's closed captioning settings.
        public var closedCaptioning: ClosedCaptioning?
        /// Whether the person sharing during a presentation can allow others to control the slide presentation. This feature is only available in version 5.8.3 or higher.
        public var isSlideControl: Bool?
        /// Whether to allow the host to present a survey to participants once a meeting has ended. This feature is only available in version 5.7.3 or higher.
        public var isMeetingSurvey: Bool?
        /// Information about the account's webinar polling settings.
        public var webinarPolling: WebinarPolling?
        /// Whether to allow the host to present surveys to attendees once a webinar has ended.
        public var isWebinarSurvey: Bool?

        /// Play sound when participants join or leave.<br>`host` - Heard by host only.<br>`all` - Heard by host and all attendees.<br>`none` - Disable.
        public enum EntryExitChime: String, Codable, CaseIterable {
            case host
            case all
            case `none`
        }

        /// Settings to manage virtual background.
        public struct VirtualBackgroundSettings: Codable {
            /// Enable virtual background.
            public var enable: Bool?
            /// Allow use of videos for virtual backgrounds.
            public var allowVideos: Bool?
            /// Allow users to upload custom backgrounds.
            public var allowUploadCustom: Bool?
            public var files: [File]?

            public struct File: Codable {
                /// Unique identifier of the file.
                public var id: String?
                /// File name.
                public var name: String?
                /// File type.
                public var type: String?
                /// Indicates whether or not this file is the default virtual background file.
                public var isDefault: Bool?
                /// File size.
                public var size: String?

                public init(id: String? = nil, name: String? = nil, type: String? = nil, isDefault: Bool? = nil, size: String? = nil) {
                    self.id = id
                    self.name = name
                    self.type = type
                    self.isDefault = isDefault
                    self.size = size
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case name
                    case type
                    case isDefault = "is_default"
                    case size
                }
            }

            public init(enable: Bool? = nil, allowVideos: Bool? = nil, allowUploadCustom: Bool? = nil, files: [File]? = nil) {
                self.enable = enable
                self.allowVideos = allowVideos
                self.allowUploadCustom = allowUploadCustom
                self.files = files
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case allowVideos = "allow_videos"
                case allowUploadCustom = "allow_upload_custom"
                case files
            }
        }

        /// Indicates who can share their screen or content during meetings. The value can be one of the following: <br>
        /// `host`: Only host can share the screen.<br>
        /// `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
        public enum WhoCanShareScreen: String, Codable, CaseIterable {
            case host
            case all
        }

        /// Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:<br>
        /// `host`: Only a host can share the screen when someone else is sharing.<br>
        /// `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
        public enum WhoCanShareScreenWhenSomeoneIsSharing: String, Codable, CaseIterable {
            case host
            case all
        }

        public struct WebinarLiveStreaming: Codable {
            /// Whether webinar livestreaming is enabled.
            public var enable: Bool?
            /// The available livestreaming services:
            /// * `facebook`
            /// * `workplace_by_facebook`
            /// * `youtube`
            /// * `custom_live_streaming_service`
            public var liveStreamingService: [LiveStreamingServiceItem]?
            /// The specific instructions to allow your account's meeting hosts to configure a custom livestream.
            public var customServiceInstructions: String?
            /// Whether to notify users to watch the livestream. This does not apply to custom RTMP (real-time messaging protocol).
            public var isLiveStreamingReminder: Bool?

            public enum LiveStreamingServiceItem: String, Codable, CaseIterable {
                case facebook
                case workplaceByFacebook = "workplace_by_facebook"
                case youtube
                case customLiveStreamingService = "custom_live_streaming_service"
            }

            public init(enable: Bool? = nil, liveStreamingService: [LiveStreamingServiceItem]? = nil, customServiceInstructions: String? = nil, isLiveStreamingReminder: Bool? = nil) {
                self.enable = enable
                self.liveStreamingService = liveStreamingService
                self.customServiceInstructions = customServiceInstructions
                self.isLiveStreamingReminder = isLiveStreamingReminder
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case liveStreamingService = "live_streaming_service"
                case customServiceInstructions = "custom_service_instructions"
                case isLiveStreamingReminder = "live_streaming_reminder"
            }
        }

        public struct WebinarChat: Codable {
            /// Whether to allow webinar participants to send chat messages.
            public var enable: Bool?
            /// Allow webinar panelists to chat with:
            /// * `1` — Host and all panelists.
            /// * `2` — Everyone.
            public var allowPanelistsChatWith: Int?
            /// Allow webinar attendees to chat with:
            /// * `1` — No one.
            /// * `2` — Host and all panelists.
            /// * `3` — Everyone.
            public var allowAttendeesChatWith: Int?
            /// By default, allow webinar attendees to chat with:
            /// * `1` — Host and all panelists.
            /// * `2` — Everyone.
            public var defaultAttendeesChatWith: Int?
            /// Whether to allow webinar panelists to send direct messages to other panelists.
            public var allowPanelistsSendDirectMessage: Bool?
            /// Whether to allow webinar attendees to save chats:
            /// * `0` — Attendees cannot save chats.
            /// * `1` — Attendees can only save host and panelist chats.
            /// * `2` — Attendees can save all chats.
            public var allowUsersSaveChats: Int?
            /// Whether to automatically save chat messages to a local file on the host's computer when the webinar ends.
            public var allowAutoSaveLocalChatFile: Bool?

            public init(enable: Bool? = nil, allowPanelistsChatWith: Int? = nil, allowAttendeesChatWith: Int? = nil, defaultAttendeesChatWith: Int? = nil, allowPanelistsSendDirectMessage: Bool? = nil, allowUsersSaveChats: Int? = nil, allowAutoSaveLocalChatFile: Bool? = nil) {
                self.enable = enable
                self.allowPanelistsChatWith = allowPanelistsChatWith
                self.allowAttendeesChatWith = allowAttendeesChatWith
                self.defaultAttendeesChatWith = defaultAttendeesChatWith
                self.allowPanelistsSendDirectMessage = allowPanelistsSendDirectMessage
                self.allowUsersSaveChats = allowUsersSaveChats
                self.allowAutoSaveLocalChatFile = allowAutoSaveLocalChatFile
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case allowPanelistsChatWith = "allow_panelists_chat_with"
                case allowAttendeesChatWith = "allow_attendees_chat_with"
                case defaultAttendeesChatWith = "default_attendees_chat_with"
                case allowPanelistsSendDirectMessage = "allow_panelists_send_direct_message"
                case allowUsersSaveChats = "allow_users_save_chats"
                case allowAutoSaveLocalChatFile = "allow_auto_save_local_chat_file"
            }
        }

        /// Information about the account's closed captioning settings.
        public struct ClosedCaptioning: Codable {
            /// Whether to allow the host to type closed captions or assign a participant or 3rd-party service to provide closed captioning.
            public var enable: Bool?
            /// Whether to allow the use of an API token to integrate with 3rd-party closed captioning services.
            public var isThirdPartyCaptioningService: Bool?
            /// Whether to allow a live transcription service to transcribe meetings.
            public var isAutoTranscribing: Bool?
            /// Whether to allow the viewing of full transcripts in the in-meeting side panel.
            public var isViewFullTranscript: Bool?
            /// Whether to allow participants to save closed captions or transcripts.
            public var isSaveCaption: Bool?

            public init(enable: Bool? = nil, isThirdPartyCaptioningService: Bool? = nil, isAutoTranscribing: Bool? = nil, isViewFullTranscript: Bool? = nil, isSaveCaption: Bool? = nil) {
                self.enable = enable
                self.isThirdPartyCaptioningService = isThirdPartyCaptioningService
                self.isAutoTranscribing = isAutoTranscribing
                self.isViewFullTranscript = isViewFullTranscript
                self.isSaveCaption = isSaveCaption
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case isThirdPartyCaptioningService = "third_party_captioning_service"
                case isAutoTranscribing = "auto_transcribing"
                case isViewFullTranscript = "view_full_transcript"
                case isSaveCaption = "save_caption"
            }
        }

        /// Information about the account's webinar polling settings.
        public struct WebinarPolling: Codable {
            /// Whether to allow the host to add polls before or during a webinar.
            public var enable: Bool?
            /// Whether to allow host to create advanced polls and quizzes. Advanced polls and quizzes include single choice, multiple choice, drop down, matching, short answer, long answer, rank order, and fill-in-the-blank questions. Hosts can also set the correct answers for quizzes they create.
            public var isAdvancedPolls: Bool?

            public init(enable: Bool? = nil, isAdvancedPolls: Bool? = nil) {
                self.enable = enable
                self.isAdvancedPolls = isAdvancedPolls
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case isAdvancedPolls = "advanced_polls"
            }
        }

        public init(isE2eEncryption: Bool? = nil, isChat: Bool? = nil, allowParticipantsChatWith: Int? = nil, allowUsersSaveChats: Int? = nil, isPrivateChat: Bool? = nil, isAutoSavingChat: Bool? = nil, entryExitChime: EntryExitChime? = nil, isRecordPlayOwnVoice: Bool? = nil, isFeedback: Bool? = nil, isPostMeetingFeedback: Bool? = nil, isCoHost: Bool? = nil, isPolling: Bool? = nil, isAttendeeOnHold: Bool? = nil, isShowMeetingControlToolbar: Bool? = nil, allowShowZoomWindows: Bool? = nil, isAnnotation: Bool? = nil, isWhiteboard: Bool? = nil, isWebinarQuestionAnswer: Bool? = nil, isAnonymousQuestionAnswer: Bool? = nil, isBreakoutRoom: Bool? = nil, isBreakoutRoomSchedule: Bool? = nil, isClosedCaption: Bool? = nil, isFarEndCameraControl: Bool? = nil, isGroupHd: Bool? = nil, isVirtualBackground: Bool? = nil, virtualBackgroundSettings: VirtualBackgroundSettings? = nil, isWatermark: Bool? = nil, isAlertGuestJoin: Bool? = nil, isAutoAnswer: Bool? = nil, isP2pConnetion: Bool? = nil, isP2pPorts: Bool? = nil, portsRange: String? = nil, isSendingDefaultEmailInvites: Bool? = nil, useHTMLFormatEmail: Bool? = nil, isDscpMarking: Bool? = nil, dscpAudio: Int? = nil, dscpVideo: Int? = nil, isStereoAudio: Bool? = nil, isOriginalAudio: Bool? = nil, isScreenSharing: Bool? = nil, isRemoteControl: Bool? = nil, allowLiveStreaming: Bool? = nil, isLiveStreamingFacebook: Bool? = nil, isWorkplaceByFacebook: Bool? = nil, isLiveStreamingYoutube: Bool? = nil, isCustomLiveStreamingService: Bool? = nil, customServiceInstructions: String? = nil, isCustomDataCenterRegions: Bool? = nil, dataCenterRegions: [String]? = nil, isMeetingReactions: Bool? = nil, isShowAJoinFromYourBrowserLink: Bool? = nil, isJoinFromMobile: Bool? = nil, isJoinFromDesktop: Bool? = nil, allowParticipantsToRename: Bool? = nil, whoCanShareScreen: WhoCanShareScreen? = nil, whoCanShareScreenWhenSomeoneIsSharing: WhoCanShareScreenWhenSomeoneIsSharing? = nil, isFileTransfer: Bool? = nil, isRequestPermissionToUnmute: Bool? = nil, webinarLiveStreaming: WebinarLiveStreaming? = nil, webinarChat: WebinarChat? = nil, closedCaptioning: ClosedCaptioning? = nil, isSlideControl: Bool? = nil, isMeetingSurvey: Bool? = nil, webinarPolling: WebinarPolling? = nil, isWebinarSurvey: Bool? = nil) {
            self.isE2eEncryption = isE2eEncryption
            self.isChat = isChat
            self.allowParticipantsChatWith = allowParticipantsChatWith
            self.allowUsersSaveChats = allowUsersSaveChats
            self.isPrivateChat = isPrivateChat
            self.isAutoSavingChat = isAutoSavingChat
            self.entryExitChime = entryExitChime
            self.isRecordPlayOwnVoice = isRecordPlayOwnVoice
            self.isFeedback = isFeedback
            self.isPostMeetingFeedback = isPostMeetingFeedback
            self.isCoHost = isCoHost
            self.isPolling = isPolling
            self.isAttendeeOnHold = isAttendeeOnHold ?? false
            self.isShowMeetingControlToolbar = isShowMeetingControlToolbar
            self.allowShowZoomWindows = allowShowZoomWindows
            self.isAnnotation = isAnnotation
            self.isWhiteboard = isWhiteboard
            self.isWebinarQuestionAnswer = isWebinarQuestionAnswer
            self.isAnonymousQuestionAnswer = isAnonymousQuestionAnswer
            self.isBreakoutRoom = isBreakoutRoom
            self.isBreakoutRoomSchedule = isBreakoutRoomSchedule
            self.isClosedCaption = isClosedCaption
            self.isFarEndCameraControl = isFarEndCameraControl
            self.isGroupHd = isGroupHd
            self.isVirtualBackground = isVirtualBackground
            self.virtualBackgroundSettings = virtualBackgroundSettings
            self.isWatermark = isWatermark
            self.isAlertGuestJoin = isAlertGuestJoin
            self.isAutoAnswer = isAutoAnswer
            self.isP2pConnetion = isP2pConnetion
            self.isP2pPorts = isP2pPorts
            self.portsRange = portsRange
            self.isSendingDefaultEmailInvites = isSendingDefaultEmailInvites
            self.useHTMLFormatEmail = useHTMLFormatEmail
            self.isDscpMarking = isDscpMarking
            self.dscpAudio = dscpAudio
            self.dscpVideo = dscpVideo
            self.isStereoAudio = isStereoAudio
            self.isOriginalAudio = isOriginalAudio
            self.isScreenSharing = isScreenSharing
            self.isRemoteControl = isRemoteControl
            self.allowLiveStreaming = allowLiveStreaming
            self.isLiveStreamingFacebook = isLiveStreamingFacebook
            self.isWorkplaceByFacebook = isWorkplaceByFacebook
            self.isLiveStreamingYoutube = isLiveStreamingYoutube
            self.isCustomLiveStreamingService = isCustomLiveStreamingService
            self.customServiceInstructions = customServiceInstructions
            self.isCustomDataCenterRegions = isCustomDataCenterRegions
            self.dataCenterRegions = dataCenterRegions
            self.isMeetingReactions = isMeetingReactions
            self.isShowAJoinFromYourBrowserLink = isShowAJoinFromYourBrowserLink
            self.isJoinFromMobile = isJoinFromMobile
            self.isJoinFromDesktop = isJoinFromDesktop
            self.allowParticipantsToRename = allowParticipantsToRename
            self.whoCanShareScreen = whoCanShareScreen
            self.whoCanShareScreenWhenSomeoneIsSharing = whoCanShareScreenWhenSomeoneIsSharing
            self.isFileTransfer = isFileTransfer
            self.isRequestPermissionToUnmute = isRequestPermissionToUnmute
            self.webinarLiveStreaming = webinarLiveStreaming
            self.webinarChat = webinarChat
            self.closedCaptioning = closedCaptioning
            self.isSlideControl = isSlideControl
            self.isMeetingSurvey = isMeetingSurvey
            self.webinarPolling = webinarPolling
            self.isWebinarSurvey = isWebinarSurvey
        }

        private enum CodingKeys: String, CodingKey {
            case isE2eEncryption = "e2e_encryption"
            case isChat = "chat"
            case allowParticipantsChatWith = "allow_participants_chat_with"
            case allowUsersSaveChats = "allow_users_save_chats"
            case isPrivateChat = "private_chat"
            case isAutoSavingChat = "auto_saving_chat"
            case entryExitChime = "entry_exit_chime"
            case isRecordPlayOwnVoice = "record_play_own_voice"
            case isFeedback = "feedback"
            case isPostMeetingFeedback = "post_meeting_feedback"
            case isCoHost = "co_host"
            case isPolling = "polling"
            case isAttendeeOnHold = "attendee_on_hold"
            case isShowMeetingControlToolbar = "show_meeting_control_toolbar"
            case allowShowZoomWindows = "allow_show_zoom_windows"
            case isAnnotation = "annotation"
            case isWhiteboard = "whiteboard"
            case isWebinarQuestionAnswer = "webinar_question_answer"
            case isAnonymousQuestionAnswer = "anonymous_question_answer"
            case isBreakoutRoom = "breakout_room"
            case isBreakoutRoomSchedule = "breakout_room_schedule"
            case isClosedCaption = "closed_caption"
            case isFarEndCameraControl = "far_end_camera_control"
            case isGroupHd = "group_hd"
            case isVirtualBackground = "virtual_background"
            case virtualBackgroundSettings = "virtual_background_settings"
            case isWatermark = "watermark"
            case isAlertGuestJoin = "alert_guest_join"
            case isAutoAnswer = "auto_answer"
            case isP2pConnetion = "p2p_connetion"
            case isP2pPorts = "p2p_ports"
            case portsRange = "ports_range"
            case isSendingDefaultEmailInvites = "sending_default_email_invites"
            case useHTMLFormatEmail = "use_html_format_email"
            case isDscpMarking = "dscp_marking"
            case dscpAudio = "dscp_audio"
            case dscpVideo = "dscp_video"
            case isStereoAudio = "stereo_audio"
            case isOriginalAudio = "original_audio"
            case isScreenSharing = "screen_sharing"
            case isRemoteControl = "remote_control"
            case allowLiveStreaming = "allow_live_streaming"
            case isLiveStreamingFacebook = "live_streaming_facebook"
            case isWorkplaceByFacebook = "workplace_by_facebook"
            case isLiveStreamingYoutube = "live_streaming_youtube"
            case isCustomLiveStreamingService = "custom_live_streaming_service"
            case customServiceInstructions = "custom_service_instructions"
            case isCustomDataCenterRegions = "custom_data_center_regions"
            case dataCenterRegions = "data_center_regions"
            case isMeetingReactions = "meeting_reactions"
            case isShowAJoinFromYourBrowserLink = "show_a_join_from_your_browser_link"
            case isJoinFromMobile = "join_from_mobile"
            case isJoinFromDesktop = "join_from_desktop"
            case allowParticipantsToRename = "allow_participants_to_rename"
            case whoCanShareScreen = "who_can_share_screen"
            case whoCanShareScreenWhenSomeoneIsSharing = "who_can_share_screen_when_someone_is_sharing"
            case isFileTransfer = "file_transfer"
            case isRequestPermissionToUnmute = "request_permission_to_unmute"
            case webinarLiveStreaming = "webinar_live_streaming"
            case webinarChat = "webinar_chat"
            case closedCaptioning = "closed_captioning"
            case isSlideControl = "slide_control"
            case isMeetingSurvey = "meeting_survey"
            case webinarPolling = "webinar_polling"
            case isWebinarSurvey = "webinar_survey"
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.isE2eEncryption = try values.decodeIfPresent(Bool.self, forKey: .isE2eEncryption)
            self.isChat = try values.decodeIfPresent(Bool.self, forKey: .isChat)
            self.allowParticipantsChatWith = try values.decodeIfPresent(Int.self, forKey: .allowParticipantsChatWith)
            self.allowUsersSaveChats = try values.decodeIfPresent(Int.self, forKey: .allowUsersSaveChats)
            self.isPrivateChat = try values.decodeIfPresent(Bool.self, forKey: .isPrivateChat)
            self.isAutoSavingChat = try values.decodeIfPresent(Bool.self, forKey: .isAutoSavingChat)
            self.entryExitChime = try values.decodeIfPresent(EntryExitChime.self, forKey: .entryExitChime)
            self.isRecordPlayOwnVoice = try values.decodeIfPresent(Bool.self, forKey: .isRecordPlayOwnVoice)
            self.isFeedback = try values.decodeIfPresent(Bool.self, forKey: .isFeedback)
            self.isPostMeetingFeedback = try values.decodeIfPresent(Bool.self, forKey: .isPostMeetingFeedback)
            self.isCoHost = try values.decodeIfPresent(Bool.self, forKey: .isCoHost)
            self.isPolling = try values.decodeIfPresent(Bool.self, forKey: .isPolling)
            self.isAttendeeOnHold = try values.decodeIfPresent(Bool.self, forKey: .isAttendeeOnHold) ?? false
            self.isShowMeetingControlToolbar = try values.decodeIfPresent(Bool.self, forKey: .isShowMeetingControlToolbar)
            self.allowShowZoomWindows = try values.decodeIfPresent(Bool.self, forKey: .allowShowZoomWindows)
            self.isAnnotation = try values.decodeIfPresent(Bool.self, forKey: .isAnnotation)
            self.isWhiteboard = try values.decodeIfPresent(Bool.self, forKey: .isWhiteboard)
            self.isWebinarQuestionAnswer = try values.decodeIfPresent(Bool.self, forKey: .isWebinarQuestionAnswer)
            self.isAnonymousQuestionAnswer = try values.decodeIfPresent(Bool.self, forKey: .isAnonymousQuestionAnswer)
            self.isBreakoutRoom = try values.decodeIfPresent(Bool.self, forKey: .isBreakoutRoom)
            self.isBreakoutRoomSchedule = try values.decodeIfPresent(Bool.self, forKey: .isBreakoutRoomSchedule)
            self.isClosedCaption = try values.decodeIfPresent(Bool.self, forKey: .isClosedCaption)
            self.isFarEndCameraControl = try values.decodeIfPresent(Bool.self, forKey: .isFarEndCameraControl)
            self.isGroupHd = try values.decodeIfPresent(Bool.self, forKey: .isGroupHd)
            self.isVirtualBackground = try values.decodeIfPresent(Bool.self, forKey: .isVirtualBackground)
            self.virtualBackgroundSettings = try values.decodeIfPresent(VirtualBackgroundSettings.self, forKey: .virtualBackgroundSettings)
            self.isWatermark = try values.decodeIfPresent(Bool.self, forKey: .isWatermark)
            self.isAlertGuestJoin = try values.decodeIfPresent(Bool.self, forKey: .isAlertGuestJoin)
            self.isAutoAnswer = try values.decodeIfPresent(Bool.self, forKey: .isAutoAnswer)
            self.isP2pConnetion = try values.decodeIfPresent(Bool.self, forKey: .isP2pConnetion)
            self.isP2pPorts = try values.decodeIfPresent(Bool.self, forKey: .isP2pPorts)
            self.portsRange = try values.decodeIfPresent(String.self, forKey: .portsRange)
            self.isSendingDefaultEmailInvites = try values.decodeIfPresent(Bool.self, forKey: .isSendingDefaultEmailInvites)
            self.useHTMLFormatEmail = try values.decodeIfPresent(Bool.self, forKey: .useHTMLFormatEmail)
            self.isDscpMarking = try values.decodeIfPresent(Bool.self, forKey: .isDscpMarking)
            self.dscpAudio = try values.decodeIfPresent(Int.self, forKey: .dscpAudio)
            self.dscpVideo = try values.decodeIfPresent(Int.self, forKey: .dscpVideo)
            self.isStereoAudio = try values.decodeIfPresent(Bool.self, forKey: .isStereoAudio)
            self.isOriginalAudio = try values.decodeIfPresent(Bool.self, forKey: .isOriginalAudio)
            self.isScreenSharing = try values.decodeIfPresent(Bool.self, forKey: .isScreenSharing)
            self.isRemoteControl = try values.decodeIfPresent(Bool.self, forKey: .isRemoteControl)
            self.allowLiveStreaming = try values.decodeIfPresent(Bool.self, forKey: .allowLiveStreaming)
            self.isLiveStreamingFacebook = try values.decodeIfPresent(Bool.self, forKey: .isLiveStreamingFacebook)
            self.isWorkplaceByFacebook = try values.decodeIfPresent(Bool.self, forKey: .isWorkplaceByFacebook)
            self.isLiveStreamingYoutube = try values.decodeIfPresent(Bool.self, forKey: .isLiveStreamingYoutube)
            self.isCustomLiveStreamingService = try values.decodeIfPresent(Bool.self, forKey: .isCustomLiveStreamingService)
            self.customServiceInstructions = try values.decodeIfPresent(String.self, forKey: .customServiceInstructions)
            self.isCustomDataCenterRegions = try values.decodeIfPresent(Bool.self, forKey: .isCustomDataCenterRegions)
            self.dataCenterRegions = try values.decodeIfPresent([String].self, forKey: .dataCenterRegions)
            self.isMeetingReactions = try values.decodeIfPresent(Bool.self, forKey: .isMeetingReactions)
            self.isShowAJoinFromYourBrowserLink = try values.decodeIfPresent(Bool.self, forKey: .isShowAJoinFromYourBrowserLink)
            self.isJoinFromMobile = try values.decodeIfPresent(Bool.self, forKey: .isJoinFromMobile)
            self.isJoinFromDesktop = try values.decodeIfPresent(Bool.self, forKey: .isJoinFromDesktop)
            self.allowParticipantsToRename = try values.decodeIfPresent(Bool.self, forKey: .allowParticipantsToRename)
            self.whoCanShareScreen = try values.decodeIfPresent(WhoCanShareScreen.self, forKey: .whoCanShareScreen)
            self.whoCanShareScreenWhenSomeoneIsSharing = try values.decodeIfPresent(WhoCanShareScreenWhenSomeoneIsSharing.self, forKey: .whoCanShareScreenWhenSomeoneIsSharing)
            self.isFileTransfer = try values.decodeIfPresent(Bool.self, forKey: .isFileTransfer)
            self.isRequestPermissionToUnmute = try values.decodeIfPresent(Bool.self, forKey: .isRequestPermissionToUnmute)
            self.webinarLiveStreaming = try values.decodeIfPresent(WebinarLiveStreaming.self, forKey: .webinarLiveStreaming)
            self.webinarChat = try values.decodeIfPresent(WebinarChat.self, forKey: .webinarChat)
            self.closedCaptioning = try values.decodeIfPresent(ClosedCaptioning.self, forKey: .closedCaptioning)
            self.isSlideControl = try values.decodeIfPresent(Bool.self, forKey: .isSlideControl)
            self.isMeetingSurvey = try values.decodeIfPresent(Bool.self, forKey: .isMeetingSurvey)
            self.webinarPolling = try values.decodeIfPresent(WebinarPolling.self, forKey: .webinarPolling)
            self.isWebinarSurvey = try values.decodeIfPresent(Bool.self, forKey: .isWebinarSurvey)
        }
    }

    /// Account Settings: Notification.
    public struct EmailNotification: Codable {
        /// Whether to notify the host when a cloud recording is available.
        public var isCloudRecordingAvailableReminder: Bool?
        /// Whether to notify the person who scheduled the meeting or webinar for the host when a cloud recording is available.
        public var isRecordingAvailableReminderSchedulers: Bool?
        /// Whether to notify any alternative hosts when a cloud recording is available.
        public var isRecordingAvailableReminderAlternativeHosts: Bool?
        /// Notify the host when participants join the meeting before them.
        public var isJbhReminder: Bool?
        /// Notify the host and participants when a meeting is cancelled.
        public var isCancelMeetingReminder: Bool?
        /// Notify user when host licenses are running low.
        public var isLowHostCountReminder: Bool?
        /// Notify when an alternative host is set or removed from a meeting.
        public var isAlternativeHostReminder: Bool?
        /// Notify the host there is a meeting is scheduled, rescheduled, or cancelled.
        public var isScheduleForReminder: Bool?

        public init(isCloudRecordingAvailableReminder: Bool? = nil, isRecordingAvailableReminderSchedulers: Bool? = nil, isRecordingAvailableReminderAlternativeHosts: Bool? = nil, isJbhReminder: Bool? = nil, isCancelMeetingReminder: Bool? = nil, isLowHostCountReminder: Bool? = nil, isAlternativeHostReminder: Bool? = nil, isScheduleForReminder: Bool? = nil) {
            self.isCloudRecordingAvailableReminder = isCloudRecordingAvailableReminder
            self.isRecordingAvailableReminderSchedulers = isRecordingAvailableReminderSchedulers
            self.isRecordingAvailableReminderAlternativeHosts = isRecordingAvailableReminderAlternativeHosts
            self.isJbhReminder = isJbhReminder
            self.isCancelMeetingReminder = isCancelMeetingReminder
            self.isLowHostCountReminder = isLowHostCountReminder
            self.isAlternativeHostReminder = isAlternativeHostReminder
            self.isScheduleForReminder = isScheduleForReminder
        }

        private enum CodingKeys: String, CodingKey {
            case isCloudRecordingAvailableReminder = "cloud_recording_available_reminder"
            case isRecordingAvailableReminderSchedulers = "recording_available_reminder_schedulers"
            case isRecordingAvailableReminderAlternativeHosts = "recording_available_reminder_alternative_hosts"
            case isJbhReminder = "jbh_reminder"
            case isCancelMeetingReminder = "cancel_meeting_reminder"
            case isLowHostCountReminder = "low_host_count_reminder"
            case isAlternativeHostReminder = "alternative_host_reminder"
            case isScheduleForReminder = "schedule_for_reminder"
        }
    }

    /// Account Settings: Zoom Rooms.
    public struct ZoomRooms: Codable {
        /// Upcoming meeting alert.
        public var isUpcomingMeetingAlert: Bool?
        /// Start AirPlay service manually.
        public var isStartAirplayManually: Bool?
        /// Weekly system restart.
        public var isWeeklySystemRestart: Bool?
        /// Display meeting list with calendar integration.
        public var isListMeetingsWithCalendar: Bool?
        /// Zoom Room post meeting feedback.
        public var isZrPostMeetingFeedback: Bool?
        /// Automatic direct sharing using an ultrasonic proximity signal.
        public var isUltrasonic: Bool?
        /// Shift all meetings to private.
        public var isForcePrivateMeeting: Bool?
        /// Hide host and meeting ID from private meetings.
        public var isHideHostInformation: Bool?
        /// Cloud recording for instant meetings.
        public var isCmrForInstantMeeting: Bool?
        /// Automatic start and stop for scheduled meetings.
        public var isAutoStartStopScheduledMeetings: Bool?

        public init(isUpcomingMeetingAlert: Bool? = nil, isStartAirplayManually: Bool? = nil, isWeeklySystemRestart: Bool? = nil, isListMeetingsWithCalendar: Bool? = nil, isZrPostMeetingFeedback: Bool? = nil, isUltrasonic: Bool? = nil, isForcePrivateMeeting: Bool? = nil, isHideHostInformation: Bool? = nil, isCmrForInstantMeeting: Bool? = nil, isAutoStartStopScheduledMeetings: Bool? = nil) {
            self.isUpcomingMeetingAlert = isUpcomingMeetingAlert
            self.isStartAirplayManually = isStartAirplayManually
            self.isWeeklySystemRestart = isWeeklySystemRestart
            self.isListMeetingsWithCalendar = isListMeetingsWithCalendar
            self.isZrPostMeetingFeedback = isZrPostMeetingFeedback
            self.isUltrasonic = isUltrasonic
            self.isForcePrivateMeeting = isForcePrivateMeeting
            self.isHideHostInformation = isHideHostInformation
            self.isCmrForInstantMeeting = isCmrForInstantMeeting
            self.isAutoStartStopScheduledMeetings = isAutoStartStopScheduledMeetings
        }

        private enum CodingKeys: String, CodingKey {
            case isUpcomingMeetingAlert = "upcoming_meeting_alert"
            case isStartAirplayManually = "start_airplay_manually"
            case isWeeklySystemRestart = "weekly_system_restart"
            case isListMeetingsWithCalendar = "list_meetings_with_calendar"
            case isZrPostMeetingFeedback = "zr_post_meeting_feedback"
            case isUltrasonic = "ultrasonic"
            case isForcePrivateMeeting = "force_private_meeting"
            case isHideHostInformation = "hide_host_information"
            case isCmrForInstantMeeting = "cmr_for_instant_meeting"
            case isAutoStartStopScheduledMeetings = "auto_start_stop_scheduled_meetings"
        }
    }

    /// [Security settings](https://support.zoom.us/hc/en-us/articles/360034675592-Advanced-security-settings#h_bf8a25f6-9a66-447a-befd-f02ed3404f89) of an Account.
    public struct Security: Codable {
        /// Only account administrators can change a user's username and picture.
        public var isAdminChangeNamePic: Bool?
        /// Allow users to import photos from a photo library on a  device.
        public var isImportPhotosFromDevices: Bool?
        /// Hide billing information.
        public var isHideBillingInfo: Bool?
        /// This object refers to the [enhanced password rules](https://support.zoom.us/hc/en-us/articles/360034675592-Advanced-security-settings#h_bf8a25f6-9a66-447a-befd-f02ed3404f89) that allows Zoom account admins and owners to apply extra requiremets to the users' Zoom login password.
        public var passwordRequirement: PasswordRequirement?
        /// Settings for 2FA( [two factor authentication](https://support.zoom.us/hc/en-us/articles/360038247071) ). The value can be one of the following:
        /// `all`: Two factor authentication will be enabled for all users in the account.<br>
        /// `none`: Two factor authentication is disabled.<br>
        /// `group`: Two factor authentication will be enabled for users belonging to specific groups. If 2FA is enabled for certain groups, the group IDs of the group(s) will be provided in the `sign_in_with_two_factor_auth_groups` field.<br>
        /// `role`: Two factor authentication will be enabled only for users assigned with specific roles in the account. If 2FA is enabled for specific roles, the role IDs will be provided in the
        /// `sign_in_with_two_factor_auth_roles` field.
        public var signInWithTwoFactorAuth: SignInWithTwoFactorAuth?
        /// Settings for User Sign In interval requirements after a period of inactivity. If enabled, this setting forces automatic logout of users in Zoom Client app after a set amount of time. <br>
        /// 
        /// If this setting is disabled, the value of this field will be `0`. If the setting is enabled, the value of this field will indicate the **period of inactivity** in minutes after which, an inactive user will be automatically logged out of the Zoom Client. The value for the period of inactivity can be one of the following:<br>
        /// 
        /// `5`: 5 minutes<br>
        /// `10`: 10 minutes<br>
        /// `15`: 15 minutes<br>
        /// `30`: 30 minutes<br>
        /// `45`: 45 minutes<br>
        /// `60`: 60 minutes<br>
        /// `90`: 90 minutes<br>
        /// `120`: 120 minutes
        public var signAgainPeriodForInactivityOnClient: Int?
        /// Settings for User Sign In interval requirements after a period of inactivity. If enabled, this setting forces automatic logout of users in Zoom Web Portal after a set amount of time. <br>
        /// 
        /// If this setting is disabled, the value of this field will be `0`. If the setting is enabled, the value of this field will indicate the **period of inactivity** in minutes after which, an inactive user will be automatically logged out of the Zoom Web Portal. The value for the period of inactivity can be one of the following:<br>
        /// 
        /// `5`: 5 minutes<br>
        /// `10`: 10 minutes<br>
        /// `15`: 15 minutes<br>
        /// `30`: 30 minutes<br>
        /// `60`: 60 minutes<br>
        /// `120`: 120 minutes
        public var signAgainPeriodForInactivityOnWeb: Int?
        /// This field contains group IDs of groups that have 2FA enabled. This field is only returned if the value of `sign_in_with_two_factor_auth` is `group`
        public var signInWithTwoFactorAuthGroups: [String]?
        /// This field contains role IDs of roles that have 2FA enabled. This field is only returned if the value of `sign_in_with_two_factor_auth` is `role`.
        public var signInWithTwoFactorAuthRoles: [String]?

        /// This object refers to the [enhanced password rules](https://support.zoom.us/hc/en-us/articles/360034675592-Advanced-security-settings#h_bf8a25f6-9a66-447a-befd-f02ed3404f89) that allows Zoom account admins and owners to apply extra requiremets to the users' Zoom login password.
        public struct PasswordRequirement: Codable {
            /// Specify a minimum length for the password. The password length can be from a minimum of 9 characters, up to 14 characters. If you provide `0` as the value of this field, this field will be disabled and not be used and the basic password length requirement (minimum of 8 characters) will be applied for the requirement.
            public var minimumPasswordLength: Int?
            /// If the value of this field is set to `true`, the password must have at least one special character(!, @, #...).
            public var haveSpecialCharacter: Bool?
            /// Specify the max length of consecutive characters(abcde...) that can be used in a password.
            /// If you set the value of this field to `0`, no restriction will be applied on consecutive characters. 
            /// 
            /// If you would like to set this restriction, you can specify a number between 4 and 8 that define the maximum allowed length for consecutive characters in a password.
            /// 
            /// The max allowed length will be `n-1` where `n` refers to the value you provide for this field.  For instance, if you provide `4` as the value, there can only be a maximum of `3` consecutive characters in a password(example: abc1x@8fdh).
            public var consecutiveCharactersLength: Int?
            /// If the value of this field is set to `true`, user passwords will have to pass detection through a weak password dictionary in case hackers use simple passwords to sign in to your users’ accounts.
            public var isWeakEnhanceDetection: Bool?

            public init(minimumPasswordLength: Int? = nil, haveSpecialCharacter: Bool? = nil, consecutiveCharactersLength: Int? = nil, isWeakEnhanceDetection: Bool? = nil) {
                self.minimumPasswordLength = minimumPasswordLength
                self.haveSpecialCharacter = haveSpecialCharacter
                self.consecutiveCharactersLength = consecutiveCharactersLength
                self.isWeakEnhanceDetection = isWeakEnhanceDetection
            }

            private enum CodingKeys: String, CodingKey {
                case minimumPasswordLength = "minimum_password_length"
                case haveSpecialCharacter = "have_special_character"
                case consecutiveCharactersLength = "consecutive_characters_length"
                case isWeakEnhanceDetection = "weak_enhance_detection"
            }
        }

        /// Settings for 2FA( [two factor authentication](https://support.zoom.us/hc/en-us/articles/360038247071) ). The value can be one of the following:
        /// `all`: Two factor authentication will be enabled for all users in the account.<br>
        /// `none`: Two factor authentication is disabled.<br>
        /// `group`: Two factor authentication will be enabled for users belonging to specific groups. If 2FA is enabled for certain groups, the group IDs of the group(s) will be provided in the `sign_in_with_two_factor_auth_groups` field.<br>
        /// `role`: Two factor authentication will be enabled only for users assigned with specific roles in the account. If 2FA is enabled for specific roles, the role IDs will be provided in the
        /// `sign_in_with_two_factor_auth_roles` field.
        public enum SignInWithTwoFactorAuth: String, Codable, CaseIterable {
            case all
            case group
            case role
            case `none`
        }

        public init(isAdminChangeNamePic: Bool? = nil, isImportPhotosFromDevices: Bool? = nil, isHideBillingInfo: Bool? = nil, passwordRequirement: PasswordRequirement? = nil, signInWithTwoFactorAuth: SignInWithTwoFactorAuth? = nil, signAgainPeriodForInactivityOnClient: Int? = nil, signAgainPeriodForInactivityOnWeb: Int? = nil, signInWithTwoFactorAuthGroups: [String]? = nil, signInWithTwoFactorAuthRoles: [String]? = nil) {
            self.isAdminChangeNamePic = isAdminChangeNamePic
            self.isImportPhotosFromDevices = isImportPhotosFromDevices
            self.isHideBillingInfo = isHideBillingInfo
            self.passwordRequirement = passwordRequirement
            self.signInWithTwoFactorAuth = signInWithTwoFactorAuth
            self.signAgainPeriodForInactivityOnClient = signAgainPeriodForInactivityOnClient
            self.signAgainPeriodForInactivityOnWeb = signAgainPeriodForInactivityOnWeb
            self.signInWithTwoFactorAuthGroups = signInWithTwoFactorAuthGroups
            self.signInWithTwoFactorAuthRoles = signInWithTwoFactorAuthRoles
        }

        private enum CodingKeys: String, CodingKey {
            case isAdminChangeNamePic = "admin_change_name_pic"
            case isImportPhotosFromDevices = "import_photos_from_devices"
            case isHideBillingInfo = "hide_billing_info"
            case passwordRequirement = "password_requirement"
            case signInWithTwoFactorAuth = "sign_in_with_two_factor_auth"
            case signAgainPeriodForInactivityOnClient = "sign_again_period_for_inactivity_on_client"
            case signAgainPeriodForInactivityOnWeb = "sign_again_period_for_inactivity_on_web"
            case signInWithTwoFactorAuthGroups = "sign_in_with_two_factor_auth_groups"
            case signInWithTwoFactorAuthRoles = "sign_in_with_two_factor_auth_roles"
        }
    }

    /// Account Settings: Recording.
    public struct Recording: Codable {
        /// Allow hosts and participants to record the meeting using a local file.
        public var isLocalRecording: Bool?
        /// Allow hosts to record and save the meeting in the cloud.
        public var isCloudRecording: Bool?
        /// Record the active speaker with a shared screen.
        public var isRecordSpeakerView: Bool?
        /// Record the gallery view with a shared screen.
        public var isRecordGalleryView: Bool?
        /// Whether to record one audio file for all participants.
        public var isRecordAudioFile: Bool?
        /// Save the chat text from the meeting.
        public var isSaveChatText: Bool?
        /// Add a timestamp to the recording.
        public var isShowTimestamp: Bool?
        /// Automatically transcribe the audio of the meeting or webinar to the cloud.
        public var isRecordingAudioTranscript: Bool?
        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public var autoRecording: AutoRecording?
        /// Cloud recording downloads.
        public var isCloudRecordingDownload: Bool?
        /// Only the host can download cloud recordings.
        public var isCloudRecordingDownloadHost: Bool?
        /// Cloud recordings are only accessible to account members. People outside of your organization cannot open links that provide access to cloud recordings.
        public var isAccountUserAccessRecording: Bool?
        /// Allow Zoom to permanantly delete recordings automatically after a specified number of days.
        public var autoDeleteCmr: Bool?
        /// When the `auto_delete_cmr` value is `true`, this value is the number of days before the auto-deletion of cloud recordings: 
        /// * `30` — 30 days. 
        /// * `60` — 60 days. 
        /// * `90` — 90 days. 
        /// * `120` — 120 days.
        public var autoDeleteCmrDays: Int?
        /// This object represents the minimum password requirements set for recordings via Account Recording Settings.
        public var recordingPasswordRequirement: RecordingPasswordRequirement?
        /// Allow recovery of deleted cloud recordings from trash. 
        /// If the value of this field is set to `true`, deleted cloud recordings will be kept in trash for 30 days after deletion and can be recovered within that period.
        public var allowRecoveryDeletedCloudRecordings: Bool?
        /// Show a disclaimer to participants before a recording starts
        public var isRecordingDisclaimer: Bool?
        /// If the value of this field is set to `true`, hosts will be able to delete the recordings. If this option is set to `false`, the recordings cannot be deleted by the host and only admin can delete them.
        public var hostDeleteCloudRecording: Bool?
        /// Require a passcode to access existing cloud recordings.
        public var isRequiredPasswordForExistingCloudRecordings: Bool?
        /// If set to `true`, meeting hosts cannot view their meeting cloud recordings. Only the admins who have recording management privilege can access them.
        public var isPreventHostAccessRecording: Bool?
        /// Setting to allow cloud recording access only from specific IP address ranges.
        public var ipAddressAccessControl: IpAddressAccessControl?
        /// [Archiving solution](https://support.zoom.us/hc/en-us/articles/360050431572-Archiving-Meeting-and-Webinar-data) settings. This setting can only be used if you have been granted with archiving solution access by the Zoom support team.
        public var archive: Archive?

        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public enum AutoRecording: String, Codable, CaseIterable {
            case local
            case cloud
            case `none`
        }

        /// This object represents the minimum password requirements set for recordings via Account Recording Settings.
        public struct RecordingPasswordRequirement: Codable {
            /// Minimum required length for the password.
            public var length: Int?
            /// Indicates whether or not password must contain at least one alphabetical letter (a, b, c..).
            public var haveLetter: Bool?
            /// Indicates whether or not password must contain at least one number(1, 2, 3..).
            public var haveNumber: Bool?
            /// Indicates whether or not password must contain at least one special character(!, @, #..).
            public var haveSpecialCharacter: Bool?
            /// Indicates whether or not password must contain only numeric characters.
            public var onlyAllowNumeric: Bool?

            public init(length: Int? = nil, haveLetter: Bool? = nil, haveNumber: Bool? = nil, haveSpecialCharacter: Bool? = nil, onlyAllowNumeric: Bool? = nil) {
                self.length = length
                self.haveLetter = haveLetter
                self.haveNumber = haveNumber
                self.haveSpecialCharacter = haveSpecialCharacter
                self.onlyAllowNumeric = onlyAllowNumeric
            }

            private enum CodingKeys: String, CodingKey {
                case length
                case haveLetter = "have_letter"
                case haveNumber = "have_number"
                case haveSpecialCharacter = "have_special_character"
                case onlyAllowNumeric = "only_allow_numeric"
            }
        }

        /// Setting to allow cloud recording access only from specific IP address ranges.
        public struct IpAddressAccessControl: Codable {
            /// If set to `true`, the cloud recordings of this account can only be accessed by the IP addresses defined in the `ip_addresses_or_ranges` property.
            public var enable: Bool?
            /// IP addresses or ranges that have access to the cloud recordings. Separate multiple IP ranges with comma. Use n.n.n.n, n.n.n.n/n or n.n.n.n - n.n.n.n syntax where n is a number.
            /// 
            /// Example: `46.33.24.184, 48.99.100.2/25` or `200.181.108.17 - 220.181.108.157`
            public var ipAddressesOrRanges: String?

            public init(enable: Bool? = nil, ipAddressesOrRanges: String? = nil) {
                self.enable = enable
                self.ipAddressesOrRanges = ipAddressesOrRanges
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case ipAddressesOrRanges = "ip_addresses_or_ranges"
            }
        }

        /// [Archiving solution](https://support.zoom.us/hc/en-us/articles/360050431572-Archiving-Meeting-and-Webinar-data) settings. This setting can only be used if you have been granted with archiving solution access by the Zoom support team.
        public struct Archive: Codable {
            /// Enable the archiving feature.
            public var enable: Bool?
            /// Archive types:
            /// 
            /// * `1`: Only meetings are archived.<br>
            /// * `2`: Only webinars are archived.<br>
            /// * `3`: Both meetings and webinars are archived.
            public var type: Int?
            public var settings: Settings?

            public struct Settings: Codable {
                /// Include in-meeting chat in the archive.
                public var isChatFile: Bool?
                /// Include user email in in-meeting chat file.
                public var isChatWithSenderEmail: Bool?
                /// Include in-meeting and/or in-webinar audio in the archive.
                public var isAudioFile: Bool?
                /// Include in-meeting and/or in-webinar video in the archive.
                public var isVideoFile: Bool?
                /// Include closed caption or transcript in the archive.
                public var isCcTranscriptFile: Bool?

                public init(isChatFile: Bool? = nil, isChatWithSenderEmail: Bool? = nil, isAudioFile: Bool? = nil, isVideoFile: Bool? = nil, isCcTranscriptFile: Bool? = nil) {
                    self.isChatFile = isChatFile
                    self.isChatWithSenderEmail = isChatWithSenderEmail
                    self.isAudioFile = isAudioFile
                    self.isVideoFile = isVideoFile
                    self.isCcTranscriptFile = isCcTranscriptFile
                }

                private enum CodingKeys: String, CodingKey {
                    case isChatFile = "chat_file"
                    case isChatWithSenderEmail = "chat_with_sender_email"
                    case isAudioFile = "audio_file"
                    case isVideoFile = "video_file"
                    case isCcTranscriptFile = "cc_transcript_file"
                }
            }

            public init(enable: Bool? = nil, type: Int? = nil, settings: Settings? = nil) {
                self.enable = enable
                self.type = type
                self.settings = settings
            }
        }

        public init(isLocalRecording: Bool? = nil, isCloudRecording: Bool? = nil, isRecordSpeakerView: Bool? = nil, isRecordGalleryView: Bool? = nil, isRecordAudioFile: Bool? = nil, isSaveChatText: Bool? = nil, isShowTimestamp: Bool? = nil, isRecordingAudioTranscript: Bool? = nil, autoRecording: AutoRecording? = nil, isCloudRecordingDownload: Bool? = nil, isCloudRecordingDownloadHost: Bool? = nil, isAccountUserAccessRecording: Bool? = nil, autoDeleteCmr: Bool? = nil, autoDeleteCmrDays: Int? = nil, recordingPasswordRequirement: RecordingPasswordRequirement? = nil, allowRecoveryDeletedCloudRecordings: Bool? = nil, isRecordingDisclaimer: Bool? = nil, hostDeleteCloudRecording: Bool? = nil, isRequiredPasswordForExistingCloudRecordings: Bool? = nil, isPreventHostAccessRecording: Bool? = nil, ipAddressAccessControl: IpAddressAccessControl? = nil, archive: Archive? = nil) {
            self.isLocalRecording = isLocalRecording
            self.isCloudRecording = isCloudRecording
            self.isRecordSpeakerView = isRecordSpeakerView
            self.isRecordGalleryView = isRecordGalleryView
            self.isRecordAudioFile = isRecordAudioFile
            self.isSaveChatText = isSaveChatText
            self.isShowTimestamp = isShowTimestamp
            self.isRecordingAudioTranscript = isRecordingAudioTranscript
            self.autoRecording = autoRecording
            self.isCloudRecordingDownload = isCloudRecordingDownload
            self.isCloudRecordingDownloadHost = isCloudRecordingDownloadHost
            self.isAccountUserAccessRecording = isAccountUserAccessRecording
            self.autoDeleteCmr = autoDeleteCmr
            self.autoDeleteCmrDays = autoDeleteCmrDays
            self.recordingPasswordRequirement = recordingPasswordRequirement
            self.allowRecoveryDeletedCloudRecordings = allowRecoveryDeletedCloudRecordings
            self.isRecordingDisclaimer = isRecordingDisclaimer
            self.hostDeleteCloudRecording = hostDeleteCloudRecording
            self.isRequiredPasswordForExistingCloudRecordings = isRequiredPasswordForExistingCloudRecordings
            self.isPreventHostAccessRecording = isPreventHostAccessRecording
            self.ipAddressAccessControl = ipAddressAccessControl
            self.archive = archive
        }

        private enum CodingKeys: String, CodingKey {
            case isLocalRecording = "local_recording"
            case isCloudRecording = "cloud_recording"
            case isRecordSpeakerView = "record_speaker_view"
            case isRecordGalleryView = "record_gallery_view"
            case isRecordAudioFile = "record_audio_file"
            case isSaveChatText = "save_chat_text"
            case isShowTimestamp = "show_timestamp"
            case isRecordingAudioTranscript = "recording_audio_transcript"
            case autoRecording = "auto_recording"
            case isCloudRecordingDownload = "cloud_recording_download"
            case isCloudRecordingDownloadHost = "cloud_recording_download_host"
            case isAccountUserAccessRecording = "account_user_access_recording"
            case autoDeleteCmr = "auto_delete_cmr"
            case autoDeleteCmrDays = "auto_delete_cmr_days"
            case recordingPasswordRequirement = "recording_password_requirement"
            case allowRecoveryDeletedCloudRecordings = "allow_recovery_deleted_cloud_recordings"
            case isRecordingDisclaimer = "recording_disclaimer"
            case hostDeleteCloudRecording = "host_delete_cloud_recording"
            case isRequiredPasswordForExistingCloudRecordings = "required_password_for_existing_cloud_recordings"
            case isPreventHostAccessRecording = "prevent_host_access_recording"
            case ipAddressAccessControl = "ip_address_access_control"
            case archive
        }
    }

    /// Account Settings Update: Telephony.
    public struct Telephony: Codable {
        /// Users can join the meeting using the existing third party audio configuration.
        public var isThirdPartyAudio: Bool?
        /// Third party audio conference info.
        public var audioConferenceInfo: String?
        /// Indicates where most of the participants call into or call from duriing a meeting.
        public var telephonyRegions: TelephonyRegions?

        /// Indicates where most of the participants call into or call from duriing a meeting.
        public struct TelephonyRegions: Codable {
            /// The account's selected telephony regions that indicate where most participants call into or call from during a meeting.
            public var selectionValues: String?

            public init(selectionValues: String? = nil) {
                self.selectionValues = selectionValues
            }

            private enum CodingKeys: String, CodingKey {
                case selectionValues = "selection_values"
            }
        }

        public init(isThirdPartyAudio: Bool? = nil, audioConferenceInfo: String? = nil, telephonyRegions: TelephonyRegions? = nil) {
            self.isThirdPartyAudio = isThirdPartyAudio
            self.audioConferenceInfo = audioConferenceInfo
            self.telephonyRegions = telephonyRegions
        }

        private enum CodingKeys: String, CodingKey {
            case isThirdPartyAudio = "third_party_audio"
            case audioConferenceInfo = "audio_conference_info"
            case telephonyRegions = "telephony_regions"
        }
    }

    /// Account Settings: Integration.
    public struct Integration: Codable {
        /// Enable meetings to be scheduled using Google Calendar.
        public var isGoogleCalendar: Bool?
        /// Enable users who join a meeting from their mobile device to share content from their Google Drive.
        public var isGoogleDrive: Bool?
        /// Enable users who join a meeting from their mobile device to share content from their Dropbox account.
        public var isDropbox: Bool?
        /// Enable users who join a meeting from their mobile device to share content from their Box account.
        public var isBox: Bool?
        /// Enable users who join a meeting from their mobile device to share content from their Microsoft OneDrive account.
        public var isMicrosoftOneDrive: Bool?
        /// Enable users to control a connected Kubi device from within a Zoom meeting.
        public var isKubi: Bool?

        public init(isGoogleCalendar: Bool? = nil, isGoogleDrive: Bool? = nil, isDropbox: Bool? = nil, isBox: Bool? = nil, isMicrosoftOneDrive: Bool? = nil, isKubi: Bool? = nil) {
            self.isGoogleCalendar = isGoogleCalendar
            self.isGoogleDrive = isGoogleDrive
            self.isDropbox = isDropbox
            self.isBox = isBox
            self.isMicrosoftOneDrive = isMicrosoftOneDrive
            self.isKubi = isKubi
        }

        private enum CodingKeys: String, CodingKey {
            case isGoogleCalendar = "google_calendar"
            case isGoogleDrive = "google_drive"
            case isDropbox = "dropbox"
            case isBox = "box"
            case isMicrosoftOneDrive = "microsoft_one_drive"
            case isKubi = "kubi"
        }
    }

    /// Account Settings: Feature.
    public struct Feature: Codable {
        /// Set the maximum number of participants a host can have in a single meeting.
        public var meetingCapacity: Int?

        public init(meetingCapacity: Int? = nil) {
            self.meetingCapacity = meetingCapacity
        }

        private enum CodingKeys: String, CodingKey {
            case meetingCapacity = "meeting_capacity"
        }
    }

    /// Account Settings: TSP.
    public struct Tsp: Codable {
        /// Call Out
        public var isCallOut: Bool?
        /// Call Out Countries/Regions
        public var callOutCountries: [[String: AnyJSON]]?
        /// Show international numbers link on the invitation email
        public var isShowInternationalNumbersLink: Bool?
        /// Display toll-free numbers
        public var isDisplayTollFreeNumbers: Bool?

        public init(isCallOut: Bool? = nil, callOutCountries: [[String: AnyJSON]]? = nil, isShowInternationalNumbersLink: Bool? = nil, isDisplayTollFreeNumbers: Bool? = nil) {
            self.isCallOut = isCallOut
            self.callOutCountries = callOutCountries
            self.isShowInternationalNumbersLink = isShowInternationalNumbersLink
            self.isDisplayTollFreeNumbers = isDisplayTollFreeNumbers
        }

        private enum CodingKeys: String, CodingKey {
            case isCallOut = "call_out"
            case callOutCountries = "call_out_countries"
            case isShowInternationalNumbersLink = "show_international_numbers_link"
            case isDisplayTollFreeNumbers = "display_toll_free_numbers"
        }
    }

    public struct Profile: Codable {
        public var recordingStorageLocation: RecordingStorageLocation?

        public struct RecordingStorageLocation: Codable {
            /// Users can choose the country to store their recorded content. Content can include meeting, webinar, and phone recordings, as well as voicemail, transcripts, and custom greeting prompts. See [Managing the Communications Content storage location](https://support.zoom.us/hc/en-us/articles/360050781131) for details.
            /// 
            /// Provide abbreviated country codes as the value for this field. See the [Countries abbreviation list](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries) for details.
            public var allowedValues: [String]?
            /// Abbreviated country code.
            public var value: String?

            public init(allowedValues: [String]? = nil, value: String? = nil) {
                self.allowedValues = allowedValues
                self.value = value
            }

            private enum CodingKeys: String, CodingKey {
                case allowedValues = "allowed_values"
                case value
            }
        }

        public init(recordingStorageLocation: RecordingStorageLocation? = nil) {
            self.recordingStorageLocation = recordingStorageLocation
        }

        private enum CodingKeys: String, CodingKey {
            case recordingStorageLocation = "recording_storage_location"
        }
    }

    public struct OtherOptions: Codable {
        /// Whether administrators can activate users with a single default password when they add users. This immediately activates the users without waiting for them to set their own password.
        public var allowAutoActiveUsers: Bool?
        /// Whether iOS blurs the screenshot in the task switcher when multiple apps are open. Android hides the screenshot in the system-level list of recent apps.
        public var isBlurSnapshot: Bool?
        /// Whether a user with the [scheduling privilege](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-privilege) can view other users' meetings.
        public var isDisplayMeetingsScheduledForOthers: Bool?
        /// Allow connections to different CDNs (content delivery networks) for a better web browsing experience. All users in your organization will use the selected CDN to access static resources: 
        /// * `none` — Do not use a CDN. 
        /// * `default` — Use the Amazon CloudFront CDN for users **except** Chinese Mainland users. Chinese Mainland users will use the Wangsu CDN (China). 
        /// * `wangsu` — Use the Wangsu CDN for all users.
        public var useCdn: UseCdn?
        /// Whether to display the Zoom Help badge on the bottom-right of the page.
        public var allowUsersContactSupportViaChat: Bool?
        /// Whether meetings with only one person will display on the Dashboard and in reports.
        public var isShowOneUserMeetingOnDashboard: Bool?
        /// The Dashboard meeting [quality scores and network alerts](https://support.zoom.us/hc/en-us/articles/360061244651) setting: 
        /// * `0` — Do not enable meeting quality scores and network alerts on the Dashboard. 
        /// * `1` — Display the meeting quality score and network alerts on the Dashboard. 
        /// * `2` — Use custom thresholds for quality scores and network alerts.
        public var meetingQosAndMos: Int?
        /// Whether users can add pronouns to their profile cards and share them during meetings and webinars.
        public var allowUsersEnterAndSharePronouns: Bool?

        /// Allow connections to different CDNs (content delivery networks) for a better web browsing experience. All users in your organization will use the selected CDN to access static resources: 
        /// * `none` — Do not use a CDN. 
        /// * `default` — Use the Amazon CloudFront CDN for users **except** Chinese Mainland users. Chinese Mainland users will use the Wangsu CDN (China). 
        /// * `wangsu` — Use the Wangsu CDN for all users.
        public enum UseCdn: String, Codable, CaseIterable {
            case `none`
            case `default`
            case wangsu
        }

        public init(allowAutoActiveUsers: Bool? = nil, isBlurSnapshot: Bool? = nil, isDisplayMeetingsScheduledForOthers: Bool? = nil, useCdn: UseCdn? = nil, allowUsersContactSupportViaChat: Bool? = nil, isShowOneUserMeetingOnDashboard: Bool? = nil, meetingQosAndMos: Int? = nil, allowUsersEnterAndSharePronouns: Bool? = nil) {
            self.allowAutoActiveUsers = allowAutoActiveUsers
            self.isBlurSnapshot = isBlurSnapshot
            self.isDisplayMeetingsScheduledForOthers = isDisplayMeetingsScheduledForOthers
            self.useCdn = useCdn
            self.allowUsersContactSupportViaChat = allowUsersContactSupportViaChat
            self.isShowOneUserMeetingOnDashboard = isShowOneUserMeetingOnDashboard
            self.meetingQosAndMos = meetingQosAndMos
            self.allowUsersEnterAndSharePronouns = allowUsersEnterAndSharePronouns
        }

        private enum CodingKeys: String, CodingKey {
            case allowAutoActiveUsers = "allow_auto_active_users"
            case isBlurSnapshot = "blur_snapshot"
            case isDisplayMeetingsScheduledForOthers = "display_meetings_scheduled_for_others"
            case useCdn = "use_cdn"
            case allowUsersContactSupportViaChat = "allow_users_contact_support_via_chat"
            case isShowOneUserMeetingOnDashboard = "show_one_user_meeting_on_dashboard"
            case meetingQosAndMos = "meeting_qos_and_mos"
            case allowUsersEnterAndSharePronouns = "allow_users_enter_and_share_pronouns"
        }
    }

    /// The account's audio conference settings.
    public struct AudioConferencing: Codable {
        /// The account's [**Toll-free and Fee-based Toll Call**](https://support.zoom.us/hc/en-us/articles/360060950711-Enabling-Toll-free-and-Fee-based-Toll-Call#h_01F51680NJ7YHZDXGJNSKDGM2P) settings.
        public var tollFreeAndFeeBasedTollCall: TollFreeAndFeeBasedTollCall?

        /// The account's [**Toll-free and Fee-based Toll Call**](https://support.zoom.us/hc/en-us/articles/360060950711-Enabling-Toll-free-and-Fee-based-Toll-Call#h_01F51680NJ7YHZDXGJNSKDGM2P) settings.
        public struct TollFreeAndFeeBasedTollCall: Codable {
            /// Whether the account has the [**Toll-free and Fee-based Toll Call**](https://support.zoom.us/hc/en-us/articles/360060950711-Enabling-Toll-free-and-Fee-based-Toll-Call#h_01F51680NJ7YHZDXGJNSKDGM2P) setting enabled.
            public var enable: Bool?
            /// The account's **Toll-free and Fee-based Toll Call** phone number information.
            public var numbers: [Number]?
            /// Whether webinar attendees can dial in through the account's **Toll-free and Fee-based Toll Call** phone numbers. This feature is only available in version 5.2.2 and higher.
            public var allowWebinarAttendeesDial: Bool?

            public struct Number: Codable {
                /// The phone number's [E.164 country calling code](https://en.wikipedia.org/wiki/List_of_country_calling_codes).
                public var code: String?
                /// The phone number's [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
                public var countryCode: String?
                /// The country name.
                public var countryName: String?
                /// The phone number.
                public var number: String?
                /// The phone number's display number.
                public var displayNumber: String?

                public init(code: String? = nil, countryCode: String? = nil, countryName: String? = nil, number: String? = nil, displayNumber: String? = nil) {
                    self.code = code
                    self.countryCode = countryCode
                    self.countryName = countryName
                    self.number = number
                    self.displayNumber = displayNumber
                }

                private enum CodingKeys: String, CodingKey {
                    case code
                    case countryCode = "country_code"
                    case countryName = "country_name"
                    case number
                    case displayNumber = "display_number"
                }
            }

            public init(enable: Bool? = nil, numbers: [Number]? = nil, allowWebinarAttendeesDial: Bool? = nil) {
                self.enable = enable
                self.numbers = numbers
                self.allowWebinarAttendeesDial = allowWebinarAttendeesDial
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case numbers
                case allowWebinarAttendeesDial = "allow_webinar_attendees_dial"
            }
        }

        public init(tollFreeAndFeeBasedTollCall: TollFreeAndFeeBasedTollCall? = nil) {
            self.tollFreeAndFeeBasedTollCall = tollFreeAndFeeBasedTollCall
        }

        private enum CodingKeys: String, CodingKey {
            case tollFreeAndFeeBasedTollCall = "toll_free_and_fee_based_toll_call"
        }
    }

    public init(scheduleMeeting: ScheduleMeeting? = nil, inMeeting: InMeeting? = nil, emailNotification: EmailNotification? = nil, zoomRooms: ZoomRooms? = nil, security: Security? = nil, recording: Recording? = nil, telephony: Telephony? = nil, integration: Integration? = nil, feature: Feature? = nil, tsp: Tsp? = nil, profile: Profile? = nil, otherOptions: OtherOptions? = nil, audioConferencing: AudioConferencing? = nil) {
        self.scheduleMeeting = scheduleMeeting
        self.inMeeting = inMeeting
        self.emailNotification = emailNotification
        self.zoomRooms = zoomRooms
        self.security = security
        self.recording = recording
        self.telephony = telephony
        self.integration = integration
        self.feature = feature
        self.tsp = tsp
        self.profile = profile
        self.otherOptions = otherOptions
        self.audioConferencing = audioConferencing
    }

    private enum CodingKeys: String, CodingKey {
        case scheduleMeeting = "schedule_meeting"
        case inMeeting = "in_meeting"
        case emailNotification = "email_notification"
        case zoomRooms = "zoom_rooms"
        case security
        case recording
        case telephony
        case integration
        case feature
        case tsp
        case profile
        case otherOptions = "other_options"
        case audioConferencing = "audio_conferencing"
    }
}

/// Account Settings: Recording.
public struct AccountSettingsRecording: Codable {
    /// Allow hosts and participants to record the meeting using a local file.
    public var isLocalRecording: Bool?
    /// Allow hosts to record and save the meeting in the cloud.
    public var isCloudRecording: Bool?
    /// Record the active speaker with a shared screen.
    public var isRecordSpeakerView: Bool?
    /// Record the gallery view with a shared screen.
    public var isRecordGalleryView: Bool?
    /// Whether to record one audio file for all participants.
    public var isRecordAudioFile: Bool?
    /// Save the chat text from the meeting.
    public var isSaveChatText: Bool?
    /// Add a timestamp to the recording.
    public var isShowTimestamp: Bool?
    /// Automatically transcribe the audio of the meeting or webinar to the cloud.
    public var isRecordingAudioTranscript: Bool?
    /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
    public var autoRecording: AutoRecording?
    /// Cloud recording downloads.
    public var isCloudRecordingDownload: Bool?
    /// Only the host can download cloud recordings.
    public var isCloudRecordingDownloadHost: Bool?
    /// Cloud recordings are only accessible to account members. People outside of your organization cannot open links that provide access to cloud recordings.
    public var isAccountUserAccessRecording: Bool?
    /// Allow Zoom to permanantly delete recordings automatically after a specified number of days.
    public var autoDeleteCmr: Bool?
    /// When the `auto_delete_cmr` value is `true`, this value is the number of days before the auto-deletion of cloud recordings: 
    /// * `30` — 30 days. 
    /// * `60` — 60 days. 
    /// * `90` — 90 days. 
    /// * `120` — 120 days.
    public var autoDeleteCmrDays: Int?
    /// This object represents the minimum password requirements set for recordings via Account Recording Settings.
    public var recordingPasswordRequirement: RecordingPasswordRequirement?
    /// Allow recovery of deleted cloud recordings from trash. 
    /// If the value of this field is set to `true`, deleted cloud recordings will be kept in trash for 30 days after deletion and can be recovered within that period.
    public var allowRecoveryDeletedCloudRecordings: Bool?
    /// Show a disclaimer to participants before a recording starts
    public var isRecordingDisclaimer: Bool?
    /// If the value of this field is set to `true`, hosts will be able to delete the recordings. If this option is set to `false`, the recordings cannot be deleted by the host and only admin can delete them.
    public var hostDeleteCloudRecording: Bool?
    /// Require a passcode to access existing cloud recordings.
    public var isRequiredPasswordForExistingCloudRecordings: Bool?
    /// If set to `true`, meeting hosts cannot view their meeting cloud recordings. Only the admins who have recording management privilege can access them.
    public var isPreventHostAccessRecording: Bool?
    /// Setting to allow cloud recording access only from specific IP address ranges.
    public var ipAddressAccessControl: IpAddressAccessControl?
    /// [Archiving solution](https://support.zoom.us/hc/en-us/articles/360050431572-Archiving-Meeting-and-Webinar-data) settings. This setting can only be used if you have been granted with archiving solution access by the Zoom support team.
    public var archive: Archive?

    /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
    public enum AutoRecording: String, Codable, CaseIterable {
        case local
        case cloud
        case `none`
    }

    /// This object represents the minimum password requirements set for recordings via Account Recording Settings.
    public struct RecordingPasswordRequirement: Codable {
        /// Minimum required length for the password.
        public var length: Int?
        /// Indicates whether or not password must contain at least one alphabetical letter (a, b, c..).
        public var haveLetter: Bool?
        /// Indicates whether or not password must contain at least one number(1, 2, 3..).
        public var haveNumber: Bool?
        /// Indicates whether or not password must contain at least one special character(!, @, #..).
        public var haveSpecialCharacter: Bool?
        /// Indicates whether or not password must contain only numeric characters.
        public var onlyAllowNumeric: Bool?

        public init(length: Int? = nil, haveLetter: Bool? = nil, haveNumber: Bool? = nil, haveSpecialCharacter: Bool? = nil, onlyAllowNumeric: Bool? = nil) {
            self.length = length
            self.haveLetter = haveLetter
            self.haveNumber = haveNumber
            self.haveSpecialCharacter = haveSpecialCharacter
            self.onlyAllowNumeric = onlyAllowNumeric
        }

        private enum CodingKeys: String, CodingKey {
            case length
            case haveLetter = "have_letter"
            case haveNumber = "have_number"
            case haveSpecialCharacter = "have_special_character"
            case onlyAllowNumeric = "only_allow_numeric"
        }
    }

    /// Setting to allow cloud recording access only from specific IP address ranges.
    public struct IpAddressAccessControl: Codable {
        /// If set to `true`, the cloud recordings of this account can only be accessed by the IP addresses defined in the `ip_addresses_or_ranges` property.
        public var enable: Bool?
        /// IP addresses or ranges that have access to the cloud recordings. Separate multiple IP ranges with comma. Use n.n.n.n, n.n.n.n/n or n.n.n.n - n.n.n.n syntax where n is a number.
        /// 
        /// Example: `46.33.24.184, 48.99.100.2/25` or `200.181.108.17 - 220.181.108.157`
        public var ipAddressesOrRanges: String?

        public init(enable: Bool? = nil, ipAddressesOrRanges: String? = nil) {
            self.enable = enable
            self.ipAddressesOrRanges = ipAddressesOrRanges
        }

        private enum CodingKeys: String, CodingKey {
            case enable
            case ipAddressesOrRanges = "ip_addresses_or_ranges"
        }
    }

    /// [Archiving solution](https://support.zoom.us/hc/en-us/articles/360050431572-Archiving-Meeting-and-Webinar-data) settings. This setting can only be used if you have been granted with archiving solution access by the Zoom support team.
    public struct Archive: Codable {
        /// Enable the archiving feature.
        public var enable: Bool?
        /// Archive types:
        /// 
        /// * `1`: Only meetings are archived.<br>
        /// * `2`: Only webinars are archived.<br>
        /// * `3`: Both meetings and webinars are archived.
        public var type: Int?
        public var settings: Settings?

        public struct Settings: Codable {
            /// Include in-meeting chat in the archive.
            public var isChatFile: Bool?
            /// Include user email in in-meeting chat file.
            public var isChatWithSenderEmail: Bool?
            /// Include in-meeting and/or in-webinar audio in the archive.
            public var isAudioFile: Bool?
            /// Include in-meeting and/or in-webinar video in the archive.
            public var isVideoFile: Bool?
            /// Include closed caption or transcript in the archive.
            public var isCcTranscriptFile: Bool?

            public init(isChatFile: Bool? = nil, isChatWithSenderEmail: Bool? = nil, isAudioFile: Bool? = nil, isVideoFile: Bool? = nil, isCcTranscriptFile: Bool? = nil) {
                self.isChatFile = isChatFile
                self.isChatWithSenderEmail = isChatWithSenderEmail
                self.isAudioFile = isAudioFile
                self.isVideoFile = isVideoFile
                self.isCcTranscriptFile = isCcTranscriptFile
            }

            private enum CodingKeys: String, CodingKey {
                case isChatFile = "chat_file"
                case isChatWithSenderEmail = "chat_with_sender_email"
                case isAudioFile = "audio_file"
                case isVideoFile = "video_file"
                case isCcTranscriptFile = "cc_transcript_file"
            }
        }

        public init(enable: Bool? = nil, type: Int? = nil, settings: Settings? = nil) {
            self.enable = enable
            self.type = type
            self.settings = settings
        }
    }

    public init(isLocalRecording: Bool? = nil, isCloudRecording: Bool? = nil, isRecordSpeakerView: Bool? = nil, isRecordGalleryView: Bool? = nil, isRecordAudioFile: Bool? = nil, isSaveChatText: Bool? = nil, isShowTimestamp: Bool? = nil, isRecordingAudioTranscript: Bool? = nil, autoRecording: AutoRecording? = nil, isCloudRecordingDownload: Bool? = nil, isCloudRecordingDownloadHost: Bool? = nil, isAccountUserAccessRecording: Bool? = nil, autoDeleteCmr: Bool? = nil, autoDeleteCmrDays: Int? = nil, recordingPasswordRequirement: RecordingPasswordRequirement? = nil, allowRecoveryDeletedCloudRecordings: Bool? = nil, isRecordingDisclaimer: Bool? = nil, hostDeleteCloudRecording: Bool? = nil, isRequiredPasswordForExistingCloudRecordings: Bool? = nil, isPreventHostAccessRecording: Bool? = nil, ipAddressAccessControl: IpAddressAccessControl? = nil, archive: Archive? = nil) {
        self.isLocalRecording = isLocalRecording
        self.isCloudRecording = isCloudRecording
        self.isRecordSpeakerView = isRecordSpeakerView
        self.isRecordGalleryView = isRecordGalleryView
        self.isRecordAudioFile = isRecordAudioFile
        self.isSaveChatText = isSaveChatText
        self.isShowTimestamp = isShowTimestamp
        self.isRecordingAudioTranscript = isRecordingAudioTranscript
        self.autoRecording = autoRecording
        self.isCloudRecordingDownload = isCloudRecordingDownload
        self.isCloudRecordingDownloadHost = isCloudRecordingDownloadHost
        self.isAccountUserAccessRecording = isAccountUserAccessRecording
        self.autoDeleteCmr = autoDeleteCmr
        self.autoDeleteCmrDays = autoDeleteCmrDays
        self.recordingPasswordRequirement = recordingPasswordRequirement
        self.allowRecoveryDeletedCloudRecordings = allowRecoveryDeletedCloudRecordings
        self.isRecordingDisclaimer = isRecordingDisclaimer
        self.hostDeleteCloudRecording = hostDeleteCloudRecording
        self.isRequiredPasswordForExistingCloudRecordings = isRequiredPasswordForExistingCloudRecordings
        self.isPreventHostAccessRecording = isPreventHostAccessRecording
        self.ipAddressAccessControl = ipAddressAccessControl
        self.archive = archive
    }

    private enum CodingKeys: String, CodingKey {
        case isLocalRecording = "local_recording"
        case isCloudRecording = "cloud_recording"
        case isRecordSpeakerView = "record_speaker_view"
        case isRecordGalleryView = "record_gallery_view"
        case isRecordAudioFile = "record_audio_file"
        case isSaveChatText = "save_chat_text"
        case isShowTimestamp = "show_timestamp"
        case isRecordingAudioTranscript = "recording_audio_transcript"
        case autoRecording = "auto_recording"
        case isCloudRecordingDownload = "cloud_recording_download"
        case isCloudRecordingDownloadHost = "cloud_recording_download_host"
        case isAccountUserAccessRecording = "account_user_access_recording"
        case autoDeleteCmr = "auto_delete_cmr"
        case autoDeleteCmrDays = "auto_delete_cmr_days"
        case recordingPasswordRequirement = "recording_password_requirement"
        case allowRecoveryDeletedCloudRecordings = "allow_recovery_deleted_cloud_recordings"
        case isRecordingDisclaimer = "recording_disclaimer"
        case hostDeleteCloudRecording = "host_delete_cloud_recording"
        case isRequiredPasswordForExistingCloudRecordings = "required_password_for_existing_cloud_recordings"
        case isPreventHostAccessRecording = "prevent_host_access_recording"
        case ipAddressAccessControl = "ip_address_access_control"
        case archive
    }
}

public struct AccountSettingsOtherOptions: Codable {
    /// Whether administrators can activate users with a single default password when they add users. This immediately activates the users without waiting for them to set their own password.
    public var allowAutoActiveUsers: Bool?
    /// Whether iOS blurs the screenshot in the task switcher when multiple apps are open. Android hides the screenshot in the system-level list of recent apps.
    public var isBlurSnapshot: Bool?
    /// Whether a user with the [scheduling privilege](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-privilege) can view other users' meetings.
    public var isDisplayMeetingsScheduledForOthers: Bool?
    /// Allow connections to different CDNs (content delivery networks) for a better web browsing experience. All users in your organization will use the selected CDN to access static resources: 
    /// * `none` — Do not use a CDN. 
    /// * `default` — Use the Amazon CloudFront CDN for users **except** Chinese Mainland users. Chinese Mainland users will use the Wangsu CDN (China). 
    /// * `wangsu` — Use the Wangsu CDN for all users.
    public var useCdn: UseCdn?
    /// Whether to display the Zoom Help badge on the bottom-right of the page.
    public var allowUsersContactSupportViaChat: Bool?
    /// Whether meetings with only one person will display on the Dashboard and in reports.
    public var isShowOneUserMeetingOnDashboard: Bool?
    /// The Dashboard meeting [quality scores and network alerts](https://support.zoom.us/hc/en-us/articles/360061244651) setting: 
    /// * `0` — Do not enable meeting quality scores and network alerts on the Dashboard. 
    /// * `1` — Display the meeting quality score and network alerts on the Dashboard. 
    /// * `2` — Use custom thresholds for quality scores and network alerts.
    public var meetingQosAndMos: Int?
    /// Whether users can add pronouns to their profile cards and share them during meetings and webinars.
    public var allowUsersEnterAndSharePronouns: Bool?

    /// Allow connections to different CDNs (content delivery networks) for a better web browsing experience. All users in your organization will use the selected CDN to access static resources: 
    /// * `none` — Do not use a CDN. 
    /// * `default` — Use the Amazon CloudFront CDN for users **except** Chinese Mainland users. Chinese Mainland users will use the Wangsu CDN (China). 
    /// * `wangsu` — Use the Wangsu CDN for all users.
    public enum UseCdn: String, Codable, CaseIterable {
        case `none`
        case `default`
        case wangsu
    }

    public init(allowAutoActiveUsers: Bool? = nil, isBlurSnapshot: Bool? = nil, isDisplayMeetingsScheduledForOthers: Bool? = nil, useCdn: UseCdn? = nil, allowUsersContactSupportViaChat: Bool? = nil, isShowOneUserMeetingOnDashboard: Bool? = nil, meetingQosAndMos: Int? = nil, allowUsersEnterAndSharePronouns: Bool? = nil) {
        self.allowAutoActiveUsers = allowAutoActiveUsers
        self.isBlurSnapshot = isBlurSnapshot
        self.isDisplayMeetingsScheduledForOthers = isDisplayMeetingsScheduledForOthers
        self.useCdn = useCdn
        self.allowUsersContactSupportViaChat = allowUsersContactSupportViaChat
        self.isShowOneUserMeetingOnDashboard = isShowOneUserMeetingOnDashboard
        self.meetingQosAndMos = meetingQosAndMos
        self.allowUsersEnterAndSharePronouns = allowUsersEnterAndSharePronouns
    }

    private enum CodingKeys: String, CodingKey {
        case allowAutoActiveUsers = "allow_auto_active_users"
        case isBlurSnapshot = "blur_snapshot"
        case isDisplayMeetingsScheduledForOthers = "display_meetings_scheduled_for_others"
        case useCdn = "use_cdn"
        case allowUsersContactSupportViaChat = "allow_users_contact_support_via_chat"
        case isShowOneUserMeetingOnDashboard = "show_one_user_meeting_on_dashboard"
        case meetingQosAndMos = "meeting_qos_and_mos"
        case allowUsersEnterAndSharePronouns = "allow_users_enter_and_share_pronouns"
    }
}

/// Account object in the account list.
public struct AccountListItem: Codable {
    /// List of Account objects.
    public var accounts: [Account]?

    public struct Account: Codable {
        /// Account ID.
        public var id: String?
        /// Account name.
        public var accountName: String?
        /// Account owner email.
        ///
        /// Example: "john.doe@zoom.us"
        public var ownerEmail: String?
        /// Account type.
        public var accountType: String?
        /// Account seats.
        public var seats: Int?
        /// Account subscription start date and time.
        public var subscriptionStartTime: Date?
        /// Account subscription end date and time.
        public var subscriptionEndTime: Date?
        /// Account creation date and time.
        public var createdAt: Date?
        /// Account Number of the account.
        public var accountNumber: String?

        public init(id: String? = nil, accountName: String? = nil, ownerEmail: String? = nil, accountType: String? = nil, seats: Int? = nil, subscriptionStartTime: Date? = nil, subscriptionEndTime: Date? = nil, createdAt: Date? = nil, accountNumber: String? = nil) {
            self.id = id
            self.accountName = accountName
            self.ownerEmail = ownerEmail
            self.accountType = accountType
            self.seats = seats
            self.subscriptionStartTime = subscriptionStartTime
            self.subscriptionEndTime = subscriptionEndTime
            self.createdAt = createdAt
            self.accountNumber = accountNumber
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case accountName = "account_name"
            case ownerEmail = "owner_email"
            case accountType = "account_type"
            case seats
            case subscriptionStartTime = "subscription_start_time"
            case subscriptionEndTime = "subscription_end_time"
            case createdAt = "created_at"
            case accountNumber = "account_number"
        }
    }

    public init(accounts: [Account]? = nil) {
        self.accounts = accounts
    }
}

public struct AccountSettings: Codable {
    /// Account Settings: Schedule Meeting.
    public var scheduleMeeting: ScheduleMeeting?
    /// Account Settings: In Meeting.
    public var inMeeting: InMeeting?
    /// Account Settings: Notification.
    public var emailNotification: EmailNotification?
    /// Account Settings: Zoom Rooms.
    public var zoomRooms: ZoomRooms?
    /// [Security settings](https://support.zoom.us/hc/en-us/articles/360034675592-Advanced-security-settings#h_bf8a25f6-9a66-447a-befd-f02ed3404f89) of an Account.
    public var security: Security?
    /// Account Settings: Recording.
    public var recording: Recording?
    /// Account Settings: Telephony.
    public var telephony: Telephony?
    /// Account Settings: Integration.
    public var integration: Integration?
    /// Account Settings: Feature.
    public var feature: Feature?
    /// Account Settings: TSP.
    public var tsp: Tsp?
    public var profile: Profile?
    public var otherOptions: OtherOptions?
    /// The account's audio conference settings.
    public var audioConferencing: AudioConferencing?

    /// Account Settings: Schedule Meeting.
    public struct ScheduleMeeting: Codable {
        /// Start meetings with the host video on.
        public var isHostVideo: Bool?
        /// Start meetings with the participant video on. Participants can change this setting during the meeting.
        public var isParticipantVideo: Bool?
        /// Determine how participants can join the audio portion of the meeting.<br>`both` - Telephony and VoIP.<br>`telephony` - Audio PSTN telephony only.<br>`voip` - VoIP only.<br>`thirdParty` - 3rd party audio conference.
        public var audioType: AudioType?
        /// Allow participants to join the meeting before the host arrives.
        public var isJoinBeforeHost: Bool?
        /// If the value of "join_before_host" field is set to true, this field can be used to indicate time limits within which a participant may join a meeting before a host. The value of this field can be one of the following:
        /// 
        /// *  `0`: Allow participant to join anytime.
        /// *  `5`: Allow participant to join 5 minutes before meeting start time.
        ///  * `10`: Allow participant to join 10 minutes before meeting start time.
        public var jbhTime: Int?
        /// Only Zoom users who are signed in can join meetings.
        public var enforceLogin: Bool?
        /// Only signed in users with a specific domain can join meetings.
        public var enforceLoginWithDomains: Bool?
        /// Only signed in users with a specified domain can join the meeting.
        public var enforceLoginDomains: String?
        /// Always display "Zoom Meeting" as the meeting topic.
        public var isNotStoreMeetingTopic: Bool?
        /// Require a password for Personal Meetings if attendees can join before host.
        public var isForcePmiJbhPassword: Bool?
        /// Use Personal Meeting ID (PMI) when scheduling a meeting
        public var usePmiForScheduledMeetings: Bool?
        /// Use Personal Meeting ID (PMI) when starting an instant meeting
        public var usePmiForInstantMeetings: Bool?
        /// Require a password when scheduling new meetings. This setting applies for regular meetings that do not use PMI. If enabled, a password will be generated while a host schedules a new meeting and participants will be required to enter the password before they can join the meeting. This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
        public var requirePasswordForSchedulingNewMeetings: Bool?
        /// Require a password for meetings which have already been scheduled
        public var requirePasswordForScheduledMeetings: Bool?
        /// Require a password for instant meetings. If you use PMI for your instant meetings, this option will be disabled. This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
        public var requirePasswordForInstantMeetings: Bool?
        /// Require a password for a meeting held using Personal Meeting ID (PMI) This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
        public var requirePasswordForPmiMeetings: RequirePasswordForPmiMeetings?
        /// Account wide meeting/webinar [password requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
        public var meetingPasswordRequirement: MeetingPasswordRequirement?
        /// Personal Meeting Setting.<br><br>
        /// `true`: Indicates that the **"Enable Personal Meeting ID"** setting is turned on. Users can choose to use personal meeting ID for their meetings. <br><br>
        /// `false`: Indicates that the **"Enable Personal Meeting ID"** setting is [turned off](https://support.zoom.us/hc/en-us/articles/201362843-Personal-meeting-ID-PMI-and-personal-link#h_aa0335c8-3b06-41bc-bc1f-a8b84ef17f2a). If this setting is disabled, meetings that were scheduled with PMI will be invalid. Scheduled meetings will need to be manually updated.
        /// For Zoom Phone only:If a user has been assigned a desk phone, **"Elevate to Zoom Meeting"** on desk phone will be disabled.
        public var isPersonalMeeting: Bool?

        /// Determine how participants can join the audio portion of the meeting.<br>`both` - Telephony and VoIP.<br>`telephony` - Audio PSTN telephony only.<br>`voip` - VoIP only.<br>`thirdParty` - 3rd party audio conference.
        public enum AudioType: String, Codable, CaseIterable {
            case both
            case telephony
            case voip
            case thirdParty
        }

        /// Require a password for a meeting held using Personal Meeting ID (PMI) This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
        public enum RequirePasswordForPmiMeetings: String, Codable, CaseIterable {
            case jbhOnly = "jbh_only"
            case all
            case `none`
        }

        /// Account wide meeting/webinar [password requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
        public struct MeetingPasswordRequirement: Codable {
            /// The minimum length that the meeting/webinar password needs to have.
            public var length: Int?
            /// If set to `true`, the password must contain at least 1 letter (such as a,b,c...).
            public var haveLetter: Bool?
            /// If set to `true`, the password must contain at least 1 number (such as 1,2,3...).
            public var haveNumber: Bool?
            /// If set to `true`, the password must have at least 1 special character (!,@,#...).
            public var haveSpecialCharacter: Bool?
            /// If set to `true`, the password must only contain numbers and no other characters.
            public var onlyAllowNumeric: Bool?
            /// If set to `true`, the password must include both uppercase and lowercase characters.
            public var haveUpperAndLowerCharacters: Bool?
            public var consecutiveCharactersLength: Int?
            /// If set to `true`, users will be informed if the provided password is weak.
            public var isWeakEnhanceDetection: Bool?

            public init(length: Int? = nil, haveLetter: Bool? = nil, haveNumber: Bool? = nil, haveSpecialCharacter: Bool? = nil, onlyAllowNumeric: Bool? = nil, haveUpperAndLowerCharacters: Bool? = nil, consecutiveCharactersLength: Int? = nil, isWeakEnhanceDetection: Bool? = nil) {
                self.length = length
                self.haveLetter = haveLetter
                self.haveNumber = haveNumber
                self.haveSpecialCharacter = haveSpecialCharacter
                self.onlyAllowNumeric = onlyAllowNumeric
                self.haveUpperAndLowerCharacters = haveUpperAndLowerCharacters
                self.consecutiveCharactersLength = consecutiveCharactersLength
                self.isWeakEnhanceDetection = isWeakEnhanceDetection
            }

            private enum CodingKeys: String, CodingKey {
                case length
                case haveLetter = "have_letter"
                case haveNumber = "have_number"
                case haveSpecialCharacter = "have_special_character"
                case onlyAllowNumeric = "only_allow_numeric"
                case haveUpperAndLowerCharacters = "have_upper_and_lower_characters"
                case consecutiveCharactersLength = "consecutive_characters_length"
                case isWeakEnhanceDetection = "weak_enhance_detection"
            }
        }

        public init(isHostVideo: Bool? = nil, isParticipantVideo: Bool? = nil, audioType: AudioType? = nil, isJoinBeforeHost: Bool? = nil, jbhTime: Int? = nil, enforceLogin: Bool? = nil, enforceLoginWithDomains: Bool? = nil, enforceLoginDomains: String? = nil, isNotStoreMeetingTopic: Bool? = nil, isForcePmiJbhPassword: Bool? = nil, usePmiForScheduledMeetings: Bool? = nil, usePmiForInstantMeetings: Bool? = nil, requirePasswordForSchedulingNewMeetings: Bool? = nil, requirePasswordForScheduledMeetings: Bool? = nil, requirePasswordForInstantMeetings: Bool? = nil, requirePasswordForPmiMeetings: RequirePasswordForPmiMeetings? = nil, meetingPasswordRequirement: MeetingPasswordRequirement? = nil, isPersonalMeeting: Bool? = nil) {
            self.isHostVideo = isHostVideo
            self.isParticipantVideo = isParticipantVideo
            self.audioType = audioType
            self.isJoinBeforeHost = isJoinBeforeHost
            self.jbhTime = jbhTime
            self.enforceLogin = enforceLogin
            self.enforceLoginWithDomains = enforceLoginWithDomains
            self.enforceLoginDomains = enforceLoginDomains
            self.isNotStoreMeetingTopic = isNotStoreMeetingTopic
            self.isForcePmiJbhPassword = isForcePmiJbhPassword
            self.usePmiForScheduledMeetings = usePmiForScheduledMeetings
            self.usePmiForInstantMeetings = usePmiForInstantMeetings
            self.requirePasswordForSchedulingNewMeetings = requirePasswordForSchedulingNewMeetings
            self.requirePasswordForScheduledMeetings = requirePasswordForScheduledMeetings
            self.requirePasswordForInstantMeetings = requirePasswordForInstantMeetings
            self.requirePasswordForPmiMeetings = requirePasswordForPmiMeetings
            self.meetingPasswordRequirement = meetingPasswordRequirement
            self.isPersonalMeeting = isPersonalMeeting
        }

        private enum CodingKeys: String, CodingKey {
            case isHostVideo = "host_video"
            case isParticipantVideo = "participant_video"
            case audioType = "audio_type"
            case isJoinBeforeHost = "join_before_host"
            case jbhTime = "jbh_time"
            case enforceLogin = "enforce_login"
            case enforceLoginWithDomains = "enforce_login_with_domains"
            case enforceLoginDomains = "enforce_login_domains"
            case isNotStoreMeetingTopic = "not_store_meeting_topic"
            case isForcePmiJbhPassword = "force_pmi_jbh_password"
            case usePmiForScheduledMeetings = "use_pmi_for_scheduled_meetings"
            case usePmiForInstantMeetings = "use_pmi_for_instant_meetings"
            case requirePasswordForSchedulingNewMeetings = "require_password_for_scheduling_new_meetings"
            case requirePasswordForScheduledMeetings = "require_password_for_scheduled_meetings"
            case requirePasswordForInstantMeetings = "require_password_for_instant_meetings"
            case requirePasswordForPmiMeetings = "require_password_for_pmi_meetings"
            case meetingPasswordRequirement = "meeting_password_requirement"
            case isPersonalMeeting = "personal_meeting"
        }
    }

    /// Account Settings: In Meeting.
    public struct InMeeting: Codable {
        /// Zoom requires encryption for all data between the Zoom cloud, Zoom client, and Zoom Room. Require encryption for 3rd party endpoints (H323/SIP).
        public var isE2eEncryption: Bool?
        /// Allow meeting participants to send a message that is visible to all participants.
        public var isChat: Bool?
        /// Whether to allow participants to only chat with certain groups:
        /// * `1` — The participant cannot use chat.
        /// * `2` — Host and co-hosts only.
        ///  * `3` — The participant can chat with other participants publicly.
        /// * `4` - The participant can chat with other participants publicly and privately.
        /// 
        /// **Note:** This setting is only available with client versions 5.7.3 and above.
        public var allowParticipantsChatWith: Int?
        /// Whether to allow participants to save meeting chats:
        /// * `1` — Participants cannot save meeting chats.
        /// * `2` — Participants can only save host and co-host meeting chats.
        /// * `3` — Participants can save all meeting chats.
        public var allowUsersSaveChats: Int?
        /// Allow a meeting participant to send a private message to another participant.
        public var isPrivateChat: Bool?
        /// Automatically save all in-meeting chats so that the host does not need to manually save the chat transcript after the meeting starts.
        public var isAutoSavingChat: Bool?
        /// Play sound when participants join or leave.<br>`host` - Heard by host only.<br>`all` - Heard by host and all attendees.<br>`none` - Disable.
        public var entryExitChime: EntryExitChime?
        /// Record and play their own voice.
        public var isRecordPlayOwnVoice: Bool?
        /// Add a "Feedback" tab to the Windows Settings or Mac Preferences dialog. Enable users to provide feedback to Zoom at the end of the meeting.
        public var isFeedback: Bool?
        /// Display a thumbs up or down survey at the end of each meeting.
        public var isPostMeetingFeedback: Bool?
        /// Allow the host to add co-hosts.
        public var isCoHost: Bool?
        /// Add "Polls" to the meeting controls.
        public var isPolling: Bool?
        /// Allow host to put attendee on hold.
        /// 
        /// **This field has been deprecated and is no longer supported.**
        public var isAttendeeOnHold: Bool
        /// Always show the meeting control toolbar.
        public var isShowMeetingControlToolbar: Bool?
        /// Show the Zoom desktop application when sharing screens.
        public var allowShowZoomWindows: Bool?
        /// Allow participants to use annotation tools to add information to shared screens.
        public var isAnnotation: Bool?
        /// Allow participants to share a whiteboard that includes annotation tools.
        public var isWhiteboard: Bool?
        /// Whether attendees can ask the host and panelists questions in the webinar.
        public var isWebinarQuestionAnswer: Bool?
        /// Allow an anonymous Q&A in a webinar.
        public var isAnonymousQuestionAnswer: Bool?
        /// Allow host to split meeting participants into separate, smaller rooms.
        public var isBreakoutRoom: Bool?
        /// Whether the host can assign participants to breakout rooms when scheduling. This feature is only available in version 4.5.0 or higher.
        public var isBreakoutRoomSchedule: Bool?
        /// Allow a host to type closed captions. Enable a host to assign a participant or third party device to add closed captions.
        public var isClosedCaption: Bool?
        /// Allow another user to take control of your camera during a meeting.
        public var isFarEndCameraControl: Bool?
        /// Activate higher quality video for host and participants.
        /// Please note: This will use more bandwidth.
        public var isGroupHd: Bool?
        /// Allow users to replace their background with any selected image. Choose or upload an image in the Zoom desktop application settings.
        public var isVirtualBackground: Bool?
        /// Settings to manage virtual background.
        public var virtualBackgroundSettings: VirtualBackgroundSettings?
        /// Add a watermark when viewing a shared screen.
        public var isWatermark: Bool?
        /// Identify guest participants in a meeting or webinar.
        public var isAlertGuestJoin: Bool?
        /// Enable users to see and add contacts to the "auto-answer group" in the chat contact list. Any call from members of this group will automatically be answered.
        public var isAutoAnswer: Bool?
        /// Peer to peer connection while only two people are in a meeting.
        public var isP2pConnetion: Bool?
        /// Peer to peer listening ports range.
        public var isP2pPorts: Bool?
        /// The listening ports range, separated by a comma (ex 55,56). The ports range must be between 1 to 65535.
        public var portsRange: String?
        /// Only show the default email when sending email invites.
        public var isSendingDefaultEmailInvites: Bool?
        /// Use HTML formatted email for the Outlook plugin.
        public var useHTMLFormatEmail: Bool?
        /// DSCP marking.
        public var isDscpMarking: Bool?
        /// DSCP audio.
        public var dscpAudio: Int?
        /// DSCP video.
        public var dscpVideo: Int?
        /// Allow users to select stereo audio in their client settings.
        public var isStereoAudio: Bool?
        /// Allow users to select original sound in their client settings.
        public var isOriginalAudio: Bool?
        /// Allow screen sharing.
        public var isScreenSharing: Bool?
        /// Allow users to request remote control.
        public var isRemoteControl: Bool?
        /// Whether to allow livestreaming.
        public var allowLiveStreaming: Bool?
        /// Whether to allow Facebook livestreaming.
        public var isLiveStreamingFacebook: Bool?
        /// Whether to allow Workplace by Facebook livestreaming.
        public var isWorkplaceByFacebook: Bool?
        /// Whether to allow YouTube livestreaming.
        public var isLiveStreamingYoutube: Bool?
        /// Whether to allow custom livestreaming.
        public var isCustomLiveStreamingService: Bool?
        /// The specific instructions to configure a custom livestream.
        public var customServiceInstructions: String?
        /// If set to `true`, account owners and admins on paid accounts can [select data center regions](https://support.zoom.us/hc/en-us/articles/360042411451-Selecting-data-center-regions-for-hosted-meetings-and-webinars) to use for hosting their real-time meeting and webinar traffic. These regions can be provided in the `data_center_regions` field. If set to `false`, the regions cannot be customized and the default regions will be used.
        public var isCustomDataCenterRegions: Bool?
        /// If you have set the value of `custom_data_center_regions` to `true`, specify the data center regions that you would like to opt in to (country codes from among: ["EU", "HK", "AU", "IN", "LA", "TY", "CN", "US", "CA"]).
        public var dataCenterRegions: [String]?
        /// Whether meeting participants can [communicate using the emoji reactions](https://support.zoom.us/hc/en-us/articles/115001286183-Nonverbal-feedback-and-meeting-reactions) located in the **Reactions** menu in the meeting toolbar.
        public var isMeetingReactions: Bool?
        /// Whether to allow participants to join a meeting directly from their browser and bypass the Zoom application download process. This is useful for participants who cannot download, install, or run applications. Note that the meeting experience from the browser is limited.
        public var isShowAJoinFromYourBrowserLink: Bool?
        /// Whether to allow participants to join a meeting directly from their mobile browser. Note that the meeting experience from the mobile browser is limited.
        public var isJoinFromMobile: Bool?
        /// Whether to allow participants to join a meeting directly from their desktop browser. Note that the meeting experience from the desktop browser is limited.
        public var isJoinFromDesktop: Bool?
        /// If the value of this field is set to `true`, meeting participants and webinar panelists can be allowed to rename themselves during a meeting or a webinar.
        public var allowParticipantsToRename: Bool?
        /// Indicates who can share their screen or content during meetings. The value can be one of the following: <br>
        /// `host`: Only host can share the screen.<br>
        /// `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
        public var whoCanShareScreen: WhoCanShareScreen?
        /// Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:<br>
        /// `host`: Only a host can share the screen when someone else is sharing.<br>
        /// `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
        public var whoCanShareScreenWhenSomeoneIsSharing: WhoCanShareScreenWhenSomeoneIsSharing?
        /// Indicates whether [in-meeting file transfer](https://support.zoom.us/hc/en-us/articles/209605493-In-meeting-file-transfer) setting has been enabled on the account or not.
        public var isFileTransfer: Bool?
        /// Indicates whether the [**Request permission to unmute participants**](https://support.zoom.us/hc/en-us/articles/203435537-Muting-and-unmuting-participants-in-a-meeting#h_01EGK4XFWS1SJGZ71MYGKF7260) option has been enabled for the account or not.
        public var isRequestPermissionToUnmute: Bool?
        public var webinarLiveStreaming: WebinarLiveStreaming?
        public var webinarChat: WebinarChat?
        /// Information about the account's closed captioning settings.
        public var closedCaptioning: ClosedCaptioning?
        /// Whether the person sharing during a presentation can allow others to control the slide presentation. This feature is only available in version 5.8.3 or higher.
        public var isSlideControl: Bool?
        /// Whether to allow the host to present a survey to participants once a meeting has ended. This feature is only available in version 5.7.3 or higher.
        public var isMeetingSurvey: Bool?
        /// Information about the account's webinar polling settings.
        public var webinarPolling: WebinarPolling?
        /// Whether to allow the host to present surveys to attendees once a webinar has ended.
        public var isWebinarSurvey: Bool?

        /// Play sound when participants join or leave.<br>`host` - Heard by host only.<br>`all` - Heard by host and all attendees.<br>`none` - Disable.
        public enum EntryExitChime: String, Codable, CaseIterable {
            case host
            case all
            case `none`
        }

        /// Settings to manage virtual background.
        public struct VirtualBackgroundSettings: Codable {
            /// Enable virtual background.
            public var enable: Bool?
            /// Allow use of videos for virtual backgrounds.
            public var allowVideos: Bool?
            /// Allow users to upload custom backgrounds.
            public var allowUploadCustom: Bool?
            public var files: [File]?

            public struct File: Codable {
                /// Unique identifier of the file.
                public var id: String?
                /// File name.
                public var name: String?
                /// File type.
                public var type: String?
                /// Indicates whether or not this file is the default virtual background file.
                public var isDefault: Bool?
                /// File size.
                public var size: String?

                public init(id: String? = nil, name: String? = nil, type: String? = nil, isDefault: Bool? = nil, size: String? = nil) {
                    self.id = id
                    self.name = name
                    self.type = type
                    self.isDefault = isDefault
                    self.size = size
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case name
                    case type
                    case isDefault = "is_default"
                    case size
                }
            }

            public init(enable: Bool? = nil, allowVideos: Bool? = nil, allowUploadCustom: Bool? = nil, files: [File]? = nil) {
                self.enable = enable
                self.allowVideos = allowVideos
                self.allowUploadCustom = allowUploadCustom
                self.files = files
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case allowVideos = "allow_videos"
                case allowUploadCustom = "allow_upload_custom"
                case files
            }
        }

        /// Indicates who can share their screen or content during meetings. The value can be one of the following: <br>
        /// `host`: Only host can share the screen.<br>
        /// `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
        public enum WhoCanShareScreen: String, Codable, CaseIterable {
            case host
            case all
        }

        /// Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:<br>
        /// `host`: Only a host can share the screen when someone else is sharing.<br>
        /// `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
        public enum WhoCanShareScreenWhenSomeoneIsSharing: String, Codable, CaseIterable {
            case host
            case all
        }

        public struct WebinarLiveStreaming: Codable {
            /// Whether webinar livestreaming is enabled.
            public var enable: Bool?
            /// The available livestreaming services:
            /// * `facebook`
            /// * `workplace_by_facebook`
            /// * `youtube`
            /// * `custom_live_streaming_service`
            public var liveStreamingService: [LiveStreamingServiceItem]?
            /// The specific instructions to allow your account's meeting hosts to configure a custom livestream.
            public var customServiceInstructions: String?
            /// Whether to notify users to watch the livestream. This does not apply to custom RTMP (real-time messaging protocol).
            public var isLiveStreamingReminder: Bool?

            public enum LiveStreamingServiceItem: String, Codable, CaseIterable {
                case facebook
                case workplaceByFacebook = "workplace_by_facebook"
                case youtube
                case customLiveStreamingService = "custom_live_streaming_service"
            }

            public init(enable: Bool? = nil, liveStreamingService: [LiveStreamingServiceItem]? = nil, customServiceInstructions: String? = nil, isLiveStreamingReminder: Bool? = nil) {
                self.enable = enable
                self.liveStreamingService = liveStreamingService
                self.customServiceInstructions = customServiceInstructions
                self.isLiveStreamingReminder = isLiveStreamingReminder
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case liveStreamingService = "live_streaming_service"
                case customServiceInstructions = "custom_service_instructions"
                case isLiveStreamingReminder = "live_streaming_reminder"
            }
        }

        public struct WebinarChat: Codable {
            /// Whether to allow webinar participants to send chat messages.
            public var enable: Bool?
            /// Allow webinar panelists to chat with:
            /// * `1` — Host and all panelists.
            /// * `2` — Everyone.
            public var allowPanelistsChatWith: Int?
            /// Allow webinar attendees to chat with:
            /// * `1` — No one.
            /// * `2` — Host and all panelists.
            /// * `3` — Everyone.
            public var allowAttendeesChatWith: Int?
            /// By default, allow webinar attendees to chat with:
            /// * `1` — Host and all panelists.
            /// * `2` — Everyone.
            public var defaultAttendeesChatWith: Int?
            /// Whether to allow webinar panelists to send direct messages to other panelists.
            public var allowPanelistsSendDirectMessage: Bool?
            /// Whether to allow webinar attendees to save chats:
            /// * `0` — Attendees cannot save chats.
            /// * `1` — Attendees can only save host and panelist chats.
            /// * `2` — Attendees can save all chats.
            public var allowUsersSaveChats: Int?
            /// Whether to automatically save chat messages to a local file on the host's computer when the webinar ends.
            public var allowAutoSaveLocalChatFile: Bool?

            public init(enable: Bool? = nil, allowPanelistsChatWith: Int? = nil, allowAttendeesChatWith: Int? = nil, defaultAttendeesChatWith: Int? = nil, allowPanelistsSendDirectMessage: Bool? = nil, allowUsersSaveChats: Int? = nil, allowAutoSaveLocalChatFile: Bool? = nil) {
                self.enable = enable
                self.allowPanelistsChatWith = allowPanelistsChatWith
                self.allowAttendeesChatWith = allowAttendeesChatWith
                self.defaultAttendeesChatWith = defaultAttendeesChatWith
                self.allowPanelistsSendDirectMessage = allowPanelistsSendDirectMessage
                self.allowUsersSaveChats = allowUsersSaveChats
                self.allowAutoSaveLocalChatFile = allowAutoSaveLocalChatFile
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case allowPanelistsChatWith = "allow_panelists_chat_with"
                case allowAttendeesChatWith = "allow_attendees_chat_with"
                case defaultAttendeesChatWith = "default_attendees_chat_with"
                case allowPanelistsSendDirectMessage = "allow_panelists_send_direct_message"
                case allowUsersSaveChats = "allow_users_save_chats"
                case allowAutoSaveLocalChatFile = "allow_auto_save_local_chat_file"
            }
        }

        /// Information about the account's closed captioning settings.
        public struct ClosedCaptioning: Codable {
            /// Whether to allow the host to type closed captions or assign a participant or 3rd-party service to provide closed captioning.
            public var enable: Bool?
            /// Whether to allow the use of an API token to integrate with 3rd-party closed captioning services.
            public var isThirdPartyCaptioningService: Bool?
            /// Whether to allow a live transcription service to transcribe meetings.
            public var isAutoTranscribing: Bool?
            /// Whether to allow the viewing of full transcripts in the in-meeting side panel.
            public var isViewFullTranscript: Bool?
            /// Whether to allow participants to save closed captions or transcripts.
            public var isSaveCaption: Bool?

            public init(enable: Bool? = nil, isThirdPartyCaptioningService: Bool? = nil, isAutoTranscribing: Bool? = nil, isViewFullTranscript: Bool? = nil, isSaveCaption: Bool? = nil) {
                self.enable = enable
                self.isThirdPartyCaptioningService = isThirdPartyCaptioningService
                self.isAutoTranscribing = isAutoTranscribing
                self.isViewFullTranscript = isViewFullTranscript
                self.isSaveCaption = isSaveCaption
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case isThirdPartyCaptioningService = "third_party_captioning_service"
                case isAutoTranscribing = "auto_transcribing"
                case isViewFullTranscript = "view_full_transcript"
                case isSaveCaption = "save_caption"
            }
        }

        /// Information about the account's webinar polling settings.
        public struct WebinarPolling: Codable {
            /// Whether to allow the host to add polls before or during a webinar.
            public var enable: Bool?
            /// Whether to allow host to create advanced polls and quizzes. Advanced polls and quizzes include single choice, multiple choice, drop down, matching, short answer, long answer, rank order, and fill-in-the-blank questions. Hosts can also set the correct answers for quizzes they create.
            public var isAdvancedPolls: Bool?

            public init(enable: Bool? = nil, isAdvancedPolls: Bool? = nil) {
                self.enable = enable
                self.isAdvancedPolls = isAdvancedPolls
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case isAdvancedPolls = "advanced_polls"
            }
        }

        public init(isE2eEncryption: Bool? = nil, isChat: Bool? = nil, allowParticipantsChatWith: Int? = nil, allowUsersSaveChats: Int? = nil, isPrivateChat: Bool? = nil, isAutoSavingChat: Bool? = nil, entryExitChime: EntryExitChime? = nil, isRecordPlayOwnVoice: Bool? = nil, isFeedback: Bool? = nil, isPostMeetingFeedback: Bool? = nil, isCoHost: Bool? = nil, isPolling: Bool? = nil, isAttendeeOnHold: Bool? = nil, isShowMeetingControlToolbar: Bool? = nil, allowShowZoomWindows: Bool? = nil, isAnnotation: Bool? = nil, isWhiteboard: Bool? = nil, isWebinarQuestionAnswer: Bool? = nil, isAnonymousQuestionAnswer: Bool? = nil, isBreakoutRoom: Bool? = nil, isBreakoutRoomSchedule: Bool? = nil, isClosedCaption: Bool? = nil, isFarEndCameraControl: Bool? = nil, isGroupHd: Bool? = nil, isVirtualBackground: Bool? = nil, virtualBackgroundSettings: VirtualBackgroundSettings? = nil, isWatermark: Bool? = nil, isAlertGuestJoin: Bool? = nil, isAutoAnswer: Bool? = nil, isP2pConnetion: Bool? = nil, isP2pPorts: Bool? = nil, portsRange: String? = nil, isSendingDefaultEmailInvites: Bool? = nil, useHTMLFormatEmail: Bool? = nil, isDscpMarking: Bool? = nil, dscpAudio: Int? = nil, dscpVideo: Int? = nil, isStereoAudio: Bool? = nil, isOriginalAudio: Bool? = nil, isScreenSharing: Bool? = nil, isRemoteControl: Bool? = nil, allowLiveStreaming: Bool? = nil, isLiveStreamingFacebook: Bool? = nil, isWorkplaceByFacebook: Bool? = nil, isLiveStreamingYoutube: Bool? = nil, isCustomLiveStreamingService: Bool? = nil, customServiceInstructions: String? = nil, isCustomDataCenterRegions: Bool? = nil, dataCenterRegions: [String]? = nil, isMeetingReactions: Bool? = nil, isShowAJoinFromYourBrowserLink: Bool? = nil, isJoinFromMobile: Bool? = nil, isJoinFromDesktop: Bool? = nil, allowParticipantsToRename: Bool? = nil, whoCanShareScreen: WhoCanShareScreen? = nil, whoCanShareScreenWhenSomeoneIsSharing: WhoCanShareScreenWhenSomeoneIsSharing? = nil, isFileTransfer: Bool? = nil, isRequestPermissionToUnmute: Bool? = nil, webinarLiveStreaming: WebinarLiveStreaming? = nil, webinarChat: WebinarChat? = nil, closedCaptioning: ClosedCaptioning? = nil, isSlideControl: Bool? = nil, isMeetingSurvey: Bool? = nil, webinarPolling: WebinarPolling? = nil, isWebinarSurvey: Bool? = nil) {
            self.isE2eEncryption = isE2eEncryption
            self.isChat = isChat
            self.allowParticipantsChatWith = allowParticipantsChatWith
            self.allowUsersSaveChats = allowUsersSaveChats
            self.isPrivateChat = isPrivateChat
            self.isAutoSavingChat = isAutoSavingChat
            self.entryExitChime = entryExitChime
            self.isRecordPlayOwnVoice = isRecordPlayOwnVoice
            self.isFeedback = isFeedback
            self.isPostMeetingFeedback = isPostMeetingFeedback
            self.isCoHost = isCoHost
            self.isPolling = isPolling
            self.isAttendeeOnHold = isAttendeeOnHold ?? false
            self.isShowMeetingControlToolbar = isShowMeetingControlToolbar
            self.allowShowZoomWindows = allowShowZoomWindows
            self.isAnnotation = isAnnotation
            self.isWhiteboard = isWhiteboard
            self.isWebinarQuestionAnswer = isWebinarQuestionAnswer
            self.isAnonymousQuestionAnswer = isAnonymousQuestionAnswer
            self.isBreakoutRoom = isBreakoutRoom
            self.isBreakoutRoomSchedule = isBreakoutRoomSchedule
            self.isClosedCaption = isClosedCaption
            self.isFarEndCameraControl = isFarEndCameraControl
            self.isGroupHd = isGroupHd
            self.isVirtualBackground = isVirtualBackground
            self.virtualBackgroundSettings = virtualBackgroundSettings
            self.isWatermark = isWatermark
            self.isAlertGuestJoin = isAlertGuestJoin
            self.isAutoAnswer = isAutoAnswer
            self.isP2pConnetion = isP2pConnetion
            self.isP2pPorts = isP2pPorts
            self.portsRange = portsRange
            self.isSendingDefaultEmailInvites = isSendingDefaultEmailInvites
            self.useHTMLFormatEmail = useHTMLFormatEmail
            self.isDscpMarking = isDscpMarking
            self.dscpAudio = dscpAudio
            self.dscpVideo = dscpVideo
            self.isStereoAudio = isStereoAudio
            self.isOriginalAudio = isOriginalAudio
            self.isScreenSharing = isScreenSharing
            self.isRemoteControl = isRemoteControl
            self.allowLiveStreaming = allowLiveStreaming
            self.isLiveStreamingFacebook = isLiveStreamingFacebook
            self.isWorkplaceByFacebook = isWorkplaceByFacebook
            self.isLiveStreamingYoutube = isLiveStreamingYoutube
            self.isCustomLiveStreamingService = isCustomLiveStreamingService
            self.customServiceInstructions = customServiceInstructions
            self.isCustomDataCenterRegions = isCustomDataCenterRegions
            self.dataCenterRegions = dataCenterRegions
            self.isMeetingReactions = isMeetingReactions
            self.isShowAJoinFromYourBrowserLink = isShowAJoinFromYourBrowserLink
            self.isJoinFromMobile = isJoinFromMobile
            self.isJoinFromDesktop = isJoinFromDesktop
            self.allowParticipantsToRename = allowParticipantsToRename
            self.whoCanShareScreen = whoCanShareScreen
            self.whoCanShareScreenWhenSomeoneIsSharing = whoCanShareScreenWhenSomeoneIsSharing
            self.isFileTransfer = isFileTransfer
            self.isRequestPermissionToUnmute = isRequestPermissionToUnmute
            self.webinarLiveStreaming = webinarLiveStreaming
            self.webinarChat = webinarChat
            self.closedCaptioning = closedCaptioning
            self.isSlideControl = isSlideControl
            self.isMeetingSurvey = isMeetingSurvey
            self.webinarPolling = webinarPolling
            self.isWebinarSurvey = isWebinarSurvey
        }

        private enum CodingKeys: String, CodingKey {
            case isE2eEncryption = "e2e_encryption"
            case isChat = "chat"
            case allowParticipantsChatWith = "allow_participants_chat_with"
            case allowUsersSaveChats = "allow_users_save_chats"
            case isPrivateChat = "private_chat"
            case isAutoSavingChat = "auto_saving_chat"
            case entryExitChime = "entry_exit_chime"
            case isRecordPlayOwnVoice = "record_play_own_voice"
            case isFeedback = "feedback"
            case isPostMeetingFeedback = "post_meeting_feedback"
            case isCoHost = "co_host"
            case isPolling = "polling"
            case isAttendeeOnHold = "attendee_on_hold"
            case isShowMeetingControlToolbar = "show_meeting_control_toolbar"
            case allowShowZoomWindows = "allow_show_zoom_windows"
            case isAnnotation = "annotation"
            case isWhiteboard = "whiteboard"
            case isWebinarQuestionAnswer = "webinar_question_answer"
            case isAnonymousQuestionAnswer = "anonymous_question_answer"
            case isBreakoutRoom = "breakout_room"
            case isBreakoutRoomSchedule = "breakout_room_schedule"
            case isClosedCaption = "closed_caption"
            case isFarEndCameraControl = "far_end_camera_control"
            case isGroupHd = "group_hd"
            case isVirtualBackground = "virtual_background"
            case virtualBackgroundSettings = "virtual_background_settings"
            case isWatermark = "watermark"
            case isAlertGuestJoin = "alert_guest_join"
            case isAutoAnswer = "auto_answer"
            case isP2pConnetion = "p2p_connetion"
            case isP2pPorts = "p2p_ports"
            case portsRange = "ports_range"
            case isSendingDefaultEmailInvites = "sending_default_email_invites"
            case useHTMLFormatEmail = "use_html_format_email"
            case isDscpMarking = "dscp_marking"
            case dscpAudio = "dscp_audio"
            case dscpVideo = "dscp_video"
            case isStereoAudio = "stereo_audio"
            case isOriginalAudio = "original_audio"
            case isScreenSharing = "screen_sharing"
            case isRemoteControl = "remote_control"
            case allowLiveStreaming = "allow_live_streaming"
            case isLiveStreamingFacebook = "live_streaming_facebook"
            case isWorkplaceByFacebook = "workplace_by_facebook"
            case isLiveStreamingYoutube = "live_streaming_youtube"
            case isCustomLiveStreamingService = "custom_live_streaming_service"
            case customServiceInstructions = "custom_service_instructions"
            case isCustomDataCenterRegions = "custom_data_center_regions"
            case dataCenterRegions = "data_center_regions"
            case isMeetingReactions = "meeting_reactions"
            case isShowAJoinFromYourBrowserLink = "show_a_join_from_your_browser_link"
            case isJoinFromMobile = "join_from_mobile"
            case isJoinFromDesktop = "join_from_desktop"
            case allowParticipantsToRename = "allow_participants_to_rename"
            case whoCanShareScreen = "who_can_share_screen"
            case whoCanShareScreenWhenSomeoneIsSharing = "who_can_share_screen_when_someone_is_sharing"
            case isFileTransfer = "file_transfer"
            case isRequestPermissionToUnmute = "request_permission_to_unmute"
            case webinarLiveStreaming = "webinar_live_streaming"
            case webinarChat = "webinar_chat"
            case closedCaptioning = "closed_captioning"
            case isSlideControl = "slide_control"
            case isMeetingSurvey = "meeting_survey"
            case webinarPolling = "webinar_polling"
            case isWebinarSurvey = "webinar_survey"
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.isE2eEncryption = try values.decodeIfPresent(Bool.self, forKey: .isE2eEncryption)
            self.isChat = try values.decodeIfPresent(Bool.self, forKey: .isChat)
            self.allowParticipantsChatWith = try values.decodeIfPresent(Int.self, forKey: .allowParticipantsChatWith)
            self.allowUsersSaveChats = try values.decodeIfPresent(Int.self, forKey: .allowUsersSaveChats)
            self.isPrivateChat = try values.decodeIfPresent(Bool.self, forKey: .isPrivateChat)
            self.isAutoSavingChat = try values.decodeIfPresent(Bool.self, forKey: .isAutoSavingChat)
            self.entryExitChime = try values.decodeIfPresent(EntryExitChime.self, forKey: .entryExitChime)
            self.isRecordPlayOwnVoice = try values.decodeIfPresent(Bool.self, forKey: .isRecordPlayOwnVoice)
            self.isFeedback = try values.decodeIfPresent(Bool.self, forKey: .isFeedback)
            self.isPostMeetingFeedback = try values.decodeIfPresent(Bool.self, forKey: .isPostMeetingFeedback)
            self.isCoHost = try values.decodeIfPresent(Bool.self, forKey: .isCoHost)
            self.isPolling = try values.decodeIfPresent(Bool.self, forKey: .isPolling)
            self.isAttendeeOnHold = try values.decodeIfPresent(Bool.self, forKey: .isAttendeeOnHold) ?? false
            self.isShowMeetingControlToolbar = try values.decodeIfPresent(Bool.self, forKey: .isShowMeetingControlToolbar)
            self.allowShowZoomWindows = try values.decodeIfPresent(Bool.self, forKey: .allowShowZoomWindows)
            self.isAnnotation = try values.decodeIfPresent(Bool.self, forKey: .isAnnotation)
            self.isWhiteboard = try values.decodeIfPresent(Bool.self, forKey: .isWhiteboard)
            self.isWebinarQuestionAnswer = try values.decodeIfPresent(Bool.self, forKey: .isWebinarQuestionAnswer)
            self.isAnonymousQuestionAnswer = try values.decodeIfPresent(Bool.self, forKey: .isAnonymousQuestionAnswer)
            self.isBreakoutRoom = try values.decodeIfPresent(Bool.self, forKey: .isBreakoutRoom)
            self.isBreakoutRoomSchedule = try values.decodeIfPresent(Bool.self, forKey: .isBreakoutRoomSchedule)
            self.isClosedCaption = try values.decodeIfPresent(Bool.self, forKey: .isClosedCaption)
            self.isFarEndCameraControl = try values.decodeIfPresent(Bool.self, forKey: .isFarEndCameraControl)
            self.isGroupHd = try values.decodeIfPresent(Bool.self, forKey: .isGroupHd)
            self.isVirtualBackground = try values.decodeIfPresent(Bool.self, forKey: .isVirtualBackground)
            self.virtualBackgroundSettings = try values.decodeIfPresent(VirtualBackgroundSettings.self, forKey: .virtualBackgroundSettings)
            self.isWatermark = try values.decodeIfPresent(Bool.self, forKey: .isWatermark)
            self.isAlertGuestJoin = try values.decodeIfPresent(Bool.self, forKey: .isAlertGuestJoin)
            self.isAutoAnswer = try values.decodeIfPresent(Bool.self, forKey: .isAutoAnswer)
            self.isP2pConnetion = try values.decodeIfPresent(Bool.self, forKey: .isP2pConnetion)
            self.isP2pPorts = try values.decodeIfPresent(Bool.self, forKey: .isP2pPorts)
            self.portsRange = try values.decodeIfPresent(String.self, forKey: .portsRange)
            self.isSendingDefaultEmailInvites = try values.decodeIfPresent(Bool.self, forKey: .isSendingDefaultEmailInvites)
            self.useHTMLFormatEmail = try values.decodeIfPresent(Bool.self, forKey: .useHTMLFormatEmail)
            self.isDscpMarking = try values.decodeIfPresent(Bool.self, forKey: .isDscpMarking)
            self.dscpAudio = try values.decodeIfPresent(Int.self, forKey: .dscpAudio)
            self.dscpVideo = try values.decodeIfPresent(Int.self, forKey: .dscpVideo)
            self.isStereoAudio = try values.decodeIfPresent(Bool.self, forKey: .isStereoAudio)
            self.isOriginalAudio = try values.decodeIfPresent(Bool.self, forKey: .isOriginalAudio)
            self.isScreenSharing = try values.decodeIfPresent(Bool.self, forKey: .isScreenSharing)
            self.isRemoteControl = try values.decodeIfPresent(Bool.self, forKey: .isRemoteControl)
            self.allowLiveStreaming = try values.decodeIfPresent(Bool.self, forKey: .allowLiveStreaming)
            self.isLiveStreamingFacebook = try values.decodeIfPresent(Bool.self, forKey: .isLiveStreamingFacebook)
            self.isWorkplaceByFacebook = try values.decodeIfPresent(Bool.self, forKey: .isWorkplaceByFacebook)
            self.isLiveStreamingYoutube = try values.decodeIfPresent(Bool.self, forKey: .isLiveStreamingYoutube)
            self.isCustomLiveStreamingService = try values.decodeIfPresent(Bool.self, forKey: .isCustomLiveStreamingService)
            self.customServiceInstructions = try values.decodeIfPresent(String.self, forKey: .customServiceInstructions)
            self.isCustomDataCenterRegions = try values.decodeIfPresent(Bool.self, forKey: .isCustomDataCenterRegions)
            self.dataCenterRegions = try values.decodeIfPresent([String].self, forKey: .dataCenterRegions)
            self.isMeetingReactions = try values.decodeIfPresent(Bool.self, forKey: .isMeetingReactions)
            self.isShowAJoinFromYourBrowserLink = try values.decodeIfPresent(Bool.self, forKey: .isShowAJoinFromYourBrowserLink)
            self.isJoinFromMobile = try values.decodeIfPresent(Bool.self, forKey: .isJoinFromMobile)
            self.isJoinFromDesktop = try values.decodeIfPresent(Bool.self, forKey: .isJoinFromDesktop)
            self.allowParticipantsToRename = try values.decodeIfPresent(Bool.self, forKey: .allowParticipantsToRename)
            self.whoCanShareScreen = try values.decodeIfPresent(WhoCanShareScreen.self, forKey: .whoCanShareScreen)
            self.whoCanShareScreenWhenSomeoneIsSharing = try values.decodeIfPresent(WhoCanShareScreenWhenSomeoneIsSharing.self, forKey: .whoCanShareScreenWhenSomeoneIsSharing)
            self.isFileTransfer = try values.decodeIfPresent(Bool.self, forKey: .isFileTransfer)
            self.isRequestPermissionToUnmute = try values.decodeIfPresent(Bool.self, forKey: .isRequestPermissionToUnmute)
            self.webinarLiveStreaming = try values.decodeIfPresent(WebinarLiveStreaming.self, forKey: .webinarLiveStreaming)
            self.webinarChat = try values.decodeIfPresent(WebinarChat.self, forKey: .webinarChat)
            self.closedCaptioning = try values.decodeIfPresent(ClosedCaptioning.self, forKey: .closedCaptioning)
            self.isSlideControl = try values.decodeIfPresent(Bool.self, forKey: .isSlideControl)
            self.isMeetingSurvey = try values.decodeIfPresent(Bool.self, forKey: .isMeetingSurvey)
            self.webinarPolling = try values.decodeIfPresent(WebinarPolling.self, forKey: .webinarPolling)
            self.isWebinarSurvey = try values.decodeIfPresent(Bool.self, forKey: .isWebinarSurvey)
        }
    }

    /// Account Settings: Notification.
    public struct EmailNotification: Codable {
        /// Whether to notify the host when a cloud recording is available.
        public var isCloudRecordingAvailableReminder: Bool?
        /// Whether to notify the person who scheduled the meeting or webinar for the host when a cloud recording is available.
        public var isRecordingAvailableReminderSchedulers: Bool?
        /// Whether to notify any alternative hosts when a cloud recording is available.
        public var isRecordingAvailableReminderAlternativeHosts: Bool?
        /// Notify the host when participants join the meeting before them.
        public var isJbhReminder: Bool?
        /// Notify the host and participants when a meeting is cancelled.
        public var isCancelMeetingReminder: Bool?
        /// Notify user when host licenses are running low.
        public var isLowHostCountReminder: Bool?
        /// Notify when an alternative host is set or removed from a meeting.
        public var isAlternativeHostReminder: Bool?
        /// Notify the host there is a meeting is scheduled, rescheduled, or cancelled.
        public var isScheduleForReminder: Bool?

        public init(isCloudRecordingAvailableReminder: Bool? = nil, isRecordingAvailableReminderSchedulers: Bool? = nil, isRecordingAvailableReminderAlternativeHosts: Bool? = nil, isJbhReminder: Bool? = nil, isCancelMeetingReminder: Bool? = nil, isLowHostCountReminder: Bool? = nil, isAlternativeHostReminder: Bool? = nil, isScheduleForReminder: Bool? = nil) {
            self.isCloudRecordingAvailableReminder = isCloudRecordingAvailableReminder
            self.isRecordingAvailableReminderSchedulers = isRecordingAvailableReminderSchedulers
            self.isRecordingAvailableReminderAlternativeHosts = isRecordingAvailableReminderAlternativeHosts
            self.isJbhReminder = isJbhReminder
            self.isCancelMeetingReminder = isCancelMeetingReminder
            self.isLowHostCountReminder = isLowHostCountReminder
            self.isAlternativeHostReminder = isAlternativeHostReminder
            self.isScheduleForReminder = isScheduleForReminder
        }

        private enum CodingKeys: String, CodingKey {
            case isCloudRecordingAvailableReminder = "cloud_recording_available_reminder"
            case isRecordingAvailableReminderSchedulers = "recording_available_reminder_schedulers"
            case isRecordingAvailableReminderAlternativeHosts = "recording_available_reminder_alternative_hosts"
            case isJbhReminder = "jbh_reminder"
            case isCancelMeetingReminder = "cancel_meeting_reminder"
            case isLowHostCountReminder = "low_host_count_reminder"
            case isAlternativeHostReminder = "alternative_host_reminder"
            case isScheduleForReminder = "schedule_for_reminder"
        }
    }

    /// Account Settings: Zoom Rooms.
    public struct ZoomRooms: Codable {
        /// Upcoming meeting alert.
        public var isUpcomingMeetingAlert: Bool?
        /// Start AirPlay service manually.
        public var isStartAirplayManually: Bool?
        /// Weekly system restart.
        public var isWeeklySystemRestart: Bool?
        /// Display meeting list with calendar integration.
        public var isListMeetingsWithCalendar: Bool?
        /// Zoom Room post meeting feedback.
        public var isZrPostMeetingFeedback: Bool?
        /// Automatic direct sharing using an ultrasonic proximity signal.
        public var isUltrasonic: Bool?
        /// Shift all meetings to private.
        public var isForcePrivateMeeting: Bool?
        /// Hide host and meeting ID from private meetings.
        public var isHideHostInformation: Bool?
        /// Cloud recording for instant meetings.
        public var isCmrForInstantMeeting: Bool?
        /// Automatic start and stop for scheduled meetings.
        public var isAutoStartStopScheduledMeetings: Bool?

        public init(isUpcomingMeetingAlert: Bool? = nil, isStartAirplayManually: Bool? = nil, isWeeklySystemRestart: Bool? = nil, isListMeetingsWithCalendar: Bool? = nil, isZrPostMeetingFeedback: Bool? = nil, isUltrasonic: Bool? = nil, isForcePrivateMeeting: Bool? = nil, isHideHostInformation: Bool? = nil, isCmrForInstantMeeting: Bool? = nil, isAutoStartStopScheduledMeetings: Bool? = nil) {
            self.isUpcomingMeetingAlert = isUpcomingMeetingAlert
            self.isStartAirplayManually = isStartAirplayManually
            self.isWeeklySystemRestart = isWeeklySystemRestart
            self.isListMeetingsWithCalendar = isListMeetingsWithCalendar
            self.isZrPostMeetingFeedback = isZrPostMeetingFeedback
            self.isUltrasonic = isUltrasonic
            self.isForcePrivateMeeting = isForcePrivateMeeting
            self.isHideHostInformation = isHideHostInformation
            self.isCmrForInstantMeeting = isCmrForInstantMeeting
            self.isAutoStartStopScheduledMeetings = isAutoStartStopScheduledMeetings
        }

        private enum CodingKeys: String, CodingKey {
            case isUpcomingMeetingAlert = "upcoming_meeting_alert"
            case isStartAirplayManually = "start_airplay_manually"
            case isWeeklySystemRestart = "weekly_system_restart"
            case isListMeetingsWithCalendar = "list_meetings_with_calendar"
            case isZrPostMeetingFeedback = "zr_post_meeting_feedback"
            case isUltrasonic = "ultrasonic"
            case isForcePrivateMeeting = "force_private_meeting"
            case isHideHostInformation = "hide_host_information"
            case isCmrForInstantMeeting = "cmr_for_instant_meeting"
            case isAutoStartStopScheduledMeetings = "auto_start_stop_scheduled_meetings"
        }
    }

    /// [Security settings](https://support.zoom.us/hc/en-us/articles/360034675592-Advanced-security-settings#h_bf8a25f6-9a66-447a-befd-f02ed3404f89) of an Account.
    public struct Security: Codable {
        /// Only account administrators can change a user's username and picture.
        public var isAdminChangeNamePic: Bool?
        /// Allow users to import photos from a photo library on a  device.
        public var isImportPhotosFromDevices: Bool?
        /// Hide billing information.
        public var isHideBillingInfo: Bool?
        /// This object refers to the [enhanced password rules](https://support.zoom.us/hc/en-us/articles/360034675592-Advanced-security-settings#h_bf8a25f6-9a66-447a-befd-f02ed3404f89) that allows Zoom account admins and owners to apply extra requiremets to the users' Zoom login password.
        public var passwordRequirement: PasswordRequirement?
        /// Settings for 2FA( [two factor authentication](https://support.zoom.us/hc/en-us/articles/360038247071) ). The value can be one of the following:
        /// `all`: Two factor authentication will be enabled for all users in the account.<br>
        /// `none`: Two factor authentication is disabled.<br>
        /// `group`: Two factor authentication will be enabled for users belonging to specific groups. If 2FA is enabled for certain groups, the group IDs of the group(s) will be provided in the `sign_in_with_two_factor_auth_groups` field.<br>
        /// `role`: Two factor authentication will be enabled only for users assigned with specific roles in the account. If 2FA is enabled for specific roles, the role IDs will be provided in the
        /// `sign_in_with_two_factor_auth_roles` field.
        public var signInWithTwoFactorAuth: SignInWithTwoFactorAuth?
        /// Settings for User Sign In interval requirements after a period of inactivity. If enabled, this setting forces automatic logout of users in Zoom Client app after a set amount of time. <br>
        /// 
        /// If this setting is disabled, the value of this field will be `0`. If the setting is enabled, the value of this field will indicate the **period of inactivity** in minutes after which, an inactive user will be automatically logged out of the Zoom Client. The value for the period of inactivity can be one of the following:<br>
        /// 
        /// `5`: 5 minutes<br>
        /// `10`: 10 minutes<br>
        /// `15`: 15 minutes<br>
        /// `30`: 30 minutes<br>
        /// `45`: 45 minutes<br>
        /// `60`: 60 minutes<br>
        /// `90`: 90 minutes<br>
        /// `120`: 120 minutes
        public var signAgainPeriodForInactivityOnClient: Int?
        /// Settings for User Sign In interval requirements after a period of inactivity. If enabled, this setting forces automatic logout of users in Zoom Web Portal after a set amount of time. <br>
        /// 
        /// If this setting is disabled, the value of this field will be `0`. If the setting is enabled, the value of this field will indicate the **period of inactivity** in minutes after which, an inactive user will be automatically logged out of the Zoom Web Portal. The value for the period of inactivity can be one of the following:<br>
        /// 
        /// `5`: 5 minutes<br>
        /// `10`: 10 minutes<br>
        /// `15`: 15 minutes<br>
        /// `30`: 30 minutes<br>
        /// `60`: 60 minutes<br>
        /// `120`: 120 minutes
        public var signAgainPeriodForInactivityOnWeb: Int?
        /// This field contains group IDs of groups that have 2FA enabled. This field is only returned if the value of `sign_in_with_two_factor_auth` is `group`
        public var signInWithTwoFactorAuthGroups: [String]?
        /// This field contains role IDs of roles that have 2FA enabled. This field is only returned if the value of `sign_in_with_two_factor_auth` is `role`.
        public var signInWithTwoFactorAuthRoles: [String]?

        /// This object refers to the [enhanced password rules](https://support.zoom.us/hc/en-us/articles/360034675592-Advanced-security-settings#h_bf8a25f6-9a66-447a-befd-f02ed3404f89) that allows Zoom account admins and owners to apply extra requiremets to the users' Zoom login password.
        public struct PasswordRequirement: Codable {
            /// Specify a minimum length for the password. The password length can be from a minimum of 9 characters, up to 14 characters. If you provide `0` as the value of this field, this field will be disabled and not be used and the basic password length requirement (minimum of 8 characters) will be applied for the requirement.
            public var minimumPasswordLength: Int?
            /// If the value of this field is set to `true`, the password must have at least one special character(!, @, #...).
            public var haveSpecialCharacter: Bool?
            /// Specify the max length of consecutive characters(abcde...) that can be used in a password.
            /// If you set the value of this field to `0`, no restriction will be applied on consecutive characters. 
            /// 
            /// If you would like to set this restriction, you can specify a number between 4 and 8 that define the maximum allowed length for consecutive characters in a password.
            /// 
            /// The max allowed length will be `n-1` where `n` refers to the value you provide for this field.  For instance, if you provide `4` as the value, there can only be a maximum of `3` consecutive characters in a password(example: abc1x@8fdh).
            public var consecutiveCharactersLength: Int?
            /// If the value of this field is set to `true`, user passwords will have to pass detection through a weak password dictionary in case hackers use simple passwords to sign in to your users’ accounts.
            public var isWeakEnhanceDetection: Bool?

            public init(minimumPasswordLength: Int? = nil, haveSpecialCharacter: Bool? = nil, consecutiveCharactersLength: Int? = nil, isWeakEnhanceDetection: Bool? = nil) {
                self.minimumPasswordLength = minimumPasswordLength
                self.haveSpecialCharacter = haveSpecialCharacter
                self.consecutiveCharactersLength = consecutiveCharactersLength
                self.isWeakEnhanceDetection = isWeakEnhanceDetection
            }

            private enum CodingKeys: String, CodingKey {
                case minimumPasswordLength = "minimum_password_length"
                case haveSpecialCharacter = "have_special_character"
                case consecutiveCharactersLength = "consecutive_characters_length"
                case isWeakEnhanceDetection = "weak_enhance_detection"
            }
        }

        /// Settings for 2FA( [two factor authentication](https://support.zoom.us/hc/en-us/articles/360038247071) ). The value can be one of the following:
        /// `all`: Two factor authentication will be enabled for all users in the account.<br>
        /// `none`: Two factor authentication is disabled.<br>
        /// `group`: Two factor authentication will be enabled for users belonging to specific groups. If 2FA is enabled for certain groups, the group IDs of the group(s) will be provided in the `sign_in_with_two_factor_auth_groups` field.<br>
        /// `role`: Two factor authentication will be enabled only for users assigned with specific roles in the account. If 2FA is enabled for specific roles, the role IDs will be provided in the
        /// `sign_in_with_two_factor_auth_roles` field.
        public enum SignInWithTwoFactorAuth: String, Codable, CaseIterable {
            case all
            case group
            case role
            case `none`
        }

        public init(isAdminChangeNamePic: Bool? = nil, isImportPhotosFromDevices: Bool? = nil, isHideBillingInfo: Bool? = nil, passwordRequirement: PasswordRequirement? = nil, signInWithTwoFactorAuth: SignInWithTwoFactorAuth? = nil, signAgainPeriodForInactivityOnClient: Int? = nil, signAgainPeriodForInactivityOnWeb: Int? = nil, signInWithTwoFactorAuthGroups: [String]? = nil, signInWithTwoFactorAuthRoles: [String]? = nil) {
            self.isAdminChangeNamePic = isAdminChangeNamePic
            self.isImportPhotosFromDevices = isImportPhotosFromDevices
            self.isHideBillingInfo = isHideBillingInfo
            self.passwordRequirement = passwordRequirement
            self.signInWithTwoFactorAuth = signInWithTwoFactorAuth
            self.signAgainPeriodForInactivityOnClient = signAgainPeriodForInactivityOnClient
            self.signAgainPeriodForInactivityOnWeb = signAgainPeriodForInactivityOnWeb
            self.signInWithTwoFactorAuthGroups = signInWithTwoFactorAuthGroups
            self.signInWithTwoFactorAuthRoles = signInWithTwoFactorAuthRoles
        }

        private enum CodingKeys: String, CodingKey {
            case isAdminChangeNamePic = "admin_change_name_pic"
            case isImportPhotosFromDevices = "import_photos_from_devices"
            case isHideBillingInfo = "hide_billing_info"
            case passwordRequirement = "password_requirement"
            case signInWithTwoFactorAuth = "sign_in_with_two_factor_auth"
            case signAgainPeriodForInactivityOnClient = "sign_again_period_for_inactivity_on_client"
            case signAgainPeriodForInactivityOnWeb = "sign_again_period_for_inactivity_on_web"
            case signInWithTwoFactorAuthGroups = "sign_in_with_two_factor_auth_groups"
            case signInWithTwoFactorAuthRoles = "sign_in_with_two_factor_auth_roles"
        }
    }

    /// Account Settings: Recording.
    public struct Recording: Codable {
        /// Allow hosts and participants to record the meeting using a local file.
        public var isLocalRecording: Bool?
        /// Allow hosts to record and save the meeting in the cloud.
        public var isCloudRecording: Bool?
        /// Record the active speaker with a shared screen.
        public var isRecordSpeakerView: Bool?
        /// Record the gallery view with a shared screen.
        public var isRecordGalleryView: Bool?
        /// Whether to record one audio file for all participants.
        public var isRecordAudioFile: Bool?
        /// Save the chat text from the meeting.
        public var isSaveChatText: Bool?
        /// Add a timestamp to the recording.
        public var isShowTimestamp: Bool?
        /// Automatically transcribe the audio of the meeting or webinar to the cloud.
        public var isRecordingAudioTranscript: Bool?
        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public var autoRecording: AutoRecording?
        /// Cloud recording downloads.
        public var isCloudRecordingDownload: Bool?
        /// Only the host can download cloud recordings.
        public var isCloudRecordingDownloadHost: Bool?
        /// Cloud recordings are only accessible to account members. People outside of your organization cannot open links that provide access to cloud recordings.
        public var isAccountUserAccessRecording: Bool?
        /// Allow Zoom to permanantly delete recordings automatically after a specified number of days.
        public var autoDeleteCmr: Bool?
        /// When the `auto_delete_cmr` value is `true`, this value is the number of days before the auto-deletion of cloud recordings: 
        /// * `30` — 30 days. 
        /// * `60` — 60 days. 
        /// * `90` — 90 days. 
        /// * `120` — 120 days.
        public var autoDeleteCmrDays: Int?
        /// This object represents the minimum password requirements set for recordings via Account Recording Settings.
        public var recordingPasswordRequirement: RecordingPasswordRequirement?
        /// Allow recovery of deleted cloud recordings from trash. 
        /// If the value of this field is set to `true`, deleted cloud recordings will be kept in trash for 30 days after deletion and can be recovered within that period.
        public var allowRecoveryDeletedCloudRecordings: Bool?
        /// Show a disclaimer to participants before a recording starts
        public var isRecordingDisclaimer: Bool?
        /// If the value of this field is set to `true`, hosts will be able to delete the recordings. If this option is set to `false`, the recordings cannot be deleted by the host and only admin can delete them.
        public var hostDeleteCloudRecording: Bool?
        /// Require a passcode to access existing cloud recordings.
        public var isRequiredPasswordForExistingCloudRecordings: Bool?
        /// If set to `true`, meeting hosts cannot view their meeting cloud recordings. Only the admins who have recording management privilege can access them.
        public var isPreventHostAccessRecording: Bool?
        /// Setting to allow cloud recording access only from specific IP address ranges.
        public var ipAddressAccessControl: IpAddressAccessControl?
        /// [Archiving solution](https://support.zoom.us/hc/en-us/articles/360050431572-Archiving-Meeting-and-Webinar-data) settings. This setting can only be used if you have been granted with archiving solution access by the Zoom support team.
        public var archive: Archive?

        /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
        public enum AutoRecording: String, Codable, CaseIterable {
            case local
            case cloud
            case `none`
        }

        /// This object represents the minimum password requirements set for recordings via Account Recording Settings.
        public struct RecordingPasswordRequirement: Codable {
            /// Minimum required length for the password.
            public var length: Int?
            /// Indicates whether or not password must contain at least one alphabetical letter (a, b, c..).
            public var haveLetter: Bool?
            /// Indicates whether or not password must contain at least one number(1, 2, 3..).
            public var haveNumber: Bool?
            /// Indicates whether or not password must contain at least one special character(!, @, #..).
            public var haveSpecialCharacter: Bool?
            /// Indicates whether or not password must contain only numeric characters.
            public var onlyAllowNumeric: Bool?

            public init(length: Int? = nil, haveLetter: Bool? = nil, haveNumber: Bool? = nil, haveSpecialCharacter: Bool? = nil, onlyAllowNumeric: Bool? = nil) {
                self.length = length
                self.haveLetter = haveLetter
                self.haveNumber = haveNumber
                self.haveSpecialCharacter = haveSpecialCharacter
                self.onlyAllowNumeric = onlyAllowNumeric
            }

            private enum CodingKeys: String, CodingKey {
                case length
                case haveLetter = "have_letter"
                case haveNumber = "have_number"
                case haveSpecialCharacter = "have_special_character"
                case onlyAllowNumeric = "only_allow_numeric"
            }
        }

        /// Setting to allow cloud recording access only from specific IP address ranges.
        public struct IpAddressAccessControl: Codable {
            /// If set to `true`, the cloud recordings of this account can only be accessed by the IP addresses defined in the `ip_addresses_or_ranges` property.
            public var enable: Bool?
            /// IP addresses or ranges that have access to the cloud recordings. Separate multiple IP ranges with comma. Use n.n.n.n, n.n.n.n/n or n.n.n.n - n.n.n.n syntax where n is a number.
            /// 
            /// Example: `46.33.24.184, 48.99.100.2/25` or `200.181.108.17 - 220.181.108.157`
            public var ipAddressesOrRanges: String?

            public init(enable: Bool? = nil, ipAddressesOrRanges: String? = nil) {
                self.enable = enable
                self.ipAddressesOrRanges = ipAddressesOrRanges
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case ipAddressesOrRanges = "ip_addresses_or_ranges"
            }
        }

        /// [Archiving solution](https://support.zoom.us/hc/en-us/articles/360050431572-Archiving-Meeting-and-Webinar-data) settings. This setting can only be used if you have been granted with archiving solution access by the Zoom support team.
        public struct Archive: Codable {
            /// Enable the archiving feature.
            public var enable: Bool?
            /// Archive types:
            /// 
            /// * `1`: Only meetings are archived.<br>
            /// * `2`: Only webinars are archived.<br>
            /// * `3`: Both meetings and webinars are archived.
            public var type: Int?
            public var settings: Settings?

            public struct Settings: Codable {
                /// Include in-meeting chat in the archive.
                public var isChatFile: Bool?
                /// Include user email in in-meeting chat file.
                public var isChatWithSenderEmail: Bool?
                /// Include in-meeting and/or in-webinar audio in the archive.
                public var isAudioFile: Bool?
                /// Include in-meeting and/or in-webinar video in the archive.
                public var isVideoFile: Bool?
                /// Include closed caption or transcript in the archive.
                public var isCcTranscriptFile: Bool?

                public init(isChatFile: Bool? = nil, isChatWithSenderEmail: Bool? = nil, isAudioFile: Bool? = nil, isVideoFile: Bool? = nil, isCcTranscriptFile: Bool? = nil) {
                    self.isChatFile = isChatFile
                    self.isChatWithSenderEmail = isChatWithSenderEmail
                    self.isAudioFile = isAudioFile
                    self.isVideoFile = isVideoFile
                    self.isCcTranscriptFile = isCcTranscriptFile
                }

                private enum CodingKeys: String, CodingKey {
                    case isChatFile = "chat_file"
                    case isChatWithSenderEmail = "chat_with_sender_email"
                    case isAudioFile = "audio_file"
                    case isVideoFile = "video_file"
                    case isCcTranscriptFile = "cc_transcript_file"
                }
            }

            public init(enable: Bool? = nil, type: Int? = nil, settings: Settings? = nil) {
                self.enable = enable
                self.type = type
                self.settings = settings
            }
        }

        public init(isLocalRecording: Bool? = nil, isCloudRecording: Bool? = nil, isRecordSpeakerView: Bool? = nil, isRecordGalleryView: Bool? = nil, isRecordAudioFile: Bool? = nil, isSaveChatText: Bool? = nil, isShowTimestamp: Bool? = nil, isRecordingAudioTranscript: Bool? = nil, autoRecording: AutoRecording? = nil, isCloudRecordingDownload: Bool? = nil, isCloudRecordingDownloadHost: Bool? = nil, isAccountUserAccessRecording: Bool? = nil, autoDeleteCmr: Bool? = nil, autoDeleteCmrDays: Int? = nil, recordingPasswordRequirement: RecordingPasswordRequirement? = nil, allowRecoveryDeletedCloudRecordings: Bool? = nil, isRecordingDisclaimer: Bool? = nil, hostDeleteCloudRecording: Bool? = nil, isRequiredPasswordForExistingCloudRecordings: Bool? = nil, isPreventHostAccessRecording: Bool? = nil, ipAddressAccessControl: IpAddressAccessControl? = nil, archive: Archive? = nil) {
            self.isLocalRecording = isLocalRecording
            self.isCloudRecording = isCloudRecording
            self.isRecordSpeakerView = isRecordSpeakerView
            self.isRecordGalleryView = isRecordGalleryView
            self.isRecordAudioFile = isRecordAudioFile
            self.isSaveChatText = isSaveChatText
            self.isShowTimestamp = isShowTimestamp
            self.isRecordingAudioTranscript = isRecordingAudioTranscript
            self.autoRecording = autoRecording
            self.isCloudRecordingDownload = isCloudRecordingDownload
            self.isCloudRecordingDownloadHost = isCloudRecordingDownloadHost
            self.isAccountUserAccessRecording = isAccountUserAccessRecording
            self.autoDeleteCmr = autoDeleteCmr
            self.autoDeleteCmrDays = autoDeleteCmrDays
            self.recordingPasswordRequirement = recordingPasswordRequirement
            self.allowRecoveryDeletedCloudRecordings = allowRecoveryDeletedCloudRecordings
            self.isRecordingDisclaimer = isRecordingDisclaimer
            self.hostDeleteCloudRecording = hostDeleteCloudRecording
            self.isRequiredPasswordForExistingCloudRecordings = isRequiredPasswordForExistingCloudRecordings
            self.isPreventHostAccessRecording = isPreventHostAccessRecording
            self.ipAddressAccessControl = ipAddressAccessControl
            self.archive = archive
        }

        private enum CodingKeys: String, CodingKey {
            case isLocalRecording = "local_recording"
            case isCloudRecording = "cloud_recording"
            case isRecordSpeakerView = "record_speaker_view"
            case isRecordGalleryView = "record_gallery_view"
            case isRecordAudioFile = "record_audio_file"
            case isSaveChatText = "save_chat_text"
            case isShowTimestamp = "show_timestamp"
            case isRecordingAudioTranscript = "recording_audio_transcript"
            case autoRecording = "auto_recording"
            case isCloudRecordingDownload = "cloud_recording_download"
            case isCloudRecordingDownloadHost = "cloud_recording_download_host"
            case isAccountUserAccessRecording = "account_user_access_recording"
            case autoDeleteCmr = "auto_delete_cmr"
            case autoDeleteCmrDays = "auto_delete_cmr_days"
            case recordingPasswordRequirement = "recording_password_requirement"
            case allowRecoveryDeletedCloudRecordings = "allow_recovery_deleted_cloud_recordings"
            case isRecordingDisclaimer = "recording_disclaimer"
            case hostDeleteCloudRecording = "host_delete_cloud_recording"
            case isRequiredPasswordForExistingCloudRecordings = "required_password_for_existing_cloud_recordings"
            case isPreventHostAccessRecording = "prevent_host_access_recording"
            case ipAddressAccessControl = "ip_address_access_control"
            case archive
        }
    }

    /// Account Settings: Telephony.
    public struct Telephony: Codable {
        /// Users can join the meeting using the existing third party audio configuration.
        public var isThirdPartyAudio: Bool?
        /// Third party audio conference info.
        public var audioConferenceInfo: String?
        /// Indicates where most of the participants call into or call from duriing a meeting.
        public var telephonyRegions: TelephonyRegions?

        /// Indicates where most of the participants call into or call from duriing a meeting.
        public struct TelephonyRegions: Codable {
            /// Telephony region options provided by Zoom to select from.
            public var allowedValues: [String]?
            /// The account's selected telephony regions that indicate where most participants call in to or call from during a meeting.
            public var selectionValues: String?

            public init(allowedValues: [String]? = nil, selectionValues: String? = nil) {
                self.allowedValues = allowedValues
                self.selectionValues = selectionValues
            }

            private enum CodingKeys: String, CodingKey {
                case allowedValues = "allowed_values"
                case selectionValues = "selection_values"
            }
        }

        public init(isThirdPartyAudio: Bool? = nil, audioConferenceInfo: String? = nil, telephonyRegions: TelephonyRegions? = nil) {
            self.isThirdPartyAudio = isThirdPartyAudio
            self.audioConferenceInfo = audioConferenceInfo
            self.telephonyRegions = telephonyRegions
        }

        private enum CodingKeys: String, CodingKey {
            case isThirdPartyAudio = "third_party_audio"
            case audioConferenceInfo = "audio_conference_info"
            case telephonyRegions = "telephony_regions"
        }
    }

    /// Account Settings: Integration.
    public struct Integration: Codable {
        /// Enable meetings to be scheduled using Google Calendar.
        public var isGoogleCalendar: Bool?
        /// Enable users who join a meeting from their mobile device to share content from their Google Drive.
        public var isGoogleDrive: Bool?
        /// Enable users who join a meeting from their mobile device to share content from their Dropbox account.
        public var isDropbox: Bool?
        /// Enable users who join a meeting from their mobile device to share content from their Box account.
        public var isBox: Bool?
        /// Enable users who join a meeting from their mobile device to share content from their Microsoft OneDrive account.
        public var isMicrosoftOneDrive: Bool?
        /// Enable users to control a connected Kubi device from within a Zoom meeting.
        public var isKubi: Bool?

        public init(isGoogleCalendar: Bool? = nil, isGoogleDrive: Bool? = nil, isDropbox: Bool? = nil, isBox: Bool? = nil, isMicrosoftOneDrive: Bool? = nil, isKubi: Bool? = nil) {
            self.isGoogleCalendar = isGoogleCalendar
            self.isGoogleDrive = isGoogleDrive
            self.isDropbox = isDropbox
            self.isBox = isBox
            self.isMicrosoftOneDrive = isMicrosoftOneDrive
            self.isKubi = isKubi
        }

        private enum CodingKeys: String, CodingKey {
            case isGoogleCalendar = "google_calendar"
            case isGoogleDrive = "google_drive"
            case isDropbox = "dropbox"
            case isBox = "box"
            case isMicrosoftOneDrive = "microsoft_one_drive"
            case isKubi = "kubi"
        }
    }

    /// Account Settings: Feature.
    public struct Feature: Codable {
        /// Set the maximum number of participants a host can have in a single meeting.
        public var meetingCapacity: Int?

        public init(meetingCapacity: Int? = nil) {
            self.meetingCapacity = meetingCapacity
        }

        private enum CodingKeys: String, CodingKey {
            case meetingCapacity = "meeting_capacity"
        }
    }

    /// Account Settings: TSP.
    public struct Tsp: Codable {
        /// Call Out
        public var isCallOut: Bool?
        /// Call Out Countries/Regions
        public var callOutCountries: [[String: AnyJSON]]?
        /// Show international numbers link on the invitation email
        public var isShowInternationalNumbersLink: Bool?
        /// Display toll-free numbers
        public var isDisplayTollFreeNumbers: Bool?

        public init(isCallOut: Bool? = nil, callOutCountries: [[String: AnyJSON]]? = nil, isShowInternationalNumbersLink: Bool? = nil, isDisplayTollFreeNumbers: Bool? = nil) {
            self.isCallOut = isCallOut
            self.callOutCountries = callOutCountries
            self.isShowInternationalNumbersLink = isShowInternationalNumbersLink
            self.isDisplayTollFreeNumbers = isDisplayTollFreeNumbers
        }

        private enum CodingKeys: String, CodingKey {
            case isCallOut = "call_out"
            case callOutCountries = "call_out_countries"
            case isShowInternationalNumbersLink = "show_international_numbers_link"
            case isDisplayTollFreeNumbers = "display_toll_free_numbers"
        }
    }

    public struct Profile: Codable {
        public var recordingStorageLocation: RecordingStorageLocation?

        public struct RecordingStorageLocation: Codable {
            /// Users can choose the country to store their recorded content. Content can include meeting, webinar, and phone recordings, as well as voicemail, transcripts, and custom greeting prompts. See [Managing the Communications Content storage location](https://support.zoom.us/hc/en-us/articles/360050781131) for details.
            /// 
            /// Provide abbreviated country codes as the value for this field. See the [Countries abbreviation list](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries) for details.
            public var allowedValues: [String]?
            /// Abbreviated country code.
            public var value: String?

            public init(allowedValues: [String]? = nil, value: String? = nil) {
                self.allowedValues = allowedValues
                self.value = value
            }

            private enum CodingKeys: String, CodingKey {
                case allowedValues = "allowed_values"
                case value
            }
        }

        public init(recordingStorageLocation: RecordingStorageLocation? = nil) {
            self.recordingStorageLocation = recordingStorageLocation
        }

        private enum CodingKeys: String, CodingKey {
            case recordingStorageLocation = "recording_storage_location"
        }
    }

    public struct OtherOptions: Codable {
        /// Whether administrators can activate users with a single default password when they add users. This immediately activates the users without waiting for them to set their own password.
        public var allowAutoActiveUsers: Bool?
        /// Whether iOS blurs the screenshot in the task switcher when multiple apps are open. Android hides the screenshot in the system-level list of recent apps.
        public var isBlurSnapshot: Bool?
        /// Whether a user with the [scheduling privilege](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-privilege) can view other users' meetings.
        public var isDisplayMeetingsScheduledForOthers: Bool?
        /// Allow connections to different CDNs (content delivery networks) for a better web browsing experience. All users in your organization will use the selected CDN to access static resources: 
        /// * `none` — Do not use a CDN. 
        /// * `default` — Use the Amazon CloudFront CDN for users **except** Chinese Mainland users. Chinese Mainland users will use the Wangsu CDN (China). 
        /// * `wangsu` — Use the Wangsu CDN for all users.
        public var useCdn: UseCdn?
        /// Whether to display the Zoom Help badge on the bottom-right of the page.
        public var allowUsersContactSupportViaChat: Bool?
        /// Whether meetings with only one person will display on the Dashboard and in reports.
        public var isShowOneUserMeetingOnDashboard: Bool?
        /// The Dashboard meeting [quality scores and network alerts](https://support.zoom.us/hc/en-us/articles/360061244651) setting: 
        /// * `0` — Do not enable meeting quality scores and network alerts on the Dashboard. 
        /// * `1` — Display the meeting quality score and network alerts on the Dashboard. 
        /// * `2` — Use custom thresholds for quality scores and network alerts.
        public var meetingQosAndMos: Int?
        /// Whether users can add pronouns to their profile cards and share them during meetings and webinars.
        public var allowUsersEnterAndSharePronouns: Bool?

        /// Allow connections to different CDNs (content delivery networks) for a better web browsing experience. All users in your organization will use the selected CDN to access static resources: 
        /// * `none` — Do not use a CDN. 
        /// * `default` — Use the Amazon CloudFront CDN for users **except** Chinese Mainland users. Chinese Mainland users will use the Wangsu CDN (China). 
        /// * `wangsu` — Use the Wangsu CDN for all users.
        public enum UseCdn: String, Codable, CaseIterable {
            case `none`
            case `default`
            case wangsu
        }

        public init(allowAutoActiveUsers: Bool? = nil, isBlurSnapshot: Bool? = nil, isDisplayMeetingsScheduledForOthers: Bool? = nil, useCdn: UseCdn? = nil, allowUsersContactSupportViaChat: Bool? = nil, isShowOneUserMeetingOnDashboard: Bool? = nil, meetingQosAndMos: Int? = nil, allowUsersEnterAndSharePronouns: Bool? = nil) {
            self.allowAutoActiveUsers = allowAutoActiveUsers
            self.isBlurSnapshot = isBlurSnapshot
            self.isDisplayMeetingsScheduledForOthers = isDisplayMeetingsScheduledForOthers
            self.useCdn = useCdn
            self.allowUsersContactSupportViaChat = allowUsersContactSupportViaChat
            self.isShowOneUserMeetingOnDashboard = isShowOneUserMeetingOnDashboard
            self.meetingQosAndMos = meetingQosAndMos
            self.allowUsersEnterAndSharePronouns = allowUsersEnterAndSharePronouns
        }

        private enum CodingKeys: String, CodingKey {
            case allowAutoActiveUsers = "allow_auto_active_users"
            case isBlurSnapshot = "blur_snapshot"
            case isDisplayMeetingsScheduledForOthers = "display_meetings_scheduled_for_others"
            case useCdn = "use_cdn"
            case allowUsersContactSupportViaChat = "allow_users_contact_support_via_chat"
            case isShowOneUserMeetingOnDashboard = "show_one_user_meeting_on_dashboard"
            case meetingQosAndMos = "meeting_qos_and_mos"
            case allowUsersEnterAndSharePronouns = "allow_users_enter_and_share_pronouns"
        }
    }

    /// The account's audio conference settings.
    public struct AudioConferencing: Codable {
        /// The account's [**Toll-free and Fee-based Toll Call**](https://support.zoom.us/hc/en-us/articles/360060950711-Enabling-Toll-free-and-Fee-based-Toll-Call#h_01F51680NJ7YHZDXGJNSKDGM2P) settings.
        public var tollFreeAndFeeBasedTollCall: TollFreeAndFeeBasedTollCall?

        /// The account's [**Toll-free and Fee-based Toll Call**](https://support.zoom.us/hc/en-us/articles/360060950711-Enabling-Toll-free-and-Fee-based-Toll-Call#h_01F51680NJ7YHZDXGJNSKDGM2P) settings.
        public struct TollFreeAndFeeBasedTollCall: Codable {
            /// Whether the account has the [**Toll-free and Fee-based Toll Call**](https://support.zoom.us/hc/en-us/articles/360060950711-Enabling-Toll-free-and-Fee-based-Toll-Call#h_01F51680NJ7YHZDXGJNSKDGM2P) setting enabled.
            public var enable: Bool?
            /// The account's **Toll-free and Fee-based Toll Call** phone number information.
            public var numbers: [Number]?
            /// Whether webinar attendees can dial in through the account's **Toll-free and Fee-based Toll Call** phone numbers. This feature is only available in version 5.2.2 and higher.
            public var allowWebinarAttendeesDial: Bool?

            public struct Number: Codable {
                /// The phone number's [E.164 country calling code](https://en.wikipedia.org/wiki/List_of_country_calling_codes).
                public var code: String?
                /// The phone number's [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
                public var countryCode: String?
                /// The country name.
                public var countryName: String?
                /// The phone number.
                public var number: String?
                /// The phone number's display number.
                public var displayNumber: String?

                public init(code: String? = nil, countryCode: String? = nil, countryName: String? = nil, number: String? = nil, displayNumber: String? = nil) {
                    self.code = code
                    self.countryCode = countryCode
                    self.countryName = countryName
                    self.number = number
                    self.displayNumber = displayNumber
                }

                private enum CodingKeys: String, CodingKey {
                    case code
                    case countryCode = "country_code"
                    case countryName = "country_name"
                    case number
                    case displayNumber = "display_number"
                }
            }

            public init(enable: Bool? = nil, numbers: [Number]? = nil, allowWebinarAttendeesDial: Bool? = nil) {
                self.enable = enable
                self.numbers = numbers
                self.allowWebinarAttendeesDial = allowWebinarAttendeesDial
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case numbers
                case allowWebinarAttendeesDial = "allow_webinar_attendees_dial"
            }
        }

        public init(tollFreeAndFeeBasedTollCall: TollFreeAndFeeBasedTollCall? = nil) {
            self.tollFreeAndFeeBasedTollCall = tollFreeAndFeeBasedTollCall
        }

        private enum CodingKeys: String, CodingKey {
            case tollFreeAndFeeBasedTollCall = "toll_free_and_fee_based_toll_call"
        }
    }

    public init(scheduleMeeting: ScheduleMeeting? = nil, inMeeting: InMeeting? = nil, emailNotification: EmailNotification? = nil, zoomRooms: ZoomRooms? = nil, security: Security? = nil, recording: Recording? = nil, telephony: Telephony? = nil, integration: Integration? = nil, feature: Feature? = nil, tsp: Tsp? = nil, profile: Profile? = nil, otherOptions: OtherOptions? = nil, audioConferencing: AudioConferencing? = nil) {
        self.scheduleMeeting = scheduleMeeting
        self.inMeeting = inMeeting
        self.emailNotification = emailNotification
        self.zoomRooms = zoomRooms
        self.security = security
        self.recording = recording
        self.telephony = telephony
        self.integration = integration
        self.feature = feature
        self.tsp = tsp
        self.profile = profile
        self.otherOptions = otherOptions
        self.audioConferencing = audioConferencing
    }

    private enum CodingKeys: String, CodingKey {
        case scheduleMeeting = "schedule_meeting"
        case inMeeting = "in_meeting"
        case emailNotification = "email_notification"
        case zoomRooms = "zoom_rooms"
        case security
        case recording
        case telephony
        case integration
        case feature
        case tsp
        case profile
        case otherOptions = "other_options"
        case audioConferencing = "audio_conferencing"
    }
}

/// Account Settings: Zoom Rooms.
public struct AccountSettingsZoomRooms: Codable {
    /// Upcoming meeting alert.
    public var isUpcomingMeetingAlert: Bool?
    /// Start AirPlay service manually.
    public var isStartAirplayManually: Bool?
    /// Weekly system restart.
    public var isWeeklySystemRestart: Bool?
    /// Display meeting list with calendar integration.
    public var isListMeetingsWithCalendar: Bool?
    /// Zoom Room post meeting feedback.
    public var isZrPostMeetingFeedback: Bool?
    /// Automatic direct sharing using an ultrasonic proximity signal.
    public var isUltrasonic: Bool?
    /// Shift all meetings to private.
    public var isForcePrivateMeeting: Bool?
    /// Hide host and meeting ID from private meetings.
    public var isHideHostInformation: Bool?
    /// Cloud recording for instant meetings.
    public var isCmrForInstantMeeting: Bool?
    /// Automatic start and stop for scheduled meetings.
    public var isAutoStartStopScheduledMeetings: Bool?

    public init(isUpcomingMeetingAlert: Bool? = nil, isStartAirplayManually: Bool? = nil, isWeeklySystemRestart: Bool? = nil, isListMeetingsWithCalendar: Bool? = nil, isZrPostMeetingFeedback: Bool? = nil, isUltrasonic: Bool? = nil, isForcePrivateMeeting: Bool? = nil, isHideHostInformation: Bool? = nil, isCmrForInstantMeeting: Bool? = nil, isAutoStartStopScheduledMeetings: Bool? = nil) {
        self.isUpcomingMeetingAlert = isUpcomingMeetingAlert
        self.isStartAirplayManually = isStartAirplayManually
        self.isWeeklySystemRestart = isWeeklySystemRestart
        self.isListMeetingsWithCalendar = isListMeetingsWithCalendar
        self.isZrPostMeetingFeedback = isZrPostMeetingFeedback
        self.isUltrasonic = isUltrasonic
        self.isForcePrivateMeeting = isForcePrivateMeeting
        self.isHideHostInformation = isHideHostInformation
        self.isCmrForInstantMeeting = isCmrForInstantMeeting
        self.isAutoStartStopScheduledMeetings = isAutoStartStopScheduledMeetings
    }

    private enum CodingKeys: String, CodingKey {
        case isUpcomingMeetingAlert = "upcoming_meeting_alert"
        case isStartAirplayManually = "start_airplay_manually"
        case isWeeklySystemRestart = "weekly_system_restart"
        case isListMeetingsWithCalendar = "list_meetings_with_calendar"
        case isZrPostMeetingFeedback = "zr_post_meeting_feedback"
        case isUltrasonic = "ultrasonic"
        case isForcePrivateMeeting = "force_private_meeting"
        case isHideHostInformation = "hide_host_information"
        case isCmrForInstantMeeting = "cmr_for_instant_meeting"
        case isAutoStartStopScheduledMeetings = "auto_start_stop_scheduled_meetings"
    }
}

/// Account Settings: Schedule Meeting.
public struct AccountSettingsScheduleMeeting: Codable {
    /// Start meetings with the host video on.
    public var isHostVideo: Bool?
    /// Start meetings with the participant video on. Participants can change this setting during the meeting.
    public var isParticipantVideo: Bool?
    /// Determine how participants can join the audio portion of the meeting.<br>`both` - Telephony and VoIP.<br>`telephony` - Audio PSTN telephony only.<br>`voip` - VoIP only.<br>`thirdParty` - 3rd party audio conference.
    public var audioType: AudioType?
    /// Allow participants to join the meeting before the host arrives.
    public var isJoinBeforeHost: Bool?
    /// If the value of "join_before_host" field is set to true, this field can be used to indicate time limits within which a participant may join a meeting before a host. The value of this field can be one of the following:
    /// 
    /// *  `0`: Allow participant to join anytime.
    /// *  `5`: Allow participant to join 5 minutes before meeting start time.
    ///  * `10`: Allow participant to join 10 minutes before meeting start time.
    public var jbhTime: Int?
    /// Only Zoom users who are signed in can join meetings.
    public var enforceLogin: Bool?
    /// Only signed in users with a specific domain can join meetings.
    public var enforceLoginWithDomains: Bool?
    /// Only signed in users with a specified domain can join the meeting.
    public var enforceLoginDomains: String?
    /// Always display "Zoom Meeting" as the meeting topic.
    public var isNotStoreMeetingTopic: Bool?
    /// Require a password for Personal Meetings if attendees can join before host.
    public var isForcePmiJbhPassword: Bool?
    /// Use Personal Meeting ID (PMI) when scheduling a meeting
    public var usePmiForScheduledMeetings: Bool?
    /// Use Personal Meeting ID (PMI) when starting an instant meeting
    public var usePmiForInstantMeetings: Bool?
    /// Require a password when scheduling new meetings. This setting applies for regular meetings that do not use PMI. If enabled, a password will be generated while a host schedules a new meeting and participants will be required to enter the password before they can join the meeting. This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
    public var requirePasswordForSchedulingNewMeetings: Bool?
    /// Require a password for meetings which have already been scheduled
    public var requirePasswordForScheduledMeetings: Bool?
    /// Require a password for instant meetings. If you use PMI for your instant meetings, this option will be disabled. This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
    public var requirePasswordForInstantMeetings: Bool?
    /// Require a password for a meeting held using Personal Meeting ID (PMI) This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
    public var requirePasswordForPmiMeetings: RequirePasswordForPmiMeetings?
    /// Account wide meeting/webinar [password requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
    public var meetingPasswordRequirement: MeetingPasswordRequirement?
    /// Personal Meeting Setting.<br><br>
    /// `true`: Indicates that the **"Enable Personal Meeting ID"** setting is turned on. Users can choose to use personal meeting ID for their meetings. <br><br>
    /// `false`: Indicates that the **"Enable Personal Meeting ID"** setting is [turned off](https://support.zoom.us/hc/en-us/articles/201362843-Personal-meeting-ID-PMI-and-personal-link#h_aa0335c8-3b06-41bc-bc1f-a8b84ef17f2a). If this setting is disabled, meetings that were scheduled with PMI will be invalid. Scheduled meetings will need to be manually updated.
    /// For Zoom Phone only:If a user has been assigned a desk phone, **"Elevate to Zoom Meeting"** on desk phone will be disabled.
    public var isPersonalMeeting: Bool?

    /// Determine how participants can join the audio portion of the meeting.<br>`both` - Telephony and VoIP.<br>`telephony` - Audio PSTN telephony only.<br>`voip` - VoIP only.<br>`thirdParty` - 3rd party audio conference.
    public enum AudioType: String, Codable, CaseIterable {
        case both
        case telephony
        case voip
        case thirdParty
    }

    /// Require a password for a meeting held using Personal Meeting ID (PMI) This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
    public enum RequirePasswordForPmiMeetings: String, Codable, CaseIterable {
        case jbhOnly = "jbh_only"
        case all
        case `none`
    }

    /// Account wide meeting/webinar [password requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
    public struct MeetingPasswordRequirement: Codable {
        /// The minimum length that the meeting/webinar password needs to have.
        public var length: Int?
        /// If set to `true`, the password must contain at least 1 letter (such as a,b,c...).
        public var haveLetter: Bool?
        /// If set to `true`, the password must contain at least 1 number (such as 1,2,3...).
        public var haveNumber: Bool?
        /// If set to `true`, the password must have at least 1 special character (!,@,#...).
        public var haveSpecialCharacter: Bool?
        /// If set to `true`, the password must only contain numbers and no other characters.
        public var onlyAllowNumeric: Bool?
        /// If set to `true`, the password must include both uppercase and lowercase characters.
        public var haveUpperAndLowerCharacters: Bool?
        public var consecutiveCharactersLength: Int?
        /// If set to `true`, users will be informed if the provided password is weak.
        public var isWeakEnhanceDetection: Bool?

        public init(length: Int? = nil, haveLetter: Bool? = nil, haveNumber: Bool? = nil, haveSpecialCharacter: Bool? = nil, onlyAllowNumeric: Bool? = nil, haveUpperAndLowerCharacters: Bool? = nil, consecutiveCharactersLength: Int? = nil, isWeakEnhanceDetection: Bool? = nil) {
            self.length = length
            self.haveLetter = haveLetter
            self.haveNumber = haveNumber
            self.haveSpecialCharacter = haveSpecialCharacter
            self.onlyAllowNumeric = onlyAllowNumeric
            self.haveUpperAndLowerCharacters = haveUpperAndLowerCharacters
            self.consecutiveCharactersLength = consecutiveCharactersLength
            self.isWeakEnhanceDetection = isWeakEnhanceDetection
        }

        private enum CodingKeys: String, CodingKey {
            case length
            case haveLetter = "have_letter"
            case haveNumber = "have_number"
            case haveSpecialCharacter = "have_special_character"
            case onlyAllowNumeric = "only_allow_numeric"
            case haveUpperAndLowerCharacters = "have_upper_and_lower_characters"
            case consecutiveCharactersLength = "consecutive_characters_length"
            case isWeakEnhanceDetection = "weak_enhance_detection"
        }
    }

    public init(isHostVideo: Bool? = nil, isParticipantVideo: Bool? = nil, audioType: AudioType? = nil, isJoinBeforeHost: Bool? = nil, jbhTime: Int? = nil, enforceLogin: Bool? = nil, enforceLoginWithDomains: Bool? = nil, enforceLoginDomains: String? = nil, isNotStoreMeetingTopic: Bool? = nil, isForcePmiJbhPassword: Bool? = nil, usePmiForScheduledMeetings: Bool? = nil, usePmiForInstantMeetings: Bool? = nil, requirePasswordForSchedulingNewMeetings: Bool? = nil, requirePasswordForScheduledMeetings: Bool? = nil, requirePasswordForInstantMeetings: Bool? = nil, requirePasswordForPmiMeetings: RequirePasswordForPmiMeetings? = nil, meetingPasswordRequirement: MeetingPasswordRequirement? = nil, isPersonalMeeting: Bool? = nil) {
        self.isHostVideo = isHostVideo
        self.isParticipantVideo = isParticipantVideo
        self.audioType = audioType
        self.isJoinBeforeHost = isJoinBeforeHost
        self.jbhTime = jbhTime
        self.enforceLogin = enforceLogin
        self.enforceLoginWithDomains = enforceLoginWithDomains
        self.enforceLoginDomains = enforceLoginDomains
        self.isNotStoreMeetingTopic = isNotStoreMeetingTopic
        self.isForcePmiJbhPassword = isForcePmiJbhPassword
        self.usePmiForScheduledMeetings = usePmiForScheduledMeetings
        self.usePmiForInstantMeetings = usePmiForInstantMeetings
        self.requirePasswordForSchedulingNewMeetings = requirePasswordForSchedulingNewMeetings
        self.requirePasswordForScheduledMeetings = requirePasswordForScheduledMeetings
        self.requirePasswordForInstantMeetings = requirePasswordForInstantMeetings
        self.requirePasswordForPmiMeetings = requirePasswordForPmiMeetings
        self.meetingPasswordRequirement = meetingPasswordRequirement
        self.isPersonalMeeting = isPersonalMeeting
    }

    private enum CodingKeys: String, CodingKey {
        case isHostVideo = "host_video"
        case isParticipantVideo = "participant_video"
        case audioType = "audio_type"
        case isJoinBeforeHost = "join_before_host"
        case jbhTime = "jbh_time"
        case enforceLogin = "enforce_login"
        case enforceLoginWithDomains = "enforce_login_with_domains"
        case enforceLoginDomains = "enforce_login_domains"
        case isNotStoreMeetingTopic = "not_store_meeting_topic"
        case isForcePmiJbhPassword = "force_pmi_jbh_password"
        case usePmiForScheduledMeetings = "use_pmi_for_scheduled_meetings"
        case usePmiForInstantMeetings = "use_pmi_for_instant_meetings"
        case requirePasswordForSchedulingNewMeetings = "require_password_for_scheduling_new_meetings"
        case requirePasswordForScheduledMeetings = "require_password_for_scheduled_meetings"
        case requirePasswordForInstantMeetings = "require_password_for_instant_meetings"
        case requirePasswordForPmiMeetings = "require_password_for_pmi_meetings"
        case meetingPasswordRequirement = "meeting_password_requirement"
        case isPersonalMeeting = "personal_meeting"
    }
}

/// Account Settings Update: Telephony.
public struct AccountSettingsUpdateTelephony: Codable {
    /// Users can join the meeting using the existing third party audio configuration.
    public var isThirdPartyAudio: Bool?
    /// Third party audio conference info.
    public var audioConferenceInfo: String?
    /// Indicates where most of the participants call into or call from duriing a meeting.
    public var telephonyRegions: TelephonyRegions?

    /// Indicates where most of the participants call into or call from duriing a meeting.
    public struct TelephonyRegions: Codable {
        /// The account's selected telephony regions that indicate where most participants call into or call from during a meeting.
        public var selectionValues: String?

        public init(selectionValues: String? = nil) {
            self.selectionValues = selectionValues
        }

        private enum CodingKeys: String, CodingKey {
            case selectionValues = "selection_values"
        }
    }

    public init(isThirdPartyAudio: Bool? = nil, audioConferenceInfo: String? = nil, telephonyRegions: TelephonyRegions? = nil) {
        self.isThirdPartyAudio = isThirdPartyAudio
        self.audioConferenceInfo = audioConferenceInfo
        self.telephonyRegions = telephonyRegions
    }

    private enum CodingKeys: String, CodingKey {
        case isThirdPartyAudio = "third_party_audio"
        case audioConferenceInfo = "audio_conference_info"
        case telephonyRegions = "telephony_regions"
    }
}

/// Account Settings: Feature.
public struct AccountSettingsFeature: Codable {
    /// Set the maximum number of participants a host can have in a single meeting.
    public var meetingCapacity: Int?

    public init(meetingCapacity: Int? = nil) {
        self.meetingCapacity = meetingCapacity
    }

    private enum CodingKeys: String, CodingKey {
        case meetingCapacity = "meeting_capacity"
    }
}

/// Account Settings: Notification.
public struct AccountSettingsEmailNotification: Codable {
    /// Whether to notify the host when a cloud recording is available.
    public var isCloudRecordingAvailableReminder: Bool?
    /// Whether to notify the person who scheduled the meeting or webinar for the host when a cloud recording is available.
    public var isRecordingAvailableReminderSchedulers: Bool?
    /// Whether to notify any alternative hosts when a cloud recording is available.
    public var isRecordingAvailableReminderAlternativeHosts: Bool?
    /// Notify the host when participants join the meeting before them.
    public var isJbhReminder: Bool?
    /// Notify the host and participants when a meeting is cancelled.
    public var isCancelMeetingReminder: Bool?
    /// Notify user when host licenses are running low.
    public var isLowHostCountReminder: Bool?
    /// Notify when an alternative host is set or removed from a meeting.
    public var isAlternativeHostReminder: Bool?
    /// Notify the host there is a meeting is scheduled, rescheduled, or cancelled.
    public var isScheduleForReminder: Bool?

    public init(isCloudRecordingAvailableReminder: Bool? = nil, isRecordingAvailableReminderSchedulers: Bool? = nil, isRecordingAvailableReminderAlternativeHosts: Bool? = nil, isJbhReminder: Bool? = nil, isCancelMeetingReminder: Bool? = nil, isLowHostCountReminder: Bool? = nil, isAlternativeHostReminder: Bool? = nil, isScheduleForReminder: Bool? = nil) {
        self.isCloudRecordingAvailableReminder = isCloudRecordingAvailableReminder
        self.isRecordingAvailableReminderSchedulers = isRecordingAvailableReminderSchedulers
        self.isRecordingAvailableReminderAlternativeHosts = isRecordingAvailableReminderAlternativeHosts
        self.isJbhReminder = isJbhReminder
        self.isCancelMeetingReminder = isCancelMeetingReminder
        self.isLowHostCountReminder = isLowHostCountReminder
        self.isAlternativeHostReminder = isAlternativeHostReminder
        self.isScheduleForReminder = isScheduleForReminder
    }

    private enum CodingKeys: String, CodingKey {
        case isCloudRecordingAvailableReminder = "cloud_recording_available_reminder"
        case isRecordingAvailableReminderSchedulers = "recording_available_reminder_schedulers"
        case isRecordingAvailableReminderAlternativeHosts = "recording_available_reminder_alternative_hosts"
        case isJbhReminder = "jbh_reminder"
        case isCancelMeetingReminder = "cancel_meeting_reminder"
        case isLowHostCountReminder = "low_host_count_reminder"
        case isAlternativeHostReminder = "alternative_host_reminder"
        case isScheduleForReminder = "schedule_for_reminder"
    }
}

/// Account Settings: TSP.
public struct AccountSettingsTSP: Codable {
    /// Call Out
    public var isCallOut: Bool?
    /// Call Out Countries/Regions
    public var callOutCountries: [[String: AnyJSON]]?
    /// Show international numbers link on the invitation email
    public var isShowInternationalNumbersLink: Bool?
    /// Display toll-free numbers
    public var isDisplayTollFreeNumbers: Bool?

    public init(isCallOut: Bool? = nil, callOutCountries: [[String: AnyJSON]]? = nil, isShowInternationalNumbersLink: Bool? = nil, isDisplayTollFreeNumbers: Bool? = nil) {
        self.isCallOut = isCallOut
        self.callOutCountries = callOutCountries
        self.isShowInternationalNumbersLink = isShowInternationalNumbersLink
        self.isDisplayTollFreeNumbers = isDisplayTollFreeNumbers
    }

    private enum CodingKeys: String, CodingKey {
        case isCallOut = "call_out"
        case callOutCountries = "call_out_countries"
        case isShowInternationalNumbersLink = "show_international_numbers_link"
        case isDisplayTollFreeNumbers = "display_toll_free_numbers"
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
