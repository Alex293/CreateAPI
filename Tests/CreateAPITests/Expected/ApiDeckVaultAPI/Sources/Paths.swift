// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var consumers: Consumers {
        Consumers(path: "/vault/consumers")
    }

    public struct Consumers {
        /// Path: `/vault/consumers`
        public let path: String

        /// Get all consumers
        ///
        /// This endpoint includes all application consumers, along with an aggregated count of requests made.
        public func get(cursor: String? = nil, limit: Int? = nil) -> Request<ApiDeckVaultAPI.GetConsumersResponse> {
            .get(path, query: makeGetQuery(cursor, limit))
        }

        private func makeGetQuery(_ cursor: String?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(cursor, forKey: "cursor")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.Consumers {
    public func consumerID(_ consumerID: String) -> WithConsumerID {
        WithConsumerID(path: "\(path)/\(consumerID)")
    }

    public struct WithConsumerID {
        /// Path: `/vault/consumers/{consumer_id}`
        public let path: String

        /// Get consumer
        ///
        /// Consumer detail including their aggregated counts with the connections they have authorized.
        public var get: Request<ApiDeckVaultAPI.GetConsumerResponse> {
            .get(path)
        }
    }
}

extension Paths.Consumers.WithConsumerID {
    public var stats: Stats {
        Stats(path: path + "/stats")
    }

    public struct Stats {
        /// Path: `/vault/consumers/{consumer_id}/stats`
        public let path: String

        /// Consumer request counts
        ///
        /// Get consumer request counts within a given datetime range.
        public func get(startDatetime: String, endDatetime: String) -> Request<ApiDeckVaultAPI.ConsumerRequestCountsInDateRangeResponse> {
            .get(path, query: [("start_datetime", startDatetime), ("end_datetime", endDatetime)])
        }
    }
}

extension Paths {
    public static var connections: Connections {
        Connections(path: "/vault/connections")
    }

    public struct Connections {
        /// Path: `/vault/connections`
        public let path: String

        /// Get all connections
        ///
        /// This endpoint includes all the configured integrations and contains the required assets
        /// to build an integrations page where your users can install integrations.
        /// OAuth2 supported integrations will contain authorize and revoke links to handle the authentication flows.
        public func get(api: String? = nil, isConfigured: Bool? = nil) -> Request<ApiDeckVaultAPI.GetConnectionsResponse> {
            .get(path, query: makeGetQuery(api, isConfigured))
        }

        private func makeGetQuery(_ api: String?, _ isConfigured: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(api, forKey: "api")
            encoder.encode(isConfigured, forKey: "configured")
            return encoder.items
        }
    }
}

extension Paths.Connections {
    public func unifiedAPI(_ unifiedAPI: String) -> WithUnifiedAPI {
        WithUnifiedAPI(path: "\(path)/\(unifiedAPI)")
    }

    public struct WithUnifiedAPI {
        /// Path: `/vault/connections/{unified_api}`
        public let path: String
    }
}

extension Paths.Connections.WithUnifiedAPI {
    public func serviceID(_ serviceID: String) -> WithServiceID {
        WithServiceID(path: "\(path)/\(serviceID)")
    }

    public struct WithServiceID {
        /// Path: `/vault/connections/{unified_api}/{service_id}`
        public let path: String

        /// Get connection
        ///
        /// Get a connection
        public var get: Request<ApiDeckVaultAPI.GetConnectionResponse> {
            .get(path)
        }

        /// Create connection
        ///
        /// Create an authorized connection
        public func post(_ body: ApiDeckVaultAPI.Connection) -> Request<ApiDeckVaultAPI.CreateConnectionResponse> {
            .post(path, body: body)
        }

        /// Update connection
        ///
        /// Update a connection
        public func patch(_ body: ApiDeckVaultAPI.Connection) -> Request<ApiDeckVaultAPI.UpdateConnectionResponse> {
            .patch(path, body: body)
        }

        /// Deletes a connection
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Connections.WithUnifiedAPI.WithServiceID {
    public func resource(_ resource: String) -> WithResource {
        WithResource(path: "\(path)/\(resource)")
    }

    public struct WithResource {
        /// Path: `/vault/connections/{unified_api}/{service_id}/{resource}`
        public let path: String
    }
}

extension Paths.Connections.WithUnifiedAPI.WithServiceID.WithResource {
    public var config: Config {
        Config(path: path + "/config")
    }

    public struct Config {
        /// Path: `/vault/connections/{unified_api}/{service_id}/{resource}/config`
        public let path: String

        /// Get resource settings
        ///
        /// This endpoint returns custom settings and their defaults required by connection for a given resource.
        public var get: Request<ApiDeckVaultAPI.GetConnectionResponse> {
            .get(path)
        }

        /// Update settings
        ///
        /// Update default values for a connection's resource settings
        public func patch(_ body: ApiDeckVaultAPI.Connection) -> Request<ApiDeckVaultAPI.UpdateConnectionResponse> {
            .patch(path, body: body)
        }
    }
}

extension Paths {
    public static var authorize: Authorize {
        Authorize(path: "/vault/authorize")
    }

    public struct Authorize {
        /// Path: `/vault/authorize`
        public let path: String
    }
}

extension Paths.Authorize {
    public func serviceID(_ serviceID: String) -> WithServiceID {
        WithServiceID(path: "\(path)/\(serviceID)")
    }

    public struct WithServiceID {
        /// Path: `/vault/authorize/{service_id}`
        public let path: String
    }
}

extension Paths.Authorize.WithServiceID {
    public func applicationID(_ applicationID: String) -> WithApplicationID {
        WithApplicationID(path: "\(path)/\(applicationID)")
    }

    public struct WithApplicationID {
        /// Path: `/vault/authorize/{service_id}/{application_id}`
        public let path: String

        /// Authorize
        ///
        /// __In most cases the authorize link is provided in the ``/connections`` endpoint. Normally you don't need to manually generate these links.__
        /// 
        /// Use this endpoint to authenticate a user with a connector. It will return a 302 redirect to the downstream connector endpoints.
        /// 
        /// Auth links will have a state parameter included to verify the validity of the request. This is the url your users will use to activate OAuth supported integration providers.
        /// 
        /// Vault handles the complete Authorization Code Grant Type Flow for you and will redirect you to the dynamic redirect uri you have appended to the url in case this is missing the default redirect uri you have configured for your Unify application.
        public func get(parameters: GetParameters) -> Request<Void> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var state: String
            public var redirectUri: String
            public var scope: [String]?

            public init(state: String, redirectUri: String, scope: [String]? = nil) {
                self.state = state
                self.redirectUri = redirectUri
                self.scope = scope
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(state, forKey: "state")
                encoder.encode(redirectUri, forKey: "redirect_uri")
                encoder.encode(scope, forKey: "scope", explode: false, delimiter: " ")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var revoke: Revoke {
        Revoke(path: "/vault/revoke")
    }

    public struct Revoke {
        /// Path: `/vault/revoke`
        public let path: String
    }
}

extension Paths.Revoke {
    public func serviceID(_ serviceID: String) -> WithServiceID {
        WithServiceID(path: "\(path)/\(serviceID)")
    }

    public struct WithServiceID {
        /// Path: `/vault/revoke/{service_id}`
        public let path: String
    }
}

extension Paths.Revoke.WithServiceID {
    public func applicationID(_ applicationID: String) -> WithApplicationID {
        WithApplicationID(path: "\(path)/\(applicationID)")
    }

    public struct WithApplicationID {
        /// Path: `/vault/revoke/{service_id}/{application_id}`
        public let path: String

        /// Revoke
        ///
        /// __In most cases the authorize link is provided in the ``/connections`` endpoint. Normally you don't need to manually generate these links.__
        /// 
        /// Use this endpoint to revoke an existing OAuth connector.
        /// 
        /// Auth links will have a state parameter included to verify the validity of the request. This is the url your users will use to activate OAuth supported integration providers.
        /// 
        /// Vault handles the complete revoke flow for you and will redirect you to the dynamic redirect uri you have appended to the url in case this is missing the default redirect uri you have configured for your Unify application.
        public func get(state: String, redirectUri: String) -> Request<Void> {
            .get(path, query: [("state", state), ("redirect_uri", redirectUri)])
        }
    }
}

extension Paths {
    public static var callback: Callback {
        Callback(path: "/vault/callback")
    }

    public struct Callback {
        /// Path: `/vault/callback`
        public let path: String

        /// Callback
        ///
        /// This endpoint gets called after the triggering the authorize flow.
        /// 
        /// Callback links need a state and code parameter to verify the validity of the request.
        public func get(state: String, code: String) -> Request<Void> {
            .get(path, query: [("state", state), ("code", code)])
        }
    }
}

extension Paths {
    public static var sessions: Sessions {
        Sessions(path: "/vault/sessions")
    }

    public struct Sessions {
        /// Path: `/vault/sessions`
        public let path: String

        /// Create Session
        ///
        /// Making a POST request to this endpoint will initiate a Hosted Vault session. Redirect the consumer to the returned
        /// url to allow temporary access to manage their integrations and settings.
        /// 
        /// Note: This is a short lived token that will expire after 1 hour (TTL: 3600).
        public func post(_ body: ApiDeckVaultAPI.Session? = nil) -> Request<ApiDeckVaultAPI.CreateSessionResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var proxy: Proxy {
        Proxy(path: "/vault/proxy")
    }

    public struct Proxy {
        /// Path: `/vault/proxy`
        public let path: String

        /// GET
        ///
        /// **Note**: This endpoint is deprecated in favor of the [Proxy API](https://docs.apideck.com/apis/proxy). Please use the new API as documented at https://docs.apideck.com/apis/proxy
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<AnyJSON> {
            .get(path)
        }

        /// POST
        ///
        /// **Note**: This endpoint is deprecated in favor of the [Proxy API](https://docs.apideck.com/apis/proxy). Please use the new API as documented at https://docs.apideck.com/apis/proxy
        @available(*, deprecated, message: "Deprecated")
        public func post(_ body: [String: AnyJSON]? = nil) -> Request<AnyJSON> {
            .post(path, body: body)
        }

        /// PUT
        ///
        /// **Note**: This endpoint is deprecated in favor of the [Proxy API](https://docs.apideck.com/apis/proxy). Please use the new API as documented at https://docs.apideck.com/apis/proxy
        @available(*, deprecated, message: "Deprecated")
        public func put(_ body: [String: AnyJSON]? = nil) -> Request<AnyJSON> {
            .put(path, body: body)
        }

        /// PATCH
        ///
        /// **Note**: This endpoint is deprecated in favor of the [Proxy API](https://docs.apideck.com/apis/proxy). Please use the new API as documented at https://docs.apideck.com/apis/proxy
        @available(*, deprecated, message: "Deprecated")
        public func patch(_ body: [String: AnyJSON]? = nil) -> Request<AnyJSON> {
            .patch(path, body: body)
        }

        /// DELETE
        ///
        /// **Note**: This endpoint is deprecated in favor of the [Proxy API](https://docs.apideck.com/apis/proxy). Please use the new API as documented at https://docs.apideck.com/apis/proxy
        @available(*, deprecated, message: "Deprecated")
        public var delete: Request<AnyJSON> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var logs: Logs {
        Logs(path: "/vault/logs")
    }

    public struct Logs {
        /// Path: `/vault/logs`
        public let path: String

        /// Get all consumer request logs
        ///
        /// This endpoint includes all consumer request logs.
        public func get(parameters: GetParameters? = nil) -> Request<ApiDeckVaultAPI.GetLogsResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var filter: Filter?
            public var cursor: String?
            public var limit: Int?

            public struct Filter: Codable {
                /// Example: "crm+salesforce"
                public var connectorID: String?
                /// Example: 201
                public var statusCode: Double?
                /// Example: "vault,proxy"
                public var excludeUnifiedAPIs: String?

                public init(connectorID: String? = nil, statusCode: Double? = nil, excludeUnifiedAPIs: String? = nil) {
                    self.connectorID = connectorID
                    self.statusCode = statusCode
                    self.excludeUnifiedAPIs = excludeUnifiedAPIs
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(connectorID, forKey: "connector_id")
                    encoder.encode(statusCode, forKey: "status_code")
                    encoder.encode(excludeUnifiedAPIs, forKey: "exclude_unified_apis")
                    return encoder.items
                }
            }

            public init(filter: Filter? = nil, cursor: String? = nil, limit: Int? = nil) {
                self.filter = filter
                self.cursor = cursor
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(filter, forKey: "filter", isDeepObject: true)
                encoder.encode(cursor, forKey: "cursor")
                encoder.encode(limit, forKey: "limit")
                return encoder.items
            }
        }
    }
}

public enum Paths {}
