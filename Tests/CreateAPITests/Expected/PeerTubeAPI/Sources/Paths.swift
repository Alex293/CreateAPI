// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension Paths.Accounts {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/accounts/{name}`
        public let path: String

        /// Get an account
        public var get: Request<PeerTubeAPI.Account> {
            .get(path)
        }
    }
}

extension Paths.Accounts.WithName {
    public var videos: Videos {
        Videos(path: path + "/videos")
    }

    public struct Videos {
        /// Path: `/accounts/{name}/videos`
        public let path: String

        /// List videos of an account
        public func get(parameters: GetParameters? = nil) -> Request<PeerTubeAPI.VideoListResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var categoryOneOf: CategoryOneOf?
            public var isLive: Bool?
            public var tagsOneOf: TagsOneOf?
            public var tagsAllOf: TagsAllOf?
            public var licenceOneOf: LicenceOneOf?
            public var languageOneOf: LanguageOneOf?
            public var nsfw: Nsfw?
            public var isLocal: Bool?
            public var include: Int?
            /// Privacy id of the video (see [/videos/privacies](#operation/getPrivacyPolicies))
            public var privacyOneOf: Int?
            public var hasHLSFiles: Bool?
            public var hasWebtorrentFiles: Bool?
            public var skipCount: SkipCount?
            public var start: Int?
            public var count: Int?
            public var sort: Sort?

            public enum CategoryOneOf: Codable {
                case int(Int)
                case ints([Int])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .int(let value): encoder.encode(value, forKey: "value")
                    case .ints(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum TagsOneOf: Codable {
                case string(String)
                case strings([String])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .string(let value): encoder.encode(value, forKey: "value")
                    case .strings(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum TagsAllOf: Codable {
                case string(String)
                case strings([String])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .string(let value): encoder.encode(value, forKey: "value")
                    case .strings(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum LicenceOneOf: Codable {
                case int(Int)
                case ints([Int])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .int(let value): encoder.encode(value, forKey: "value")
                    case .ints(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum LanguageOneOf: Codable {
                case string(String)
                case strings([String])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .string(let value): encoder.encode(value, forKey: "value")
                    case .strings(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum Nsfw: String, Codable, CaseIterable {
                case `true`
                case `false`
            }

            public enum SkipCount: String, Codable, CaseIterable {
                case `true`
                case `false`
            }

            public enum Sort: String, Codable, CaseIterable {
                case name
                case minusduration = "-duration"
                case minuscreatedAt = "-createdAt"
                case minuspublishedAt = "-publishedAt"
                case minusviews = "-views"
                case minuslikes = "-likes"
                case minustrending = "-trending"
                case minushot = "-hot"
            }

            public init(categoryOneOf: CategoryOneOf? = nil, isLive: Bool? = nil, tagsOneOf: TagsOneOf? = nil, tagsAllOf: TagsAllOf? = nil, licenceOneOf: LicenceOneOf? = nil, languageOneOf: LanguageOneOf? = nil, nsfw: Nsfw? = nil, isLocal: Bool? = nil, include: Int? = nil, privacyOneOf: Int? = nil, hasHLSFiles: Bool? = nil, hasWebtorrentFiles: Bool? = nil, skipCount: SkipCount? = nil, start: Int? = nil, count: Int? = nil, sort: Sort? = nil) {
                self.categoryOneOf = categoryOneOf
                self.isLive = isLive
                self.tagsOneOf = tagsOneOf
                self.tagsAllOf = tagsAllOf
                self.licenceOneOf = licenceOneOf
                self.languageOneOf = languageOneOf
                self.nsfw = nsfw
                self.isLocal = isLocal
                self.include = include
                self.privacyOneOf = privacyOneOf
                self.hasHLSFiles = hasHLSFiles
                self.hasWebtorrentFiles = hasWebtorrentFiles
                self.skipCount = skipCount
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(categoryOneOf, forKey: "categoryOneOf", explode: false)
                encoder.encode(isLive, forKey: "isLive")
                encoder.encode(tagsOneOf, forKey: "tagsOneOf", explode: false)
                encoder.encode(tagsAllOf, forKey: "tagsAllOf", explode: false)
                encoder.encode(licenceOneOf, forKey: "licenceOneOf", explode: false)
                encoder.encode(languageOneOf, forKey: "languageOneOf", explode: false)
                encoder.encode(nsfw, forKey: "nsfw")
                encoder.encode(isLocal, forKey: "isLocal")
                encoder.encode(include, forKey: "include")
                encoder.encode(privacyOneOf, forKey: "privacyOneOf")
                encoder.encode(hasHLSFiles, forKey: "hasHLSFiles")
                encoder.encode(hasWebtorrentFiles, forKey: "hasWebtorrentFiles")
                encoder.encode(skipCount, forKey: "skipCount")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }
    }
}

extension Paths.Accounts.WithName {
    public var followers: Followers {
        Followers(path: path + "/followers")
    }

    public struct Followers {
        /// Path: `/accounts/{name}/followers`
        public let path: String

        /// List followers of an account
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var total: Int?
            public var data: [PeerTubeAPI.Follow]?

            public init(total: Int? = nil, data: [PeerTubeAPI.Follow]? = nil) {
                self.total = total
                self.data = data
            }
        }

        public struct GetParameters {
            public var start: Int?
            public var count: Int?
            public var sort: Sort?
            public var search: String?

            public enum Sort: String, Codable, CaseIterable {
                case createdAt
            }

            public init(start: Int? = nil, count: Int? = nil, sort: Sort? = nil, search: String? = nil) {
                self.start = start
                self.count = count
                self.sort = sort
                self.search = search
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                encoder.encode(search, forKey: "search")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var accounts: Accounts {
        Accounts(path: "/accounts")
    }

    public struct Accounts {
        /// Path: `/accounts`
        public let path: String

        /// List accounts
        public func get(parameters: GetParameters? = nil) -> Request<[PeerTubeAPI.Account]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var start: Int?
            public var count: Int?
            /// Example: "-createdAt"
            public var sort: String?

            public init(start: Int? = nil, count: Int? = nil, sort: String? = nil) {
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var config: Config {
        Config(path: "/config")
    }

    public struct Config {
        /// Path: `/config`
        public let path: String

        /// Get instance public configuration
        public var get: Request<PeerTubeAPI.ServerConfig> {
            .get(path)
        }
    }
}

extension Paths.Config {
    public var about: About {
        About(path: path + "/about")
    }

    public struct About {
        /// Path: `/config/about`
        public let path: String

        /// Get instance "About" information
        public var get: Request<PeerTubeAPI.ServerConfigAbout> {
            .get(path)
        }
    }
}

extension Paths.Config {
    public var custom: Custom {
        Custom(path: path + "/custom")
    }

    public struct Custom {
        /// Path: `/config/custom`
        public let path: String

        /// Get instance runtime configuration
        public var get: Request<PeerTubeAPI.ServerConfigCustom> {
            .get(path)
        }

        /// Set instance runtime configuration
        public var put: Request<Void> {
            .put(path)
        }

        /// Delete instance runtime configuration
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var customPages: CustomPages {
        CustomPages(path: "/custom-pages")
    }

    public struct CustomPages {
        /// Path: `/custom-pages`
        public let path: String
    }
}

extension Paths.CustomPages {
    public var homepage: Homepage {
        Homepage(path: path + "/homepage")
    }

    public struct Homepage {
        /// Path: `/custom-pages/homepage`
        public let path: String
    }
}

extension Paths.CustomPages.Homepage {
    public var instance: Instance {
        Instance(path: path + "/instance")
    }

    public struct Instance {
        /// Path: `/custom-pages/homepage/instance`
        public let path: String

        /// Get instance custom homepage
        public var get: Request<PeerTubeAPI.CustomHomepage> {
            .get(path)
        }

        /// Set instance custom homepage
        public func put(content: String? = nil) -> Request<Void> {
            .put(path, body: ["content": content])
        }
    }
}

extension Paths {
    public static var jobs: Jobs {
        Jobs(path: "/jobs")
    }

    public struct Jobs {
        /// Path: `/jobs`
        public let path: String
    }
}

extension Paths.Jobs {
    public func state(_ state: String) -> WithState {
        WithState(path: "\(path)/\(state)")
    }

    public struct WithState {
        /// Path: `/jobs/{state}`
        public let path: String

        /// List instance jobs
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var total: Int?
            public var data: [PeerTubeAPI.Job]?

            public init(total: Int? = nil, data: [PeerTubeAPI.Job]? = nil) {
                self.total = total
                self.data = data
            }
        }

        public struct GetParameters {
            public var jobType: JobType?
            public var start: Int?
            public var count: Int?
            /// Example: "-createdAt"
            public var sort: String?

            public enum JobType: String, Codable, CaseIterable {
                case activitypubFollow = "activitypub-follow"
                case activitypubHTTPBroadcast = "activitypub-http-broadcast"
                case activitypubHTTPFetcher = "activitypub-http-fetcher"
                case activitypubHTTPUnicast = "activitypub-http-unicast"
                case email
                case videoTranscoding = "video-transcoding"
                case videoFileImport = "video-file-import"
                case videoImport = "video-import"
                case videosViewsStats = "videos-views-stats"
                case activitypubRefresher = "activitypub-refresher"
                case videoRedundancy = "video-redundancy"
                case videoLiveEnding = "video-live-ending"
            }

            public init(jobType: JobType? = nil, start: Int? = nil, count: Int? = nil, sort: String? = nil) {
                self.jobType = jobType
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(jobType, forKey: "jobType")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var server: Server {
        Server(path: "/server")
    }

    public struct Server {
        /// Path: `/server`
        public let path: String
    }
}

extension Paths.Server {
    public var followers: Followers {
        Followers(path: path + "/followers")
    }

    public struct Followers {
        /// Path: `/server/followers`
        public let path: String

        /// List instances following the server
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var total: Int?
            public var data: [PeerTubeAPI.Follow]?

            public init(total: Int? = nil, data: [PeerTubeAPI.Follow]? = nil) {
                self.total = total
                self.data = data
            }
        }

        public struct GetParameters {
            public var state: State?
            public var actorType: ActorType?
            public var start: Int?
            public var count: Int?
            /// Example: "-createdAt"
            public var sort: String?

            public enum State: String, Codable, CaseIterable {
                case pending
                case accepted
            }

            public enum ActorType: String, Codable, CaseIterable {
                case person = "Person"
                case application = "Application"
                case group = "Group"
                case service = "Service"
                case organization = "Organization"
            }

            public init(state: State? = nil, actorType: ActorType? = nil, start: Int? = nil, count: Int? = nil, sort: String? = nil) {
                self.state = state
                self.actorType = actorType
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(state, forKey: "state")
                encoder.encode(actorType, forKey: "actorType")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }
    }
}

extension Paths.Server.Followers {
    public func nameWithHost(_ nameWithHost: String) -> WithNameWithHost {
        WithNameWithHost(path: "\(path)/\(nameWithHost)")
    }

    public struct WithNameWithHost {
        /// Path: `/server/followers/{nameWithHost}`
        public let path: String

        /// Remove or reject a follower to your server
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Server.Followers.WithNameWithHost {
    public var reject: Reject {
        Reject(path: path + "/reject")
    }

    public struct Reject {
        /// Path: `/server/followers/{nameWithHost}/reject`
        public let path: String

        /// Reject a pending follower to your server
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Server.Followers.WithNameWithHost {
    public var accept: Accept {
        Accept(path: path + "/accept")
    }

    public struct Accept {
        /// Path: `/server/followers/{nameWithHost}/accept`
        public let path: String

        /// Accept a pending follower to your server
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Server {
    public var following: Following {
        Following(path: path + "/following")
    }

    public struct Following {
        /// Path: `/server/following`
        public let path: String

        /// List instances followed by the server
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var total: Int?
            public var data: [PeerTubeAPI.Follow]?

            public init(total: Int? = nil, data: [PeerTubeAPI.Follow]? = nil) {
                self.total = total
                self.data = data
            }
        }

        public struct GetParameters {
            public var state: State?
            public var actorType: ActorType?
            public var start: Int?
            public var count: Int?
            /// Example: "-createdAt"
            public var sort: String?

            public enum State: String, Codable, CaseIterable {
                case pending
                case accepted
            }

            public enum ActorType: String, Codable, CaseIterable {
                case person = "Person"
                case application = "Application"
                case group = "Group"
                case service = "Service"
                case organization = "Organization"
            }

            public init(state: State? = nil, actorType: ActorType? = nil, start: Int? = nil, count: Int? = nil, sort: String? = nil) {
                self.state = state
                self.actorType = actorType
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(state, forKey: "state")
                encoder.encode(actorType, forKey: "actorType")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }

        /// Follow a list of actors (PeerTube instance, channel or account)
        public func post(_ body: PostRequest? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            public var hosts: [String]?
            public var handles: [String]?

            public init(hosts: [String]? = nil, handles: [String]? = nil) {
                self.hosts = hosts
                self.handles = handles
            }
        }
    }
}

extension Paths.Server.Following {
    public func hostOrHandle(_ hostOrHandle: String) -> WithHostOrHandle {
        WithHostOrHandle(path: "\(path)/\(hostOrHandle)")
    }

    public struct WithHostOrHandle {
        /// Path: `/server/following/{hostOrHandle}`
        public let path: String

        /// Unfollow an actor (PeerTube instance, channel or account)
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var users: Users {
        Users(path: "/users")
    }

    public struct Users {
        /// Path: `/users`
        public let path: String

        /// List users
        public func get(parameters: GetParameters? = nil) -> Request<[PeerTubeAPI.User]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var search: String?
            public var isBlocked: Bool?
            public var start: Int?
            public var count: Int?
            public var sort: Sort?

            public enum Sort: String, Codable, CaseIterable {
                case minusid = "-id"
                case minususername = "-username"
                case minuscreatedAt = "-createdAt"
            }

            public init(search: String? = nil, isBlocked: Bool? = nil, start: Int? = nil, count: Int? = nil, sort: Sort? = nil) {
                self.search = search
                self.isBlocked = isBlocked
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(search, forKey: "search")
                encoder.encode(isBlocked, forKey: "blocked")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }

        /// Create a user
        public func post(_ body: PeerTubeAPI.AddUser) -> Request<PeerTubeAPI.AddUserResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/users/{id}`
        public let path: String

        /// Get a user
        public func get(isWithStats: Bool? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(isWithStats))
        }

        public enum GetResponse: Decodable {
            case user(PeerTubeAPI.User)
            case userWithStats(PeerTubeAPI.UserWithStats)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(PeerTubeAPI.User.self) {
                    self = .user(value)
                } else if let value = try? container.decode(PeerTubeAPI.UserWithStats.self) {
                    self = .userWithStats(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        private func makeGetQuery(_ isWithStats: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isWithStats, forKey: "withStats")
            return encoder.items
        }

        /// Update a user
        public func put(_ body: PeerTubeAPI.UpdateUser) -> Request<Void> {
            .put(path, body: body)
        }

        /// Delete a user
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var oauthClients: OauthClients {
        OauthClients(path: "/oauth-clients")
    }

    public struct OauthClients {
        /// Path: `/oauth-clients`
        public let path: String
    }
}

extension Paths.OauthClients {
    public var local: Local {
        Local(path: path + "/local")
    }

    public struct Local {
        /// Path: `/oauth-clients/local`
        public let path: String

        /// Login prerequisite
        ///
        /// You need to retrieve a client id and secret before [logging in](#operation/getOAuthToken).
        public var get: Request<PeerTubeAPI.OAuthClient> {
            .get(path)
        }
    }
}

extension Paths.Users {
    public var token: Token {
        Token(path: path + "/token")
    }

    public struct Token {
        /// Path: `/users/token`
        public let path: String

        /// Login
        ///
        /// With your [client id and secret](#operation/getOAuthClient), you can retrieve an access and refresh tokens.
        public func post(_ body: PostRequest? = nil) -> Request<PostResponse> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostResponse: Decodable {
            /// Example: "Bearer"
            public var tokenType: String?
            /// Valid for 1 day
            ///
            /// Example: "90286a0bdf0f7315d9d3fe8dabf9e1d2be9c97d0"
            public var accessToken: String?
            /// Valid for 2 weeks
            ///
            /// Example: "2e0d675df9fc96d2e4ec8a3ebbbf45eca9137bb7"
            public var refreshToken: String?
            /// Example: 14399
            public var expiresIn: Int?
            /// Example: 1209600
            public var refreshTokenExpiresIn: Int?

            public init(tokenType: String? = nil, accessToken: String? = nil, refreshToken: String? = nil, expiresIn: Int? = nil, refreshTokenExpiresIn: Int? = nil) {
                self.tokenType = tokenType
                self.accessToken = accessToken
                self.refreshToken = refreshToken
                self.expiresIn = expiresIn
                self.refreshTokenExpiresIn = refreshTokenExpiresIn
            }

            private enum CodingKeys: String, CodingKey {
                case tokenType = "token_type"
                case accessToken = "access_token"
                case refreshToken = "refresh_token"
                case expiresIn = "expires_in"
                case refreshTokenExpiresIn = "refresh_token_expires_in"
            }
        }

        public enum PostRequest: Encodable {
            case oAuthTokenPassword(PeerTubeAPI.OAuthTokenPassword)
            case oAuthTokenRefreshToken(PeerTubeAPI.OAuthTokenRefreshToken)

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                switch self {
                case .oAuthTokenPassword(let value): encoder.encode(value, forKey: "value")
                case .oAuthTokenRefreshToken(let value): encoder.encode(value, forKey: "value")
                }
                return encoder.items
            }
        }
    }
}

extension Paths.Users {
    public var revokeToken: RevokeToken {
        RevokeToken(path: path + "/revoke-token")
    }

    public struct RevokeToken {
        /// Path: `/users/revoke-token`
        public let path: String

        /// Logout
        ///
        /// Revokes your access token and its associated refresh token, destroying your current session.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Users {
    public var register: Register {
        Register(path: path + "/register")
    }

    public struct Register {
        /// Path: `/users/register`
        public let path: String

        /// Register a user
        public func post(_ body: PeerTubeAPI.RegisterUser) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users.WithID {
    public var verifyEmail: VerifyEmail {
        VerifyEmail(path: path + "/verify-email")
    }

    public struct VerifyEmail {
        /// Path: `/users/{id}/verify-email`
        public let path: String

        /// Verify a user
        ///
        /// Following a user registration, the new user will receive an email asking to click a link
        /// containing a secret.
        public func post(_ body: PostRequest? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            public var verificationString: String
            public var isPendingEmail: Bool?

            public init(verificationString: String, isPendingEmail: Bool? = nil) {
                self.verificationString = verificationString
                self.isPendingEmail = isPendingEmail
            }
        }
    }
}

extension Paths.Users {
    public var askSendVerifyEmail: AskSendVerifyEmail {
        AskSendVerifyEmail(path: path + "/ask-send-verify-email")
    }

    public struct AskSendVerifyEmail {
        /// Path: `/users/ask-send-verify-email`
        public let path: String

        /// Resend user verification link
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Users {
    public var me: Me {
        Me(path: path + "/me")
    }

    public struct Me {
        /// Path: `/users/me`
        public let path: String

        /// Get my user information
        public var get: Request<[PeerTubeAPI.User]> {
            .get(path)
        }

        /// Update my user information
        public func put(_ body: PeerTubeAPI.UpdateMe) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.Users.Me.Videos {
    public var imports: Imports {
        Imports(path: path + "/imports")
    }

    public struct Imports {
        /// Path: `/users/me/videos/imports`
        public let path: String

        /// Get video imports of my user
        public func get(parameters: GetParameters? = nil) -> Request<PeerTubeAPI.VideoImportsList> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var start: Int?
            public var count: Int?
            /// Example: "-createdAt"
            public var sort: String?

            public init(start: Int? = nil, count: Int? = nil, sort: String? = nil) {
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.Me {
    public var videoQuotaUsed: VideoQuotaUsed {
        VideoQuotaUsed(path: path + "/video-quota-used")
    }

    public struct VideoQuotaUsed {
        /// Path: `/users/me/video-quota-used`
        public let path: String

        /// Get my user used quota
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// The user video quota used so far in bytes
            ///
            /// Example: 16810141515
            public var videoQuotaUsed: Double?
            /// The user video quota used today in bytes
            ///
            /// Example: 1681014151
            public var videoQuotaUsedDaily: Double?

            public init(videoQuotaUsed: Double? = nil, videoQuotaUsedDaily: Double? = nil) {
                self.videoQuotaUsed = videoQuotaUsed
                self.videoQuotaUsedDaily = videoQuotaUsedDaily
            }
        }
    }
}

extension Paths.Users.Me.Videos {
    public func videoID(_ videoID: String) -> WithVideoID {
        WithVideoID(path: "\(path)/\(videoID)")
    }

    public struct WithVideoID {
        /// Path: `/users/me/videos/{videoId}`
        public let path: String
    }
}

extension Paths.Users.Me.Videos.WithVideoID {
    public var rating: Rating {
        Rating(path: path + "/rating")
    }

    public struct Rating {
        /// Path: `/users/me/videos/{videoId}/rating`
        public let path: String

        /// Get rate of my user for a video
        public var get: Request<PeerTubeAPI.GetMeVideoRating> {
            .get(path)
        }
    }
}

extension Paths.Users.Me {
    public var videos: Videos {
        Videos(path: path + "/videos")
    }

    public struct Videos {
        /// Path: `/users/me/videos`
        public let path: String

        /// Get videos of my user
        public func get(parameters: GetParameters? = nil) -> Request<PeerTubeAPI.VideoListResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var start: Int?
            public var count: Int?
            /// Example: "-createdAt"
            public var sort: String?

            public init(start: Int? = nil, count: Int? = nil, sort: String? = nil) {
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.Me {
    public var subscriptions: Subscriptions {
        Subscriptions(path: path + "/subscriptions")
    }

    public struct Subscriptions {
        /// Path: `/users/me/subscriptions`
        public let path: String

        /// Get my user subscriptions
        public func get(parameters: GetParameters? = nil) -> Request<PeerTubeAPI.VideoChannelList> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var start: Int?
            public var count: Int?
            /// Example: "-createdAt"
            public var sort: String?

            public init(start: Int? = nil, count: Int? = nil, sort: String? = nil) {
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }

        /// Add subscription to my user
        public func post(uri: URL) -> Request<Void> {
            .post(path, body: ["uri": uri])
        }
    }
}

extension Paths.Users.Me.Subscriptions {
    public var exist: Exist {
        Exist(path: path + "/exist")
    }

    public struct Exist {
        /// Path: `/users/me/subscriptions/exist`
        public let path: String

        /// Get if subscriptions exist for my user
        public func get(uris: [URL]) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(uris))
        }

        private func makeGetQuery(_ uris: [URL]) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(uris, forKey: "uris")
            return encoder.items
        }
    }
}

extension Paths.Users.Me.Subscriptions {
    public var videos: Videos {
        Videos(path: path + "/videos")
    }

    public struct Videos {
        /// Path: `/users/me/subscriptions/videos`
        public let path: String

        /// List videos of subscriptions of my user
        public func get(parameters: GetParameters? = nil) -> Request<PeerTubeAPI.VideoListResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var categoryOneOf: CategoryOneOf?
            public var isLive: Bool?
            public var tagsOneOf: TagsOneOf?
            public var tagsAllOf: TagsAllOf?
            public var licenceOneOf: LicenceOneOf?
            public var languageOneOf: LanguageOneOf?
            public var nsfw: Nsfw?
            public var isLocal: Bool?
            public var include: Int?
            /// Privacy id of the video (see [/videos/privacies](#operation/getPrivacyPolicies))
            public var privacyOneOf: Int?
            public var hasHLSFiles: Bool?
            public var hasWebtorrentFiles: Bool?
            public var skipCount: SkipCount?
            public var start: Int?
            public var count: Int?
            public var sort: Sort?

            public enum CategoryOneOf: Codable {
                case int(Int)
                case ints([Int])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .int(let value): encoder.encode(value, forKey: "value")
                    case .ints(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum TagsOneOf: Codable {
                case string(String)
                case strings([String])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .string(let value): encoder.encode(value, forKey: "value")
                    case .strings(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum TagsAllOf: Codable {
                case string(String)
                case strings([String])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .string(let value): encoder.encode(value, forKey: "value")
                    case .strings(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum LicenceOneOf: Codable {
                case int(Int)
                case ints([Int])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .int(let value): encoder.encode(value, forKey: "value")
                    case .ints(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum LanguageOneOf: Codable {
                case string(String)
                case strings([String])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .string(let value): encoder.encode(value, forKey: "value")
                    case .strings(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum Nsfw: String, Codable, CaseIterable {
                case `true`
                case `false`
            }

            public enum SkipCount: String, Codable, CaseIterable {
                case `true`
                case `false`
            }

            public enum Sort: String, Codable, CaseIterable {
                case name
                case minusduration = "-duration"
                case minuscreatedAt = "-createdAt"
                case minuspublishedAt = "-publishedAt"
                case minusviews = "-views"
                case minuslikes = "-likes"
                case minustrending = "-trending"
                case minushot = "-hot"
            }

            public init(categoryOneOf: CategoryOneOf? = nil, isLive: Bool? = nil, tagsOneOf: TagsOneOf? = nil, tagsAllOf: TagsAllOf? = nil, licenceOneOf: LicenceOneOf? = nil, languageOneOf: LanguageOneOf? = nil, nsfw: Nsfw? = nil, isLocal: Bool? = nil, include: Int? = nil, privacyOneOf: Int? = nil, hasHLSFiles: Bool? = nil, hasWebtorrentFiles: Bool? = nil, skipCount: SkipCount? = nil, start: Int? = nil, count: Int? = nil, sort: Sort? = nil) {
                self.categoryOneOf = categoryOneOf
                self.isLive = isLive
                self.tagsOneOf = tagsOneOf
                self.tagsAllOf = tagsAllOf
                self.licenceOneOf = licenceOneOf
                self.languageOneOf = languageOneOf
                self.nsfw = nsfw
                self.isLocal = isLocal
                self.include = include
                self.privacyOneOf = privacyOneOf
                self.hasHLSFiles = hasHLSFiles
                self.hasWebtorrentFiles = hasWebtorrentFiles
                self.skipCount = skipCount
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(categoryOneOf, forKey: "categoryOneOf", explode: false)
                encoder.encode(isLive, forKey: "isLive")
                encoder.encode(tagsOneOf, forKey: "tagsOneOf", explode: false)
                encoder.encode(tagsAllOf, forKey: "tagsAllOf", explode: false)
                encoder.encode(licenceOneOf, forKey: "licenceOneOf", explode: false)
                encoder.encode(languageOneOf, forKey: "languageOneOf", explode: false)
                encoder.encode(nsfw, forKey: "nsfw")
                encoder.encode(isLocal, forKey: "isLocal")
                encoder.encode(include, forKey: "include")
                encoder.encode(privacyOneOf, forKey: "privacyOneOf")
                encoder.encode(hasHLSFiles, forKey: "hasHLSFiles")
                encoder.encode(hasWebtorrentFiles, forKey: "hasWebtorrentFiles")
                encoder.encode(skipCount, forKey: "skipCount")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.Me.Subscriptions {
    public func subscriptionHandle(_ subscriptionHandle: String) -> WithSubscriptionHandle {
        WithSubscriptionHandle(path: "\(path)/\(subscriptionHandle)")
    }

    public struct WithSubscriptionHandle {
        /// Path: `/users/me/subscriptions/{subscriptionHandle}`
        public let path: String

        /// Get subscription of my user
        public var get: Request<PeerTubeAPI.VideoChannel> {
            .get(path)
        }

        /// Delete subscription of my user
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Users.Me {
    public var notifications: Notifications {
        Notifications(path: path + "/notifications")
    }

    public struct Notifications {
        /// Path: `/users/me/notifications`
        public let path: String

        /// List my notifications
        public func get(parameters: GetParameters? = nil) -> Request<PeerTubeAPI.NotificationListResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isUnread: Bool?
            public var start: Int?
            public var count: Int?
            /// Example: "-createdAt"
            public var sort: String?

            public init(isUnread: Bool? = nil, start: Int? = nil, count: Int? = nil, sort: String? = nil) {
                self.isUnread = isUnread
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isUnread, forKey: "unread")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.Me.Notifications {
    public var read: Read {
        Read(path: path + "/read")
    }

    public struct Read {
        /// Path: `/users/me/notifications/read`
        public let path: String

        /// Mark notifications as read by their id
        public func post(ids: [Int]) -> Request<Void> {
            .post(path, body: ["ids": ids])
        }
    }
}

extension Paths.Users.Me.Notifications {
    public var readAll: ReadAll {
        ReadAll(path: path + "/read-all")
    }

    public struct ReadAll {
        /// Path: `/users/me/notifications/read-all`
        public let path: String

        /// Mark all my notification as read
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Users.Me {
    public var notificationSettings: NotificationSettings {
        NotificationSettings(path: path + "/notification-settings")
    }

    public struct NotificationSettings {
        /// Path: `/users/me/notification-settings`
        public let path: String

        /// Update my notification settings
        public func put(_ body: PutRequest? = nil) -> Request<Void> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// Notification type
            /// - `0` NONE
            /// - `1` WEB
            /// - `2` EMAIL
            public var newVideoFromSubscription: Int?
            /// Notification type
            /// - `0` NONE
            /// - `1` WEB
            /// - `2` EMAIL
            public var newCommentOnMyVideo: Int?
            /// Notification type
            /// - `0` NONE
            /// - `1` WEB
            /// - `2` EMAIL
            public var abuseAsModerator: Int?
            /// Notification type
            /// - `0` NONE
            /// - `1` WEB
            /// - `2` EMAIL
            public var videoAutoBlacklistAsModerator: Int?
            /// Notification type
            /// - `0` NONE
            /// - `1` WEB
            /// - `2` EMAIL
            public var blacklistOnMyVideo: Int?
            /// Notification type
            /// - `0` NONE
            /// - `1` WEB
            /// - `2` EMAIL
            public var myVideoPublished: Int?
            /// Notification type
            /// - `0` NONE
            /// - `1` WEB
            /// - `2` EMAIL
            public var myVideoImportFinished: Int?
            /// Notification type
            /// - `0` NONE
            /// - `1` WEB
            /// - `2` EMAIL
            public var newFollow: Int?
            /// Notification type
            /// - `0` NONE
            /// - `1` WEB
            /// - `2` EMAIL
            public var newUserRegistration: Int?
            /// Notification type
            /// - `0` NONE
            /// - `1` WEB
            /// - `2` EMAIL
            public var commentMention: Int?
            /// Notification type
            /// - `0` NONE
            /// - `1` WEB
            /// - `2` EMAIL
            public var newInstanceFollower: Int?
            /// Notification type
            /// - `0` NONE
            /// - `1` WEB
            /// - `2` EMAIL
            public var autoInstanceFollowing: Int?

            public init(newVideoFromSubscription: Int? = nil, newCommentOnMyVideo: Int? = nil, abuseAsModerator: Int? = nil, videoAutoBlacklistAsModerator: Int? = nil, blacklistOnMyVideo: Int? = nil, myVideoPublished: Int? = nil, myVideoImportFinished: Int? = nil, newFollow: Int? = nil, newUserRegistration: Int? = nil, commentMention: Int? = nil, newInstanceFollower: Int? = nil, autoInstanceFollowing: Int? = nil) {
                self.newVideoFromSubscription = newVideoFromSubscription
                self.newCommentOnMyVideo = newCommentOnMyVideo
                self.abuseAsModerator = abuseAsModerator
                self.videoAutoBlacklistAsModerator = videoAutoBlacklistAsModerator
                self.blacklistOnMyVideo = blacklistOnMyVideo
                self.myVideoPublished = myVideoPublished
                self.myVideoImportFinished = myVideoImportFinished
                self.newFollow = newFollow
                self.newUserRegistration = newUserRegistration
                self.commentMention = commentMention
                self.newInstanceFollower = newInstanceFollower
                self.autoInstanceFollowing = autoInstanceFollowing
            }
        }
    }
}

extension Paths.Users.Me {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/users/me/history`
        public let path: String
    }
}

extension Paths.Users.Me.History {
    public var videos: Videos {
        Videos(path: path + "/videos")
    }

    public struct Videos {
        /// Path: `/users/me/history/videos`
        public let path: String

        /// List watched videos history
        public func get(parameters: GetParameters? = nil) -> Request<PeerTubeAPI.VideoListResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var start: Int?
            public var count: Int?
            public var search: String?

            public init(start: Int? = nil, count: Int? = nil, search: String? = nil) {
                self.start = start
                self.count = count
                self.search = search
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(search, forKey: "search")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.Me.History.Videos {
    public var remove: Remove {
        Remove(path: path + "/remove")
    }

    public struct Remove {
        /// Path: `/users/me/history/videos/remove`
        public let path: String

        /// Clear video history
        public func post(_ body: Data? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users.Me.Avatar {
    public var pick: Pick {
        Pick(path: path + "/pick")
    }

    public struct Pick {
        /// Path: `/users/me/avatar/pick`
        public let path: String

        /// Update my user avatar
        public func post(_ body: Data? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            public var avatar: PeerTubeAPI.ActorImage?

            public init(avatar: PeerTubeAPI.ActorImage? = nil) {
                self.avatar = avatar
            }
        }
    }
}

extension Paths.Users.Me {
    public var avatar: Avatar {
        Avatar(path: path + "/avatar")
    }

    public struct Avatar {
        /// Path: `/users/me/avatar`
        public let path: String

        /// Delete my avatar
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Videos {
    public var ownership: Ownership {
        Ownership(path: path + "/ownership")
    }

    public struct Ownership {
        /// Path: `/videos/ownership`
        public let path: String

        /// List video ownership changes
        public var get: Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Videos.Ownership {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/videos/ownership/{id}`
        public let path: String
    }
}

extension Paths.Videos.Ownership.WithID {
    public var accept: Accept {
        Accept(path: path + "/accept")
    }

    public struct Accept {
        /// Path: `/videos/ownership/{id}/accept`
        public let path: String

        /// Accept ownership change request
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Videos.Ownership.WithID {
    public var refuse: Refuse {
        Refuse(path: path + "/refuse")
    }

    public struct Refuse {
        /// Path: `/videos/ownership/{id}/refuse`
        public let path: String

        /// Refuse ownership change request
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Videos.WithID {
    public var giveOwnership: GiveOwnership {
        GiveOwnership(path: path + "/give-ownership")
    }

    public struct GiveOwnership {
        /// Path: `/videos/{id}/give-ownership`
        public let path: String

        /// Request ownership change
        public func post(_ body: PostRequest) -> Request<Void> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            public var username: String

            public init(username: String) {
                self.username = username
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(username, forKey: "username")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var videos: Videos {
        Videos(path: "/videos")
    }

    public struct Videos {
        /// Path: `/videos`
        public let path: String

        /// List videos
        public func get(parameters: GetParameters? = nil) -> Request<PeerTubeAPI.VideoListResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var categoryOneOf: CategoryOneOf?
            public var isLive: Bool?
            public var tagsOneOf: TagsOneOf?
            public var tagsAllOf: TagsAllOf?
            public var licenceOneOf: LicenceOneOf?
            public var languageOneOf: LanguageOneOf?
            public var nsfw: Nsfw?
            public var isLocal: Bool?
            public var include: Int?
            /// Privacy id of the video (see [/videos/privacies](#operation/getPrivacyPolicies))
            public var privacyOneOf: Int?
            public var hasHLSFiles: Bool?
            public var hasWebtorrentFiles: Bool?
            public var skipCount: SkipCount?
            public var start: Int?
            public var count: Int?
            public var sort: Sort?

            public enum CategoryOneOf: Codable {
                case int(Int)
                case ints([Int])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .int(let value): encoder.encode(value, forKey: "value")
                    case .ints(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum TagsOneOf: Codable {
                case string(String)
                case strings([String])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .string(let value): encoder.encode(value, forKey: "value")
                    case .strings(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum TagsAllOf: Codable {
                case string(String)
                case strings([String])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .string(let value): encoder.encode(value, forKey: "value")
                    case .strings(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum LicenceOneOf: Codable {
                case int(Int)
                case ints([Int])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .int(let value): encoder.encode(value, forKey: "value")
                    case .ints(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum LanguageOneOf: Codable {
                case string(String)
                case strings([String])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .string(let value): encoder.encode(value, forKey: "value")
                    case .strings(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum Nsfw: String, Codable, CaseIterable {
                case `true`
                case `false`
            }

            public enum SkipCount: String, Codable, CaseIterable {
                case `true`
                case `false`
            }

            public enum Sort: String, Codable, CaseIterable {
                case name
                case minusduration = "-duration"
                case minuscreatedAt = "-createdAt"
                case minuspublishedAt = "-publishedAt"
                case minusviews = "-views"
                case minuslikes = "-likes"
                case minustrending = "-trending"
                case minushot = "-hot"
            }

            public init(categoryOneOf: CategoryOneOf? = nil, isLive: Bool? = nil, tagsOneOf: TagsOneOf? = nil, tagsAllOf: TagsAllOf? = nil, licenceOneOf: LicenceOneOf? = nil, languageOneOf: LanguageOneOf? = nil, nsfw: Nsfw? = nil, isLocal: Bool? = nil, include: Int? = nil, privacyOneOf: Int? = nil, hasHLSFiles: Bool? = nil, hasWebtorrentFiles: Bool? = nil, skipCount: SkipCount? = nil, start: Int? = nil, count: Int? = nil, sort: Sort? = nil) {
                self.categoryOneOf = categoryOneOf
                self.isLive = isLive
                self.tagsOneOf = tagsOneOf
                self.tagsAllOf = tagsAllOf
                self.licenceOneOf = licenceOneOf
                self.languageOneOf = languageOneOf
                self.nsfw = nsfw
                self.isLocal = isLocal
                self.include = include
                self.privacyOneOf = privacyOneOf
                self.hasHLSFiles = hasHLSFiles
                self.hasWebtorrentFiles = hasWebtorrentFiles
                self.skipCount = skipCount
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(categoryOneOf, forKey: "categoryOneOf", explode: false)
                encoder.encode(isLive, forKey: "isLive")
                encoder.encode(tagsOneOf, forKey: "tagsOneOf", explode: false)
                encoder.encode(tagsAllOf, forKey: "tagsAllOf", explode: false)
                encoder.encode(licenceOneOf, forKey: "licenceOneOf", explode: false)
                encoder.encode(languageOneOf, forKey: "languageOneOf", explode: false)
                encoder.encode(nsfw, forKey: "nsfw")
                encoder.encode(isLocal, forKey: "isLocal")
                encoder.encode(include, forKey: "include")
                encoder.encode(privacyOneOf, forKey: "privacyOneOf")
                encoder.encode(hasHLSFiles, forKey: "hasHLSFiles")
                encoder.encode(hasWebtorrentFiles, forKey: "hasWebtorrentFiles")
                encoder.encode(skipCount, forKey: "skipCount")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }
    }
}

extension Paths.Videos {
    public var categories: Categories {
        Categories(path: path + "/categories")
    }

    public struct Categories {
        /// Path: `/videos/categories`
        public let path: String

        /// List available video categories
        public var get: Request<[String]> {
            .get(path)
        }
    }
}

extension Paths.Videos {
    public var licences: Licences {
        Licences(path: path + "/licences")
    }

    public struct Licences {
        /// Path: `/videos/licences`
        public let path: String

        /// List available video licences
        public var get: Request<[String]> {
            .get(path)
        }
    }
}

extension Paths.Videos {
    public var languages: Languages {
        Languages(path: path + "/languages")
    }

    public struct Languages {
        /// Path: `/videos/languages`
        public let path: String

        /// List available video languages
        public var get: Request<[String]> {
            .get(path)
        }
    }
}

extension Paths.Videos {
    public var privacies: Privacies {
        Privacies(path: path + "/privacies")
    }

    public struct Privacies {
        /// Path: `/videos/privacies`
        public let path: String

        /// List available video privacy policies
        public var get: Request<[String]> {
            .get(path)
        }
    }
}

extension Paths.Videos {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/videos/{id}`
        public let path: String

        /// Get a video
        public var get: Request<PeerTubeAPI.VideoDetails> {
            .get(path)
        }

        /// Update a video
        public func put(_ body: Data? = nil) -> Request<Void> {
            .put(path, body: body)
        }

        /// Delete a video
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Videos.WithID {
    public var description: Description {
        Description(path: path + "/description")
    }

    public struct Description {
        /// Path: `/videos/{id}/description`
        public let path: String

        /// Get complete video description
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Videos.WithID {
    public var views: Views {
        Views(path: path + "/views")
    }

    public struct Views {
        /// Path: `/videos/{id}/views`
        public let path: String

        /// Add a view to a video
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Videos.WithID {
    public var watching: Watching {
        Watching(path: path + "/watching")
    }

    public struct Watching {
        /// Path: `/videos/{id}/watching`
        public let path: String

        /// Set watching progress of a video
        public func put(_ body: PeerTubeAPI.UserWatchingVideo) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.Videos {
    public var upload: Upload {
        Upload(path: path + "/upload")
    }

    public struct Upload {
        /// Path: `/videos/upload`
        public let path: String

        /// Upload a video
        ///
        /// Uses a single request to upload a video.
        public func post(_ body: Data? = nil) -> Request<PeerTubeAPI.VideoUploadResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Videos {
    public var uploadResumable: UploadResumable {
        UploadResumable(path: path + "/upload-resumable")
    }

    public struct UploadResumable {
        /// Path: `/videos/upload-resumable`
        public let path: String

        /// Initialize the resumable upload of a video
        ///
        /// Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to initialize the upload of a video
        public func post(_ body: PeerTubeAPI.VideoUploadRequestResumable? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        /// Send chunk for the resumable upload of a video
        ///
        /// Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to continue, pause or resume the upload of a video
        public func put(uploadID: String, _ body: Data? = nil) -> Request<PeerTubeAPI.VideoUploadResponse> {
            .put(path, query: [("upload_id", uploadID)], body: body)
        }

        public enum PutResponseHeaders {
            public static let contentLength = HTTPHeader<Double>(field: "Content-Length")
        }

        /// Cancel the resumable upload of a video, deleting any data uploaded so far
        ///
        /// Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to cancel the upload of a video
        public func delete(uploadID: String) -> Request<Void> {
            .delete(path, query: [("upload_id", uploadID)])
        }

        public enum DeleteResponseHeaders {
            public static let contentLength = HTTPHeader<Double>(field: "Content-Length")
        }
    }
}

extension Paths.Videos {
    public var imports: Imports {
        Imports(path: path + "/imports")
    }

    public struct Imports {
        /// Path: `/videos/imports`
        public let path: String

        /// Import a video
        ///
        /// Import a torrent or magnetURI or HTTP resource (if enabled by the instance administrator)
        public func post(_ body: Data? = nil) -> Request<PeerTubeAPI.VideoUploadResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Videos {
    public var live: Live {
        Live(path: path + "/live")
    }

    public struct Live {
        /// Path: `/videos/live`
        public let path: String

        /// Create a live
        public func post(_ body: Data? = nil) -> Request<PeerTubeAPI.VideoUploadResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Videos.Live {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/videos/live/{id}`
        public let path: String

        /// Get information about a live
        public var get: Request<PeerTubeAPI.LiveVideoResponse> {
            .get(path)
        }

        /// Update information about a live
        public func put(_ body: PeerTubeAPI.LiveVideoUpdate? = nil) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.Users.Me {
    public var abuses: Abuses {
        Abuses(path: path + "/abuses")
    }

    public struct Abuses {
        /// Path: `/users/me/abuses`
        public let path: String

        /// List my abuses
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var total: Int?
            public var data: [PeerTubeAPI.Abuse]?

            public init(total: Int? = nil, data: [PeerTubeAPI.Abuse]? = nil) {
                self.total = total
                self.data = data
            }
        }

        public struct GetParameters {
            public var id: Int?
            /// The abuse state (Pending = `1`, Rejected = `2`, Accepted = `3`)
            public var state: Int?
            public var sort: Sort?
            public var start: Int?
            public var count: Int?

            public enum Sort: String, Codable, CaseIterable {
                case minusid = "-id"
                case minuscreatedAt = "-createdAt"
                case minusstate = "-state"
            }

            public init(id: Int? = nil, state: Int? = nil, sort: Sort? = nil, start: Int? = nil, count: Int? = nil) {
                self.id = id
                self.state = state
                self.sort = sort
                self.start = start
                self.count = count
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(id, forKey: "id")
                encoder.encode(state, forKey: "state")
                encoder.encode(sort, forKey: "sort")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var abuses: Abuses {
        Abuses(path: "/abuses")
    }

    public struct Abuses {
        /// Path: `/abuses`
        public let path: String

        /// List abuses
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var total: Int?
            public var data: [PeerTubeAPI.Abuse]?

            public init(total: Int? = nil, data: [PeerTubeAPI.Abuse]? = nil) {
                self.total = total
                self.data = data
            }
        }

        public struct GetParameters {
            public var id: Int?
            /// Reason categories that help triage reports
            public var predefinedReason: [PredefinedReason]?
            public var search: String?
            /// The abuse state (Pending = `1`, Rejected = `2`, Accepted = `3`)
            public var state: Int?
            public var searchReporter: String?
            public var searchReportee: String?
            public var searchVideo: String?
            public var searchVideoChannel: String?
            public var videoIs: VideoIs?
            public var filter: Filter?
            public var start: Int?
            public var count: Int?
            public var sort: Sort?

            public enum PredefinedReason: String, Codable, CaseIterable {
                case violentOrAbusive
                case hatefulOrAbusive
                case spamOrMisleading
                case privacy
                case rights
                case serverRules
                case thumbnails
                case captions
            }

            public enum VideoIs: String, Codable, CaseIterable {
                case deleted
                case blacklisted
            }

            public enum Filter: String, Codable, CaseIterable {
                case video
                case comment
                case account
            }

            public enum Sort: String, Codable, CaseIterable {
                case minusid = "-id"
                case minuscreatedAt = "-createdAt"
                case minusstate = "-state"
            }

            public init(id: Int? = nil, predefinedReason: [PredefinedReason]? = nil, search: String? = nil, state: Int? = nil, searchReporter: String? = nil, searchReportee: String? = nil, searchVideo: String? = nil, searchVideoChannel: String? = nil, videoIs: VideoIs? = nil, filter: Filter? = nil, start: Int? = nil, count: Int? = nil, sort: Sort? = nil) {
                self.id = id
                self.predefinedReason = predefinedReason
                self.search = search
                self.state = state
                self.searchReporter = searchReporter
                self.searchReportee = searchReportee
                self.searchVideo = searchVideo
                self.searchVideoChannel = searchVideoChannel
                self.videoIs = videoIs
                self.filter = filter
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(id, forKey: "id")
                encoder.encode(predefinedReason, forKey: "predefinedReason")
                encoder.encode(search, forKey: "search")
                encoder.encode(state, forKey: "state")
                encoder.encode(searchReporter, forKey: "searchReporter")
                encoder.encode(searchReportee, forKey: "searchReportee")
                encoder.encode(searchVideo, forKey: "searchVideo")
                encoder.encode(searchVideoChannel, forKey: "searchVideoChannel")
                encoder.encode(videoIs, forKey: "videoIs")
                encoder.encode(filter, forKey: "filter")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }

        /// Report an abuse
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            public var abuse: Abuse?

            public struct Abuse: Decodable {
                /// Example: 42
                public var id: Int?

                public init(id: Int? = nil) {
                    self.id = id
                }
            }

            public init(abuse: Abuse? = nil) {
                self.abuse = abuse
            }
        }

        public struct PostRequest: Encodable {
            /// Reason why the user reports this video
            public var reason: String
            /// Reason categories that help triage reports
            public var predefinedReasons: [PredefinedAbuseReason]?
            public var video: Video?
            public var comment: Comment?
            public var account: Account?

            public struct Video: Encodable {
                /// Video id to report
                public var id: AnyJSON?
                /// Timestamp in the video that marks the beginning of the report
                public var startAt: Int?
                /// Timestamp in the video that marks the ending of the report
                public var endAt: Int?

                public init(id: AnyJSON? = nil, startAt: Int? = nil, endAt: Int? = nil) {
                    self.id = id
                    self.startAt = startAt
                    self.endAt = endAt
                }
            }

            public struct Comment: Encodable {
                /// Comment id to report
                public var id: AnyJSON?

                public init(id: AnyJSON? = nil) {
                    self.id = id
                }
            }

            public struct Account: Encodable {
                /// Account id to report
                public var id: Int?

                public init(id: Int? = nil) {
                    self.id = id
                }
            }

            public init(reason: String, predefinedReasons: [PredefinedAbuseReason]? = nil, video: Video? = nil, comment: Comment? = nil, account: Account? = nil) {
                self.reason = reason
                self.predefinedReasons = predefinedReasons
                self.video = video
                self.comment = comment
                self.account = account
            }
        }
    }
}

extension Paths.Abuses {
    public func abuseID(_ abuseID: String) -> WithAbuseID {
        WithAbuseID(path: "\(path)/\(abuseID)")
    }

    public struct WithAbuseID {
        /// Path: `/abuses/{abuseId}`
        public let path: String

        /// Update an abuse
        public func put(_ body: PutRequest? = nil) -> Request<Void> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// The abuse state (Pending = `1`, Rejected = `2`, Accepted = `3`)
            public var state: Int?
            /// Update the report comment visible only to the moderation team
            public var moderationComment: String?

            public init(state: Int? = nil, moderationComment: String? = nil) {
                self.state = state
                self.moderationComment = moderationComment
            }
        }

        /// Delete an abuse
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Abuses.WithAbuseID {
    public var messages: Messages {
        Messages(path: path + "/messages")
    }

    public struct Messages {
        /// Path: `/abuses/{abuseId}/messages`
        public let path: String

        /// List messages of an abuse
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var total: Int?
            public var data: [PeerTubeAPI.AbuseMessage]?

            public init(total: Int? = nil, data: [PeerTubeAPI.AbuseMessage]? = nil) {
                self.total = total
                self.data = data
            }
        }

        /// Add message to an abuse
        public func post(message: String) -> Request<Void> {
            .post(path, body: ["message": message])
        }
    }
}

extension Paths.Abuses.WithAbuseID.Messages {
    public func abuseMessageID(_ abuseMessageID: String) -> WithAbuseMessageID {
        WithAbuseMessageID(path: "\(path)/\(abuseMessageID)")
    }

    public struct WithAbuseMessageID {
        /// Path: `/abuses/{abuseId}/messages/{abuseMessageId}`
        public let path: String

        /// Delete an abuse message
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Videos.WithID {
    public var blacklist: Blacklist {
        Blacklist(path: path + "/blacklist")
    }

    public struct Blacklist {
        /// Path: `/videos/{id}/blacklist`
        public let path: String

        /// Block a video
        public var post: Request<Void> {
            .post(path)
        }

        /// Unblock a video by its id
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Videos {
    public var blacklist: Blacklist {
        Blacklist(path: path + "/blacklist")
    }

    public struct Blacklist {
        /// Path: `/videos/blacklist`
        public let path: String

        /// List video blocks
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var total: Int?
            public var data: [PeerTubeAPI.VideoBlacklist]?

            public init(total: Int? = nil, data: [PeerTubeAPI.VideoBlacklist]? = nil) {
                self.total = total
                self.data = data
            }
        }

        public struct GetParameters {
            public var type: Int?
            public var search: String?
            public var start: Int?
            public var count: Int?
            public var sort: Sort?

            public enum Sort: String, Codable, CaseIterable {
                case minusid = "-id"
                case name
                case minusduration = "-duration"
                case minusviews = "-views"
                case minuslikes = "-likes"
                case minusdislikes = "-dislikes"
                case minusuuid = "-uuid"
                case minuscreatedAt = "-createdAt"
            }

            public init(type: Int? = nil, search: String? = nil, start: Int? = nil, count: Int? = nil, sort: Sort? = nil) {
                self.type = type
                self.search = search
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(search, forKey: "search")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }
    }
}

extension Paths.Videos.WithID {
    public var captions: Captions {
        Captions(path: path + "/captions")
    }

    public struct Captions {
        /// Path: `/videos/{id}/captions`
        public let path: String

        /// List captions of a video
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var total: Int?
            public var data: [PeerTubeAPI.VideoCaption]?

            public init(total: Int? = nil, data: [PeerTubeAPI.VideoCaption]? = nil) {
                self.total = total
                self.data = data
            }
        }
    }
}

extension Paths.Videos.WithID.Captions {
    public func captionLanguage(_ captionLanguage: String) -> WithCaptionLanguage {
        WithCaptionLanguage(path: "\(path)/\(captionLanguage)")
    }

    public struct WithCaptionLanguage {
        /// Path: `/videos/{id}/captions/{captionLanguage}`
        public let path: String

        /// Add or replace a video caption
        public func put(_ body: Data? = nil) -> Request<Void> {
            .put(path, body: body)
        }

        /// Delete a video caption
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var videoChannels: VideoChannels {
        VideoChannels(path: "/video-channels")
    }

    public struct VideoChannels {
        /// Path: `/video-channels`
        public let path: String

        /// List video channels
        public func get(parameters: GetParameters? = nil) -> Request<PeerTubeAPI.VideoChannelList> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var start: Int?
            public var count: Int?
            /// Example: "-createdAt"
            public var sort: String?

            public init(start: Int? = nil, count: Int? = nil, sort: String? = nil) {
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }

        /// Create a video channel
        public func post(_ body: PeerTubeAPI.VideoChannelCreate? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            public var videoChannel: VideoChannel?

            public struct VideoChannel: Decodable {
                public var id: AnyJSON?

                public init(id: AnyJSON? = nil) {
                    self.id = id
                }
            }

            public init(videoChannel: VideoChannel? = nil) {
                self.videoChannel = videoChannel
            }
        }
    }
}

extension Paths.VideoChannels {
    public func channelHandle(_ channelHandle: String) -> WithChannelHandle {
        WithChannelHandle(path: "\(path)/\(channelHandle)")
    }

    public struct WithChannelHandle {
        /// Path: `/video-channels/{channelHandle}`
        public let path: String

        /// Get a video channel
        public var get: Request<PeerTubeAPI.VideoChannel> {
            .get(path)
        }

        /// Update a video channel
        public func put(_ body: PeerTubeAPI.VideoChannelUpdate? = nil) -> Request<Void> {
            .put(path, body: body)
        }

        /// Delete a video channel
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.VideoChannels.WithChannelHandle {
    public var videos: Videos {
        Videos(path: path + "/videos")
    }

    public struct Videos {
        /// Path: `/video-channels/{channelHandle}/videos`
        public let path: String

        /// List videos of a video channel
        public func get(parameters: GetParameters? = nil) -> Request<PeerTubeAPI.VideoListResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var categoryOneOf: CategoryOneOf?
            public var isLive: Bool?
            public var tagsOneOf: TagsOneOf?
            public var tagsAllOf: TagsAllOf?
            public var licenceOneOf: LicenceOneOf?
            public var languageOneOf: LanguageOneOf?
            public var nsfw: Nsfw?
            public var isLocal: Bool?
            public var include: Int?
            /// Privacy id of the video (see [/videos/privacies](#operation/getPrivacyPolicies))
            public var privacyOneOf: Int?
            public var hasHLSFiles: Bool?
            public var hasWebtorrentFiles: Bool?
            public var skipCount: SkipCount?
            public var start: Int?
            public var count: Int?
            public var sort: Sort?

            public enum CategoryOneOf: Codable {
                case int(Int)
                case ints([Int])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .int(let value): encoder.encode(value, forKey: "value")
                    case .ints(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum TagsOneOf: Codable {
                case string(String)
                case strings([String])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .string(let value): encoder.encode(value, forKey: "value")
                    case .strings(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum TagsAllOf: Codable {
                case string(String)
                case strings([String])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .string(let value): encoder.encode(value, forKey: "value")
                    case .strings(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum LicenceOneOf: Codable {
                case int(Int)
                case ints([Int])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .int(let value): encoder.encode(value, forKey: "value")
                    case .ints(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum LanguageOneOf: Codable {
                case string(String)
                case strings([String])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .string(let value): encoder.encode(value, forKey: "value")
                    case .strings(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum Nsfw: String, Codable, CaseIterable {
                case `true`
                case `false`
            }

            public enum SkipCount: String, Codable, CaseIterable {
                case `true`
                case `false`
            }

            public enum Sort: String, Codable, CaseIterable {
                case name
                case minusduration = "-duration"
                case minuscreatedAt = "-createdAt"
                case minuspublishedAt = "-publishedAt"
                case minusviews = "-views"
                case minuslikes = "-likes"
                case minustrending = "-trending"
                case minushot = "-hot"
            }

            public init(categoryOneOf: CategoryOneOf? = nil, isLive: Bool? = nil, tagsOneOf: TagsOneOf? = nil, tagsAllOf: TagsAllOf? = nil, licenceOneOf: LicenceOneOf? = nil, languageOneOf: LanguageOneOf? = nil, nsfw: Nsfw? = nil, isLocal: Bool? = nil, include: Int? = nil, privacyOneOf: Int? = nil, hasHLSFiles: Bool? = nil, hasWebtorrentFiles: Bool? = nil, skipCount: SkipCount? = nil, start: Int? = nil, count: Int? = nil, sort: Sort? = nil) {
                self.categoryOneOf = categoryOneOf
                self.isLive = isLive
                self.tagsOneOf = tagsOneOf
                self.tagsAllOf = tagsAllOf
                self.licenceOneOf = licenceOneOf
                self.languageOneOf = languageOneOf
                self.nsfw = nsfw
                self.isLocal = isLocal
                self.include = include
                self.privacyOneOf = privacyOneOf
                self.hasHLSFiles = hasHLSFiles
                self.hasWebtorrentFiles = hasWebtorrentFiles
                self.skipCount = skipCount
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(categoryOneOf, forKey: "categoryOneOf", explode: false)
                encoder.encode(isLive, forKey: "isLive")
                encoder.encode(tagsOneOf, forKey: "tagsOneOf", explode: false)
                encoder.encode(tagsAllOf, forKey: "tagsAllOf", explode: false)
                encoder.encode(licenceOneOf, forKey: "licenceOneOf", explode: false)
                encoder.encode(languageOneOf, forKey: "languageOneOf", explode: false)
                encoder.encode(nsfw, forKey: "nsfw")
                encoder.encode(isLocal, forKey: "isLocal")
                encoder.encode(include, forKey: "include")
                encoder.encode(privacyOneOf, forKey: "privacyOneOf")
                encoder.encode(hasHLSFiles, forKey: "hasHLSFiles")
                encoder.encode(hasWebtorrentFiles, forKey: "hasWebtorrentFiles")
                encoder.encode(skipCount, forKey: "skipCount")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }
    }
}

extension Paths.VideoChannels.WithChannelHandle {
    public var followers: Followers {
        Followers(path: path + "/followers")
    }

    public struct Followers {
        /// Path: `/video-channels/{channelHandle}/followers`
        public let path: String

        /// List followers of a video channel
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var total: Int?
            public var data: [PeerTubeAPI.Follow]?

            public init(total: Int? = nil, data: [PeerTubeAPI.Follow]? = nil) {
                self.total = total
                self.data = data
            }
        }

        public struct GetParameters {
            public var start: Int?
            public var count: Int?
            public var sort: Sort?
            public var search: String?

            public enum Sort: String, Codable, CaseIterable {
                case createdAt
            }

            public init(start: Int? = nil, count: Int? = nil, sort: Sort? = nil, search: String? = nil) {
                self.start = start
                self.count = count
                self.sort = sort
                self.search = search
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                encoder.encode(search, forKey: "search")
                return encoder.items
            }
        }
    }
}

extension Paths.VideoChannels.WithChannelHandle.Avatar {
    public var pick: Pick {
        Pick(path: path + "/pick")
    }

    public struct Pick {
        /// Path: `/video-channels/{channelHandle}/avatar/pick`
        public let path: String

        /// Update channel avatar
        public func post(_ body: Data? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            public var avatar: PeerTubeAPI.ActorImage?

            public init(avatar: PeerTubeAPI.ActorImage? = nil) {
                self.avatar = avatar
            }
        }
    }
}

extension Paths.VideoChannels.WithChannelHandle {
    public var avatar: Avatar {
        Avatar(path: path + "/avatar")
    }

    public struct Avatar {
        /// Path: `/video-channels/{channelHandle}/avatar`
        public let path: String

        /// Delete channel avatar
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.VideoChannels.WithChannelHandle.Banner {
    public var pick: Pick {
        Pick(path: path + "/pick")
    }

    public struct Pick {
        /// Path: `/video-channels/{channelHandle}/banner/pick`
        public let path: String

        /// Update channel banner
        public func post(_ body: Data? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            public var banner: PeerTubeAPI.ActorImage?

            public init(banner: PeerTubeAPI.ActorImage? = nil) {
                self.banner = banner
            }
        }
    }
}

extension Paths.VideoChannels.WithChannelHandle {
    public var banner: Banner {
        Banner(path: path + "/banner")
    }

    public struct Banner {
        /// Path: `/video-channels/{channelHandle}/banner`
        public let path: String

        /// Delete channel banner
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.VideoPlaylists {
    public var privacies: Privacies {
        Privacies(path: path + "/privacies")
    }

    public struct Privacies {
        /// Path: `/video-playlists/privacies`
        public let path: String

        /// List available playlist privacy policies
        public var get: Request<[String]> {
            .get(path)
        }
    }
}

extension Paths {
    public static var videoPlaylists: VideoPlaylists {
        VideoPlaylists(path: "/video-playlists")
    }

    public struct VideoPlaylists {
        /// Path: `/video-playlists`
        public let path: String

        /// List video playlists
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var total: Int?
            public var data: [PeerTubeAPI.VideoPlaylist]?

            public init(total: Int? = nil, data: [PeerTubeAPI.VideoPlaylist]? = nil) {
                self.total = total
                self.data = data
            }
        }

        public struct GetParameters {
            public var start: Int?
            public var count: Int?
            /// Example: "-createdAt"
            public var sort: String?

            public init(start: Int? = nil, count: Int? = nil, sort: String? = nil) {
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }

        /// Create a video playlist
        ///
        /// If the video playlist is set as public, `videoChannelId` is mandatory.
        public func post(_ body: Data? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            public var videoPlaylist: VideoPlaylist?

            public struct VideoPlaylist: Decodable {
                public var id: AnyJSON?
                public var uuid: AnyJSON?
                public var shortUUID: AnyJSON?

                public init(id: AnyJSON? = nil, uuid: AnyJSON? = nil, shortUUID: AnyJSON? = nil) {
                    self.id = id
                    self.uuid = uuid
                    self.shortUUID = shortUUID
                }
            }

            public init(videoPlaylist: VideoPlaylist? = nil) {
                self.videoPlaylist = videoPlaylist
            }
        }
    }
}

extension Paths.VideoPlaylists {
    public func playlistID(_ playlistID: String) -> WithPlaylistID {
        WithPlaylistID(path: "\(path)/\(playlistID)")
    }

    public struct WithPlaylistID {
        /// Path: `/video-playlists/{playlistId}`
        public let path: String

        /// Get a video playlist
        public var get: Request<PeerTubeAPI.VideoPlaylist> {
            .get(path)
        }

        /// Update a video playlist
        ///
        /// If the video playlist is set as public, the playlist must have a assigned channel.
        public func put(_ body: Data? = nil) -> Request<Void> {
            .put(path, body: body)
        }

        /// Delete a video playlist
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.VideoPlaylists.WithPlaylistID {
    public var videos: Videos {
        Videos(path: path + "/videos")
    }

    public struct Videos {
        /// Path: `/video-playlists/{playlistId}/videos`
        public let path: String

        /// List videos of a playlist
        public func get(start: Int? = nil, count: Int? = nil) -> Request<PeerTubeAPI.VideoListResponse> {
            .get(path, query: makeGetQuery(start, count))
        }

        private func makeGetQuery(_ start: Int?, _ count: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(start, forKey: "start")
            encoder.encode(count, forKey: "count")
            return encoder.items
        }

        /// Add a video in a playlist
        public func post(_ body: PostRequest? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            public var videoPlaylistElement: VideoPlaylistElement?

            public struct VideoPlaylistElement: Decodable {
                public var id: Int?

                public init(id: Int? = nil) {
                    self.id = id
                }
            }

            public init(videoPlaylistElement: VideoPlaylistElement? = nil) {
                self.videoPlaylistElement = videoPlaylistElement
            }
        }

        public struct PostRequest: Encodable {
            /// Video to add in the playlist
            public var videoID: AnyJSON
            /// Start the video at this specific timestamp
            public var startTimestamp: Int?
            /// Stop the video at this specific timestamp
            public var stopTimestamp: Int?

            public init(videoID: AnyJSON, startTimestamp: Int? = nil, stopTimestamp: Int? = nil) {
                self.videoID = videoID
                self.startTimestamp = startTimestamp
                self.stopTimestamp = stopTimestamp
            }

            private enum CodingKeys: String, CodingKey {
                case videoID = "videoId"
                case startTimestamp
                case stopTimestamp
            }
        }
    }
}

extension Paths.VideoPlaylists.WithPlaylistID.Videos {
    public var reorder: Reorder {
        Reorder(path: path + "/reorder")
    }

    public struct Reorder {
        /// Path: `/video-playlists/{playlistId}/videos/reorder`
        public let path: String

        /// Reorder a playlist
        public func post(_ body: PostRequest? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Start position of the element to reorder
            public var startPosition: Int
            /// New position for the block to reorder, to add the block before the first element
            public var insertAfterPosition: Int
            /// How many element from `startPosition` to reorder
            public var reorderLength: Int?

            public init(startPosition: Int, insertAfterPosition: Int, reorderLength: Int? = nil) {
                self.startPosition = startPosition
                self.insertAfterPosition = insertAfterPosition
                self.reorderLength = reorderLength
            }
        }
    }
}

extension Paths.VideoPlaylists.WithPlaylistID.Videos {
    public func playlistElementID(_ playlistElementID: Int) -> WithPlaylistElementID {
        WithPlaylistElementID(path: "\(path)/\(playlistElementID)")
    }

    public struct WithPlaylistElementID {
        /// Path: `/video-playlists/{playlistId}/videos/{playlistElementId}`
        public let path: String

        /// Update a playlist element
        public func put(_ body: PutRequest? = nil) -> Request<Void> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// Start the video at this specific timestamp
            public var startTimestamp: Int?
            /// Stop the video at this specific timestamp
            public var stopTimestamp: Int?

            public init(startTimestamp: Int? = nil, stopTimestamp: Int? = nil) {
                self.startTimestamp = startTimestamp
                self.stopTimestamp = stopTimestamp
            }
        }

        /// Delete an element from a playlist
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Users.Me {
    public var videoPlaylists: VideoPlaylists {
        VideoPlaylists(path: path + "/video-playlists")
    }

    public struct VideoPlaylists {
        /// Path: `/users/me/video-playlists`
        public let path: String
    }
}

extension Paths.Users.Me.VideoPlaylists {
    public var videosExist: VideosExist {
        VideosExist(path: path + "/videos-exist")
    }

    public struct VideosExist {
        /// Path: `/users/me/video-playlists/videos-exist`
        public let path: String

        /// Check video exists in my playlists
        public func get(videoIDs: [String]) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(videoIDs))
        }

        public struct GetResponse: Decodable {
            public var videoID: [VideoIDItem]?

            public struct VideoIDItem: Decodable {
                public var playlistElementID: Int?
                public var playlistID: Int?
                public var startTimestamp: Int?
                public var stopTimestamp: Int?

                public init(playlistElementID: Int? = nil, playlistID: Int? = nil, startTimestamp: Int? = nil, stopTimestamp: Int? = nil) {
                    self.playlistElementID = playlistElementID
                    self.playlistID = playlistID
                    self.startTimestamp = startTimestamp
                    self.stopTimestamp = stopTimestamp
                }

                private enum CodingKeys: String, CodingKey {
                    case playlistElementID = "playlistElementId"
                    case playlistID = "playlistId"
                    case startTimestamp
                    case stopTimestamp
                }
            }

            public init(videoID: [VideoIDItem]? = nil) {
                self.videoID = videoID
            }

            private enum CodingKeys: String, CodingKey {
                case videoID = "videoId"
            }
        }

        private func makeGetQuery(_ videoIDs: [String]) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(videoIDs, forKey: "videoIds")
            return encoder.items
        }
    }
}

extension Paths.Accounts.WithName {
    public var videoChannels: VideoChannels {
        VideoChannels(path: path + "/video-channels")
    }

    public struct VideoChannels {
        /// Path: `/accounts/{name}/video-channels`
        public let path: String

        /// List video channels of an account
        public func get(parameters: GetParameters? = nil) -> Request<PeerTubeAPI.VideoChannelList> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isWithStats: Bool?
            public var start: Int?
            public var count: Int?
            /// Example: "-createdAt"
            public var sort: String?

            public init(isWithStats: Bool? = nil, start: Int? = nil, count: Int? = nil, sort: String? = nil) {
                self.isWithStats = isWithStats
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isWithStats, forKey: "withStats")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }
    }
}

extension Paths.Accounts.WithName {
    public var ratings: Ratings {
        Ratings(path: path + "/ratings")
    }

    public struct Ratings {
        /// Path: `/accounts/{name}/ratings`
        public let path: String

        /// List ratings of an account
        public func get(parameters: GetParameters? = nil) -> Request<[PeerTubeAPI.VideoRating]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var start: Int?
            public var count: Int?
            /// Example: "-createdAt"
            public var sort: String?
            public var rating: Rating?

            public enum Rating: String, Codable, CaseIterable {
                case like
                case dislike
            }

            public init(start: Int? = nil, count: Int? = nil, sort: String? = nil, rating: Rating? = nil) {
                self.start = start
                self.count = count
                self.sort = sort
                self.rating = rating
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                encoder.encode(rating, forKey: "rating")
                return encoder.items
            }
        }
    }
}

extension Paths.Videos.WithID {
    public var commentThreads: CommentThreads {
        CommentThreads(path: path + "/comment-threads")
    }

    public struct CommentThreads {
        /// Path: `/videos/{id}/comment-threads`
        public let path: String

        /// List threads of a video
        public func get(parameters: GetParameters? = nil) -> Request<PeerTubeAPI.CommentThreadResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var start: Int?
            public var count: Int?
            public var sort: Sort?

            public enum Sort: String, Codable, CaseIterable {
                case minuscreatedAt = "-createdAt"
                case minustotalReplies = "-totalReplies"
            }

            public init(start: Int? = nil, count: Int? = nil, sort: Sort? = nil) {
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }

        /// Create a thread
        public func post(text: AnyJSON) -> Request<PeerTubeAPI.CommentThreadPostResponse> {
            .post(path, body: ["text": text])
        }
    }
}

extension Paths.Videos.WithID.CommentThreads {
    public func threadID(_ threadID: Int) -> WithThreadID {
        WithThreadID(path: "\(path)/\(threadID)")
    }

    public struct WithThreadID {
        /// Path: `/videos/{id}/comment-threads/{threadId}`
        public let path: String

        /// Get a thread
        public var get: Request<PeerTubeAPI.VideoCommentThreadTree> {
            .get(path)
        }
    }
}

extension Paths.Videos.WithID {
    public var comments: Comments {
        Comments(path: path + "/comments")
    }

    public struct Comments {
        /// Path: `/videos/{id}/comments`
        public let path: String
    }
}

extension Paths.Videos.WithID.Comments {
    public func commentID(_ commentID: String) -> WithCommentID {
        WithCommentID(path: "\(path)/\(commentID)")
    }

    public struct WithCommentID {
        /// Path: `/videos/{id}/comments/{commentId}`
        public let path: String

        /// Reply to a thread of a video
        public func post(text: AnyJSON) -> Request<PeerTubeAPI.CommentThreadPostResponse> {
            .post(path, body: ["text": text])
        }

        /// Delete a comment or a reply
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Videos.WithID {
    public var rate: Rate {
        Rate(path: path + "/rate")
    }

    public struct Rate {
        /// Path: `/videos/{id}/rate`
        public let path: String

        /// Like/dislike a video
        public func put(rating: PutRequest.Rating) -> Request<Void> {
            .put(path, body: PutRequest(rating: rating))
        }

        public struct PutRequest: Encodable {
            public var rating: Rating

            public enum Rating: String, Codable, CaseIterable {
                case like
                case dislike
            }

            public init(rating: Rating) {
                self.rating = rating
            }
        }
    }
}

extension Paths.Videos.WithID {
    public var hls: Hls {
        Hls(path: path + "/hls")
    }

    public struct Hls {
        /// Path: `/videos/{id}/hls`
        public let path: String

        /// Delete video HLS files
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Videos.WithID {
    public var webtorrent: Webtorrent {
        Webtorrent(path: path + "/webtorrent")
    }

    public struct Webtorrent {
        /// Path: `/videos/{id}/webtorrent`
        public let path: String

        /// Delete video WebTorrent files
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Videos.WithID {
    public var transcoding: Transcoding {
        Transcoding(path: path + "/transcoding")
    }

    public struct Transcoding {
        /// Path: `/videos/{id}/transcoding`
        public let path: String

        /// Create a transcoding job
        public func post(transcodingType: PostRequest.TranscodingType) -> Request<Void> {
            .post(path, body: PostRequest(transcodingType: transcodingType))
        }

        public struct PostRequest: Encodable {
            public var transcodingType: TranscodingType

            public enum TranscodingType: String, Codable, CaseIterable {
                case hls
                case webtorrent
            }

            public init(transcodingType: TranscodingType) {
                self.transcodingType = transcodingType
            }
        }
    }
}

extension Paths {
    public static var search: Search {
        Search(path: "/search")
    }

    public struct Search {
        /// Path: `/search`
        public let path: String
    }
}

extension Paths.Search {
    public var videos: Videos {
        Videos(path: path + "/videos")
    }

    public struct Videos {
        /// Path: `/search/videos`
        public let path: String

        /// Search videos
        public func get(parameters: GetParameters) -> Request<PeerTubeAPI.VideoListResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var search: String
            public var categoryOneOf: CategoryOneOf?
            public var isLive: Bool?
            public var tagsOneOf: TagsOneOf?
            public var tagsAllOf: TagsAllOf?
            public var licenceOneOf: LicenceOneOf?
            public var languageOneOf: LanguageOneOf?
            public var nsfw: Nsfw?
            public var isLocal: Bool?
            public var include: Int?
            /// Privacy id of the video (see [/videos/privacies](#operation/getPrivacyPolicies))
            public var privacyOneOf: Int?
            public var hasHLSFiles: Bool?
            public var hasWebtorrentFiles: Bool?
            public var skipCount: SkipCount?
            public var start: Int?
            public var count: Int?
            public var searchTarget: SearchTarget?
            public var sort: Sort?
            public var startDate: Date?
            public var endDate: Date?
            public var originallyPublishedStartDate: Date?
            public var originallyPublishedEndDate: Date?
            public var durationMin: Int?
            public var durationMax: Int?

            public enum CategoryOneOf: Codable {
                case int(Int)
                case ints([Int])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .int(let value): encoder.encode(value, forKey: "value")
                    case .ints(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum TagsOneOf: Codable {
                case string(String)
                case strings([String])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .string(let value): encoder.encode(value, forKey: "value")
                    case .strings(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum TagsAllOf: Codable {
                case string(String)
                case strings([String])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .string(let value): encoder.encode(value, forKey: "value")
                    case .strings(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum LicenceOneOf: Codable {
                case int(Int)
                case ints([Int])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .int(let value): encoder.encode(value, forKey: "value")
                    case .ints(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum LanguageOneOf: Codable {
                case string(String)
                case strings([String])

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    switch self {
                    case .string(let value): encoder.encode(value, forKey: "value")
                    case .strings(let value): encoder.encode(value, forKey: "value")
                    }
                    return encoder.items
                }
            }

            public enum Nsfw: String, Codable, CaseIterable {
                case `true`
                case `false`
            }

            public enum SkipCount: String, Codable, CaseIterable {
                case `true`
                case `false`
            }

            public enum SearchTarget: String, Codable, CaseIterable {
                case local
                case searchIndex = "search-index"
            }

            public enum Sort: String, Codable, CaseIterable {
                case name
                case minusduration = "-duration"
                case minuscreatedAt = "-createdAt"
                case minuspublishedAt = "-publishedAt"
                case minusviews = "-views"
                case minuslikes = "-likes"
                case minusmatch = "-match"
            }

            public init(search: String, categoryOneOf: CategoryOneOf? = nil, isLive: Bool? = nil, tagsOneOf: TagsOneOf? = nil, tagsAllOf: TagsAllOf? = nil, licenceOneOf: LicenceOneOf? = nil, languageOneOf: LanguageOneOf? = nil, nsfw: Nsfw? = nil, isLocal: Bool? = nil, include: Int? = nil, privacyOneOf: Int? = nil, hasHLSFiles: Bool? = nil, hasWebtorrentFiles: Bool? = nil, skipCount: SkipCount? = nil, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget? = nil, sort: Sort? = nil, startDate: Date? = nil, endDate: Date? = nil, originallyPublishedStartDate: Date? = nil, originallyPublishedEndDate: Date? = nil, durationMin: Int? = nil, durationMax: Int? = nil) {
                self.search = search
                self.categoryOneOf = categoryOneOf
                self.isLive = isLive
                self.tagsOneOf = tagsOneOf
                self.tagsAllOf = tagsAllOf
                self.licenceOneOf = licenceOneOf
                self.languageOneOf = languageOneOf
                self.nsfw = nsfw
                self.isLocal = isLocal
                self.include = include
                self.privacyOneOf = privacyOneOf
                self.hasHLSFiles = hasHLSFiles
                self.hasWebtorrentFiles = hasWebtorrentFiles
                self.skipCount = skipCount
                self.start = start
                self.count = count
                self.searchTarget = searchTarget
                self.sort = sort
                self.startDate = startDate
                self.endDate = endDate
                self.originallyPublishedStartDate = originallyPublishedStartDate
                self.originallyPublishedEndDate = originallyPublishedEndDate
                self.durationMin = durationMin
                self.durationMax = durationMax
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(search, forKey: "search")
                encoder.encode(categoryOneOf, forKey: "categoryOneOf", explode: false)
                encoder.encode(isLive, forKey: "isLive")
                encoder.encode(tagsOneOf, forKey: "tagsOneOf", explode: false)
                encoder.encode(tagsAllOf, forKey: "tagsAllOf", explode: false)
                encoder.encode(licenceOneOf, forKey: "licenceOneOf", explode: false)
                encoder.encode(languageOneOf, forKey: "languageOneOf", explode: false)
                encoder.encode(nsfw, forKey: "nsfw")
                encoder.encode(isLocal, forKey: "isLocal")
                encoder.encode(include, forKey: "include")
                encoder.encode(privacyOneOf, forKey: "privacyOneOf")
                encoder.encode(hasHLSFiles, forKey: "hasHLSFiles")
                encoder.encode(hasWebtorrentFiles, forKey: "hasWebtorrentFiles")
                encoder.encode(skipCount, forKey: "skipCount")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(searchTarget, forKey: "searchTarget")
                encoder.encode(sort, forKey: "sort")
                encoder.encode(startDate, forKey: "startDate")
                encoder.encode(endDate, forKey: "endDate")
                encoder.encode(originallyPublishedStartDate, forKey: "originallyPublishedStartDate")
                encoder.encode(originallyPublishedEndDate, forKey: "originallyPublishedEndDate")
                encoder.encode(durationMin, forKey: "durationMin")
                encoder.encode(durationMax, forKey: "durationMax")
                return encoder.items
            }
        }
    }
}

extension Paths.Search {
    public var videoChannels: VideoChannels {
        VideoChannels(path: path + "/video-channels")
    }

    public struct VideoChannels {
        /// Path: `/search/video-channels`
        public let path: String

        /// Search channels
        public func get(parameters: GetParameters) -> Request<PeerTubeAPI.VideoChannelList> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var search: String
            public var start: Int?
            public var count: Int?
            public var searchTarget: SearchTarget?
            /// Example: "-createdAt"
            public var sort: String?

            public enum SearchTarget: String, Codable, CaseIterable {
                case local
                case searchIndex = "search-index"
            }

            public init(search: String, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget? = nil, sort: String? = nil) {
                self.search = search
                self.start = start
                self.count = count
                self.searchTarget = searchTarget
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(search, forKey: "search")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(searchTarget, forKey: "searchTarget")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }
    }
}

extension Paths.Search {
    public var videoPlaylists: VideoPlaylists {
        VideoPlaylists(path: path + "/video-playlists")
    }

    public struct VideoPlaylists {
        /// Path: `/search/video-playlists`
        public let path: String

        /// Search playlists
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            public var total: Int?
            public var data: [PeerTubeAPI.VideoPlaylist]?

            public init(total: Int? = nil, data: [PeerTubeAPI.VideoPlaylist]? = nil) {
                self.total = total
                self.data = data
            }
        }

        public struct GetParameters {
            public var search: String
            public var start: Int?
            public var count: Int?
            public var searchTarget: SearchTarget?
            /// Example: "-createdAt"
            public var sort: String?

            public enum SearchTarget: String, Codable, CaseIterable {
                case local
                case searchIndex = "search-index"
            }

            public init(search: String, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget? = nil, sort: String? = nil) {
                self.search = search
                self.start = start
                self.count = count
                self.searchTarget = searchTarget
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(search, forKey: "search")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(searchTarget, forKey: "searchTarget")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var blocklist: Blocklist {
        Blocklist(path: "/blocklist")
    }

    public struct Blocklist {
        /// Path: `/blocklist`
        public let path: String
    }
}

extension Paths.Blocklist {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/blocklist/status`
        public let path: String

        /// Get block status of accounts/hosts
        public func get(accounts: [String]? = nil, hosts: [String]? = nil) -> Request<PeerTubeAPI.BlockStatus> {
            .get(path, query: makeGetQuery(accounts, hosts))
        }

        private func makeGetQuery(_ accounts: [String]?, _ hosts: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(accounts, forKey: "accounts")
            encoder.encode(hosts, forKey: "hosts")
            return encoder.items
        }
    }
}

extension Paths.Server {
    public var blocklist: Blocklist {
        Blocklist(path: path + "/blocklist")
    }

    public struct Blocklist {
        /// Path: `/server/blocklist`
        public let path: String
    }
}

extension Paths.Server.Blocklist {
    public var accounts: Accounts {
        Accounts(path: path + "/accounts")
    }

    public struct Accounts {
        /// Path: `/server/blocklist/accounts`
        public let path: String

        /// List account blocks
        public func get(parameters: GetParameters? = nil) -> Request<Void> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var start: Int?
            public var count: Int?
            /// Example: "-createdAt"
            public var sort: String?

            public init(start: Int? = nil, count: Int? = nil, sort: String? = nil) {
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }

        /// Block an account
        public func post(accountName: String) -> Request<Void> {
            .post(path, body: ["accountName": accountName])
        }
    }
}

extension Paths.Server.Blocklist.Accounts {
    public func accountName(_ accountName: String) -> WithAccountName {
        WithAccountName(path: "\(path)/\(accountName)")
    }

    public struct WithAccountName {
        /// Path: `/server/blocklist/accounts/{accountName}`
        public let path: String

        /// Unblock an account by its handle
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Server.Blocklist {
    public var servers: Servers {
        Servers(path: path + "/servers")
    }

    public struct Servers {
        /// Path: `/server/blocklist/servers`
        public let path: String

        /// List server blocks
        public func get(parameters: GetParameters? = nil) -> Request<Void> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var start: Int?
            public var count: Int?
            /// Example: "-createdAt"
            public var sort: String?

            public init(start: Int? = nil, count: Int? = nil, sort: String? = nil) {
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }

        /// Block a server
        public func post(host: String) -> Request<Void> {
            .post(path, body: ["host": host])
        }
    }
}

extension Paths.Server.Blocklist.Servers {
    public func host(_ host: String) -> WithHost {
        WithHost(path: "\(path)/\(host)")
    }

    public struct WithHost {
        /// Path: `/server/blocklist/servers/{host}`
        public let path: String

        /// Unblock a server by its domain
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Server {
    public var redundancy: Redundancy {
        Redundancy(path: path + "/redundancy")
    }

    public struct Redundancy {
        /// Path: `/server/redundancy`
        public let path: String
    }
}

extension Paths.Server.Redundancy {
    public func host(_ host: String) -> WithHost {
        WithHost(path: "\(path)/\(host)")
    }

    public struct WithHost {
        /// Path: `/server/redundancy/{host}`
        public let path: String

        /// Update a server redundancy policy
        public func put(isRedundancyAllowed: Bool) -> Request<Void> {
            .put(path, body: ["redundancyAllowed": isRedundancyAllowed])
        }
    }
}

extension Paths.Server.Redundancy {
    public var videos: Videos {
        Videos(path: path + "/videos")
    }

    public struct Videos {
        /// Path: `/server/redundancy/videos`
        public let path: String

        /// List videos being mirrored
        public func get(parameters: GetParameters) -> Request<[PeerTubeAPI.VideoRedundancy]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var target: Target
            public var start: Int?
            public var count: Int?
            public var sort: Sort?

            public enum Target: String, Codable, CaseIterable {
                case myVideos = "my-videos"
                case remoteVideos = "remote-videos"
            }

            public enum Sort: String, Codable, CaseIterable {
                case name
            }

            public init(target: Target, start: Int? = nil, count: Int? = nil, sort: Sort? = nil) {
                self.target = target
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(target, forKey: "target")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }

        /// Mirror a video
        public func post(videoID: AnyJSON) -> Request<Void> {
            .post(path, body: ["videoId": videoID])
        }
    }
}

extension Paths.Server.Redundancy.Videos {
    public func redundancyID(_ redundancyID: String) -> WithRedundancyID {
        WithRedundancyID(path: "\(path)/\(redundancyID)")
    }

    public struct WithRedundancyID {
        /// Path: `/server/redundancy/videos/{redundancyId}`
        public let path: String

        /// Delete a mirror done on a video
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var feeds: Feeds {
        Feeds(path: "/feeds")
    }

    public struct Feeds {
        /// Path: `/feeds`
        public let path: String
    }
}

extension Paths.Feeds {
    public func format(_ format: String) -> WithVideoComments {
        WithVideoComments(path: "\(path)/video-comments.\(format)")
    }

    public struct WithVideoComments {
        /// Path: `/feeds/video-comments.{format}`
        public let path: String

        /// List comments on videos
        public func get(parameters: GetParameters? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters?.asQuery)
        }

        public enum GetResponseHeaders {
            public static let cacheControl = HTTPHeader<String>(field: "Cache-Control")
        }

        public struct GetParameters {
            public var videoID: String?
            public var accountID: String?
            public var accountName: String?
            public var videoChannelID: String?
            public var videoChannelName: String?

            public init(videoID: String? = nil, accountID: String? = nil, accountName: String? = nil, videoChannelID: String? = nil, videoChannelName: String? = nil) {
                self.videoID = videoID
                self.accountID = accountID
                self.accountName = accountName
                self.videoChannelID = videoChannelID
                self.videoChannelName = videoChannelName
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(videoID, forKey: "videoId")
                encoder.encode(accountID, forKey: "accountId")
                encoder.encode(accountName, forKey: "accountName")
                encoder.encode(videoChannelID, forKey: "videoChannelId")
                encoder.encode(videoChannelName, forKey: "videoChannelName")
                return encoder.items
            }
        }
    }
}

extension Paths.Feeds {
    public func format(_ format: String) -> WithVideos {
        WithVideos(path: "\(path)/videos.\(format)")
    }

    public struct WithVideos {
        /// Path: `/feeds/videos.{format}`
        public let path: String

        /// List videos
        public func get(parameters: GetParameters? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters?.asQuery)
        }

        public enum GetResponseHeaders {
            public static let cacheControl = HTTPHeader<String>(field: "Cache-Control")
        }

        public struct GetParameters {
            public var accountID: String?
            public var accountName: String?
            public var videoChannelID: String?
            public var videoChannelName: String?
            /// Example: "-createdAt"
            public var sort: String?
            public var nsfw: Nsfw?
            public var isLocal: Bool?
            public var include: Int?
            /// Privacy id of the video (see [/videos/privacies](#operation/getPrivacyPolicies))
            public var privacyOneOf: Int?
            public var hasHLSFiles: Bool?
            public var hasWebtorrentFiles: Bool?

            public enum Nsfw: String, Codable, CaseIterable {
                case `true`
                case `false`
            }

            public init(accountID: String? = nil, accountName: String? = nil, videoChannelID: String? = nil, videoChannelName: String? = nil, sort: String? = nil, nsfw: Nsfw? = nil, isLocal: Bool? = nil, include: Int? = nil, privacyOneOf: Int? = nil, hasHLSFiles: Bool? = nil, hasWebtorrentFiles: Bool? = nil) {
                self.accountID = accountID
                self.accountName = accountName
                self.videoChannelID = videoChannelID
                self.videoChannelName = videoChannelName
                self.sort = sort
                self.nsfw = nsfw
                self.isLocal = isLocal
                self.include = include
                self.privacyOneOf = privacyOneOf
                self.hasHLSFiles = hasHLSFiles
                self.hasWebtorrentFiles = hasWebtorrentFiles
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(accountID, forKey: "accountId")
                encoder.encode(accountName, forKey: "accountName")
                encoder.encode(videoChannelID, forKey: "videoChannelId")
                encoder.encode(videoChannelName, forKey: "videoChannelName")
                encoder.encode(sort, forKey: "sort")
                encoder.encode(nsfw, forKey: "nsfw")
                encoder.encode(isLocal, forKey: "isLocal")
                encoder.encode(include, forKey: "include")
                encoder.encode(privacyOneOf, forKey: "privacyOneOf")
                encoder.encode(hasHLSFiles, forKey: "hasHLSFiles")
                encoder.encode(hasWebtorrentFiles, forKey: "hasWebtorrentFiles")
                return encoder.items
            }
        }
    }
}

extension Paths.Feeds {
    public func format(_ format: String) -> WithSubscriptions {
        WithSubscriptions(path: "\(path)/subscriptions.\(format)")
    }

    public struct WithSubscriptions {
        /// Path: `/feeds/subscriptions.{format}`
        public let path: String

        /// List videos of subscriptions tied to a token
        public func get(parameters: GetParameters) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters.asQuery)
        }

        public enum GetResponseHeaders {
            public static let cacheControl = HTTPHeader<String>(field: "Cache-Control")
        }

        public struct GetParameters {
            public var accountID: String
            public var token: String
            /// Example: "-createdAt"
            public var sort: String?
            public var nsfw: Nsfw?
            public var isLocal: Bool?
            public var include: Int?
            /// Privacy id of the video (see [/videos/privacies](#operation/getPrivacyPolicies))
            public var privacyOneOf: Int?
            public var hasHLSFiles: Bool?
            public var hasWebtorrentFiles: Bool?

            public enum Nsfw: String, Codable, CaseIterable {
                case `true`
                case `false`
            }

            public init(accountID: String, token: String, sort: String? = nil, nsfw: Nsfw? = nil, isLocal: Bool? = nil, include: Int? = nil, privacyOneOf: Int? = nil, hasHLSFiles: Bool? = nil, hasWebtorrentFiles: Bool? = nil) {
                self.accountID = accountID
                self.token = token
                self.sort = sort
                self.nsfw = nsfw
                self.isLocal = isLocal
                self.include = include
                self.privacyOneOf = privacyOneOf
                self.hasHLSFiles = hasHLSFiles
                self.hasWebtorrentFiles = hasWebtorrentFiles
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(accountID, forKey: "accountId")
                encoder.encode(token, forKey: "token")
                encoder.encode(sort, forKey: "sort")
                encoder.encode(nsfw, forKey: "nsfw")
                encoder.encode(isLocal, forKey: "isLocal")
                encoder.encode(include, forKey: "include")
                encoder.encode(privacyOneOf, forKey: "privacyOneOf")
                encoder.encode(hasHLSFiles, forKey: "hasHLSFiles")
                encoder.encode(hasWebtorrentFiles, forKey: "hasWebtorrentFiles")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var plugins: Plugins {
        Plugins(path: "/plugins")
    }

    public struct Plugins {
        /// Path: `/plugins`
        public let path: String

        /// List plugins
        public func get(parameters: GetParameters? = nil) -> Request<PeerTubeAPI.PluginResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var pluginType: Int?
            public var isUninstalled: Bool?
            public var start: Int?
            public var count: Int?
            /// Example: "-createdAt"
            public var sort: String?

            public init(pluginType: Int? = nil, isUninstalled: Bool? = nil, start: Int? = nil, count: Int? = nil, sort: String? = nil) {
                self.pluginType = pluginType
                self.isUninstalled = isUninstalled
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(pluginType, forKey: "pluginType")
                encoder.encode(isUninstalled, forKey: "uninstalled")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }
    }
}

extension Paths.Plugins {
    public var available: Available {
        Available(path: path + "/available")
    }

    public struct Available {
        /// Path: `/plugins/available`
        public let path: String

        /// List available plugins
        public func get(parameters: GetParameters? = nil) -> Request<PeerTubeAPI.PluginResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var search: String?
            public var pluginType: Int?
            public var currentPeerTubeEngine: String?
            public var start: Int?
            public var count: Int?
            /// Example: "-createdAt"
            public var sort: String?

            public init(search: String? = nil, pluginType: Int? = nil, currentPeerTubeEngine: String? = nil, start: Int? = nil, count: Int? = nil, sort: String? = nil) {
                self.search = search
                self.pluginType = pluginType
                self.currentPeerTubeEngine = currentPeerTubeEngine
                self.start = start
                self.count = count
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(search, forKey: "search")
                encoder.encode(pluginType, forKey: "pluginType")
                encoder.encode(currentPeerTubeEngine, forKey: "currentPeerTubeEngine")
                encoder.encode(start, forKey: "start")
                encoder.encode(count, forKey: "count")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }
    }
}

extension Paths.Plugins {
    public var install: Install {
        Install(path: path + "/install")
    }

    public struct Install {
        /// Path: `/plugins/install`
        public let path: String

        /// Install a plugin
        public func post(_ body: PostRequest? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        public enum PostRequest: Encodable {
            case a(A)
            case b(B)

            public struct A: Encodable {
                /// Example: "peertube-plugin-auth-ldap"
                public var npmName: String

                public init(npmName: String) {
                    self.npmName = npmName
                }
            }

            public struct B: Encodable {
                public var path: String

                public init(path: String) {
                    self.path = path
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .a(let value): try container.encode(value)
                case .b(let value): try container.encode(value)
                }
            }
        }
    }
}

extension Paths.Plugins {
    public var update: Update {
        Update(path: path + "/update")
    }

    public struct Update {
        /// Path: `/plugins/update`
        public let path: String

        /// Update a plugin
        public func post(_ body: PostRequest? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        public enum PostRequest: Encodable {
            case a(A)
            case b(B)

            public struct A: Encodable {
                /// Example: "peertube-plugin-auth-ldap"
                public var npmName: String

                public init(npmName: String) {
                    self.npmName = npmName
                }
            }

            public struct B: Encodable {
                public var path: String

                public init(path: String) {
                    self.path = path
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .a(let value): try container.encode(value)
                case .b(let value): try container.encode(value)
                }
            }
        }
    }
}

extension Paths.Plugins {
    public var uninstall: Uninstall {
        Uninstall(path: path + "/uninstall")
    }

    public struct Uninstall {
        /// Path: `/plugins/uninstall`
        public let path: String

        /// Uninstall a plugin
        public func post(npmName: String) -> Request<Void> {
            .post(path, body: ["npmName": npmName])
        }
    }
}

extension Paths.Plugins {
    public func npmName(_ npmName: String) -> WithNpmName {
        WithNpmName(path: "\(path)/\(npmName)")
    }

    public struct WithNpmName {
        /// Path: `/plugins/{npmName}`
        public let path: String

        /// Get a plugin
        public var get: Request<PeerTubeAPI.Plugin> {
            .get(path)
        }
    }
}

extension Paths.Plugins.WithNpmName {
    public var settings: Settings {
        Settings(path: path + "/settings")
    }

    public struct Settings {
        /// Path: `/plugins/{npmName}/settings`
        public let path: String

        /// Set a plugin's settings
        public func put(settings: [String: AnyJSON]? = nil) -> Request<Void> {
            .put(path, body: ["settings": settings])
        }
    }
}

extension Paths.Plugins.WithNpmName {
    public var publicSettings: PublicSettings {
        PublicSettings(path: path + "/public-settings")
    }

    public struct PublicSettings {
        /// Path: `/plugins/{npmName}/public-settings`
        public let path: String

        /// Get a plugin's public settings
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Plugins.WithNpmName {
    public var registeredSettings: RegisteredSettings {
        RegisteredSettings(path: path + "/registered-settings")
    }

    public struct RegisteredSettings {
        /// Path: `/plugins/{npmName}/registered-settings`
        public let path: String

        /// Get a plugin's registered settings
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

public enum Paths {}
