// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import NaiveDate

public struct VideoConstantNumberCategory: Codable {
    /// Category id of the video (see [/videos/categories](#operation/getCategories))
    ///
    /// Example: 15
    public var id: Int?
    /// Example: "Science & Technology"
    public var label: String?

    public init(id: Int? = nil, label: String? = nil) {
        self.id = id
        self.label = label
    }
}

public struct VideoConstantNumberLicence: Codable {
    /// Licence id of the video (see [/videos/licences](#operation/getLicences))
    public var id: Int?
    /// Example: "Attribution - Share Alike"
    public var label: String?

    public init(id: Int? = nil, label: String? = nil) {
        self.id = id
        self.label = label
    }
}

public struct VideoConstantStringLanguage: Codable {
    /// Language id of the video (see [/videos/languages](#operation/getLanguages))
    ///
    /// Example: "en"
    public var id: String?
    /// Example: "English"
    public var label: String?

    public init(id: String? = nil, label: String? = nil) {
        self.id = id
        self.label = label
    }
}

public struct VideoPlaylistPrivacyConstant: Codable {
    /// Video playlist privacy policy (see [/video-playlists/privacies])
    public var id: Int?
    public var label: String?

    public init(id: Int? = nil, label: String? = nil) {
        self.id = id
        self.label = label
    }
}

public struct VideoPlaylistTypeConstant: Codable {
    /// The video playlist type (Regular = `1`, Watch Later = `2`)
    public var id: Int?
    public var label: String?

    public init(id: Int? = nil, label: String? = nil) {
        self.id = id
        self.label = label
    }
}

public struct VideoPrivacyConstant: Codable {
    /// Privacy id of the video (see [/videos/privacies](#operation/getPrivacyPolicies))
    public var id: Int?
    public var label: String?

    public init(id: Int? = nil, label: String? = nil) {
        self.id = id
        self.label = label
    }
}

public struct BlockStatus: Codable {
    public var accounts: [String: Account]?
    public var hosts: [String: Host]?

    public struct Account: Codable {
        public var isBlockedByServer: Bool?
        public var isBlockedByUser: Bool?

        public init(isBlockedByServer: Bool? = nil, isBlockedByUser: Bool? = nil) {
            self.isBlockedByServer = isBlockedByServer
            self.isBlockedByUser = isBlockedByUser
        }

        private enum CodingKeys: String, CodingKey {
            case isBlockedByServer = "blockedByServer"
            case isBlockedByUser = "blockedByUser"
        }
    }

    public struct Host: Codable {
        public var isBlockedByServer: Bool?
        public var isBlockedByUser: Bool?

        public init(isBlockedByServer: Bool? = nil, isBlockedByUser: Bool? = nil) {
            self.isBlockedByServer = isBlockedByServer
            self.isBlockedByUser = isBlockedByUser
        }

        private enum CodingKeys: String, CodingKey {
            case isBlockedByServer = "blockedByServer"
            case isBlockedByUser = "blockedByUser"
        }
    }

    public init(accounts: [String: Account]? = nil, hosts: [String: Host]? = nil) {
        self.accounts = accounts
        self.hosts = hosts
    }
}

public enum NSFWPolicy: String, Codable, CaseIterable {
    case display
    case blur
    case doNotList = "do_not_list"
}

public struct VideoStateConstant: Codable {
    /// The video state (Published = `1`, to transcode = `2`, to import = `3`)
    public var id: Int?
    public var label: String?

    public init(id: Int? = nil, label: String? = nil) {
        self.id = id
        self.label = label
    }
}

public struct AbuseStateConstant: Codable {
    /// The abuse state (Pending = `1`, Rejected = `2`, Accepted = `3`)
    public var id: Int?
    public var label: String?

    public init(id: Int? = nil, label: String? = nil) {
        self.id = id
        self.label = label
    }
}

public enum AbusePredefinedReason: String, Codable, CaseIterable {
    case violentOrAbusive
    case hatefulOrAbusive
    case spamOrMisleading
    case privacy
    case rights
    case serverRules
    case thumbnails
    case captions
}

/// Resolutions and their labels for the video
public struct VideoResolutionConstant: Codable {
    /// Video resolution (`0`, `240`, `360`, `720`, `1080`, `1440` or `2160`)
    /// 
    /// `0` is used as a special value for stillimage videos dedicated to audio, a.k.a. audio-only videos.
    ///
    /// Example: 240
    public var id: Int?
    /// Example: "240p"
    public var label: String?

    public init(id: Int? = nil, label: String? = nil) {
        self.id = id
        self.label = label
    }
}

public struct VideoScheduledUpdate: Codable {
    /// Privacy id of the video (see [/videos/privacies](#operation/getPrivacyPolicies))
    public var privacy: Int?
    /// When to update the video
    public var updateAt: NaiveDate

    public init(privacy: Int? = nil, updateAt: NaiveDate) {
        self.privacy = privacy
        self.updateAt = updateAt
    }
}

public struct AccountSummary: Codable {
    public var id: Int?
    public var name: String?
    public var displayName: String?
    public var url: String?
    public var host: String?
    public var avatar: ActorImage?

    public init(id: Int? = nil, name: String? = nil, displayName: String? = nil, url: String? = nil, host: String? = nil, avatar: ActorImage? = nil) {
        self.id = id
        self.name = name
        self.displayName = displayName
        self.url = url
        self.host = host
        self.avatar = avatar
    }
}

public struct VideoChannelSummary: Codable {
    /// Example: 42
    public var id: Int?
    public var name: String?
    public var displayName: String?
    public var url: String?
    public var host: String?
    public var avatar: ActorImage?

    public init(id: Int? = nil, name: String? = nil, displayName: String? = nil, url: String? = nil, host: String? = nil, avatar: ActorImage? = nil) {
        self.id = id
        self.name = name
        self.displayName = displayName
        self.url = url
        self.host = host
        self.avatar = avatar
    }
}

public struct PlaylistElement: Codable {
    public var position: Int?
    public var startTimestamp: Int?
    public var stopTimestamp: Int?
    public var video: Video?

    public init(position: Int? = nil, startTimestamp: Int? = nil, stopTimestamp: Int? = nil, video: Video? = nil) {
        self.position = position
        self.startTimestamp = startTimestamp
        self.stopTimestamp = stopTimestamp
        self.video = video
    }
}

public struct VideoFile: Codable {
    /// Magnet URI allowing to resolve the video via BitTorrent without a metainfo file
    public var magnetUri: URL?
    /// Resolutions and their labels for the video
    public var resolution: VideoResolutionConstant?
    /// Video file size in bytes
    public var size: Int?
    /// Direct URL of the torrent file
    public var torrentURL: String?
    /// URL endpoint that transfers the torrent file as an attachment (so that the browser opens a download dialog)
    public var torrentDownloadURL: String?
    /// Direct URL of the video
    public var fileURL: String?
    /// URL endpoint that transfers the video file as an attachment (so that the browser opens a download dialog)
    public var fileDownloadURL: String?
    /// Frames per second of the video file
    public var fps: Double?
    /// URL dereferencing the output of ffprobe on the file
    public var metadataURL: String?

    public init(magnetUri: URL? = nil, resolution: VideoResolutionConstant? = nil, size: Int? = nil, torrentURL: String? = nil, torrentDownloadURL: String? = nil, fileURL: String? = nil, fileDownloadURL: String? = nil, fps: Double? = nil, metadataURL: String? = nil) {
        self.magnetUri = magnetUri
        self.resolution = resolution
        self.size = size
        self.torrentURL = torrentURL
        self.torrentDownloadURL = torrentDownloadURL
        self.fileURL = fileURL
        self.fileDownloadURL = fileDownloadURL
        self.fps = fps
        self.metadataURL = metadataURL
    }

    private enum CodingKeys: String, CodingKey {
        case magnetUri
        case resolution
        case size
        case torrentURL = "torrentUrl"
        case torrentDownloadURL = "torrentDownloadUrl"
        case fileURL = "fileUrl"
        case fileDownloadURL = "fileDownloadUrl"
        case fps
        case metadataURL = "metadataUrl"
    }
}

public struct VideoStreamingPlaylists: Codable {
    /// Example: 42
    public var id: Int?
    /// Playlist type:
    /// - `1`: HLS
    public var type: Int?
    public var videoStreamingPlaylistsHLS: VideoStreamingPlaylistsHLS

    public init(id: Int? = nil, type: Int? = nil, videoStreamingPlaylistsHLS: VideoStreamingPlaylistsHLS) {
        self.id = id
        self.type = type
        self.videoStreamingPlaylistsHLS = videoStreamingPlaylistsHLS
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.type = try values.decodeIfPresent(Int.self, forKey: "type")
        self.videoStreamingPlaylistsHLS = try VideoStreamingPlaylistsHLS(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encode(videoStreamingPlaylistsHLS, forKey: "videoStreamingPlaylistsHLS")
    }
}

public struct VideoStreamingPlaylistsHLS: Codable {
    public var playlistURL: String?
    public var segmentsSha256URL: String?
    /// Video files associated to this playlist.
    /// 
    /// The difference with the root `files` property is that these files are fragmented, so they can be used in this streaming playlist (HLS, etc.)
    public var files: [VideoFile]?
    public var redundancies: [Redundancy]?

    public struct Redundancy: Codable {
        public var baseURL: String?

        public init(baseURL: String? = nil) {
            self.baseURL = baseURL
        }

        private enum CodingKeys: String, CodingKey {
            case baseURL = "baseUrl"
        }
    }

    public init(playlistURL: String? = nil, segmentsSha256URL: String? = nil, files: [VideoFile]? = nil, redundancies: [Redundancy]? = nil) {
        self.playlistURL = playlistURL
        self.segmentsSha256URL = segmentsSha256URL
        self.files = files
        self.redundancies = redundancies
    }

    private enum CodingKeys: String, CodingKey {
        case playlistURL = "playlistUrl"
        case segmentsSha256URL = "segmentsSha256Url"
        case files
        case redundancies
    }
}

public struct VideoInfo: Codable {
    public var id: AnyJSON?
    public var uuid: AnyJSON?
    public var name: AnyJSON?

    public init(id: AnyJSON? = nil, uuid: AnyJSON? = nil, name: AnyJSON? = nil) {
        self.id = id
        self.uuid = uuid
        self.name = name
    }
}

public struct Video: Codable {
    /// Object id for the video
    public var id: Int?
    /// Universal identifier for the video, that can be used across instances
    public var uuid: String?
    public var shortUUID: String?
    public var isLive: Bool?
    /// Time at which the video object was first drafted
    ///
    /// Example: "2017-10-01T10:52:46.396Z"
    public var createdAt: Date?
    /// Time at which the video was marked as ready for playback (with restrictions depending on `privacy`). Usually set after a `state` evolution.
    ///
    /// Example: "2018-10-01T10:52:46.396Z"
    public var publishedAt: Date?
    /// Last time the video's metadata was modified
    ///
    /// Example: "2021-05-04T08:01:01.502Z"
    public var updatedAt: Date?
    /// Used to represent a date of first publication, prior to the practical publication date of `publishedAt`
    ///
    /// Example: "2010-10-01T10:52:46.396Z"
    public var originallyPublishedAt: Date?
    /// Category in which the video is classified
    public var category: VideoConstantNumberCategory?
    /// Licence under which the video is distributed
    public var licence: VideoConstantNumberLicence?
    /// Main language used in the video
    public var language: VideoConstantStringLanguage?
    /// Privacy policy used to distribute the video
    public var privacy: VideoPrivacyConstant?
    /// Truncated description of the video, written in Markdown.
    /// Resolve `descriptionPath` to get the full description of maximum `10000` characters.
    ///
    /// Example:
    ///
    /// "**[Want to help to translate this video?](https://weblate.framasoft.org/projects/what-is-peertube-video/)**\r\n\r\n
    /// **Take back the control of your videos! [#JoinPeertube](https://joinpeertube.org)**\r\n*A decentralized video hosting network, based on fr...
    /// "
    public var description: String?
    /// Duration of the video in seconds
    ///
    /// Example: 1419
    public var duration: Int?
    public var isLocal: Bool?
    /// Title of the video
    ///
    /// Example: "What is PeerTube?"
    public var name: String?
    /// Example: "/static/thumbnails/a65bc12f-9383-462e-81ae-8207e8b434ee.jpg"
    public var thumbnailPath: String?
    /// Example: "/lazy-static/previews/a65bc12f-9383-462e-81ae-8207e8b434ee.jpg"
    public var previewPath: String?
    /// Example: "/videos/embed/a65bc12f-9383-462e-81ae-8207e8b434ee"
    public var embedPath: String?
    /// Example: 1337
    public var views: Int?
    /// Example: 42
    public var likes: Int?
    public var dislikes: Int?
    public var isNsfw: Bool?
    public var isWaitTranscoding: Bool?
    /// Represents the internal state of the video processing within the PeerTube instance
    public var state: VideoStateConstant?
    public var scheduledUpdate: VideoScheduledUpdate?
    public var isBlacklisted: Bool?
    public var blacklistedReason: String?
    public var account: AccountSummary?
    public var channel: VideoChannelSummary?
    public var userHistory: UserHistory?

    public struct UserHistory: Codable {
        public var currentTime: Int?

        public init(currentTime: Int? = nil) {
            self.currentTime = currentTime
        }
    }

    public init(id: Int? = nil, uuid: String? = nil, shortUUID: String? = nil, isLive: Bool? = nil, createdAt: Date? = nil, publishedAt: Date? = nil, updatedAt: Date? = nil, originallyPublishedAt: Date? = nil, category: VideoConstantNumberCategory? = nil, licence: VideoConstantNumberLicence? = nil, language: VideoConstantStringLanguage? = nil, privacy: VideoPrivacyConstant? = nil, description: String? = nil, duration: Int? = nil, isLocal: Bool? = nil, name: String? = nil, thumbnailPath: String? = nil, previewPath: String? = nil, embedPath: String? = nil, views: Int? = nil, likes: Int? = nil, dislikes: Int? = nil, isNsfw: Bool? = nil, isWaitTranscoding: Bool? = nil, state: VideoStateConstant? = nil, scheduledUpdate: VideoScheduledUpdate? = nil, isBlacklisted: Bool? = nil, blacklistedReason: String? = nil, account: AccountSummary? = nil, channel: VideoChannelSummary? = nil, userHistory: UserHistory? = nil) {
        self.id = id
        self.uuid = uuid
        self.shortUUID = shortUUID
        self.isLive = isLive
        self.createdAt = createdAt
        self.publishedAt = publishedAt
        self.updatedAt = updatedAt
        self.originallyPublishedAt = originallyPublishedAt
        self.category = category
        self.licence = licence
        self.language = language
        self.privacy = privacy
        self.description = description
        self.duration = duration
        self.isLocal = isLocal
        self.name = name
        self.thumbnailPath = thumbnailPath
        self.previewPath = previewPath
        self.embedPath = embedPath
        self.views = views
        self.likes = likes
        self.dislikes = dislikes
        self.isNsfw = isNsfw
        self.isWaitTranscoding = isWaitTranscoding
        self.state = state
        self.scheduledUpdate = scheduledUpdate
        self.isBlacklisted = isBlacklisted
        self.blacklistedReason = blacklistedReason
        self.account = account
        self.channel = channel
        self.userHistory = userHistory
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case uuid
        case shortUUID
        case isLive
        case createdAt
        case publishedAt
        case updatedAt
        case originallyPublishedAt
        case category
        case licence
        case language
        case privacy
        case description
        case duration
        case isLocal
        case name
        case thumbnailPath
        case previewPath
        case embedPath
        case views
        case likes
        case dislikes
        case isNsfw = "nsfw"
        case isWaitTranscoding = "waitTranscoding"
        case state
        case scheduledUpdate
        case isBlacklisted = "blacklisted"
        case blacklistedReason
        case account
        case channel
        case userHistory
    }
}

public struct VideoDetails: Codable {
    public var video: Video
    /// If the video is a live, you have the amount of current viewers
    public var viewers: Int?
    /// Path at which to get the full description of maximum `10000` characters
    ///
    /// Example: "/api/v1/videos/9c9de5e8-0a1e-484a-b099-e80766180a6d/description"
    public var descriptionPath: String?
    /// A text tell the audience how to support the video creator
    ///
    /// Example: "Please support our work on https://soutenir.framasoft.org/en/ <3"
    public var support: String?
    public var channel: VideoChannel?
    public var account: Account?
    /// Example: ["flowers", "gardening"]
    public var tags: [String]?
    public var isCommentsEnabled: Bool?
    public var isDownloadEnabled: Bool?
    /// Example: ["https://peertube2.cpy.re/tracker/announce", "wss://peertube2.cpy.re/tracker/socket"]
    public var trackerURLs: [String]?
    /// WebTorrent/raw video files. If WebTorrent is disabled on the server:
    /// 
    /// - field will be empty
    /// - video files will be found in `streamingPlaylists[].files` field
    public var files: [VideoFile]?
    /// HLS playlists/manifest files. If HLS is disabled on the server:
    /// 
    /// - field will be empty
    /// - video files will be found in `files` field
    public var streamingPlaylists: [VideoStreamingPlaylists]?

    public init(video: Video, viewers: Int? = nil, descriptionPath: String? = nil, support: String? = nil, channel: VideoChannel? = nil, account: Account? = nil, tags: [String]? = nil, isCommentsEnabled: Bool? = nil, isDownloadEnabled: Bool? = nil, trackerURLs: [String]? = nil, files: [VideoFile]? = nil, streamingPlaylists: [VideoStreamingPlaylists]? = nil) {
        self.video = video
        self.viewers = viewers
        self.descriptionPath = descriptionPath
        self.support = support
        self.channel = channel
        self.account = account
        self.tags = tags
        self.isCommentsEnabled = isCommentsEnabled
        self.isDownloadEnabled = isDownloadEnabled
        self.trackerURLs = trackerURLs
        self.files = files
        self.streamingPlaylists = streamingPlaylists
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.video = try Video(from: decoder)
        self.viewers = try values.decodeIfPresent(Int.self, forKey: "viewers")
        self.descriptionPath = try values.decodeIfPresent(String.self, forKey: "descriptionPath")
        self.support = try values.decodeIfPresent(String.self, forKey: "support")
        self.channel = try VideoChannel(from: decoder)
        self.account = try Account(from: decoder)
        self.tags = try values.decodeIfPresent([String].self, forKey: "tags")
        self.isCommentsEnabled = try values.decodeIfPresent(Bool.self, forKey: "commentsEnabled")
        self.isDownloadEnabled = try values.decodeIfPresent(Bool.self, forKey: "downloadEnabled")
        self.trackerURLs = try values.decodeIfPresent([String].self, forKey: "trackerUrls")
        self.files = try values.decodeIfPresent([VideoFile].self, forKey: "files")
        self.streamingPlaylists = try values.decodeIfPresent([VideoStreamingPlaylists].self, forKey: "streamingPlaylists")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(video, forKey: "video")
        try values.encodeIfPresent(viewers, forKey: "viewers")
        try values.encodeIfPresent(descriptionPath, forKey: "descriptionPath")
        try values.encodeIfPresent(support, forKey: "support")
        try values.encodeIfPresent(channel, forKey: "channel")
        try values.encodeIfPresent(account, forKey: "account")
        try values.encodeIfPresent(tags, forKey: "tags")
        try values.encodeIfPresent(isCommentsEnabled, forKey: "commentsEnabled")
        try values.encodeIfPresent(isDownloadEnabled, forKey: "downloadEnabled")
        try values.encodeIfPresent(trackerURLs, forKey: "trackerUrls")
        try values.encodeIfPresent(files, forKey: "files")
        try values.encodeIfPresent(streamingPlaylists, forKey: "streamingPlaylists")
    }
}

public struct FileRedundancyInformation: Codable {
    /// Example: 42
    public var id: Int?
    public var fileURL: String?
    public var strategy: Strategy?
    public var size: Int?
    public var createdAt: Date?
    public var updatedAt: Date?
    public var expiresOn: Date?

    public enum Strategy: String, Codable, CaseIterable {
        case manual
        case mostViews = "most-views"
        case trending
        case recentlyAdded = "recently-added"
    }

    public init(id: Int? = nil, fileURL: String? = nil, strategy: Strategy? = nil, size: Int? = nil, createdAt: Date? = nil, updatedAt: Date? = nil, expiresOn: Date? = nil) {
        self.id = id
        self.fileURL = fileURL
        self.strategy = strategy
        self.size = size
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.expiresOn = expiresOn
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case fileURL = "fileUrl"
        case strategy
        case size
        case createdAt
        case updatedAt
        case expiresOn
    }
}

public struct VideoRedundancy: Codable {
    /// Example: 42
    public var id: Int?
    public var name: String?
    public var url: String?
    /// Example: "9c9de5e8-0a1e-484a-b099-e80766180a6d"
    public var uuid: String?
    public var redundancies: Redundancies?

    public struct Redundancies: Codable {
        public var files: [FileRedundancyInformation]?
        public var streamingPlaylists: [FileRedundancyInformation]?

        public init(files: [FileRedundancyInformation]? = nil, streamingPlaylists: [FileRedundancyInformation]? = nil) {
            self.files = files
            self.streamingPlaylists = streamingPlaylists
        }
    }

    public init(id: Int? = nil, name: String? = nil, url: String? = nil, uuid: String? = nil, redundancies: Redundancies? = nil) {
        self.id = id
        self.name = name
        self.url = url
        self.uuid = uuid
        self.redundancies = redundancies
    }
}

public struct VideoImportStateConstant: Codable {
    /// The video import state (Pending = `1`, Success = `2`, Failed = `3`)
    public var id: Int?
    /// Example: "Pending"
    public var label: String?

    public init(id: Int? = nil, label: String? = nil) {
        self.id = id
        self.label = label
    }
}

public struct VideoCreateImport: Codable {
    public var object: Object
    public var videoUploadRequestCommon: VideoUploadRequestCommon

    public enum Object: Codable {
        case a(A)
        case b(B)
        case c(C)

        public struct A: Codable {
            public var targetURL: AnyJSON

            public init(targetURL: AnyJSON) {
                self.targetURL = targetURL
            }

            private enum CodingKeys: String, CodingKey {
                case targetURL = "targetUrl"
            }
        }

        public struct B: Codable {
            public var magnetUri: AnyJSON

            public init(magnetUri: AnyJSON) {
                self.magnetUri = magnetUri
            }
        }

        public struct C: Codable {
            public var torrentfile: AnyJSON

            public init(torrentfile: AnyJSON) {
                self.torrentfile = torrentfile
            }
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(A.self) {
                self = .a(value)
            } else if let value = try? container.decode(B.self) {
                self = .b(value)
            } else if let value = try? container.decode(C.self) {
                self = .c(value)
            } else {
                throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .a(let value): try container.encode(value)
            case .b(let value): try container.encode(value)
            case .c(let value): try container.encode(value)
            }
        }
    }

    public init(object: Object, videoUploadRequestCommon: VideoUploadRequestCommon) {
        self.object = object
        self.videoUploadRequestCommon = videoUploadRequestCommon
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.videoUploadRequestCommon = try VideoUploadRequestCommon(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encode(videoUploadRequestCommon, forKey: "videoUploadRequestCommon")
    }
}

public struct VideoImport: Codable {
    public var id: Int?
    /// Remote URL where to find the import's source video
    ///
    /// Example: "https://framatube.org/videos/watch/9c9de5e8-0a1e-484a-b099-e80766180a6d"
    public var targetURL: String?
    /// Magnet URI allowing to resolve the import's source video
    public var magnetUri: URL?
    /// Torrent file containing only the video file
    public var torrentfile: String?
    public var torrentName: String?
    public var state: VideoImportStateConstant?
    public var error: String?
    public var createdAt: Date?
    public var updatedAt: Date?
    public var video: Video?

    public init(id: Int? = nil, targetURL: String? = nil, magnetUri: URL? = nil, torrentfile: String? = nil, torrentName: String? = nil, state: VideoImportStateConstant? = nil, error: String? = nil, createdAt: Date? = nil, updatedAt: Date? = nil, video: Video? = nil) {
        self.id = id
        self.targetURL = targetURL
        self.magnetUri = magnetUri
        self.torrentfile = torrentfile
        self.torrentName = torrentName
        self.state = state
        self.error = error
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.video = video
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case targetURL = "targetUrl"
        case magnetUri
        case torrentfile
        case torrentName
        case state
        case error
        case createdAt
        case updatedAt
        case video
    }
}

public struct VideoImportsList: Codable {
    public var total: Int?
    public var data: [VideoImport]?

    public init(total: Int? = nil, data: [VideoImport]? = nil) {
        self.total = total
        self.data = data
    }
}

public struct Abuse: Codable {
    /// Example: 42
    public var id: Int?
    /// Example: "The video is a spam"
    public var reason: String?
    /// Example: ["spamOrMisleading"]
    public var predefinedReasons: [AbusePredefinedReason]?
    public var reporterAccount: Account?
    public var state: AbuseStateConstant?
    /// Example: "Decided to ban the server since it spams us regularly"
    public var moderationComment: String?
    public var video: VideoInfo?
    public var createdAt: Date?

    public init(id: Int? = nil, reason: String? = nil, predefinedReasons: [AbusePredefinedReason]? = nil, reporterAccount: Account? = nil, state: AbuseStateConstant? = nil, moderationComment: String? = nil, video: VideoInfo? = nil, createdAt: Date? = nil) {
        self.id = id
        self.reason = reason
        self.predefinedReasons = predefinedReasons
        self.reporterAccount = reporterAccount
        self.state = state
        self.moderationComment = moderationComment
        self.video = video
        self.createdAt = createdAt
    }
}

public struct AbuseMessage: Codable {
    /// Example: 42
    public var id: Int?
    public var message: String?
    public var isByModerator: Bool?
    public var createdAt: Date?
    public var account: AccountSummary?

    public init(id: Int? = nil, message: String? = nil, isByModerator: Bool? = nil, createdAt: Date? = nil, account: AccountSummary? = nil) {
        self.id = id
        self.message = message
        self.isByModerator = isByModerator
        self.createdAt = createdAt
        self.account = account
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case message
        case isByModerator = "byModerator"
        case createdAt
        case account
    }
}

public struct VideoBlacklist: Codable {
    /// Example: 42
    public var id: Int?
    public var videoID: AnyJSON?
    public var createdAt: Date?
    public var updatedAt: Date?
    public var name: String?
    /// Example: "9c9de5e8-0a1e-484a-b099-e80766180a6d"
    public var uuid: String?
    public var description: String?
    public var duration: Int?
    public var views: Int?
    public var likes: Int?
    public var dislikes: Int?
    public var isNsfw: Bool?

    public init(id: Int? = nil, videoID: AnyJSON? = nil, createdAt: Date? = nil, updatedAt: Date? = nil, name: String? = nil, uuid: String? = nil, description: String? = nil, duration: Int? = nil, views: Int? = nil, likes: Int? = nil, dislikes: Int? = nil, isNsfw: Bool? = nil) {
        self.id = id
        self.videoID = videoID
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.name = name
        self.uuid = uuid
        self.description = description
        self.duration = duration
        self.views = views
        self.likes = likes
        self.dislikes = dislikes
        self.isNsfw = isNsfw
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case videoID = "videoId"
        case createdAt
        case updatedAt
        case name
        case uuid
        case description
        case duration
        case views
        case likes
        case dislikes
        case isNsfw = "nsfw"
    }
}

public struct VideoPlaylist: Codable {
    /// Example: 42
    public var id: Int?
    /// Example: "9c9de5e8-0a1e-484a-b099-e80766180a6d"
    public var uuid: String?
    public var shortUUID: String?
    public var createdAt: Date?
    public var updatedAt: Date?
    public var description: String?
    public var displayName: String?
    public var isLocal: Bool?
    public var videoLength: Int?
    public var thumbnailPath: String?
    public var privacy: VideoPlaylistPrivacyConstant?
    public var type: VideoPlaylistTypeConstant?
    public var ownerAccount: AccountSummary?
    public var videoChannel: VideoChannelSummary?

    public init(id: Int? = nil, uuid: String? = nil, shortUUID: String? = nil, createdAt: Date? = nil, updatedAt: Date? = nil, description: String? = nil, displayName: String? = nil, isLocal: Bool? = nil, videoLength: Int? = nil, thumbnailPath: String? = nil, privacy: VideoPlaylistPrivacyConstant? = nil, type: VideoPlaylistTypeConstant? = nil, ownerAccount: AccountSummary? = nil, videoChannel: VideoChannelSummary? = nil) {
        self.id = id
        self.uuid = uuid
        self.shortUUID = shortUUID
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.description = description
        self.displayName = displayName
        self.isLocal = isLocal
        self.videoLength = videoLength
        self.thumbnailPath = thumbnailPath
        self.privacy = privacy
        self.type = type
        self.ownerAccount = ownerAccount
        self.videoChannel = videoChannel
    }
}

public struct VideoComment: Codable {
    /// Example: 42
    public var id: Int?
    public var url: String?
    /// Text of the comment
    ///
    /// Example: "This video is wonderful!"
    public var text: String?
    /// Example: 42
    public var threadID: Int?
    public var inReplyToCommentID: Int?
    public var videoID: AnyJSON?
    public var createdAt: Date?
    public var updatedAt: Date?
    public var deletedAt: Date?
    public var isDeleted: Bool
    public var totalRepliesFromVideoAuthor: Int?
    public var totalReplies: Int?
    public var account: Account?

    public init(id: Int? = nil, url: String? = nil, text: String? = nil, threadID: Int? = nil, inReplyToCommentID: Int? = nil, videoID: AnyJSON? = nil, createdAt: Date? = nil, updatedAt: Date? = nil, deletedAt: Date? = nil, isDeleted: Bool? = nil, totalRepliesFromVideoAuthor: Int? = nil, totalReplies: Int? = nil, account: Account? = nil) {
        self.id = id
        self.url = url
        self.text = text
        self.threadID = threadID
        self.inReplyToCommentID = inReplyToCommentID
        self.videoID = videoID
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.deletedAt = deletedAt
        self.isDeleted = isDeleted ?? false
        self.totalRepliesFromVideoAuthor = totalRepliesFromVideoAuthor
        self.totalReplies = totalReplies
        self.account = account
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case url
        case text
        case threadID = "threadId"
        case inReplyToCommentID = "inReplyToCommentId"
        case videoID = "videoId"
        case createdAt
        case updatedAt
        case deletedAt
        case isDeleted
        case totalRepliesFromVideoAuthor
        case totalReplies
        case account
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.id = try values.decodeIfPresent(Int.self, forKey: .id)
        self.url = try values.decodeIfPresent(String.self, forKey: .url)
        self.text = try values.decodeIfPresent(String.self, forKey: .text)
        self.threadID = try values.decodeIfPresent(Int.self, forKey: .threadID)
        self.inReplyToCommentID = try values.decodeIfPresent(Int.self, forKey: .inReplyToCommentID)
        self.videoID = try values.decodeIfPresent(AnyJSON.self, forKey: .videoID)
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: .createdAt)
        self.updatedAt = try values.decodeIfPresent(Date.self, forKey: .updatedAt)
        self.deletedAt = try values.decodeIfPresent(Date.self, forKey: .deletedAt)
        self.isDeleted = try values.decodeIfPresent(Bool.self, forKey: .isDeleted) ?? false
        self.totalRepliesFromVideoAuthor = try values.decodeIfPresent(Int.self, forKey: .totalRepliesFromVideoAuthor)
        self.totalReplies = try values.decodeIfPresent(Int.self, forKey: .totalReplies)
        self.account = try values.decodeIfPresent(Account.self, forKey: .account)
    }
}

public struct VideoCommentThreadTree: Codable {
    public var comment: VideoComment?
    public var children: [VideoCommentThreadTree]?

    public init(comment: VideoComment? = nil, children: [VideoCommentThreadTree]? = nil) {
        self.comment = comment
        self.children = children
    }
}

public struct VideoCaption: Codable {
    public var language: VideoConstantStringLanguage?
    public var captionPath: String?

    public init(language: VideoConstantStringLanguage? = nil, captionPath: String? = nil) {
        self.language = language
        self.captionPath = captionPath
    }
}

public struct ActorImage: Codable {
    public var path: String?
    public var createdAt: Date?
    public var updatedAt: Date?

    public init(path: String? = nil, createdAt: Date? = nil, updatedAt: Date? = nil) {
        self.path = path
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }
}

public struct ActorInfo: Codable {
    /// Example: 42
    public var id: Int?
    public var name: String?
    public var displayName: String?
    public var host: String?
    public var avatar: Avatar?

    public struct Avatar: Codable {
        public var path: String?

        public init(path: String? = nil) {
            self.path = path
        }
    }

    public init(id: Int? = nil, name: String? = nil, displayName: String? = nil, host: String? = nil, avatar: Avatar? = nil) {
        self.id = id
        self.name = name
        self.displayName = displayName
        self.host = host
        self.avatar = avatar
    }
}

public struct Actor: Codable {
    /// Example: 42
    public var id: Int?
    public var url: String?
    /// Immutable name of the actor, used to find or mention it
    public var name: String?
    /// Server on which the actor is resident
    public var host: String?
    /// Whether this actor's host allows redundancy of its videos
    public var isHostRedundancyAllowed: Bool?
    /// Number of actors subscribed to by this actor, as seen by this instance
    public var followingCount: Int?
    /// Number of followers of this actor, as seen by this instance
    public var followersCount: Int?
    public var createdAt: Date?
    public var updatedAt: Date?
    public var avatar: ActorImage?

    public init(id: Int? = nil, url: String? = nil, name: String? = nil, host: String? = nil, isHostRedundancyAllowed: Bool? = nil, followingCount: Int? = nil, followersCount: Int? = nil, createdAt: Date? = nil, updatedAt: Date? = nil, avatar: ActorImage? = nil) {
        self.id = id
        self.url = url
        self.name = name
        self.host = host
        self.isHostRedundancyAllowed = isHostRedundancyAllowed
        self.followingCount = followingCount
        self.followersCount = followersCount
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.avatar = avatar
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case url
        case name
        case host
        case isHostRedundancyAllowed = "hostRedundancyAllowed"
        case followingCount
        case followersCount
        case createdAt
        case updatedAt
        case avatar
    }
}

public struct Account: Codable {
    public var actor: Actor
    /// Object id for the user tied to this account
    public var userID: AnyJSON?
    /// Editable name of the account, displayed in its representations
    public var displayName: String?
    /// Text or bio displayed on the account's profile
    public var description: String?

    public init(actor: Actor, userID: AnyJSON? = nil, displayName: String? = nil, description: String? = nil) {
        self.actor = actor
        self.userID = userID
        self.displayName = displayName
        self.description = description
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.actor = try Actor(from: decoder)
        self.userID = try AnyJSON(from: decoder)
        self.displayName = try values.decodeIfPresent(String.self, forKey: "displayName")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(actor, forKey: "actor")
        try values.encodeIfPresent(userID, forKey: "userId")
        try values.encodeIfPresent(displayName, forKey: "displayName")
        try values.encodeIfPresent(description, forKey: "description")
    }
}

public struct UserWatchingVideo: Codable {
    /// Timestamp within the video, in seconds
    public var currentTime: Int?

    public init(currentTime: Int? = nil) {
        self.currentTime = currentTime
    }
}

public struct ServerConfig: Codable {
    public var instance: Instance?
    public var search: Search?
    public var plugin: Plugin?
    public var theme: Theme?
    public var email: Email?
    public var contactForm: ContactForm?
    public var serverVersion: String?
    public var serverCommit: String?
    public var signup: Signup?
    public var transcoding: Transcoding?
    public var `import`: Import?
    public var autoBlacklist: AutoBlacklist?
    public var avatar: Avatar?
    public var video: Video?
    public var videoCaption: VideoCaption?
    public var user: User?
    public var trending: Trending?
    public var tracker: Tracker?
    public var followings: Followings?
    public var homepage: Homepage?

    public struct Instance: Codable {
        public var name: String?
        public var shortDescription: String?
        public var defaultClientRoute: String?
        public var isNSFW: Bool?
        public var defaultNSFWPolicy: String?
        public var customizations: Customizations?

        public struct Customizations: Codable {
            public var javascript: String?
            public var css: String?

            public init(javascript: String? = nil, css: String? = nil) {
                self.javascript = javascript
                self.css = css
            }
        }

        public init(name: String? = nil, shortDescription: String? = nil, defaultClientRoute: String? = nil, isNSFW: Bool? = nil, defaultNSFWPolicy: String? = nil, customizations: Customizations? = nil) {
            self.name = name
            self.shortDescription = shortDescription
            self.defaultClientRoute = defaultClientRoute
            self.isNSFW = isNSFW
            self.defaultNSFWPolicy = defaultNSFWPolicy
            self.customizations = customizations
        }
    }

    public struct Search: Codable {
        public var remoteUri: RemoteUri?

        public struct RemoteUri: Codable {
            public var isUsers: Bool?
            public var isAnonymous: Bool?

            public init(isUsers: Bool? = nil, isAnonymous: Bool? = nil) {
                self.isUsers = isUsers
                self.isAnonymous = isAnonymous
            }

            private enum CodingKeys: String, CodingKey {
                case isUsers = "users"
                case isAnonymous = "anonymous"
            }
        }

        public init(remoteUri: RemoteUri? = nil) {
            self.remoteUri = remoteUri
        }
    }

    public struct Plugin: Codable {
        public var registered: [String]?

        public init(registered: [String]? = nil) {
            self.registered = registered
        }
    }

    public struct Theme: Codable {
        public var registered: [String]?

        public init(registered: [String]? = nil) {
            self.registered = registered
        }
    }

    public struct Email: Codable {
        public var isEnabled: Bool?

        public init(isEnabled: Bool? = nil) {
            self.isEnabled = isEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case isEnabled = "enabled"
        }
    }

    public struct ContactForm: Codable {
        public var isEnabled: Bool?

        public init(isEnabled: Bool? = nil) {
            self.isEnabled = isEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case isEnabled = "enabled"
        }
    }

    public struct Signup: Codable {
        public var isAllowed: Bool?
        public var isAllowedForCurrentIP: Bool?
        public var requiresEmailVerification: Bool?

        public init(isAllowed: Bool? = nil, isAllowedForCurrentIP: Bool? = nil, requiresEmailVerification: Bool? = nil) {
            self.isAllowed = isAllowed
            self.isAllowedForCurrentIP = isAllowedForCurrentIP
            self.requiresEmailVerification = requiresEmailVerification
        }

        private enum CodingKeys: String, CodingKey {
            case isAllowed = "allowed"
            case isAllowedForCurrentIP = "allowedForCurrentIP"
            case requiresEmailVerification
        }
    }

    public struct Transcoding: Codable {
        public var hls: Hls?
        public var webtorrent: Webtorrent?
        public var enabledResolutions: [Int]?

        public struct Hls: Codable {
            public var isEnabled: Bool?

            public init(isEnabled: Bool? = nil) {
                self.isEnabled = isEnabled
            }

            private enum CodingKeys: String, CodingKey {
                case isEnabled = "enabled"
            }
        }

        public struct Webtorrent: Codable {
            public var isEnabled: Bool?

            public init(isEnabled: Bool? = nil) {
                self.isEnabled = isEnabled
            }

            private enum CodingKeys: String, CodingKey {
                case isEnabled = "enabled"
            }
        }

        public init(hls: Hls? = nil, webtorrent: Webtorrent? = nil, enabledResolutions: [Int]? = nil) {
            self.hls = hls
            self.webtorrent = webtorrent
            self.enabledResolutions = enabledResolutions
        }
    }

    public struct Import: Codable {
        public var videos: Videos?

        public struct Videos: Codable {
            public var http: HTTP?
            public var torrent: Torrent?

            public struct HTTP: Codable {
                public var isEnabled: Bool?

                public init(isEnabled: Bool? = nil) {
                    self.isEnabled = isEnabled
                }

                private enum CodingKeys: String, CodingKey {
                    case isEnabled = "enabled"
                }
            }

            public struct Torrent: Codable {
                public var isEnabled: Bool?

                public init(isEnabled: Bool? = nil) {
                    self.isEnabled = isEnabled
                }

                private enum CodingKeys: String, CodingKey {
                    case isEnabled = "enabled"
                }
            }

            public init(http: HTTP? = nil, torrent: Torrent? = nil) {
                self.http = http
                self.torrent = torrent
            }
        }

        public init(videos: Videos? = nil) {
            self.videos = videos
        }
    }

    public struct AutoBlacklist: Codable {
        public var videos: Videos?

        public struct Videos: Codable {
            public var ofUsers: OfUsers?

            public struct OfUsers: Codable {
                public var isEnabled: Bool?

                public init(isEnabled: Bool? = nil) {
                    self.isEnabled = isEnabled
                }

                private enum CodingKeys: String, CodingKey {
                    case isEnabled = "enabled"
                }
            }

            public init(ofUsers: OfUsers? = nil) {
                self.ofUsers = ofUsers
            }
        }

        public init(videos: Videos? = nil) {
            self.videos = videos
        }
    }

    public struct Avatar: Codable {
        public var file: File?
        public var extensions: [String]?

        public struct File: Codable {
            public var size: Size?

            public struct Size: Codable {
                public var max: Int?

                public init(max: Int? = nil) {
                    self.max = max
                }
            }

            public init(size: Size? = nil) {
                self.size = size
            }
        }

        public init(file: File? = nil, extensions: [String]? = nil) {
            self.file = file
            self.extensions = extensions
        }
    }

    public struct Video: Codable {
        public var image: Image?
        public var file: File?

        public struct Image: Codable {
            public var extensions: [String]?
            public var size: Size?

            public struct Size: Codable {
                public var max: Int?

                public init(max: Int? = nil) {
                    self.max = max
                }
            }

            public init(extensions: [String]? = nil, size: Size? = nil) {
                self.extensions = extensions
                self.size = size
            }
        }

        public struct File: Codable {
            public var extensions: [String]?

            public init(extensions: [String]? = nil) {
                self.extensions = extensions
            }
        }

        public init(image: Image? = nil, file: File? = nil) {
            self.image = image
            self.file = file
        }
    }

    public struct VideoCaption: Codable {
        public var file: File?

        public struct File: Codable {
            public var size: Size?
            public var extensions: [String]?

            public struct Size: Codable {
                public var max: Int?

                public init(max: Int? = nil) {
                    self.max = max
                }
            }

            public init(size: Size? = nil, extensions: [String]? = nil) {
                self.size = size
                self.extensions = extensions
            }
        }

        public init(file: File? = nil) {
            self.file = file
        }
    }

    public struct User: Codable {
        /// Example: 16810141515
        public var videoQuota: Int?
        /// Example: 1681014151
        public var videoQuotaDaily: Int?

        public init(videoQuota: Int? = nil, videoQuotaDaily: Int? = nil) {
            self.videoQuota = videoQuota
            self.videoQuotaDaily = videoQuotaDaily
        }
    }

    public struct Trending: Codable {
        public var videos: Videos?

        public struct Videos: Codable {
            public var intervalDays: Int?

            public init(intervalDays: Int? = nil) {
                self.intervalDays = intervalDays
            }
        }

        public init(videos: Videos? = nil) {
            self.videos = videos
        }
    }

    public struct Tracker: Codable {
        public var isEnabled: Bool?

        public init(isEnabled: Bool? = nil) {
            self.isEnabled = isEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case isEnabled = "enabled"
        }
    }

    public struct Followings: Codable {
        public var instance: Instance?

        public struct Instance: Codable {
            public var autoFollowIndex: AutoFollowIndex?

            public struct AutoFollowIndex: Codable {
                public var indexURL: String?

                public init(indexURL: String? = nil) {
                    self.indexURL = indexURL
                }

                private enum CodingKeys: String, CodingKey {
                    case indexURL = "indexUrl"
                }
            }

            public init(autoFollowIndex: AutoFollowIndex? = nil) {
                self.autoFollowIndex = autoFollowIndex
            }
        }

        public init(instance: Instance? = nil) {
            self.instance = instance
        }
    }

    public struct Homepage: Codable {
        public var isEnabled: Bool?

        public init(isEnabled: Bool? = nil) {
            self.isEnabled = isEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case isEnabled = "enabled"
        }
    }

    public init(instance: Instance? = nil, search: Search? = nil, plugin: Plugin? = nil, theme: Theme? = nil, email: Email? = nil, contactForm: ContactForm? = nil, serverVersion: String? = nil, serverCommit: String? = nil, signup: Signup? = nil, transcoding: Transcoding? = nil, `import`: Import? = nil, autoBlacklist: AutoBlacklist? = nil, avatar: Avatar? = nil, video: Video? = nil, videoCaption: VideoCaption? = nil, user: User? = nil, trending: Trending? = nil, tracker: Tracker? = nil, followings: Followings? = nil, homepage: Homepage? = nil) {
        self.instance = instance
        self.search = search
        self.plugin = plugin
        self.theme = theme
        self.email = email
        self.contactForm = contactForm
        self.serverVersion = serverVersion
        self.serverCommit = serverCommit
        self.signup = signup
        self.transcoding = transcoding
        self.import = `import`
        self.autoBlacklist = autoBlacklist
        self.avatar = avatar
        self.video = video
        self.videoCaption = videoCaption
        self.user = user
        self.trending = trending
        self.tracker = tracker
        self.followings = followings
        self.homepage = homepage
    }

    private enum CodingKeys: String, CodingKey {
        case instance
        case search
        case plugin
        case theme
        case email
        case contactForm
        case serverVersion
        case serverCommit
        case signup
        case transcoding
        case `import` = "import"
        case autoBlacklist
        case avatar
        case video
        case videoCaption
        case user
        case trending
        case tracker
        case followings
        case homepage
    }
}

public struct ServerConfigAbout: Codable {
    public var instance: Instance?

    public struct Instance: Codable {
        public var name: String?
        public var shortDescription: String?
        public var description: String?
        public var terms: String?

        public init(name: String? = nil, shortDescription: String? = nil, description: String? = nil, terms: String? = nil) {
            self.name = name
            self.shortDescription = shortDescription
            self.description = description
            self.terms = terms
        }
    }

    public init(instance: Instance? = nil) {
        self.instance = instance
    }
}

public struct ServerConfigCustom: Codable {
    public var instance: Instance?
    public var theme: Theme?
    public var services: Services?
    public var cache: Cache?
    public var signup: Signup?
    public var admin: Admin?
    public var contactForm: ContactForm?
    /// Settings that apply to new users, if registration is enabled
    public var user: User?
    /// Settings pertaining to transcoding jobs
    public var transcoding: Transcoding?
    public var `import`: Import?
    public var autoBlacklist: AutoBlacklist?
    public var followers: Followers?

    public struct Instance: Codable {
        public var name: String?
        public var shortDescription: String?
        public var description: String?
        public var terms: String?
        public var defaultClientRoute: String?
        public var isNSFW: Bool?
        public var defaultNSFWPolicy: String?
        public var customizations: Customizations?

        public struct Customizations: Codable {
            public var javascript: String?
            public var css: String?

            public init(javascript: String? = nil, css: String? = nil) {
                self.javascript = javascript
                self.css = css
            }
        }

        public init(name: String? = nil, shortDescription: String? = nil, description: String? = nil, terms: String? = nil, defaultClientRoute: String? = nil, isNSFW: Bool? = nil, defaultNSFWPolicy: String? = nil, customizations: Customizations? = nil) {
            self.name = name
            self.shortDescription = shortDescription
            self.description = description
            self.terms = terms
            self.defaultClientRoute = defaultClientRoute
            self.isNSFW = isNSFW
            self.defaultNSFWPolicy = defaultNSFWPolicy
            self.customizations = customizations
        }
    }

    public struct Theme: Codable {
        public var `default`: String?

        public init(`default`: String? = nil) {
            self.default = `default`
        }

        private enum CodingKeys: String, CodingKey {
            case `default` = "default"
        }
    }

    public struct Services: Codable {
        public var twitter: Twitter?

        public struct Twitter: Codable {
            public var username: String?
            public var isWhitelisted: Bool?

            public init(username: String? = nil, isWhitelisted: Bool? = nil) {
                self.username = username
                self.isWhitelisted = isWhitelisted
            }

            private enum CodingKeys: String, CodingKey {
                case username
                case isWhitelisted = "whitelisted"
            }
        }

        public init(twitter: Twitter? = nil) {
            self.twitter = twitter
        }
    }

    public struct Cache: Codable {
        public var previews: Previews?
        public var captions: Captions?

        public struct Previews: Codable {
            public var size: Int?

            public init(size: Int? = nil) {
                self.size = size
            }
        }

        public struct Captions: Codable {
            public var size: Int?

            public init(size: Int? = nil) {
                self.size = size
            }
        }

        public init(previews: Previews? = nil, captions: Captions? = nil) {
            self.previews = previews
            self.captions = captions
        }
    }

    public struct Signup: Codable {
        public var isEnabled: Bool?
        public var limit: Int?
        public var requiresEmailVerification: Bool?

        public init(isEnabled: Bool? = nil, limit: Int? = nil, requiresEmailVerification: Bool? = nil) {
            self.isEnabled = isEnabled
            self.limit = limit
            self.requiresEmailVerification = requiresEmailVerification
        }

        private enum CodingKeys: String, CodingKey {
            case isEnabled = "enabled"
            case limit
            case requiresEmailVerification
        }
    }

    public struct Admin: Codable {
        public var email: String?

        public init(email: String? = nil) {
            self.email = email
        }
    }

    public struct ContactForm: Codable {
        public var isEnabled: Bool?

        public init(isEnabled: Bool? = nil) {
            self.isEnabled = isEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case isEnabled = "enabled"
        }
    }

    /// Settings that apply to new users, if registration is enabled
    public struct User: Codable {
        /// Example: 16810141515
        public var videoQuota: Int?
        /// Example: 1681014151
        public var videoQuotaDaily: Int?

        public init(videoQuota: Int? = nil, videoQuotaDaily: Int? = nil) {
            self.videoQuota = videoQuota
            self.videoQuotaDaily = videoQuotaDaily
        }
    }

    /// Settings pertaining to transcoding jobs
    public struct Transcoding: Codable {
        public var isEnabled: Bool?
        /// Allow your users to upload .mkv, .mov, .avi, .wmv, .flv, .f4v, .3g2, .3gp, .mts, m2ts, .mxf, .nut videos
        public var allowAdditionalExtensions: Bool?
        /// If a user uploads an audio file, PeerTube will create a video by merging the preview file and the audio file
        public var allowAudioFiles: Bool?
        /// Amount of threads used by ffmpeg for 1 transcoding job
        public var threads: Int?
        /// Amount of transcoding jobs to execute in parallel
        public var concurrency: Double?
        /// New profiles can be added by plugins ; available in core PeerTube: 'default'.
        public var profile: Profile?
        /// Resolutions to transcode _new videos_ to
        public var resolutions: Resolutions?
        /// WebTorrent-specific settings
        public var webtorrent: Webtorrent?
        /// HLS-specific settings
        public var hls: Hls?

        /// New profiles can be added by plugins ; available in core PeerTube: 'default'.
        public enum Profile: String, Codable, CaseIterable {
            case `default`
        }

        /// Resolutions to transcode _new videos_ to
        public struct Resolutions: Codable {
            public var is_0p: Bool?
            public var is_144p: Bool?
            public var is_240p: Bool?
            public var is_360p: Bool?
            public var is_480p: Bool?
            public var is_720p: Bool?
            public var is_1080p: Bool?
            public var is_1440p: Bool?
            public var is_2160p: Bool?

            public init(is_0p: Bool? = nil, is_144p: Bool? = nil, is_240p: Bool? = nil, is_360p: Bool? = nil, is_480p: Bool? = nil, is_720p: Bool? = nil, is_1080p: Bool? = nil, is_1440p: Bool? = nil, is_2160p: Bool? = nil) {
                self.is_0p = is_0p
                self.is_144p = is_144p
                self.is_240p = is_240p
                self.is_360p = is_360p
                self.is_480p = is_480p
                self.is_720p = is_720p
                self.is_1080p = is_1080p
                self.is_1440p = is_1440p
                self.is_2160p = is_2160p
            }

            private enum CodingKeys: String, CodingKey {
                case is_0p = "0p"
                case is_144p = "144p"
                case is_240p = "240p"
                case is_360p = "360p"
                case is_480p = "480p"
                case is_720p = "720p"
                case is_1080p = "1080p"
                case is_1440p = "1440p"
                case is_2160p = "2160p"
            }
        }

        /// WebTorrent-specific settings
        public struct Webtorrent: Codable {
            public var isEnabled: Bool?

            public init(isEnabled: Bool? = nil) {
                self.isEnabled = isEnabled
            }

            private enum CodingKeys: String, CodingKey {
                case isEnabled = "enabled"
            }
        }

        /// HLS-specific settings
        public struct Hls: Codable {
            public var isEnabled: Bool?

            public init(isEnabled: Bool? = nil) {
                self.isEnabled = isEnabled
            }

            private enum CodingKeys: String, CodingKey {
                case isEnabled = "enabled"
            }
        }

        public init(isEnabled: Bool? = nil, allowAdditionalExtensions: Bool? = nil, allowAudioFiles: Bool? = nil, threads: Int? = nil, concurrency: Double? = nil, profile: Profile? = nil, resolutions: Resolutions? = nil, webtorrent: Webtorrent? = nil, hls: Hls? = nil) {
            self.isEnabled = isEnabled
            self.allowAdditionalExtensions = allowAdditionalExtensions
            self.allowAudioFiles = allowAudioFiles
            self.threads = threads
            self.concurrency = concurrency
            self.profile = profile
            self.resolutions = resolutions
            self.webtorrent = webtorrent
            self.hls = hls
        }

        private enum CodingKeys: String, CodingKey {
            case isEnabled = "enabled"
            case allowAdditionalExtensions
            case allowAudioFiles
            case threads
            case concurrency
            case profile
            case resolutions
            case webtorrent
            case hls
        }
    }

    public struct Import: Codable {
        public var videos: Videos?

        public struct Videos: Codable {
            public var http: HTTP?
            public var torrent: Torrent?

            public struct HTTP: Codable {
                public var isEnabled: Bool?

                public init(isEnabled: Bool? = nil) {
                    self.isEnabled = isEnabled
                }

                private enum CodingKeys: String, CodingKey {
                    case isEnabled = "enabled"
                }
            }

            public struct Torrent: Codable {
                public var isEnabled: Bool?

                public init(isEnabled: Bool? = nil) {
                    self.isEnabled = isEnabled
                }

                private enum CodingKeys: String, CodingKey {
                    case isEnabled = "enabled"
                }
            }

            public init(http: HTTP? = nil, torrent: Torrent? = nil) {
                self.http = http
                self.torrent = torrent
            }
        }

        public init(videos: Videos? = nil) {
            self.videos = videos
        }
    }

    public struct AutoBlacklist: Codable {
        public var videos: Videos?

        public struct Videos: Codable {
            public var ofUsers: OfUsers?

            public struct OfUsers: Codable {
                public var isEnabled: Bool?

                public init(isEnabled: Bool? = nil) {
                    self.isEnabled = isEnabled
                }

                private enum CodingKeys: String, CodingKey {
                    case isEnabled = "enabled"
                }
            }

            public init(ofUsers: OfUsers? = nil) {
                self.ofUsers = ofUsers
            }
        }

        public init(videos: Videos? = nil) {
            self.videos = videos
        }
    }

    public struct Followers: Codable {
        public var instance: Instance?

        public struct Instance: Codable {
            public var isEnabled: Bool?
            public var isManualApproval: Bool?

            public init(isEnabled: Bool? = nil, isManualApproval: Bool? = nil) {
                self.isEnabled = isEnabled
                self.isManualApproval = isManualApproval
            }

            private enum CodingKeys: String, CodingKey {
                case isEnabled = "enabled"
                case isManualApproval = "manualApproval"
            }
        }

        public init(instance: Instance? = nil) {
            self.instance = instance
        }
    }

    public init(instance: Instance? = nil, theme: Theme? = nil, services: Services? = nil, cache: Cache? = nil, signup: Signup? = nil, admin: Admin? = nil, contactForm: ContactForm? = nil, user: User? = nil, transcoding: Transcoding? = nil, `import`: Import? = nil, autoBlacklist: AutoBlacklist? = nil, followers: Followers? = nil) {
        self.instance = instance
        self.theme = theme
        self.services = services
        self.cache = cache
        self.signup = signup
        self.admin = admin
        self.contactForm = contactForm
        self.user = user
        self.transcoding = transcoding
        self.import = `import`
        self.autoBlacklist = autoBlacklist
        self.followers = followers
    }

    private enum CodingKeys: String, CodingKey {
        case instance
        case theme
        case services
        case cache
        case signup
        case admin
        case contactForm
        case user
        case transcoding
        case `import` = "import"
        case autoBlacklist
        case followers
    }
}

public struct CustomHomepage: Codable {
    public var content: String?

    public init(content: String? = nil) {
        self.content = content
    }
}

public struct Follow: Codable {
    /// Example: 42
    public var id: Int?
    public var follower: Actor?
    public var following: Actor?
    /// Score reflecting the reachability of the actor, with steps of `10` and a base score of `1000`.
    public var score: Double?
    public var state: State?
    public var createdAt: Date?
    public var updatedAt: Date?

    public enum State: String, Codable, CaseIterable {
        case pending
        case accepted
    }

    public init(id: Int? = nil, follower: Actor? = nil, following: Actor? = nil, score: Double? = nil, state: State? = nil, createdAt: Date? = nil, updatedAt: Date? = nil) {
        self.id = id
        self.follower = follower
        self.following = following
        self.score = score
        self.state = state
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }
}

public enum PredefinedAbuseReason: String, Codable, CaseIterable {
    case violentOrAbusive
    case hatefulOrAbusive
    case spamOrMisleading
    case privacy
    case rights
    case serverRules
    case thumbnails
    case captions
}

public struct Job: Codable {
    /// Example: 42
    public var id: Int?
    public var state: State?
    public var type: `Type`?
    public var data: [String: AnyJSON]?
    public var error: [String: AnyJSON]?
    public var createdAt: Date?
    public var finishedOn: Date?
    public var processedOn: Date?

    public enum State: String, Codable, CaseIterable {
        case active
        case completed
        case failed
        case waiting
        case delayed
    }

    public enum `Type`: String, Codable, CaseIterable {
        case activitypubHTTPUnicast = "activitypub-http-unicast"
        case activitypubHTTPBroadcast = "activitypub-http-broadcast"
        case activitypubHTTPFetcher = "activitypub-http-fetcher"
        case activitypubFollow = "activitypub-follow"
        case videoFileImport = "video-file-import"
        case videoTranscoding = "video-transcoding"
        case email
        case videoImport = "video-import"
        case videosViewsStats = "videos-views-stats"
        case activitypubRefresher = "activitypub-refresher"
        case videoRedundancy = "video-redundancy"
    }

    public init(id: Int? = nil, state: State? = nil, type: `Type`? = nil, data: [String: AnyJSON]? = nil, error: [String: AnyJSON]? = nil, createdAt: Date? = nil, finishedOn: Date? = nil, processedOn: Date? = nil) {
        self.id = id
        self.state = state
        self.type = type
        self.data = data
        self.error = error
        self.createdAt = createdAt
        self.finishedOn = finishedOn
        self.processedOn = processedOn
    }
}

public struct AddUserResponse: Codable {
    public var user: User?

    public struct User: Codable {
        /// Example: 42
        public var id: Int?
        public var account: Account?

        public struct Account: Codable {
            /// Example: 42
            public var id: Int?

            public init(id: Int? = nil) {
                self.id = id
            }
        }

        public init(id: Int? = nil, account: Account? = nil) {
            self.id = id
            self.account = account
        }
    }

    public init(user: User? = nil) {
        self.user = user
    }
}

public struct VideoUploadRequestCommon: Codable {
    /// Video name
    ///
    /// Example: "What is PeerTube?"
    public var name: String
    /// Channel id that will contain this video
    public var channelID: Int
    /// Privacy id of the video (see [/videos/privacies](#operation/getPrivacyPolicies))
    public var privacy: Int?
    /// Category id of the video (see [/videos/categories](#operation/getCategories))
    ///
    /// Example: 15
    public var category: Int?
    /// Licence id of the video (see [/videos/licences](#operation/getLicences))
    public var licence: Int?
    /// Language id of the video (see [/videos/languages](#operation/getLanguages))
    ///
    /// Example: "en"
    public var language: String?
    /// Video description
    ///
    /// Example:
    ///
    /// "**[Want to help to translate this video?](https://weblate.framasoft.org/projects/what-is-peertube-video/)**\r\n\r\n**Take back the control of your videos! [#JoinPeertube](https://joinpeertube.org)**
    /// "
    public var description: String?
    /// Whether or not we wait transcoding before publish the video
    public var isWaitTranscoding: Bool?
    /// A text tell the audience how to support the video creator
    ///
    /// Example: "Please support our work on https://soutenir.framasoft.org/en/ <3"
    public var support: String?
    /// Whether or not this video contains sensitive content
    public var isNsfw: Bool?
    /// Video tags (maximum 5 tags each between 2 and 30 characters)
    ///
    /// Example: ["framasoft", "peertube"]
    public var tags: [String]?
    /// Enable or disable comments for this video
    public var isCommentsEnabled: Bool?
    /// Enable or disable downloading for this video
    public var isDownloadEnabled: Bool?
    /// Date when the content was originally published
    public var originallyPublishedAt: Date?
    public var scheduleUpdate: VideoScheduledUpdate?
    /// Video thumbnail file
    public var thumbnailfile: String?
    /// Video preview file
    public var previewfile: String?

    public init(name: String, channelID: Int, privacy: Int? = nil, category: Int? = nil, licence: Int? = nil, language: String? = nil, description: String? = nil, isWaitTranscoding: Bool? = nil, support: String? = nil, isNsfw: Bool? = nil, tags: [String]? = nil, isCommentsEnabled: Bool? = nil, isDownloadEnabled: Bool? = nil, originallyPublishedAt: Date? = nil, scheduleUpdate: VideoScheduledUpdate? = nil, thumbnailfile: String? = nil, previewfile: String? = nil) {
        self.name = name
        self.channelID = channelID
        self.privacy = privacy
        self.category = category
        self.licence = licence
        self.language = language
        self.description = description
        self.isWaitTranscoding = isWaitTranscoding
        self.support = support
        self.isNsfw = isNsfw
        self.tags = tags
        self.isCommentsEnabled = isCommentsEnabled
        self.isDownloadEnabled = isDownloadEnabled
        self.originallyPublishedAt = originallyPublishedAt
        self.scheduleUpdate = scheduleUpdate
        self.thumbnailfile = thumbnailfile
        self.previewfile = previewfile
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case channelID = "channelId"
        case privacy
        case category
        case licence
        case language
        case description
        case isWaitTranscoding = "waitTranscoding"
        case support
        case isNsfw = "nsfw"
        case tags
        case isCommentsEnabled = "commentsEnabled"
        case isDownloadEnabled = "downloadEnabled"
        case originallyPublishedAt
        case scheduleUpdate
        case thumbnailfile
        case previewfile
    }
}

public struct VideoUploadRequestLegacy: Codable {
    public var videoUploadRequestCommon: VideoUploadRequestCommon
    /// Video file
    public var videofile: String

    public init(videoUploadRequestCommon: VideoUploadRequestCommon, videofile: String) {
        self.videoUploadRequestCommon = videoUploadRequestCommon
        self.videofile = videofile
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.videoUploadRequestCommon = try VideoUploadRequestCommon(from: decoder)
        self.videofile = try values.decode(String.self, forKey: "videofile")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(videoUploadRequestCommon, forKey: "videoUploadRequestCommon")
        try values.encode(videofile, forKey: "videofile")
    }
}

public struct VideoUploadRequestResumable: Codable {
    public var videoUploadRequestCommon: VideoUploadRequestCommon
    /// Video filename including extension
    ///
    /// Example: "what_is_peertube.mp4"
    public var filename: String
    /// Video thumbnail file
    public var thumbnailfile: String?
    /// Video preview file
    public var previewfile: String?

    public init(videoUploadRequestCommon: VideoUploadRequestCommon, filename: String, thumbnailfile: String? = nil, previewfile: String? = nil) {
        self.videoUploadRequestCommon = videoUploadRequestCommon
        self.filename = filename
        self.thumbnailfile = thumbnailfile
        self.previewfile = previewfile
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.videoUploadRequestCommon = try VideoUploadRequestCommon(from: decoder)
        self.filename = try values.decode(String.self, forKey: "filename")
        self.thumbnailfile = try values.decodeIfPresent(String.self, forKey: "thumbnailfile")
        self.previewfile = try values.decodeIfPresent(String.self, forKey: "previewfile")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(videoUploadRequestCommon, forKey: "videoUploadRequestCommon")
        try values.encode(filename, forKey: "filename")
        try values.encodeIfPresent(thumbnailfile, forKey: "thumbnailfile")
        try values.encodeIfPresent(previewfile, forKey: "previewfile")
    }
}

public struct VideoUploadResponse: Codable {
    public var video: Video?

    public struct Video: Codable {
        public var id: AnyJSON?
        public var uuid: AnyJSON?
        public var shortUUID: AnyJSON?

        public init(id: AnyJSON? = nil, uuid: AnyJSON? = nil, shortUUID: AnyJSON? = nil) {
            self.id = id
            self.uuid = uuid
            self.shortUUID = shortUUID
        }
    }

    public init(video: Video? = nil) {
        self.video = video
    }
}

public struct CommentThreadResponse: Codable {
    public var total: Int?
    public var data: [VideoComment]?

    public init(total: Int? = nil, data: [VideoComment]? = nil) {
        self.total = total
        self.data = data
    }
}

public struct CommentThreadPostResponse: Codable {
    public var comment: VideoComment?

    public init(comment: VideoComment? = nil) {
        self.comment = comment
    }
}

public struct VideoListResponse: Codable {
    public var total: Int?
    public var data: [Video]?

    public init(total: Int? = nil, data: [Video]? = nil) {
        self.total = total
        self.data = data
    }
}

public struct User: Codable {
    public var account: Account?
    /// Automatically start playing the upcoming video after the currently playing video
    public var isAutoPlayNextVideo: Bool?
    /// Automatically start playing the video on the playlist after the currently playing video
    public var isAutoPlayNextVideoPlaylist: Bool?
    /// Automatically start playing the video on the watch page
    public var isAutoPlayVideo: Bool?
    public var isBlocked: Bool?
    public var blockedReason: String?
    public var createdAt: String?
    /// The user email
    public var email: String?
    /// Has the user confirmed their email address?
    public var isEmailVerified: Bool?
    public var id: Int?
    /// Auth plugin to use to authenticate the user
    public var pluginAuth: String?
    public var lastLoginDate: Date?
    public var isNoInstanceConfigWarningModal: Bool?
    public var isNoAccountSetupWarningModal: Bool?
    public var isNoWelcomeModal: Bool?
    public var nsfwPolicy: NSFWPolicy?
    /// The user role (Admin = `0`, Moderator = `1`, User = `2`)
    public var role: Int?
    public var roleLabel: RoleLabel?
    /// Theme enabled by this user
    public var theme: String?
    /// Immutable name of the user, used to find or mention its actor
    ///
    /// Example: "chocobozzz"
    public var username: String?
    public var videoChannels: [VideoChannel]?
    /// The user video quota in bytes
    ///
    /// Example: -1
    public var videoQuota: Int?
    /// The user daily video quota in bytes
    ///
    /// Example: -1
    public var videoQuotaDaily: Int?
    /// Enable P2P in the player
    public var isP2pEnabled: Bool?

    public enum RoleLabel: String, Codable, CaseIterable {
        case user = "User"
        case moderator = "Moderator"
        case administrator = "Administrator"
    }

    public init(account: Account? = nil, isAutoPlayNextVideo: Bool? = nil, isAutoPlayNextVideoPlaylist: Bool? = nil, isAutoPlayVideo: Bool? = nil, isBlocked: Bool? = nil, blockedReason: String? = nil, createdAt: String? = nil, email: String? = nil, isEmailVerified: Bool? = nil, id: Int? = nil, pluginAuth: String? = nil, lastLoginDate: Date? = nil, isNoInstanceConfigWarningModal: Bool? = nil, isNoAccountSetupWarningModal: Bool? = nil, isNoWelcomeModal: Bool? = nil, nsfwPolicy: NSFWPolicy? = nil, role: Int? = nil, roleLabel: RoleLabel? = nil, theme: String? = nil, username: String? = nil, videoChannels: [VideoChannel]? = nil, videoQuota: Int? = nil, videoQuotaDaily: Int? = nil, isP2pEnabled: Bool? = nil) {
        self.account = account
        self.isAutoPlayNextVideo = isAutoPlayNextVideo
        self.isAutoPlayNextVideoPlaylist = isAutoPlayNextVideoPlaylist
        self.isAutoPlayVideo = isAutoPlayVideo
        self.isBlocked = isBlocked
        self.blockedReason = blockedReason
        self.createdAt = createdAt
        self.email = email
        self.isEmailVerified = isEmailVerified
        self.id = id
        self.pluginAuth = pluginAuth
        self.lastLoginDate = lastLoginDate
        self.isNoInstanceConfigWarningModal = isNoInstanceConfigWarningModal
        self.isNoAccountSetupWarningModal = isNoAccountSetupWarningModal
        self.isNoWelcomeModal = isNoWelcomeModal
        self.nsfwPolicy = nsfwPolicy
        self.role = role
        self.roleLabel = roleLabel
        self.theme = theme
        self.username = username
        self.videoChannels = videoChannels
        self.videoQuota = videoQuota
        self.videoQuotaDaily = videoQuotaDaily
        self.isP2pEnabled = isP2pEnabled
    }

    private enum CodingKeys: String, CodingKey {
        case account
        case isAutoPlayNextVideo = "autoPlayNextVideo"
        case isAutoPlayNextVideoPlaylist = "autoPlayNextVideoPlaylist"
        case isAutoPlayVideo = "autoPlayVideo"
        case isBlocked = "blocked"
        case blockedReason
        case createdAt
        case email
        case isEmailVerified = "emailVerified"
        case id
        case pluginAuth
        case lastLoginDate
        case isNoInstanceConfigWarningModal = "noInstanceConfigWarningModal"
        case isNoAccountSetupWarningModal = "noAccountSetupWarningModal"
        case isNoWelcomeModal = "noWelcomeModal"
        case nsfwPolicy
        case role
        case roleLabel
        case theme
        case username
        case videoChannels
        case videoQuota
        case videoQuotaDaily
        case isP2pEnabled = "p2pEnabled"
    }
}

public struct UserWithStats: Codable {
    public var user: User
    /// Count of videos published
    public var videosCount: Int?
    /// Count of reports/abuses of which the user is a target
    public var abusesCount: Int?
    /// Count of reports/abuses created by the user and accepted/acted upon by the moderation team
    public var abusesAcceptedCount: Int?
    /// Count of reports/abuses created by the user
    public var abusesCreatedCount: Int?
    /// Count of comments published
    public var videoCommentsCount: Int?

    public init(user: User, videosCount: Int? = nil, abusesCount: Int? = nil, abusesAcceptedCount: Int? = nil, abusesCreatedCount: Int? = nil, videoCommentsCount: Int? = nil) {
        self.user = user
        self.videosCount = videosCount
        self.abusesCount = abusesCount
        self.abusesAcceptedCount = abusesAcceptedCount
        self.abusesCreatedCount = abusesCreatedCount
        self.videoCommentsCount = videoCommentsCount
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.user = try User(from: decoder)
        self.videosCount = try values.decodeIfPresent(Int.self, forKey: "videosCount")
        self.abusesCount = try values.decodeIfPresent(Int.self, forKey: "abusesCount")
        self.abusesAcceptedCount = try values.decodeIfPresent(Int.self, forKey: "abusesAcceptedCount")
        self.abusesCreatedCount = try values.decodeIfPresent(Int.self, forKey: "abusesCreatedCount")
        self.videoCommentsCount = try values.decodeIfPresent(Int.self, forKey: "videoCommentsCount")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(user, forKey: "user")
        try values.encodeIfPresent(videosCount, forKey: "videosCount")
        try values.encodeIfPresent(abusesCount, forKey: "abusesCount")
        try values.encodeIfPresent(abusesAcceptedCount, forKey: "abusesAcceptedCount")
        try values.encodeIfPresent(abusesCreatedCount, forKey: "abusesCreatedCount")
        try values.encodeIfPresent(videoCommentsCount, forKey: "videoCommentsCount")
    }
}

public struct AddUser: Codable {
    /// Immutable name of the user, used to find or mention its actor
    ///
    /// Example: "chocobozzz"
    public var username: String
    public var password: String
    /// The user email
    public var email: String
    /// The user video quota in bytes
    ///
    /// Example: -1
    public var videoQuota: Int
    /// The user daily video quota in bytes
    ///
    /// Example: -1
    public var videoQuotaDaily: Int
    /// Immutable name of the channel, used to interact with its actor
    ///
    /// Example: "framasoft_videos"
    public var channelName: String?
    /// The user role (Admin = `0`, Moderator = `1`, User = `2`)
    public var role: Int
    /// Admin flags for the user (None = `0`, Bypass video blocklist = `1`)
    public var adminFlags: Int?

    public init(username: String, password: String, email: String, videoQuota: Int, videoQuotaDaily: Int, channelName: String? = nil, role: Int, adminFlags: Int? = nil) {
        self.username = username
        self.password = password
        self.email = email
        self.videoQuota = videoQuota
        self.videoQuotaDaily = videoQuotaDaily
        self.channelName = channelName
        self.role = role
        self.adminFlags = adminFlags
    }
}

public struct UpdateUser: Codable {
    /// The updated email of the user
    public var email: AnyJSON?
    /// Set the email as verified
    public var isEmailVerified: Bool?
    /// The updated video quota of the user in bytes
    public var videoQuota: Int?
    /// The updated daily video quota of the user in bytes
    public var videoQuotaDaily: Int?
    /// The auth plugin to use to authenticate the user
    ///
    /// Example: "peertube-plugin-auth-saml2"
    public var pluginAuth: String?
    /// The user role (Admin = `0`, Moderator = `1`, User = `2`)
    public var role: Int?
    /// Admin flags for the user (None = `0`, Bypass video blocklist = `1`)
    public var adminFlags: Int?

    public init(email: AnyJSON? = nil, isEmailVerified: Bool? = nil, videoQuota: Int? = nil, videoQuotaDaily: Int? = nil, pluginAuth: String? = nil, role: Int? = nil, adminFlags: Int? = nil) {
        self.email = email
        self.isEmailVerified = isEmailVerified
        self.videoQuota = videoQuota
        self.videoQuotaDaily = videoQuotaDaily
        self.pluginAuth = pluginAuth
        self.role = role
        self.adminFlags = adminFlags
    }

    private enum CodingKeys: String, CodingKey {
        case email
        case isEmailVerified = "emailVerified"
        case videoQuota
        case videoQuotaDaily
        case pluginAuth
        case role
        case adminFlags
    }
}

public struct UpdateMe: Codable {
    public var password: String?
    public var currentPassword: String?
    /// New email used for login and service communications
    public var email: AnyJSON?
    /// New name of the user in its representations
    public var displayName: String?
    /// New NSFW display policy
    public var displayNSFW: DisplayNSFW?
    /// Whether to enable P2P in the player or not
    public var isP2pEnabled: Bool?
    /// New preference regarding playing videos automatically
    public var isAutoPlayVideo: Bool?
    /// New preference regarding playing following videos automatically
    public var isAutoPlayNextVideo: Bool?
    /// New preference regarding playing following playlist videos automatically
    public var isAutoPlayNextVideoPlaylist: Bool?
    /// Whether to keep track of watched history or not
    public var isVideosHistoryEnabled: Bool?
    /// List of languages to filter videos down to
    public var videoLanguages: [String]?
    public var theme: String?
    public var isNoInstanceConfigWarningModal: Bool?
    public var isNoAccountSetupWarningModal: Bool?
    public var isNoWelcomeModal: Bool?

    /// New NSFW display policy
    public enum DisplayNSFW: String, Codable, CaseIterable {
        case `true`
        case `false`
        case both
    }

    public init(password: String? = nil, currentPassword: String? = nil, email: AnyJSON? = nil, displayName: String? = nil, displayNSFW: DisplayNSFW? = nil, isP2pEnabled: Bool? = nil, isAutoPlayVideo: Bool? = nil, isAutoPlayNextVideo: Bool? = nil, isAutoPlayNextVideoPlaylist: Bool? = nil, isVideosHistoryEnabled: Bool? = nil, videoLanguages: [String]? = nil, theme: String? = nil, isNoInstanceConfigWarningModal: Bool? = nil, isNoAccountSetupWarningModal: Bool? = nil, isNoWelcomeModal: Bool? = nil) {
        self.password = password
        self.currentPassword = currentPassword
        self.email = email
        self.displayName = displayName
        self.displayNSFW = displayNSFW
        self.isP2pEnabled = isP2pEnabled
        self.isAutoPlayVideo = isAutoPlayVideo
        self.isAutoPlayNextVideo = isAutoPlayNextVideo
        self.isAutoPlayNextVideoPlaylist = isAutoPlayNextVideoPlaylist
        self.isVideosHistoryEnabled = isVideosHistoryEnabled
        self.videoLanguages = videoLanguages
        self.theme = theme
        self.isNoInstanceConfigWarningModal = isNoInstanceConfigWarningModal
        self.isNoAccountSetupWarningModal = isNoAccountSetupWarningModal
        self.isNoWelcomeModal = isNoWelcomeModal
    }

    private enum CodingKeys: String, CodingKey {
        case password
        case currentPassword
        case email
        case displayName
        case displayNSFW
        case isP2pEnabled = "p2pEnabled"
        case isAutoPlayVideo = "autoPlayVideo"
        case isAutoPlayNextVideo = "autoPlayNextVideo"
        case isAutoPlayNextVideoPlaylist = "autoPlayNextVideoPlaylist"
        case isVideosHistoryEnabled = "videosHistoryEnabled"
        case videoLanguages
        case theme
        case isNoInstanceConfigWarningModal = "noInstanceConfigWarningModal"
        case isNoAccountSetupWarningModal = "noAccountSetupWarningModal"
        case isNoWelcomeModal = "noWelcomeModal"
    }
}

public struct GetMeVideoRating: Codable {
    /// Example: 42
    public var id: Int
    /// Rating of the video
    public var rating: Rating

    /// Rating of the video
    public enum Rating: String, Codable, CaseIterable {
        case like
        case dislike
        case `none`
    }

    public init(id: Int, rating: Rating) {
        self.id = id
        self.rating = rating
    }
}

public struct VideoRating: Codable {
    public var video: Video
    /// Rating of the video
    public var rating: Rating

    /// Rating of the video
    public enum Rating: String, Codable, CaseIterable {
        case like
        case dislike
        case `none`
    }

    public init(video: Video, rating: Rating) {
        self.video = video
        self.rating = rating
    }
}

public struct RegisterUser: Codable {
    /// Immutable name of the user, used to find or mention its actor
    public var username: String
    public var password: String
    /// Email of the user, used for login or service communications
    public var email: String
    /// Editable name of the user, displayed in its representations
    public var displayName: String?
    /// Channel base information used to create the first channel of the user
    public var channel: Channel?

    /// Channel base information used to create the first channel of the user
    public struct Channel: Codable {
        /// Immutable name of the channel, used to interact with its actor
        ///
        /// Example: "framasoft_videos"
        public var name: String?
        public var displayName: AnyJSON?

        public init(name: String? = nil, displayName: AnyJSON? = nil) {
            self.name = name
            self.displayName = displayName
        }
    }

    public init(username: String, password: String, email: String, displayName: String? = nil, channel: Channel? = nil) {
        self.username = username
        self.password = password
        self.email = email
        self.displayName = displayName
        self.channel = channel
    }
}

public struct OAuthClient: Codable {
    /// Example: "v1ikx5hnfop4mdpnci8nsqh93c45rldf"
    public var clientID: String?
    /// Example: "AjWiOapPltI6EnsWQwlFarRtLh4u8tDt"
    public var clientSecret: String?

    public init(clientID: String? = nil, clientSecret: String? = nil) {
        self.clientID = clientID
        self.clientSecret = clientSecret
    }

    private enum CodingKeys: String, CodingKey {
        case clientID = "client_id"
        case clientSecret = "client_secret"
    }
}

public struct OAuthTokenPassword: Codable {
    public var oAuthClient: OAuthClient
    public var grantType: GrantType?
    public var username: AnyJSON?
    public var password: String?

    public enum GrantType: String, Codable, CaseIterable {
        case password
        case refreshToken = "refresh_token"
    }

    public init(oAuthClient: OAuthClient, grantType: GrantType? = nil, username: AnyJSON? = nil, password: String? = nil) {
        self.oAuthClient = oAuthClient
        self.grantType = grantType
        self.username = username
        self.password = password
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.oAuthClient = try OAuthClient(from: decoder)
        self.grantType = try GrantType(from: decoder)
        self.username = try AnyJSON(from: decoder)
        self.password = try values.decodeIfPresent(String.self, forKey: "password")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(oAuthClient, forKey: "oAuthClient")
        try values.encodeIfPresent(grantType, forKey: "grant_type")
        try values.encodeIfPresent(username, forKey: "username")
        try values.encodeIfPresent(password, forKey: "password")
    }
}

public struct OAuthTokenRefreshToken: Codable {
    public var oAuthClient: OAuthClient
    public var grantType: GrantType?
    /// Example: "2e0d675df9fc96d2e4ec8a3ebbbf45eca9137bb7"
    public var refreshToken: String?

    public enum GrantType: String, Codable, CaseIterable {
        case password
        case refreshToken = "refresh_token"
    }

    public init(oAuthClient: OAuthClient, grantType: GrantType? = nil, refreshToken: String? = nil) {
        self.oAuthClient = oAuthClient
        self.grantType = grantType
        self.refreshToken = refreshToken
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.oAuthClient = try OAuthClient(from: decoder)
        self.grantType = try GrantType(from: decoder)
        self.refreshToken = try values.decodeIfPresent(String.self, forKey: "refresh_token")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(oAuthClient, forKey: "oAuthClient")
        try values.encodeIfPresent(grantType, forKey: "grant_type")
        try values.encodeIfPresent(refreshToken, forKey: "refresh_token")
    }
}

public struct VideoChannel: Codable {
    /// Editable name of the channel, displayed in its representations
    ///
    /// Example: "Videos of Framasoft"
    public var displayName: String?
    /// Example: "Videos made with <3 by Framasoft"
    public var description: String?
    /// Text shown by default on all videos of this channel, to tell the audience how to support it
    ///
    /// Example: "Please support our work on https://soutenir.framasoft.org/en/ <3"
    public var support: String?
    public var id: Int?
    public var isLocal: Bool?
    public var updatedAt: Date?
    public var ownerAccount: OwnerAccount?

    public struct OwnerAccount: Codable {
        public var id: Int?
        /// Example: "9c9de5e8-0a1e-484a-b099-e80766180a6d"
        public var uuid: String?

        public init(id: Int? = nil, uuid: String? = nil) {
            self.id = id
            self.uuid = uuid
        }
    }

    public init(displayName: String? = nil, description: String? = nil, support: String? = nil, id: Int? = nil, isLocal: Bool? = nil, updatedAt: Date? = nil, ownerAccount: OwnerAccount? = nil) {
        self.displayName = displayName
        self.description = description
        self.support = support
        self.id = id
        self.isLocal = isLocal
        self.updatedAt = updatedAt
        self.ownerAccount = ownerAccount
    }
}

public struct VideoChannelCreate: Codable {
    public var videoChannel: VideoChannel
    /// Username of the channel to create
    public var name: String?

    public init(videoChannel: VideoChannel, name: String? = nil) {
        self.videoChannel = videoChannel
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.videoChannel = try VideoChannel(from: decoder)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(videoChannel, forKey: "videoChannel")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct VideoChannelUpdate: Codable {
    public var videoChannel: VideoChannel
    /// Update the support field for all videos of this channel
    public var isBulkVideosSupportUpdate: Bool?

    public init(videoChannel: VideoChannel, isBulkVideosSupportUpdate: Bool? = nil) {
        self.videoChannel = videoChannel
        self.isBulkVideosSupportUpdate = isBulkVideosSupportUpdate
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.videoChannel = try VideoChannel(from: decoder)
        self.isBulkVideosSupportUpdate = try values.decodeIfPresent(Bool.self, forKey: "bulkVideosSupportUpdate")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(videoChannel, forKey: "videoChannel")
        try values.encodeIfPresent(isBulkVideosSupportUpdate, forKey: "bulkVideosSupportUpdate")
    }
}

public struct VideoChannelList: Codable {
    public var total: Int?
    public var data: [Datum]?

    public struct Datum: Codable {
        public var videoChannel: VideoChannel
        public var actor: Actor

        public init(videoChannel: VideoChannel, actor: Actor) {
            self.videoChannel = videoChannel
            self.actor = actor
        }

        public init(from decoder: Decoder) throws {
            self.videoChannel = try VideoChannel(from: decoder)
            self.actor = try Actor(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(videoChannel, forKey: "videoChannel")
            try values.encode(actor, forKey: "actor")
        }
    }

    public init(total: Int? = nil, data: [Datum]? = nil) {
        self.total = total
        self.data = data
    }
}

public struct MRSSPeerLink: Codable {
    public var href: String?
    public var type: `Type`?

    public enum `Type`: String, Codable, CaseIterable {
        case applicationXBittorrent = "application/x-bittorrent"
    }

    public init(href: String? = nil, type: `Type`? = nil) {
        self.href = href
        self.type = type
    }
}

public struct MRSSGroupContent: Codable {
    public var url: String?
    public var fileSize: Int?
    public var type: String?
    public var framerate: Int?
    public var duration: Int?
    public var height: Int?
    public var lang: String?

    public init(url: String? = nil, fileSize: Int? = nil, type: String? = nil, framerate: Int? = nil, duration: Int? = nil, height: Int? = nil, lang: String? = nil) {
        self.url = url
        self.fileSize = fileSize
        self.type = type
        self.framerate = framerate
        self.duration = duration
        self.height = height
        self.lang = lang
    }
}

public struct VideoCommentsForXMLItem: Codable {
    public var link: String?
    public var guid: String?
    public var pubDate: Date?
    public var contentEncoded: String?
    public var dcCreator: String?

    public init(link: String? = nil, guid: String? = nil, pubDate: Date? = nil, contentEncoded: String? = nil, dcCreator: String? = nil) {
        self.link = link
        self.guid = guid
        self.pubDate = pubDate
        self.contentEncoded = contentEncoded
        self.dcCreator = dcCreator
    }

    private enum CodingKeys: String, CodingKey {
        case link
        case guid
        case pubDate
        case contentEncoded = "content:encoded"
        case dcCreator = "dc:creator"
    }
}

public struct VideosForXMLItem: Codable {
    /// Video watch page URL
    public var link: String?
    /// Video canonical URL
    public var guid: String?
    /// Video publication date
    public var pubDate: Date?
    /// Video description
    public var description: String?
    /// Video description
    public var contentEncoded: String?
    /// Publisher user name
    public var dcCreator: String?
    /// Video category (MRSS)
    public var mediaCategory: Int?
    /// See [media:community](https://www.rssboard.org/media-rss#media-community) (MRSS)
    public var mediaCommunity: MediaCommunity?
    public var mediaEmbed: MediaEmbed?
    public var mediaPlayer: MediaPlayer?
    public var mediaThumbnail: MediaThumbnail?
    /// See [media:title](https://www.rssboard.org/media-rss#media-title) (MRSS). We only use `plain` titles.
    public var mediaTitle: String?
    public var mediaDescription: String?
    /// See [media:rating](https://www.rssboard.org/media-rss#media-rating) (MRSS)
    public var mediaRating: MediaRating?
    /// Main streamable file for the video
    public var enclosure: Enclosure?
    /// List of streamable files for the video. see [media:peerLink](https://www.rssboard.org/media-rss#media-peerlink) and [media:content](https://www.rssboard.org/media-rss#media-content) or  (MRSS)
    public var mediaGroup: [MediaGroupItem]?

    /// See [media:community](https://www.rssboard.org/media-rss#media-community) (MRSS)
    public struct MediaCommunity: Codable {
        public var mediaStatistics: MediaStatistics?

        public struct MediaStatistics: Codable {
            public var views: Int?

            public init(views: Int? = nil) {
                self.views = views
            }
        }

        public init(mediaStatistics: MediaStatistics? = nil) {
            self.mediaStatistics = mediaStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case mediaStatistics = "media:statistics"
        }
    }

    public struct MediaEmbed: Codable {
        /// Video embed path, relative to the canonical URL domain (MRSS)
        public var url: String?

        public init(url: String? = nil) {
            self.url = url
        }
    }

    public struct MediaPlayer: Codable {
        /// Video watch path, relative to the canonical URL domain (MRSS)
        public var url: String?

        public init(url: String? = nil) {
            self.url = url
        }
    }

    public struct MediaThumbnail: Codable {
        public var url: String?
        public var height: Int?
        public var width: Int?

        public init(url: String? = nil, height: Int? = nil, width: Int? = nil) {
            self.url = url
            self.height = height
            self.width = width
        }
    }

    /// See [media:rating](https://www.rssboard.org/media-rss#media-rating) (MRSS)
    public enum MediaRating: String, Codable, CaseIterable {
        case nonadult
        case adult
    }

    /// Main streamable file for the video
    public struct Enclosure: Codable {
        public var url: String?
        public var type: `Type`?
        public var length: Int?

        public enum `Type`: String, Codable, CaseIterable {
            case applicationXBittorrent = "application/x-bittorrent"
        }

        public init(url: String? = nil, type: `Type`? = nil, length: Int? = nil) {
            self.url = url
            self.type = type
            self.length = length
        }
    }

    public struct MediaGroupItem: Codable {
        public var mRSSPeerLink: MRSSPeerLink?
        public var mRSSGroupContent: MRSSGroupContent?

        public init(mRSSPeerLink: MRSSPeerLink? = nil, mRSSGroupContent: MRSSGroupContent? = nil) {
            self.mRSSPeerLink = mRSSPeerLink
            self.mRSSGroupContent = mRSSGroupContent
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.mRSSPeerLink = try? container.decode(MRSSPeerLink.self)
            self.mRSSGroupContent = try? container.decode(MRSSGroupContent.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = mRSSPeerLink { try container.encode(value) }
            if let value = mRSSGroupContent { try container.encode(value) }
        }
    }

    public init(link: String? = nil, guid: String? = nil, pubDate: Date? = nil, description: String? = nil, contentEncoded: String? = nil, dcCreator: String? = nil, mediaCategory: Int? = nil, mediaCommunity: MediaCommunity? = nil, mediaEmbed: MediaEmbed? = nil, mediaPlayer: MediaPlayer? = nil, mediaThumbnail: MediaThumbnail? = nil, mediaTitle: String? = nil, mediaDescription: String? = nil, mediaRating: MediaRating? = nil, enclosure: Enclosure? = nil, mediaGroup: [MediaGroupItem]? = nil) {
        self.link = link
        self.guid = guid
        self.pubDate = pubDate
        self.description = description
        self.contentEncoded = contentEncoded
        self.dcCreator = dcCreator
        self.mediaCategory = mediaCategory
        self.mediaCommunity = mediaCommunity
        self.mediaEmbed = mediaEmbed
        self.mediaPlayer = mediaPlayer
        self.mediaThumbnail = mediaThumbnail
        self.mediaTitle = mediaTitle
        self.mediaDescription = mediaDescription
        self.mediaRating = mediaRating
        self.enclosure = enclosure
        self.mediaGroup = mediaGroup
    }

    private enum CodingKeys: String, CodingKey {
        case link
        case guid
        case pubDate
        case description
        case contentEncoded = "content:encoded"
        case dcCreator = "dc:creator"
        case mediaCategory = "media:category"
        case mediaCommunity = "media:community"
        case mediaEmbed = "media:embed"
        case mediaPlayer = "media:player"
        case mediaThumbnail = "media:thumbnail"
        case mediaTitle = "media:title"
        case mediaDescription = "media:description"
        case mediaRating = "media:rating"
        case enclosure
        case mediaGroup = "media:group"
    }
}

public struct Notification: Codable {
    /// Example: 42
    public var id: Int?
    /// Notification type, following the `UserNotificationType` enum:
    /// - `1` NEW_VIDEO_FROM_SUBSCRIPTION
    /// - `2` NEW_COMMENT_ON_MY_VIDEO
    /// - `3` NEW_ABUSE_FOR_MODERATORS
    /// - `4` BLACKLIST_ON_MY_VIDEO
    /// - `5` UNBLACKLIST_ON_MY_VIDEO
    /// - `6` MY_VIDEO_PUBLISHED
    /// - `7` MY_VIDEO_IMPORT_SUCCESS
    /// - `8` MY_VIDEO_IMPORT_ERROR
    /// - `9` NEW_USER_REGISTRATION
    /// - `10` NEW_FOLLOW
    /// - `11` COMMENT_MENTION
    /// - `12` VIDEO_AUTO_BLACKLIST_FOR_MODERATORS
    /// - `13` NEW_INSTANCE_FOLLOWER
    /// - `14` AUTO_INSTANCE_FOLLOWING
    /// - `15` ABUSE_STATE_CHANGE
    /// - `16` ABUSE_NEW_MESSAGE
    /// - `17` NEW_PLUGIN_VERSION
    /// - `18` NEW_PEERTUBE_VERSION
    public var type: Int?
    public var isRead: Bool?
    public var video: Video?
    public var videoImport: VideoImport?
    public var comment: Comment?
    public var videoAbuse: VideoAbuse?
    public var videoBlacklist: VideoBlacklist?
    public var account: ActorInfo?
    public var actorFollow: ActorFollow?
    public var createdAt: Date?
    public var updatedAt: Date?

    public struct Video: Codable {
        public var videoInfo: VideoInfo
        public var channel: ActorInfo?

        public init(videoInfo: VideoInfo, channel: ActorInfo? = nil) {
            self.videoInfo = videoInfo
            self.channel = channel
        }

        public init(from decoder: Decoder) throws {
            self.videoInfo = try VideoInfo(from: decoder)
            self.channel = try ActorInfo(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(videoInfo, forKey: "videoInfo")
            try values.encodeIfPresent(channel, forKey: "channel")
        }
    }

    public struct VideoImport: Codable {
        /// Example: 42
        public var id: Int?
        public var video: VideoInfo?
        public var torrentName: String?
        public var magnetUri: AnyJSON?
        public var targetUri: URL?

        public init(id: Int? = nil, video: VideoInfo? = nil, torrentName: String? = nil, magnetUri: AnyJSON? = nil, targetUri: URL? = nil) {
            self.id = id
            self.video = video
            self.torrentName = torrentName
            self.magnetUri = magnetUri
            self.targetUri = targetUri
        }
    }

    public struct Comment: Codable {
        /// Example: 42
        public var id: Int?
        public var threadID: Int?
        public var video: VideoInfo?
        public var account: ActorInfo?

        public init(id: Int? = nil, threadID: Int? = nil, video: VideoInfo? = nil, account: ActorInfo? = nil) {
            self.id = id
            self.threadID = threadID
            self.video = video
            self.account = account
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case threadID = "threadId"
            case video
            case account
        }
    }

    public struct VideoAbuse: Codable {
        /// Example: 42
        public var id: Int?
        public var video: VideoInfo?

        public init(id: Int? = nil, video: VideoInfo? = nil) {
            self.id = id
            self.video = video
        }
    }

    public struct VideoBlacklist: Codable {
        /// Example: 42
        public var id: Int?
        public var video: VideoInfo?

        public init(id: Int? = nil, video: VideoInfo? = nil) {
            self.id = id
            self.video = video
        }
    }

    public struct ActorFollow: Codable {
        /// Example: 42
        public var id: Int?
        public var follower: ActorInfo?
        public var state: State?
        public var following: Following?

        public enum State: String, Codable, CaseIterable {
            case pending
            case accepted
        }

        public struct Following: Codable {
            public var type: `Type`?
            public var name: String?
            public var displayName: String?
            public var host: String?

            public enum `Type`: String, Codable, CaseIterable {
                case account
                case channel
                case instance
            }

            public init(type: `Type`? = nil, name: String? = nil, displayName: String? = nil, host: String? = nil) {
                self.type = type
                self.name = name
                self.displayName = displayName
                self.host = host
            }
        }

        public init(id: Int? = nil, follower: ActorInfo? = nil, state: State? = nil, following: Following? = nil) {
            self.id = id
            self.follower = follower
            self.state = state
            self.following = following
        }
    }

    public init(id: Int? = nil, type: Int? = nil, isRead: Bool? = nil, video: Video? = nil, videoImport: VideoImport? = nil, comment: Comment? = nil, videoAbuse: VideoAbuse? = nil, videoBlacklist: VideoBlacklist? = nil, account: ActorInfo? = nil, actorFollow: ActorFollow? = nil, createdAt: Date? = nil, updatedAt: Date? = nil) {
        self.id = id
        self.type = type
        self.isRead = isRead
        self.video = video
        self.videoImport = videoImport
        self.comment = comment
        self.videoAbuse = videoAbuse
        self.videoBlacklist = videoBlacklist
        self.account = account
        self.actorFollow = actorFollow
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case type
        case isRead = "read"
        case video
        case videoImport
        case comment
        case videoAbuse
        case videoBlacklist
        case account
        case actorFollow
        case createdAt
        case updatedAt
    }
}

public struct NotificationListResponse: Codable {
    public var total: Int?
    public var data: [Notification]?

    public init(total: Int? = nil, data: [Notification]? = nil) {
        self.total = total
        self.data = data
    }
}

public struct Plugin: Codable {
    /// Example: "peertube-plugin-auth-ldap"
    public var name: String?
    /// - `1`: PLUGIN
    /// - `2`: THEME
    public var type: Int?
    /// Example: "0.0.3"
    public var latestVersion: String?
    /// Example: "0.0.1"
    public var version: String?
    public var isEnabled: Bool?
    public var isUninstalled: Bool?
    /// Example: "2.2.0"
    public var peertubeEngine: String?
    public var description: String?
    /// Example: "https://framagit.org/framasoft/peertube/official-plugins/tree/master/peertube-plugin-auth-ldap"
    public var homepage: String?
    public var settings: [String: AnyJSON]?
    public var createdAt: Date?
    public var updatedAt: Date?

    public init(name: String? = nil, type: Int? = nil, latestVersion: String? = nil, version: String? = nil, isEnabled: Bool? = nil, isUninstalled: Bool? = nil, peertubeEngine: String? = nil, description: String? = nil, homepage: String? = nil, settings: [String: AnyJSON]? = nil, createdAt: Date? = nil, updatedAt: Date? = nil) {
        self.name = name
        self.type = type
        self.latestVersion = latestVersion
        self.version = version
        self.isEnabled = isEnabled
        self.isUninstalled = isUninstalled
        self.peertubeEngine = peertubeEngine
        self.description = description
        self.homepage = homepage
        self.settings = settings
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case type
        case latestVersion
        case version
        case isEnabled = "enabled"
        case isUninstalled = "uninstalled"
        case peertubeEngine
        case description
        case homepage
        case settings
        case createdAt
        case updatedAt
    }
}

public struct PluginResponse: Codable {
    public var total: Int?
    public var data: [Plugin]?

    public init(total: Int? = nil, data: [Plugin]? = nil) {
        self.total = total
        self.data = data
    }
}

public struct LiveVideoUpdate: Codable {
    public var isSaveReplay: Bool?
    /// User can stream multiple times in a permanent live
    public var isPermanentLive: Bool?

    public init(isSaveReplay: Bool? = nil, isPermanentLive: Bool? = nil) {
        self.isSaveReplay = isSaveReplay
        self.isPermanentLive = isPermanentLive
    }

    private enum CodingKeys: String, CodingKey {
        case isSaveReplay = "saveReplay"
        case isPermanentLive = "permanentLive"
    }
}

public struct LiveVideoResponse: Codable {
    public var rtmpURL: String?
    public var rtmpsURL: String?
    /// RTMP stream key to use to stream into this live video
    public var streamKey: String?
    public var isSaveReplay: Bool?
    /// User can stream multiple times in a permanent live
    public var isPermanentLive: Bool?

    public init(rtmpURL: String? = nil, rtmpsURL: String? = nil, streamKey: String? = nil, isSaveReplay: Bool? = nil, isPermanentLive: Bool? = nil) {
        self.rtmpURL = rtmpURL
        self.rtmpsURL = rtmpsURL
        self.streamKey = streamKey
        self.isSaveReplay = isSaveReplay
        self.isPermanentLive = isPermanentLive
    }

    private enum CodingKeys: String, CodingKey {
        case rtmpURL = "rtmpUrl"
        case rtmpsURL = "rtmpsUrl"
        case streamKey
        case isSaveReplay = "saveReplay"
        case isPermanentLive = "permanentLive"
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
