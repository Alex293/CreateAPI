// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

public struct Account: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The status of the account. Currently the only possible value is "active", but more values may be added in the future.
    public var accountStatus: String?
    public var createdOn: Date?
    public var displayName: String?
    public var isHas2faEnabled: Bool?
    public var links: Links?
    /// Account name defined by the owner. Should be used instead of the "username" field. Note that "nickname" cannot be used in place of "username" in URLs and queries, as "nickname" is not guaranteed to be unique.
    public var nickname: String?
    public var username: String?
    public var uuid: String?
    public var website: String?

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var avatar: Avatar?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var followers: Followers?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var following: Following?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var html: HTML?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var repositories: Repositories?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Avatar: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Followers: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Following: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct HTML: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Repositories: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(avatar: Avatar? = nil, followers: Followers? = nil, following: Following? = nil, html: HTML? = nil, repositories: Repositories? = nil, this: `Self`? = nil) {
            self.avatar = avatar
            self.followers = followers
            self.following = following
            self.html = html
            self.repositories = repositories
            self.this = this
        }

        private enum CodingKeys: String, CodingKey {
            case avatar
            case followers
            case following
            case html
            case repositories
            case this = "self"
        }
    }

    public init(object: Object, accountStatus: String? = nil, createdOn: Date? = nil, displayName: String? = nil, isHas2faEnabled: Bool? = nil, links: Links? = nil, nickname: String? = nil, username: String? = nil, uuid: String? = nil, website: String? = nil) {
        self.object = object
        self.accountStatus = accountStatus
        self.createdOn = createdOn
        self.displayName = displayName
        self.isHas2faEnabled = isHas2faEnabled
        self.links = links
        self.nickname = nickname
        self.username = username
        self.uuid = uuid
        self.website = website
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.accountStatus = try values.decodeIfPresent(String.self, forKey: "account_status")
        self.createdOn = try values.decodeIfPresent(Date.self, forKey: "created_on")
        self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
        self.isHas2faEnabled = try values.decodeIfPresent(Bool.self, forKey: "has_2fa_enabled")
        self.links = try Links(from: decoder)
        self.nickname = try values.decodeIfPresent(String.self, forKey: "nickname")
        self.username = try values.decodeIfPresent(String.self, forKey: "username")
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
        self.website = try values.decodeIfPresent(String.self, forKey: "website")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(accountStatus, forKey: "account_status")
        try values.encodeIfPresent(createdOn, forKey: "created_on")
        try values.encodeIfPresent(displayName, forKey: "display_name")
        try values.encodeIfPresent(isHas2faEnabled, forKey: "has_2fa_enabled")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(nickname, forKey: "nickname")
        try values.encodeIfPresent(username, forKey: "username")
        try values.encodeIfPresent(uuid, forKey: "uuid")
        try values.encodeIfPresent(website, forKey: "website")
    }
}

public struct Author: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The raw author value from the repository. This may be the only value available if the author does not match a user in Bitbucket.
    public var raw: String?
    public var user: Account?

    public init(object: Object, raw: String? = nil, user: Account? = nil) {
        self.object = object
        self.raw = raw
        self.user = user
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.raw = try values.decodeIfPresent(String.self, forKey: "raw")
        self.user = try Account(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(raw, forKey: "raw")
        try values.encodeIfPresent(user, forKey: "user")
    }
}

public struct BaseCommit: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var author: Author?
    public var date: Date?
    public var hash: String?
    public var message: String?
    public var parents: [BaseCommit]?
    public var summary: Summary?

    public struct Summary: Codable {
        /// The user's content rendered as HTML.
        public var html: String?
        /// The type of markup language the raw content is to be interpreted in.
        public var markup: Markup?
        /// The text as it was typed by a user.
        public var raw: String?

        /// The type of markup language the raw content is to be interpreted in.
        public enum Markup: String, Codable, CaseIterable {
            case markdown
            case creole
            case plaintext
        }

        public init(html: String? = nil, markup: Markup? = nil, raw: String? = nil) {
            self.html = html
            self.markup = markup
            self.raw = raw
        }
    }

    public init(object: Object, author: Author? = nil, date: Date? = nil, hash: String? = nil, message: String? = nil, parents: [BaseCommit]? = nil, summary: Summary? = nil) {
        self.object = object
        self.author = author
        self.date = date
        self.hash = hash
        self.message = message
        self.parents = parents
        self.summary = summary
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.author = try Author(from: decoder)
        self.date = try values.decodeIfPresent(Date.self, forKey: "date")
        self.hash = try values.decodeIfPresent(String.self, forKey: "hash")
        self.message = try values.decodeIfPresent(String.self, forKey: "message")
        self.parents = try values.decodeIfPresent([BaseCommit].self, forKey: "parents")
        self.summary = try Summary(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(author, forKey: "author")
        try values.encodeIfPresent(date, forKey: "date")
        try values.encodeIfPresent(hash, forKey: "hash")
        try values.encodeIfPresent(message, forKey: "message")
        try values.encodeIfPresent(parents, forKey: "parents")
        try values.encodeIfPresent(summary, forKey: "summary")
    }
}

public struct Branch: Codable {
    public var ref: Ref
    /// The default merge strategy for pull requests targeting this branch.
    public var defaultMergeStrategy: String?
    /// Available merge strategies for pull requests targeting this branch.
    public var mergeStrategies: [MergeStrategy]?

    public enum MergeStrategy: String, Codable, CaseIterable {
        case mergeCommit = "merge_commit"
        case squash
        case fastForward = "fast_forward"
    }

    public init(ref: Ref, defaultMergeStrategy: String? = nil, mergeStrategies: [MergeStrategy]? = nil) {
        self.ref = ref
        self.defaultMergeStrategy = defaultMergeStrategy
        self.mergeStrategies = mergeStrategies
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.ref = try Ref(from: decoder)
        self.defaultMergeStrategy = try values.decodeIfPresent(String.self, forKey: "default_merge_strategy")
        self.mergeStrategies = try values.decodeIfPresent([MergeStrategy].self, forKey: "merge_strategies")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(ref, forKey: "ref")
        try values.encodeIfPresent(defaultMergeStrategy, forKey: "default_merge_strategy")
        try values.encodeIfPresent(mergeStrategies, forKey: "merge_strategies")
    }
}

public struct BranchingModel: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The active branch types.
    public var branchTypes: [BranchType]?
    public var development: Development?
    public var production: Production?

    public struct BranchType: Codable {
        /// The kind of branch.
        public var kind: Kind
        /// The prefix for this branch type. A branch with this prefix will be classified as per `kind`. The prefix must be a valid prefix for a branch and must always exist. It cannot be blank, empty or `null`.
        public var prefix: String

        /// The kind of branch.
        public enum Kind: String, Codable, CaseIterable {
            case feature
            case bugfix
            case release
            case hotfix
        }

        public init(kind: Kind, prefix: String) {
            self.kind = kind
            self.prefix = prefix
        }
    }

    public struct Development: Codable {
        public var branch: Branch?
        /// Name of the target branch. Will be listed here even when the target branch does not exist. Will be `null` if targeting the main branch and the repository is empty.
        public var name: String
        /// Indicates if the setting points at an explicit branch (`false`) or tracks the main branch (`true`).
        public var useMainbranch: Bool

        public init(branch: Branch? = nil, name: String, useMainbranch: Bool) {
            self.branch = branch
            self.name = name
            self.useMainbranch = useMainbranch
        }

        private enum CodingKeys: String, CodingKey {
            case branch
            case name
            case useMainbranch = "use_mainbranch"
        }
    }

    public struct Production: Codable {
        public var branch: Branch?
        /// Name of the target branch. Will be listed here even when the target branch does not exist. Will be `null` if targeting the main branch and the repository is empty.
        public var name: String
        /// Indicates if the setting points at an explicit branch (`false`) or tracks the main branch (`true`).
        public var useMainbranch: Bool

        public init(branch: Branch? = nil, name: String, useMainbranch: Bool) {
            self.branch = branch
            self.name = name
            self.useMainbranch = useMainbranch
        }

        private enum CodingKeys: String, CodingKey {
            case branch
            case name
            case useMainbranch = "use_mainbranch"
        }
    }

    public init(object: Object, branchTypes: [BranchType]? = nil, development: Development? = nil, production: Production? = nil) {
        self.object = object
        self.branchTypes = branchTypes
        self.development = development
        self.production = production
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.branchTypes = try values.decodeIfPresent([BranchType].self, forKey: "branch_types")
        self.development = try Development(from: decoder)
        self.production = try Production(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(branchTypes, forKey: "branch_types")
        try values.encodeIfPresent(development, forKey: "development")
        try values.encodeIfPresent(production, forKey: "production")
    }
}

public struct BranchingModelSettings: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var branchTypes: [BranchType]?
    public var development: Development?
    public var links: Links?
    public var production: Production?

    public struct BranchType: Codable {
        /// Whether the branch type is enabled or not. A disabled branch type may contain an invalid `prefix`.
        public var isEnabled: Bool?
        /// The kind of the branch type.
        public var kind: Kind
        /// The prefix for this branch type. A branch with this prefix will be classified as per `kind`. The `prefix` of an enabled branch type must be a valid branch prefix.Additionally, it cannot be blank, empty or `null`. The `prefix` for a disabled branch type can be empty or invalid.
        public var prefix: String?

        /// The kind of the branch type.
        public enum Kind: String, Codable, CaseIterable {
            case feature
            case bugfix
            case release
            case hotfix
        }

        public init(isEnabled: Bool? = nil, kind: Kind, prefix: String? = nil) {
            self.isEnabled = isEnabled
            self.kind = kind
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case isEnabled = "enabled"
            case kind
            case prefix
        }
    }

    public struct Development: Codable {
        /// Indicates if the configured branch is valid, that is, if the configured branch actually exists currently. Is always `true` when `use_mainbranch` is `true` (even if the main branch does not exist). This field is read-only. This field is ignored when updating/creating settings.
        public var isValid: Bool?
        /// The configured branch. It must be `null` when `use_mainbranch` is `true`. Otherwise it must be a non-empty value. It is possible for the configured branch to not exist (e.g. it was deleted after the settings are set). In this case `is_valid` will be `false`. The branch must exist when updating/setting the `name` or an error will occur.
        public var name: String?
        /// Indicates if the setting points at an explicit branch (`false`) or tracks the main branch (`true`). When `true` the `name` must be `null` or not provided. When `false` the `name` must contain a non-empty branch name.
        public var useMainbranch: Bool?

        public init(isValid: Bool? = nil, name: String? = nil, useMainbranch: Bool? = nil) {
            self.isValid = isValid
            self.name = name
            self.useMainbranch = useMainbranch
        }

        private enum CodingKeys: String, CodingKey {
            case isValid = "is_valid"
            case name
            case useMainbranch = "use_mainbranch"
        }
    }

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(this: `Self`? = nil) {
            self.this = this
        }

        private enum CodingKeys: String, CodingKey {
            case this = "self"
        }
    }

    public struct Production: Codable {
        /// Indicates if branch is enabled or not.
        public var isEnabled: Bool?
        /// Indicates if the configured branch is valid, that is, if the configured branch actually exists currently. Is always `true` when `use_mainbranch` is `true` (even if the main branch does not exist). This field is read-only. This field is ignored when updating/creating settings.
        public var isValid: Bool?
        /// The configured branch. It must be `null` when `use_mainbranch` is `true`. Otherwise it must be a non-empty value. It is possible for the configured branch to not exist (e.g. it was deleted after the settings are set). In this case `is_valid` will be `false`. The branch must exist when updating/setting the `name` or an error will occur.
        public var name: String?
        /// Indicates if the setting points at an explicit branch (`false`) or tracks the main branch (`true`). When `true` the `name` must be `null` or not provided. When `false` the `name` must contain a non-empty branch name.
        public var useMainbranch: Bool?

        public init(isEnabled: Bool? = nil, isValid: Bool? = nil, name: String? = nil, useMainbranch: Bool? = nil) {
            self.isEnabled = isEnabled
            self.isValid = isValid
            self.name = name
            self.useMainbranch = useMainbranch
        }

        private enum CodingKeys: String, CodingKey {
            case isEnabled = "enabled"
            case isValid = "is_valid"
            case name
            case useMainbranch = "use_mainbranch"
        }
    }

    public init(object: Object, branchTypes: [BranchType]? = nil, development: Development? = nil, links: Links? = nil, production: Production? = nil) {
        self.object = object
        self.branchTypes = branchTypes
        self.development = development
        self.links = links
        self.production = production
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.branchTypes = try values.decodeIfPresent([BranchType].self, forKey: "branch_types")
        self.development = try Development(from: decoder)
        self.links = try Links(from: decoder)
        self.production = try Production(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(branchTypes, forKey: "branch_types")
        try values.encodeIfPresent(development, forKey: "development")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(production, forKey: "production")
    }
}

public struct Branchrestriction: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// Indicates how the restriction is matched against a branch. The default is `glob`.
    public var branchMatchKind: BranchMatchKind
    /// Apply the restriction to branches of this type. Active when `branch_match_kind` is `branching_model`. The branch type will be calculated using the branching model configured for the repository.
    public var branchType: BranchType?
    public var groups: [Group]?
    /// The branch restriction status' id.
    public var id: Int?
    /// The type of restriction that is being applied.
    public var kind: Kind
    public var links: Links?
    /// Apply the restriction to branches that match this pattern. Active when `branch_match_kind` is `glob`. Will be empty when `branch_match_kind` is `branching_model`.
    public var pattern: String
    public var users: [Account]?
    /// <staticmethod object at 0x7fd97f988d50>
    public var value: Int?

    /// Indicates how the restriction is matched against a branch. The default is `glob`.
    public enum BranchMatchKind: String, Codable, CaseIterable {
        case branchingModel = "branching_model"
        case glob
    }

    /// Apply the restriction to branches of this type. Active when `branch_match_kind` is `branching_model`. The branch type will be calculated using the branching model configured for the repository.
    public enum BranchType: String, Codable, CaseIterable {
        case feature
        case bugfix
        case release
        case hotfix
        case development
        case production
    }

    /// The type of restriction that is being applied.
    public enum Kind: String, Codable, CaseIterable {
        case requireTasksToBeCompleted = "require_tasks_to_be_completed"
        case allowAutoMergeWhenBuildsPass = "allow_auto_merge_when_builds_pass"
        case requirePassingBuildsToMerge = "require_passing_builds_to_merge"
        case force
        case requireAllDependenciesMerged = "require_all_dependencies_merged"
        case requireCommitsBehind = "require_commits_behind"
        case restrictMerges = "restrict_merges"
        case enforceMergeChecks = "enforce_merge_checks"
        case resetPullrequestChangesRequestedOnChange = "reset_pullrequest_changes_requested_on_change"
        case requireNoChangesRequested = "require_no_changes_requested"
        case smartResetPullrequestApprovals = "smart_reset_pullrequest_approvals"
        case push
        case requireApprovalsToMerge = "require_approvals_to_merge"
        case requireDefaultReviewerApprovalsToMerge = "require_default_reviewer_approvals_to_merge"
        case resetPullrequestApprovalsOnChange = "reset_pullrequest_approvals_on_change"
        case delete
    }

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(this: `Self`? = nil) {
            self.this = this
        }

        private enum CodingKeys: String, CodingKey {
            case this = "self"
        }
    }

    public init(object: Object, branchMatchKind: BranchMatchKind, branchType: BranchType? = nil, groups: [Group]? = nil, id: Int? = nil, kind: Kind, links: Links? = nil, pattern: String, users: [Account]? = nil, value: Int? = nil) {
        self.object = object
        self.branchMatchKind = branchMatchKind
        self.branchType = branchType
        self.groups = groups
        self.id = id
        self.kind = kind
        self.links = links
        self.pattern = pattern
        self.users = users
        self.value = value
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.branchMatchKind = try BranchMatchKind(from: decoder)
        self.branchType = try BranchType(from: decoder)
        self.groups = try values.decodeIfPresent([Group].self, forKey: "groups")
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.kind = try Kind(from: decoder)
        self.links = try Links(from: decoder)
        self.pattern = try values.decode(String.self, forKey: "pattern")
        self.users = try values.decodeIfPresent([Account].self, forKey: "users")
        self.value = try values.decodeIfPresent(Int.self, forKey: "value")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encode(branchMatchKind, forKey: "branch_match_kind")
        try values.encodeIfPresent(branchType, forKey: "branch_type")
        try values.encodeIfPresent(groups, forKey: "groups")
        try values.encodeIfPresent(id, forKey: "id")
        try values.encode(kind, forKey: "kind")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encode(pattern, forKey: "pattern")
        try values.encodeIfPresent(users, forKey: "users")
        try values.encodeIfPresent(value, forKey: "value")
    }
}

public final class Comment: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var content: Content?
    public var createdOn: Date?
    public var isDeleted: Bool?
    public var id: Int?
    public var inline: Inline?
    public var links: Links?
    public var parent: Comment?
    public var updatedOn: Date?
    public var user: User?

    public struct Content: Codable {
        /// The user's content rendered as HTML.
        public var html: String?
        /// The type of markup language the raw content is to be interpreted in.
        public var markup: Markup?
        /// The text as it was typed by a user.
        public var raw: String?

        /// The type of markup language the raw content is to be interpreted in.
        public enum Markup: String, Codable, CaseIterable {
            case markdown
            case creole
            case plaintext
        }

        public init(html: String? = nil, markup: Markup? = nil, raw: String? = nil) {
            self.html = html
            self.markup = markup
            self.raw = raw
        }
    }

    public struct Inline: Codable {
        /// The comment's anchor line in the old version of the file.
        public var from: Int?
        /// The path of the file this comment is anchored to.
        public var path: String
        /// The comment's anchor line in the new version of the file. If the 'from' line is also provided, this value will be removed.
        public var to: Int?

        public init(from: Int? = nil, path: String, to: Int? = nil) {
            self.from = from
            self.path = path
            self.to = to
        }
    }

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var code: Code?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var html: HTML?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Code: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct HTML: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(code: Code? = nil, html: HTML? = nil, this: `Self`? = nil) {
            self.code = code
            self.html = html
            self.this = this
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case html
            case this = "self"
        }
    }

    public init(object: Object, content: Content? = nil, createdOn: Date? = nil, isDeleted: Bool? = nil, id: Int? = nil, inline: Inline? = nil, links: Links? = nil, parent: Comment? = nil, updatedOn: Date? = nil, user: User? = nil) {
        self.object = object
        self.content = content
        self.createdOn = createdOn
        self.isDeleted = isDeleted
        self.id = id
        self.inline = inline
        self.links = links
        self.parent = parent
        self.updatedOn = updatedOn
        self.user = user
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.content = try Content(from: decoder)
        self.createdOn = try values.decodeIfPresent(Date.self, forKey: "created_on")
        self.isDeleted = try values.decodeIfPresent(Bool.self, forKey: "deleted")
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.inline = try Inline(from: decoder)
        self.links = try Links(from: decoder)
        self.parent = try Comment(from: decoder)
        self.updatedOn = try values.decodeIfPresent(Date.self, forKey: "updated_on")
        self.user = try User(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(content, forKey: "content")
        try values.encodeIfPresent(createdOn, forKey: "created_on")
        try values.encodeIfPresent(isDeleted, forKey: "deleted")
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(inline, forKey: "inline")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(parent, forKey: "parent")
        try values.encodeIfPresent(updatedOn, forKey: "updated_on")
        try values.encodeIfPresent(user, forKey: "user")
    }
}

public struct Commit: Codable {
    public var baseCommit: BaseCommit
    public var participants: [Participant]?
    public var repository: Repository?

    public init(baseCommit: BaseCommit, participants: [Participant]? = nil, repository: Repository? = nil) {
        self.baseCommit = baseCommit
        self.participants = participants
        self.repository = repository
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.baseCommit = try BaseCommit(from: decoder)
        self.participants = try values.decodeIfPresent([Participant].self, forKey: "participants")
        self.repository = try Repository(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(baseCommit, forKey: "baseCommit")
        try values.encodeIfPresent(participants, forKey: "participants")
        try values.encodeIfPresent(repository, forKey: "repository")
    }
}

public struct CommitComment: Codable {
    public var comment: Comment
    public var commit: Commit?

    public init(comment: Comment, commit: Commit? = nil) {
        self.comment = comment
        self.commit = commit
    }

    public init(from decoder: Decoder) throws {
        self.comment = try Comment(from: decoder)
        self.commit = try Commit(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(comment, forKey: "comment")
        try values.encodeIfPresent(commit, forKey: "commit")
    }
}

/// A file object, representing a file at a commit in a repository
public struct CommitFile: Codable {
    public var attributes: Attributes?
    public var commit: Commit?
    /// The escaped version of the path as it appears in a diff. If the path does not require escaping this will be the same as path.
    public var escapedPath: String?
    /// The path in the repository
    public var path: String?
    public var type: String

    public enum Attributes: String, Codable, CaseIterable {
        case link
        case executable
        case subrepository
        case binary
        case lfs
    }

    public init(attributes: Attributes? = nil, commit: Commit? = nil, escapedPath: String? = nil, path: String? = nil, type: String) {
        self.attributes = attributes
        self.commit = commit
        self.escapedPath = escapedPath
        self.path = path
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case attributes
        case commit
        case escapedPath = "escaped_path"
        case path
        case type
    }
}

public struct Commitstatus: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var createdOn: Date?
    /// A description of the build (e.g. "Unit tests in Bamboo")
    public var description: String?
    /// An identifier for the status that's unique to
    ///         its type (current "build" is the only supported type) and the vendor,
    ///         e.g. BB-DEPLOY
    public var key: String?
    public var links: Links?
    /// An identifier for the build itself, e.g. BB-DEPLOY-1
    public var name: String?
    /// The name of the ref that pointed to this commit at the time the status
    /// object was created. Note that this the ref may since have moved off of
    /// the commit. This optional field can be useful for build systems whose
    /// build triggers and configuration are branch-dependent (e.g. a Pipeline
    /// build).
    /// It is legitimate for this field to not be set, or even apply (e.g. a
    /// static linting job).
    public var refname: String?
    /// Provides some indication of the status of this commit
    public var state: State?
    public var updatedOn: Date?
    /// A URL linking back to the vendor or build system, for providing more information about whatever process produced this status. Accepts context variables `repository` and `commit` that Bitbucket will evaluate at runtime whenever at runtime. For example, one could use https://foo.com/builds/{repository.full_name} which Bitbucket will turn into https://foo.com/builds/foo/bar at render time.
    public var url: String?
    /// The commit status' id.
    public var uuid: String?

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var commit: Commit?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Commit: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(commit: Commit? = nil, this: `Self`? = nil) {
            self.commit = commit
            self.this = this
        }

        private enum CodingKeys: String, CodingKey {
            case commit
            case this = "self"
        }
    }

    /// Provides some indication of the status of this commit
    public enum State: String, Codable, CaseIterable {
        case successful = "SUCCESSFUL"
        case failed = "FAILED"
        case inprogress = "INPROGRESS"
        case stopped = "STOPPED"
    }

    public init(object: Object, createdOn: Date? = nil, description: String? = nil, key: String? = nil, links: Links? = nil, name: String? = nil, refname: String? = nil, state: State? = nil, updatedOn: Date? = nil, url: String? = nil, uuid: String? = nil) {
        self.object = object
        self.createdOn = createdOn
        self.description = description
        self.key = key
        self.links = links
        self.name = name
        self.refname = refname
        self.state = state
        self.updatedOn = updatedOn
        self.url = url
        self.uuid = uuid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.createdOn = try values.decodeIfPresent(Date.self, forKey: "created_on")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.key = try values.decodeIfPresent(String.self, forKey: "key")
        self.links = try Links(from: decoder)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.refname = try values.decodeIfPresent(String.self, forKey: "refname")
        self.state = try State(from: decoder)
        self.updatedOn = try values.decodeIfPresent(Date.self, forKey: "updated_on")
        self.url = try values.decodeIfPresent(String.self, forKey: "url")
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(createdOn, forKey: "created_on")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(key, forKey: "key")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(refname, forKey: "refname")
        try values.encodeIfPresent(state, forKey: "state")
        try values.encodeIfPresent(updatedOn, forKey: "updated_on")
        try values.encodeIfPresent(url, forKey: "url")
        try values.encodeIfPresent(uuid, forKey: "uuid")
    }
}

public struct Component: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var id: Int?
    public var links: Links?
    public var name: String?

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(this: `Self`? = nil) {
            self.this = this
        }

        private enum CodingKeys: String, CodingKey {
            case this = "self"
        }
    }

    public init(object: Object, id: Int? = nil, links: Links? = nil, name: String? = nil) {
        self.object = object
        self.id = id
        self.links = links
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.links = try Links(from: decoder)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct DeployKey: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var addedOn: Date?
    /// The comment parsed from the deploy key (if present)
    public var comment: String?
    /// The deploy key value.
    public var key: String?
    /// The user-defined label for the deploy key
    public var label: String?
    public var lastUsed: Date?
    public var links: Links?
    public var owner: Account?
    public var repository: Repository?

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(this: `Self`? = nil) {
            self.this = this
        }

        private enum CodingKeys: String, CodingKey {
            case this = "self"
        }
    }

    public init(object: Object, addedOn: Date? = nil, comment: String? = nil, key: String? = nil, label: String? = nil, lastUsed: Date? = nil, links: Links? = nil, owner: Account? = nil, repository: Repository? = nil) {
        self.object = object
        self.addedOn = addedOn
        self.comment = comment
        self.key = key
        self.label = label
        self.lastUsed = lastUsed
        self.links = links
        self.owner = owner
        self.repository = repository
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.addedOn = try values.decodeIfPresent(Date.self, forKey: "added_on")
        self.comment = try values.decodeIfPresent(String.self, forKey: "comment")
        self.key = try values.decodeIfPresent(String.self, forKey: "key")
        self.label = try values.decodeIfPresent(String.self, forKey: "label")
        self.lastUsed = try values.decodeIfPresent(Date.self, forKey: "last_used")
        self.links = try Links(from: decoder)
        self.owner = try Account(from: decoder)
        self.repository = try Repository(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(addedOn, forKey: "added_on")
        try values.encodeIfPresent(comment, forKey: "comment")
        try values.encodeIfPresent(key, forKey: "key")
        try values.encodeIfPresent(label, forKey: "label")
        try values.encodeIfPresent(lastUsed, forKey: "last_used")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(owner, forKey: "owner")
        try values.encodeIfPresent(repository, forKey: "repository")
    }
}

public struct Deployment: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var environment: DeploymentEnvironment?
    public var release: DeploymentRelease?
    public var state: Object?
    /// The UUID identifying the deployment.
    public var uuid: String?

    public init(object: Object, environment: DeploymentEnvironment? = nil, release: DeploymentRelease? = nil, state: Object? = nil, uuid: String? = nil) {
        self.object = object
        self.environment = environment
        self.release = release
        self.state = state
        self.uuid = uuid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.environment = try DeploymentEnvironment(from: decoder)
        self.release = try DeploymentRelease(from: decoder)
        self.state = try Object(from: decoder)
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(environment, forKey: "environment")
        try values.encodeIfPresent(release, forKey: "release")
        try values.encodeIfPresent(state, forKey: "state")
        try values.encodeIfPresent(uuid, forKey: "uuid")
    }
}

public struct DeploymentEnvironment: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The name of the environment.
    public var name: String?
    /// The UUID identifying the environment.
    public var uuid: String?

    public init(object: Object, name: String? = nil, uuid: String? = nil) {
        self.object = object
        self.name = name
        self.uuid = uuid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(uuid, forKey: "uuid")
    }
}

public struct DeploymentRelease: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var commit: Commit?
    /// The timestamp when the release was created.
    public var createdOn: Date?
    /// The name of the release.
    public var name: String?
    /// Link to the pipeline that produced the release.
    public var url: URL?
    /// The UUID identifying the release.
    public var uuid: String?

    public init(object: Object, commit: Commit? = nil, createdOn: Date? = nil, name: String? = nil, url: URL? = nil, uuid: String? = nil) {
        self.object = object
        self.commit = commit
        self.createdOn = createdOn
        self.name = name
        self.url = url
        self.uuid = uuid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.commit = try Commit(from: decoder)
        self.createdOn = try values.decodeIfPresent(Date.self, forKey: "created_on")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.url = try values.decodeIfPresent(URL.self, forKey: "url")
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(commit, forKey: "commit")
        try values.encodeIfPresent(createdOn, forKey: "created_on")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(url, forKey: "url")
        try values.encodeIfPresent(uuid, forKey: "uuid")
    }
}

public struct DeploymentStateCompleted: Codable {
    public var object: Object
    /// The timestamp when the deployment completed.
    public var completionDate: Date?
    public var deployer: Account?
    /// The name of deployment state (COMPLETED).
    public var name: Name?
    /// The timestamp when the deployment was started.
    public var startDate: Date?
    public var status: Object?
    /// Link to the deployment result.
    public var url: URL?

    /// The name of deployment state (COMPLETED).
    public enum Name: String, Codable, CaseIterable {
        case completed = "COMPLETED"
    }

    public init(object: Object, completionDate: Date? = nil, deployer: Account? = nil, name: Name? = nil, startDate: Date? = nil, status: Object? = nil, url: URL? = nil) {
        self.object = object
        self.completionDate = completionDate
        self.deployer = deployer
        self.name = name
        self.startDate = startDate
        self.status = status
        self.url = url
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.completionDate = try values.decodeIfPresent(Date.self, forKey: "completion_date")
        self.deployer = try Account(from: decoder)
        self.name = try Name(from: decoder)
        self.startDate = try values.decodeIfPresent(Date.self, forKey: "start_date")
        self.status = try Object(from: decoder)
        self.url = try values.decodeIfPresent(URL.self, forKey: "url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(completionDate, forKey: "completion_date")
        try values.encodeIfPresent(deployer, forKey: "deployer")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(startDate, forKey: "start_date")
        try values.encodeIfPresent(status, forKey: "status")
        try values.encodeIfPresent(url, forKey: "url")
    }
}

public struct DeploymentStateCompletedStatusFailed: Codable {
    public var object: Object
    /// The name of the completed deployment status (FAILED).
    public var name: Name?

    /// The name of the completed deployment status (FAILED).
    public enum Name: String, Codable, CaseIterable {
        case failed = "FAILED"
    }

    public init(object: Object, name: Name? = nil) {
        self.object = object
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct DeploymentStateCompletedStatusStopped: Codable {
    public var object: Object
    /// The name of the completed deployment status (STOPPED).
    public var name: Name?

    /// The name of the completed deployment status (STOPPED).
    public enum Name: String, Codable, CaseIterable {
        case stopped = "STOPPED"
    }

    public init(object: Object, name: Name? = nil) {
        self.object = object
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct DeploymentStateCompletedStatusSuccessful: Codable {
    public var object: Object
    /// The name of the completed deployment status (SUCCESSFUL).
    public var name: Name?

    /// The name of the completed deployment status (SUCCESSFUL).
    public enum Name: String, Codable, CaseIterable {
        case successful = "SUCCESSFUL"
    }

    public init(object: Object, name: Name? = nil) {
        self.object = object
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct DeploymentStateInProgress: Codable {
    public var object: Object
    public var deployer: Account?
    /// The name of deployment state (IN_PROGRESS).
    public var name: Name?
    /// The timestamp when the deployment was started.
    public var startDate: Date?
    /// Link to the deployment result.
    public var url: URL?

    /// The name of deployment state (IN_PROGRESS).
    public enum Name: String, Codable, CaseIterable {
        case inProgress = "IN_PROGRESS"
    }

    public init(object: Object, deployer: Account? = nil, name: Name? = nil, startDate: Date? = nil, url: URL? = nil) {
        self.object = object
        self.deployer = deployer
        self.name = name
        self.startDate = startDate
        self.url = url
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.deployer = try Account(from: decoder)
        self.name = try Name(from: decoder)
        self.startDate = try values.decodeIfPresent(Date.self, forKey: "start_date")
        self.url = try values.decodeIfPresent(URL.self, forKey: "url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(deployer, forKey: "deployer")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(startDate, forKey: "start_date")
        try values.encodeIfPresent(url, forKey: "url")
    }
}

public struct DeploymentStateUndeployed: Codable {
    public var object: Object
    /// The name of deployment state (UNDEPLOYED).
    public var name: Name?
    /// Link to trigger the deployment.
    public var triggerURL: URL?

    /// The name of deployment state (UNDEPLOYED).
    public enum Name: String, Codable, CaseIterable {
        case undeployed = "UNDEPLOYED"
    }

    public init(object: Object, name: Name? = nil, triggerURL: URL? = nil) {
        self.object = object
        self.name = name
        self.triggerURL = triggerURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
        self.triggerURL = try values.decodeIfPresent(URL.self, forKey: "trigger_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(triggerURL, forKey: "trigger_url")
    }
}

public struct DeploymentVariable: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The unique name of the variable.
    public var key: String?
    /// If true, this variable will be treated as secured. The value will never be exposed in the logs or the REST API.
    public var isSecured: Bool?
    /// The UUID identifying the variable.
    public var uuid: String?
    /// The value of the variable. If the variable is secured, this will be empty.
    public var value: String?

    public init(object: Object, key: String? = nil, isSecured: Bool? = nil, uuid: String? = nil, value: String? = nil) {
        self.object = object
        self.key = key
        self.isSecured = isSecured
        self.uuid = uuid
        self.value = value
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.key = try values.decodeIfPresent(String.self, forKey: "key")
        self.isSecured = try values.decodeIfPresent(Bool.self, forKey: "secured")
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
        self.value = try values.decodeIfPresent(String.self, forKey: "value")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(key, forKey: "key")
        try values.encodeIfPresent(isSecured, forKey: "secured")
        try values.encodeIfPresent(uuid, forKey: "uuid")
        try values.encodeIfPresent(value, forKey: "value")
    }
}

/// A diffstat object that includes a summary of changes made to a file between two commits.
public struct Diffstat: Codable {
    public var linesAdded: Int?
    public var linesRemoved: Int?
    public var new: CommitFile?
    public var old: CommitFile?
    public var status: Status?
    public var type: String

    public enum Status: String, Codable, CaseIterable {
        case added
        case removed
        case modified
        case renamed
    }

    public init(linesAdded: Int? = nil, linesRemoved: Int? = nil, new: CommitFile? = nil, old: CommitFile? = nil, status: Status? = nil, type: String) {
        self.linesAdded = linesAdded
        self.linesRemoved = linesRemoved
        self.new = new
        self.old = old
        self.status = status
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case linesAdded = "lines_added"
        case linesRemoved = "lines_removed"
        case new
        case old
        case status
        case type
    }
}

/// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
public struct Error: Codable {
    public var error: Error?
    public var type: String

    public struct Error: Codable {
        /// Optional structured data that is endpoint-specific.
        public var data: [String: AnyJSON]?
        public var detail: String?
        public var message: String

        public init(data: [String: AnyJSON]? = nil, detail: String? = nil, message: String) {
            self.data = data
            self.detail = detail
            self.message = message
        }
    }

    public init(error: Error? = nil, type: String) {
        self.error = error
        self.type = type
    }
}

/// Options for issue export.
public struct ExportOptions: Codable {
    public var isIncludeAttachments: Bool?
    public var projectKey: String?
    public var projectName: String?
    public var isSendEmail: Bool?
    public var type: String

    public init(isIncludeAttachments: Bool? = nil, projectKey: String? = nil, projectName: String? = nil, isSendEmail: Bool? = nil, type: String) {
        self.isIncludeAttachments = isIncludeAttachments
        self.projectKey = projectKey
        self.projectName = projectName
        self.isSendEmail = isSendEmail
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case isIncludeAttachments = "include_attachments"
        case projectKey = "project_key"
        case projectName = "project_name"
        case isSendEmail = "send_email"
        case type
    }
}

public struct Group: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The concatenation of the workspace's slug and the group's slug,
    /// separated with a colon (e.g. `acme:developers`)
    public var fullSlug: String?
    public var links: Links?
    public var name: String?
    public var owner: Account?
    /// The "sluggified" version of the group's name. This contains only ASCII
    /// characters and can therefore be slightly different than the name
    public var slug: String?
    public var workspace: Workspace?

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var html: HTML?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct HTML: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(html: HTML? = nil, this: `Self`? = nil) {
            self.html = html
            self.this = this
        }

        private enum CodingKeys: String, CodingKey {
            case html
            case this = "self"
        }
    }

    public init(object: Object, fullSlug: String? = nil, links: Links? = nil, name: String? = nil, owner: Account? = nil, slug: String? = nil, workspace: Workspace? = nil) {
        self.object = object
        self.fullSlug = fullSlug
        self.links = links
        self.name = name
        self.owner = owner
        self.slug = slug
        self.workspace = workspace
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.fullSlug = try values.decodeIfPresent(String.self, forKey: "full_slug")
        self.links = try Links(from: decoder)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.owner = try Account(from: decoder)
        self.slug = try values.decodeIfPresent(String.self, forKey: "slug")
        self.workspace = try Workspace(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(fullSlug, forKey: "full_slug")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(owner, forKey: "owner")
        try values.encodeIfPresent(slug, forKey: "slug")
        try values.encodeIfPresent(workspace, forKey: "workspace")
    }
}

/// An event, associated with a resource or subject type.
public struct HookEvent: Codable {
    /// The category this event belongs to.
    public var category: String?
    /// More detailed description of the webhook event type.
    public var description: String?
    /// The event identifier.
    public var event: Event?
    /// Summary of the webhook event type.
    public var label: String?

    /// The event identifier.
    public enum Event: String, Codable, CaseIterable {
        case pullrequestUnapproved = "pullrequest:unapproved"
        case issueCommentCreated = "issue:comment_created"
        case repoImported = "repo:imported"
        case repoCreated = "repo:created"
        case repoCommitCommentCreated = "repo:commit_comment_created"
        case pullrequestApproved = "pullrequest:approved"
        case pullrequestCommentUpdated = "pullrequest:comment_updated"
        case issueUpdated = "issue:updated"
        case projectUpdated = "project:updated"
        case repoDeleted = "repo:deleted"
        case pullrequestChangesRequestCreated = "pullrequest:changes_request_created"
        case pullrequestCommentCreated = "pullrequest:comment_created"
        case repoCommitStatusUpdated = "repo:commit_status_updated"
        case pullrequestUpdated = "pullrequest:updated"
        case issueCreated = "issue:created"
        case repoFork = "repo:fork"
        case pullrequestCommentDeleted = "pullrequest:comment_deleted"
        case repoCommitStatusCreated = "repo:commit_status_created"
        case repoUpdated = "repo:updated"
        case pullrequestRejected = "pullrequest:rejected"
        case pullrequestFulfilled = "pullrequest:fulfilled"
        case pullrequestCreated = "pullrequest:created"
        case pullrequestChangesRequestRemoved = "pullrequest:changes_request_removed"
        case repoTransfer = "repo:transfer"
        case repoPush = "repo:push"
    }

    public init(category: String? = nil, description: String? = nil, event: Event? = nil, label: String? = nil) {
        self.category = category
        self.description = description
        self.event = event
        self.label = label
    }
}

public struct Issue: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var assignee: User?
    public var component: Component?
    public var content: Content?
    public var createdOn: Date?
    public var editedOn: Date?
    public var id: Int?
    public var kind: Kind?
    public var links: Links?
    public var milestone: Milestone?
    public var priority: Priority?
    public var reporter: User?
    public var repository: Repository?
    public var state: State?
    public var title: String?
    public var updatedOn: Date?
    public var version: Version?
    public var votes: Int?

    public struct Content: Codable {
        /// The user's content rendered as HTML.
        public var html: String?
        /// The type of markup language the raw content is to be interpreted in.
        public var markup: Markup?
        /// The text as it was typed by a user.
        public var raw: String?

        /// The type of markup language the raw content is to be interpreted in.
        public enum Markup: String, Codable, CaseIterable {
            case markdown
            case creole
            case plaintext
        }

        public init(html: String? = nil, markup: Markup? = nil, raw: String? = nil) {
            self.html = html
            self.markup = markup
            self.raw = raw
        }
    }

    public enum Kind: String, Codable, CaseIterable {
        case bug
        case enhancement
        case proposal
        case task
    }

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var attachments: Attachments?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var comments: Comments?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var html: HTML?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var vote: Vote?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var watch: Watch?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Attachments: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Comments: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct HTML: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Vote: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Watch: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(attachments: Attachments? = nil, comments: Comments? = nil, html: HTML? = nil, this: `Self`? = nil, vote: Vote? = nil, watch: Watch? = nil) {
            self.attachments = attachments
            self.comments = comments
            self.html = html
            self.this = this
            self.vote = vote
            self.watch = watch
        }

        private enum CodingKeys: String, CodingKey {
            case attachments
            case comments
            case html
            case this = "self"
            case vote
            case watch
        }
    }

    public enum Priority: String, Codable, CaseIterable {
        case trivial
        case minor
        case major
        case critical
        case blocker
    }

    public enum State: String, Codable, CaseIterable {
        case new
        case `open`
        case resolved
        case onHold = "on hold"
        case invalid
        case duplicate
        case wontfix
        case closed
    }

    public init(object: Object, assignee: User? = nil, component: Component? = nil, content: Content? = nil, createdOn: Date? = nil, editedOn: Date? = nil, id: Int? = nil, kind: Kind? = nil, links: Links? = nil, milestone: Milestone? = nil, priority: Priority? = nil, reporter: User? = nil, repository: Repository? = nil, state: State? = nil, title: String? = nil, updatedOn: Date? = nil, version: Version? = nil, votes: Int? = nil) {
        self.object = object
        self.assignee = assignee
        self.component = component
        self.content = content
        self.createdOn = createdOn
        self.editedOn = editedOn
        self.id = id
        self.kind = kind
        self.links = links
        self.milestone = milestone
        self.priority = priority
        self.reporter = reporter
        self.repository = repository
        self.state = state
        self.title = title
        self.updatedOn = updatedOn
        self.version = version
        self.votes = votes
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.assignee = try User(from: decoder)
        self.component = try Component(from: decoder)
        self.content = try Content(from: decoder)
        self.createdOn = try values.decodeIfPresent(Date.self, forKey: "created_on")
        self.editedOn = try values.decodeIfPresent(Date.self, forKey: "edited_on")
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.kind = try Kind(from: decoder)
        self.links = try Links(from: decoder)
        self.milestone = try Milestone(from: decoder)
        self.priority = try Priority(from: decoder)
        self.reporter = try User(from: decoder)
        self.repository = try Repository(from: decoder)
        self.state = try State(from: decoder)
        self.title = try values.decodeIfPresent(String.self, forKey: "title")
        self.updatedOn = try values.decodeIfPresent(Date.self, forKey: "updated_on")
        self.version = try Version(from: decoder)
        self.votes = try values.decodeIfPresent(Int.self, forKey: "votes")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(assignee, forKey: "assignee")
        try values.encodeIfPresent(component, forKey: "component")
        try values.encodeIfPresent(content, forKey: "content")
        try values.encodeIfPresent(createdOn, forKey: "created_on")
        try values.encodeIfPresent(editedOn, forKey: "edited_on")
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(kind, forKey: "kind")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(milestone, forKey: "milestone")
        try values.encodeIfPresent(priority, forKey: "priority")
        try values.encodeIfPresent(reporter, forKey: "reporter")
        try values.encodeIfPresent(repository, forKey: "repository")
        try values.encodeIfPresent(state, forKey: "state")
        try values.encodeIfPresent(title, forKey: "title")
        try values.encodeIfPresent(updatedOn, forKey: "updated_on")
        try values.encodeIfPresent(version, forKey: "version")
        try values.encodeIfPresent(votes, forKey: "votes")
    }
}

public struct IssueAttachment: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var links: Links?
    public var name: String?

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(this: `Self`? = nil) {
            self.this = this
        }

        private enum CodingKeys: String, CodingKey {
            case this = "self"
        }
    }

    public init(object: Object, links: Links? = nil, name: String? = nil) {
        self.object = object
        self.links = links
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.links = try Links(from: decoder)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

/// An issue change.
public struct IssueChange: Codable {
    public var changes: Changes?
    public var createdOn: Date?
    public var issue: Issue?
    public var links: Links?
    public var message: Message?
    public var name: String?
    public var type: String
    public var user: User?

    public struct Changes: Codable {
        public var assignee: Assignee?
        public var component: Component?
        public var content: Content?
        public var kind: Kind?
        public var milestone: Milestone?
        public var priority: Priority?
        public var state: State?
        public var title: Title?
        public var version: Version?

        public struct Assignee: Codable {
            public var new: String?
            public var old: String?

            public init(new: String? = nil, old: String? = nil) {
                self.new = new
                self.old = old
            }
        }

        public struct Component: Codable {
            public var new: String?
            public var old: String?

            public init(new: String? = nil, old: String? = nil) {
                self.new = new
                self.old = old
            }
        }

        public struct Content: Codable {
            public var new: String?
            public var old: String?

            public init(new: String? = nil, old: String? = nil) {
                self.new = new
                self.old = old
            }
        }

        public struct Kind: Codable {
            public var new: String?
            public var old: String?

            public init(new: String? = nil, old: String? = nil) {
                self.new = new
                self.old = old
            }
        }

        public struct Milestone: Codable {
            public var new: String?
            public var old: String?

            public init(new: String? = nil, old: String? = nil) {
                self.new = new
                self.old = old
            }
        }

        public struct Priority: Codable {
            public var new: String?
            public var old: String?

            public init(new: String? = nil, old: String? = nil) {
                self.new = new
                self.old = old
            }
        }

        public struct State: Codable {
            public var new: String?
            public var old: String?

            public init(new: String? = nil, old: String? = nil) {
                self.new = new
                self.old = old
            }
        }

        public struct Title: Codable {
            public var new: String?
            public var old: String?

            public init(new: String? = nil, old: String? = nil) {
                self.new = new
                self.old = old
            }
        }

        public struct Version: Codable {
            public var new: String?
            public var old: String?

            public init(new: String? = nil, old: String? = nil) {
                self.new = new
                self.old = old
            }
        }

        public init(assignee: Assignee? = nil, component: Component? = nil, content: Content? = nil, kind: Kind? = nil, milestone: Milestone? = nil, priority: Priority? = nil, state: State? = nil, title: Title? = nil, version: Version? = nil) {
            self.assignee = assignee
            self.component = component
            self.content = content
            self.kind = kind
            self.milestone = milestone
            self.priority = priority
            self.state = state
            self.title = title
            self.version = version
        }
    }

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var issue: Issue?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Issue: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(issue: Issue? = nil, this: `Self`? = nil) {
            self.issue = issue
            self.this = this
        }

        private enum CodingKeys: String, CodingKey {
            case issue
            case this = "self"
        }
    }

    public struct Message: Codable {
        /// The user's content rendered as HTML.
        public var html: String?
        /// The type of markup language the raw content is to be interpreted in.
        public var markup: Markup?
        /// The text as it was typed by a user.
        public var raw: String?

        /// The type of markup language the raw content is to be interpreted in.
        public enum Markup: String, Codable, CaseIterable {
            case markdown
            case creole
            case plaintext
        }

        public init(html: String? = nil, markup: Markup? = nil, raw: String? = nil) {
            self.html = html
            self.markup = markup
            self.raw = raw
        }
    }

    public init(changes: Changes? = nil, createdOn: Date? = nil, issue: Issue? = nil, links: Links? = nil, message: Message? = nil, name: String? = nil, type: String, user: User? = nil) {
        self.changes = changes
        self.createdOn = createdOn
        self.issue = issue
        self.links = links
        self.message = message
        self.name = name
        self.type = type
        self.user = user
    }

    private enum CodingKeys: String, CodingKey {
        case changes
        case createdOn = "created_on"
        case issue
        case links
        case message
        case name
        case type
        case user
    }
}

public struct IssueComment: Codable {
    public var comment: Comment
    public var issue: Issue?

    public init(comment: Comment, issue: Issue? = nil) {
        self.comment = comment
        self.issue = issue
    }

    public init(from decoder: Decoder) throws {
        self.comment = try Comment(from: decoder)
        self.issue = try Issue(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(comment, forKey: "comment")
        try values.encodeIfPresent(issue, forKey: "issue")
    }
}

/// The status of an import or export job
public struct IssueJobStatus: Codable {
    /// The total number of issues already imported/exported
    public var count: Int?
    /// The percentage of issues already imported/exported
    public var pct: Double?
    /// The phase of the import/export job
    public var phase: String?
    /// The status of the import/export job
    public var status: Status?
    /// The total number of issues being imported/exported
    public var total: Int?
    public var type: String?

    /// The status of the import/export job
    public enum Status: String, Codable, CaseIterable {
        case accepted = "ACCEPTED"
        case started = "STARTED"
        case running = "RUNNING"
        case failure = "FAILURE"
    }

    public init(count: Int? = nil, pct: Double? = nil, phase: String? = nil, status: Status? = nil, total: Int? = nil, type: String? = nil) {
        self.count = count
        self.pct = pct
        self.phase = phase
        self.status = status
        self.total = total
        self.type = type
    }
}

public struct Milestone: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var id: Int?
    public var links: Links?
    public var name: String?

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(this: `Self`? = nil) {
            self.this = this
        }

        private enum CodingKeys: String, CodingKey {
            case this = "self"
        }
    }

    public init(object: Object, id: Int? = nil, links: Links? = nil, name: String? = nil) {
        self.object = object
        self.id = id
        self.links = links
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.links = try Links(from: decoder)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

/// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
public struct Object: Codable {
    public var type: String

    public init(type: String) {
        self.type = type
    }
}

public struct Page: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
    }
}

/// A paginated list of annotations.
public struct PaginatedAnnotations: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    /// The values of the current page.
    public var values: [ReportAnnotation]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [ReportAnnotation]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of branches.
public struct PaginatedBranches: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [Branch]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Branch]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of branch restriction rules.
public struct PaginatedBranchrestrictions: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [Branchrestriction]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Branchrestriction]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// Page
///
/// A paginated list of commits.
public struct PaginatedChangeset: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [BaseCommit]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [BaseCommit]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of commit comments.
public struct PaginatedCommitComments: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [CommitComment]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [CommitComment]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of commit status objects.
public struct PaginatedCommitstatuses: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [Commitstatus]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Commitstatus]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of issue tracker components.
public struct PaginatedComponents: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [Component]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Component]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of deploy keys.
public struct PaginatedDeployKeys: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [DeployKey]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [DeployKey]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// Paginated Deployment Variables
///
/// A paged list of deployment variables.
public struct PaginatedDeploymentVariable: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    /// The values of the current page.
    public var values: [DeploymentVariable]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [DeploymentVariable]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paged list of deployments
public struct PaginatedDeployments: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    /// The values of the current page.
    public var values: [Deployment]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Deployment]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// Paginated Diff Stat
///
/// A paginated list of diffstats.
public struct PaginatedDiffstats: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 500 with 5000 being the maximum allowed value.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [Diffstat]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Diffstat]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// Paginated Deployment Environments
///
/// A paged list of environments
public struct PaginatedEnvironments: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    /// The values of the current page.
    public var values: [DeploymentEnvironment]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [DeploymentEnvironment]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of commit_file objects.
public struct PaginatedFiles: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [CommitFile]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [CommitFile]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of webhook types available to subscribe on.
public struct PaginatedHookEvents: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [HookEvent]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [HookEvent]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// Paginated Issue Attachment
///
/// A paginated list of issue attachments.
public struct PaginatedIssueAttachments: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [IssueAttachment]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [IssueAttachment]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of issue comments.
public struct PaginatedIssueComments: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [IssueComment]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [IssueComment]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of issues.
public struct PaginatedIssues: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [Issue]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Issue]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of issue changes.
public struct PaginatedLogEntries: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [IssueChange]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [IssueChange]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of issue tracker milestones.
public struct PaginatedMilestones: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [Milestone]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Milestone]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// Paginated Pipeline Cache
///
/// A paged list of pipeline caches
public struct PaginatedPipelineCaches: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    /// The values of the current page.
    public var values: [PipelineCache]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [PipelineCache]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paged list of known hosts.
public struct PaginatedPipelineKnownHosts: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    /// The values of the current page.
    public var values: [PipelineKnownHost]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [PipelineKnownHost]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paged list of the executions of a schedule.
public struct PaginatedPipelineScheduleExecutions: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    /// The values of the current page.
    public var values: [Object]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Object]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// Paginated Pipeline Schedule
///
/// A paged list of schedules
public struct PaginatedPipelineSchedules: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    /// The values of the current page.
    public var values: [PipelineSchedule]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [PipelineSchedule]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paged list of pipeline steps.
public struct PaginatedPipelineSteps: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    /// The values of the current page.
    public var values: [PipelineStep]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [PipelineStep]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paged list of variables.
public struct PaginatedPipelineVariables: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    /// The values of the current page.
    public var values: [PipelineVariable]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [PipelineVariable]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paged list of pipelines
public struct PaginatedPipelines: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    /// The values of the current page.
    public var values: [Pipeline]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Pipeline]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of projects
public struct PaginatedProjects: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [Project]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Project]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of pullrequest comments.
public struct PaginatedPullrequestComments: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [PullrequestComment]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [PullrequestComment]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of pullrequests.
public struct PaginatedPullrequests: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [Pullrequest]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Pullrequest]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of refs.
public struct PaginatedRefs: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [Ref]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Ref]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of reports.
public struct PaginatedReports: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    /// The values of the current page.
    public var values: [Report]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Report]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of repositories.
public struct PaginatedRepositories: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [Repository]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Repository]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of repository permissions.
public struct PaginatedRepositoryPermissions: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [RepositoryPermission]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [RepositoryPermission]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of snippet comments.
public struct PaginatedSnippetComments: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [SnippetComment]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [SnippetComment]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// Paginated Snippet Commits
///
/// A paginated list of snippet commits.
public struct PaginatedSnippetCommit: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [SnippetCommit]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [SnippetCommit]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of snippets.
public struct PaginatedSnippets: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [Snippet]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Snippet]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of SSH keys.
public struct PaginatedSshUserKeys: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [SshAccountKey]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [SshAccountKey]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of tags.
public struct PaginatedTags: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [Tag]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Tag]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of team permissions.
public struct PaginatedTeamPermissions: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [TeamPermission]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [TeamPermission]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of teams.
public struct PaginatedTeams: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [Account]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Account]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// Paginated Tree Entry
///
/// A paginated list of commit_file and/or commit_directory objects.
public struct PaginatedTreeentries: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [Treeentry]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Treeentry]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of users.
public struct PaginatedUsers: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [User]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [User]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of issue tracker versions.
public struct PaginatedVersions: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [Version]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Version]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of webhook subscriptions
public struct PaginatedWebhookSubscriptions: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [WebhookSubscription]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [WebhookSubscription]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of workspace memberships.
public struct PaginatedWorkspaceMemberships: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [WorkspaceMembership]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [WorkspaceMembership]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

/// A paginated list of workspaces.
public struct PaginatedWorkspaces: Codable {
    /// Link to the next page if it exists. The last page of a collection does not have this value. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var next: URL?
    /// Page number of the current results. This is an optional element that is not provided in all responses.
    public var page: Int?
    /// Current number of objects on the existing page. The default value is 10 with 100 being the maximum allowed value. Individual APIs may enforce different values.
    public var pagelen: Int?
    /// Link to previous page if it exists. A collections first page does not have this value. This is an optional element that is not provided in all responses. Some result sets strictly support forward navigation and never provide previous links. Clients must anticipate that backwards navigation is not always available. Use this link to navigate the result set and refrain from constructing your own URLs.
    public var previous: URL?
    /// Total number of objects in the response. This is an optional element that is not provided in all responses, as it can be expensive to compute.
    public var size: Int?
    public var values: [Workspace]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, size: Int? = nil, values: [Workspace]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.size = size
        self.values = values
    }
}

public struct Participant: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var isApproved: Bool?
    /// The ISO8601 timestamp of the participant's action. For approvers, this is the time of their approval. For commenters and pull request reviewers who are not approvers, this is the time they last commented, or null if they have not commented.
    public var participatedOn: Date?
    public var role: Role?
    public var state: State?
    public var user: User?

    public enum Role: String, Codable, CaseIterable {
        case participant = "PARTICIPANT"
        case reviewer = "REVIEWER"
    }

    public enum State: String, Codable, CaseIterable {
        case approved
        case changesRequested = "changes_requested"
        case null
    }

    public init(object: Object, isApproved: Bool? = nil, participatedOn: Date? = nil, role: Role? = nil, state: State? = nil, user: User? = nil) {
        self.object = object
        self.isApproved = isApproved
        self.participatedOn = participatedOn
        self.role = role
        self.state = state
        self.user = user
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.isApproved = try values.decodeIfPresent(Bool.self, forKey: "approved")
        self.participatedOn = try values.decodeIfPresent(Date.self, forKey: "participated_on")
        self.role = try Role(from: decoder)
        self.state = try State(from: decoder)
        self.user = try User(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(isApproved, forKey: "approved")
        try values.encodeIfPresent(participatedOn, forKey: "participated_on")
        try values.encodeIfPresent(role, forKey: "role")
        try values.encodeIfPresent(state, forKey: "state")
        try values.encodeIfPresent(user, forKey: "user")
    }
}

public struct Pipeline: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The build number of the pipeline.
    public var buildNumber: Int?
    /// The number of build seconds used by this pipeline.
    public var buildSecondsUsed: Int?
    /// The timestamp when the Pipeline was completed. This is not set if the pipeline is still in progress.
    public var completedOn: Date?
    /// The timestamp when the pipeline was created.
    public var createdOn: Date?
    public var creator: Account?
    public var repository: Repository?
    public var state: Object?
    public var target: Object?
    public var trigger: Object?
    /// The UUID identifying the pipeline.
    public var uuid: String?

    public init(object: Object, buildNumber: Int? = nil, buildSecondsUsed: Int? = nil, completedOn: Date? = nil, createdOn: Date? = nil, creator: Account? = nil, repository: Repository? = nil, state: Object? = nil, target: Object? = nil, trigger: Object? = nil, uuid: String? = nil) {
        self.object = object
        self.buildNumber = buildNumber
        self.buildSecondsUsed = buildSecondsUsed
        self.completedOn = completedOn
        self.createdOn = createdOn
        self.creator = creator
        self.repository = repository
        self.state = state
        self.target = target
        self.trigger = trigger
        self.uuid = uuid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.buildNumber = try values.decodeIfPresent(Int.self, forKey: "build_number")
        self.buildSecondsUsed = try values.decodeIfPresent(Int.self, forKey: "build_seconds_used")
        self.completedOn = try values.decodeIfPresent(Date.self, forKey: "completed_on")
        self.createdOn = try values.decodeIfPresent(Date.self, forKey: "created_on")
        self.creator = try Account(from: decoder)
        self.repository = try Repository(from: decoder)
        self.state = try Object(from: decoder)
        self.target = try Object(from: decoder)
        self.trigger = try Object(from: decoder)
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(buildNumber, forKey: "build_number")
        try values.encodeIfPresent(buildSecondsUsed, forKey: "build_seconds_used")
        try values.encodeIfPresent(completedOn, forKey: "completed_on")
        try values.encodeIfPresent(createdOn, forKey: "created_on")
        try values.encodeIfPresent(creator, forKey: "creator")
        try values.encodeIfPresent(repository, forKey: "repository")
        try values.encodeIfPresent(state, forKey: "state")
        try values.encodeIfPresent(target, forKey: "target")
        try values.encodeIfPresent(trigger, forKey: "trigger")
        try values.encodeIfPresent(uuid, forKey: "uuid")
    }
}

public struct PipelineBuildNumber: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The next number that will be used as build number.
    public var next: Int?

    public init(object: Object, next: Int? = nil) {
        self.object = object
        self.next = next
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.next = try values.decodeIfPresent(Int.self, forKey: "next")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(next, forKey: "next")
    }
}

public struct PipelineCache: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The timestamp when the cache was created.
    public var createdOn: Date?
    /// The size of the file containing the archive of the cache.
    public var fileSizeBytes: Int?
    /// The name of the cache.
    public var name: String?
    /// The path where the cache contents were retrieved from.
    public var path: String?
    /// The UUID of the pipeline that created the cache.
    public var pipelineUUID: String?
    /// The uuid of the step that created the cache.
    public var stepUUID: String?
    /// The UUID identifying the pipeline cache.
    public var uuid: String?

    public init(object: Object, createdOn: Date? = nil, fileSizeBytes: Int? = nil, name: String? = nil, path: String? = nil, pipelineUUID: String? = nil, stepUUID: String? = nil, uuid: String? = nil) {
        self.object = object
        self.createdOn = createdOn
        self.fileSizeBytes = fileSizeBytes
        self.name = name
        self.path = path
        self.pipelineUUID = pipelineUUID
        self.stepUUID = stepUUID
        self.uuid = uuid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.createdOn = try values.decodeIfPresent(Date.self, forKey: "created_on")
        self.fileSizeBytes = try values.decodeIfPresent(Int.self, forKey: "file_size_bytes")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.path = try values.decodeIfPresent(String.self, forKey: "path")
        self.pipelineUUID = try values.decodeIfPresent(String.self, forKey: "pipeline_uuid")
        self.stepUUID = try values.decodeIfPresent(String.self, forKey: "step_uuid")
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(createdOn, forKey: "created_on")
        try values.encodeIfPresent(fileSizeBytes, forKey: "file_size_bytes")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(path, forKey: "path")
        try values.encodeIfPresent(pipelineUUID, forKey: "pipeline_uuid")
        try values.encodeIfPresent(stepUUID, forKey: "step_uuid")
        try values.encodeIfPresent(uuid, forKey: "uuid")
    }
}

/// A representation of the location of pipeline cache content.
public struct PipelineCacheContentUri: Codable {
    /// The uri for pipeline cache content.
    public var uri: URL?

    public init(uri: URL? = nil) {
        self.uri = uri
    }
}

/// An executable pipeline command.
public struct PipelineCommand: Codable {
    /// The executable command.
    public var command: String?
    /// The name of the command.
    public var name: String?

    public init(command: String? = nil, name: String? = nil) {
        self.command = command
        self.name = name
    }
}

public struct PipelineCommitTarget: Codable {
    public var object: Object
    public var commit: Commit?
    public var selector: PipelineSelector?

    public init(object: Object, commit: Commit? = nil, selector: PipelineSelector? = nil) {
        self.object = object
        self.commit = commit
        self.selector = selector
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.commit = try Commit(from: decoder)
        self.selector = try PipelineSelector(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(commit, forKey: "commit")
        try values.encodeIfPresent(selector, forKey: "selector")
    }
}

public struct PipelineError: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The error key.
    public var key: String?
    /// The error message.
    public var message: String?

    public init(object: Object, key: String? = nil, message: String? = nil) {
        self.object = object
        self.key = key
        self.message = message
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.key = try values.decodeIfPresent(String.self, forKey: "key")
        self.message = try values.decodeIfPresent(String.self, forKey: "message")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(key, forKey: "key")
        try values.encodeIfPresent(message, forKey: "message")
    }
}

/// The definition of a Docker image that can be used for a Bitbucket Pipelines step execution context.
public struct PipelineImage: Codable {
    /// The email needed to authenticate with the Docker registry. Only required when using a private Docker image.
    public var email: String?
    /// The name of the image. If the image is hosted on DockerHub the short name can be used, otherwise the fully qualified name is required here.
    public var name: String?
    /// The password needed to authenticate with the Docker registry. Only required when using a private Docker image.
    public var password: String?
    /// The username needed to authenticate with the Docker registry. Only required when using a private Docker image.
    public var username: String?

    public init(email: String? = nil, name: String? = nil, password: String? = nil, username: String? = nil) {
        self.email = email
        self.name = name
        self.password = password
        self.username = username
    }
}

public struct PipelineKnownHost: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The hostname of the known host.
    public var hostname: String?
    public var publicKey: PipelineSshPublicKey?
    /// The UUID identifying the known host.
    public var uuid: String?

    public init(object: Object, hostname: String? = nil, publicKey: PipelineSshPublicKey? = nil, uuid: String? = nil) {
        self.object = object
        self.hostname = hostname
        self.publicKey = publicKey
        self.uuid = uuid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.hostname = try values.decodeIfPresent(String.self, forKey: "hostname")
        self.publicKey = try PipelineSshPublicKey(from: decoder)
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(hostname, forKey: "hostname")
        try values.encodeIfPresent(publicKey, forKey: "public_key")
        try values.encodeIfPresent(uuid, forKey: "uuid")
    }
}

public struct PipelineRefTarget: Codable {
    public var object: Object
    public var commit: Commit?
    /// The name of the reference.
    public var refName: String?
    /// The type of reference (branch/tag).
    public var refType: RefType?
    public var selector: PipelineSelector?

    /// The type of reference (branch/tag).
    public enum RefType: String, Codable, CaseIterable {
        case branch
        case tag
        case namedBranch = "named_branch"
        case bookmark
    }

    public init(object: Object, commit: Commit? = nil, refName: String? = nil, refType: RefType? = nil, selector: PipelineSelector? = nil) {
        self.object = object
        self.commit = commit
        self.refName = refName
        self.refType = refType
        self.selector = selector
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.commit = try Commit(from: decoder)
        self.refName = try values.decodeIfPresent(String.self, forKey: "ref_name")
        self.refType = try RefType(from: decoder)
        self.selector = try PipelineSelector(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(commit, forKey: "commit")
        try values.encodeIfPresent(refName, forKey: "ref_name")
        try values.encodeIfPresent(refType, forKey: "ref_type")
        try values.encodeIfPresent(selector, forKey: "selector")
    }
}

public struct PipelineSchedule: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The timestamp when the schedule was created.
    public var createdOn: Date?
    /// The cron expression that the schedule applies.
    public var cronPattern: String?
    /// Whether the schedule is enabled.
    public var isEnabled: Bool?
    public var selector: PipelineSelector?
    public var target: Object?
    /// The timestamp when the schedule was updated.
    public var updatedOn: Date?
    /// The UUID identifying the schedule.
    public var uuid: String?

    public init(object: Object, createdOn: Date? = nil, cronPattern: String? = nil, isEnabled: Bool? = nil, selector: PipelineSelector? = nil, target: Object? = nil, updatedOn: Date? = nil, uuid: String? = nil) {
        self.object = object
        self.createdOn = createdOn
        self.cronPattern = cronPattern
        self.isEnabled = isEnabled
        self.selector = selector
        self.target = target
        self.updatedOn = updatedOn
        self.uuid = uuid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.createdOn = try values.decodeIfPresent(Date.self, forKey: "created_on")
        self.cronPattern = try values.decodeIfPresent(String.self, forKey: "cron_pattern")
        self.isEnabled = try values.decodeIfPresent(Bool.self, forKey: "enabled")
        self.selector = try PipelineSelector(from: decoder)
        self.target = try Object(from: decoder)
        self.updatedOn = try values.decodeIfPresent(Date.self, forKey: "updated_on")
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(createdOn, forKey: "created_on")
        try values.encodeIfPresent(cronPattern, forKey: "cron_pattern")
        try values.encodeIfPresent(isEnabled, forKey: "enabled")
        try values.encodeIfPresent(selector, forKey: "selector")
        try values.encodeIfPresent(target, forKey: "target")
        try values.encodeIfPresent(updatedOn, forKey: "updated_on")
        try values.encodeIfPresent(uuid, forKey: "uuid")
    }
}

public struct PipelineScheduleExecutionErrored: Codable {
    public var object: Object
    public var error: PipelineError?

    public init(object: Object, error: PipelineError? = nil) {
        self.object = object
        self.error = error
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.error = try PipelineError(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(error, forKey: "error")
    }
}

public struct PipelineScheduleExecutionExecuted: Codable {
    public var object: Object
    public var pipeline: Pipeline?

    public init(object: Object, pipeline: Pipeline? = nil) {
        self.object = object
        self.pipeline = pipeline
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.pipeline = try Pipeline(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(pipeline, forKey: "pipeline")
    }
}

public struct PipelineSelector: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The name of the matching pipeline definition.
    public var pattern: String?
    /// The type of selector.
    public var type: `Type`?

    /// The type of selector.
    public enum `Type`: String, Codable, CaseIterable {
        case branches
        case tags
        case bookmarks
        case `default`
        case custom
    }

    public init(object: Object, pattern: String? = nil, type: `Type`? = nil) {
        self.object = object
        self.pattern = pattern
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.pattern = try values.decodeIfPresent(String.self, forKey: "pattern")
        self.type = try `Type`(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(pattern, forKey: "pattern")
        try values.encodeIfPresent(type, forKey: "type")
    }
}

public struct PipelineSshKeyPair: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The SSH private key. This value will be empty when retrieving the SSH key pair.
    public var privateKey: String?
    /// The SSH public key.
    public var publicKey: String?

    public init(object: Object, privateKey: String? = nil, publicKey: String? = nil) {
        self.object = object
        self.privateKey = privateKey
        self.publicKey = publicKey
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.privateKey = try values.decodeIfPresent(String.self, forKey: "private_key")
        self.publicKey = try values.decodeIfPresent(String.self, forKey: "public_key")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(privateKey, forKey: "private_key")
        try values.encodeIfPresent(publicKey, forKey: "public_key")
    }
}

public struct PipelineSshPublicKey: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The base64 encoded public key.
    public var key: String?
    /// The type of the public key.
    public var keyType: String?
    /// The MD5 fingerprint of the public key.
    public var md5Fingerprint: String?
    /// The SHA-256 fingerprint of the public key.
    public var sha256Fingerprint: String?

    public init(object: Object, key: String? = nil, keyType: String? = nil, md5Fingerprint: String? = nil, sha256Fingerprint: String? = nil) {
        self.object = object
        self.key = key
        self.keyType = keyType
        self.md5Fingerprint = md5Fingerprint
        self.sha256Fingerprint = sha256Fingerprint
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.key = try values.decodeIfPresent(String.self, forKey: "key")
        self.keyType = try values.decodeIfPresent(String.self, forKey: "key_type")
        self.md5Fingerprint = try values.decodeIfPresent(String.self, forKey: "md5_fingerprint")
        self.sha256Fingerprint = try values.decodeIfPresent(String.self, forKey: "sha256_fingerprint")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(key, forKey: "key")
        try values.encodeIfPresent(keyType, forKey: "key_type")
        try values.encodeIfPresent(md5Fingerprint, forKey: "md5_fingerprint")
        try values.encodeIfPresent(sha256Fingerprint, forKey: "sha256_fingerprint")
    }
}

public struct PipelineStateCompleted: Codable {
    public var object: Object
    /// The name of pipeline state (COMPLETED).
    public var name: Name?
    public var result: Object?

    /// The name of pipeline state (COMPLETED).
    public enum Name: String, Codable, CaseIterable {
        case completed = "COMPLETED"
    }

    public init(object: Object, name: Name? = nil, result: Object? = nil) {
        self.object = object
        self.name = name
        self.result = result
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
        self.result = try Object(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(result, forKey: "result")
    }
}

public struct PipelineStateCompletedError: Codable {
    public var object: Object
    public var error: PipelineError?
    /// The name of the result (ERROR)
    public var name: Name?

    /// The name of the result (ERROR)
    public enum Name: String, Codable, CaseIterable {
        case error = "ERROR"
    }

    public init(object: Object, error: PipelineError? = nil, name: Name? = nil) {
        self.object = object
        self.error = error
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.error = try PipelineError(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(error, forKey: "error")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct PipelineStateCompletedExpired: Codable {
    public var object: Object
    /// The name of the stopped result (EXPIRED).
    public var name: Name?

    /// The name of the stopped result (EXPIRED).
    public enum Name: String, Codable, CaseIterable {
        case expired = "EXPIRED"
    }

    public init(object: Object, name: Name? = nil) {
        self.object = object
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct PipelineStateCompletedFailed: Codable {
    public var object: Object
    /// The name of the failed result (FAILED).
    public var name: Name?

    /// The name of the failed result (FAILED).
    public enum Name: String, Codable, CaseIterable {
        case failed = "FAILED"
    }

    public init(object: Object, name: Name? = nil) {
        self.object = object
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct PipelineStateCompletedStopped: Codable {
    public var object: Object
    /// The name of the stopped result (STOPPED).
    public var name: Name?

    /// The name of the stopped result (STOPPED).
    public enum Name: String, Codable, CaseIterable {
        case stopped = "STOPPED"
    }

    public init(object: Object, name: Name? = nil) {
        self.object = object
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct PipelineStateCompletedSuccessful: Codable {
    public var object: Object
    /// The name of the successful result (SUCCESSFUL).
    public var name: Name?

    /// The name of the successful result (SUCCESSFUL).
    public enum Name: String, Codable, CaseIterable {
        case successful = "SUCCESSFUL"
    }

    public init(object: Object, name: Name? = nil) {
        self.object = object
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct PipelineStateInProgress: Codable {
    public var object: Object
    /// The name of pipeline state (IN_PROGRESS).
    public var name: Name?
    public var stage: Object?

    /// The name of pipeline state (IN_PROGRESS).
    public enum Name: String, Codable, CaseIterable {
        case inProgress = "IN_PROGRESS"
    }

    public init(object: Object, name: Name? = nil, stage: Object? = nil) {
        self.object = object
        self.name = name
        self.stage = stage
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
        self.stage = try Object(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(stage, forKey: "stage")
    }
}

public struct PipelineStateInProgressPaused: Codable {
    public var object: Object
    /// The name of the stage (PAUSED)
    public var name: Name?

    /// The name of the stage (PAUSED)
    public enum Name: String, Codable, CaseIterable {
        case paused = "PAUSED"
    }

    public init(object: Object, name: Name? = nil) {
        self.object = object
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct PipelineStateInProgressRunning: Codable {
    public var object: Object
    /// The name of the stage (RUNNING)
    public var name: Name?

    /// The name of the stage (RUNNING)
    public enum Name: String, Codable, CaseIterable {
        case running = "RUNNING"
    }

    public init(object: Object, name: Name? = nil) {
        self.object = object
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct PipelineStatePending: Codable {
    public var object: Object
    /// The name of pipeline state (PENDING).
    public var name: Name?

    /// The name of pipeline state (PENDING).
    public enum Name: String, Codable, CaseIterable {
        case pending = "PENDING"
    }

    public init(object: Object, name: Name? = nil) {
        self.object = object
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct PipelineStep: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The timestamp when the step execution was completed. This is not set if the step is still in progress.
    public var completedOn: Date?
    /// Pipeline Image
    ///
    /// The definition of a Docker image that can be used for a Bitbucket Pipelines step execution context.
    public var image: PipelineImage?
    /// The list of build commands. These commands are executed in the build container.
    public var scriptCommands: [PipelineCommand]?
    /// The list of commands that are executed as part of the setup phase of the build. These commands are executed outside the build container.
    public var setupCommands: [PipelineCommand]?
    /// The timestamp when the step execution was started. This is not set when the step hasn't executed yet.
    public var startedOn: Date?
    public var state: Object?
    /// The UUID identifying the step.
    public var uuid: String?

    public init(object: Object, completedOn: Date? = nil, image: PipelineImage? = nil, scriptCommands: [PipelineCommand]? = nil, setupCommands: [PipelineCommand]? = nil, startedOn: Date? = nil, state: Object? = nil, uuid: String? = nil) {
        self.object = object
        self.completedOn = completedOn
        self.image = image
        self.scriptCommands = scriptCommands
        self.setupCommands = setupCommands
        self.startedOn = startedOn
        self.state = state
        self.uuid = uuid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.completedOn = try values.decodeIfPresent(Date.self, forKey: "completed_on")
        self.image = try PipelineImage(from: decoder)
        self.scriptCommands = try values.decodeIfPresent([PipelineCommand].self, forKey: "script_commands")
        self.setupCommands = try values.decodeIfPresent([PipelineCommand].self, forKey: "setup_commands")
        self.startedOn = try values.decodeIfPresent(Date.self, forKey: "started_on")
        self.state = try Object(from: decoder)
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(completedOn, forKey: "completed_on")
        try values.encodeIfPresent(image, forKey: "image")
        try values.encodeIfPresent(scriptCommands, forKey: "script_commands")
        try values.encodeIfPresent(setupCommands, forKey: "setup_commands")
        try values.encodeIfPresent(startedOn, forKey: "started_on")
        try values.encodeIfPresent(state, forKey: "state")
        try values.encodeIfPresent(uuid, forKey: "uuid")
    }
}

public struct PipelineStepError: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The error key.
    public var key: String?
    /// The error message.
    public var message: String?

    public init(object: Object, key: String? = nil, message: String? = nil) {
        self.object = object
        self.key = key
        self.message = message
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.key = try values.decodeIfPresent(String.self, forKey: "key")
        self.message = try values.decodeIfPresent(String.self, forKey: "message")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(key, forKey: "key")
        try values.encodeIfPresent(message, forKey: "message")
    }
}

public struct PipelineStepStateCompleted: Codable {
    public var object: Object
    /// The name of pipeline step state (COMPLETED).
    public var name: Name?
    public var result: Object?

    /// The name of pipeline step state (COMPLETED).
    public enum Name: String, Codable, CaseIterable {
        case completed = "COMPLETED"
    }

    public init(object: Object, name: Name? = nil, result: Object? = nil) {
        self.object = object
        self.name = name
        self.result = result
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
        self.result = try Object(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(result, forKey: "result")
    }
}

public struct PipelineStepStateCompletedError: Codable {
    public var object: Object
    public var error: PipelineStepError?
    /// The name of the result (ERROR)
    public var name: Name?

    /// The name of the result (ERROR)
    public enum Name: String, Codable, CaseIterable {
        case error = "ERROR"
    }

    public init(object: Object, error: PipelineStepError? = nil, name: Name? = nil) {
        self.object = object
        self.error = error
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.error = try PipelineStepError(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(error, forKey: "error")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct PipelineStepStateCompletedExpired: Codable {
    public var object: Object
    /// The name of the result (EXPIRED)
    public var name: Name?

    /// The name of the result (EXPIRED)
    public enum Name: String, Codable, CaseIterable {
        case expired = "EXPIRED"
    }

    public init(object: Object, name: Name? = nil) {
        self.object = object
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct PipelineStepStateCompletedFailed: Codable {
    public var object: Object
    /// The name of the result (FAILED)
    public var name: Name?

    /// The name of the result (FAILED)
    public enum Name: String, Codable, CaseIterable {
        case failed = "FAILED"
    }

    public init(object: Object, name: Name? = nil) {
        self.object = object
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct PipelineStepStateCompletedNotRun: Codable {
    public var object: Object
    /// The name of the result (NOT_RUN)
    public var name: Name?

    /// The name of the result (NOT_RUN)
    public enum Name: String, Codable, CaseIterable {
        case notRun = "NOT_RUN"
    }

    public init(object: Object, name: Name? = nil) {
        self.object = object
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct PipelineStepStateCompletedStopped: Codable {
    public var object: Object
    /// The name of the result (STOPPED)
    public var name: Name?

    /// The name of the result (STOPPED)
    public enum Name: String, Codable, CaseIterable {
        case stopped = "STOPPED"
    }

    public init(object: Object, name: Name? = nil) {
        self.object = object
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct PipelineStepStateCompletedSuccessful: Codable {
    public var object: Object
    /// The name of the result (SUCCESSFUL)
    public var name: Name?

    /// The name of the result (SUCCESSFUL)
    public enum Name: String, Codable, CaseIterable {
        case successful = "SUCCESSFUL"
    }

    public init(object: Object, name: Name? = nil) {
        self.object = object
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct PipelineStepStateInProgress: Codable {
    public var object: Object
    /// The name of pipeline step state (IN_PROGRESS).
    public var name: Name?

    /// The name of pipeline step state (IN_PROGRESS).
    public enum Name: String, Codable, CaseIterable {
        case inProgress = "IN_PROGRESS"
    }

    public init(object: Object, name: Name? = nil) {
        self.object = object
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct PipelineStepStatePending: Codable {
    public var object: Object
    /// The name of pipeline step state (PENDING).
    public var name: Name?

    /// The name of pipeline step state (PENDING).
    public enum Name: String, Codable, CaseIterable {
        case pending = "PENDING"
    }

    public init(object: Object, name: Name? = nil) {
        self.object = object
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct PipelineStepStateReady: Codable {
    public var object: Object
    /// The name of pipeline step state (READY).
    public var name: Name?

    /// The name of pipeline step state (READY).
    public enum Name: String, Codable, CaseIterable {
        case ready = "READY"
    }

    public init(object: Object, name: Name? = nil) {
        self.object = object
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.name = try Name(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct PipelineVariable: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The unique name of the variable.
    public var key: String?
    /// If true, this variable will be treated as secured. The value will never be exposed in the logs or the REST API.
    public var isSecured: Bool?
    /// The UUID identifying the variable.
    public var uuid: String?
    /// The value of the variable. If the variable is secured, this will be empty.
    public var value: String?

    public init(object: Object, key: String? = nil, isSecured: Bool? = nil, uuid: String? = nil, value: String? = nil) {
        self.object = object
        self.key = key
        self.isSecured = isSecured
        self.uuid = uuid
        self.value = value
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.key = try values.decodeIfPresent(String.self, forKey: "key")
        self.isSecured = try values.decodeIfPresent(Bool.self, forKey: "secured")
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
        self.value = try values.decodeIfPresent(String.self, forKey: "value")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(key, forKey: "key")
        try values.encodeIfPresent(isSecured, forKey: "secured")
        try values.encodeIfPresent(uuid, forKey: "uuid")
        try values.encodeIfPresent(value, forKey: "value")
    }
}

public struct PipelinesConfig: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// Whether Pipelines is enabled for the repository.
    public var isEnabled: Bool?
    public var repository: Repository?

    public init(object: Object, isEnabled: Bool? = nil, repository: Repository? = nil) {
        self.object = object
        self.isEnabled = isEnabled
        self.repository = repository
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.isEnabled = try values.decodeIfPresent(Bool.self, forKey: "enabled")
        self.repository = try Repository(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(isEnabled, forKey: "enabled")
        try values.encodeIfPresent(repository, forKey: "repository")
    }
}

public struct Project: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var createdOn: Date?
    public var description: String?
    /// Indicates whether the project is publicly accessible, or whether it is
    /// private to the team and consequently only visible to team members.
    /// Note that private projects cannot contain public repositories.
    public var isPrivate: Bool?
    /// The project's key.
    public var key: String?
    public var links: Links?
    /// The name of the project.
    public var name: String?
    public var owner: Account?
    public var updatedOn: Date?
    /// The project's immutable id.
    public var uuid: String?

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var avatar: Avatar?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var html: HTML?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Avatar: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct HTML: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(avatar: Avatar? = nil, html: HTML? = nil) {
            self.avatar = avatar
            self.html = html
        }
    }

    public init(object: Object, createdOn: Date? = nil, description: String? = nil, isPrivate: Bool? = nil, key: String? = nil, links: Links? = nil, name: String? = nil, owner: Account? = nil, updatedOn: Date? = nil, uuid: String? = nil) {
        self.object = object
        self.createdOn = createdOn
        self.description = description
        self.isPrivate = isPrivate
        self.key = key
        self.links = links
        self.name = name
        self.owner = owner
        self.updatedOn = updatedOn
        self.uuid = uuid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.createdOn = try values.decodeIfPresent(Date.self, forKey: "created_on")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.isPrivate = try values.decodeIfPresent(Bool.self, forKey: "is_private")
        self.key = try values.decodeIfPresent(String.self, forKey: "key")
        self.links = try Links(from: decoder)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.owner = try Account(from: decoder)
        self.updatedOn = try values.decodeIfPresent(Date.self, forKey: "updated_on")
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(createdOn, forKey: "created_on")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(isPrivate, forKey: "is_private")
        try values.encodeIfPresent(key, forKey: "key")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(owner, forKey: "owner")
        try values.encodeIfPresent(updatedOn, forKey: "updated_on")
        try values.encodeIfPresent(uuid, forKey: "uuid")
    }
}

public struct Pullrequest: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var author: Account?
    /// A boolean flag indicating if merging the pull request closes the source branch.
    public var isCloseSourceBranch: Bool?
    public var closedBy: Account?
    /// The number of comments for a specific pull request.
    public var commentCount: Int?
    /// The ISO8601 timestamp the request was created.
    public var createdOn: Date?
    public var destination: PullrequestEndpoint?
    /// The pull request's unique ID. Note that pull request IDs are only unique within their associated repository.
    public var id: Int?
    public var links: Links?
    /// Pull Request Commit
    public var mergeCommit: MergeCommit?
    /// The list of users that are collaborating on this pull request.
    ///         Collaborators are user that:
    /// 
    ///         * are added to the pull request as a reviewer (part of the reviewers
    ///           list)
    ///         * are not explicit reviewers, but have commented on the pull request
    ///         * are not explicit reviewers, but have approved the pull request
    /// 
    ///         Each user is wrapped in an object that indicates the user's role and
    ///         whether they have approved the pull request. For performance reasons,
    ///         the API only returns this list when an API requests a pull request by
    ///         id.
    public var participants: [Participant]?
    /// Explains why a pull request was declined. This field is only applicable to pull requests in rejected state.
    public var reason: String?
    /// Rendered Pull Request Markup
    ///
    /// User provided pull request text, interpreted in a markup language and rendered in HTML
    public var rendered: Rendered?
    /// The list of users that were added as reviewers on this pull request when it was created. For performance reasons, the API only includes this list on a pull request's `self` URL.
    public var reviewers: [Account]?
    public var source: PullrequestEndpoint?
    /// The pull request's current status.
    public var state: State?
    public var summary: Summary?
    /// The number of open tasks for a specific pull request.
    public var taskCount: Int?
    /// Title of the pull request.
    public var title: String?
    /// The ISO8601 timestamp the request was last updated.
    public var updatedOn: Date?

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var activity: Activity?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var approve: Approve?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var comments: Comments?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var commits: Commits?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var decline: Decline?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var diff: Diff?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var diffstat: Diffstat?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var html: HTML?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var merge: Merge?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Activity: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Approve: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Comments: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Commits: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Decline: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Diff: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Diffstat: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct HTML: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Merge: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(activity: Activity? = nil, approve: Approve? = nil, comments: Comments? = nil, commits: Commits? = nil, decline: Decline? = nil, diff: Diff? = nil, diffstat: Diffstat? = nil, html: HTML? = nil, merge: Merge? = nil, this: `Self`? = nil) {
            self.activity = activity
            self.approve = approve
            self.comments = comments
            self.commits = commits
            self.decline = decline
            self.diff = diff
            self.diffstat = diffstat
            self.html = html
            self.merge = merge
            self.this = this
        }

        private enum CodingKeys: String, CodingKey {
            case activity
            case approve
            case comments
            case commits
            case decline
            case diff
            case diffstat
            case html
            case merge
            case this = "self"
        }
    }

    /// Pull Request Commit
    public struct MergeCommit: Codable {
        public var hash: String?

        public init(hash: String? = nil) {
            self.hash = hash
        }
    }

    /// Rendered Pull Request Markup
    ///
    /// User provided pull request text, interpreted in a markup language and rendered in HTML
    public struct Rendered: Codable {
        public var description: Description?
        public var reason: Reason?
        public var title: Title?

        public struct Description: Codable {
            /// The user's content rendered as HTML.
            public var html: String?
            /// The type of markup language the raw content is to be interpreted in.
            public var markup: Markup?
            /// The text as it was typed by a user.
            public var raw: String?

            /// The type of markup language the raw content is to be interpreted in.
            public enum Markup: String, Codable, CaseIterable {
                case markdown
                case creole
                case plaintext
            }

            public init(html: String? = nil, markup: Markup? = nil, raw: String? = nil) {
                self.html = html
                self.markup = markup
                self.raw = raw
            }
        }

        public struct Reason: Codable {
            /// The user's content rendered as HTML.
            public var html: String?
            /// The type of markup language the raw content is to be interpreted in.
            public var markup: Markup?
            /// The text as it was typed by a user.
            public var raw: String?

            /// The type of markup language the raw content is to be interpreted in.
            public enum Markup: String, Codable, CaseIterable {
                case markdown
                case creole
                case plaintext
            }

            public init(html: String? = nil, markup: Markup? = nil, raw: String? = nil) {
                self.html = html
                self.markup = markup
                self.raw = raw
            }
        }

        public struct Title: Codable {
            /// The user's content rendered as HTML.
            public var html: String?
            /// The type of markup language the raw content is to be interpreted in.
            public var markup: Markup?
            /// The text as it was typed by a user.
            public var raw: String?

            /// The type of markup language the raw content is to be interpreted in.
            public enum Markup: String, Codable, CaseIterable {
                case markdown
                case creole
                case plaintext
            }

            public init(html: String? = nil, markup: Markup? = nil, raw: String? = nil) {
                self.html = html
                self.markup = markup
                self.raw = raw
            }
        }

        public init(description: Description? = nil, reason: Reason? = nil, title: Title? = nil) {
            self.description = description
            self.reason = reason
            self.title = title
        }
    }

    /// The pull request's current status.
    public enum State: String, Codable, CaseIterable {
        case merged = "MERGED"
        case superseded = "SUPERSEDED"
        case `open` = "OPEN"
        case declined = "DECLINED"
    }

    public struct Summary: Codable {
        /// The user's content rendered as HTML.
        public var html: String?
        /// The type of markup language the raw content is to be interpreted in.
        public var markup: Markup?
        /// The text as it was typed by a user.
        public var raw: String?

        /// The type of markup language the raw content is to be interpreted in.
        public enum Markup: String, Codable, CaseIterable {
            case markdown
            case creole
            case plaintext
        }

        public init(html: String? = nil, markup: Markup? = nil, raw: String? = nil) {
            self.html = html
            self.markup = markup
            self.raw = raw
        }
    }

    public init(object: Object, author: Account? = nil, isCloseSourceBranch: Bool? = nil, closedBy: Account? = nil, commentCount: Int? = nil, createdOn: Date? = nil, destination: PullrequestEndpoint? = nil, id: Int? = nil, links: Links? = nil, mergeCommit: MergeCommit? = nil, participants: [Participant]? = nil, reason: String? = nil, rendered: Rendered? = nil, reviewers: [Account]? = nil, source: PullrequestEndpoint? = nil, state: State? = nil, summary: Summary? = nil, taskCount: Int? = nil, title: String? = nil, updatedOn: Date? = nil) {
        self.object = object
        self.author = author
        self.isCloseSourceBranch = isCloseSourceBranch
        self.closedBy = closedBy
        self.commentCount = commentCount
        self.createdOn = createdOn
        self.destination = destination
        self.id = id
        self.links = links
        self.mergeCommit = mergeCommit
        self.participants = participants
        self.reason = reason
        self.rendered = rendered
        self.reviewers = reviewers
        self.source = source
        self.state = state
        self.summary = summary
        self.taskCount = taskCount
        self.title = title
        self.updatedOn = updatedOn
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.author = try Account(from: decoder)
        self.isCloseSourceBranch = try values.decodeIfPresent(Bool.self, forKey: "close_source_branch")
        self.closedBy = try Account(from: decoder)
        self.commentCount = try values.decodeIfPresent(Int.self, forKey: "comment_count")
        self.createdOn = try values.decodeIfPresent(Date.self, forKey: "created_on")
        self.destination = try PullrequestEndpoint(from: decoder)
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.links = try Links(from: decoder)
        self.mergeCommit = try MergeCommit(from: decoder)
        self.participants = try values.decodeIfPresent([Participant].self, forKey: "participants")
        self.reason = try values.decodeIfPresent(String.self, forKey: "reason")
        self.rendered = try Rendered(from: decoder)
        self.reviewers = try values.decodeIfPresent([Account].self, forKey: "reviewers")
        self.source = try PullrequestEndpoint(from: decoder)
        self.state = try State(from: decoder)
        self.summary = try Summary(from: decoder)
        self.taskCount = try values.decodeIfPresent(Int.self, forKey: "task_count")
        self.title = try values.decodeIfPresent(String.self, forKey: "title")
        self.updatedOn = try values.decodeIfPresent(Date.self, forKey: "updated_on")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(author, forKey: "author")
        try values.encodeIfPresent(isCloseSourceBranch, forKey: "close_source_branch")
        try values.encodeIfPresent(closedBy, forKey: "closed_by")
        try values.encodeIfPresent(commentCount, forKey: "comment_count")
        try values.encodeIfPresent(createdOn, forKey: "created_on")
        try values.encodeIfPresent(destination, forKey: "destination")
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(mergeCommit, forKey: "merge_commit")
        try values.encodeIfPresent(participants, forKey: "participants")
        try values.encodeIfPresent(reason, forKey: "reason")
        try values.encodeIfPresent(rendered, forKey: "rendered")
        try values.encodeIfPresent(reviewers, forKey: "reviewers")
        try values.encodeIfPresent(source, forKey: "source")
        try values.encodeIfPresent(state, forKey: "state")
        try values.encodeIfPresent(summary, forKey: "summary")
        try values.encodeIfPresent(taskCount, forKey: "task_count")
        try values.encodeIfPresent(title, forKey: "title")
        try values.encodeIfPresent(updatedOn, forKey: "updated_on")
    }
}

public struct PullrequestComment: Codable {
    public var comment: Comment
    public var pullrequest: Pullrequest?

    public init(comment: Comment, pullrequest: Pullrequest? = nil) {
        self.comment = comment
        self.pullrequest = pullrequest
    }

    public init(from decoder: Decoder) throws {
        self.comment = try Comment(from: decoder)
        self.pullrequest = try Pullrequest(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(comment, forKey: "comment")
        try values.encodeIfPresent(pullrequest, forKey: "pullrequest")
    }
}

public struct PullrequestEndpoint: Codable {
    /// Pull Request Branch
    public var branch: Branch?
    /// Pull Request Commit
    public var commit: Commit?
    public var repository: Repository?

    /// Pull Request Branch
    public struct Branch: Codable {
        /// The default merge strategy, when this endpoint is the destination of the pull request.
        public var defaultMergeStrategy: String?
        /// Available merge strategies, when this endpoint is the destination of the pull request.
        public var mergeStrategies: [MergeStrategy]?
        public var name: String?

        public enum MergeStrategy: String, Codable, CaseIterable {
            case mergeCommit = "merge_commit"
            case squash
            case fastForward = "fast_forward"
        }

        public init(defaultMergeStrategy: String? = nil, mergeStrategies: [MergeStrategy]? = nil, name: String? = nil) {
            self.defaultMergeStrategy = defaultMergeStrategy
            self.mergeStrategies = mergeStrategies
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case defaultMergeStrategy = "default_merge_strategy"
            case mergeStrategies = "merge_strategies"
            case name
        }
    }

    /// Pull Request Commit
    public struct Commit: Codable {
        public var hash: String?

        public init(hash: String? = nil) {
            self.hash = hash
        }
    }

    public init(branch: Branch? = nil, commit: Commit? = nil, repository: Repository? = nil) {
        self.branch = branch
        self.commit = commit
        self.repository = repository
    }
}

/// The metadata that describes a pull request merge.
public struct PullrequestMergeParameters: Codable {
    /// Whether the source branch should be deleted. If this is not provided, we fallback to the value used when the pull request was created, which defaults to False
    public var isCloseSourceBranch: Bool?
    /// The merge strategy that will be used to merge the pull request.
    public var mergeStrategy: MergeStrategy?
    /// The commit message that will be used on the resulting commit.
    public var message: String?
    public var type: String

    /// The merge strategy that will be used to merge the pull request.
    public enum MergeStrategy: String, Codable, CaseIterable {
        case mergeCommit = "merge_commit"
        case squash
        case fastForward = "fast_forward"
    }

    public init(isCloseSourceBranch: Bool? = nil, mergeStrategy: MergeStrategy? = nil, message: String? = nil, type: String) {
        self.isCloseSourceBranch = isCloseSourceBranch
        self.mergeStrategy = mergeStrategy
        self.message = message
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case isCloseSourceBranch = "close_source_branch"
        case mergeStrategy = "merge_strategy"
        case message
        case type
    }
}

/// A ref object, representing a branch or tag in a repository.
public struct Ref: Codable {
    public var links: Links?
    /// The name of the ref.
    public var name: String?
    public var target: Commit?
    public var type: String

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var commits: Commits?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var html: HTML?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Commits: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct HTML: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(commits: Commits? = nil, html: HTML? = nil, this: `Self`? = nil) {
            self.commits = commits
            self.html = html
            self.this = this
        }

        private enum CodingKeys: String, CodingKey {
            case commits
            case html
            case this = "self"
        }
    }

    public init(links: Links? = nil, name: String? = nil, target: Commit? = nil, type: String) {
        self.links = links
        self.name = name
        self.target = target
        self.type = type
    }
}

public struct Report: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The timestamp when the report was created.
    public var createdOn: Date?
    /// An array of data fields to display information on the report. Maximum 10.
    public var data: [ReportData]?
    /// A string to describe the purpose of the report.
    public var details: String?
    /// ID of the report provided by the report creator. It can be used to identify the report as an alternative to it's generated uuid. It is not used by Bitbucket, but only by the report creator for updating or deleting this specific report. Needs to be unique.
    public var externalID: String?
    /// A URL linking to the results of the report in an external tool.
    public var link: URL?
    /// A URL to the report logo. If none is provided, the default insights logo will be used.
    public var logoURL: URL?
    /// If enabled, a remote link is created in Jira for the issue associated with the commit the report belongs to.
    public var isRemoteLinkEnabled: Bool?
    /// The type of the report.
    public var reportType: ReportType?
    /// A string to describe the tool or company who created the report.
    public var reporter: String?
    /// The state of the report. May be set to PENDING and later updated.
    public var result: Result?
    /// The title of the report.
    public var title: String?
    /// The timestamp when the report was updated.
    public var updatedOn: Date?
    /// The UUID that can be used to identify the report.
    public var uuid: String?

    /// The type of the report.
    public enum ReportType: String, Codable, CaseIterable {
        case security = "SECURITY"
        case coverage = "COVERAGE"
        case test = "TEST"
        case bug = "BUG"
    }

    /// The state of the report. May be set to PENDING and later updated.
    public enum Result: String, Codable, CaseIterable {
        case passed = "PASSED"
        case failed = "FAILED"
        case pending = "PENDING"
    }

    public init(object: Object, createdOn: Date? = nil, data: [ReportData]? = nil, details: String? = nil, externalID: String? = nil, link: URL? = nil, logoURL: URL? = nil, isRemoteLinkEnabled: Bool? = nil, reportType: ReportType? = nil, reporter: String? = nil, result: Result? = nil, title: String? = nil, updatedOn: Date? = nil, uuid: String? = nil) {
        self.object = object
        self.createdOn = createdOn
        self.data = data
        self.details = details
        self.externalID = externalID
        self.link = link
        self.logoURL = logoURL
        self.isRemoteLinkEnabled = isRemoteLinkEnabled
        self.reportType = reportType
        self.reporter = reporter
        self.result = result
        self.title = title
        self.updatedOn = updatedOn
        self.uuid = uuid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.createdOn = try values.decodeIfPresent(Date.self, forKey: "created_on")
        self.data = try values.decodeIfPresent([ReportData].self, forKey: "data")
        self.details = try values.decodeIfPresent(String.self, forKey: "details")
        self.externalID = try values.decodeIfPresent(String.self, forKey: "external_id")
        self.link = try values.decodeIfPresent(URL.self, forKey: "link")
        self.logoURL = try values.decodeIfPresent(URL.self, forKey: "logo_url")
        self.isRemoteLinkEnabled = try values.decodeIfPresent(Bool.self, forKey: "remote_link_enabled")
        self.reportType = try ReportType(from: decoder)
        self.reporter = try values.decodeIfPresent(String.self, forKey: "reporter")
        self.result = try Result(from: decoder)
        self.title = try values.decodeIfPresent(String.self, forKey: "title")
        self.updatedOn = try values.decodeIfPresent(Date.self, forKey: "updated_on")
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(createdOn, forKey: "created_on")
        try values.encodeIfPresent(data, forKey: "data")
        try values.encodeIfPresent(details, forKey: "details")
        try values.encodeIfPresent(externalID, forKey: "external_id")
        try values.encodeIfPresent(link, forKey: "link")
        try values.encodeIfPresent(logoURL, forKey: "logo_url")
        try values.encodeIfPresent(isRemoteLinkEnabled, forKey: "remote_link_enabled")
        try values.encodeIfPresent(reportType, forKey: "report_type")
        try values.encodeIfPresent(reporter, forKey: "reporter")
        try values.encodeIfPresent(result, forKey: "result")
        try values.encodeIfPresent(title, forKey: "title")
        try values.encodeIfPresent(updatedOn, forKey: "updated_on")
        try values.encodeIfPresent(uuid, forKey: "uuid")
    }
}

public struct ReportAnnotation: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The type of the report.
    public var annotationType: AnnotationType?
    /// The timestamp when the report was created.
    public var createdOn: Date?
    /// The details to show to users when clicking on the annotation.
    public var details: String?
    /// ID of the annotation provided by the annotation creator. It can be used to identify the annotation as an alternative to it's generated uuid. It is not used by Bitbucket, but only by the annotation creator for updating or deleting this specific annotation. Needs to be unique.
    public var externalID: String?
    /// The line number that the annotation should belong to. If no line number is provided, then it will default to 0 and in a pull request it will appear at the top of the file specified by the path field.
    public var line: Int?
    /// A URL linking to the annotation in an external tool.
    public var link: URL?
    /// The path of the file on which this annotation should be placed. This is the path of the file relative to the git repository. If no path is provided, then it will appear in the overview modal on all pull requests where the tip of the branch is the given commit, regardless of which files were modified.
    public var path: String?
    /// The state of the report. May be set to PENDING and later updated.
    public var result: Result?
    /// The severity of the annotation.
    public var severity: Severity?
    /// The message to display to users.
    public var summary: String?
    /// The timestamp when the report was updated.
    public var updatedOn: Date?
    /// The UUID that can be used to identify the annotation.
    public var uuid: String?

    /// The type of the report.
    public enum AnnotationType: String, Codable, CaseIterable {
        case vulnerability = "VULNERABILITY"
        case codeSmell = "CODE_SMELL"
        case bug = "BUG"
    }

    /// The state of the report. May be set to PENDING and later updated.
    public enum Result: String, Codable, CaseIterable {
        case passed = "PASSED"
        case failed = "FAILED"
        case skipped = "SKIPPED"
        case ignored = "IGNORED"
    }

    /// The severity of the annotation.
    public enum Severity: String, Codable, CaseIterable {
        case critical = "CRITICAL"
        case high = "HIGH"
        case medium = "MEDIUM"
        case low = "LOW"
    }

    public init(object: Object, annotationType: AnnotationType? = nil, createdOn: Date? = nil, details: String? = nil, externalID: String? = nil, line: Int? = nil, link: URL? = nil, path: String? = nil, result: Result? = nil, severity: Severity? = nil, summary: String? = nil, updatedOn: Date? = nil, uuid: String? = nil) {
        self.object = object
        self.annotationType = annotationType
        self.createdOn = createdOn
        self.details = details
        self.externalID = externalID
        self.line = line
        self.link = link
        self.path = path
        self.result = result
        self.severity = severity
        self.summary = summary
        self.updatedOn = updatedOn
        self.uuid = uuid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.annotationType = try AnnotationType(from: decoder)
        self.createdOn = try values.decodeIfPresent(Date.self, forKey: "created_on")
        self.details = try values.decodeIfPresent(String.self, forKey: "details")
        self.externalID = try values.decodeIfPresent(String.self, forKey: "external_id")
        self.line = try values.decodeIfPresent(Int.self, forKey: "line")
        self.link = try values.decodeIfPresent(URL.self, forKey: "link")
        self.path = try values.decodeIfPresent(String.self, forKey: "path")
        self.result = try Result(from: decoder)
        self.severity = try Severity(from: decoder)
        self.summary = try values.decodeIfPresent(String.self, forKey: "summary")
        self.updatedOn = try values.decodeIfPresent(Date.self, forKey: "updated_on")
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(annotationType, forKey: "annotation_type")
        try values.encodeIfPresent(createdOn, forKey: "created_on")
        try values.encodeIfPresent(details, forKey: "details")
        try values.encodeIfPresent(externalID, forKey: "external_id")
        try values.encodeIfPresent(line, forKey: "line")
        try values.encodeIfPresent(link, forKey: "link")
        try values.encodeIfPresent(path, forKey: "path")
        try values.encodeIfPresent(result, forKey: "result")
        try values.encodeIfPresent(severity, forKey: "severity")
        try values.encodeIfPresent(summary, forKey: "summary")
        try values.encodeIfPresent(updatedOn, forKey: "updated_on")
        try values.encodeIfPresent(uuid, forKey: "uuid")
    }
}

/// A key-value element that will be displayed along with the report.
public struct ReportData: Codable {
    /// A string describing what this data field represents.
    public var title: String?
    /// The type of data contained in the value field. If not provided, then the value will be detected as a boolean, number or string.
    public var type: `Type`?
    /// The value of the data element.
    public var value: [String: AnyJSON]?

    /// The type of data contained in the value field. If not provided, then the value will be detected as a boolean, number or string.
    public enum `Type`: String, Codable, CaseIterable {
        case boolean = "BOOLEAN"
        case date = "DATE"
        case duration = "DURATION"
        case link = "LINK"
        case number = "NUMBER"
        case percentage = "PERCENTAGE"
        case text = "TEXT"
    }

    public init(title: String? = nil, type: `Type`? = nil, value: [String: AnyJSON]? = nil) {
        self.title = title
        self.type = type
        self.value = value
    }
}

public final class Repository: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var createdOn: Date?
    public var description: String?
    /// Controls the rules for forking this repository.
    /// 
    /// * **allow_forks**: unrestricted forking
    /// * **no_public_forks**: restrict forking to private forks (forks cannot
    ///   be made public later)
    /// * **no_forks**: deny all forking
    public var forkPolicy: ForkPolicy?
    /// The concatenation of the repository owner's username and the slugified name, e.g. "evzijst/interruptingcow". This is the same string used in Bitbucket URLs.
    public var fullName: String?
    public var hasIssues: Bool?
    public var hasWiki: Bool?
    public var isPrivate: Bool?
    public var language: String?
    public var links: Links?
    public var mainbranch: Branch?
    public var name: String?
    public var owner: Account?
    public var parent: Repository?
    public var project: Project?
    public var scm: Scm?
    public var size: Int?
    public var updatedOn: Date?
    /// The repository's immutable id. This can be used as a substitute for the slug segment in URLs. Doing this guarantees your URLs will survive renaming of the repository by its owner, or even transfer of the repository to a different user.
    public var uuid: String?

    /// Controls the rules for forking this repository.
    /// 
    /// * **allow_forks**: unrestricted forking
    /// * **no_public_forks**: restrict forking to private forks (forks cannot
    ///   be made public later)
    /// * **no_forks**: deny all forking
    public enum ForkPolicy: String, Codable, CaseIterable {
        case allowForks = "allow_forks"
        case noPublicForks = "no_public_forks"
        case noForks = "no_forks"
    }

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var avatar: Avatar?
        public var clone: [CloneItem]?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var commits: Commits?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var downloads: Downloads?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var forks: Forks?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var hooks: Hooks?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var html: HTML?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var pullrequests: Pullrequests?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var watchers: Watchers?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Avatar: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct CloneItem: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Commits: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Downloads: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Forks: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Hooks: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct HTML: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Pullrequests: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Watchers: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(avatar: Avatar? = nil, clone: [CloneItem]? = nil, commits: Commits? = nil, downloads: Downloads? = nil, forks: Forks? = nil, hooks: Hooks? = nil, html: HTML? = nil, pullrequests: Pullrequests? = nil, this: `Self`? = nil, watchers: Watchers? = nil) {
            self.avatar = avatar
            self.clone = clone
            self.commits = commits
            self.downloads = downloads
            self.forks = forks
            self.hooks = hooks
            self.html = html
            self.pullrequests = pullrequests
            self.this = this
            self.watchers = watchers
        }

        private enum CodingKeys: String, CodingKey {
            case avatar
            case clone
            case commits
            case downloads
            case forks
            case hooks
            case html
            case pullrequests
            case this = "self"
            case watchers
        }
    }

    public enum Scm: String, Codable, CaseIterable {
        case git
    }

    public init(object: Object, createdOn: Date? = nil, description: String? = nil, forkPolicy: ForkPolicy? = nil, fullName: String? = nil, hasIssues: Bool? = nil, hasWiki: Bool? = nil, isPrivate: Bool? = nil, language: String? = nil, links: Links? = nil, mainbranch: Branch? = nil, name: String? = nil, owner: Account? = nil, parent: Repository? = nil, project: Project? = nil, scm: Scm? = nil, size: Int? = nil, updatedOn: Date? = nil, uuid: String? = nil) {
        self.object = object
        self.createdOn = createdOn
        self.description = description
        self.forkPolicy = forkPolicy
        self.fullName = fullName
        self.hasIssues = hasIssues
        self.hasWiki = hasWiki
        self.isPrivate = isPrivate
        self.language = language
        self.links = links
        self.mainbranch = mainbranch
        self.name = name
        self.owner = owner
        self.parent = parent
        self.project = project
        self.scm = scm
        self.size = size
        self.updatedOn = updatedOn
        self.uuid = uuid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.createdOn = try values.decodeIfPresent(Date.self, forKey: "created_on")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.forkPolicy = try ForkPolicy(from: decoder)
        self.fullName = try values.decodeIfPresent(String.self, forKey: "full_name")
        self.hasIssues = try values.decodeIfPresent(Bool.self, forKey: "has_issues")
        self.hasWiki = try values.decodeIfPresent(Bool.self, forKey: "has_wiki")
        self.isPrivate = try values.decodeIfPresent(Bool.self, forKey: "is_private")
        self.language = try values.decodeIfPresent(String.self, forKey: "language")
        self.links = try Links(from: decoder)
        self.mainbranch = try Branch(from: decoder)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.owner = try Account(from: decoder)
        self.parent = try Repository(from: decoder)
        self.project = try Project(from: decoder)
        self.scm = try Scm(from: decoder)
        self.size = try values.decodeIfPresent(Int.self, forKey: "size")
        self.updatedOn = try values.decodeIfPresent(Date.self, forKey: "updated_on")
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(createdOn, forKey: "created_on")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(forkPolicy, forKey: "fork_policy")
        try values.encodeIfPresent(fullName, forKey: "full_name")
        try values.encodeIfPresent(hasIssues, forKey: "has_issues")
        try values.encodeIfPresent(hasWiki, forKey: "has_wiki")
        try values.encodeIfPresent(isPrivate, forKey: "is_private")
        try values.encodeIfPresent(language, forKey: "language")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(mainbranch, forKey: "mainbranch")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(owner, forKey: "owner")
        try values.encodeIfPresent(parent, forKey: "parent")
        try values.encodeIfPresent(project, forKey: "project")
        try values.encodeIfPresent(scm, forKey: "scm")
        try values.encodeIfPresent(size, forKey: "size")
        try values.encodeIfPresent(updatedOn, forKey: "updated_on")
        try values.encodeIfPresent(uuid, forKey: "uuid")
    }
}

/// A user's permission for a given repository.
public struct RepositoryPermission: Codable {
    public var permission: Permission?
    public var repository: Repository?
    public var type: String
    public var user: User?

    public enum Permission: String, Codable, CaseIterable {
        case admin
        case write
        case read
    }

    public init(permission: Permission? = nil, repository: Repository? = nil, type: String, user: User? = nil) {
        self.permission = permission
        self.repository = repository
        self.type = type
        self.user = user
    }
}

public struct SearchCodeSearchResult: Codable {
    public var contentMatchCount: Int?
    public var contentMatches: [SearchContentMatch]?
    public var file: CommitFile?
    public var pathMatches: [SearchSegment]?
    public var type: String?

    public init(contentMatchCount: Int? = nil, contentMatches: [SearchContentMatch]? = nil, file: CommitFile? = nil, pathMatches: [SearchSegment]? = nil, type: String? = nil) {
        self.contentMatchCount = contentMatchCount
        self.contentMatches = contentMatches
        self.file = file
        self.pathMatches = pathMatches
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case contentMatchCount = "content_match_count"
        case contentMatches = "content_matches"
        case file
        case pathMatches = "path_matches"
        case type
    }
}

public struct SearchContentMatch: Codable {
    public var lines: [SearchLine]?

    public init(lines: [SearchLine]? = nil) {
        self.lines = lines
    }
}

public struct SearchLine: Codable {
    public var line: Int?
    public var segments: [SearchSegment]?

    public init(line: Int? = nil, segments: [SearchSegment]? = nil) {
        self.line = line
        self.segments = segments
    }
}

public struct SearchResultPage: Codable {
    public var next: URL?
    public var page: Int?
    public var pagelen: Int?
    public var previous: URL?
    public var isQuerySubstituted: Bool?
    public var size: Int?
    public var values: [SearchCodeSearchResult]?

    public init(next: URL? = nil, page: Int? = nil, pagelen: Int? = nil, previous: URL? = nil, isQuerySubstituted: Bool? = nil, size: Int? = nil, values: [SearchCodeSearchResult]? = nil) {
        self.next = next
        self.page = page
        self.pagelen = pagelen
        self.previous = previous
        self.isQuerySubstituted = isQuerySubstituted
        self.size = size
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case next
        case page
        case pagelen
        case previous
        case isQuerySubstituted = "query_substituted"
        case size
        case values
    }
}

public struct SearchSegment: Codable {
    public var isMatch: Bool?
    public var text: String?

    public init(isMatch: Bool? = nil, text: String? = nil) {
        self.isMatch = isMatch
        self.text = text
    }

    private enum CodingKeys: String, CodingKey {
        case isMatch = "match"
        case text
    }
}

public struct Snippet: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var createdOn: Date?
    public var creator: Account?
    public var id: Int?
    public var isPrivate: Bool?
    public var owner: Account?
    /// The DVCS used to store the snippet.
    public var scm: Scm?
    public var title: String?
    public var updatedOn: Date?

    /// The DVCS used to store the snippet.
    public enum Scm: String, Codable, CaseIterable {
        case git
    }

    public init(object: Object, createdOn: Date? = nil, creator: Account? = nil, id: Int? = nil, isPrivate: Bool? = nil, owner: Account? = nil, scm: Scm? = nil, title: String? = nil, updatedOn: Date? = nil) {
        self.object = object
        self.createdOn = createdOn
        self.creator = creator
        self.id = id
        self.isPrivate = isPrivate
        self.owner = owner
        self.scm = scm
        self.title = title
        self.updatedOn = updatedOn
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.createdOn = try values.decodeIfPresent(Date.self, forKey: "created_on")
        self.creator = try Account(from: decoder)
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.isPrivate = try values.decodeIfPresent(Bool.self, forKey: "is_private")
        self.owner = try Account(from: decoder)
        self.scm = try Scm(from: decoder)
        self.title = try values.decodeIfPresent(String.self, forKey: "title")
        self.updatedOn = try values.decodeIfPresent(Date.self, forKey: "updated_on")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(createdOn, forKey: "created_on")
        try values.encodeIfPresent(creator, forKey: "creator")
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(isPrivate, forKey: "is_private")
        try values.encodeIfPresent(owner, forKey: "owner")
        try values.encodeIfPresent(scm, forKey: "scm")
        try values.encodeIfPresent(title, forKey: "title")
        try values.encodeIfPresent(updatedOn, forKey: "updated_on")
    }
}

public struct SnippetComment: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var links: Links?
    public var snippet: Snippet?

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var html: HTML?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct HTML: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(html: HTML? = nil, this: `Self`? = nil) {
            self.html = html
            self.this = this
        }

        private enum CodingKeys: String, CodingKey {
            case html
            case this = "self"
        }
    }

    public init(object: Object, links: Links? = nil, snippet: Snippet? = nil) {
        self.object = object
        self.links = links
        self.snippet = snippet
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.links = try Links(from: decoder)
        self.snippet = try Snippet(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(snippet, forKey: "snippet")
    }
}

public struct SnippetCommit: Codable {
    public var baseCommit: BaseCommit
    public var links: Links?
    public var snippet: Snippet?

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var diff: Diff?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var html: HTML?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Diff: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct HTML: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(diff: Diff? = nil, html: HTML? = nil, this: `Self`? = nil) {
            self.diff = diff
            self.html = html
            self.this = this
        }

        private enum CodingKeys: String, CodingKey {
            case diff
            case html
            case this = "self"
        }
    }

    public init(baseCommit: BaseCommit, links: Links? = nil, snippet: Snippet? = nil) {
        self.baseCommit = baseCommit
        self.links = links
        self.snippet = snippet
    }

    public init(from decoder: Decoder) throws {
        self.baseCommit = try BaseCommit(from: decoder)
        self.links = try Links(from: decoder)
        self.snippet = try Snippet(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(baseCommit, forKey: "baseCommit")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(snippet, forKey: "snippet")
    }
}

public struct SshAccountKey: Codable {
    public var sshKey: SshKey
    public var owner: Account?

    public init(sshKey: SshKey, owner: Account? = nil) {
        self.sshKey = sshKey
        self.owner = owner
    }

    public init(from decoder: Decoder) throws {
        self.sshKey = try SshKey(from: decoder)
        self.owner = try Account(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(sshKey, forKey: "sshKey")
        try values.encodeIfPresent(owner, forKey: "owner")
    }
}

public struct SshKey: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    /// The comment parsed from the SSH key (if present)
    public var comment: String?
    public var createdOn: Date?
    /// The SSH public key value in OpenSSH format.
    public var key: String?
    /// The user-defined label for the SSH key
    public var label: String?
    public var lastUsed: Date?
    public var links: Links?
    /// The SSH key's immutable ID.
    public var uuid: String?

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(this: `Self`? = nil) {
            self.this = this
        }

        private enum CodingKeys: String, CodingKey {
            case this = "self"
        }
    }

    public init(object: Object, comment: String? = nil, createdOn: Date? = nil, key: String? = nil, label: String? = nil, lastUsed: Date? = nil, links: Links? = nil, uuid: String? = nil) {
        self.object = object
        self.comment = comment
        self.createdOn = createdOn
        self.key = key
        self.label = label
        self.lastUsed = lastUsed
        self.links = links
        self.uuid = uuid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.comment = try values.decodeIfPresent(String.self, forKey: "comment")
        self.createdOn = try values.decodeIfPresent(Date.self, forKey: "created_on")
        self.key = try values.decodeIfPresent(String.self, forKey: "key")
        self.label = try values.decodeIfPresent(String.self, forKey: "label")
        self.lastUsed = try values.decodeIfPresent(Date.self, forKey: "last_used")
        self.links = try Links(from: decoder)
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(comment, forKey: "comment")
        try values.encodeIfPresent(createdOn, forKey: "created_on")
        try values.encodeIfPresent(key, forKey: "key")
        try values.encodeIfPresent(label, forKey: "label")
        try values.encodeIfPresent(lastUsed, forKey: "last_used")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(uuid, forKey: "uuid")
    }
}

/// The mapping of resource/subject types pointing to their individual event types.
public struct SubjectTypes: Codable {
    public var repository: Repository?
    public var team: Team?
    public var user: User?

    public struct Repository: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var events: Events?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Events: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(events: Events? = nil) {
            self.events = events
        }
    }

    public struct Team: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var events: Events?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Events: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(events: Events? = nil) {
            self.events = events
        }
    }

    public struct User: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var events: Events?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Events: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(events: Events? = nil) {
            self.events = events
        }
    }

    public init(repository: Repository? = nil, team: Team? = nil, user: User? = nil) {
        self.repository = repository
        self.team = team
        self.user = user
    }
}

public struct Tag: Codable {
    public var ref: Ref
    /// The date that the tag was created, if available
    public var date: Date?
    /// The message associated with the tag, if available.
    public var message: String?
    public var tagger: Author?

    public init(ref: Ref, date: Date? = nil, message: String? = nil, tagger: Author? = nil) {
        self.ref = ref
        self.date = date
        self.message = message
        self.tagger = tagger
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.ref = try Ref(from: decoder)
        self.date = try values.decodeIfPresent(Date.self, forKey: "date")
        self.message = try values.decodeIfPresent(String.self, forKey: "message")
        self.tagger = try Author(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(ref, forKey: "ref")
        try values.encodeIfPresent(date, forKey: "date")
        try values.encodeIfPresent(message, forKey: "message")
        try values.encodeIfPresent(tagger, forKey: "tagger")
    }
}

/// A user's permission for a given team.
public struct TeamPermission: Codable {
    public var permission: Permission?
    public var team: Account?
    public var type: String
    public var user: User?

    public enum Permission: String, Codable, CaseIterable {
        case admin
        case collaborator
        case member
    }

    public init(permission: Permission? = nil, team: Account? = nil, type: String, user: User? = nil) {
        self.permission = permission
        self.team = team
        self.type = type
        self.user = user
    }
}

/// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
public struct Treeentry: Codable {
    public var commit: Commit?
    /// The path in the repository
    public var path: String?
    public var type: String

    public init(commit: Commit? = nil, path: String? = nil, type: String) {
        self.commit = commit
        self.path = path
        self.type = type
    }
}

public struct User: Codable {
    public var account: Account
    /// The user's Atlassian account ID.
    public var accountID: String?
    public var isStaff: Bool?

    public init(account: Account, accountID: String? = nil, isStaff: Bool? = nil) {
        self.account = account
        self.accountID = accountID
        self.isStaff = isStaff
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.account = try Account(from: decoder)
        self.accountID = try values.decodeIfPresent(String.self, forKey: "account_id")
        self.isStaff = try values.decodeIfPresent(Bool.self, forKey: "is_staff")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(account, forKey: "account")
        try values.encodeIfPresent(accountID, forKey: "account_id")
        try values.encodeIfPresent(isStaff, forKey: "is_staff")
    }
}

public struct Version: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var id: Int?
    public var links: Links?
    public var name: String?

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(this: `Self`? = nil) {
            self.this = this
        }

        private enum CodingKeys: String, CodingKey {
            case this = "self"
        }
    }

    public init(object: Object, id: Int? = nil, links: Links? = nil, name: String? = nil) {
        self.object = object
        self.id = id
        self.links = links
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
        self.links = try Links(from: decoder)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

public struct WebhookSubscription: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var isActive: Bool?
    public var createdAt: Date?
    /// A user-defined description of the webhook.
    public var description: String?
    /// The events this webhook is subscribed to.
    public var events: [Event]?
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var subject: Object?
    /// The type of entity, which is `repository` in the case of webhook subscriptions on repositories.
    public var subjectType: SubjectType?
    /// The URL events get delivered to.
    public var url: URL?
    /// The webhook's id
    public var uuid: String?

    public enum Event: String, Codable, CaseIterable {
        case pullrequestUnapproved = "pullrequest:unapproved"
        case issueCommentCreated = "issue:comment_created"
        case repoImported = "repo:imported"
        case repoCreated = "repo:created"
        case repoCommitCommentCreated = "repo:commit_comment_created"
        case pullrequestApproved = "pullrequest:approved"
        case pullrequestCommentUpdated = "pullrequest:comment_updated"
        case issueUpdated = "issue:updated"
        case projectUpdated = "project:updated"
        case repoDeleted = "repo:deleted"
        case pullrequestChangesRequestCreated = "pullrequest:changes_request_created"
        case pullrequestCommentCreated = "pullrequest:comment_created"
        case repoCommitStatusUpdated = "repo:commit_status_updated"
        case pullrequestUpdated = "pullrequest:updated"
        case issueCreated = "issue:created"
        case repoFork = "repo:fork"
        case pullrequestCommentDeleted = "pullrequest:comment_deleted"
        case repoCommitStatusCreated = "repo:commit_status_created"
        case repoUpdated = "repo:updated"
        case pullrequestRejected = "pullrequest:rejected"
        case pullrequestFulfilled = "pullrequest:fulfilled"
        case pullrequestCreated = "pullrequest:created"
        case pullrequestChangesRequestRemoved = "pullrequest:changes_request_removed"
        case repoTransfer = "repo:transfer"
        case repoPush = "repo:push"
    }

    /// The type of entity, which is `repository` in the case of webhook subscriptions on repositories.
    public enum SubjectType: String, Codable, CaseIterable {
        case workspace
        case user
        case repository
        case team
    }

    public init(object: Object, isActive: Bool? = nil, createdAt: Date? = nil, description: String? = nil, events: [Event]? = nil, subject: Object? = nil, subjectType: SubjectType? = nil, url: URL? = nil, uuid: String? = nil) {
        self.object = object
        self.isActive = isActive
        self.createdAt = createdAt
        self.description = description
        self.events = events
        self.subject = subject
        self.subjectType = subjectType
        self.url = url
        self.uuid = uuid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.isActive = try values.decodeIfPresent(Bool.self, forKey: "active")
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.events = try values.decodeIfPresent([Event].self, forKey: "events")
        self.subject = try Object(from: decoder)
        self.subjectType = try SubjectType(from: decoder)
        self.url = try values.decodeIfPresent(URL.self, forKey: "url")
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(isActive, forKey: "active")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(events, forKey: "events")
        try values.encodeIfPresent(subject, forKey: "subject")
        try values.encodeIfPresent(subjectType, forKey: "subject_type")
        try values.encodeIfPresent(url, forKey: "url")
        try values.encodeIfPresent(uuid, forKey: "uuid")
    }
}

public struct Workspace: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var createdOn: Date?
    /// Indicates whether the workspace is publicly accessible, or whether it is
    /// private to the members and consequently only visible to members.
    /// Note that private workspaces cannot contain public repositories.
    public var isPrivate: Bool?
    public var links: Links?
    /// The name of the workspace.
    public var name: String?
    /// The short label that identifies this workspace.
    public var slug: String?
    public var updatedOn: Date?
    /// The workspace's immutable id.
    public var uuid: String?

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var avatar: Avatar?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var html: HTML?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var members: Members?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var owners: Owners?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var projects: Projects?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var repositories: Repositories?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?
        /// Link
        ///
        /// A link to a resource related to this object.
        public var snippets: Snippets?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Avatar: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct HTML: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Members: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Owners: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Projects: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Repositories: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct Snippets: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(avatar: Avatar? = nil, html: HTML? = nil, members: Members? = nil, owners: Owners? = nil, projects: Projects? = nil, repositories: Repositories? = nil, this: `Self`? = nil, snippets: Snippets? = nil) {
            self.avatar = avatar
            self.html = html
            self.members = members
            self.owners = owners
            self.projects = projects
            self.repositories = repositories
            self.this = this
            self.snippets = snippets
        }

        private enum CodingKeys: String, CodingKey {
            case avatar
            case html
            case members
            case owners
            case projects
            case repositories
            case this = "self"
            case snippets
        }
    }

    public init(object: Object, createdOn: Date? = nil, isPrivate: Bool? = nil, links: Links? = nil, name: String? = nil, slug: String? = nil, updatedOn: Date? = nil, uuid: String? = nil) {
        self.object = object
        self.createdOn = createdOn
        self.isPrivate = isPrivate
        self.links = links
        self.name = name
        self.slug = slug
        self.updatedOn = updatedOn
        self.uuid = uuid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.object = try Object(from: decoder)
        self.createdOn = try values.decodeIfPresent(Date.self, forKey: "created_on")
        self.isPrivate = try values.decodeIfPresent(Bool.self, forKey: "is_private")
        self.links = try Links(from: decoder)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.slug = try values.decodeIfPresent(String.self, forKey: "slug")
        self.updatedOn = try values.decodeIfPresent(Date.self, forKey: "updated_on")
        self.uuid = try values.decodeIfPresent(String.self, forKey: "uuid")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(createdOn, forKey: "created_on")
        try values.encodeIfPresent(isPrivate, forKey: "is_private")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(slug, forKey: "slug")
        try values.encodeIfPresent(updatedOn, forKey: "updated_on")
        try values.encodeIfPresent(uuid, forKey: "uuid")
    }
}

public struct WorkspaceMembership: Codable {
    /// Base type for most resource objects. It defines the common `type` element that identifies an object's type. It also identifies the element as Swagger's `discriminator`.
    public var object: Object
    public var links: Links?
    public var user: Account?
    public var workspace: Workspace?

    public struct Links: Codable {
        /// Link
        ///
        /// A link to a resource related to this object.
        public var this: `Self`?

        /// Link
        ///
        /// A link to a resource related to this object.
        public struct `Self`: Codable {
            public var href: URL?
            public var name: String?

            public init(href: URL? = nil, name: String? = nil) {
                self.href = href
                self.name = name
            }
        }

        public init(this: `Self`? = nil) {
            self.this = this
        }

        private enum CodingKeys: String, CodingKey {
            case this = "self"
        }
    }

    public init(object: Object, links: Links? = nil, user: Account? = nil, workspace: Workspace? = nil) {
        self.object = object
        self.links = links
        self.user = user
        self.workspace = workspace
    }

    public init(from decoder: Decoder) throws {
        self.object = try Object(from: decoder)
        self.links = try Links(from: decoder)
        self.user = try Account(from: decoder)
        self.workspace = try Workspace(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(links, forKey: "links")
        try values.encodeIfPresent(user, forKey: "user")
        try values.encodeIfPresent(workspace, forKey: "workspace")
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
