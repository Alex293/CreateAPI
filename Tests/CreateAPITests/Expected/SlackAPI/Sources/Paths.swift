// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import APIClient

extension Paths {
    public static var apiTest: APITest {
        APITest(path: "/api.test")
    }

    public struct APITest {
        /// Path: `/api.test`
        public let path: String

        /// Checks API calling code.
        ///
        /// [API method documentation](https://api.slack.com/methods/api.test)
        public func get(foo: String? = nil, error: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: makeGetQuery(foo, error))
        }

        private func makeGetQuery(_ foo: String?, _ error: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("foo", foo?.asQueryValue)
            query.addQueryItem("error", error?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var appsPermissionsInfo: AppsPermissionsInfo {
        AppsPermissionsInfo(path: "/apps.permissions.info")
    }

    public struct AppsPermissionsInfo {
        /// Path: `/apps.permissions.info`
        public let path: String

        /// Returns list of permissions this app has on a team.
        ///
        /// [API method documentation](https://api.slack.com/methods/apps.permissions.info)
        public func get(token: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: makeGetQuery(token))
        }

        private func makeGetQuery(_ token: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("token", token?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var appsPermissionsRequest: AppsPermissionsRequest {
        AppsPermissionsRequest(path: "/apps.permissions.request")
    }

    public struct AppsPermissionsRequest {
        /// Path: `/apps.permissions.request`
        public let path: String

        /// Allows an app to request additional scopes
        ///
        /// [API method documentation](https://api.slack.com/methods/apps.permissions.request)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var scopes: String?
            public var token: String?
            public var triggerID: String?

            public init(scopes: String? = nil, token: String? = nil, triggerID: String? = nil) {
                self.scopes = scopes
                self.token = token
                self.triggerID = triggerID
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("scopes", scopes?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("trigger_id", triggerID?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var appsPermissionsResourcesList: AppsPermissionsResourcesList {
        AppsPermissionsResourcesList(path: "/apps.permissions.resources.list")
    }

    public struct AppsPermissionsResourcesList {
        /// Path: `/apps.permissions.resources.list`
        public let path: String

        /// Returns list of resource grants this app has on a team.
        ///
        /// [API method documentation](https://api.slack.com/methods/apps.permissions.resources.list)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var cursor: String?
            public var token: String?
            public var limit: Int?

            public init(cursor: String? = nil, token: String? = nil, limit: Int? = nil) {
                self.cursor = cursor
                self.token = token
                self.limit = limit
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("cursor", cursor?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("limit", limit?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var appsPermissionsScopesList: AppsPermissionsScopesList {
        AppsPermissionsScopesList(path: "/apps.permissions.scopes.list")
    }

    public struct AppsPermissionsScopesList {
        /// Path: `/apps.permissions.scopes.list`
        public let path: String

        /// Returns list of scopes this app has on a team.
        ///
        /// [API method documentation](https://api.slack.com/methods/apps.permissions.scopes.list)
        public func get(token: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: makeGetQuery(token))
        }

        private func makeGetQuery(_ token: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("token", token?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var authRevoke: AuthRevoke {
        AuthRevoke(path: "/auth.revoke")
    }

    public struct AuthRevoke {
        /// Path: `/auth.revoke`
        public let path: String

        /// Revokes a token.
        ///
        /// [API method documentation](https://api.slack.com/methods/auth.revoke)
        public func get(isTest: Bool? = nil, token: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: makeGetQuery(isTest, token))
        }

        private func makeGetQuery(_ isTest: Bool?, _ token: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("test", isTest?.asQueryValue)
            query.addQueryItem("token", token?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var authTest: AuthTest {
        AuthTest(path: "/auth.test")
    }

    public struct AuthTest {
        /// Path: `/auth.test`
        public let path: String

        /// Checks authentication & identity.
        ///
        /// [API method documentation](https://api.slack.com/methods/auth.test)
        public var get: Request<[String: [String: AnyJSON]]> {
            .get(path)
        }
    }
}

extension Paths {
    public static var botsInfo: BotsInfo {
        BotsInfo(path: "/bots.info")
    }

    public struct BotsInfo {
        /// Path: `/bots.info`
        public let path: String

        /// Gets information about a bot user.
        ///
        /// [API method documentation](https://api.slack.com/methods/bots.info)
        public func get(token: String? = nil, bot: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: makeGetQuery(token, bot))
        }

        private func makeGetQuery(_ token: String?, _ bot: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("token", token?.asQueryValue)
            query.addQueryItem("bot", bot?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var channelsArchive: ChannelsArchive {
        ChannelsArchive(path: "/channels.archive")
    }

    public struct ChannelsArchive {
        /// Path: `/channels.archive`
        public let path: String

        /// Archives a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/channels.archive)
        public func post(channel: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["channel": channel])
        }
    }
}

extension Paths {
    public static var channelsCreate: ChannelsCreate {
        ChannelsCreate(path: "/channels.create")
    }

    public struct ChannelsCreate {
        /// Path: `/channels.create`
        public let path: String

        /// Creates a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/channels.create)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Whether to return errors on invalid channel name instead of modifying it to meet the specified criteria.
            public var isValidate: Bool?
            /// Name of channel to create
            public var name: String?

            public init(isValidate: Bool? = nil, name: String? = nil) {
                self.isValidate = isValidate
                self.name = name
            }

            private enum CodingKeys: String, CodingKey {
                case isValidate = "validate"
                case name
            }
        }
    }
}

extension Paths {
    public static var channelsHistory: ChannelsHistory {
        ChannelsHistory(path: "/channels.history")
    }

    public struct ChannelsHistory {
        /// Path: `/channels.history`
        public let path: String

        /// Fetches history of messages and events from a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/channels.history)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var count: Int?
            public var isUnreads: Bool?
            public var isInclusive: Bool?
            public var token: String?
            public var oldest: Double?
            public var channel: String?
            public var latest: Double?

            public init(count: Int? = nil, isUnreads: Bool? = nil, isInclusive: Bool? = nil, token: String? = nil, oldest: Double? = nil, channel: String? = nil, latest: Double? = nil) {
                self.count = count
                self.isUnreads = isUnreads
                self.isInclusive = isInclusive
                self.token = token
                self.oldest = oldest
                self.channel = channel
                self.latest = latest
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("count", count?.asQueryValue)
                query.addQueryItem("unreads", isUnreads?.asQueryValue)
                query.addQueryItem("inclusive", isInclusive?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("oldest", oldest?.asQueryValue)
                query.addQueryItem("channel", channel?.asQueryValue)
                query.addQueryItem("latest", latest?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var channelsInfo: ChannelsInfo {
        ChannelsInfo(path: "/channels.info")
    }

    public struct ChannelsInfo {
        /// Path: `/channels.info`
        public let path: String

        /// Gets information about a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/channels.info)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var token: String?
            public var isIncludeLocale: Bool?
            public var channel: String?

            public init(token: String? = nil, isIncludeLocale: Bool? = nil, channel: String? = nil) {
                self.token = token
                self.isIncludeLocale = isIncludeLocale
                self.channel = channel
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("include_locale", isIncludeLocale?.asQueryValue)
                query.addQueryItem("channel", channel?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var channelsInvite: ChannelsInvite {
        ChannelsInvite(path: "/channels.invite")
    }

    public struct ChannelsInvite {
        /// Path: `/channels.invite`
        public let path: String

        /// Invites a user to a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/channels.invite)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// User to invite to channel.
            public var user: String?
            /// Channel to invite user to.
            public var channel: String?

            public init(user: String? = nil, channel: String? = nil) {
                self.user = user
                self.channel = channel
            }
        }
    }
}

extension Paths {
    public static var channelsJoin: ChannelsJoin {
        ChannelsJoin(path: "/channels.join")
    }

    public struct ChannelsJoin {
        /// Path: `/channels.join`
        public let path: String

        /// Joins a channel, creating it if needed.
        ///
        /// [API method documentation](https://api.slack.com/methods/channels.join)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Whether to return errors on invalid channel name instead of modifying it to meet the specified criteria.
            public var isValidate: Bool?
            /// Name of channel to join
            public var name: String?

            public init(isValidate: Bool? = nil, name: String? = nil) {
                self.isValidate = isValidate
                self.name = name
            }

            private enum CodingKeys: String, CodingKey {
                case isValidate = "validate"
                case name
            }
        }
    }
}

extension Paths {
    public static var channelsKick: ChannelsKick {
        ChannelsKick(path: "/channels.kick")
    }

    public struct ChannelsKick {
        /// Path: `/channels.kick`
        public let path: String

        /// Removes a user from a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/channels.kick)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// User to remove from channel.
            public var user: String?
            /// Channel to remove user from.
            public var channel: String?

            public init(user: String? = nil, channel: String? = nil) {
                self.user = user
                self.channel = channel
            }
        }
    }
}

extension Paths {
    public static var channelsLeave: ChannelsLeave {
        ChannelsLeave(path: "/channels.leave")
    }

    public struct ChannelsLeave {
        /// Path: `/channels.leave`
        public let path: String

        /// Leaves a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/channels.leave)
        public func post(channel: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["channel": channel])
        }
    }
}

extension Paths {
    public static var channelsList: ChannelsList {
        ChannelsList(path: "/channels.list")
    }

    public struct ChannelsList {
        /// Path: `/channels.list`
        public let path: String

        /// Lists all channels in a Slack team.
        ///
        /// [API method documentation](https://api.slack.com/methods/channels.list)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var excludeMembers: Bool?
            public var cursor: String?
            public var token: String?
            public var limit: Int?
            public var excludeArchived: Bool?

            public init(excludeMembers: Bool? = nil, cursor: String? = nil, token: String? = nil, limit: Int? = nil, excludeArchived: Bool? = nil) {
                self.excludeMembers = excludeMembers
                self.cursor = cursor
                self.token = token
                self.limit = limit
                self.excludeArchived = excludeArchived
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("exclude_members", excludeMembers?.asQueryValue)
                query.addQueryItem("cursor", cursor?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("limit", limit?.asQueryValue)
                query.addQueryItem("exclude_archived", excludeArchived?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var channelsMark: ChannelsMark {
        ChannelsMark(path: "/channels.mark")
    }

    public struct ChannelsMark {
        /// Path: `/channels.mark`
        public let path: String

        /// Sets the read cursor in a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/channels.mark)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Timestamp of the most recently seen message.
            public var ts: Double?
            /// Channel to set reading cursor in.
            public var channel: String?

            public init(ts: Double? = nil, channel: String? = nil) {
                self.ts = ts
                self.channel = channel
            }
        }
    }
}

extension Paths {
    public static var channelsRename: ChannelsRename {
        ChannelsRename(path: "/channels.rename")
    }

    public struct ChannelsRename {
        /// Path: `/channels.rename`
        public let path: String

        /// Renames a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/channels.rename)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Whether to return errors on invalid channel name instead of modifying it to meet the specified criteria.
            public var isValidate: Bool?
            /// New name for channel.
            public var name: String?
            /// Channel to rename
            public var channel: String?

            public init(isValidate: Bool? = nil, name: String? = nil, channel: String? = nil) {
                self.isValidate = isValidate
                self.name = name
                self.channel = channel
            }

            private enum CodingKeys: String, CodingKey {
                case isValidate = "validate"
                case name
                case channel
            }
        }
    }
}

extension Paths {
    public static var channelsReplies: ChannelsReplies {
        ChannelsReplies(path: "/channels.replies")
    }

    public struct ChannelsReplies {
        /// Path: `/channels.replies`
        public let path: String

        /// Retrieve a thread of messages posted to a channel
        ///
        /// [API method documentation](https://api.slack.com/methods/channels.replies)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var threadTs: Double?
            public var token: String?
            public var channel: String?

            public init(threadTs: Double? = nil, token: String? = nil, channel: String? = nil) {
                self.threadTs = threadTs
                self.token = token
                self.channel = channel
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("thread_ts", threadTs?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("channel", channel?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var channelsSetPurpose: ChannelsSetPurpose {
        ChannelsSetPurpose(path: "/channels.setPurpose")
    }

    public struct ChannelsSetPurpose {
        /// Path: `/channels.setPurpose`
        public let path: String

        /// Sets the purpose for a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/channels.setPurpose)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The new purpose
            public var purpose: String?
            /// Channel to set the purpose of
            public var channel: String?

            public init(purpose: String? = nil, channel: String? = nil) {
                self.purpose = purpose
                self.channel = channel
            }
        }
    }
}

extension Paths {
    public static var channelsSetTopic: ChannelsSetTopic {
        ChannelsSetTopic(path: "/channels.setTopic")
    }

    public struct ChannelsSetTopic {
        /// Path: `/channels.setTopic`
        public let path: String

        /// Sets the topic for a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/channels.setTopic)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The new topic
            public var topic: String?
            /// Channel to set the topic of
            public var channel: String?

            public init(topic: String? = nil, channel: String? = nil) {
                self.topic = topic
                self.channel = channel
            }
        }
    }
}

extension Paths {
    public static var channelsUnarchive: ChannelsUnarchive {
        ChannelsUnarchive(path: "/channels.unarchive")
    }

    public struct ChannelsUnarchive {
        /// Path: `/channels.unarchive`
        public let path: String

        /// Unarchives a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/channels.unarchive)
        public func post(channel: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["channel": channel])
        }
    }
}

extension Paths {
    public static var chatDelete: ChatDelete {
        ChatDelete(path: "/chat.delete")
    }

    public struct ChatDelete {
        /// Path: `/chat.delete`
        public let path: String

        /// Deletes a message.
        ///
        /// [API method documentation](https://api.slack.com/methods/chat.delete)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Pass true to delete the message as the authed user with `chat:write:user` scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with `chat:write:bot` scope.
            public var isAsUser: Bool?
            /// Timestamp of the message to be deleted.
            public var ts: Double?
            /// Channel containing the message to be deleted.
            public var channel: String?

            public init(isAsUser: Bool? = nil, ts: Double? = nil, channel: String? = nil) {
                self.isAsUser = isAsUser
                self.ts = ts
                self.channel = channel
            }

            private enum CodingKeys: String, CodingKey {
                case isAsUser = "as_user"
                case ts
                case channel
            }
        }
    }
}

extension Paths {
    public static var chatGetPermalink: ChatGetPermalink {
        ChatGetPermalink(path: "/chat.getPermalink")
    }

    public struct ChatGetPermalink {
        /// Path: `/chat.getPermalink`
        public let path: String

        /// Retrieve a permalink URL for a specific extant message
        ///
        /// [API method documentation](https://api.slack.com/methods/chat.getPermalink)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var token: String?
            public var messageTs: Double?
            public var channel: String?

            public init(token: String? = nil, messageTs: Double? = nil, channel: String? = nil) {
                self.token = token
                self.messageTs = messageTs
                self.channel = channel
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("message_ts", messageTs?.asQueryValue)
                query.addQueryItem("channel", channel?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var chatMeMessage: ChatMeMessage {
        ChatMeMessage(path: "/chat.meMessage")
    }

    public struct ChatMeMessage {
        /// Path: `/chat.meMessage`
        public let path: String

        /// Share a me message into a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/chat.meMessage)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Text of the message to send.
            public var text: String?
            /// Channel to send message to. Can be a public channel, private group or IM channel. Can be an encoded ID, or a name.
            public var channel: String?

            public init(text: String? = nil, channel: String? = nil) {
                self.text = text
                self.channel = channel
            }
        }
    }
}

extension Paths {
    public static var chatPostEphemeral: ChatPostEphemeral {
        ChatPostEphemeral(path: "/chat.postEphemeral")
    }

    public struct ChatPostEphemeral {
        /// Path: `/chat.postEphemeral`
        public let path: String

        /// Sends an ephemeral message to a user in a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/chat.postEphemeral)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// A JSON-based array of structured attachments, presented as a URL-encoded string.
            public var attachments: String?
            /// Text of the message to send. See below for an explanation of [formatting](#formatting). This field is usually required, unless you're providing only `attachments` instead.
            public var text: String?
            /// Find and link channel names and usernames.
            public var isLinkNames: Bool?
            /// Change how messages are treated. Defaults to `none`. See [below](#formatting).
            public var parse: String?
            /// `id` of the user who will receive the ephemeral message. The user should be in the channel specified by the `channel` argument.
            public var user: String?
            /// Pass true to post the message as the authed bot. Defaults to false.
            public var isAsUser: Bool?
            /// Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name.
            public var channel: String?

            public init(attachments: String? = nil, text: String? = nil, isLinkNames: Bool? = nil, parse: String? = nil, user: String? = nil, isAsUser: Bool? = nil, channel: String? = nil) {
                self.attachments = attachments
                self.text = text
                self.isLinkNames = isLinkNames
                self.parse = parse
                self.user = user
                self.isAsUser = isAsUser
                self.channel = channel
            }

            private enum CodingKeys: String, CodingKey {
                case attachments
                case text
                case isLinkNames = "link_names"
                case parse
                case user
                case isAsUser = "as_user"
                case channel
            }
        }
    }
}

extension Paths {
    public static var chatPostMessage: ChatPostMessage {
        ChatPostMessage(path: "/chat.postMessage")
    }

    public struct ChatPostMessage {
        /// Path: `/chat.postMessage`
        public let path: String

        /// Sends a message to a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/chat.postMessage)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Set your bot's user name. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
            public var username: String?
            /// Provide another message's `ts` value to make this message a reply. Avoid using a reply's `ts` value; use its parent instead.
            public var threadTs: Double?
            /// A JSON-based array of structured attachments, presented as a URL-encoded string.
            public var attachments: String?
            /// Pass true to enable unfurling of primarily text-based content.
            public var isUnfurlLinks: Bool?
            /// Text of the message to send. See below for an explanation of [formatting](#formatting). This field is usually required, unless you're providing only `attachments` instead. Provide no more than 40,000 characters or [risk truncation](/changelog/2018-04-truncating-really-long-messages).
            public var text: String?
            /// Pass false to disable unfurling of media content.
            public var isUnfurlMedia: Bool?
            /// Change how messages are treated. Defaults to `none`. See [below](#formatting).
            public var parse: String?
            /// Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [authorship](#authorship) below.
            public var isAsUser: Bool?
            /// Disable Slack markup parsing by setting to `false`. Enabled by default.
            public var isMrkdwn: Bool?
            /// Emoji to use as the icon for this message. Overrides `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise ignored. See [authorship](#authorship) below.
            public var iconEmoji: String?
            /// Find and link channel names and usernames.
            public var isLinkNames: Bool?
            /// URL to an image to use as the icon for this message. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
            public var iconURL: String?
            /// Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details.
            public var channel: String?
            /// Used in conjunction with `thread_ts` and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to `false`.
            public var isReplyBroadcast: Bool?

            public init(username: String? = nil, threadTs: Double? = nil, attachments: String? = nil, isUnfurlLinks: Bool? = nil, text: String? = nil, isUnfurlMedia: Bool? = nil, parse: String? = nil, isAsUser: Bool? = nil, isMrkdwn: Bool? = nil, iconEmoji: String? = nil, isLinkNames: Bool? = nil, iconURL: String? = nil, channel: String? = nil, isReplyBroadcast: Bool? = nil) {
                self.username = username
                self.threadTs = threadTs
                self.attachments = attachments
                self.isUnfurlLinks = isUnfurlLinks
                self.text = text
                self.isUnfurlMedia = isUnfurlMedia
                self.parse = parse
                self.isAsUser = isAsUser
                self.isMrkdwn = isMrkdwn
                self.iconEmoji = iconEmoji
                self.isLinkNames = isLinkNames
                self.iconURL = iconURL
                self.channel = channel
                self.isReplyBroadcast = isReplyBroadcast
            }

            private enum CodingKeys: String, CodingKey {
                case username
                case threadTs = "thread_ts"
                case attachments
                case isUnfurlLinks = "unfurl_links"
                case text
                case isUnfurlMedia = "unfurl_media"
                case parse
                case isAsUser = "as_user"
                case isMrkdwn = "mrkdwn"
                case iconEmoji = "icon_emoji"
                case isLinkNames = "link_names"
                case iconURL = "icon_url"
                case channel
                case isReplyBroadcast = "reply_broadcast"
            }
        }
    }
}

extension Paths {
    public static var chatUnfurl: ChatUnfurl {
        ChatUnfurl(path: "/chat.unfurl")
    }

    public struct ChatUnfurl {
        /// Path: `/chat.unfurl`
        public let path: String

        /// Provide custom unfurl behavior for user-posted URLs
        ///
        /// [API method documentation](https://api.slack.com/methods/chat.unfurl)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Provide a simply-formatted string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior
            public var userAuthMessage: String?
            /// Set to `true` or `1` to indicate the user must install your Slack app to trigger unfurls for this domain
            public var isUserAuthRequired: Bool?
            /// URL-encoded JSON map with keys set to URLs featured in the the message, pointing to their unfurl message attachments.
            public var unfurls: String?
            /// Timestamp of the message to add unfurl behavior to.
            public var ts: String?
            /// Send users to this custom URL where they will complete authentication in your app to fully trigger unfurling. Value should be properly URL-encoded.
            public var userAuthURL: String?
            /// Channel ID of the message
            public var channel: String?

            public init(userAuthMessage: String? = nil, isUserAuthRequired: Bool? = nil, unfurls: String? = nil, ts: String? = nil, userAuthURL: String? = nil, channel: String? = nil) {
                self.userAuthMessage = userAuthMessage
                self.isUserAuthRequired = isUserAuthRequired
                self.unfurls = unfurls
                self.ts = ts
                self.userAuthURL = userAuthURL
                self.channel = channel
            }

            private enum CodingKeys: String, CodingKey {
                case userAuthMessage = "user_auth_message"
                case isUserAuthRequired = "user_auth_required"
                case unfurls
                case ts
                case userAuthURL = "user_auth_url"
                case channel
            }
        }
    }
}

extension Paths {
    public static var chatUpdate: ChatUpdate {
        ChatUpdate(path: "/chat.update")
    }

    public struct ChatUpdate {
        /// Path: `/chat.update`
        public let path: String

        /// Updates a message.
        ///
        /// [API method documentation](https://api.slack.com/methods/chat.update)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// A JSON-based array of structured attachments, presented as a URL-encoded string. This field is required when not presenting `text`.
            public var attachments: String?
            /// New text for the message, using the [default formatting rules](/docs/formatting). It's not required when presenting `attachments`.
            public var text: String?
            /// Timestamp of the message to be updated.
            public var ts: Double?
            /// Change how messages are treated. Defaults to `client`, unlike `chat.postMessage`. See [below](#formatting).
            public var parse: String?
            /// Pass true to update the message as the authed user. [Bot users](/bot-users) in this context are considered authed users.
            public var isAsUser: Bool?
            /// Find and link channel names and usernames. Defaults to `none`. See [below](#formatting).
            public var isLinkNames: Bool?
            /// Channel containing the message to be updated.
            public var channel: String?

            public init(attachments: String? = nil, text: String? = nil, ts: Double? = nil, parse: String? = nil, isAsUser: Bool? = nil, isLinkNames: Bool? = nil, channel: String? = nil) {
                self.attachments = attachments
                self.text = text
                self.ts = ts
                self.parse = parse
                self.isAsUser = isAsUser
                self.isLinkNames = isLinkNames
                self.channel = channel
            }

            private enum CodingKeys: String, CodingKey {
                case attachments
                case text
                case ts
                case parse
                case isAsUser = "as_user"
                case isLinkNames = "link_names"
                case channel
            }
        }
    }
}

extension Paths {
    public static var conversationsArchive: ConversationsArchive {
        ConversationsArchive(path: "/conversations.archive")
    }

    public struct ConversationsArchive {
        /// Path: `/conversations.archive`
        public let path: String

        /// Archives a conversation.
        ///
        /// [API method documentation](https://api.slack.com/methods/conversations.archive)
        public func post(channel: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["channel": channel])
        }
    }
}

extension Paths {
    public static var conversationsClose: ConversationsClose {
        ConversationsClose(path: "/conversations.close")
    }

    public struct ConversationsClose {
        /// Path: `/conversations.close`
        public let path: String

        /// Closes a direct message or multi-person direct message.
        ///
        /// [API method documentation](https://api.slack.com/methods/conversations.close)
        public func post(channel: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["channel": channel])
        }
    }
}

extension Paths {
    public static var conversationsCreate: ConversationsCreate {
        ConversationsCreate(path: "/conversations.create")
    }

    public struct ConversationsCreate {
        /// Path: `/conversations.create`
        public let path: String

        /// Initiates a public or private channel-based conversation
        ///
        /// [API method documentation](https://api.slack.com/methods/conversations.create)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Name of the public or private channel to create
            public var name: String?
            /// Create a private channel instead of a public one
            public var isPrivate: Bool?

            public init(name: String? = nil, isPrivate: Bool? = nil) {
                self.name = name
                self.isPrivate = isPrivate
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case isPrivate = "is_private"
            }
        }
    }
}

extension Paths {
    public static var conversationsHistory: ConversationsHistory {
        ConversationsHistory(path: "/conversations.history")
    }

    public struct ConversationsHistory {
        /// Path: `/conversations.history`
        public let path: String

        /// Fetches a conversation's history of messages and events.
        ///
        /// [API method documentation](https://api.slack.com/methods/conversations.history)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var isInclusive: Bool?
            public var cursor: String?
            public var token: String?
            public var limit: Int?
            public var oldest: Double?
            public var channel: String?
            public var latest: Double?

            public init(isInclusive: Bool? = nil, cursor: String? = nil, token: String? = nil, limit: Int? = nil, oldest: Double? = nil, channel: String? = nil, latest: Double? = nil) {
                self.isInclusive = isInclusive
                self.cursor = cursor
                self.token = token
                self.limit = limit
                self.oldest = oldest
                self.channel = channel
                self.latest = latest
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("inclusive", isInclusive?.asQueryValue)
                query.addQueryItem("cursor", cursor?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("limit", limit?.asQueryValue)
                query.addQueryItem("oldest", oldest?.asQueryValue)
                query.addQueryItem("channel", channel?.asQueryValue)
                query.addQueryItem("latest", latest?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var conversationsInfo: ConversationsInfo {
        ConversationsInfo(path: "/conversations.info")
    }

    public struct ConversationsInfo {
        /// Path: `/conversations.info`
        public let path: String

        /// Retrieve information about a conversation.
        ///
        /// [API method documentation](https://api.slack.com/methods/conversations.info)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var token: String?
            public var channel: String?
            public var isIncludeLocale: Bool?

            public init(token: String? = nil, channel: String? = nil, isIncludeLocale: Bool? = nil) {
                self.token = token
                self.channel = channel
                self.isIncludeLocale = isIncludeLocale
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("channel", channel?.asQueryValue)
                query.addQueryItem("include_locale", isIncludeLocale?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var conversationsInvite: ConversationsInvite {
        ConversationsInvite(path: "/conversations.invite")
    }

    public struct ConversationsInvite {
        /// Path: `/conversations.invite`
        public let path: String

        /// Invites users to a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/conversations.invite)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// A comma separated list of user IDs. Up to 30 users may be listed.
            public var users: String?
            /// The ID of the public or private channel to invite user(s) to.
            public var channel: String?

            public init(users: String? = nil, channel: String? = nil) {
                self.users = users
                self.channel = channel
            }
        }
    }
}

extension Paths {
    public static var conversationsJoin: ConversationsJoin {
        ConversationsJoin(path: "/conversations.join")
    }

    public struct ConversationsJoin {
        /// Path: `/conversations.join`
        public let path: String

        /// Joins an existing conversation.
        ///
        /// [API method documentation](https://api.slack.com/methods/conversations.join)
        public func post(channel: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["channel": channel])
        }
    }
}

extension Paths {
    public static var conversationsKick: ConversationsKick {
        ConversationsKick(path: "/conversations.kick")
    }

    public struct ConversationsKick {
        /// Path: `/conversations.kick`
        public let path: String

        /// Removes a user from a conversation.
        ///
        /// [API method documentation](https://api.slack.com/methods/conversations.kick)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// User ID to be removed.
            public var user: String?
            /// ID of conversation to remove user from.
            public var channel: String?

            public init(user: String? = nil, channel: String? = nil) {
                self.user = user
                self.channel = channel
            }
        }
    }
}

extension Paths {
    public static var conversationsLeave: ConversationsLeave {
        ConversationsLeave(path: "/conversations.leave")
    }

    public struct ConversationsLeave {
        /// Path: `/conversations.leave`
        public let path: String

        /// Leaves a conversation.
        ///
        /// [API method documentation](https://api.slack.com/methods/conversations.leave)
        public func post(channel: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["channel": channel])
        }
    }
}

extension Paths {
    public static var conversationsList: ConversationsList {
        ConversationsList(path: "/conversations.list")
    }

    public struct ConversationsList {
        /// Path: `/conversations.list`
        public let path: String

        /// Lists all channels in a Slack team.
        ///
        /// [API method documentation](https://api.slack.com/methods/conversations.list)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var cursor: String?
            public var token: String?
            public var limit: Int?
            public var excludeArchived: Bool?
            public var types: String?

            public init(cursor: String? = nil, token: String? = nil, limit: Int? = nil, excludeArchived: Bool? = nil, types: String? = nil) {
                self.cursor = cursor
                self.token = token
                self.limit = limit
                self.excludeArchived = excludeArchived
                self.types = types
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("cursor", cursor?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("limit", limit?.asQueryValue)
                query.addQueryItem("exclude_archived", excludeArchived?.asQueryValue)
                query.addQueryItem("types", types?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var conversationsMembers: ConversationsMembers {
        ConversationsMembers(path: "/conversations.members")
    }

    public struct ConversationsMembers {
        /// Path: `/conversations.members`
        public let path: String

        /// Retrieve members of a conversation.
        ///
        /// [API method documentation](https://api.slack.com/methods/conversations.members)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var cursor: String?
            public var token: String?
            public var limit: Int?
            public var channel: String?

            public init(cursor: String? = nil, token: String? = nil, limit: Int? = nil, channel: String? = nil) {
                self.cursor = cursor
                self.token = token
                self.limit = limit
                self.channel = channel
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("cursor", cursor?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("limit", limit?.asQueryValue)
                query.addQueryItem("channel", channel?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var conversationsOpen: ConversationsOpen {
        ConversationsOpen(path: "/conversations.open")
    }

    public struct ConversationsOpen {
        /// Path: `/conversations.open`
        public let path: String

        /// Opens or resumes a direct message or multi-person direct message.
        ///
        /// [API method documentation](https://api.slack.com/methods/conversations.open)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Boolean, indicates you want the full IM channel definition in the response.
            public var isReturnIm: Bool?
            /// Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a `channel` when not supplying `users`.
            public var users: String?
            /// Resume a conversation by supplying an `im` or `mpim`'s ID. Or provide the `users` field instead.
            public var channel: String?

            public init(isReturnIm: Bool? = nil, users: String? = nil, channel: String? = nil) {
                self.isReturnIm = isReturnIm
                self.users = users
                self.channel = channel
            }

            private enum CodingKeys: String, CodingKey {
                case isReturnIm = "return_im"
                case users
                case channel
            }
        }
    }
}

extension Paths {
    public static var conversationsRename: ConversationsRename {
        ConversationsRename(path: "/conversations.rename")
    }

    public struct ConversationsRename {
        /// Path: `/conversations.rename`
        public let path: String

        /// Renames a conversation.
        ///
        /// [API method documentation](https://api.slack.com/methods/conversations.rename)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// New name for conversation.
            public var name: String?
            /// ID of conversation to rename
            public var channel: String?

            public init(name: String? = nil, channel: String? = nil) {
                self.name = name
                self.channel = channel
            }
        }
    }
}

extension Paths {
    public static var conversationsReplies: ConversationsReplies {
        ConversationsReplies(path: "/conversations.replies")
    }

    public struct ConversationsReplies {
        /// Path: `/conversations.replies`
        public let path: String

        /// Retrieve a thread of messages posted to a conversation
        ///
        /// [API method documentation](https://api.slack.com/methods/conversations.replies)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var isInclusive: Bool?
            public var ts: Double?
            public var cursor: String?
            public var token: String?
            public var limit: Int?
            public var oldest: Double?
            public var channel: String?
            public var latest: Double?

            public init(isInclusive: Bool? = nil, ts: Double? = nil, cursor: String? = nil, token: String? = nil, limit: Int? = nil, oldest: Double? = nil, channel: String? = nil, latest: Double? = nil) {
                self.isInclusive = isInclusive
                self.ts = ts
                self.cursor = cursor
                self.token = token
                self.limit = limit
                self.oldest = oldest
                self.channel = channel
                self.latest = latest
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("inclusive", isInclusive?.asQueryValue)
                query.addQueryItem("ts", ts?.asQueryValue)
                query.addQueryItem("cursor", cursor?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("limit", limit?.asQueryValue)
                query.addQueryItem("oldest", oldest?.asQueryValue)
                query.addQueryItem("channel", channel?.asQueryValue)
                query.addQueryItem("latest", latest?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var conversationsSetPurpose: ConversationsSetPurpose {
        ConversationsSetPurpose(path: "/conversations.setPurpose")
    }

    public struct ConversationsSetPurpose {
        /// Path: `/conversations.setPurpose`
        public let path: String

        /// Sets the purpose for a conversation.
        ///
        /// [API method documentation](https://api.slack.com/methods/conversations.setPurpose)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// A new, specialer purpose
            public var purpose: String?
            /// Conversation to set the purpose of
            public var channel: String?

            public init(purpose: String? = nil, channel: String? = nil) {
                self.purpose = purpose
                self.channel = channel
            }
        }
    }
}

extension Paths {
    public static var conversationsSetTopic: ConversationsSetTopic {
        ConversationsSetTopic(path: "/conversations.setTopic")
    }

    public struct ConversationsSetTopic {
        /// Path: `/conversations.setTopic`
        public let path: String

        /// Sets the topic for a conversation.
        ///
        /// [API method documentation](https://api.slack.com/methods/conversations.setTopic)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The new topic string. Does not support formatting or linkification.
            public var topic: String?
            /// Conversation to set the topic of
            public var channel: String?

            public init(topic: String? = nil, channel: String? = nil) {
                self.topic = topic
                self.channel = channel
            }
        }
    }
}

extension Paths {
    public static var conversationsUnarchive: ConversationsUnarchive {
        ConversationsUnarchive(path: "/conversations.unarchive")
    }

    public struct ConversationsUnarchive {
        /// Path: `/conversations.unarchive`
        public let path: String

        /// Reverses conversation archival.
        ///
        /// [API method documentation](https://api.slack.com/methods/conversations.unarchive)
        public func post(channel: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["channel": channel])
        }
    }
}

extension Paths {
    public static var dialogOpen: DialogOpen {
        DialogOpen(path: "/dialog.open")
    }

    public struct DialogOpen {
        /// Path: `/dialog.open`
        public let path: String

        /// Open a dialog with a user
        ///
        /// [API method documentation](https://api.slack.com/methods/dialog.open)
        public func get(dialog: String? = nil, triggerID: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: makeGetQuery(dialog, triggerID))
        }

        private func makeGetQuery(_ dialog: String?, _ triggerID: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("dialog", dialog?.asQueryValue)
            query.addQueryItem("trigger_id", triggerID?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var dndEndDnd: DndEndDnd {
        DndEndDnd(path: "/dnd.endDnd")
    }

    public struct DndEndDnd {
        /// Path: `/dnd.endDnd`
        public let path: String

        /// Ends the current user's Do Not Disturb session immediately.
        ///
        /// [API method documentation](https://api.slack.com/methods/dnd.endDnd)
        public var post: Request<[String: [String: AnyJSON]]> {
            .post(path)
        }
    }
}

extension Paths {
    public static var dndEndSnooze: DndEndSnooze {
        DndEndSnooze(path: "/dnd.endSnooze")
    }

    public struct DndEndSnooze {
        /// Path: `/dnd.endSnooze`
        public let path: String

        /// Ends the current user's snooze mode immediately.
        ///
        /// [API method documentation](https://api.slack.com/methods/dnd.endSnooze)
        public var post: Request<[String: [String: AnyJSON]]> {
            .post(path)
        }
    }
}

extension Paths {
    public static var dndInfo: DndInfo {
        DndInfo(path: "/dnd.info")
    }

    public struct DndInfo {
        /// Path: `/dnd.info`
        public let path: String

        /// Retrieves a user's current Do Not Disturb status.
        ///
        /// [API method documentation](https://api.slack.com/methods/dnd.info)
        public func get(token: String? = nil, user: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: makeGetQuery(token, user))
        }

        private func makeGetQuery(_ token: String?, _ user: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("token", token?.asQueryValue)
            query.addQueryItem("user", user?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var dndSetSnooze: DndSetSnooze {
        DndSetSnooze(path: "/dnd.setSnooze")
    }

    public struct DndSetSnooze {
        /// Path: `/dnd.setSnooze`
        public let path: String

        /// Turns on Do Not Disturb mode for the current user, or changes its duration.
        ///
        /// [API method documentation](https://api.slack.com/methods/dnd.setSnooze)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body?.asQuery())
        }

        public struct PostRequest: Encodable {
            /// Number of minutes, from now, to snooze until.
            public var numMinutes: Int?
            /// Authentication token. Requires scope: `dnd:write`
            public var token: String?

            public init(numMinutes: Int? = nil, token: String? = nil) {
                self.numMinutes = numMinutes
                self.token = token
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("num_minutes", numMinutes?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths {
    public static var dndTeamInfo: DndTeamInfo {
        DndTeamInfo(path: "/dnd.teamInfo")
    }

    public struct DndTeamInfo {
        /// Path: `/dnd.teamInfo`
        public let path: String

        /// Retrieves the Do Not Disturb status for users on a team.
        ///
        /// [API method documentation](https://api.slack.com/methods/dnd.teamInfo)
        public func get(token: String? = nil, users: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: makeGetQuery(token, users))
        }

        private func makeGetQuery(_ token: String?, _ users: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("token", token?.asQueryValue)
            query.addQueryItem("users", users?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var emojiList: EmojiList {
        EmojiList(path: "/emoji.list")
    }

    public struct EmojiList {
        /// Path: `/emoji.list`
        public let path: String

        /// Lists custom emoji for a team.
        ///
        /// [API method documentation](https://api.slack.com/methods/emoji.list)
        public func get(token: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: makeGetQuery(token))
        }

        private func makeGetQuery(_ token: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("token", token?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var filesCommentsAdd: FilesCommentsAdd {
        FilesCommentsAdd(path: "/files.comments.add")
    }

    public struct FilesCommentsAdd {
        /// Path: `/files.comments.add`
        public let path: String

        /// Add a comment to an existing file.
        ///
        /// [API method documentation](https://api.slack.com/methods/files.comments.add)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Text of the comment to add.
            public var comment: String?
            /// File to add a comment to.
            public var file: String?

            public init(comment: String? = nil, file: String? = nil) {
                self.comment = comment
                self.file = file
            }
        }
    }
}

extension Paths {
    public static var filesCommentsDelete: FilesCommentsDelete {
        FilesCommentsDelete(path: "/files.comments.delete")
    }

    public struct FilesCommentsDelete {
        /// Path: `/files.comments.delete`
        public let path: String

        /// Deletes an existing comment on a file.
        ///
        /// [API method documentation](https://api.slack.com/methods/files.comments.delete)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The comment to delete.
            public var id: String?
            /// File to delete a comment from.
            public var file: String?

            public init(id: String? = nil, file: String? = nil) {
                self.id = id
                self.file = file
            }
        }
    }
}

extension Paths {
    public static var filesCommentsEdit: FilesCommentsEdit {
        FilesCommentsEdit(path: "/files.comments.edit")
    }

    public struct FilesCommentsEdit {
        /// Path: `/files.comments.edit`
        public let path: String

        /// Edit an existing file comment.
        ///
        /// [API method documentation](https://api.slack.com/methods/files.comments.edit)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Text of the comment to edit.
            public var comment: String?
            /// The comment to edit.
            public var id: String?
            /// File containing the comment to edit.
            public var file: String?

            public init(comment: String? = nil, id: String? = nil, file: String? = nil) {
                self.comment = comment
                self.id = id
                self.file = file
            }
        }
    }
}

extension Paths {
    public static var filesDelete: FilesDelete {
        FilesDelete(path: "/files.delete")
    }

    public struct FilesDelete {
        /// Path: `/files.delete`
        public let path: String

        /// Deletes a file.
        ///
        /// [API method documentation](https://api.slack.com/methods/files.delete)
        public func post(file: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["file": file])
        }
    }
}

extension Paths {
    public static var filesInfo: FilesInfo {
        FilesInfo(path: "/files.info")
    }

    public struct FilesInfo {
        /// Path: `/files.info`
        public let path: String

        /// Gets information about a team file.
        ///
        /// [API method documentation](https://api.slack.com/methods/files.info)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var count: String?
            public var token: String?
            public var file: String?
            public var page: String?

            public init(count: String? = nil, token: String? = nil, file: String? = nil, page: String? = nil) {
                self.count = count
                self.token = token
                self.file = file
                self.page = page
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("count", count?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("file", file?.asQueryValue)
                query.addQueryItem("page", page?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var filesList: FilesList {
        FilesList(path: "/files.list")
    }

    public struct FilesList {
        /// Path: `/files.list`
        public let path: String

        /// Lists & filters team files.
        ///
        /// [API method documentation](https://api.slack.com/methods/files.list)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var count: String?
            public var channel: String?
            public var tsTo: Double?
            public var tsFrom: Double?
            public var token: String?
            public var user: String?
            public var page: String?
            public var types: String?

            public init(count: String? = nil, channel: String? = nil, tsTo: Double? = nil, tsFrom: Double? = nil, token: String? = nil, user: String? = nil, page: String? = nil, types: String? = nil) {
                self.count = count
                self.channel = channel
                self.tsTo = tsTo
                self.tsFrom = tsFrom
                self.token = token
                self.user = user
                self.page = page
                self.types = types
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("count", count?.asQueryValue)
                query.addQueryItem("channel", channel?.asQueryValue)
                query.addQueryItem("ts_to", tsTo?.asQueryValue)
                query.addQueryItem("ts_from", tsFrom?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("user", user?.asQueryValue)
                query.addQueryItem("page", page?.asQueryValue)
                query.addQueryItem("types", types?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var filesRevokePublicURL: FilesRevokePublicURL {
        FilesRevokePublicURL(path: "/files.revokePublicURL")
    }

    public struct FilesRevokePublicURL {
        /// Path: `/files.revokePublicURL`
        public let path: String

        /// Revokes public/external sharing access for a file
        ///
        /// [API method documentation](https://api.slack.com/methods/files.revokePublicURL)
        public func post(file: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["file": file])
        }
    }
}

extension Paths {
    public static var filesSharedPublicURL: FilesSharedPublicURL {
        FilesSharedPublicURL(path: "/files.sharedPublicURL")
    }

    public struct FilesSharedPublicURL {
        /// Path: `/files.sharedPublicURL`
        public let path: String

        /// Enables a file for public/external sharing.
        ///
        /// [API method documentation](https://api.slack.com/methods/files.sharedPublicURL)
        public func post(file: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["file": file])
        }
    }
}

extension Paths {
    public static var filesUpload: FilesUpload {
        FilesUpload(path: "/files.upload")
    }

    public struct FilesUpload {
        /// Path: `/files.upload`
        public let path: String

        /// Uploads or creates a file.
        ///
        /// [API method documentation](https://api.slack.com/methods/files.upload)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body?.asQuery())
        }

        public struct PostRequest: Encodable {
            /// Comma-separated list of channel names or IDs where the file will be shared.
            public var channels: String?
            /// Title of file.
            public var title: String?
            /// Initial comment to add to file.
            public var initialComment: String?
            /// A [file type](/types/file#file_types) identifier.
            public var filetype: String?
            /// Filename of file.
            public var filename: String?
            /// File contents via a POST variable. If omitting this parameter, you must provide a `file`.
            public var content: String?
            /// Authentication token. Requires scope: `files:write:user`
            public var token: String?
            /// File contents via `multipart/form-data`. If omitting this parameter, you must submit `content`.
            public var file: String?

            public init(channels: String? = nil, title: String? = nil, initialComment: String? = nil, filetype: String? = nil, filename: String? = nil, content: String? = nil, token: String? = nil, file: String? = nil) {
                self.channels = channels
                self.title = title
                self.initialComment = initialComment
                self.filetype = filetype
                self.filename = filename
                self.content = content
                self.token = token
                self.file = file
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("channels", channels?.asQueryValue)
                query.addQueryItem("title", title?.asQueryValue)
                query.addQueryItem("initial_comment", initialComment?.asQueryValue)
                query.addQueryItem("filetype", filetype?.asQueryValue)
                query.addQueryItem("filename", filename?.asQueryValue)
                query.addQueryItem("content", content?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("file", file?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths {
    public static var groupsArchive: GroupsArchive {
        GroupsArchive(path: "/groups.archive")
    }

    public struct GroupsArchive {
        /// Path: `/groups.archive`
        public let path: String

        /// Archives a private channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/groups.archive)
        public func post(channel: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["channel": channel])
        }
    }
}

extension Paths {
    public static var groupsCreate: GroupsCreate {
        GroupsCreate(path: "/groups.create")
    }

    public struct GroupsCreate {
        /// Path: `/groups.create`
        public let path: String

        /// Creates a private channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/groups.create)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Whether to return errors on invalid channel name instead of modifying it to meet the specified criteria.
            public var isValidate: Bool?
            /// Name of private channel to create
            public var name: String?

            public init(isValidate: Bool? = nil, name: String? = nil) {
                self.isValidate = isValidate
                self.name = name
            }

            private enum CodingKeys: String, CodingKey {
                case isValidate = "validate"
                case name
            }
        }
    }
}

extension Paths {
    public static var groupsCreateChild: GroupsCreateChild {
        GroupsCreateChild(path: "/groups.createChild")
    }

    public struct GroupsCreateChild {
        /// Path: `/groups.createChild`
        public let path: String

        /// Clones and archives a private channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/groups.createChild)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body?.asQuery())
        }

        public struct PostRequest: Encodable {
            /// Authentication token. Requires scope: `groups:write`
            public var token: String?
            /// Private channel to clone and archive.
            public var channel: String?

            public init(token: String? = nil, channel: String? = nil) {
                self.token = token
                self.channel = channel
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("channel", channel?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths {
    public static var groupsHistory: GroupsHistory {
        GroupsHistory(path: "/groups.history")
    }

    public struct GroupsHistory {
        /// Path: `/groups.history`
        public let path: String

        /// Fetches history of messages and events from a private channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/groups.history)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var count: Int?
            public var isUnreads: Bool?
            public var isInclusive: Bool?
            public var token: String?
            public var oldest: Double?
            public var channel: String?
            public var latest: Double?

            public init(count: Int? = nil, isUnreads: Bool? = nil, isInclusive: Bool? = nil, token: String? = nil, oldest: Double? = nil, channel: String? = nil, latest: Double? = nil) {
                self.count = count
                self.isUnreads = isUnreads
                self.isInclusive = isInclusive
                self.token = token
                self.oldest = oldest
                self.channel = channel
                self.latest = latest
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("count", count?.asQueryValue)
                query.addQueryItem("unreads", isUnreads?.asQueryValue)
                query.addQueryItem("inclusive", isInclusive?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("oldest", oldest?.asQueryValue)
                query.addQueryItem("channel", channel?.asQueryValue)
                query.addQueryItem("latest", latest?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var groupsInfo: GroupsInfo {
        GroupsInfo(path: "/groups.info")
    }

    public struct GroupsInfo {
        /// Path: `/groups.info`
        public let path: String

        /// Gets information about a private channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/groups.info)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var token: String?
            public var isIncludeLocale: Bool?
            public var channel: String?

            public init(token: String? = nil, isIncludeLocale: Bool? = nil, channel: String? = nil) {
                self.token = token
                self.isIncludeLocale = isIncludeLocale
                self.channel = channel
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("include_locale", isIncludeLocale?.asQueryValue)
                query.addQueryItem("channel", channel?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var groupsInvite: GroupsInvite {
        GroupsInvite(path: "/groups.invite")
    }

    public struct GroupsInvite {
        /// Path: `/groups.invite`
        public let path: String

        /// Invites a user to a private channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/groups.invite)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// User to invite.
            public var user: String?
            /// Private channel to invite user to.
            public var channel: String?

            public init(user: String? = nil, channel: String? = nil) {
                self.user = user
                self.channel = channel
            }
        }
    }
}

extension Paths {
    public static var groupsKick: GroupsKick {
        GroupsKick(path: "/groups.kick")
    }

    public struct GroupsKick {
        /// Path: `/groups.kick`
        public let path: String

        /// Removes a user from a private channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/groups.kick)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// User to remove from private channel.
            public var user: String?
            /// Private channel to remove user from.
            public var channel: String?

            public init(user: String? = nil, channel: String? = nil) {
                self.user = user
                self.channel = channel
            }
        }
    }
}

extension Paths {
    public static var groupsLeave: GroupsLeave {
        GroupsLeave(path: "/groups.leave")
    }

    public struct GroupsLeave {
        /// Path: `/groups.leave`
        public let path: String

        /// Leaves a private channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/groups.leave)
        public func post(channel: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["channel": channel])
        }
    }
}

extension Paths {
    public static var groupsList: GroupsList {
        GroupsList(path: "/groups.list")
    }

    public struct GroupsList {
        /// Path: `/groups.list`
        public let path: String

        /// Lists private channels that the calling user has access to.
        ///
        /// [API method documentation](https://api.slack.com/methods/groups.list)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var excludeMembers: Bool?
            public var token: String?
            public var excludeArchived: Bool?

            public init(excludeMembers: Bool? = nil, token: String? = nil, excludeArchived: Bool? = nil) {
                self.excludeMembers = excludeMembers
                self.token = token
                self.excludeArchived = excludeArchived
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("exclude_members", excludeMembers?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("exclude_archived", excludeArchived?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var groupsMark: GroupsMark {
        GroupsMark(path: "/groups.mark")
    }

    public struct GroupsMark {
        /// Path: `/groups.mark`
        public let path: String

        /// Sets the read cursor in a private channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/groups.mark)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Timestamp of the most recently seen message.
            public var ts: Double?
            /// Private channel to set reading cursor in.
            public var channel: String?

            public init(ts: Double? = nil, channel: String? = nil) {
                self.ts = ts
                self.channel = channel
            }
        }
    }
}

extension Paths {
    public static var groupsOpen: GroupsOpen {
        GroupsOpen(path: "/groups.open")
    }

    public struct GroupsOpen {
        /// Path: `/groups.open`
        public let path: String

        /// Opens a private channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/groups.open)
        public func post(channel: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["channel": channel])
        }
    }
}

extension Paths {
    public static var groupsRename: GroupsRename {
        GroupsRename(path: "/groups.rename")
    }

    public struct GroupsRename {
        /// Path: `/groups.rename`
        public let path: String

        /// Renames a private channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/groups.rename)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Whether to return errors on invalid channel name instead of modifying it to meet the specified criteria.
            public var isValidate: Bool?
            /// New name for private channel.
            public var name: String?
            /// Private channel to rename
            public var channel: String?

            public init(isValidate: Bool? = nil, name: String? = nil, channel: String? = nil) {
                self.isValidate = isValidate
                self.name = name
                self.channel = channel
            }

            private enum CodingKeys: String, CodingKey {
                case isValidate = "validate"
                case name
                case channel
            }
        }
    }
}

extension Paths {
    public static var groupsReplies: GroupsReplies {
        GroupsReplies(path: "/groups.replies")
    }

    public struct GroupsReplies {
        /// Path: `/groups.replies`
        public let path: String

        /// Retrieve a thread of messages posted to a private channel
        ///
        /// [API method documentation](https://api.slack.com/methods/groups.replies)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var threadTs: Double?
            public var token: String?
            public var channel: String?

            public init(threadTs: Double? = nil, token: String? = nil, channel: String? = nil) {
                self.threadTs = threadTs
                self.token = token
                self.channel = channel
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("thread_ts", threadTs?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("channel", channel?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var groupsSetPurpose: GroupsSetPurpose {
        GroupsSetPurpose(path: "/groups.setPurpose")
    }

    public struct GroupsSetPurpose {
        /// Path: `/groups.setPurpose`
        public let path: String

        /// Sets the purpose for a private channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/groups.setPurpose)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The new purpose
            public var purpose: String?
            /// Private channel to set the purpose of
            public var channel: String?

            public init(purpose: String? = nil, channel: String? = nil) {
                self.purpose = purpose
                self.channel = channel
            }
        }
    }
}

extension Paths {
    public static var groupsSetTopic: GroupsSetTopic {
        GroupsSetTopic(path: "/groups.setTopic")
    }

    public struct GroupsSetTopic {
        /// Path: `/groups.setTopic`
        public let path: String

        /// Sets the topic for a private channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/groups.setTopic)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The new topic
            public var topic: String?
            /// Private channel to set the topic of
            public var channel: String?

            public init(topic: String? = nil, channel: String? = nil) {
                self.topic = topic
                self.channel = channel
            }
        }
    }
}

extension Paths {
    public static var groupsUnarchive: GroupsUnarchive {
        GroupsUnarchive(path: "/groups.unarchive")
    }

    public struct GroupsUnarchive {
        /// Path: `/groups.unarchive`
        public let path: String

        /// Unarchives a private channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/groups.unarchive)
        public func post(channel: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["channel": channel])
        }
    }
}

extension Paths {
    public static var imClose: ImClose {
        ImClose(path: "/im.close")
    }

    public struct ImClose {
        /// Path: `/im.close`
        public let path: String

        /// Close a direct message channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/im.close)
        public func post(channel: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["channel": channel])
        }
    }
}

extension Paths {
    public static var imHistory: ImHistory {
        ImHistory(path: "/im.history")
    }

    public struct ImHistory {
        /// Path: `/im.history`
        public let path: String

        /// Fetches history of messages and events from direct message channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/im.history)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var count: Int?
            public var isUnreads: Bool?
            public var isInclusive: Bool?
            public var token: String?
            public var oldest: Double?
            public var channel: String?
            public var latest: Double?

            public init(count: Int? = nil, isUnreads: Bool? = nil, isInclusive: Bool? = nil, token: String? = nil, oldest: Double? = nil, channel: String? = nil, latest: Double? = nil) {
                self.count = count
                self.isUnreads = isUnreads
                self.isInclusive = isInclusive
                self.token = token
                self.oldest = oldest
                self.channel = channel
                self.latest = latest
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("count", count?.asQueryValue)
                query.addQueryItem("unreads", isUnreads?.asQueryValue)
                query.addQueryItem("inclusive", isInclusive?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("oldest", oldest?.asQueryValue)
                query.addQueryItem("channel", channel?.asQueryValue)
                query.addQueryItem("latest", latest?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var imList: ImList {
        ImList(path: "/im.list")
    }

    public struct ImList {
        /// Path: `/im.list`
        public let path: String

        /// Lists direct message channels for the calling user.
        ///
        /// [API method documentation](https://api.slack.com/methods/im.list)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var cursor: String?
            public var token: String?
            public var limit: Int?

            public init(cursor: String? = nil, token: String? = nil, limit: Int? = nil) {
                self.cursor = cursor
                self.token = token
                self.limit = limit
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("cursor", cursor?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("limit", limit?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var imMark: ImMark {
        ImMark(path: "/im.mark")
    }

    public struct ImMark {
        /// Path: `/im.mark`
        public let path: String

        /// Sets the read cursor in a direct message channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/im.mark)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Timestamp of the most recently seen message.
            public var ts: Double?
            /// Direct message channel to set reading cursor in.
            public var channel: String?

            public init(ts: Double? = nil, channel: String? = nil) {
                self.ts = ts
                self.channel = channel
            }
        }
    }
}

extension Paths {
    public static var imOpen: ImOpen {
        ImOpen(path: "/im.open")
    }

    public struct ImOpen {
        /// Path: `/im.open`
        public let path: String

        /// Opens a direct message channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/im.open)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Boolean, indicates you want the full IM channel definition in the response.
            public var isReturnIm: Bool?
            /// User to open a direct message channel with.
            public var user: String?
            /// Set this to `true` to receive the locale for this im. Defaults to `false`
            public var isIncludeLocale: Bool?

            public init(isReturnIm: Bool? = nil, user: String? = nil, isIncludeLocale: Bool? = nil) {
                self.isReturnIm = isReturnIm
                self.user = user
                self.isIncludeLocale = isIncludeLocale
            }

            private enum CodingKeys: String, CodingKey {
                case isReturnIm = "return_im"
                case user
                case isIncludeLocale = "include_locale"
            }
        }
    }
}

extension Paths {
    public static var imReplies: ImReplies {
        ImReplies(path: "/im.replies")
    }

    public struct ImReplies {
        /// Path: `/im.replies`
        public let path: String

        /// Retrieve a thread of messages posted to a direct message conversation
        ///
        /// [API method documentation](https://api.slack.com/methods/im.replies)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var threadTs: Double?
            public var token: String?
            public var channel: String?

            public init(threadTs: Double? = nil, token: String? = nil, channel: String? = nil) {
                self.threadTs = threadTs
                self.token = token
                self.channel = channel
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("thread_ts", threadTs?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("channel", channel?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var migrationExchange: MigrationExchange {
        MigrationExchange(path: "/migration.exchange")
    }

    public struct MigrationExchange {
        /// Path: `/migration.exchange`
        public let path: String

        /// For Enterprise Grid workspaces, map local user IDs to global user IDs
        ///
        /// [API method documentation](https://api.slack.com/methods/migration.exchange)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var token: String?
            public var isToOld: Bool?
            public var users: String?

            public init(token: String? = nil, isToOld: Bool? = nil, users: String? = nil) {
                self.token = token
                self.isToOld = isToOld
                self.users = users
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("to_old", isToOld?.asQueryValue)
                query.addQueryItem("users", users?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var mpimClose: MpimClose {
        MpimClose(path: "/mpim.close")
    }

    public struct MpimClose {
        /// Path: `/mpim.close`
        public let path: String

        /// Closes a multiparty direct message channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/mpim.close)
        public func post(channel: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["channel": channel])
        }
    }
}

extension Paths {
    public static var mpimHistory: MpimHistory {
        MpimHistory(path: "/mpim.history")
    }

    public struct MpimHistory {
        /// Path: `/mpim.history`
        public let path: String

        /// Fetches history of messages and events from a multiparty direct message.
        ///
        /// [API method documentation](https://api.slack.com/methods/mpim.history)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var count: Int?
            public var isUnreads: Bool?
            public var isInclusive: Bool?
            public var token: String?
            public var oldest: Double?
            public var channel: String?
            public var latest: Double?

            public init(count: Int? = nil, isUnreads: Bool? = nil, isInclusive: Bool? = nil, token: String? = nil, oldest: Double? = nil, channel: String? = nil, latest: Double? = nil) {
                self.count = count
                self.isUnreads = isUnreads
                self.isInclusive = isInclusive
                self.token = token
                self.oldest = oldest
                self.channel = channel
                self.latest = latest
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("count", count?.asQueryValue)
                query.addQueryItem("unreads", isUnreads?.asQueryValue)
                query.addQueryItem("inclusive", isInclusive?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("oldest", oldest?.asQueryValue)
                query.addQueryItem("channel", channel?.asQueryValue)
                query.addQueryItem("latest", latest?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var mpimList: MpimList {
        MpimList(path: "/mpim.list")
    }

    public struct MpimList {
        /// Path: `/mpim.list`
        public let path: String

        /// Lists multiparty direct message channels for the calling user.
        ///
        /// [API method documentation](https://api.slack.com/methods/mpim.list)
        public func get(token: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: makeGetQuery(token))
        }

        private func makeGetQuery(_ token: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("token", token?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var mpimMark: MpimMark {
        MpimMark(path: "/mpim.mark")
    }

    public struct MpimMark {
        /// Path: `/mpim.mark`
        public let path: String

        /// Sets the read cursor in a multiparty direct message channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/mpim.mark)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Timestamp of the most recently seen message.
            public var ts: Double?
            /// Multiparty direct message channel to set reading cursor in.
            public var channel: String?

            public init(ts: Double? = nil, channel: String? = nil) {
                self.ts = ts
                self.channel = channel
            }
        }
    }
}

extension Paths {
    public static var mpimOpen: MpimOpen {
        MpimOpen(path: "/mpim.open")
    }

    public struct MpimOpen {
        /// Path: `/mpim.open`
        public let path: String

        /// This method opens a multiparty direct message.
        ///
        /// [API method documentation](https://api.slack.com/methods/mpim.open)
        public func post(users: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["users": users])
        }
    }
}

extension Paths {
    public static var mpimReplies: MpimReplies {
        MpimReplies(path: "/mpim.replies")
    }

    public struct MpimReplies {
        /// Path: `/mpim.replies`
        public let path: String

        /// Retrieve a thread of messages posted to a direct message conversation from a multiparty direct message.
        ///
        /// [API method documentation](https://api.slack.com/methods/mpim.replies)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var threadTs: Double?
            public var token: String?
            public var channel: String?

            public init(threadTs: Double? = nil, token: String? = nil, channel: String? = nil) {
                self.threadTs = threadTs
                self.token = token
                self.channel = channel
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("thread_ts", threadTs?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("channel", channel?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var oauthAccess: OauthAccess {
        OauthAccess(path: "/oauth.access")
    }

    public struct OauthAccess {
        /// Path: `/oauth.access`
        public let path: String

        /// Exchanges a temporary OAuth verifier code for an access token.
        ///
        /// [API method documentation](https://api.slack.com/methods/oauth.access)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var clientSecret: String?
            public var code: String?
            public var isSingleChannel: Bool?
            public var clientID: String?
            public var redirectUri: String?

            public init(clientSecret: String? = nil, code: String? = nil, isSingleChannel: Bool? = nil, clientID: String? = nil, redirectUri: String? = nil) {
                self.clientSecret = clientSecret
                self.code = code
                self.isSingleChannel = isSingleChannel
                self.clientID = clientID
                self.redirectUri = redirectUri
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("client_secret", clientSecret?.asQueryValue)
                query.addQueryItem("code", code?.asQueryValue)
                query.addQueryItem("single_channel", isSingleChannel?.asQueryValue)
                query.addQueryItem("client_id", clientID?.asQueryValue)
                query.addQueryItem("redirect_uri", redirectUri?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var oauthToken: OauthToken {
        OauthToken(path: "/oauth.token")
    }

    public struct OauthToken {
        /// Path: `/oauth.token`
        public let path: String

        /// Exchanges a temporary OAuth verifier code for a workspace token.
        ///
        /// [API method documentation](https://api.slack.com/methods/oauth.token)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var clientSecret: String?
            public var code: String?
            public var isSingleChannel: Bool?
            public var clientID: String?
            public var redirectUri: String?

            public init(clientSecret: String? = nil, code: String? = nil, isSingleChannel: Bool? = nil, clientID: String? = nil, redirectUri: String? = nil) {
                self.clientSecret = clientSecret
                self.code = code
                self.isSingleChannel = isSingleChannel
                self.clientID = clientID
                self.redirectUri = redirectUri
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("client_secret", clientSecret?.asQueryValue)
                query.addQueryItem("code", code?.asQueryValue)
                query.addQueryItem("single_channel", isSingleChannel?.asQueryValue)
                query.addQueryItem("client_id", clientID?.asQueryValue)
                query.addQueryItem("redirect_uri", redirectUri?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var pinsAdd: PinsAdd {
        PinsAdd(path: "/pins.add")
    }

    public struct PinsAdd {
        /// Path: `/pins.add`
        public let path: String

        /// Pins an item to a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/pins.add)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// File comment to pin.
            public var fileComment: String?
            /// Timestamp of the message to pin.
            public var timestamp: Double?
            /// File to pin.
            public var file: String?
            /// Channel to pin the item in.
            public var channel: String?

            public init(fileComment: String? = nil, timestamp: Double? = nil, file: String? = nil, channel: String? = nil) {
                self.fileComment = fileComment
                self.timestamp = timestamp
                self.file = file
                self.channel = channel
            }

            private enum CodingKeys: String, CodingKey {
                case fileComment = "file_comment"
                case timestamp
                case file
                case channel
            }
        }
    }
}

extension Paths {
    public static var pinsList: PinsList {
        PinsList(path: "/pins.list")
    }

    public struct PinsList {
        /// Path: `/pins.list`
        public let path: String

        /// Lists items pinned to a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/pins.list)
        public func get(token: String? = nil, channel: String? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(token, channel))
        }

        private func makeGetQuery(_ token: String?, _ channel: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("token", token?.asQueryValue)
            query.addQueryItem("channel", channel?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var pinsRemove: PinsRemove {
        PinsRemove(path: "/pins.remove")
    }

    public struct PinsRemove {
        /// Path: `/pins.remove`
        public let path: String

        /// Un-pins an item from a channel.
        ///
        /// [API method documentation](https://api.slack.com/methods/pins.remove)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// File comment to un-pin.
            public var fileComment: String?
            /// Timestamp of the message to un-pin.
            public var timestamp: Double?
            /// File to un-pin.
            public var file: String?
            /// Channel where the item is pinned to.
            public var channel: String?

            public init(fileComment: String? = nil, timestamp: Double? = nil, file: String? = nil, channel: String? = nil) {
                self.fileComment = fileComment
                self.timestamp = timestamp
                self.file = file
                self.channel = channel
            }

            private enum CodingKeys: String, CodingKey {
                case fileComment = "file_comment"
                case timestamp
                case file
                case channel
            }
        }
    }
}

extension Paths {
    public static var reactionsAdd: ReactionsAdd {
        ReactionsAdd(path: "/reactions.add")
    }

    public struct ReactionsAdd {
        /// Path: `/reactions.add`
        public let path: String

        /// Adds a reaction to an item.
        ///
        /// [API method documentation](https://api.slack.com/methods/reactions.add)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Reaction (emoji) name.
            public var name: String?
            /// File comment to add reaction to.
            public var fileComment: String?
            /// Timestamp of the message to add reaction to.
            public var timestamp: Double?
            /// File to add reaction to.
            public var file: String?
            /// Channel where the message to add reaction to was posted.
            public var channel: String?

            public init(name: String? = nil, fileComment: String? = nil, timestamp: Double? = nil, file: String? = nil, channel: String? = nil) {
                self.name = name
                self.fileComment = fileComment
                self.timestamp = timestamp
                self.file = file
                self.channel = channel
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case fileComment = "file_comment"
                case timestamp
                case file
                case channel
            }
        }
    }
}

extension Paths {
    public static var reactionsGet: ReactionsGet {
        ReactionsGet(path: "/reactions.get")
    }

    public struct ReactionsGet {
        /// Path: `/reactions.get`
        public let path: String

        /// Gets reactions for an item.
        ///
        /// [API method documentation](https://api.slack.com/methods/reactions.get)
        public func get(parameters: GetParameters? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var isFull: Bool?
            public var fileComment: String?
            public var timestamp: Double?
            public var token: String?
            public var file: String?
            public var channel: String?

            public init(isFull: Bool? = nil, fileComment: String? = nil, timestamp: Double? = nil, token: String? = nil, file: String? = nil, channel: String? = nil) {
                self.isFull = isFull
                self.fileComment = fileComment
                self.timestamp = timestamp
                self.token = token
                self.file = file
                self.channel = channel
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("full", isFull?.asQueryValue)
                query.addQueryItem("file_comment", fileComment?.asQueryValue)
                query.addQueryItem("timestamp", timestamp?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("file", file?.asQueryValue)
                query.addQueryItem("channel", channel?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var reactionsList: ReactionsList {
        ReactionsList(path: "/reactions.list")
    }

    public struct ReactionsList {
        /// Path: `/reactions.list`
        public let path: String

        /// Lists reactions made by a user.
        ///
        /// [API method documentation](https://api.slack.com/methods/reactions.list)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var count: String?
            public var token: String?
            public var isFull: Bool?
            public var user: String?
            public var page: String?

            public init(count: String? = nil, token: String? = nil, isFull: Bool? = nil, user: String? = nil, page: String? = nil) {
                self.count = count
                self.token = token
                self.isFull = isFull
                self.user = user
                self.page = page
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("count", count?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("full", isFull?.asQueryValue)
                query.addQueryItem("user", user?.asQueryValue)
                query.addQueryItem("page", page?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var reactionsRemove: ReactionsRemove {
        ReactionsRemove(path: "/reactions.remove")
    }

    public struct ReactionsRemove {
        /// Path: `/reactions.remove`
        public let path: String

        /// Removes a reaction from an item.
        ///
        /// [API method documentation](https://api.slack.com/methods/reactions.remove)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Reaction (emoji) name.
            public var name: String?
            /// File comment to remove reaction from.
            public var fileComment: String?
            /// Timestamp of the message to remove reaction from.
            public var timestamp: Double?
            /// File to remove reaction from.
            public var file: String?
            /// Channel where the message to remove reaction from was posted.
            public var channel: String?

            public init(name: String? = nil, fileComment: String? = nil, timestamp: Double? = nil, file: String? = nil, channel: String? = nil) {
                self.name = name
                self.fileComment = fileComment
                self.timestamp = timestamp
                self.file = file
                self.channel = channel
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case fileComment = "file_comment"
                case timestamp
                case file
                case channel
            }
        }
    }
}

extension Paths {
    public static var remindersAdd: RemindersAdd {
        RemindersAdd(path: "/reminders.add")
    }

    public struct RemindersAdd {
        /// Path: `/reminders.add`
        public let path: String

        /// Creates a reminder.
        ///
        /// [API method documentation](https://api.slack.com/methods/reminders.add)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The content of the reminder
            public var text: String?
            /// The user who will receive the reminder. If no user is specified, the reminder will go to user who created it.
            public var user: String?
            /// When this reminder should happen: the Unix timestamp (up to five years from now), the number of seconds until the reminder (if within 24 hours), or a natural language description (Ex. "in 15 minutes," or "every Thursday")
            public var time: String?

            public init(text: String? = nil, user: String? = nil, time: String? = nil) {
                self.text = text
                self.user = user
                self.time = time
            }
        }
    }
}

extension Paths {
    public static var remindersComplete: RemindersComplete {
        RemindersComplete(path: "/reminders.complete")
    }

    public struct RemindersComplete {
        /// Path: `/reminders.complete`
        public let path: String

        /// Marks a reminder as complete.
        ///
        /// [API method documentation](https://api.slack.com/methods/reminders.complete)
        public func post(reminder: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["reminder": reminder])
        }
    }
}

extension Paths {
    public static var remindersDelete: RemindersDelete {
        RemindersDelete(path: "/reminders.delete")
    }

    public struct RemindersDelete {
        /// Path: `/reminders.delete`
        public let path: String

        /// Deletes a reminder.
        ///
        /// [API method documentation](https://api.slack.com/methods/reminders.delete)
        public func post(reminder: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["reminder": reminder])
        }
    }
}

extension Paths {
    public static var remindersInfo: RemindersInfo {
        RemindersInfo(path: "/reminders.info")
    }

    public struct RemindersInfo {
        /// Path: `/reminders.info`
        public let path: String

        /// Gets information about a reminder.
        ///
        /// [API method documentation](https://api.slack.com/methods/reminders.info)
        public func get(token: String? = nil, reminder: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: makeGetQuery(token, reminder))
        }

        private func makeGetQuery(_ token: String?, _ reminder: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("token", token?.asQueryValue)
            query.addQueryItem("reminder", reminder?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var remindersList: RemindersList {
        RemindersList(path: "/reminders.list")
    }

    public struct RemindersList {
        /// Path: `/reminders.list`
        public let path: String

        /// Lists all reminders created by or for a given user.
        ///
        /// [API method documentation](https://api.slack.com/methods/reminders.list)
        public func get(token: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: makeGetQuery(token))
        }

        private func makeGetQuery(_ token: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("token", token?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var rtmConnect: RtmConnect {
        RtmConnect(path: "/rtm.connect")
    }

    public struct RtmConnect {
        /// Path: `/rtm.connect`
        public let path: String

        /// Starts a Real Time Messaging session.
        ///
        /// [API method documentation](https://api.slack.com/methods/rtm.connect)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var isPresenceSub: Bool?
            public var token: String?
            public var isBatchPresenceAware: Bool?

            public init(isPresenceSub: Bool? = nil, token: String? = nil, isBatchPresenceAware: Bool? = nil) {
                self.isPresenceSub = isPresenceSub
                self.token = token
                self.isBatchPresenceAware = isBatchPresenceAware
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("presence_sub", isPresenceSub?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("batch_presence_aware", isBatchPresenceAware?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var searchAll: SearchAll {
        SearchAll(path: "/search.all")
    }

    public struct SearchAll {
        /// Path: `/search.all`
        public let path: String

        /// Searches for messages and files matching a query.
        ///
        /// [API method documentation](https://api.slack.com/methods/search.all)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var sortDir: String?
            public var query: String?
            public var sort: String?
            public var count: String?
            public var token: String?
            public var isHighlight: Bool?
            public var page: String?

            public init(sortDir: String? = nil, query: String? = nil, sort: String? = nil, count: String? = nil, token: String? = nil, isHighlight: Bool? = nil, page: String? = nil) {
                self.sortDir = sortDir
                self.query = query
                self.sort = sort
                self.count = count
                self.token = token
                self.isHighlight = isHighlight
                self.page = page
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("sort_dir", sortDir?.asQueryValue)
                query.addQueryItem("query", self.query?.asQueryValue)
                query.addQueryItem("sort", sort?.asQueryValue)
                query.addQueryItem("count", count?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("highlight", isHighlight?.asQueryValue)
                query.addQueryItem("page", page?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var searchFiles: SearchFiles {
        SearchFiles(path: "/search.files")
    }

    public struct SearchFiles {
        /// Path: `/search.files`
        public let path: String

        /// Searches for files matching a query.
        ///
        /// [API method documentation](https://api.slack.com/methods/search.files)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var sortDir: String?
            public var query: String?
            public var sort: String?
            public var isHighlight: Bool?
            public var count: String?
            public var token: String?
            public var page: String?

            public init(sortDir: String? = nil, query: String? = nil, sort: String? = nil, isHighlight: Bool? = nil, count: String? = nil, token: String? = nil, page: String? = nil) {
                self.sortDir = sortDir
                self.query = query
                self.sort = sort
                self.isHighlight = isHighlight
                self.count = count
                self.token = token
                self.page = page
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("sort_dir", sortDir?.asQueryValue)
                query.addQueryItem("query", self.query?.asQueryValue)
                query.addQueryItem("sort", sort?.asQueryValue)
                query.addQueryItem("highlight", isHighlight?.asQueryValue)
                query.addQueryItem("count", count?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("page", page?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var searchMessages: SearchMessages {
        SearchMessages(path: "/search.messages")
    }

    public struct SearchMessages {
        /// Path: `/search.messages`
        public let path: String

        /// Searches for messages matching a query.
        ///
        /// [API method documentation](https://api.slack.com/methods/search.messages)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var sortDir: String?
            public var query: String?
            public var sort: String?
            public var count: String?
            public var token: String?
            public var isHighlight: Bool?
            public var page: String?

            public init(sortDir: String? = nil, query: String? = nil, sort: String? = nil, count: String? = nil, token: String? = nil, isHighlight: Bool? = nil, page: String? = nil) {
                self.sortDir = sortDir
                self.query = query
                self.sort = sort
                self.count = count
                self.token = token
                self.isHighlight = isHighlight
                self.page = page
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("sort_dir", sortDir?.asQueryValue)
                query.addQueryItem("query", self.query?.asQueryValue)
                query.addQueryItem("sort", sort?.asQueryValue)
                query.addQueryItem("count", count?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("highlight", isHighlight?.asQueryValue)
                query.addQueryItem("page", page?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var starsAdd: StarsAdd {
        StarsAdd(path: "/stars.add")
    }

    public struct StarsAdd {
        /// Path: `/stars.add`
        public let path: String

        /// Adds a star to an item.
        ///
        /// [API method documentation](https://api.slack.com/methods/stars.add)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// File comment to add star to.
            public var fileComment: String?
            /// Timestamp of the message to add star to.
            public var timestamp: Double?
            /// Channel to add star to, or channel where the message to add star to was posted (used with `timestamp`).
            public var channel: String?
            /// File to add star to.
            public var file: String?

            public init(fileComment: String? = nil, timestamp: Double? = nil, channel: String? = nil, file: String? = nil) {
                self.fileComment = fileComment
                self.timestamp = timestamp
                self.channel = channel
                self.file = file
            }

            private enum CodingKeys: String, CodingKey {
                case fileComment = "file_comment"
                case timestamp
                case channel
                case file
            }
        }
    }
}

extension Paths {
    public static var starsList: StarsList {
        StarsList(path: "/stars.list")
    }

    public struct StarsList {
        /// Path: `/stars.list`
        public let path: String

        /// Lists stars for a user.
        ///
        /// [API method documentation](https://api.slack.com/methods/stars.list)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var count: String?
            public var token: String?
            public var page: String?

            public init(count: String? = nil, token: String? = nil, page: String? = nil) {
                self.count = count
                self.token = token
                self.page = page
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("count", count?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("page", page?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var starsRemove: StarsRemove {
        StarsRemove(path: "/stars.remove")
    }

    public struct StarsRemove {
        /// Path: `/stars.remove`
        public let path: String

        /// Removes a star from an item.
        ///
        /// [API method documentation](https://api.slack.com/methods/stars.remove)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// File comment to remove star from.
            public var fileComment: String?
            /// Timestamp of the message to remove star from.
            public var timestamp: Double?
            /// Channel to remove star from, or channel where the message to remove star from was posted (used with `timestamp`).
            public var channel: String?
            /// File to remove star from.
            public var file: String?

            public init(fileComment: String? = nil, timestamp: Double? = nil, channel: String? = nil, file: String? = nil) {
                self.fileComment = fileComment
                self.timestamp = timestamp
                self.channel = channel
                self.file = file
            }

            private enum CodingKeys: String, CodingKey {
                case fileComment = "file_comment"
                case timestamp
                case channel
                case file
            }
        }
    }
}

extension Paths {
    public static var teamAccessLogs: TeamAccessLogs {
        TeamAccessLogs(path: "/team.accessLogs")
    }

    public struct TeamAccessLogs {
        /// Path: `/team.accessLogs`
        public let path: String

        /// Gets the access logs for the current team.
        ///
        /// [API method documentation](https://api.slack.com/methods/team.accessLogs)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var count: String?
            public var token: String?
            public var page: String?
            public var before: Int?

            public init(count: String? = nil, token: String? = nil, page: String? = nil, before: Int? = nil) {
                self.count = count
                self.token = token
                self.page = page
                self.before = before
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("count", count?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("page", page?.asQueryValue)
                query.addQueryItem("before", before?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var teamBillableInfo: TeamBillableInfo {
        TeamBillableInfo(path: "/team.billableInfo")
    }

    public struct TeamBillableInfo {
        /// Path: `/team.billableInfo`
        public let path: String

        /// Gets billable users information for the current team.
        ///
        /// [API method documentation](https://api.slack.com/methods/team.billableInfo)
        public func get(token: String? = nil, user: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: makeGetQuery(token, user))
        }

        private func makeGetQuery(_ token: String?, _ user: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("token", token?.asQueryValue)
            query.addQueryItem("user", user?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var teamInfo: TeamInfo {
        TeamInfo(path: "/team.info")
    }

    public struct TeamInfo {
        /// Path: `/team.info`
        public let path: String

        /// Gets information about the current team.
        ///
        /// [API method documentation](https://api.slack.com/methods/team.info)
        public func get(token: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: makeGetQuery(token))
        }

        private func makeGetQuery(_ token: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("token", token?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var teamIntegrationLogs: TeamIntegrationLogs {
        TeamIntegrationLogs(path: "/team.integrationLogs")
    }

    public struct TeamIntegrationLogs {
        /// Path: `/team.integrationLogs`
        public let path: String

        /// Gets the integration logs for the current team.
        ///
        /// [API method documentation](https://api.slack.com/methods/team.integrationLogs)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var count: String?
            public var changeType: String?
            public var appID: Int?
            public var token: String?
            public var user: String?
            public var serviceID: Int?
            public var page: String?

            public init(count: String? = nil, changeType: String? = nil, appID: Int? = nil, token: String? = nil, user: String? = nil, serviceID: Int? = nil, page: String? = nil) {
                self.count = count
                self.changeType = changeType
                self.appID = appID
                self.token = token
                self.user = user
                self.serviceID = serviceID
                self.page = page
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("count", count?.asQueryValue)
                query.addQueryItem("change_type", changeType?.asQueryValue)
                query.addQueryItem("app_id", appID?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("user", user?.asQueryValue)
                query.addQueryItem("service_id", serviceID?.asQueryValue)
                query.addQueryItem("page", page?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var teamProfileGet: TeamProfileGet {
        TeamProfileGet(path: "/team.profile.get")
    }

    public struct TeamProfileGet {
        /// Path: `/team.profile.get`
        public let path: String

        /// Retrieve a team's profile.
        ///
        /// [API method documentation](https://api.slack.com/methods/team.profile.get)
        public func get(token: String? = nil, visibility: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: makeGetQuery(token, visibility))
        }

        private func makeGetQuery(_ token: String?, _ visibility: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("token", token?.asQueryValue)
            query.addQueryItem("visibility", visibility?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var usergroupsCreate: UsergroupsCreate {
        UsergroupsCreate(path: "/usergroups.create")
    }

    public struct UsergroupsCreate {
        /// Path: `/usergroups.create`
        public let path: String

        /// Create a User Group
        ///
        /// [API method documentation](https://api.slack.com/methods/usergroups.create)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// A mention handle. Must be unique among channels, users and User Groups.
            public var handle: String?
            /// A name for the User Group. Must be unique among User Groups.
            public var name: String?
            /// A comma separated string of encoded channel IDs for which the User Group uses as a default.
            public var channels: String?
            /// Include the number of users in each User Group.
            public var isIncludeCount: Bool?
            /// A short description of the User Group.
            public var description: String?

            public init(handle: String? = nil, name: String? = nil, channels: String? = nil, isIncludeCount: Bool? = nil, description: String? = nil) {
                self.handle = handle
                self.name = name
                self.channels = channels
                self.isIncludeCount = isIncludeCount
                self.description = description
            }

            private enum CodingKeys: String, CodingKey {
                case handle
                case name
                case channels
                case isIncludeCount = "include_count"
                case description
            }
        }
    }
}

extension Paths {
    public static var usergroupsDisable: UsergroupsDisable {
        UsergroupsDisable(path: "/usergroups.disable")
    }

    public struct UsergroupsDisable {
        /// Path: `/usergroups.disable`
        public let path: String

        /// Disable an existing User Group
        ///
        /// [API method documentation](https://api.slack.com/methods/usergroups.disable)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Include the number of users in the User Group.
            public var isIncludeCount: Bool?
            /// The encoded ID of the User Group to disable.
            public var usergroup: String?

            public init(isIncludeCount: Bool? = nil, usergroup: String? = nil) {
                self.isIncludeCount = isIncludeCount
                self.usergroup = usergroup
            }

            private enum CodingKeys: String, CodingKey {
                case isIncludeCount = "include_count"
                case usergroup
            }
        }
    }
}

extension Paths {
    public static var usergroupsEnable: UsergroupsEnable {
        UsergroupsEnable(path: "/usergroups.enable")
    }

    public struct UsergroupsEnable {
        /// Path: `/usergroups.enable`
        public let path: String

        /// Enable a User Group
        ///
        /// [API method documentation](https://api.slack.com/methods/usergroups.enable)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Include the number of users in the User Group.
            public var isIncludeCount: Bool?
            /// The encoded ID of the User Group to enable.
            public var usergroup: String?

            public init(isIncludeCount: Bool? = nil, usergroup: String? = nil) {
                self.isIncludeCount = isIncludeCount
                self.usergroup = usergroup
            }

            private enum CodingKeys: String, CodingKey {
                case isIncludeCount = "include_count"
                case usergroup
            }
        }
    }
}

extension Paths {
    public static var usergroupsList: UsergroupsList {
        UsergroupsList(path: "/usergroups.list")
    }

    public struct UsergroupsList {
        /// Path: `/usergroups.list`
        public let path: String

        /// List all User Groups for a team
        ///
        /// [API method documentation](https://api.slack.com/methods/usergroups.list)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var isIncludeUsers: Bool?
            public var token: String?
            public var isIncludeCount: Bool?
            public var isIncludeDisabled: Bool?

            public init(isIncludeUsers: Bool? = nil, token: String? = nil, isIncludeCount: Bool? = nil, isIncludeDisabled: Bool? = nil) {
                self.isIncludeUsers = isIncludeUsers
                self.token = token
                self.isIncludeCount = isIncludeCount
                self.isIncludeDisabled = isIncludeDisabled
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("include_users", isIncludeUsers?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("include_count", isIncludeCount?.asQueryValue)
                query.addQueryItem("include_disabled", isIncludeDisabled?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var usergroupsUpdate: UsergroupsUpdate {
        UsergroupsUpdate(path: "/usergroups.update")
    }

    public struct UsergroupsUpdate {
        /// Path: `/usergroups.update`
        public let path: String

        /// Update an existing User Group
        ///
        /// [API method documentation](https://api.slack.com/methods/usergroups.update)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// A mention handle. Must be unique among channels, users and User Groups.
            public var handle: String?
            /// A short description of the User Group.
            public var description: String?
            /// A comma separated string of encoded channel IDs for which the User Group uses as a default.
            public var channels: String?
            /// Include the number of users in the User Group.
            public var isIncludeCount: Bool?
            /// The encoded ID of the User Group to update.
            public var usergroup: String?
            /// A name for the User Group. Must be unique among User Groups.
            public var name: String?

            public init(handle: String? = nil, description: String? = nil, channels: String? = nil, isIncludeCount: Bool? = nil, usergroup: String? = nil, name: String? = nil) {
                self.handle = handle
                self.description = description
                self.channels = channels
                self.isIncludeCount = isIncludeCount
                self.usergroup = usergroup
                self.name = name
            }

            private enum CodingKeys: String, CodingKey {
                case handle
                case description
                case channels
                case isIncludeCount = "include_count"
                case usergroup
                case name
            }
        }
    }
}

extension Paths {
    public static var usergroupsUsersList: UsergroupsUsersList {
        UsergroupsUsersList(path: "/usergroups.users.list")
    }

    public struct UsergroupsUsersList {
        /// Path: `/usergroups.users.list`
        public let path: String

        /// List all users in a User Group
        ///
        /// [API method documentation](https://api.slack.com/methods/usergroups.users.list)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var token: String?
            public var isIncludeDisabled: Bool?
            public var usergroup: String?

            public init(token: String? = nil, isIncludeDisabled: Bool? = nil, usergroup: String? = nil) {
                self.token = token
                self.isIncludeDisabled = isIncludeDisabled
                self.usergroup = usergroup
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("include_disabled", isIncludeDisabled?.asQueryValue)
                query.addQueryItem("usergroup", usergroup?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var usergroupsUsersUpdate: UsergroupsUsersUpdate {
        UsergroupsUsersUpdate(path: "/usergroups.users.update")
    }

    public struct UsergroupsUsersUpdate {
        /// Path: `/usergroups.users.update`
        public let path: String

        /// Update the list of users for a User Group
        ///
        /// [API method documentation](https://api.slack.com/methods/usergroups.users.update)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Include the number of users in the User Group.
            public var isIncludeCount: Bool?
            /// A comma separated string of encoded user IDs that represent the entire list of users for the User Group.
            public var users: String?
            /// The encoded ID of the User Group to update.
            public var usergroup: String?

            public init(isIncludeCount: Bool? = nil, users: String? = nil, usergroup: String? = nil) {
                self.isIncludeCount = isIncludeCount
                self.users = users
                self.usergroup = usergroup
            }

            private enum CodingKeys: String, CodingKey {
                case isIncludeCount = "include_count"
                case users
                case usergroup
            }
        }
    }
}

extension Paths {
    public static var usersConversations: UsersConversations {
        UsersConversations(path: "/users.conversations")
    }

    public struct UsersConversations {
        /// Path: `/users.conversations`
        public let path: String

        /// List conversations the calling user may access.
        ///
        /// [API method documentation](https://api.slack.com/methods/users.conversations)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var cursor: String?
            public var token: String?
            public var limit: Int?
            public var user: String?
            public var excludeArchived: Bool?
            public var types: String?

            public init(cursor: String? = nil, token: String? = nil, limit: Int? = nil, user: String? = nil, excludeArchived: Bool? = nil, types: String? = nil) {
                self.cursor = cursor
                self.token = token
                self.limit = limit
                self.user = user
                self.excludeArchived = excludeArchived
                self.types = types
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("cursor", cursor?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("limit", limit?.asQueryValue)
                query.addQueryItem("user", user?.asQueryValue)
                query.addQueryItem("exclude_archived", excludeArchived?.asQueryValue)
                query.addQueryItem("types", types?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var usersDeletePhoto: UsersDeletePhoto {
        UsersDeletePhoto(path: "/users.deletePhoto")
    }

    public struct UsersDeletePhoto {
        /// Path: `/users.deletePhoto`
        public let path: String

        /// Delete the user profile photo
        ///
        /// [API method documentation](https://api.slack.com/methods/users.deletePhoto)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body?.asQuery())
        }

        public struct PostRequest: Encodable {
            /// Authentication token. Requires scope: `users.profile:write`
            public var token: String?

            public init(token: String? = nil) {
                self.token = token
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("token", token?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths {
    public static var usersGetPresence: UsersGetPresence {
        UsersGetPresence(path: "/users.getPresence")
    }

    public struct UsersGetPresence {
        /// Path: `/users.getPresence`
        public let path: String

        /// Gets user presence information.
        ///
        /// [API method documentation](https://api.slack.com/methods/users.getPresence)
        public func get(token: String? = nil, user: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: makeGetQuery(token, user))
        }

        private func makeGetQuery(_ token: String?, _ user: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("token", token?.asQueryValue)
            query.addQueryItem("user", user?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var usersIdentity: UsersIdentity {
        UsersIdentity(path: "/users.identity")
    }

    public struct UsersIdentity {
        /// Path: `/users.identity`
        public let path: String

        /// Get a user's identity.
        ///
        /// [API method documentation](https://api.slack.com/methods/users.identity)
        public func get(token: String? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(token))
        }

        private func makeGetQuery(_ token: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("token", token?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var usersInfo: UsersInfo {
        UsersInfo(path: "/users.info")
    }

    public struct UsersInfo {
        /// Path: `/users.info`
        public let path: String

        /// Gets information about a user.
        ///
        /// [API method documentation](https://api.slack.com/methods/users.info)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var isIncludeLocale: Bool?
            public var token: String?
            public var user: String?

            public init(isIncludeLocale: Bool? = nil, token: String? = nil, user: String? = nil) {
                self.isIncludeLocale = isIncludeLocale
                self.token = token
                self.user = user
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("include_locale", isIncludeLocale?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("user", user?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var usersList: UsersList {
        UsersList(path: "/users.list")
    }

    public struct UsersList {
        /// Path: `/users.list`
        public let path: String

        /// Lists all users in a Slack team.
        ///
        /// [API method documentation](https://api.slack.com/methods/users.list)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var isPresence: Bool?
            public var cursor: String?
            public var token: String?
            public var limit: Int?
            public var isIncludeLocale: Bool?

            public init(isPresence: Bool? = nil, cursor: String? = nil, token: String? = nil, limit: Int? = nil, isIncludeLocale: Bool? = nil) {
                self.isPresence = isPresence
                self.cursor = cursor
                self.token = token
                self.limit = limit
                self.isIncludeLocale = isIncludeLocale
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("presence", isPresence?.asQueryValue)
                query.addQueryItem("cursor", cursor?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("limit", limit?.asQueryValue)
                query.addQueryItem("include_locale", isIncludeLocale?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var usersLookupByEmail: UsersLookupByEmail {
        UsersLookupByEmail(path: "/users.lookupByEmail")
    }

    public struct UsersLookupByEmail {
        /// Path: `/users.lookupByEmail`
        public let path: String

        /// Find a user with an email address.
        ///
        /// [API method documentation](https://api.slack.com/methods/users.lookupByEmail)
        public func get(token: String? = nil, email: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: makeGetQuery(token, email))
        }

        private func makeGetQuery(_ token: String?, _ email: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("token", token?.asQueryValue)
            query.addQueryItem("email", email?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    public static var usersProfileGet: UsersProfileGet {
        UsersProfileGet(path: "/users.profile.get")
    }

    public struct UsersProfileGet {
        /// Path: `/users.profile.get`
        public let path: String

        /// Retrieves a user's profile information.
        ///
        /// [API method documentation](https://api.slack.com/methods/users.profile.get)
        public func get(parameters: GetParameters? = nil) -> Request<[String: [String: AnyJSON]]> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var token: String?
            public var isIncludeLabels: Bool?
            public var user: String?

            public init(token: String? = nil, isIncludeLabels: Bool? = nil, user: String? = nil) {
                self.token = token
                self.isIncludeLabels = isIncludeLabels
                self.user = user
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("include_labels", isIncludeLabels?.asQueryValue)
                query.addQueryItem("user", user?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths {
    public static var usersProfileSet: UsersProfileSet {
        UsersProfileSet(path: "/users.profile.set")
    }

    public struct UsersProfileSet {
        /// Path: `/users.profile.set`
        public let path: String

        /// Set the profile information for a user.
        ///
        /// [API method documentation](https://api.slack.com/methods/users.profile.set)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Collection of key:value pairs presented as a URL-encoded JSON hash.
            public var profile: String?
            /// ID of user to change. This argument may only be specified by team admins on paid teams.
            public var user: String?
            /// Value to set a single key to. Usable only if `profile` is not passed.
            public var value: String?
            /// Name of a single key to set. Usable only if `profile` is not passed.
            public var name: String?

            public init(profile: String? = nil, user: String? = nil, value: String? = nil, name: String? = nil) {
                self.profile = profile
                self.user = user
                self.value = value
                self.name = name
            }
        }
    }
}

extension Paths {
    public static var usersSetActive: UsersSetActive {
        UsersSetActive(path: "/users.setActive")
    }

    public struct UsersSetActive {
        /// Path: `/users.setActive`
        public let path: String

        /// Marked a user as active. Deprecated and non-functional.
        ///
        /// [API method documentation](https://api.slack.com/methods/users.setActive)
        public var post: Request<[String: [String: AnyJSON]]> {
            .post(path)
        }
    }
}

extension Paths {
    public static var usersSetPhoto: UsersSetPhoto {
        UsersSetPhoto(path: "/users.setPhoto")
    }

    public struct UsersSetPhoto {
        /// Path: `/users.setPhoto`
        public let path: String

        /// Set the user profile photo
        ///
        /// [API method documentation](https://api.slack.com/methods/users.setPhoto)
        public func post(_ body: PostRequest? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: body?.asQuery())
        }

        public struct PostRequest: Encodable {
            /// File contents via `multipart/form-data`.
            public var image: String?
            /// Width/height of crop box (always square)
            public var cropW: Int?
            /// Authentication token. Requires scope: `users.profile:write`
            public var token: String?
            /// Y coordinate of top-left corner of crop box
            public var cropY: Int?
            /// X coordinate of top-left corner of crop box
            public var cropX: Int?

            public init(image: String? = nil, cropW: Int? = nil, token: String? = nil, cropY: Int? = nil, cropX: Int? = nil) {
                self.image = image
                self.cropW = cropW
                self.token = token
                self.cropY = cropY
                self.cropX = cropX
            }

            public func asQuery() -> String {
                var query: [(String, String?)] = []
                query.addQueryItem("image", image?.asQueryValue)
                query.addQueryItem("crop_w", cropW?.asQueryValue)
                query.addQueryItem("token", token?.asQueryValue)
                query.addQueryItem("crop_y", cropY?.asQueryValue)
                query.addQueryItem("crop_x", cropX?.asQueryValue)
                return query.asPercentEncodedQuery
            }
        }
    }
}

extension Paths {
    public static var usersSetPresence: UsersSetPresence {
        UsersSetPresence(path: "/users.setPresence")
    }

    public struct UsersSetPresence {
        /// Path: `/users.setPresence`
        public let path: String

        /// Manually sets user presence.
        ///
        /// [API method documentation](https://api.slack.com/methods/users.setPresence)
        public func post(presence: String? = nil) -> Request<[String: [String: AnyJSON]]> {
            .post(path, body: ["presence": presence])
        }
    }
}

public enum Paths {}

extension Bool {
    var asQueryValue: String {
        self ? "true" : "false"
    }
}

extension Date {
    var asQueryValue: String {
        ISO8601DateFormatter().string(from: self)
    }
}

extension Double {
    var asQueryValue: String {
        String(self)
    }
}

extension Int {
    var asQueryValue: String {
        String(self)
    }
}

extension Int32 {
    var asQueryValue: String {
        String(self)
    }
}

extension Int64 {
    var asQueryValue: String {
        String(self)
    }
}

extension String {
    var asQueryValue: String {
        self
    }
}

extension URL {
    var asQueryValue: String {
        absoluteString
    }
}

extension RawRepresentable where RawValue == String {
    var asQueryValue: String {
        rawValue
    }
}

extension Array where Element == (String, String?) {
    mutating func addQueryItem(_ name: String, _ value: String?) {
        guard let value = value, !value.isEmpty else { return }
        append((name, value))
    }

    var asPercentEncodedQuery: String {
        var components = URLComponents()
        components.queryItems = self.map(URLQueryItem.init)
        return components.percentEncodedQuery ?? ""
    }
}
